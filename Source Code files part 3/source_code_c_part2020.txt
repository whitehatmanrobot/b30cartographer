ew Case(countryname + " - Console Trial (default renewal)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444"),				// Verify that we can't see any 4's voucher offers as renewals
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(                                           // Verify current sub is in expected renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepSetRenewal		(                                           // Set next renewal for a different offer...
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?            // & expect convert if currently in monthly
					Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					true : false),                                                      
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.Yearly4999    ),          // Everyone should be yearly at this point, because
					// yearly hasn't gotten to the end of their first 12 months yet
					new StepWaitForRoll		(roll10							),          // Time advance 12 months
					new StepVerify			(Global.OfferType.Monthly599    )           // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (non-default non-voucher renewal)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepSetRenewal		(
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,          // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Yearly4999 : Global.OfferType.Monthly599)          // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to LO)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to PP)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to 3M)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)           // Verify current sub is in expected renewal
					));
				
				if(fRunBetaPromoTest)
				{
#if !SKIP_BETA_PROMO_AND_TEST
					if(fStarterKitToAnnualAutoRenew)
					{

						caselist.Add(new Case(countryname + " - Beta1",
							new StepCreateAccount	("66666", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta1 offer
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

						caselist.Add(new Case(countryname + " - Beta2",
							new StepCreateAccount	("77777", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta2 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

						caselist.Add(new Case(countryname + " - Beta3",
							new StepCreateAccount	("88888", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta3 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

						caselist.Add(new Case(countryname + " - Beta4",
							new StepCreateAccount	("99999", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta4 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

						caselist.Add(new Case(countryname + " - Promo",
							new StepCreateAccount	("AAAAA", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the promo offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

						caselist.Add(new Case(countryname + " - Test",
							new StepCreateAccount	("BBBBB", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the test offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Yearly4999	)           // Verify current sub is the annual paid offer
							));

					}
					else // if (!fStarterKitToAnnualAutoRenew)
					{
						caselist.Add(new Case(countryname + " - Beta1",
							new StepCreateAccount	("66666", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta1 offer
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));

						caselist.Add(new Case(countryname + " - Beta2",
							new StepCreateAccount	("77777", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta2 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));

						caselist.Add(new Case(countryname + " - Beta3",
							new StepCreateAccount	("88888", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta3 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));

						caselist.Add(new Case(countryname + " - Beta4",
							new StepCreateAccount	("99999", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the beta4 offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));

						caselist.Add(new Case(countryname + " - Promo",
							new StepCreateAccount	("AAAAA", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the promo offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));

						Ccaselist.Add(new Case(countryname + " - Test",
							new StepCreateAccount	("BBBBB", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the test offer 
							new StepWaitForRoll		(roll0							),          // Time advance 2 months
							new StepWaitForRoll		(roll7							),          // Time advance 10 months
							new StepWaitForRoll		(roll10							),          // Time advance 12 months
							new StepVerify			(Global.OfferType.Monthly599	)           // Verify current sub is monthly paid offer
							));
					}
#endif
				}
			}

			// FROM SCRIPTCANCELCREDIT
			foreach(byte cc in Owner.Countries)
			{
				// Determine the country code and string for this test
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				if(fOneOnly && preferred != countrycode)
					continue;

				// Start the pre-paid subscription cancellation tests
				StepVerifyOpenBalance initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);

				caselist.Add(new Case(countryname + " - Cancel launch-offer sub",
					new StepCreateAccount		("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the starter kit
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of starter kit
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel pre-paid sub",
					new StepCreateAccount		("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 12 month pre-paid
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of 12 month pre-paid
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel three-month sub",
					new StepCreateAccount		("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 3 month pre-paid
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of 3 month pre-paid
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel game-trial sub",
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of game-trial
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel console-trial sub",
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepCreateAccount		("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month console-trial
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of console-trial
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				// Start the billed subscription cancellation tests
			
				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel monthly sub in 1st month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Monthly599	),			// Set the renewal to monthly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Monthly599	),          // Verify current sub is monthly
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in first month of monthly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel yearly sub in 1st month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Yearly4999	),			// Set the renewal to yearly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Yearly4999	),          // Verify current sub is yearly
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in first month of yearly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel monthly sub in 2nd month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Monthly599	),			// Set the renewal to monthly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Monthly599	),          // Verify current sub is monthly
					new StepWaitForRoll			(roll3							),          // Time advance 1 month
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in second month of monthly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel yearly sub in 2nd month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Yearly4999	),			// Set the renewal to yearly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Yearly4999	),          // Verify current sub is yearly
					new StepWaitForRoll			(roll3							),          // Time advance 1 month
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in second month of yearly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel monthly sub in 3rd month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Monthly599	),			// Set the renewal to monthly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Monthly599	),          // Verify current sub is monthly
					new StepWaitForRoll			(roll5							),          // Time advance 1 month
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in third month of monthly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel yearly sub in 3rd month",
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepSetRenewal			(Global.OfferType.Yearly4999	),			// Set the renewal to yearly
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepVerify				(Global.OfferType.Yearly4999	),          // Verify current sub is yearly
					new StepWaitForRoll			(roll5							),          // Time advance 1 month
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in third month of yearly
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					));		
			}
/*
			// FROM SCRIPTINTEGRATIONCASES
			foreach(byte cc in Owner.Countries)
			{
				// Determine the country code and string for this test
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				if(fOneOnly && preferred != countrycode)
					continue;

				// This case verifies the refund of a conversion from MB to PP within the first month
				caselist.Add(new Case(countryname + " - MB to PP .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to LO within the first month
				caselist.Add(new Case(countryname + " - MB to LO .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to 3M within the first month
				caselist.Add(new Case(countryname + " - MB to 3M .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to PP within the first month
				caselist.Add(new Case(countryname + " - YB to PP .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to LO within the first month
				caselist.Add(new Case(countryname + " - YB to LO .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to 3M within the first month
				caselist.Add(new Case(countryname + " - YB to 3M .5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll1							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to PP within the second month
				caselist.Add(new Case(countryname + " - MB to PP 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to LO within the second month
				caselist.Add(new Case(countryname + " - MB to LO 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to 3M within the second month
				caselist.Add(new Case(countryname + " - MB to 3M 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to PP within the second month
				caselist.Add(new Case(countryname + " - YB to PP 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to LO within the second month
				caselist.Add(new Case(countryname + " - YB to LO 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to 3M within the second month
				caselist.Add(new Case(countryname + " - YB to 3M 1.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll3							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to PP within the third month
				caselist.Add(new Case(countryname + " - MB to PP 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to LO within the third month
				caselist.Add(new Case(countryname + " - MB to LO 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));

				// This case verifies the refund of a conversion from MB to 3M within the third month
				caselist.Add(new Case(countryname + " - MB to 3M 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to PP within the third month
				caselist.Add(new Case(countryname + " - YB to PP 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.PrepaidCard	),
					new StepVerifyExpiryDate	(Global.OfferLength.PrepaidCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to LO within the third month
				caselist.Add(new Case(countryname + " - YB to LO 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.LaunchOffer	),
					new StepVerifyExpiryDate	(Global.OfferLength.LaunchOffer),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));

				// This case verifies the refund of a conversion from YB to 3M within the third month
				caselist.Add(new Case(countryname + " - YB to 3M 2.5 Months In", //true,
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
					new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
					new StepWaitForRoll		(roll0							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(roll5							),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
					new StepVerify			(Global.OfferType.ThreeMonthCard),
					new StepVerifyExpiryDate	(Global.OfferLength.ThreeMonthCard),
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true, 7)
					));
			}
*/			
			cases = (Case[]) caselist.ToArray(typeof(Case));
		}

		public ScriptRenewCancel()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\ScriptVerifySPSConn.cs ===
using System;
using System.Collections;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for ScriptVerifySPSConn.
	/// </summary>
	public class ScriptVerifySPSConn : Script
	{
		TimeRoll tr = new TimeRoll("Add violations",TimeRollType.no_roll,0);

		override public ArrayList GetRolls()
		{
			TimeRoll[] timeRolls = new TimeRoll[] {tr};
			ArrayList timeRollContainers = new ArrayList();
			timeRollContainers.Add(timeRolls);
			return timeRollContainers;
		}

		protected override void Initialize()
		{
			ArrayList al = new ArrayList();

			for(int i = 0; i < 1; ++i)
			{
				al.Add(new Case("StepGetOpenBalance",
					new StepCreateAccount   ("11111"						),
					new StepUpdatePaymentInstrument(						),
					new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
					new StepSettleBalance(),
					new StepWaitForRoll		(tr								)
					));
			}
			cases = (Case[]) al.ToArray(typeof(Case));
		}
		
		public ScriptVerifySPSConn()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\ScriptIntegrationCases.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for ScriptCodePaths.
	/// </summary>
	public class ScriptIntegrationCases:Script
	{

		TimeRoll roll0		= new TimeRoll("1st roll - 2 months",TimeRollType.month,2);
		TimeRoll roll1		= new TimeRoll("2nd roll - 15 days",TimeRollType.day,15);
		TimeRoll roll2		= new TimeRoll("3rd roll - 1 month",TimeRollType.month,1);
		TimeRoll roll3		= new TimeRoll("4th roll - 1 month",TimeRollType.month,1);
		TimeRoll roll4		= new TimeRoll("5th roll - 1 month",TimeRollType.month,1);
		TimeRoll roll5		= new TimeRoll("6th roll - 1 month",TimeRollType.month,1);

		override public ArrayList GetRolls()
		{
			TimeRoll[] timeRolls = new TimeRoll[] {roll0, roll1, roll2, roll3, roll4, roll5};
			ArrayList timeRollContainers = new ArrayList();
			timeRollContainers.Add(timeRolls);
			return timeRollContainers;
		}

		protected override void Initialize()
		{
			ArrayList caselist = new ArrayList();
			ArrayList defaultAutoRenewMonthlyCountries = new ArrayList();
			defaultAutoRenewMonthlyCountries.Add(Owner.Country.JP);

			string countryname;
			Owner.Country countrycode;
			bool fOnlyExpired = false;
			bool fNoExpired = false;
			bool fOneOnly = false;
			Owner.Country preferred = Owner.Country.US;

			foreach(byte cc in Owner.Countries)
			{
				// Yearly to others
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				if(fOneOnly && (preferred != countrycode))
					continue;

				// 1
				if(!fOnlyExpired)
				{
					// This case verifies the refund of a conversion from MB to PP within the third month
					caselist.Add(new Case("** " + countryname + " - MB to PP 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Monthly599	),
//						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
//						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to PP within the third month
					caselist.Add(new Case("** " + countryname + " - YB to PP 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from MB to LO within the third month
					caselist.Add(new Case("** " + countryname + " - MB to LO 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to LO within the third month
					caselist.Add(new Case("** " + countryname + " - YB to LO 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from MB to 3M within the third month
					caselist.Add(new Case("** " + countryname + " - MB to 3M 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to 3M within the third month
					caselist.Add(new Case("** " + countryname + " - YB to 3M 2.5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, true),
						//new StepWaitForRoll		(creditverify2					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the conversion from MB to PP at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - MB to PP 0 Months In", true, 
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the conversion from MB to LO at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - MB to LO 0 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the conversion from MB to 3M at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - MB to 3M 0 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the conversion from YB to PP at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - YB to PP 0 Months In", true, 
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the conversion from YB to LO at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - YB to LO 0 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the conversion from YB to 3M at the very beginning of the month while settling charges
					caselist.Add(new Case(countryname + " - YB to 3M 0 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies the refund of a conversion from MB to PP within the first month
					caselist.Add(new Case("* " + countryname + " - MB to PP .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from MB to LO within the first month
					caselist.Add(new Case("* " + countryname + " - MB to LO .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from MB to 3M within the first month
					caselist.Add(new Case("* " + countryname + " - MB to 3M .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to PP within the first month
					caselist.Add(new Case("* " + countryname + " - YB to PP .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to LO within the first month
					caselist.Add(new Case("* " + countryname + " - YB to LO .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the refund of a conversion from YB to 3M within the first month
					caselist.Add(new Case("* " + countryname + " - YB to 3M .5 Months In", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, false, false),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						//new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.Summary),
						new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.Summary, true, true),
						//new StepWaitForRoll		(creditverify					),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No)
						));

					// This case verifies the conversion from MB to PP at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - MB to PP NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard	)
						));

					// This case verifies the conversion from MB to LO at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - MB to LO NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer	)
						));

					// This case verifies the conversion from MB to 3M at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - MB to 3M NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard)
						));

					// This case verifies the conversion from YB to PP at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - YB to PP NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard	)
						));

					// This case verifies the conversion from YB to LO at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - YB to LO NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer	)
						));

					// This case verifies the conversion from YB to 3M at the very beginning of the month without settling charges
					caselist.Add(new Case(countryname + " - YB to 3M NotSettled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard	)
						));

					// This case tests that the grace period on the monthly offer is 30 days
					caselist.Add(new Case(countryname + " - MB Canceled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired),
						new StepWaitForRoll		(roll2							),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Canceled)
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.Monthly599	),
//						new StepVerifyAccountStatus(Global.AccountStatus.Canceled)
						));

					// This case tests that the grace period on the yearly offer is 60 days
					caselist.Add(new Case(countryname + " - YB Canceled", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired),
						new StepWaitForRoll		(roll3							),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Canceled)
						));

					// This case tests that the 12 month pre-paid offer is set to autorenew correctly
					caselist.Add(new Case(countryname + " - PP to autorenew", true,
						new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll3							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case tests that the starter kit offer is set to autorenew correctly
					caselist.Add(new Case(countryname + " - LO to autorenew", true,
						new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll3							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case tests that the three-month offer is set to autorenew correctly
					caselist.Add(new Case(countryname + " - 3M to autorenew", true,
						new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll3							),
						new StepVerify			(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case tests that the yearly offer can be set to renew into the billed offer other than it's autorenew offer
					caselist.Add(new Case(countryname + " - YB to non-autorenew", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll0							),
						new StepVerify			(Global.OfferType.Yearly4999,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599),
						new StepWaitForRoll		(roll3							),
						new StepVerify			(Global.OfferType.Yearly4999,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599),
						new StepWaitForRoll		(roll5							),
						new StepVerify			(Global.OfferType.Yearly4999,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599)
						));

//					// This test verifies that the game trial can renew into the 12 month pre-paid offer
//					caselist.Add(new Case(countryname + " - GT to PP Normal", true,
//						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));
//
//					// This test verifies that the game trial can renew into the 12 month pre-paid offer
//					caselist.Add(new Case(countryname + " - CT to PP Normal", true,
//						new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.PrepaidCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));
//
//					// This test verifies that the game trial can renew into the starter kit offer
//					caselist.Add(new Case(countryname + " - GT to LO Normal", true,
//						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));
//
//					// This test verifies that the game trial can renew into the starter kit offer
//					caselist.Add(new Case(countryname + " - CT to LO Normal", true,
//						new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.LaunchOffer,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));
//
//					// This test verifies that the game trial can renew into the 3 month pre-paid offer
//					caselist.Add(new Case(countryname + " - GT to 3M Normal", true,
//						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));
//
//					// This test verifies that the game trial can renew into the 3 month pre-paid offer
//					caselist.Add(new Case(countryname + " - CT to 3M Normal", true,
//						new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
//						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.No),
//						new StepWaitForRoll		(roll0							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll1							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll3							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
//						new StepWaitForRoll		(roll5							),
//						new StepVerify			(Global.OfferType.ThreeMonthCard,
//						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
//						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
//						));

					// This test verifies that the monthly offer can be converted into the 12 month pre-paid offer when suspended
					caselist.Add(new Case(countryname + " - MB to PP Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the monthly offer can be converted into the starter-kit offer when suspended
					caselist.Add(new Case(countryname + " - MB to LO Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the monthly offer can be converted into the 3 month pre-paid offer when suspended
					caselist.Add(new Case(countryname + " - MB to 3M Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the 12 month pre-paid offer when suspended
					caselist.Add(new Case(countryname + " - YB to PP Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the starter-kit offer when suspended
					caselist.Add(new Case(countryname + " - YB to LO Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the 3-month pre-paid offer when suspended
					caselist.Add(new Case(countryname + " - YB to 3M Suspended", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(5, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Suspended, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test validates that we have a 0 balance when we've converted while in declines
					// but before a violation was added
					caselist.Add(new Case(countryname + " - MB to PP Violations Convert with Zero Balance", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal      (Global.OfferType.Monthly599	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(3, false						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled, Global.ViolationStatus.No),
						new StepVerify			(Global.OfferType.PrepaidCard   ),
						new StepGetOpenBalance	(AccountStatementInfoSetLogDepth.LineItems)
						));
				}

				if(!fNoExpired)
				{

					// This test verifies that the monthly offer can be converted into the 12 month prepaid offer when expired
					caselist.Add(new Case(countryname + " - MB to PP Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//						new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the monthly offer can be converted into the starter-kit offer when expired
					caselist.Add(new Case(countryname + " - MB to LO Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//						new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the monthly offer can be converted into the 3 month prepaid offer when expired
					caselist.Add(new Case(countryname + " - MB to 3M Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//							new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//							new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the 12 month prepaid offer when expired
					caselist.Add(new Case(countryname + " - YB to PP Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//						new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.PrepaidCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.PrepaidCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the starter-kit offer when expired
					caselist.Add(new Case(countryname + " - YB to LO Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//						new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.LaunchOffer, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.LaunchOffer,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer can be converted into the 3 month prepaid offer when expired
					caselist.Add(new Case(countryname + " - YB to 3M Expired", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No	),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepStopPayment		(7, true						),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.Yes),
						new StepUpdatePaymentInstrument(true					),
						//							new StepVerifyAccountStatus(Global.AccountStatus.Expired, Global.ViolationStatus.No),
						//							new StepReinstateSubscription(true						),
						new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ThreeMonthCard, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Yearly4999 : Global.OfferType.Monthly599,						
						StepSetRenewal.ExpectConvert.No),
						new StepSetRenewal		(
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999,						
						StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.ThreeMonthCard,
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));
				}

				if(!fOnlyExpired)
				{
					// This test verifies that the monthly offer converts to yearly
					caselist.Add(new Case(countryname + " - MB to YB Normal", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.Yes),
						new StepVerify			(Global.OfferType.Yearly4999, 
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999, 
						defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This test verifies that the yearly offer doesn't convert to monthly (from the client)
					caselist.Add(new Case(countryname + " - YB to MB Normal", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Yearly4999, StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepVerify			(Global.OfferType.Yearly4999	),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No),
						new StepVerify			(Global.OfferType.Yearly4999, Global.OfferType.Monthly599),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Yearly4999, Global.OfferType.Monthly599)
						));

					// This test verifies that renewing to monthly from monthly fails
					caselist.Add(new Case(countryname + " - MB to MB Normal", true,
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.No),
						new StepWaitForRoll		(roll0							),
						new StepCloseBalance	(								),
						new StepSettleBalance	(								),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.Monthly599, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.Monthly599	),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepWaitForRoll		(roll1							),
						new StepVerify			(Global.OfferType.Monthly599	)
						));

					// TODO - add a case to make sure that CSR can convert yearly to monthly
				}
			}

			cases = (Case[]) caselist.ToArray(typeof(Case));
		}


		public ScriptIntegrationCases()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrix\Web References\com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace RenewalMatrix.com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02 {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    // CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
    public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public bdk() {
//            this.Url = "https://oban3/bdk2/bdk.WSDL";
            this.Url = "https://XONTEBILLSPS03/bdk2/bdk.WSDL";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.Invoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
            object[] results = this.Invoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.Invoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.Invoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.Invoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.Invoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID});
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.Invoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID});
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.Invoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID});
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TestConnection(string bstrInputString, out string pbstrOutputString) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        bstrInputString});
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        bstrInputString}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.Invoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.Invoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.Invoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale});
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
            object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.Invoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid});
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.Invoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId});
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML});
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
            this.Invoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendHCI(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.Invoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML});
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale});
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.Invoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.Invoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory});
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML});
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.Invoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription});
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, out string pbstrErrorXML) {
            object[] results = this.Invoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndActivateToken(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepCloseBalance.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepCloseBalance.
	/// </summary>
	[Serializable]
	public class StepCloseBalance : CaseStep
	{
		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			string PaymentInstrumentId;
			string ErrorXml;
			string AmountCharged;
			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);
			PaymentInstrumentId=ui.paymentInstrumentId;

			if (Parent.Xenoned)
			{
				PaymentInstrumentId = Parent.PaymentInstrumentId;
			}

			Log("StepCloseBalance: Running CloseBalance on " + PaymentInstrumentId);

			bdk.CloseBalance(1,
				1,
				Guid.NewGuid().ToString(), 
				PaymentInstrumentId, 
				"", 
				out ErrorXml, 
				out AmountCharged);

			XmlDocument doc=new XmlDocument();
			doc.LoadXml(ErrorXml);
			XmlElement root=doc.DocumentElement;
			XmlNode node=root.SelectSingleNode(@"ErrorHResult");

			// make sure we didn't get an error back
			if("0x0" != node.InnerText)
			{
				Log("CloseBalance returned unexpected error code: " + node.InnerText + " for PI: " + PaymentInstrumentId);
				return false;
			}

			Log("Closed balance on PI " + PaymentInstrumentId);

			Log("Waiting for any SCG processing");
			Thread.Sleep(20000);
			// TODO - verify the ready balance if one was specified
			return true;
		}


		public StepCloseBalance()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\ScriptVerifyThreading.cs ===
using System;
using System.Collections;
namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for ScriptVerifyThreading.
	/// </summary>
	public class ScriptVerifyThreading : Script
	{
		TimeRoll [] rolls = new TimeRoll[] {new TimeRoll("Roll 1",TimeRollType.no_roll,0), new TimeRoll("Roll 2",TimeRollType.no_roll,0), new TimeRoll("Roll 3",TimeRollType.no_roll,0), new TimeRoll("Roll 4",TimeRollType.no_roll,0), new TimeRoll("Roll 5",TimeRollType.no_roll,0), new TimeRoll("Roll 6",TimeRollType.no_roll,0), new TimeRoll("Roll 7",TimeRollType.no_roll,0), new TimeRoll("Roll 8",TimeRollType.no_roll,0), new TimeRoll("Roll 9",TimeRollType.no_roll,0), new TimeRoll("Roll 10",TimeRollType.no_roll,0)};

		override public ArrayList GetRolls()
		{
			ArrayList timeRollContainers = new ArrayList();
			timeRollContainers.Add(rolls);
			return timeRollContainers;
		}

		protected override void Initialize()
		{
			System.Random r = new Random();

			ArrayList c = new ArrayList();

			for(int i = 0; i < 1000; ++i)
			{
				ArrayList al = new ArrayList();
				al.Add(new StepRandomWait(r.Next(10000)));
				for(int j = 0; j < rolls.Length; ++j)
				{
					if(r.Next(100) < 95)
					{
						al.Add(new StepWaitForRoll(rolls[j]));
						al.Add(new StepRandomWait(r.Next(10000)));
					}
				}
				c.Add(new Case("Case " + i.ToString(), (CaseStep[]) al.ToArray(typeof(CaseStep))));
			}
			cases = (Case[]) c.ToArray(typeof(Case));
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepCreateAccount.cs ===
using System;
using System.Diagnostics;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.Billing;
using System.Threading;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepCreateAccount.
	/// </summary>
	[Serializable]
	public class StepCreateAccount : CaseStep
	{
		public void PrintDebug()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			xrlSE.TitleID = 0;
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					//Thread.Sleep(60000 + randomBackoff.Next(30000));
                    Thread.Sleep(10000);
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					//Thread.Sleep(60000 + randomBackoff.Next(30000));
                    Thread.Sleep(20000 + randomBackoff.Next(1));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("         Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);

		}



		public bool isXenon;
		public string Voucher;
		public ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode=ServerTestFramework.LiveService.UserAccount.XeUser.Country.US; 

		public override bool Execute()
		{
			UacsCommon UACS=new UacsCommon();
			ulong puid=0;
			// some puid
			if (!isXenon)
			{
				int maxRetry = 0;
				
				Owner o=UACS.GenerateOwner((Owner.Country)CountryCode);
				do
				{
                    try
                    {
                        o.email = CountryCode.ToString() + "_XboxRenewalTesting@xboxlive.com";
                        o.gamertag = "auto" + UACS.Random.GenerateRandomNameString(10);
                        o.firstName = o.gamertag;
                        o.lastName = Voucher.Substring(1, 5);
                        o.activationCode = Voucher;
                        o.cardExpiration = new DateTime(2066, 6, 6);
                        Parent.Log(Header + " creating " + CountryCode + " account " + o.gamertag);
                        puid = o.Create();
                        if (puid == 0)
                        {
                            string outputString;
                            outputString = o.GetType().Name;
                            outputString += " XErr:" + ServerTestFramework.Global.XErrToString(o.XErr) + "  HTTP:" + o.httpStatus;
                            Log(outputString);
                            maxRetry++;
                            continue;
                        }
                        if (UodbWS.IsUserQueued(puid))
                        {
                            Parent.Log(Header + " user is queued!");
                            System.Threading.Thread.Sleep(250);
                            puid = 0;
                            maxRetry++;
                            continue;
                        }
                    }
                    catch {
                        //retry if exception throw during user creation. 
                        maxRetry++;
                        Log("sleep 20 sec before recreate the user");
                        System.Threading.Thread.Sleep(20000);
                        continue;
                    }
				} while (puid==0 && maxRetry < 5);
				Parent.Puid=puid;
				Parent.GamerTag = o.gamertag;
				Parent.LanguageID = o.languageId;
				Parent.CountryID = (byte) CountryCode;
				Parent.OwnerForPassport = o;
				Parent.Log(Header+" created account "+o.gamertag+", puid "+Parent.Puid+ " in offer "+((ulong) Global.GetOfferFromVoucher(Voucher)).ToString("X8") +" using this voucher:" + Voucher);
                ulong passportPuid = UodbWS.GetUserPassportUserPuid(Parent.Puid);
                Parent.Log(DateTime.Now + " PassportIdH: " + (int)((passportPuid & 0xffffffff00000000) >> 32) + " PassportLow: " + (int)(passportPuid & 0xffffffff));
               
			}
			else
			{
				XeUser user = new XeUser(true, CountryCode);
				user.CreateAsGold = true;
				// TODO: Fixme, add a global method to do this
				if ((Voucher == "XeMonthlyCC") || 
					(Voucher == "XeYearlyCC") || 
                    (Voucher == "XeDiscountYearlyCC") ||
					(Voucher == "XeThreeMonthCC") ||
					(Voucher == "XeOneMonthTrial") ||
					(Voucher == "XeThirteenMonthPrepaid") ||                    
                    (Voucher == "XeTwelveMonthProm"))
				{
					user.PaymentInstrumentType = PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
					user.BillingToken = "";
					user.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
					user.CreditCardInfo.ExpirationDate = new DateTime(2020,12,1);
				} 
				else
				{
					user.PaymentInstrumentType = PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.None;
					user.BillingToken = Voucher;
					Parent.VouchersUsed[((long)Global.GetOfferFromVoucher(Voucher)).ToString() + "0"] = new Object();
				}
				int maxRetry = 0;
				do
				{
                    try
                    {
                        user.OfferId = (ulong)Global.GetOfferFromVoucher(Voucher);
                        user.Email = CountryCode.ToString() + "_XboxRenewalTesting@xboxlive.com";
                        user.Gamertag = "auto" + UACS.Random.GenerateRandomNameString(10);
                        user.FirstName = user.Gamertag;
                        user.PassportMemberName = "xblrenewtest-" + Guid.NewGuid().ToString() + "@xboxtest.com";
                        user.LastName = Voucher.Substring(0, 5);
                        user.CountryId = (byte)CountryCode;
                        Parent.Log(Header + " creating " + CountryCode + " account " + user.Gamertag + " with offer 0x" + user.OfferId.ToString("X") + " using this voucher:" + Voucher);
                        puid = user.Create();

                        Parent.Puid = user.UserPuid;
                        Parent.GamerTag = user.Gamertag;
                        Parent.XenonKey = new byte[user.m_response.XenonKey.Length];
                        Array.Copy(user.m_response.XenonKey, Parent.XenonKey, user.m_response.XenonKey.Length);
                        Parent.CountryID = (byte)CountryCode;
                        Parent.LanguageID = user.LanguageId;
                        if (puid == 0)
                        {
                            string outputString;
                            outputString = user.GetType().Name;
                            outputString += " XErr:" + ServerTestFramework.Global.XErrToString(user.XErr) + "  HTTP:" + user.xrl.httpStatus;
                            Log(outputString);
                            maxRetry++;
                            continue;
                        }
                        bool isUserQueued = UodbWS.IsUserQueued(user.UserPuid);
                        if (isUserQueued)
                        {
                            Parent.Log(Header + " user is queued!");
                            System.Threading.Thread.Sleep(250);
                            maxRetry++;
                            continue;
                        }
                        // If we are queued, we won't be able to get our PI anyway
                        Parent.PaymentInstrumentId = null;
                        PaymentInstrumentInfoEx[] piieArray = user.GetPaymentInstruments();
                        // Just grab the last one
                        foreach (PaymentInstrumentInfoEx piie in piieArray)
                        {
                            Parent.PaymentInstrumentId = piie.PaymentInstrumentId;
                        }
                    }
                    catch
                    {
                        //retry if exception throw during user creation. 
                        maxRetry++;
                        Log("sleep 20 sec before recreate the user");
                        System.Threading.Thread.Sleep(20000);
                        continue;
                    }
				}
				while (puid==0 && maxRetry < 5);
				Parent.OwnerForPassport = null;
				Parent.Xenoned = true;
				Parent.AddressInfo = user.AddressInfo;
				UodbWS.ExecuteNonQuery("delete from t_machine_trial_count where bi_machine_id = 0x" + user.MachinePuid.ToString("X"));
				Parent.Log("User Puid:" + user.UserPuid);
                ulong passportPuid = UodbWS.GetUserPassportUserPuid(user.UserPuid);
                Parent.Log(DateTime.Now + " PassportIdH: " + (int)((passportPuid & 0xffffffff00000000) >> 32) + " PassportLow: " + (int)(passportPuid & 0xffffffff));
              

				//PrintDebug();
			}
			return true;
		}

		public StepCreateAccount(string voucher):this(voucher, ServerTestFramework.LiveService.UserAccount.XeUser.Country.US, false)
		{
		}

		public StepCreateAccount(string voucher, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode):this(voucher, countryCode, false)
		{
		}

		public StepCreateAccount(string voucher, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode, bool isXenon)
		{
			//Ugh... Stupid asserts, will re-enable once code is implemented
			//Debug.Assert(voucher.Length==5);
			//Debug.Assert((voucher[0]>='0' && voucher[0]<='9') || (voucher[0]>='A' && voucher[0]<='C'));
			if (voucher.Length == 5)
				Voucher=voucher+voucher+voucher+voucher+voucher; // UGH!  Alright, who wrote this!?
			else
				Voucher = voucher;
			CountryCode=countryCode;
			this.isXenon=isXenon;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\ScriptXboxKorea.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for ScriptAllCasesKorea.
	/// </summary>
	public class ScriptXboxKorea : Script
	{
		TimeRoll roll0		= new TimeRoll("1st roll - 2 months",TimeRollType.month, 2);
		TimeRoll roll1		= new TimeRoll("2nd roll - 15 days",TimeRollType.day,15);
		TimeRoll roll2		= new TimeRoll("3rd roll - 0 days",TimeRollType.end_of_month,0);
		TimeRoll roll3		= new TimeRoll("4th roll - 15 days",TimeRollType.day,15);
		TimeRoll roll4		= new TimeRoll("5th roll - 0 days",TimeRollType.end_of_month,0);
		TimeRoll roll5		= new TimeRoll("6th roll - 15 days",TimeRollType.day,15);
		TimeRoll roll6		= new TimeRoll("7th roll - 0 days",TimeRollType.end_of_month,0);
		TimeRoll roll7		= new TimeRoll("8th roll - 7 months",TimeRollType.month,7);
		TimeRoll roll8		= new TimeRoll("9th roll - 15 days",TimeRollType.day,15);
		TimeRoll roll9		= new TimeRoll("10th roll - 0 days",TimeRollType.end_of_month,0);
		TimeRoll roll10		= new TimeRoll("11th roll - 11 months",TimeRollType.month,11);

		override public ArrayList GetRolls()
		{
			TimeRoll[] timeRolls = new TimeRoll[] {roll0,roll1,roll2,roll3,roll4,roll5,roll6,roll7,roll8,roll9,roll10};
			ArrayList timeRollContainers = new ArrayList();
			timeRollContainers.Add(timeRolls);
			return timeRollContainers;
		}

		protected override void Initialize()
		{
			ArrayList caselist = new ArrayList();

			string countryname;
			Owner.Country countrycode;

			// Debug variables for only running one test case
			bool fOneOnly = true;
			bool fNoExpired = false;
			Owner.Country preferred = Owner.Country.KR;


			// Build offering Array lists for eligible enumeration testing
			ArrayList defaultNonVoucherOffers = new ArrayList();
			defaultNonVoucherOffers.Add(Global.OfferType.Monthly599);
			defaultNonVoucherOffers.Add(Global.OfferType.Yearly4999);

			ArrayList defaultNonVoucherOffersFromMonthly = new ArrayList();
			defaultNonVoucherOffersFromMonthly.Add(Global.OfferType.Yearly4999);

			ArrayList defaultOnesVoucherOffers = new ArrayList();
			defaultOnesVoucherOffers.Add(Global.OfferType.LaunchOffer);

			ArrayList defaultTwosVoucherOffers = new ArrayList();
			defaultTwosVoucherOffers.Add(Global.OfferType.PrepaidCard);

			ArrayList defaultCsVoucherOffers = new ArrayList();
			defaultCsVoucherOffers.Add(Global.OfferType.ThreeMonthCard);
			
			ArrayList emptyOffersList = new ArrayList();

			// FROM SCRIPTALLCOUNTRIES
			foreach(byte cc in Owner.Countries)
			{
				// Determine the country code and string for this test
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				if(fOneOnly && preferred != countrycode)
					continue;

				caselist.Add(new Case(countryname + " - Launch Offer (No renewal)",
					new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.LaunchOffer,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444"),				// Verify that we can't see any 4's voucher offers as renewals
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer   ),          // Verify current sub is the starter kit offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			( Global.OfferType.LaunchOffer)
				));
				caselist.Add(new Case(countryname + " - Launch Offer (non-default non-voucher renewal)",
					new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.LaunchOffer,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(											// Change to non-default non-voucher renewal
					Global.OfferType.Monthly599,					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer   ),          // Verify current sub is the starter kit offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(											// Verify renewal to non-default non-voucher offer
					Global.OfferType.Monthly599)
					));

				caselist.Add(new Case(countryname + " - Launch Offer (renewal to LO)",
					new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.LaunchOffer,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer   ),          // Verify current sub is the starter kit offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.LaunchOffer   )           // Verify successful renewal to starter kit
					));

				caselist.Add(new Case(countryname + " - Launch Offer (renewal to PP)",
					new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.LaunchOffer,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo pre-paid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer   ),          // Verify current sub is the starter kit offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.PrepaidCard   )           // Verify successful renewal to 12 mo pre-paid
					));

				caselist.Add(new Case(countryname + " - Launch Offer (renewal to 3M)",
					new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.LaunchOffer,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 month
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer   ),          // Verify current sub is the starter kit offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)           // Verify successful renewal to 3 month
					));

				caselist.Add(new Case(countryname + " - Pre Paid (No renewal)",
					new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the annual prepaid offer
					new StepVerify			(Global.OfferType.PrepaidCard,              // Verify current sub and default renewal
					Global.OfferType.None),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444"),				// Verify that we can't see any 4's voucher offers as renewals
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard   ),          // Verify current sub is the annual prepaid offer
					new StepWaitForRoll		(roll7							)          // Time advance 10 months
					));

				caselist.Add(new Case(countryname + " - Pre Paid (non-default non-voucher renewal)",
					new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the 12 mo pre-paid offer
					new StepVerify			(Global.OfferType.PrepaidCard,              // Verify current sub and default renewal
												       Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.Monthly599,			// Change to non-default non-voucher renewal
																		false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard   ),          // Verify current sub is the 12 mo pre-paid offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.Monthly599			)			// Verify renewal to non-default non-voucher offer
					));

				caselist.Add(new Case(countryname + " - Pre Paid (renewal to LO)",
					new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.PrepaidCard,              // Verify current sub and default renewal
											Global.OfferType.None			),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard   ),          // Verify current sub is the 12 mo pre-paid offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.LaunchOffer   )           // Verify successful renewal to starter kit
					));

				caselist.Add(new Case(countryname + " - Pre Paid (renewal to PP)",
					new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.PrepaidCard,              // Verify current sub and default renewal
					Global.OfferType.None									),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo pre-paid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard   ),          // Verify current sub is the 12 mo pre-paid offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.PrepaidCard   )           // Verify successful renewal to 12 mo pre-paid
					));

				caselist.Add(new Case(countryname + " - Pre Paid (renewal to 3M)",
					new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the starter kit offer
					new StepVerify			(Global.OfferType.PrepaidCard,              // Verify current sub and default renewal
													   Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 month
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard   ),          // Verify current sub is the 12 mo pre-paid offer
					new StepWaitForRoll		(roll7							),          // Time advance 10 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)           // Verify successful renewal to 3 month
					));

				caselist.Add(new Case(countryname + " - Three Month (No renewal)",
					new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the three-month offer
					new StepVerify			(Global.OfferType.ThreeMonthCard,           // Verify current sub and default renewal
					Global.OfferType.None),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444"),				// Verify that we can't see any 4's voucher offers as renewals
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)          // Verify current sub is the three-month offerl
					));

//				caselist.Add(new Case(countryname + " - Three Month (non-default non-voucher renewal)",
//					new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the three-month offer
//					new StepVerify			(Global.OfferType.ThreeMonthCard,           // Verify current sub and default renewal
//					Global.OfferType.None),
//					new StepSetRenewal		(Global.OfferType.Monthly599,false),                                                      
//					new StepWaitForRoll		(roll0							),          // Time advance 2 months
//					new StepVerify			(Global.OfferType.ThreeMonthCard),          // Verify current sub is the three-month offer
//					new StepWaitForRoll		(roll2							),          // Time advance 1 month
//					new StepVerify			(
//					Global.OfferType.Monthly599)          // Verify renewal to non-default non-voucher offer
//					));

				caselist.Add(new Case(countryname + " - Three Month (renewal to LO)",
					new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the three-month offer
					new StepVerify			(Global.OfferType.ThreeMonthCard,           // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard),          // Verify current sub is the three-month offer
					new StepWaitForRoll		(roll2							),          // Time advance 1 month
					new StepVerify			(Global.OfferType.LaunchOffer   )           // Verify successful renewal to starter kit
					));

				caselist.Add(new Case(countryname + " - Three Month (renewal to PP)",
					new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the three-month offer
					new StepVerify			(Global.OfferType.ThreeMonthCard,           // Verify current sub and default renewal
														Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo pre-paid offer
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard),          // Verify current sub is the three-month offer
					new StepWaitForRoll		(roll2							),          // Time advance 1 month
					new StepVerify			(Global.OfferType.PrepaidCard   )           // Verify successful renewal to 12 mo pre-paid
					));

				caselist.Add(new Case(countryname + " - Three Month (renewal to 3M)",
					new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			), 			// Create the account in the three-month offer
					new StepVerify			(Global.OfferType.ThreeMonthCard,           // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 mo pre-paid offer
					false),
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard),          // Verify current sub is the three-month offer                                  
					new StepWaitForRoll		(roll2							),          // Time advance 1 month
					new StepVerify			(Global.OfferType.ThreeMonthCard)			// Verify successful renewal to 3 month
					));

				// In addition to testing the renewals from the game trial offer, this case will also verify
				// propper offer enumeration from monthly and yearly billed offers
				caselist.Add(new Case(countryname + " - Game Trial (No renewal)",
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the game trial offer
					new StepVerify			(Global.OfferType.GameTrial,                // Verify current sub and default renewal
														Global.OfferType.None),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444")				// Verify that we can't see any 4's voucher offers as renewals                                      
					));

//				caselist.Add(new Case(countryname + " - Game Trial (non-default non-voucher renewal)",
//					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the game trial offer
//					new StepVerify			(Global.OfferType.GameTrial,                // Verify current sub and default renewal
//					Global.OfferType.None),
//					new StepSetRenewal		(Global.OfferType.Monthly599, false),                                                      
//					new StepWaitForRoll		(roll0							),          // Time advance 2 months
//					new StepVerify			(
//					Global.OfferType.Monthly599)          // Verify current sub is in expected renewal
//					));

				caselist.Add(new Case(countryname + " - Game Trial (renewal to LO)",
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the game trial offer
					new StepVerify			(Global.OfferType.GameTrial,                // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Game Trial (renewal to PP)",
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the game trial offer
					new StepVerify			(Global.OfferType.GameTrial,                // Verify current sub and default renewal
					Global.OfferType.None									),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Game Trial (renewal to 3M)",
					new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the game trial offer
					new StepVerify			(Global.OfferType.GameTrial,                // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)           // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (No renewal)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					Global.OfferType.None),
					new StepVerifyEnumerate(defaultNonVoucherOffers			),			// Verify that we can see the non-voucher offers
					new StepVerifyEnumerate("1111111111111111111111111",				// Verify that we can see the 1's voucher offers as renewals
					defaultOnesVoucherOffers),
					new StepVerifyEnumerate("2222222222222222222222222",				// Verify that we can see the 2's voucher offers as renewals
					defaultTwosVoucherOffers),
					new StepVerifyEnumerate("CCCCCCCCCCCCCCCCCCCCCCCCC",				// Verify that we can see the C's voucher offers as renewals
					defaultCsVoucherOffers),
					new StepVerifyEnumerate("3333333333333333333333333"),				// Verify that we can't see any 3's voucher offers as renewals
					new StepVerifyEnumerate("4444444444444444444444444")				// Verify that we can't see any 4's voucher offers as renewals
					));

//				caselist.Add(new Case(countryname + " - Console Trial (non-default non-voucher renewal)",
//					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
//					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
//					Global.OfferType.None),
//					new StepSetRenewal		(Global.OfferType.Monthly599,          // Set the next renewal as the starter kit
//					false),                                                      
//					new StepWaitForRoll		(roll0							),          // Time advance 2 months
//					new StepVerify			(Global.OfferType.Monthly599)          // Verify current sub is in expected renewal
//					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to LO)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.LaunchOffer,              // Set the next renewal as the starter kit
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.LaunchOffer)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to PP)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.PrepaidCard,              // Set the next renewal as the 12 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.PrepaidCard)              // Verify current sub is in expected renewal
					));

				caselist.Add(new Case(countryname + " - Console Trial (renewal to 3M)",
					new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the console trial offer
					new StepVerify			(Global.OfferType.ConsoleTrial,             // Verify current sub and default renewal
					Global.OfferType.None),
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,           // Set the next renewal as the 3 mo prepaid
					false),                                                      
					new StepWaitForRoll		(roll0							),          // Time advance 2 months
					new StepVerify			(Global.OfferType.ThreeMonthCard)           // Verify current sub is in expected renewal
					));
				
			}

			// FROM SCRIPTINTEGRATIONCASES
			foreach(byte cc in Owner.Countries)
			{
				// Yearly to others
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				if(fOneOnly && (preferred != countrycode))
					continue;
				
				if(!fNoExpired)
				{
				

					// This case verifies that the starter kit offer can not be renewed into the game trial offer
					caselist.Add(new Case(countryname + " - LO to GT failure",
						new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.LaunchOffer,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.LaunchOffer	)
						//					new StepVerify			(Global.OfferType.LaunchOffer,     
						//					defaultAutoRenewMonthlyCountries.Contains((ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the starter kit offer can not be renewed into the console trial offer
					caselist.Add(new Case(countryname + " - LO to CT failure",
						new StepCreateAccount	("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.LaunchOffer,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.LaunchOffer	)
						//					new StepVerify			(Global.OfferType.LaunchOffer,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the 12 month prepaid offer can not be renewed into the game trial offer
					caselist.Add(new Case(countryname + " - PP to GT failure",
						new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.PrepaidCard,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.PrepaidCard	)
						//					new StepVerify			(Global.OfferType.PrepaidCard,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the 12 month prepaid offer can not be renewed into the console trial offer
					caselist.Add(new Case(countryname + " - PP to CT failure",
						new StepCreateAccount	("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.PrepaidCard,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.PrepaidCard	)
						//					new StepVerify			(Global.OfferType.PrepaidCard,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the 3 month prepaid offer can not be renewed into the game trial offer
					caselist.Add(new Case(countryname + " - 3M to GT failure",
						new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.ThreeMonthCard,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.ThreeMonthCard)
						//					new StepVerify			(Global.OfferType.ThreeMonthCard,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the 3 month prepaid offer can not be renewed into the console trial offer
					caselist.Add(new Case(countryname + " - 3M to CT failure",
						new StepCreateAccount	("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.ThreeMonthCard,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.ThreeMonthCard)
						//					new StepVerify			(Global.OfferType.ThreeMonthCard,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the game trial offer can not be renewed into the game trial offer
					caselist.Add(new Case(countryname + " - GT to GT failure",
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.GameTrial,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.GameTrial		)
						//					new StepVerify			(Global.OfferType.GameTrial,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the game trial offer can not be renewed into the console trial offer
					caselist.Add(new Case(countryname + " - GT to CT failure",
						new StepCreateAccount	("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.GameTrial,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.GameTrial		)
						//					new StepVerify			(Global.OfferType.GameTrial,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the console trial offer can not be renewed into the game trial offer
					caselist.Add(new Case(countryname + " - CT to GT failure",
						new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.ConsoleTrial,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.GameTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.ConsoleTrial	)
						//					new StepVerify			(Global.OfferType.ConsoleTrial,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

					// This case verifies that the console trial offer can not be renewed into the console trial offer
					caselist.Add(new Case(countryname + " - CT to CT failure",
						new StepCreateAccount	("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),
						new StepVerify			(Global.OfferType.ConsoleTrial,     
						Global.OfferType.None),
						new StepSetRenewal		(Global.OfferType.ConsoleTrial, StepSetRenewal.ExpectConvert.Failure),
						new StepVerify			(Global.OfferType.ConsoleTrial	)
						//					new StepVerify			(Global.OfferType.ConsoleTrial,     
						//					defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
						//					Global.OfferType.Monthly599 : Global.OfferType.Yearly4999)
						));

				}
			}

			// FROM SCRIPTCANCELCREDIT
			foreach(byte cc in Owner.Countries)
			{
				// Determine the country code and string for this test
				countrycode = (Owner.Country) cc;
				countryname = ((Owner.Country) countrycode).ToString();

				// TODO - Perform a lookup on the expected credit values to use for each test

				if(fOneOnly && preferred != countrycode)
					continue;

				// Start the pre-paid subscription cancellation tests
				StepVerifyOpenBalance initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);

				caselist.Add(new Case(countryname + " - Cancel launch-offer sub",
					new StepCreateAccount		("11111", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the starter kit
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of starter kit
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					//new StepGetOpenBalance		(AccountStatementInfoSetLogDepth.LineItems)			// Get current balance and display it
					// TODO - remove the StepGetOpenBalance and add a StepVerifyBalances for the specific ammounts
					));
				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel pre-paid sub",
					new StepCreateAccount		("22222", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 12 month pre-paid
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of 12 month pre-paid
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					//new StepGetOpenBalance		(AccountStatementInfoSetLogDepth.LineItems)			// Get current balance and display it
					// TODO - remove the StepGetOpenBalance and add a StepVerifyBalances for the specific ammounts
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel three-month sub",
					new StepCreateAccount		("CCCCC", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 3 month pre-paid
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of 3 month pre-paid
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					//new StepGetOpenBalance		(AccountStatementInfoSetLogDepth.LineItems)			// Get current balance and display it
					// TODO - remove the StepGetOpenBalance and add a StepVerifyBalances for the specific ammounts
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel game-trial sub",
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepCreateAccount		("33333", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month game-trial
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of game-trial
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					//new StepGetOpenBalance		(AccountStatementInfoSetLogDepth.LineItems)			// Get current balance and display it
					// TODO - remove the StepGetOpenBalance and add a StepVerifyBalances for the specific ammounts
					));

				initialStep = new StepVerifyOpenBalance (AccountStatementInfoSetLogDepth.LineItems, false, false);
				caselist.Add(new Case(countryname + " - Cancel console-trial sub",
					new StepWaitForRoll			(roll0							),			// Time advance 2 months
					new StepCreateAccount		("44444", (ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode			),			// Create the account in the 2 month console-trial
					new StepWaitForRoll			(roll1							),          // Time advance 15 days
					//new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, false, false, 0),
					initialStep,
					new StepCancelSubscription	(								),          // Cancel sub in middle of console-trial
					new StepVerifyOpenBalance   (AccountStatementInfoSetLogDepth.LineItems, true, false, ref initialStep)
					//new StepGetOpenBalance		(AccountStatementInfoSetLogDepth.LineItems)			// Get current balance and display it
					// TODO - remove the StepGetOpenBalance and add a StepVerifyBalances for the specific ammounts
					));

				// Start the billed subscription cancellation tests
			
				
			}

	
			cases = (Case[]) caselist.ToArray(typeof(Case));
		}

		public ScriptXboxKorea()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepCancelSubscription.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Threading;
using System.Xml;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepCancelSubscription.
	/// </summary>
	[Serializable]
	public class StepCancelSubscription : CaseStep
	{

		bool VerifyUODBStateChange = false;
		//So that we can maintain compatibility with Live subscription tests
		Global.OfferType OfferToCancel = Global.OfferType.None;

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			UserSubInfo [] subs;
			UserSubInfo cursub;
			string ErrorXml;
			string AmountCharged;
			string SubStatusInfo;
			int RemovedServiceInstanceCount;
			string RemovedServiceInstanceSetXML;
			string subscriptionID = null;

			GetSubscriptionStatus substat = new GetSubscriptionStatus(new LogDelegate(Log));
			GetSubscriptionStatus.Status acctstatusold = new GetSubscriptionStatus.Status();
			// This is done specifically in this order to do the function call first so that we know uodb is up to date
			// for the call to getusersubs
			if(!substat.GetStatus(Parent.Puid, out acctstatusold) && VerifyUODBStateChange)
			{
				Log("Failed to retrieve the current account status!");
				return false;
			}

			UodbWS.GetUserSubs(Parent.Puid, out subs, out cursub);
			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);
			
			//Make sure that offer is specified so that the correct subscription is cancelled
			//Scenario: when user has both premium subscription and Live subscription
			if (OfferToCancel != Global.OfferType.None)
			{
				foreach (UserSubInfo usi in subs)
				{
					if(usi.offerId == (ulong) OfferToCancel)
					{
						subscriptionID = String.Copy(usi.serviceInstanceId);
                        subscriptionID = subscriptionID.Remove(11, 1);
                        subscriptionID = subscriptionID.Insert(11, "A");
						substat.bSpecificSUB = true;
						substat.SubscriptionID = String.Copy(usi.serviceInstanceId);
					}
				}
			}
				// We now have to hack the service instance ID to be the default subscription ID
				// This winds up just being the service instance ID with the 12th character switched from B to A
			else
			{
				subscriptionID = String.Copy(cursub.serviceInstanceId);
				subscriptionID = subscriptionID.Remove(11, 1);
				subscriptionID = subscriptionID.Insert(11, "A");
			}
			Log("StepCancelSubscription: Running CancelSubscription on " + subscriptionID);

			bdk.CancelSubscription(1,
				1,
				1,
				1,
				Guid.NewGuid().ToString(),
				false,
				subscriptionID,
                "",
                "<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\"><CommentCode>1234</CommentCode><CommentText>Cancel request received through RenewalMatrix Test</CommentText></CommentInfo>", 
				out ErrorXml, 
				out AmountCharged,
				out SubStatusInfo,
				out RemovedServiceInstanceCount, // TODO - make sure this is actually the subscription we want
				out RemovedServiceInstanceSetXML);

			XmlDocument doc=new XmlDocument();
			doc.LoadXml(ErrorXml);
			XmlElement root=doc.DocumentElement;
			XmlNode node=root.SelectSingleNode(@"ErrorHResult");

			// make sure we didn't get an error back
			if("0x0" != node.InnerText)
			{
				Log("CancelSubscription returned unexpected error code: " + node.InnerText + " for sub: " + subscriptionID);
				return false;
			}

			if(1 != RemovedServiceInstanceCount)
			{
				Log("CancelSubscription didn't actually cancel: " + subscriptionID);
				return false;
			}

			Log("Waiting for SCG response (30 sec)");
			Thread.Sleep(30000);

			if(!VerifyUODBStateChange)
			{
				Log("Cancelled subscription on sub " + subscriptionID);
				return true;
			}

			GetSubscriptionStatus.Status newstatus;
			if(!substat.GetStatus(Parent.Puid, true, out newstatus, Parent.Xenoned, Parent.Xenoned))
			{
				Log("Failed to retrieve the updated account status!");
				return false;
			}

			if(newstatus.AccountStatus == acctstatusold.AccountStatus)
			{
				Log("No change from state " + acctstatusold.AccountStatus.ToString());
				return false;
			}

			Log("Cancelled subscription on sub " + subscriptionID);
			return true;
		}

		public StepCancelSubscription(bool VerifyStateChange, Global.OfferType offer)
		{
			VerifyUODBStateChange = VerifyStateChange;
			OfferToCancel = offer; // Using the offer we can obtain the subscription id for the user
								   // Mainly used for non-Live memberships- eg. Game Subscriptions
		}
		public StepCancelSubscription(bool VerifyStateChange)
		{
			//By default we cancel the live membership (Gold) for the user
			VerifyUODBStateChange = VerifyStateChange;
			//
			// TODO: Add constructor logic here
			//
		}
		public StepCancelSubscription()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepGetOpenBalance.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Xml;
using System.Collections;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepGetBalance.
	/// </summary>
	/// 
	
	enum Balance
	{
		AccountActivitySet = 0x10000001
	};

	[Serializable]
	public class StepGetOpenBalance : CaseStep
	{
		AccountStatementInfoSetLogDepth logging = AccountStatementInfoSetLogDepth.None;

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			string ErrorXml;
			string AccountStatementInfoSetXml;
			string UserNotificationSetXml;

			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);

			string acctid = ui.billingAccountId;

			bdk.GetStatement(1, 1, 1, 1, acctid, 0, 0, 2, false, out ErrorXml, out AccountStatementInfoSetXml, out UserNotificationSetXml);
			
			AccountStatementInfoSet asis = new AccountStatementInfoSet();

			if(asis.Parse(AccountStatementInfoSetXml))
			{
				Parent.State[Balance.AccountActivitySet] = asis;
			}

			if(logging != AccountStatementInfoSetLogDepth.None)
				asis.Log(new LogDelegate(Log), logging);

			return true;
		}

		public StepGetOpenBalance(AccountStatementInfoSetLogDepth LogResults)
		{
			logging = LogResults;
		}

		public StepGetOpenBalance()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepRandomWait.cs ===
using System;
using System.Threading;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepRandomWait.
	/// </summary>
	[Serializable]
	public class StepRandomWait : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public int WaitMilliseconds;
		public StepRandomWait(int MaxWaitMilliseconds)
		{
			//
			// TODO: Add constructor logic here
			//
			WaitMilliseconds = MaxWaitMilliseconds;
		}

		public override bool Execute()
		{
            Thread.Sleep(WaitMilliseconds);
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepSetRenewal.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using System.Threading;

namespace RenewalMatrix
{
    /// <summary>
    /// Summary description for StepSetRenewal.
    /// </summary>
    [Serializable]
    public class StepSetRenewal : CaseStep
    {
        public void PrintDebug()
        {
            bool b = false;         // stores result of request call
            uint retryCount = 0;    // allows us to retry several times when a request fails
            uint maxRetries = 3;    // defines how many failures we'll tolerate before giving up
            ulong currentOffer = 0;
            System.Random randomBackoff = new Random();
            XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
            XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

            xrlSE.UserPuid = Parent.Puid;
            xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
            xrlSE.CountryID = Parent.CountryID;
            xrlSE.LanguageID = Parent.LanguageID;
            xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
                (uint)PaymentTypeEnum.CreditCard |
                (uint)PaymentTypeEnum.Token;
            //xrlSE.GameRating = 0xFFFF;
            xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
                (uint) OfferingTypeEnum.Renewal;
            xrlSE.TitleID = this.TitleID;
            xrlSE.TitleCategories = 0xFFFFFFFF;
            xrlSE.QueryForNew = false;
            xrlSE.QueryForRenewals = false;
            xrlSE.QueryForCurrent = true;
            xrlSE.GameRating = 2;

            do
            {
                if(retryCount > 0)
                {
                    // Backoff on failures
                    Log("Retry #" + retryCount + " of " + maxRetries);
                    Log("Backing off for random 60-90 second interval");
                    Thread.Sleep(60000 + randomBackoff.Next(30000));
                }
                b = xrlSE.Execute(out xrlSER);
                if (!b)
                {
                    string outputString;
                    outputString=xrlSE.GetType().Name;
                    outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
                    Log(outputString);
                    retryCount++;
                }
            }
            while(!b && retryCount <= maxRetries);

            if (!b)
            {
                Log("Enumerating subscriptions failed");
                return;
            }

            int counter = 0;
            foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
            {
                    
                Log(" --- Offer Enumeration --- ");
                Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
                Log("Offer Name         :" + bsi.OfferName);
                Log("Offer Type         :" + bsi.OfferType); 
                Log("Convert Mode       :" + bsi.ConvertMode);
                Log("Frequency          :" + bsi.Frequency);
                Log("Duration           :" + bsi.Duration);
                Log("Is User Subscribed :" + bsi.userIsSubscribed);
                if (bsi.userIsSubscribed)
                {
                    counter++;
                    currentOffer = bsi.OfferID;
                }
                Log("-- Prices --");
                foreach (OfferPrice op in bsi.Prices)
                    Log(" -- Price  :" + op.PriceText);                 
                Log(" ------------------------- ");
            }

            if (counter == 0)
            {
                Log("No subscription found");
                return;
            }

            retryCount = 0;

            XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
            XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

            xrlGUSD.OfferId = (ulong) currentOffer;
            xrlGUSD.UserPuid = Parent.Puid;

            //Call XRLXeGetUserSubscriptionDetails


            // try up to 5 times when request fails due to timeout, etc.
            do
            {
                if(retryCount > 0)
                {
                    // Backoff on failures
                    Log("Retry #" + retryCount + " of " + maxRetries);
                    Log("Backing off for 30 second interval");
                    //Thread.Sleep(60000 + randomBackoff.Next(30000));
                    Thread.Sleep(30000);
                }

                b = xrlGUSD.Execute(out xrlGUSDR);

                if (!b)
                {
                    string outputString;
                    outputString=xrlGUSD.GetType().Name;
                    outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
                    Log(outputString);
                    retryCount++;
                }
            }
            while(!b && retryCount <= maxRetries);

            //xrlGUSDR.
            // if we've reached the maximum number of retries and still no success, return failure
            if(!b)
                return;

            Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
            Log("         Description : "+xrlGUSDR.Description);
            Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
            Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
            Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
            Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
            Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
            Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
            Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
            Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
            Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);

        }



        public enum ExpectConvert {Yes, No, DontCare, Failure};
        // NOTE: should be made private once I verify with SOAP serialization that everything works.
        public ExpectConvert    expectConvert;
        public Global.OfferType Offer;
        public uint TitleID;
        public bool setCountryThroughParent = false;
        public ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode;
        public override bool Execute()
        {
            if (setCountryThroughParent)
                this.countryCode = (ServerTestFramework.LiveService.UserAccount.XeUser.Country) Parent.CountryID;

                // Gather data prior to the renewal so that we know if the renewal was 
                // a convert or a renew
            XRLGetSubscriptionStatusDetails []details;
            XRLGetSubscriptionStatusResponse response;
            XRLGetSubscriptionStatusResponse responseNew;
            XRLGetSubscriptionStatus gss=new XRLGetSubscriptionStatus();
            gss.userPuid=Parent.Puid;
            gss.Execute(out response, out details);

        
            XRLRenewSubscription renew=new XRLRenewSubscription();
            ServerTestFramework.LiveService.Billing.XRLXeOfferPurchase xeRenew = new ServerTestFramework.LiveService.Billing.XRLXeOfferPurchase();
            xeRenew.SchemaVersion = WireData.MakeSchemaVersion(1,0);
            
            if (Parent.Xenoned)
            {
                Parent.Log(Header+" setting renewal to "+ Offer +"(0x"+((uint)Offer).ToString("X8")+"), expecting a "+GetExpectingString());
                //renew.titleId = 0xFFFE07D1;
                //renew.Slot.SetClientType(ServerTestFramework.LiveService.FakeSG.CSGInfo.ClientType.Xenon);
                xeRenew.OfferID = (ulong) Offer;
                xeRenew.UserPuid = Parent.Puid;
                xeRenew.BillingToken = Global.GetVoucherFromOffer(Offer);
                xeRenew.PaymentType = (uint) ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token;
                xeRenew.CountryID = (byte) countryCode;
                xeRenew.Tier = (byte)UodbWS.GetUserTier(Parent.Puid); 
            }
            else
            {
                Parent.Log(Header+" setting renewal to "+ Offer +"(0x"+((uint)Offer).ToString("X8")+"), expecting a "+GetExpectingString() + " and we are using this voucher:" + Global.GetVoucherFromOffer(Offer));
                renew.userPUID=Parent.Puid;
                renew.offerId=(ulong) Offer;
                renew.voucher=Global.GetVoucherFromOffer(Offer);
            }

            if (Parent.Xenoned && Global.IsCreditCardOffer(Offer))
            {
                xeRenew.PaymentType = (uint) ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard;
                xeRenew.BillingToken = "";
                
                XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
                XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
                xrlXGPI.MaxResults = 1;
                xrlXGPI.UserPuid = Parent.Puid;
                
                if (!xrlXGPI.Execute(out xrlXGPIR))
                {
                    Parent.Log("Failed getting a payment instrument");
                }
                Parent.Log("Next step");
                if(xrlXGPIR.PaymentInstrumentCount == 0)
                {
                    Parent.Log("Payment instrument needed, creating a new one");
                    XRLXeAddPaymentInstrument xrlXAPI = new XRLXeAddPaymentInstrument();
                    XRLXeAddPaymentInstrumentResponse xrlXAPIR = new XRLXeAddPaymentInstrumentResponse();
                    Log("Adding payment instrument with PUID:" + Parent.Puid);
                    xrlXAPI.UserPuid = Parent.Puid;
                    xrlXAPI.AddressInfo = Parent.AddressInfo;
                    xrlXAPI.PaymentInstrumentType = (byte) PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
                    xrlXAPI.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
                    xrlXAPI.CreditCardInfo.ExpirationDate = new DateTime(2020,12,1);
                    if (!xrlXAPI.Execute(out xrlXAPIR))
                    {
                        Parent.Log("Failed adding a payment instrument:"+xrlXAPI.XErr);
                    }
                    else
                    {
                        Parent.Log("Succeeded adding payment instrument");
                    }
                    if (xrlXAPIR == null)
                    {
                        Parent.Log("Function succeeded, but response was null, attempting to query it");
                        if (!xrlXGPI.Execute(out xrlXGPIR))
                        {
                            Parent.Log("Failed getting a payment instrument after setting one, aborting");
                            return false;
                        }
                        else
                        {
                            if (xrlXGPIR.PaymentInstrumentCount != 0)
                            {
                                xeRenew.PaymentInstrumentID = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
                                Parent.PaymentInstrumentId = xeRenew.PaymentInstrumentID;
                            }
                            else
                            {
                                Parent.Log("Query succeeded, but no payment instrument found after adding one, aborting");
                                return false;
                            }
                        }
                    }
                    else
                    {
                        xeRenew.PaymentInstrumentID = xrlXAPIR.PaymentInstrumentId;
                        Parent.PaymentInstrumentId = xeRenew.PaymentInstrumentID;
                    }                   
                }
                else
                {
                    Parent.Log("No new payment instrument needed");
                    xeRenew.PaymentInstrumentID = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
                    Parent.PaymentInstrumentId = xeRenew.PaymentInstrumentID;
                }
            }

            int attempt=5;
            bool b;
            do
            {
                if (!Parent.Xenoned)
                {
                    // Try a couple of times before giving up. UACS could just be having a bad day
                    b=renew.Execute();
                    if (!b)
                    {
                        Log("Renew Failed, retrying");
                    }
                }
                else
                {
                    int i = 0;
                    while (Parent.VouchersUsed[((long)Offer).ToString() + (Parent.VoucherNumber % 4).ToString()] != null)
                    {
                        Parent.VoucherNumber++;
                        if (i++ > 4)
                        {
                            break;
                        }
                    }
                    xeRenew.BillingToken = Global.GetSecondaryVoucher(Offer, Parent.VoucherNumber);
                    if (xeRenew.BillingToken != "")
                        Parent.VouchersUsed[((long)Offer).ToString() + (Parent.VoucherNumber % 4).ToString()] = new Object();
                    PrintDebug();
                    Log("Executing Renew, attempt "+attempt+", using payment method " + xeRenew.PaymentType + " and this token:"+xeRenew.BillingToken);
                    xeRenew.Slot.userFlag0 = (uint)((byte)countryCode << 8);
                    b = xeRenew.Execute();
                    if (!b)
                    {
                        Log("Renew Failed, retrying");
                        Log("Renew failed with XErr:"+ServerTestFramework.Global.XErrToString(xeRenew.XErr)+"  HTTP:"+xeRenew.httpStatus);
                    }
                    PrintDebug();
                }
            } while(--attempt!=0 && b==false);
            Log("Finished Renew");
        
            // If I fail and I'm not expecting a failure then dump, if I succeed and I'm expecting a failure then dump.
            if (expectConvert==ExpectConvert.Failure)
            {
                if (b)
                {
                    gss.Execute(out responseNew, out details);

                    Log("We expected a failure, but set renewal passed!");
                    Log("Old offer: " + response.currentOfferId.ToString("X8"));
                    Log("Requested offer: " + Offer.ToString() + " (" + ((ulong)Offer).ToString("X8") + ")");
                    Log("New offer: " + responseNew.currentOfferId.ToString("X8"));

                    return false;
                }
                return true;
            }
            if(!b && expectConvert != ExpectConvert.Failure)
            {
                if (!Parent.Xenoned)
                    Log("Renew failed with XErr:"+ServerTestFramework.Global.XErrToString(renew.XErr)+"  HTTP:"+renew.httpStatus);
                else
                    Log("Renew failed with XErr:"+ServerTestFramework.Global.XErrToString(xeRenew.XErr)+"  HTTP:"+xeRenew.httpStatus);
                return false;
            }

            if (expectConvert != ExpectConvert.DontCare)
            {
                gss.Execute(out responseNew, out details);
            
                Log("Old start date = " + response.startDate.ToShortDateString() + " (" + response.startDate.ToShortTimeString() + ")");
                Log("Old end date = " + response.endDate.ToShortDateString() + " (" + response.endDate.ToShortTimeString() + ")");
                Log("Old offer id = " + response.currentOfferId.ToString("X8"));

                Log("New start date = " + responseNew.startDate.ToShortDateString() + " (" + responseNew.startDate.ToShortTimeString() + ")");
                Log("New end date = " + responseNew.endDate.ToShortDateString() + " ("  + responseNew.endDate.ToShortTimeString() + ")");
                Log("New offer id = " + responseNew.currentOfferId.ToString("X8"));

                if (response.startDate==responseNew.startDate &&
                    response.endDate==responseNew.endDate &&
                    response.currentOfferId==responseNew.currentOfferId)
                {
                    // this was a renew
                    if (expectConvert==ExpectConvert.Yes)
                    {
                        Log("Renew passed, but we expected a CONVERT and we got a RENEW");
                        Log("Old offer: " + response.currentOfferId.ToString("X8"));
                        Log("Requested offer: " + Offer.ToString() + " (0x" + ((ulong)Offer).ToString("X8") + ")");
                        Log("New offer: " + responseNew.currentOfferId.ToString("X8"));
                
                        return false;
                    }
                }
                else            
                {
                    // this was a convert
                    if (responseNew.currentOfferId!=(ulong) Offer)
                    {
                        //This should never happen
                        Log("WARNING: We detected a convert (or so we thought), but the currentOfferId does not match... hmmm");
                        Log("Old offer: " + response.currentOfferId.ToString("X8"));
                        Log("Requested offer: " + Offer.ToString() + " (0x" + ((ulong)Offer).ToString("X8") + ")");
                        Log("New offer: " + responseNew.currentOfferId.ToString("X8"));
                    }

                    if (expectConvert==ExpectConvert.No)
                    {
                        Log("Renew passed, but we expected a RENEW and we got a CONVERT");
                        Log("Old offer: " + response.currentOfferId.ToString("X8"));
                        Log("Requested offer: " + Offer.ToString() + " (0x" + ((ulong)Offer).ToString("X8") + ")");
                        Log("New offer: " + responseNew.currentOfferId.ToString("X8"));

                        return false;
                    }
                }
            }

            return true;
        }

        string GetExpectingString()
        {
            switch (expectConvert)
            {
                case ExpectConvert.DontCare:
                    return "pass (don't care which)";
                case ExpectConvert.Failure:
                    return "failure";
                case ExpectConvert.No:
                    return "renewal";
                case ExpectConvert.Yes:
                    return "convert";
                default:
                    return "unknown";
            }
        }
 
        public StepSetRenewal(Global.OfferType offer ):this(offer, ExpectConvert.DontCare)
        {}

        public StepSetRenewal(Global.OfferType offer, bool expectConvert ):this(offer)
        {
            if (expectConvert)
                this.expectConvert=ExpectConvert.Yes;
            else
                this.expectConvert=ExpectConvert.No;
        }

        public StepSetRenewal(Global.OfferType offer, ExpectConvert expectConvert ):this(offer, expectConvert, ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
        {
            // Fixme: WHich constructor executes first?
            this.countryCode = ServerTestFramework.LiveService.UserAccount.XeUser.Country.US;
            setCountryThroughParent = true;
        }

        public StepSetRenewal(Global.OfferType offer, ExpectConvert expectConvert, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
            : this(offer, expectConvert, countryCode, 0)
        {

        }

        public StepSetRenewal(Global.OfferType offer, ExpectConvert expectConvert, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode, uint titleid)
        {
            this.expectConvert=expectConvert;
            this.countryCode=countryCode;
            Offer=offer;
            TitleID = titleid;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepUpdatePaymentInstrument.cs ===
using System;
using ServerTestFramework;
using System.Threading;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepUpdatePaymentInstrument.
	/// </summary>
	[Serializable]
	public class StepUpdatePaymentInstrument : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		bool WaitForChange = false;

		// TODO: Add Xe Version
		public override bool Execute()
		{
			if (!Parent.Xenoned)
			{
				XRLGetPaymentInfo gpi = new XRLGetPaymentInfo();
				XRLGetPaymentInfoResponse gpir;
				gpi.userPuid = Parent.Puid;

				UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);

				GetSubscriptionStatus substat = new GetSubscriptionStatus(new LogDelegate(Log));
				GetSubscriptionStatus.Status acctstatusold = new GetSubscriptionStatus.Status();

				Log("StepUpdatePaymentInstrument: Running Update for payment instrument " + ui.paymentInstrumentId);

				if(WaitForChange && !substat.GetStatus(Parent.Puid, out acctstatusold))
				{
					Log("Failed to retrieve the current account status!");
					return false;
				}

				if(!gpi.Execute(out gpir))
				{
					Log("Failed to retrieve the payment instrument information for this user.");
					return false;
				}

				XRLSetPaymentInfo spi = new XRLSetPaymentInfo();
				spi.GetFrom(Parent.Puid, gpir);
				// Update the expiry date on the credit card to one month forward.
				spi.cardExpiration = spi.cardExpiration.AddYears(1);
				if(!spi.Execute())
				{
					Log("Failed to update the payment instrument information for this user.");
					string outputString;
					outputString=spi.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(spi.XErr)+"  HTTP:"+spi.httpStatus;
					Log(outputString);
					return false;
				}
				if(!WaitForChange)
					return true;

				long curtime = DateTime.Now.Ticks;

				// Wait for up to two minutes to to ensure the value changes.
				GetSubscriptionStatus.Status newstatus;
				if(!substat.GetStatus(Parent.Puid, true, out newstatus, Parent.Xenoned, Parent.Xenoned))
				{
					Log("Failed to retrieve the updated account status!");
					return false;
				}

				if(newstatus.AccountStatus == acctstatusold.AccountStatus && newstatus.HasViolations == acctstatusold.HasViolations)
				{
					Log("No change from state " + acctstatusold.AccountStatus.ToString() + ((acctstatusold.HasViolations) ? " with violations." : " without violations."));
					return false;
				}

				return true;
			}
			else
			{
				XRLXeUpdatePaymentInstrument xrlXeUpi = new XRLXeUpdatePaymentInstrument();

				// Get info here
				
				XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
				XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
				xrlXGPI.MaxResults = 1;
				xrlXGPI.UserPuid = Parent.Puid;
		
				if (!xrlXGPI.Execute(out xrlXGPIR))
				{
					Parent.Log("Failed getting a payment instrument");
				}

				GetSubscriptionStatus substat = new GetSubscriptionStatus(new LogDelegate(Log));
				GetSubscriptionStatus.Status acctstatusold = new GetSubscriptionStatus.Status();

				// Fix payment here
				xrlXeUpi.PaymentInstrumentId = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
				xrlXeUpi.UserPuid = Parent.Puid;
				xrlXeUpi.CreditCardInfo = xrlXGPIR.PaymentInstrumentInfo[0].CreditCardInfo;
				xrlXeUpi.CreditCardInfo.ExpirationDate = xrlXeUpi.CreditCardInfo.ExpirationDate.AddYears(1);
				xrlXeUpi.AddressInfo = xrlXGPIR.PaymentInstrumentInfo[0].AddressInfo;
				xrlXeUpi.DirectDebitInfo = xrlXGPIR.PaymentInstrumentInfo[0].DirectDebitInfo;
				xrlXeUpi.PhoneInfo = xrlXGPIR.PaymentInstrumentInfo[0].PhoneInfo;

				if(!xrlXeUpi.Execute())
				{
					Log("Failed to update the payment instrument information for this user.");
					string outputString;
					outputString= xrlXeUpi.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlXeUpi.XErr)+"  HTTP:"+xrlXeUpi.httpStatus;
					Log(outputString);
					return false;
				}

				GetSubscriptionStatus.Status newstatus;
				if(!substat.GetStatus(Parent.Puid, true, out newstatus, Parent.Xenoned, Parent.Xenoned))
				{
					Log("Failed to retrieve the updated account status!");
					return false;
				}

				if(newstatus.AccountStatus == acctstatusold.AccountStatus && newstatus.HasViolations == acctstatusold.HasViolations)
				{
					Log("No change from state " + acctstatusold.AccountStatus.ToString() + ((acctstatusold.HasViolations) ? " with violations." : " without violations."));
					return false;
				}

				return true;
			}
		}

		public StepUpdatePaymentInstrument()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public StepUpdatePaymentInstrument(bool WaitForStateChange)
		{
			WaitForChange = WaitForStateChange;
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepReinstateSubscription.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepReinstateSubscription.
	/// </summary>
	[Serializable]
	public class StepReinstateSubscription : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public bool WaitForChange = true;

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			UserSubInfo cursub;
			UserSubInfo [] subs;
			string ErrorXml;
			string AmountCharged;
			string SubStatusInfo;

			GetSubscriptionStatus substat = new GetSubscriptionStatus(new LogDelegate(Log));
			GetSubscriptionStatus.Status acctstatusold = new GetSubscriptionStatus.Status();
			// This is done specifically in this order to do the function call first so that we know uodb is up to date
			// for the call to getusersubs
			if(!substat.GetStatus(Parent.Puid, out acctstatusold) && WaitForChange)
			{
				Log("Failed to retrieve the current account status!");
				return false;
			}

			UodbWS.GetUserSubs(Parent.Puid, out subs, out cursub);
			UserInfo ui = UodbWS.GetUserInfo(Parent.Puid);

			Log("StepReinstateSubscription: Running ReinstateSubscription on " + cursub.serviceInstanceId);

			bdk.ReinstateSubscription(1,
				1,
				1,
				1,
				cursub.serviceInstanceId,
				0,
				"<CommentInfo xmlns=\"urn:schemas-microsoft-com:billing-data\"><CommentCode>12345678</CommentCode><CommentText>Xbox Renewal Test Case</CommentText></CommentInfo>", 
				out ErrorXml, 
				out AmountCharged,
				out SubStatusInfo);

			if(!WaitForChange)
				return true;

			GetSubscriptionStatus.Status newstatus;
			if(!substat.GetStatus(Parent.Puid, true, out newstatus, Parent.Xenoned, Parent.Xenoned))
			{
				Log("Failed to retrieve the updated account status!");
				return false;
			}

			if(newstatus.AccountStatus == acctstatusold.AccountStatus)
			{
				Log("No change from state " + acctstatusold.AccountStatus.ToString());
				return false;
			}

			return true;
		}


		public StepReinstateSubscription()
		{
			//
			// TODO: Add constructor logic here
			//
		}
		public StepReinstateSubscription(bool WaitForStateChange)
		{
			WaitForChange = WaitForStateChange;
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepStopPayment.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Threading;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepStopPayment.
	/// </summary>
	[Serializable]
	public class StepStopPayment : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public int count = 1;
		public bool waitforchange = false;
		// END NOTE

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			string PaymentInstrumentId;
			string ErrorXml;
			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);

			GetSubscriptionStatus.Status acctstatusold = new GetSubscriptionStatus.Status();
			GetSubscriptionStatus substat = new GetSubscriptionStatus(new LogDelegate(Log));

			Log("StepStopPayment: Running StopPayment " + count.ToString() + " times on " + ui.paymentInstrumentId);
			if(waitforchange && !substat.GetStatus(Parent.Puid, out acctstatusold))
			{
				Log("Failed to retrieve the current account status!");
				return false;
			}

			PaymentInstrumentId=ui.paymentInstrumentId;

			if (Parent.Xenoned)
			{
				PaymentInstrumentId = Parent.PaymentInstrumentId;
			}

			for (int i=0; i<count; i++)
			{
				Log("Stopping payment");
				bdk.StopPayments(	1,
					1,
					PaymentInstrumentId,
					out ErrorXml);
				Thread.Sleep(1000);
			}
			Log("Waiting 30 seconds for SCG to respond");
			Thread.Sleep(30000);

			if(!waitforchange)
				return true;

			GetSubscriptionStatus.Status newstatus;
			if(!substat.GetStatus(Parent.Puid, true, out newstatus, Parent.Xenoned, Parent.Xenoned))
			{
				Log("Failed to retrieve the updated account status!");
				return false;
			}

			if (count > 4)
			{
				if(newstatus.AccountStatus == acctstatusold.AccountStatus && newstatus.HasViolations == acctstatusold.HasViolations)
				{
					Log("No change from state " + acctstatusold.AccountStatus.ToString() + ((acctstatusold.HasViolations) ? " with violations." : " without violations."));
					return false;
				}
			}

			return true;
		}

		public StepStopPayment(int Count)
		{
			count=Count;
			Debug.Assert(Count>0);
		}

		public StepStopPayment(int Count, bool WaitForStatusChange)
		{
			count=Count;
			waitforchange = WaitForStatusChange;
			Debug.Assert(Count>0);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepSettleBalance.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Xml;
using System.Threading;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepSettleBalance.
	/// </summary>
	[Serializable]
	public class StepSettleBalance : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public double expectedAmount=0;
		public bool checkBalance = false;

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();
			string PaymentInstrumentId;
			string ErrorXml;
			string AmountCharged;
			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);
			PaymentInstrumentId=ui.paymentInstrumentId;

			Log("StepSettleBalance: Running SettleBalance on " + ui.paymentInstrumentId);
			bdk.SettleBalance(1,1,Guid.NewGuid().ToString(),PaymentInstrumentId,out ErrorXml, out AmountCharged);

			// If we got this far, parse the amount charged XML block
			XmlDocument doc=new XmlDocument();
			doc.LoadXml(AmountCharged);

			// Create an XmlNamespaceManager for resolving namespaces
			XmlNamespaceManager nsmgr = new XmlNamespaceManager(doc.NameTable);
			nsmgr.AddNamespace("ac", "urn:schemas-microsoft-com:billing-data");

			// Select the node that shows the gross amount charged
			XmlElement root=doc.DocumentElement;
			XmlNode node=root.SelectSingleNode("//ac:Gross", nsmgr);
			double charged=Convert.ToDouble(node.InnerText);

			// And compare it against the expected amount
			Log("SettleBalance: amount charged = "+charged);
			if (charged!=expectedAmount && checkBalance)
			{
				Log("FAILED: Expected to be charged "+expectedAmount);
				return false;
			}
			Log("Waiting for SCG processing");
			Thread.Sleep(20000);
			return true;
		}

		public StepSettleBalance()
		{
		}

		public StepSettleBalance(double expected)
		{
			expectedAmount=expected;
			checkBalance = true;
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepVerifyAccountStatus.cs ===
using System;
using System.Threading;
using ServerTestFramework;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepVerifyAccountStatus.
	/// </summary>
	[Serializable]
	public class StepVerifyAccountStatus : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public Global.AccountStatus acctstatus;
		public Global.ViolationStatus violationstatus = Global.ViolationStatus.DontCare;

		public StepVerifyAccountStatus(Global.AccountStatus status)
		{
			acctstatus = status;
		}

		public StepVerifyAccountStatus(Global.AccountStatus status, Global.ViolationStatus ExpectAccountViolations)
		{
			acctstatus = status;
			violationstatus = ExpectAccountViolations;
		}

		public override bool Execute()
		{
			GetSubscriptionStatus gss = new GetSubscriptionStatus(new LogDelegate(Log));
			GetSubscriptionStatus.Status status;
			string logline = "StepVerifyAccountStatus: Verifying account is " + acctstatus.ToString();

			switch(violationstatus)
			{
				case Global.ViolationStatus.No:
					logline += " with no violations.";
					break;
				case Global.ViolationStatus.Yes:
					logline += " with violations.";
					break;
				case Global.ViolationStatus.DontCare:
					logline += " ignoring violations.";
					break;
			};
			Log(logline);

			if(!gss.GetStatus(Parent.Puid, true, out status, Parent.Xenoned, Parent.Xenoned))
			{
				Log("Retrieving the account status failed!");
				return false;
			}
			if(status.AccountStatus != acctstatus)
			{
				Log("Mismatch! Account status: " + status.AccountStatus.ToString() + " Expected status: " + acctstatus.ToString());
				return false;
			}
			if(violationstatus != Global.ViolationStatus.DontCare &&
				((violationstatus == Global.ViolationStatus.Yes && !status.HasViolations) ||
				(violationstatus == Global.ViolationStatus.No && status.HasViolations)))
			{
				Log("Mismatch! Account " + ((status.HasViolations) ? " has " : " doesn't have ") + " violations.  Expected otherwise.");
				return false;
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepVerify.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepVerify.
	/// </summary>
	[Serializable]
	public class StepVerify : CaseStep
	{
		public void PrintDebug()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			xrlSE.TitleID = 0;
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for 30 second interval");
					//Thread.Sleep(60000 + randomBackoff.Next(30000));
                    Thread.Sleep(30000);
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("         Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);

		}


		// I intentionally didn't want to add Ignore as an offer type to prevent
		// users from using it for signups or renewals;
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public bool IgnoreNext=false;
		public Global.OfferType Current, Next;

		public override bool Execute()
		{
			Parent.Log(Header+" verifying offer 0x"+((ulong)Current).ToString("X")+" / "+Next);
			if (!Parent.Xenoned)
			{
				XRLGetSubscriptionStatus request=new XRLGetSubscriptionStatus();
				XRLGetSubscriptionStatusResponse Head;
				XRLGetSubscriptionStatusDetails []Details;

				request.userPuid=Parent.Puid;

				bool b = false;			// stores result of request call
				uint retryCount = 0;	// allows us to retry several times when a request fails
				uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
				System.Random randomBackoff = new Random();

				// try up to 5 times when request fails due to timeout, etc.
				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						//Thread.Sleep(10000 + randomBackoff.Next(30000));
                        Thread.Sleep(10000);
					}

					b = request.Execute(out Head, out Details);

					if (!b)
					{
						string outputString;
						outputString=request.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(request.XErr)+"  HTTP:"+request.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				// if we've reached the maximum number of retries and still no success, return failure
				if(!b)
					return false;

				Log("    Current offer ID : 0x"+Head.currentOfferId.ToString("X"));
				Log("Current offer status : "+Head.currentOfferStatus);
				Log("          Start date : "+Head.startDate.ToLocalTime());
				Log("            End date : "+Head.endDate.ToLocalTime());
				Log("       Next offer ID : 0x"+Head.renewalOfferId.ToString("X"));
				Log("   Next offer status : "+Head.renewalStatus);
				Log("               Grace : "+Head.renewalGracePeriod);
				if (Head.currentOfferId!=(ulong) Current)
				{
					b=false;
					Parent.Log("Current offer mismatch! (Expected 0x"+((uint)Current).ToString("X")+" ("+Current+") got 0x"+Head.currentOfferId.ToString("X")+")" + Head);
				}
				if (!IgnoreNext)
					if ((Head.renewalStatus != (byte) Global.RenewalStatus.NO_RENEWAL && Next == Global.OfferType.None) || (Head.renewalOfferId!=(ulong) Next))
					{
						b=false;
						Parent.Log("Renewal offer mismatch! (Expected 0x"+((uint)Current).ToString("X")+" ("+Next+") got "+Head.renewalOfferId.ToString("X")+")");
					}

				return b;
			}
			else
			{
				bool b = false;			// stores result of request call
				bool globalFailure = false;
				uint retryCount = 0;	// allows us to retry several times when a request fails
				uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
				ulong currentOffer = 0;
				System.Random randomBackoff = new Random();

				// ******************* BUG WORKAROUND *********************
				//PrintDebug();
				// ***************** END BUG WORKAROUND *******************

				XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
				XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

				xrlSE.UserPuid = Parent.Puid;
				xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
				xrlSE.CountryID = Parent.CountryID;
				xrlSE.LanguageID = Parent.LanguageID;
				xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
									(uint)PaymentTypeEnum.CreditCard |
									(uint)PaymentTypeEnum.Token;
				//xrlSE.GameRating = 0xFFFF;
				xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
									(uint) OfferingTypeEnum.Renewal;
				//xrlSE.TitleID = 0;
				xrlSE.TitleCategories = 0xFFFFFFFF;
				xrlSE.QueryForNew = false;
				xrlSE.QueryForRenewals = false;
				xrlSE.QueryForCurrent = true;
				// HACKHACK - Stf not quite there yet
				xrlSE.RequestFlags |= 0x0008;
				// /HACKHACK
				xrlSE.GameRating = 2;

				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						//Thread.Sleep(60000 + randomBackoff.Next(30000));
                        Thread.Sleep(10000);
					}
					try
					{
							//xrlSE.Timeout = 360000;
						b = xrlSE.Execute(out xrlSER);
					}
					catch (Exception e)
					{
						Log(e.ToString());
					}
					if (!b)
					{
						string outputString;
						outputString=xrlSE.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				if (!b)
				{
					Log("Enumerating subscriptions failed");
					return false;
				}

				int counter = 0;
				foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
				{
					
					Log(" --- Offer Enumeration --- ");
					Log("Offer ID           :0x" + bsi.OfferID.ToString("X"));
					Log("Offer Name         :" + bsi.OfferName);
					Log("Offer Type         :" + bsi.OfferType); 
					Log("Convert Mode       :" + bsi.ConvertMode);
					Log("Frequency          :" + bsi.Frequency);
					Log("Duration           :" + bsi.Duration);
					Log("Is User Subscribed :" + bsi.userIsSubscribed);
					if (bsi.userIsSubscribed)
					{
						counter++;
						currentOffer = bsi.OfferID;
					}
					Log("-- Prices --");
					foreach (OfferPrice op in bsi.Prices)
						Log(" -- Price	:" + op.PriceText);					
					Log(" ------------------------- ");
				}

				if (counter > 1)
				{
					Log("Too many subscriptions found");
					return false;
				}

				if (counter == 0)
				{
					Log("No subscription found");
					return false;
				}

				if (currentOffer!=(ulong) Current)
				{
					Log(" ** Current offer mismatch! -Expected "+Current+" (0x"+((uint)Current).ToString("X")+") got 0x"+((uint)currentOffer).ToString("X")+"-");
					globalFailure = true;
				}

				retryCount = 0;

				XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
				XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

				xrlGUSD.OfferId = (ulong) currentOffer;
				xrlGUSD.UserPuid = Parent.Puid;

				//Call XRLXeGetUserSubscriptionDetails


				// try up to 5 times when request fails due to timeout, etc.
				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						//Thread.Sleep(60000 + randomBackoff.Next(30000));
                        Thread.Sleep(10000 );
					}

					b = xrlGUSD.Execute(out xrlGUSDR);

					if (!b)
					{
						string outputString;
						outputString=xrlGUSD.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				//xrlGUSDR.
				// if we've reached the maximum number of retries and still no success, return failure
				if(!b)
				{
					Log("Get Subscription Status Failed");
					return true;
				}

				Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
				Log("         Description : "+xrlGUSDR.Description);
				Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
				Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
				Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
				Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
				Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
				Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X"));
				Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
				Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
				Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);
				GetSubscriptionStatus.Status status;
				GetSubscriptionStatus gss = new GetSubscriptionStatus(new LogDelegate(Log));
				gss.GetStatus(Parent.Puid, false, out status, true, true);
				
				//TODO: Add more verification
				if (!IgnoreNext)
					if ((xrlGUSDR.RenewalOfferStatus != (byte) Global.RenewalStatus.NO_RENEWAL && Next == Global.OfferType.None) || (xrlGUSDR.RenewalOfferId!=(ulong) Next))
					{
						b=false;
						Parent.Log("Renewal offer mismatch! (Expected "+ ((uint) Next).ToString("X")+" got "+xrlGUSDR.RenewalOfferId.ToString("X")+")");
					}
				if (globalFailure)
					return false;
				return b;
			}
		}

		public StepVerify(Global.OfferType current)
		{
			IgnoreNext=true;
			Current=current;
		}

		public StepVerify(Global.OfferType current, Global.OfferType next)
		{
			Current=current;
			Next=next;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\TimeRoll.cs ===
using System;
using System.Runtime;
using System.Threading;
using System.Collections;
using ServerTestFramework;

namespace RenewalMatrix
{
	public enum TimeRollType
	{
		day,
		week,
		month,
		end_of_month,
		no_roll
	}
	/// <summary>
	/// Timeroll class.
	/// Keeps track of how long a time roll should be.
	/// Roll time == 0 with anything but no_roll specified is a special case that will advance the clock to the end of the month.
	/// </summary>
	public class TimeRoll
	{
		public int rollTime;
		public int absoluteRollTime;
		public TimeRollType rollType;
		public string Name;
		public bool Buffer;

		// Only use this one if you really know what you are doing
		public TimeRoll(string name, TimeRollType trt, int rollTimeValue, bool TimeBuffer)
		{
			Name=name;
			rollTime = rollTimeValue;
			rollType = trt;
			Buffer = TimeBuffer;
		}

		public TimeRoll(string name, TimeRollType trt, int rollTimeValue)
		{
			Name=name;
			rollTime = rollTimeValue;
			rollType = trt;
			//removed the extra buffers between each check point
            Buffer = false;
		}		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepVerifyExpiryDate.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using Microsoft.SPG.Test.Billing;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepVerifyExpiryDate.
	/// </summary>
	[Serializable]
	public class StepVerifyExpiryDate : CaseStep
	{
		public Global.OfferLength length;
		//public BillingTestClient client;

		public override bool Execute()
		{
			Parent.Log(Header+" verifying expiry date");
			XRLGetSubscriptionStatus request=new XRLGetSubscriptionStatus();
			XRLGetSubscriptionStatusResponse Head;
			XRLGetSubscriptionStatusDetails []Details;

			request.userPuid=Parent.Puid;

			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 0;	// defines how many failures we'll tolerate before giving up
			System.Random randomBackoff = new Random();

			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = request.Execute(out Head, out Details);

				if(!b)
				{
					string outputString;
					outputString=request.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(request.XErr)+"  HTTP:"+request.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return false;

			// get current time on SPS 1-box -- this is what our start date should be
			DateTime myStartTime = TimeZone.CurrentTimeZone.ToLocalTime(Form1.client.GetClockTime());			

			// determine our end date based on the current offer length
			DateTime myEndTime = TimeZone.CurrentTimeZone.ToLocalTime(myStartTime.AddMonths((int)length));

			// get the actual start and end date of the offer
			DateTime startTime = Head.startDate.ToLocalTime();
			DateTime endTime = Head.endDate.ToLocalTime();

			// compare values
			if(!DateTime.Equals(myStartTime.Date, startTime.Date))
			{
				// allow for 1-box based date to be one day ahead of offer date because the time it takes to do
				// time rolls and periodic processing could cause the time on the 1-box to move to the next day
				if(DateTime.Equals(myStartTime.AddDays(-1).Date, startTime.Date))
				{
					Parent.Log("Start date: Expected " + myStartTime.ToLongDateString() + ", got " + startTime.ToLongDateString());
					Parent.Log("1-box time could be 1 day ahead because of time elapsed for clock rolls and periodic processing");
				}
				
				else
				{
					b = false;
					Parent.Log("Start date mismatch! (Expected " + myStartTime.ToLongDateString() + ", got " + startTime.ToLongDateString());
				}
			}

			if(!DateTime.Equals(myEndTime.Date, endTime.Date))
			{
				// allow for 1-box based date to be one day ahead of offer date because the time it takes to do
				// time rolls and periodic processing could cause the time on the 1-box to move to the next day
				if(DateTime.Equals(myEndTime.AddDays(-1).Date, endTime.Date))
				{
					Parent.Log("End date: Expected " + myEndTime.ToLongDateString() + ", got " + endTime.ToLongDateString());
					Parent.Log("1-box time could be 1 day ahead because of time elapsed for clock rolls and periodic processing");
				}
				
				else
				{
					b = false;
					Parent.Log("End date mismatch! (Expected " + myEndTime.ToLongDateString() + ", got " + endTime.ToLongDateString());
				}
			}

			if(b)
			{
				Parent.Log("Verified offer dates: Expected Start = " + startTime.ToLongDateString() + ", End = " + endTime.ToLongDateString());
				Parent.Log("Got Start = " + myStartTime.ToLongDateString() + ", End = " + myEndTime.ToLongDateString());
			}
			return b;
		}

		public StepVerifyExpiryDate(Global.OfferLength offerLength)
		{
			length = offerLength;
			//client = new BillingTestClient();
		}

		public StepVerifyExpiryDate()
		{
			//
			// TODO: Add constructor logic here
			//
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepWaitForRoll.cs ===
using System;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepWaitForRoll.
	/// </summary>
	[Serializable]
	public class StepWaitForRoll : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public TimeRoll roll;
		public override bool Execute()
		{
			return true;
		}

		public StepWaitForRoll(TimeRoll roll)
		{
			this.roll=roll;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepVerifyOpenBalance.cs ===
using System;
using ServerTestFramework;
using System.Diagnostics;
using System.Web.Services.Protocols;
using System.Xml;
using System.Collections;
using ServerTestFramework.Database;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepVerifyOpenBalance.
	/// </summary>
	/// 
	
//	enum Balance
//	{
//		AccountActivitySet = 0x10000001
//	};

	[Serializable]
	public class StepVerifyOpenBalance : CaseStep
	{
		public Currency BegReadyBalance;
		public Currency BegOpenBalance;
		public Currency BegRefundBalance;

		public Currency CurReadyBalance;
		public Currency CurOpenBalance;
		public Currency CurRefundBalance;

		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public bool CancelConvertFlag;
		public bool CreditExpectedFlag;
		public StepVerifyOpenBalance PrevCase;

		public AccountStatementInfoSetLogDepth logging = AccountStatementInfoSetLogDepth.None;

		public override bool Execute()
		{
			BdkInterface bdk=new BdkInterface();

			string ErrorXml;
			string AccountStatementInfoSetXML;
			string UserNotificationSetXML;

			UserInfo ui=UodbWS.GetUserInfo(Parent.Puid);

			string acctid = ui.billingAccountId;

			bdk.GetStatement(1, 1, 1, 1, acctid, 0, 0, 2, false, out ErrorXml, out AccountStatementInfoSetXML, out UserNotificationSetXML);
			
			AccountStatementInfoSet asis = new AccountStatementInfoSet();

			if(asis.Parse(AccountStatementInfoSetXML))
			{
				Parent.State[Balance.AccountActivitySet] = asis;
			}

			if(logging != AccountStatementInfoSetLogDepth.None)
				asis.Log(new LogDelegate(Log), logging);

			AccountStatementInfo temp1 = (AccountStatementInfo)asis.AccountStatementInfoSetSet[0];
			AccountStatement temp2 = (AccountStatement)temp1.AccountStatementSet[0];
			
			CurReadyBalance = temp2.ReadyBalance;
			CurOpenBalance = temp2.OpenBalance;
			CurRefundBalance = temp2.RefundBalance;

			if(CancelConvertFlag)
			{
				//if(PrevCaseIndex > 0)
				if (PrevCase != null)
				{
					// Get beginning balance and compare with current balance
					//CaseStep prevStep = Parent.Steps[PrevCaseIndex];
					//StepVerifyOpenBalance prevBal = (StepVerifyOpenBalance) prevStep;
					StepVerifyOpenBalance prevBal = PrevCase;
					BegReadyBalance = prevBal.BegReadyBalance;
					BegOpenBalance = prevBal.BegOpenBalance;
					BegRefundBalance = prevBal.BegRefundBalance;

					Log("***Retrieved beginning balances:");
					Log("***BegReadyBalance = " + BegReadyBalance.Display());
					Log("***BegOpenBalance = " + BegOpenBalance.Display());
					Log("***BegRefundBalance = " + BegRefundBalance.Display());

					Log("***Comparing with current balances:");
					Log("***CurReadyBalance = " + CurReadyBalance.Display());		
					Log("***CurOpenBalance = " + CurOpenBalance.Display());
					Log("***CurRefundBalance = " + CurRefundBalance.Display());
				}

				if(CreditExpectedFlag)
				{	
					if(CurReadyBalance < BegReadyBalance)
					{
						Log("Verified credit to account: " + (BegReadyBalance - CurReadyBalance).Display());
					}
					else
					{
						Log("FAILED: Expected a credit after Cancel/Convert, but didn't get one");
						return false;
					}
				}
				else
				{
					if(CurReadyBalance == BegReadyBalance)
					{
						Log("Verified no credit to account");
					}
					else
					{
						Log("FAILED: Didn't expect a credit after Cancel/Convert, but got one: "
							+ (BegReadyBalance - CurReadyBalance).Display());
						return false;
					}
				}
			}
			else
			{
				// Hack to check for 0 balance
				// Since CancelConvertFlag = FALSE && CreditExpectedFlag = TRUE should never happen,
				// use this combination to check for the special case of a 0 balance
				if(CreditExpectedFlag)
				{
					if(CurReadyBalance.Value == 0)
					{
						Log("Verified zero balance on account");
					}
					else
					{
						Log("FAILED: Expected zero balance on account, but got: " + CurReadyBalance.Display());
						return false;
					}
				} 
				// Store beginning balance for comparison later
				else
				{
					BegReadyBalance = CurReadyBalance;
					BegOpenBalance = CurOpenBalance;
					BegRefundBalance = CurRefundBalance;

					Log("***Stored beginning balances:");
					Log("***BegReadyBalance = " + BegReadyBalance.Display());
					Log("***BegOpenBalance = " + BegOpenBalance.Display());
					Log("***BegRefundBalance = " + BegRefundBalance.Display());
				}
			}
			return true;
		}

		public StepVerifyOpenBalance(AccountStatementInfoSetLogDepth LogResults, bool PostCancelOrConvert, bool CreditExpected, ref StepVerifyOpenBalance CompareCase)
		{
			logging = LogResults;
			CancelConvertFlag = PostCancelOrConvert;
			CreditExpectedFlag = CreditExpected;
			//PrevCaseIndex = CompareCaseIndex;
			PrevCase = CompareCase;
		}

		public StepVerifyOpenBalance(AccountStatementInfoSetLogDepth LogResults, bool PostCancelOrConvert, bool CreditExpected)
		{
			logging = LogResults;
			CancelConvertFlag = PostCancelOrConvert;
			CreditExpectedFlag = CreditExpected;
			PrevCase = null;
		}

		public StepVerifyOpenBalance(AccountStatementInfoSetLogDepth LogResults)
		{
			logging = LogResults;
			PrevCase = null;
		}

		public StepVerifyOpenBalance()
		{
			PrevCase = null;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\StepVerifyEnumerate.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;

namespace RenewalMatrix
{
	/// <summary>
	/// Summary description for StepVerifyEnumerate.
	/// </summary>
	[Serializable]
	public class StepVerifyEnumerate : CaseStep
	{
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public string enumerationSubCode = "";
		public ArrayList enumerationOffersExpected = new ArrayList();
		
		// For the case where we're providing a sub-code and not expecting anything to be listed
		public StepVerifyEnumerate(string subCode)
		{
			enumerationSubCode = subCode;
		}

		// For the case where we're providing a sub-code and expecting a particular list
		public StepVerifyEnumerate(string subCode, ArrayList offersExpected)
		{
			enumerationSubCode = subCode;
			enumerationOffersExpected = offersExpected;
		}

		// For the case where we're not providing a sub-code and we're expecting a particular list
		public StepVerifyEnumerate(ArrayList offersExpected)
		{
			enumerationOffersExpected = offersExpected;
		}

		public override bool Execute()
		{
			Log("StepVerifyEnumerate: Verifying offers for subcode - '" + enumerationSubCode + "'");

			XRLEnumerateEligible ee = new XRLEnumerateEligible();
			XRLEnumerateEligibleHeader eligibleHeader;
			XRLEnumerateEligibleRecord [] eligibleRecords;

			// The only fields we might want to overwrite are...
			//    UserPUID     - this should probably always be the Parent.Puid
			//    MaxResults   - most likely 10 will be sufficient
			//    LanguageId   - 1 is English
			//    VoucherLen   - size of any subcode string
			//    Voucher      - subcode string

			ee.UserPUID = Parent.Puid;
			ee.MaxResults = 10;
			ee.LanguageId = 1;
			try 
			{
				ee.VoucherLen = Convert.ToUInt16(enumerationSubCode.Length);
				ee.Voucher = enumerationSubCode;
			}
			catch (System.OverflowException) 
			{
				Log("Sub code size was too long, discarding...");
				ee.VoucherLen = 0;
				ee.Voucher = "";
			}

			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			System.Random randomBackoff = new Random();

			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					//Thread.Sleep(60000 + randomBackoff.Next(30000));
                    Thread.Sleep(10000);
				}

				// Issue the enumerate call
				b = ee.Execute(out eligibleHeader, out eligibleRecords);
				
				if(!b)
				{
					string outputString;
					outputString=ee.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(ee.XErr)+"  HTTP:"+ee.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return false;

			// Iterate through the expected offers and make sure that they are present in the response
			if(enumerationOffersExpected.Count != eligibleRecords.Length)
			{
				string outputString;
				outputString=enumerationOffersExpected.Count + " eligible offers expected, " + eligibleRecords.Length + " eligible offers returned.";
				Log(outputString);
				return false;
			}

			foreach(XRLEnumerateEligibleRecord header in eligibleRecords)
			{
				if(!enumerationOffersExpected.Contains((Global.OfferType) header.offeringId))
				{
					string outputString;
					outputString="Eligible offering " + header.offeringId.ToString() + " wasn't expected";
					Log(outputString);
					return false;					
				}
			}

			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\Config.cs ===
using System;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for Config.
	/// </summary>
	public class Config
	{
		public static bool UseOldThreadScheduling = false;
		public static bool CallOneBox = true;
		public static DateTime StartDateTime;
		public static Form1 UIAccessPoint;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\FileTracker.cs ===
using System;
using System.Collections;

namespace RenewalMatrix.New_Code
{
	
	/// <summary>
	/// Summary description for FileTracker.
	/// </summary>
	public class FileTracker
	{
		//
		private static Hashtable fileNames;

		/// <summary>
		/// 
		/// </summary>
		/// <param name="filename"></param>
		/// <returns></returns>
		public static bool IsUnique(string filename)
		{
			if (fileNames == null)
				fileNames = new Hashtable();
			return (fileNames[filename] == null);
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="filename"></param>
		public static void AddFile(string filename)
		{
			if (fileNames == null)
				fileNames = new Hashtable();
			fileNames[filename] = new Object();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\FilterForm.Designer.cs ===
namespace RenewalMatrix.New_Code
{
    partial class FilterForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;       

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.FilterTreeView = new System.Windows.Forms.TreeView();
            this.okButton = new System.Windows.Forms.Button();
            this.SuspendLayout();
            // 
            // FilterTreeView
            // 
            this.FilterTreeView.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            this.FilterTreeView.BackColor = System.Drawing.SystemColors.HighlightText;
            this.FilterTreeView.CheckBoxes = true;
            this.FilterTreeView.Location = new System.Drawing.Point(0, 0);
            this.FilterTreeView.Name = "FilterTreeView";
            this.FilterTreeView.Size = new System.Drawing.Size(500, 321);
            this.FilterTreeView.TabIndex = 0;
            this.FilterTreeView.AfterCheck += new System.Windows.Forms.TreeViewEventHandler(this.FilterTreeView_AfterCheck);
            this.FilterTreeView.AfterSelect += new System.Windows.Forms.TreeViewEventHandler(this.FilterTreeView_AfterSelect);
            this.FilterTreeView.MouseMove += new System.Windows.Forms.MouseEventHandler(this.FilterTreeView_MouseMove);
            // 
            // okButton
            // 
            this.okButton.Anchor = System.Windows.Forms.AnchorStyles.Bottom;
            this.okButton.BackColor = System.Drawing.SystemColors.Control;
            this.okButton.FlatStyle = System.Windows.Forms.FlatStyle.Popup;
            this.okButton.Location = new System.Drawing.Point(220, 331);
            this.okButton.Name = "okButton";
            this.okButton.Size = new System.Drawing.Size(58, 23);
            this.okButton.TabIndex = 1;
            this.okButton.Text = "OK";
            this.okButton.UseVisualStyleBackColor = false;
            this.okButton.Click += new System.EventHandler(this.okButton_Click);
            // 
            // FilterForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.SystemColors.ActiveBorder;
            this.ClientSize = new System.Drawing.Size(499, 366);
            this.Controls.Add(this.okButton);
            this.Controls.Add(this.FilterTreeView);
            this.Name = "FilterForm";
            this.Load += new System.EventHandler(this.FilterForm_Load);
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TreeView FilterTreeView;
        private System.Windows.Forms.Button okButton;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\FilterForm.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Xml;
using System.Reflection;
using ServerTestFramework.LiveService.UserAccount;

namespace RenewalMatrix.New_Code
{
    public partial class FilterForm : Form
    {
        public XmlDocument ReturnXmlDoc;
        public Type CallingObject;

        //Toolttip variables
        private ToolTip TTip;
        private TreeNode NodeUnderMouse = null;
        private int OldNodeIndex = -1;
      
        public FilterForm(Type callingObject)
        {
            CallingObject = callingObject;
            this.Text = "Matrix Filter for: " + CallingObject.ToString();
            InitializeComponent();
        }

        private void FilterForm_Load(object sender, EventArgs e)
        {
            TTip = new ToolTip();
            TTip.InitialDelay = 300;
            TTip.AutoPopDelay = 8000;
            TTip.ReshowDelay = 100;
            TTip.ShowAlways = true;  // always show whether or not the form is active
        }

        public void LoadTree(XmlDocument dom)
        {
            try
            {
                this.FilterTreeView.Nodes.Clear();
                XmlElement xEl = dom.DocumentElement as XmlElement;
                this.FilterTreeView.Nodes.Add(new TreeNode(xEl.GetAttribute("name")));
                TreeNode tNode = new TreeNode();
                tNode = this.FilterTreeView.Nodes[0];
                ToolTipMapping(tNode, xEl.Name);
                AddNode(dom.DocumentElement, tNode);
            }
            catch (XmlException xmle)
            {
                throw xmle;
            }
            FilterTreeView.Nodes[0].Expand();
        }
        private void AddNode(XmlNode inXmlNode, TreeNode inTreeNode)
        {
            XmlNode xNode;
            TreeNode tNode;
            XmlNodeList nodeList;         
            int i;  

            // Loop through the XML nodes until the leaf is reached.
            // Add the nodes to the TreeView during the looping process.
            if (inXmlNode.HasChildNodes)
            {
                nodeList = inXmlNode.ChildNodes;
                for (i = 0; i <= nodeList.Count - 1; i++)
                {
                    xNode = inXmlNode.ChildNodes[i];
                    XmlElement xEl = (xNode as XmlElement);
                    TreeNode tN = new TreeNode(xEl.GetAttribute("name"));
                    inTreeNode.Nodes.Add(tN);
                    //Add tool tips for all the treenodes
                    ToolTipMapping(tN, xEl.Name);                    
                    tNode = inTreeNode.Nodes[i];
                    AddNode(xNode, tNode);
                }
            }
            else
            {                
                inTreeNode.Text = ((XmlElement)(inXmlNode)).GetAttribute("name");
            }
        }

        private int DoNotEnter = 0;
        private void FilterTreeView_AfterCheck(object sender, System.Windows.Forms.TreeViewEventArgs e)
        {
            if (DoNotEnter > 0)
            {
                DoNotEnter--;
                return;
            }

            CheckAll(e.Node.Nodes, (e.Node.Checked));

            TreeNode parent = e.Node.Parent;
            while (parent != null)
            {
                bool hasCheckedKids = false;
                // determine if this parent has any selected nodes
                foreach (TreeNode n in parent.Nodes)
                {
                    if (n.Checked)
                    {
                        hasCheckedKids = true;
                        break;
                    }
                }

                if (hasCheckedKids && parent.Checked == false)
                {
                    DoNotEnter++;
                    parent.Checked = e.Node.Checked;
                }
                if (!hasCheckedKids)
                {
                    DoNotEnter++;
                    parent.Checked = false;
                }
                parent = parent.Parent;
            }
        }

        private void CheckAll(TreeNodeCollection col, bool newValue)
        {
            this.SuspendLayout();
            foreach (TreeNode node in col)
            {
                node.Checked = newValue;
                CheckAll(node.Nodes, newValue);
            }
            //this.ExpandCheckedNodes();
            this.ResumeLayout();
        }

        private void ExpandCheckedNodes()
        {
            // Only expand Countries, Matrix and AccountType
            foreach (TreeNode n in FilterTreeView.Nodes)
            {
                if (n.Checked)
                {
                    // Expand this (suite node)
                    n.Expand();

                    // Expand children (group node)
                    foreach (TreeNode n2 in n.Nodes)
                    {
                        if (n2.Checked)
                        {
                            n2.Expand();
                            foreach (TreeNode n3 in n2.Nodes)
                            {
                                if (n3.Checked)
                                    n3.Expand();
                            }
                        }
                    }
                }
            }
        }

        private void FilterTreeView_MouseMove(object sender, MouseEventArgs e)
        {
            NodeUnderMouse = FilterTreeView.GetNodeAt(e.X, e.Y);           

            if(NodeUnderMouse != null)
            {
                if (NodeUnderMouse.Index != OldNodeIndex)
                {
                    // Save old one
                    OldNodeIndex = NodeUnderMouse.Index;

                    if (TTip.Active)
                    {
                        // Turn it off
                        TTip.Active = false;
                        TTip.SetToolTip(this.FilterTreeView, NodeUnderMouse.ToolTipText);
                        // Turn it back on
                        TTip.Active = true;
                    }
                    else
                    {
                        TTip.SetToolTip(this.FilterTreeView, NodeUnderMouse.ToolTipText);
                    }                  
                }
            }
        }

        private void okButton_Click(object sender, System.EventArgs e)
        {
            ReturnXmlDoc = new XmlDocument();
            if (!FilterTreeView.Nodes[0].Checked)
            {
                ReturnXmlDoc = null;
                MessageBox.Show("None of the options were selected", "Matrix Filter Selection");
                CloseForm();
                return;
            }
            CollectData();
            CloseForm();
            return;
        }

        //Collect data for building the filter and pass it back to caller in the xml format
        private void CollectData()
        {
            ReturnXmlDoc = new XmlDocument();
            ReturnXmlDoc.AppendChild(ReturnXmlDoc.CreateElement("entire"));
            XmlElement allCountryEl = ReturnXmlDoc.DocumentElement;
            allCountryEl.SetAttribute("name", "All Countries");

            TreeNode tNode = FilterTreeView.Nodes[0].Nodes[0];
            AddXmlNodes(allCountryEl, tNode);
        }

        private void AddXmlNodes(XmlNode inXmlNode, TreeNode inTreeNode)
        {
            string elementName;
            if (inTreeNode.Checked)
            {
                try
                {
                    elementName = TreenodeLevelMapping(inTreeNode.Level);
                }
                catch (Exception e)
                {
                    throw e;
                }
                XmlElement newEl = (XmlElement)inXmlNode.AppendChild(ReturnXmlDoc.CreateElement(elementName));
                newEl.SetAttribute("name", inTreeNode.Text);
                int numChildNodes = inTreeNode.GetNodeCount(false);
                if (numChildNodes > 0)
                {
                    for (int i = 0; i < numChildNodes; i++)
                    {
                        AddXmlNodes(newEl, inTreeNode.Nodes[i]);                     
                    }
                }                
            }
            if (inTreeNode.NextNode != null && inTreeNode.Level == 1)
            {
                AddXmlNodes(inXmlNode, inTreeNode.NextNode);
            }
            return;
        }

        //Maps the Level of the treenode to XML element types - country, Matrix, UserAccountType
        private string TreenodeLevelMapping( int level)
        {
            switch (level)
            {
                case 0:
                    return "entire";
                case 1:
                    return "Country";
                case 2:
                    return "Matrix";
                case 3:
                    return "UserAccountType";
                default:
                    {
                        ArgumentOutOfRangeException e = new ArgumentOutOfRangeException();
                        throw e;
                    }
            }
        }

        private void ToolTipMapping(TreeNode node, string name)
        {            
            switch (name)
            {
                case "entire":
                    {
                        node.ToolTipText = "Select all possible test cases";
                        break;
                    }
                case "Country":
                    {
                        node.ToolTipText = "Select all cases for this country";
                        break;
                    }
                case "Matrix":
                    {
                        MethodInfo mi = CallingObject.GetMethod("MatrixDescription");
                        node.ToolTipText =  "Select Matrix: " + (string) mi.Invoke(null, new Object[] { (Global.MatrixType) Enum.Parse(typeof(Global.MatrixType), node.Text, true) });
                        break;
                    }
                case "UserAccountType":
                    {
                        node.ToolTipText = "UserAccount Types";
                        break;
                    }
            }

        }

        private void CloseForm()
        {
            this.Close();
        }

        private void FilterTreeView_AfterSelect(object sender, TreeViewEventArgs e)
        {

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\HeavyweightObject.cs ===
using System;
using System.IO;
using System.Collections;
using System.Threading;
using System.Web.Services.Protocols;
using ServerTestFramework.LiveService.UserAccount;
using System.Runtime.Serialization.Formatters.Soap;
using System.Runtime.Serialization.Formatters.Binary;

namespace RenewalMatrix.New_Code
{
	public enum HwoClassState
	{
		HWO_INITIALIZED,
		HWO_BUILDING,
		HWO_RUNNING,
		HWO_NEEDS_REINIT,
		HWO_STALE,
		HWO_FINISHED
	}

	/// <summary>
	/// Summary description for HeavyweightObject.
	/// TODO: Some SERIOUS documentation needed
	/// </summary>
	[Serializable]
	public class HeavyweightObject
	{
		// Global User Information
		public ulong													Puid=0;
		public string													GamerTag = "";     //added gamertag in order to sign in to the XKDC
		public byte []													XenonKey = null;   //used for signin to the XKDC
		public bool														Xenoned=false;
		public byte														CountryID=0;
		public ushort													LanguageID=0;
		public int														VoucherNumber=0;
		public string													PaymentInstrumentId = "";
		public byte []													SignedUserPassportPuid = null;
		public string													UserPassportMemberName = "";
		public bool														PassportAssociated = false;
		public AddressInfoData												AddressInfo = null;
		public Hashtable												VouchersUsed = new Hashtable();
		// For easy passport linking.  Not present for Xenoned accounts
		public ServerTestFramework.LiveService.UserAccount.Owner		OwnerForPassport = null;

		//NOTE: The following items should be private (and will be once I know serialization works Soap->Binary)
		public System.Collections.Queue relativeTimeSet;
		public System.Collections.Queue absoluteTimeSet;

		//Case steps
		public System.Collections.Hashtable stepsForAbsoluteTime;

		// Filename for serialization
		public string filename;
		//public string logFilename;
		public string description;

		//Logging information
		public ArrayList OutputLog;
		public string Name;
		public bool failureOccurred;
		public uint FailureCount = 0;

		// Misc older logic
		public bool ContinueOnFailures;
		public System.Collections.Hashtable State = new Hashtable();

		// For time logic
		public int currentAbsoluteTime;
		public int nextAbsoluteTime;
		// Note: 1-based for the moment
		public int currentStepIndex;
		//
		public int totalSteps;

		public int lastAbsoluteRunTime;

		public HwoClassState currentState;
		public LightweightTracker lwo;
		// END NOTE
				
		public LightweightTracker LightweightObject
		{
			get
			{
				return lwo;
			}
		}

		public int			PuidLow
		{
			get
			{
				return (int)(Puid & 0xFFFFFFFF);
			}
		}
		public int			PuidHigh
		{
			get
			{
				return (int)(Puid >> 32);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		public HeavyweightObject(Case caseItem)
		{
			stepsForAbsoluteTime = new Hashtable();
			relativeTimeSet = new Queue();
			absoluteTimeSet = new Queue();
			currentAbsoluteTime = 0;
			lastAbsoluteRunTime = -1;
			System.Random rand = new Random();
			do
			{
				filename = "hwo" + rand.Next(1000000) + ".xml";
			}
			while (!FileTracker.IsUnique(filename));
			FileTracker.AddFile(filename);
			//logFilename = filename + ".log";
			currentState = HwoClassState.HWO_INITIALIZED;
			this.Name = caseItem.Name;
			OutputLog = new ArrayList();
			failureOccurred = false;

			//TODO: Remove me (once no longer necessary)
			//containedCase = caseItem;

			int currentTime = 0;
			
			ArrayList arrayListForCurrentTime = new ArrayList();
			//Populate case items from case
			foreach (CaseStep cs in caseItem.Steps)
			{
				if (cs != null)
				{
					if (cs is StepWaitForRoll)
					{
						stepsForAbsoluteTime[currentTime] = arrayListForCurrentTime;
						arrayListForCurrentTime = new ArrayList();
						absoluteTimeSet.Enqueue(currentTime);
						// + buffer to verify we always hit our date
						currentTime = ((StepWaitForRoll) cs).roll.absoluteRollTime;
					}
					else
					{
						arrayListForCurrentTime.Add(cs);
						totalSteps++;
					}
				}
			}
			stepsForAbsoluteTime[currentTime] = arrayListForCurrentTime;
			absoluteTimeSet.Enqueue(currentTime);

			this.ContinueOnFailures = caseItem.ContinueOnFailures;
			lwo = new LightweightTracker(this);
		}

		/// <summary>
		/// Repairs class after deserialization
		/// </summary>
		public void ReInitialize(LightweightTracker lightObject)
		{
			if (currentState != HwoClassState.HWO_NEEDS_REINIT)
			{
				throw new Exception("Function called in invalid state.  Expected: " + HwoClassState.HWO_NEEDS_REINIT + " Actual: " + currentState);
			}
			lwo = lightObject;
			// here to repair anything that needs to be repaired after deserialization
			currentState = HwoClassState.HWO_RUNNING;
		}

		/// <summary>
		/// Runs the steps associated with this time
		/// </summary>
		public void RunSteps()
		{
			if (currentState != HwoClassState.HWO_RUNNING)
			{
				currentState = HwoClassState.HWO_RUNNING;
			}
			if (failureOccurred && !ContinueOnFailures)
			{
				return;
			}
			if (lastAbsoluteRunTime == currentAbsoluteTime)
			{
				return;
			}
			ArrayList steps = (ArrayList) stepsForAbsoluteTime[currentAbsoluteTime];
			if (steps == null)
			{
				throw new Exception("There should never be no steps associated with a particular time");
			}
			DateTime currentTime = Form1.currTime;
			//currentTime = currentTime.AddDays(currentAbsoluteTime);
			Log("------ Current time for this set of steps:" + currentTime.ToString() + " ------");
			foreach (CaseStep step in steps)
			{
				if (step == null)
				{
					// Should be an assert
					throw new Exception("Error: null Step");
				}
				step.Parent = this;

				// Copied from Case.cs
	
				this.lwo.Code = Case.PassCode.Running;
				bool b=false;
				bool exceptionOccured = false;  // Used to tract if we see an exception
				uint retryCount = 0;            // Allows us to retry several times when an exception is received
				uint maxRetries = 5;            // Defines how many exceptions we'll tolerate before giving up
				System.Random randomBackoff = new Random();
				// Try up to 5 times when an exception is responsible for the failure
				do
				{
					exceptionOccured = false;

					if(retryCount > 0)
					{
						// Backoff on exceptions
						step.Log("Retry #" + retryCount + " of " + maxRetries);
						step.Log("Backing off for random 5-25 second interval");
						Thread.Sleep(5000 + randomBackoff.Next(20000));
					}

					try
					{
						b=true;
						// COMMENT THIS OUT FOR TESTING WITHOUT 1-BOX CALLS
						b=step.Execute();
						currentStepIndex++;
					}
					catch(SoapException e)
					{
						BdkInterface bdk=new BdkInterface();
						bdk.ParseError(e.Message);
						step.Log("Failed with 0x"+((uint)bdk.LastErrorCode).ToString("X")+" - "+bdk.LastError);
						b=false;
						exceptionOccured = true;
					}
					catch(Exception e)
					{
						step.Log("Failed with exception");
						step.Log(e.Message);
						step.Log(e.StackTrace);
						b=false;
						exceptionOccured = true;
					}
					retryCount++;
				}
				while(exceptionOccured && retryCount <= maxRetries);
				if (!b)
				{
					FailureCount++;
					failureOccurred=true;
					OutputLog.Add(step.Header+" FAILED");
					// If you were to remove this break, a case would continue executing after a failure
					// ... it looks like that is not the wanted behavior, so I added a break here
					if(!this.ContinueOnFailures)
						break;

					// Added a sleep when errors are detected so that one error doesn't cause cascading
					// errors as multiple tests swamp the available sockets
					Thread.Sleep(5000);
				}

			
			}
			if ((totalSteps == currentStepIndex) || (failureOccurred))
			{
				currentState = HwoClassState.HWO_FINISHED;
				OutputLog.Add("Case "+Name+" completed");
				if (failureOccurred)
				{
					this.lwo.Code=Case.PassCode.Failed;

					// search for test case in result array and update result
					CaseResult searchCase = new CaseResult(Name, Global.TestCode.Failed, null);
					int caseIndex = Global.ResultArray.IndexOf(searchCase);
					((CaseResult)(Global.ResultArray[caseIndex])).TestErrors = OutputLog;
				}	
				else
				{
					this.lwo.Code=Case.PassCode.Passed;

					// search for test case in result array and update result
					CaseResult searchCase = new CaseResult(Name, Global.TestCode.Passed, null);
					int caseIndex = Global.ResultArray.IndexOf(searchCase);
					((CaseResult)(Global.ResultArray[caseIndex])).TestStatus = Global.TestCode.Passed;
				}
			}
			// END Copied from Case.cs
			lastAbsoluteRunTime = currentAbsoluteTime;
		}

		/// <summary>
		/// 
		/// </summary>
		public int LoadStepsForAbsoluteTime(int newAbsoluteTime)
		{
			if (currentState == HwoClassState.HWO_INITIALIZED)
			{
				currentState = HwoClassState.HWO_RUNNING;
			}
			if (currentState != HwoClassState.HWO_RUNNING)
			{
				throw new Exception("Function called in invalid state.  Expected: " + HwoClassState.HWO_RUNNING + " Actual: " + currentState);
			}
			if (nextAbsoluteTime == -1)
			{
				throw new Exception("Error: Test should have been finished");				
			}
			if (newAbsoluteTime < nextAbsoluteTime)
			{
				// Don't care about this roll, but we should not have been called with it
				//throw new Exception("Error: No steps for this time roll");
			}
			if (newAbsoluteTime > nextAbsoluteTime)
			{
				throw new Exception("Error: this function should never be called with a time in the future");
			}
			currentAbsoluteTime = (int) absoluteTimeSet.Dequeue();
			if (absoluteTimeSet.Count != 0)
			{
				nextAbsoluteTime = (int) absoluteTimeSet.Peek();
			}
			else
			{
				nextAbsoluteTime = -1;
			}
			if (absoluteTimeSet.Count == 0)
			{
				currentState = HwoClassState.HWO_FINISHED;
			}
			return nextAbsoluteTime;
		}

		/// <summary>
		/// Currently only supports serializing once the class is in the running state
		/// Otherwise, we have no way of determining what state we are in
		/// </summary>
		/// <returns></returns>
		public string Serialize()
		{
			if (currentState != HwoClassState.HWO_RUNNING)
			{
				throw new Exception("Function called in invalid state.  Expected: " + HwoClassState.HWO_RUNNING + " Actual: " + currentState);
			}
			Stream strmWrite;
			strmWrite = File.OpenWrite(filename);
			SoapFormatter sf = new SoapFormatter();
			sf.Serialize(strmWrite, this);
			strmWrite.Close();
			currentState = HwoClassState.HWO_STALE;
			return filename;
		}

		public bool IsDone()
		{
			return (HwoClassState.HWO_FINISHED == currentState);
		}

		/// <summary>
		/// Make sure we aren't doing anything we should not
		/// </summary>
		private void SetNeedsReinit()
		{
			currentState = HwoClassState.HWO_NEEDS_REINIT;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="filename"></param>
		/// <returns></returns>
		public static HeavyweightObject Deserialize(string filename)
		{
			HeavyweightObject hwo;
			Stream strmRead;
			strmRead = File.OpenRead(filename);
			SoapFormatter soapFormatter = new SoapFormatter();
			hwo = (HeavyweightObject) soapFormatter.Deserialize(strmRead);
			strmRead.Close();
			hwo.SetNeedsReinit();
			return hwo;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="s"></param>
		public void Log(string s)
		{
			Console.WriteLine(s);
			lock(this)
			{
				OutputLog.Add(s);
			}
		}

		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public ArrayList GetLog()
		{
			ArrayList logCopy = new ArrayList();
			lock(this)
			{
				logCopy.AddRange(OutputLog);
			}
			return logCopy;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\ScriptXeExaustiveRenewalPaths.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;


namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// An exaustive test of all available renewal paths
	/// </summary>
	public class ScriptXeExaustiveRenewalPaths : Script
	{
		ArrayList timeRollArrays;

		public ScriptXeExaustiveRenewalPaths()
		{
		}

		override public ArrayList GetRolls()
		{
			return timeRollArrays;
		}

		public Case GenerateCase(Global.OfferType offerRenewingFrom, Global.OfferType offerRenewingTo, bool ExpectConvert, XeUser.Country countrycode, bool defaultsCases)
		{
			int currentStep = 0;
			ArrayList buildSteps = new ArrayList();
			string name = countrycode.ToString() + ": From " + RenewalMatrix.Global.GetOfferFriendlyName(offerRenewingFrom) +
				" ("+ ((ulong) offerRenewingFrom).ToString("X") + ") to " + RenewalMatrix.Global.GetOfferFriendlyName(offerRenewingTo) + " (" + ((ulong) offerRenewingTo).ToString("X") + ")";

			List<TimeRoll> TimeRollsForCase = new List<TimeRoll>();			

			if (!defaultsCases)
			{
				if (offerRenewingFrom == offerRenewingTo)
				{
					if ((offerRenewingFrom == RenewalMatrix.Global.OfferType.XeMonthlyCC) ||
						(offerRenewingFrom == RenewalMatrix.Global.OfferType.XeYearlyCC) ||
						(offerRenewingFrom == RenewalMatrix.Global.OfferType.XeThreeMonthCC))
					{
						return null;
					}
				}
			}
		
			if (!ExpectConvert)
			{
				name+= " not expecting a conversion";
				if (offerRenewingFrom == RenewalMatrix.Global.OfferType.XeMigration)
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(RenewalMatrix.Global.OfferType.LaunchOffer),countrycode));
					//buildSteps.Add(new StepSetRenewal(RenewalMatrix.Global.OfferType.Monthly599));
					buildSteps.Add(new StepVerify(RenewalMatrix.Global.OfferType.LaunchOffer));
					TimeRollsForCase.Add(new TimeRoll("Roll "+ currentStep +" - "+((int) RenewalMatrix.Global.OfferLength.LaunchOffer-1).ToString()+" Month",TimeRollType.month,(int) RenewalMatrix.Global.OfferLength.LaunchOffer-1));
					buildSteps.Add(new StepWaitForRoll(TimeRollsForCase[currentStep]));								// Roll to get OUT of the initial offer					
					currentStep++;
					buildSteps.Add(new StepMigrateAccountToXenon());										// Migrate the account
				}				
                else
			    {
                    if (offerRenewingFrom == Global.OfferType.XeTwelveMonthProm)
                    {
                        buildSteps.Add(new StepCreateFreeAccount(countrycode, false));                        
                        buildSteps.Add(new StepSetRenewal(offerRenewingFrom, StepSetRenewal.ExpectConvert.DontCare, countrycode));			
                    }
                    else
                    {
                        buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(offerRenewingFrom), countrycode, true));
                    }
				}
		
				buildSteps.Add(new StepVerify(offerRenewingFrom));
				if (!defaultsCases)
					buildSteps.Add(new StepSetRenewal(offerRenewingTo, RenewalMatrix.StepSetRenewal.ExpectConvert.DontCare, countrycode));
				int CurrentOfferLength = RenewalMatrix.Global.GetOfferLengthFromOffer(offerRenewingFrom);
				if (CurrentOfferLength > 1)
				{
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - "+(CurrentOfferLength-1)+" Month",TimeRollType.month,CurrentOfferLength-1));
				}
				else
				{
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - 2 weeks",TimeRollType.week,2));
				}
				buildSteps.Add(new StepWaitForRoll(TimeRollsForCase[currentStep]));								// Roll to get OUT of the initial offer					
				currentStep++;
				buildSteps.Add(new StepVerify(offerRenewingFrom));
				if (CurrentOfferLength > 1)
				{
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - 1 Month",TimeRollType.month,1, true));
				}
				else
				{
                    //no more buffer, check should be done right at the end of the month
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - EOM",TimeRollType.end_of_month,1, true));
				}
				buildSteps.Add(new StepWaitForRoll(TimeRollsForCase[currentStep]));								// Roll to get OUT of the initial offer					
				if (offerRenewingTo != Global.OfferType.XeFree)
					buildSteps.Add(new StepVerify(offerRenewingTo));
				else
					buildSteps.Add(new StepVerifyFreeOffer());
			}
			else
			{			
				name+= " expecting a conversion";
				if (offerRenewingFrom == RenewalMatrix.Global.OfferType.XeMigration)
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(RenewalMatrix.Global.OfferType.LaunchOffer),countrycode));
					//buildSteps.Add(new StepSetRenewal(RenewalMatrix.Global.OfferType.Monthly599));
					TimeRollsForCase.Add(new TimeRoll("Roll "+ currentStep +" - "+((int) RenewalMatrix.Global.OfferLength.LaunchOffer-1).ToString()+" Month",TimeRollType.month,(int) RenewalMatrix.Global.OfferLength.LaunchOffer-1));
					buildSteps.Add(new StepWaitForRoll(TimeRollsForCase[currentStep]));								// Roll to get OUT of the initial offer					
					currentStep++;
					buildSteps.Add(new StepMigrateAccountToXenon());										// Migrate the account
				}                
                else
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(offerRenewingFrom),countrycode, true));
				}
		
				buildSteps.Add(new StepVerify(offerRenewingFrom));
				if (!defaultsCases)
					buildSteps.Add(new StepSetRenewal(offerRenewingTo, RenewalMatrix.StepSetRenewal.ExpectConvert.DontCare, countrycode));
				buildSteps.Add(new StepVerify(offerRenewingTo));
				int CurrentOfferLength = RenewalMatrix.Global.GetOfferLengthFromOffer(offerRenewingFrom) + RenewalMatrix.Global.GetOfferLengthFromOffer(offerRenewingTo);
				if ((Global.OfferType.XeMonthlyCC == offerRenewingFrom) && (Global.IsCreditCardOffer(offerRenewingTo)))
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - "+(CurrentOfferLength-2)+" Month",TimeRollType.month,CurrentOfferLength-2));
				else
					TimeRollsForCase.Add(new TimeRoll("Roll "+currentStep+" - "+(CurrentOfferLength-1)+" Month",TimeRollType.month,CurrentOfferLength-1));
				buildSteps.Add(new StepWaitForRoll(TimeRollsForCase[currentStep]));								// Roll to get OUT of the initial offer					
				currentStep++;
                if (offerRenewingTo != Global.OfferType.XeFree)
					buildSteps.Add(new StepVerify(offerRenewingTo));
				else
					buildSteps.Add(new StepVerifyFreeOffer());
			}
			timeRollArrays.Add(TimeRollsForCase.ToArray());

			return new Case((CaseStep[])buildSteps.ToArray(typeof(CaseStep)),name);
		}

		public ArrayList GetOfferRenewals(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode)
		{
			ArrayList baseOffers = new ArrayList();

            if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthProm); 
            //if(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.PT)
            //    baseOffers.Add(RenewalMatrix.Global.OfferType.XeMigration);
			if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
			{
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeYearCC);
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwoYearCC);
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
			    //baseOffers.Add(RenewalMatrix.Global.OfferType.XeDiscountYearlyCC);
			}
			if ((CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.HK) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.TW) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.SG))
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthTrial);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);
			/*if (CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.US ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.CA)*/
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid);
			return baseOffers;
		}

		public ArrayList GetOfferConverts(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode)
		{
			ArrayList baseOffers = new ArrayList();

            if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthProm);
            //if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.PT)
            //    baseOffers.Add(RenewalMatrix.Global.OfferType.XeMigration);
			if ((CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.HK) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.TW) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.SG))
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);

			if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
			{
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeMonthlyCC);
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeYearCC);
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwoYearCC);
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
                //baseOffers.Add(RenewalMatrix.Global.OfferType.XeDiscountYearlyCC);
			}

			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthTrial);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);
            
			if (CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.US ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.CA)
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid);

            //baseOffers.Add(RenewalMatrix.Global.OfferType.XeFree);
			//baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid);
			//baseOffers.Add(RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid);
             
             
			return baseOffers; 
		}
        
		public ArrayList GetOfferRenewTo(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode, RenewalMatrix.Global.OfferType BaseOffer)
		{
			ArrayList returnedOffers = new ArrayList();
			switch (BaseOffer)
			{
				case RenewalMatrix.Global.OfferType.XeMigration:
				case RenewalMatrix.Global.OfferType.XeThreeYearCC:
				case RenewalMatrix.Global.OfferType.XeTwoYearCC:
				case RenewalMatrix.Global.OfferType.XeYearlyCC:                
				case RenewalMatrix.Global.OfferType.XeThreeMonthCC:
				case RenewalMatrix.Global.OfferType.XeOneMonthTrial:
				case RenewalMatrix.Global.OfferType.XeOneMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid:

                    if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US 
                            && BaseOffer != RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid)
                    {
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthProm);	
                    }
				
                    if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
					{
						//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeYearCC);
						//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwoYearCC);
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeMonthlyCC);
					}
					if ((CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.HK) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.TW) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.SG))
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);					
					break;
				case RenewalMatrix.Global.OfferType.XeMonthlyCC:
					throw new ArgumentException("Monthly offers do not renew");
				case RenewalMatrix.Global.OfferType.XeFree:
					throw new ArgumentException("Free offers do not renew");
                case RenewalMatrix.Global.OfferType.XeTwelveMonthProm:
                    if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                    {
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeMonthlyCC);
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);
                    }
                    break;
			}
			return returnedOffers;
		}

		public ArrayList GetOfferConvertTo(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode, RenewalMatrix.Global.OfferType BaseOffer)
		{
			ArrayList returnedOffers = new ArrayList();
			switch (BaseOffer)
			{
                
				case RenewalMatrix.Global.OfferType.XeMigration:
				case RenewalMatrix.Global.OfferType.XeThreeYearCC:
				case RenewalMatrix.Global.OfferType.XeTwoYearCC:
				case RenewalMatrix.Global.OfferType.XeYearlyCC:                
				case RenewalMatrix.Global.OfferType.XeThreeMonthCC:
				case RenewalMatrix.Global.OfferType.XeOneMonthTrial:
				case RenewalMatrix.Global.OfferType.XeOneMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid:
					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);
					/*if (CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.US ||
						CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP ||
						CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.CA)*/
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid);

					//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid);
					//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid);
					break;
                case RenewalMatrix.Global.OfferType.XeTwelveMonthProm:
                    if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                    {
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);
                    }
                    break;


				case RenewalMatrix.Global.OfferType.XeMonthlyCC:
                case RenewalMatrix.Global.OfferType.XeFree:

                    if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                    {
                        returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthProm);
                    }

					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
					returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);
					/*if (CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.US ||
						CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP ||
						CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.CA)*/
				     returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid);

					//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid);
					//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid);
					if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
					{
						//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeYearCC);
						//returnedOffers.Add(RenewalMatrix.Global.OfferType.XeTwoYearCC);
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeMonthlyCC);
					}
					if ((CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.HK) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.TW) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR) &&
						(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.SG))
						returnedOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);
					break;                
            }
			return returnedOffers;
		}

		public ArrayList GetOfferDefaults(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode)
		{
            ArrayList baseOffers = new ArrayList();

            //if(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.PT)
            //    baseOffers.Add(RenewalMatrix.Global.OfferType.XeMigration);
			if (CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
			{
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeYearCC);
				//baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwoYearCC);
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeYearlyCC);
                //baseOffers.Add(RenewalMatrix.Global.OfferType.XeDiscountYearlyCC);
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeMonthlyCC);
			}

			if ((CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.HK) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.TW) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR) &&
				(CountryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.SG))
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthCC);

			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthTrial);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeOneMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid);
			baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid);

            if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
            baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwelveMonthProm);

			if (CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.US ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP ||
				CountryCode ==ServerTestFramework.LiveService.UserAccount.XeUser.Country.CA)
				baseOffers.Add(RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid);

			//baseOffers.Add(RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid);
			//baseOffers.Add(RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid);
			return baseOffers; 
		}

		public RenewalMatrix.Global.OfferType GetOfferDefaultTo(ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryCode, RenewalMatrix.Global.OfferType BaseOffer)
		{
			ArrayList returnedOffers = new ArrayList();
			switch (BaseOffer)
			{
				case RenewalMatrix.Global.OfferType.XeMigration:
				case RenewalMatrix.Global.OfferType.XeThreeYearCC:
				case RenewalMatrix.Global.OfferType.XeTwoYearCC:
				case RenewalMatrix.Global.OfferType.XeYearlyCC:               
                case RenewalMatrix.Global.OfferType.XeTwelveMonthProm:
					if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP)
						return RenewalMatrix.Global.OfferType.XeMonthlyCC;
					if (CountryCode == ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
						return RenewalMatrix.Global.OfferType.XeFree;
					return RenewalMatrix.Global.OfferType.XeYearlyCC;
				case RenewalMatrix.Global.OfferType.XeMonthlyCC:
                    return RenewalMatrix.Global.OfferType.XeMonthlyCC;
                case RenewalMatrix.Global.OfferType.XeThreeMonthCC:
                    return RenewalMatrix.Global.OfferType.XeThreeMonthCC;
                case RenewalMatrix.Global.OfferType.XeOneMonthTrial:
				case RenewalMatrix.Global.OfferType.XeOneMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThreeMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwelveMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirteenMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeTwentyFourMonthPrepaid:
				case RenewalMatrix.Global.OfferType.XeThirtySixMonthPrepaid:
					return RenewalMatrix.Global.OfferType.XeFree;
               			// not used
				//case RenewalMatrix.Global.OfferType.XeFree:

			}
			throw new ArgumentException("Invalid offer type specified");
		}

		// Silver -> PP - Convert
		// PP -> PP		- Convert
		// Silver -> CC - Convert
		// PP -> CC		- Renew
		// CC -> CC		- Depends ( Montly -> Any - Convert / All others -> Any - Renew )

		// Defaults
		// PP -> None (All)
		// CC -> Auto Renew (No CC for Korea)
		// Migration -> Yearly	(All but below)
		// Migration -> Monthly (Japan)
		// Migration -> None	(Korea)


		protected override void Initialize()
		{
			ArrayList caseList = new ArrayList();
			ArrayList OfferRenewals = new ArrayList();
			ArrayList OfferConverts = new ArrayList();
			ArrayList OfferDefaults = new ArrayList();
			timeRollArrays = new ArrayList();

			//string countryname;
			//ServerTestFramework.LiveService.UserAccount.XeUser.Country countrycode;

			foreach (ServerTestFramework.LiveService.UserAccount.XeUser.Country cc in Form1.Countries)
			{
                if ((!(cc == XeUser.Country.US /*|| cc == XeUser.Country.CA  || 
                   cc == XeUser.Country.JP /*|| cc == XeUser.Country.UK*/))) continue;

				OfferRenewals = GetOfferRenewals(cc);
				OfferConverts = GetOfferConverts(cc);
				OfferDefaults = GetOfferDefaults(cc);

				foreach (RenewalMatrix.Global.OfferType ot in OfferRenewals)
				{
					ArrayList OfferRenewTo = GetOfferRenewTo(cc, ot);                                     
					foreach (RenewalMatrix.Global.OfferType renewToOT in OfferRenewTo)
					{
                        //if (!((ot == Global.OfferType.XeOneMonthTrial) ||  (ot == Global.OfferType.XeOneMonthPrepaid))) continue;
                        //if (ot != Global.OfferType.XeTwelveMonthProm) continue;
						Case caseToAdd = GenerateCase(ot, renewToOT, false, cc, false);
						if (caseToAdd != null)
							caseList.Add(caseToAdd);
                        break;
					}
				}
                
				foreach (RenewalMatrix.Global.OfferType ot in OfferConverts)
				{
					ArrayList OfferConvertTo = GetOfferConvertTo(cc, ot);
					foreach (RenewalMatrix.Global.OfferType renewToOT in OfferConvertTo)
					{
                        //if (ot != Global.OfferType.XeMonthlyCC) continue;
                        //if (renewToOT != Global.OfferType.XeTwelveMonthProm) continue;
						Case caseToAdd = GenerateCase(ot, renewToOT, true, cc, false);

						if (caseToAdd != null)
							caseList.Add(caseToAdd);
					}
				}

			   foreach (RenewalMatrix.Global.OfferType ot in OfferDefaults)
				{
					RenewalMatrix.Global.OfferType OfferDefaultTo = GetOfferDefaultTo(cc, ot);

                    //if (ot != Global.OfferType.XeThreeMonthPrepaid) continue;
                    //if (OfferDefaultTo != Global.OfferType.XeThreeMonthCC) continue;
					Case caseToAdd = GenerateCase (ot, OfferDefaultTo, false, cc, true);
                   
					
					if (caseToAdd != null)
						caseList.Add(caseToAdd);
				}
			}
			cases = (Case[]) caseList.ToArray(typeof(Case));
		}  
//		protected override void Initialize()
//		{
//            timeRollArrays = new ArrayList();
//            
//            List<Case> caseList = new List<Case>();
//
//            caseList.Add(GenerateCase(Global.OfferType.XeYearlyCC, Global.OfferType.XeMonthlyCC, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeYearlyCC, Global.OfferType.XeThreeMonthCC, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeDiscountYearlyCC, Global.OfferType.XeThreeMonthCC, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeThreeMonthCC, Global.OfferType.XeMonthlyCC, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeOneMonthTrial, Global.OfferType.XeThreeMonthCC, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeOneMonthTrial, Global.OfferType.XeOneMonthPrepaid, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeOneMonthTrial, Global.OfferType.XeThreeMonthPrepaid, false, XeUser.Country.IN, false, false));
//            caseList.Add(GenerateCase(Global.OfferType.XeOneMonthTrial, Global.OfferType.XeTwelveMonthPrepaid, false, XeUser.Country.IN, false, false));
//            
//            cases = (Case[])caseList.ToArray();
//
//		}  
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\ScriptHelper.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.Xml;
using System.Reflection;
using ServerTestFramework.LiveService.UserAccount;

namespace RenewalMatrix.New_Code
{
    public class ScriptHelper
    {
        public uint[] Matrices;
        public uint[] UserAccounts;

        //Stores the user selected test case filter information.
        private Hashtable FilterTable;
        public Type CallingObject;       

        public ScriptHelper(int matrixSize, Global.UserAccountType skipUt, Type callingObject)
        {
            init(matrixSize, skipUt);
            CallingObject = callingObject;
        }

        public void init(int matrixSize, Global.UserAccountType skipUt)
        {
            int i;
            Global.UserAccountType uat = new Global.UserAccountType();
            Global.MatrixType mt = new Global.MatrixType();

            //populate the UserAccounts array with UserAccountType enum			
            FieldInfo[] fields = typeof(Global.UserAccountType).GetFields();
            
            //logic to skip a single Useraccount type
            if (skipUt != Global.UserAccountType.AccountTypeNone)
            {
                UserAccounts = new uint[fields.Length - 3];                
            }
            else
            {
                UserAccounts = new uint[fields.Length - 2];
            }
            int j = 0;
            for (i = 1; i < fields.Length -1; i++)
            {
                if (skipUt != Global.UserAccountType.AccountTypeNone && skipUt != ((Global.UserAccountType)fields[i].GetValue(uat)))
                {
                    UserAccounts[j] = (uint)fields[i].GetValue(uat);
                    j++;
                }
                else if (skipUt == Global.UserAccountType.AccountTypeNone)
                {
                    UserAccounts[i-1] = (uint)fields[i].GetValue(uat);
                }
            }

            //populate the matrices array with MatrixType enum
            FieldInfo[] fields2 = typeof(Global.MatrixType).GetFields();
            Matrices = new uint[matrixSize];
            for (i = 1; i <= matrixSize; i++)
            {
                Matrices[i - 1] = (uint)fields2[i].GetValue(mt);
            }
        }

        private XmlDocument GenerateFilterXml()
        {
            XmlDocument filterValues = new XmlDocument();
            filterValues.AppendChild(filterValues.CreateElement("entire"));
            XmlElement allCountryEl = filterValues.DocumentElement;
            allCountryEl.SetAttribute("name", "All Countries");

            foreach (ServerTestFramework.LiveService.UserAccount.XeUser.Country cc in  Form1.Countries)
            {
                XmlElement countryEl = (XmlElement)allCountryEl.AppendChild(filterValues.CreateElement("Country"));
                countryEl.SetAttribute("name", cc.ToString());
                foreach (Global.MatrixType mt in Matrices)
                {
                    XmlElement matrixEl = (XmlElement)countryEl.AppendChild(filterValues.CreateElement("Matrix"));
                    matrixEl.SetAttribute("name", mt.ToString());                    
                    foreach (Global.UserAccountType uat in UserAccounts)
                    {
                        XmlElement acctTypeEl = (XmlElement)matrixEl.AppendChild(filterValues.CreateElement("UserAccountType"));
                        acctTypeEl.SetAttribute("name", uat.ToString());
                    }
                }
            }
            return (filterValues);
        }
        private void ConsumeXml(XmlDocument xml)
        {
            FilterTable = new Hashtable();
            XmlElement xEl = xml.DocumentElement;            
            foreach (XmlElement xCountry in xEl.ChildNodes)
            {
                FilterObject fObj = new FilterObject();
                fObj.CountryValue = (ServerTestFramework.LiveService.UserAccount.XeUser.Country) Enum.Parse(typeof(ServerTestFramework.LiveService.UserAccount.XeUser.Country), xCountry.GetAttribute("name"), true);
                fObj.MatrixValue = 0;
                foreach (XmlElement xMatrix in xCountry.ChildNodes)
                {
                    fObj.MatrixValue = fObj.MatrixValue | (uint)Enum.Parse(typeof(Global.MatrixType), xMatrix.GetAttribute("name"), true);
                    uint userAcctVal = 0;
                    foreach (XmlElement xUserAcct in xMatrix.ChildNodes)
                    {
                        userAcctVal = userAcctVal | (uint)Enum.Parse(typeof(Global.UserAccountType), xUserAcct.GetAttribute("name"), true);
                    }
                    fObj.UserAccountValue.Add(userAcctVal);
                }
                FilterTable.Add(xCountry.GetAttribute("name"), fObj);             
            }
        }

        public FilterObject GetObject(string key)
        {
            if (!FilterTable.ContainsKey(key))
            {
                return null;
            }
           FilterObject fObj = ((FilterObject)FilterTable[key]);
           return fObj;
        }
        
        public void ObtainTestFilters()
        {
            XmlDocument filterValues = GenerateFilterXml();
            FilterForm fForm = new FilterForm(CallingObject);
            fForm.LoadTree(filterValues);
            fForm.ShowDialog();
            ConsumeXml(fForm.ReturnXmlDoc);
        }
    }

    public class FilterObject
    {
        public ServerTestFramework.LiveService.UserAccount.XeUser.Country CountryValue;
        public uint MatrixValue;
        public ArrayList UserAccountValue;

        public FilterObject()
        {
            UserAccountValue = new ArrayList();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\ScriptZuneSubscriptions.cs ===
using System;
using System.Collections;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;


namespace RenewalMatrix.New_Code
{
    class ScriptZuneSubscriptions : Script
    {
        ArrayList timeRollArrays;
		public const uint TITLEID = 0xFFFE0777; //Title which offers the Argo subscription
		public const uint SERVICEID1 = 0xFFFE0777;// Service associated with the Argo subscription
        public const int MATRIXSIZE = 7;

        //This class provides the ability to set Country/Matrix/Useraccountype filters to select a subset of test cases
        public RenewalMatrix.New_Code.ScriptHelper scriptHelper;

		public enum RollTimeCmp
		{
			Equal,
			LessThan,
			GreaterThan
		}

		public ScriptZuneSubscriptions()
		{
			//
			// TODO: Add constructor logic here
			//
			
		}

		public override ArrayList GetRolls()
		{
			return timeRollArrays;
		}

		public static string MatrixDescription(Global.MatrixType mt)
		{
			string desc;
			switch(mt)
			{
				case Global.MatrixType.MatrixOne:
				{
					desc = "Initial ArgoSub Purchase and Default Renewal";
					break;
				}
				case Global.MatrixType.MatrixTwo:
				{
					desc = "Stacking of ArgoSub Offers";
					break;
				}
				case Global.MatrixType.MatrixThree:
				{
					desc = "ArgoSub Renewal Change";
					break;
				}
				case Global.MatrixType.MatrixFour:
				{
					desc = "Cancelled ArgoSub- Repurchase after an interval";
					break;
				}
				case Global.MatrixType.MatrixFive:
				{
					desc = "User Account Changes during ArgoSub";
					break;
				}
                case Global.MatrixType.MatrixSix:
                {
                    desc = "Cancelled ArgoSub- Immediate Repurchase";
                    break;
                }
                case Global.MatrixType.MatrixSeven:
                {
                    desc = "Additional 14-day Trial cases";
                    break;
                }
				default:
				{
					throw new ArgumentException("Incorrect MatrixType: ");
				}
			}
			return desc;
		}

		protected int EstimateRollTime(Global.OfferType currentOffer, RollTimeCmp timeCmp, out RenewalMatrix.TimeRollType rollType)
		{
			int offerLen = Global.GetOfferLengthFromOffer(currentOffer);
			int estimatedTime = 0;
			rollType = TimeRollType.week;

            //Estimating the clock roll time on the SCG side based on the offerlength.
            //If RollTimeCmp.LessThan implies clock roll is less than or equal to half the offerlength
            //HACK: to include processing in days to accomodate Trial offers
            if (timeCmp == RollTimeCmp.LessThan && Global.IsOfferLengthInDays(currentOffer))
            {
                rollType = TimeRollType.day;
                return 8;
            }
            else if (timeCmp == RollTimeCmp.GreaterThan && Global.IsOfferLengthInDays(currentOffer))
            {
                rollType = TimeRollType.day;
                return 10;
            }
			else if( timeCmp == RollTimeCmp.LessThan)
			{
				switch(offerLen)
				{
					case 1:
					{
						estimatedTime = 2;
						rollType = TimeRollType.week;
						break;
					}
					case 3:
					{
						estimatedTime = 6;
						rollType = TimeRollType.week;
						break;
					}
					case 12:
					{
						estimatedTime = 5;
						rollType = TimeRollType.month;
						break;
					}
				}
			}
            // If RollTimeCmp.GreaterThan implies clock roll is greater than half the offerlength
            else if (timeCmp == RollTimeCmp.GreaterThan)
            {
                switch (offerLen)
                {
                    case 0:
                        {
                            estimatedTime = 2;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 1:
                        {
                            estimatedTime = 3;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 3:
                        {
                            estimatedTime = 8;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 12:
                        {
                            estimatedTime = 31; // We want it to be less than 8 months!
                            rollType = TimeRollType.week;
                            break;
                        }
                }
            }
            else
            {
                switch (offerLen)
                {
                    case 1:
                        {
                            estimatedTime = 1;
                            rollType = TimeRollType.month;
                            break;
                        }
                    case 3:
                        {
                            estimatedTime = 3;
                            rollType = TimeRollType.month;
                            break;
                        }
                    case 12:
                        {
                            estimatedTime = 12;
                            rollType = TimeRollType.month;
                            break;
                        }
                }
            }
			return estimatedTime;
		}

		public Case GenerateCase(Global.MatrixType matrixType, Global.UserAccountType userAccount, Global.OfferType initialArgoSub, Global.OfferType futureArgoSub, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList buildSteps = new ArrayList();
			string name; // CASE NAME
			int currentStep = 0;
			// clock roll steps, currently 2 are required for every matrix except 4
			int numSteps = 2;
			if(matrixType == Global.MatrixType.MatrixFour)
			{
				numSteps = 3;
			}
			int rollTime;
			TimeRoll[] timeRollsForCase;
			timeRollsForCase = new TimeRoll[numSteps];
			TimeRollType tRollType;

			try
			{
				name = countryCode.ToString() + ": " + matrixType.ToString() + "(User: " + userAccount.ToString() + ")"+ " - " + MatrixDescription(matrixType) + 
					" Initial ArgoSub:" + RenewalMatrix.Global.GetOfferFriendlyName(initialArgoSub)+ "; " + "Future ArgoSub:" + RenewalMatrix.Global.GetOfferFriendlyName(futureArgoSub);
			}
			catch(Exception)
			{
				throw;
			}
			/***************************************************************************************************************************
			STEP: intial case steps depend on the type of the user 
			******************************************************************************************************************************/
			switch(userAccount)
			{
				case Global.UserAccountType.AccountTypeSilver:
				{
					buildSteps.Add(new StepCreateFreeAccount(countryCode));
					break;
				}
				case Global.UserAccountType.AccountTypeArgo:
				{
                    bool ArgoAccount = true;
                    buildSteps.Add(new StepCreateFreeAccount(countryCode, ArgoAccount));
					break;
				}
				case Global.UserAccountType.AccountTypeGold:
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(RenewalMatrix.Global.OfferType.XeYearlyCC), countryCode, true));
					break;
				}
				default:
				{
					throw new ArgumentException("Invalid UserAccountType!");
				}
			}

			/*****************************************************************************************************************************
			Steps which are common to all the matrices
			STEP: Able to enumerate the Argo subscription offer
			STEP: Verify whether the service associated with the title FFFF0095 is available to the user - should be NOT GRANTED SERVICE
			STEP: Purchase Argo subscription based on the initialArgoSub
			STEP: Verify the Argo subscription is the same as purchased
			STEP: Verify whther the service associated with the title FFFF0095 is available to the user - should be GRANTED SERVICE
			******************************************************************************************************************************/
			buildSteps.Add(new StepVerifyXeEnumerate());
			//buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, false));
			//TODO: Fix me so that offers can be purchased using tokens
            if(Global.IsCreditCardOffer(initialArgoSub))
            {
			    buildSteps.Add(new StepPurchaseOffer(initialArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
            }
            else
            {
                buildSteps.Add(new StepPurchaseOffer(initialArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
            }
			buildSteps.Add(new StepVerifyPremiumSubscription(initialArgoSub,TITLEID));
			//buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));

            /***************************************************************************************************************************
            Steps specific to Matrices
            MatrixOne-
                STEP: Clock roll the one-box by a substantial amount of time (less than the offer length)
                STEP: Verify the service is granted to the user.
                STEP: Verify the Argo subscriptions details matches what was purchased.  i.e. start and end date, default renewal etc.
                STEP: Clock-roll the one-box by a amount of time greater than current offer length, such that the subscription advances into default renewal.
                STEP: Verify that the user has a subscription and the service associated with the title is granted to the user.
            MatrixTwo-CONVERSION
                STEP: Clock-roll the one-box by a substantial amount of time (less than current offer length)
                STEP: Stack another prepaid offer to the current offer and the subscription details should enlist the new offer as the current offer and also increase the subscription period by required amount of time.
                STEP: Clock-roll the one-box by a period such that the date is after the old offer end date and before the new offer end date.
                STEP: Verify the service corresponding to the Title is granted to the user.
            MatrixThree-RENEWAL
                STEP: Clock-roll the one-box by a substantial amount of time ( less than current offer length)
                STEP: Change the default subscription renewal to the one specified in the test case.
                STEP: Verify from the subscription details whether the renewal has been set to the new renewal.
                STEP: Clock-roll the one-box such that renewal sets in.
                STEP: Verify whether the current subscription is the new subscription.
            MatrixFour- CANCELLATION Of PREMIUM SUBS AND REPURCHASE AFTER AN INTERVAL
                STEP: Clock-roll the one-box by a substantial amount of time ( < current offer length).
                STEP: Cancel the offers using the OfferingCancel api used by xbox.com
                STEP: Clock-roll so that you are safely out of the cancelled offers period.                
                STEP: Depending on the Test case purchase or redeem the final Argo subscription.
                STEP: Clock-roll the one-box by a substantial amount of time ( <  current offer length).
                STEP: Verify that the current offer is the new offer  with the corresponding start and end dates.               
            MatrixFive-
                STEP: Clock roll substantial amount of time such that (for Gold account) user has been downgraded. 
                      If Gold then clock roll by a year else clockroll by 2 weeks.
                STEP: For Silver account purchase a live a gold subscription.               
            MatrixSix- CANCELLATION Of PREMIUM SUBS AND IMMEDIATE REPURCHASE
                STEP: Clock-roll the one-box by a substantial amount of time ( > current offer length), so the subscription expires.
                STEP: Cancel the credit card offers (prepaid offers have expired)
                STEP: Clock-roll two weeks.
                STEP: Verify that the service is unavailable to the user.
                STEP: Depending on the Test case purchase or redeem the final Argo subscription.
                STEP: Clock-roll the one-box by a substantial amount of time ( <  current offer length).
                STEP: Verify that the current offer is the new offer (Offer after Expiration/Cancellation column in the table above) with the corresponding start and end dates.
                STEP: Verify that the user has access to the service corresponding to the Argo subscription.
             MatrixSeven- ADDITIONAL 14 DAY TRIAL TEST CASES
            ****************************************************************************************************************************/

            switch (matrixType)
			{
				case Global.MatrixType.MatrixOne:
				{
					rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime,false);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    buildSteps.Add(new StepVerifyPremiumSubscription(initialArgoSub, TITLEID));
					rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, true);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    //make sure default renewal sets it for CC offers
                    if (Global.IsCreditCardOffer(initialArgoSub))
                    {
                        buildSteps.Add(new StepVerifyPremiumSubscription(initialArgoSub, TITLEID));
                    }
                    else
                    {
                        buildSteps.Add(new StepVerifyXeEnumerate());
                    }
					break;
				}
                case Global.MatrixType.MatrixTwo:
                {
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepSetRenewal(futureArgoSub, StepSetRenewal.ExpectConvert.DontCare, countryCode, TITLEID));
                    //buildSteps.Add(new StepVerifyPremiumSubscription(futureArgoSub, TITLEID));
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime,true);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyPremiumSubscription(futureArgoSub, TITLEID));
                    break;
                }
                case Global.MatrixType.MatrixThree:
                {
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepSetRenewal(futureArgoSub, StepSetRenewal.ExpectConvert.DontCare, countryCode, TITLEID));                 
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, true);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyPremiumSubscription(futureArgoSub, TITLEID));
                    break;
                }
				case Global.MatrixType.MatrixFour:
				{
					rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, false);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
					//buildSteps.Add(new StepCancelSubscription(true,initialArgoSub));
                    buildSteps.Add(new StepOfferingCancel(initialArgoSub));
					rollTime = EstimateRollTime(initialArgoSub,RollTimeCmp.LessThan,out tRollType);
					timeRollsForCase[currentStep] = new TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType,rollTime, true);
					buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;					
                    if (Global.IsCreditCardOffer(futureArgoSub))
                    {
                        buildSteps.Add(new StepPurchaseOffer(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
                    }
                    else
                    {

                        if (initialArgoSub == Global.OfferType.ArgoSub14DayTrial && futureArgoSub == Global.OfferType.ArgoSub14DayTrial)
                        {
                            buildSteps.Add(new StepPurchaseOfferExpectFail(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
                        }
                        else
                        {
                            buildSteps.Add(new StepPurchaseOffer(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
                        }
                    }
					rollTime = EstimateRollTime(futureArgoSub, RollTimeCmp.LessThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, true);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    if (futureArgoSub == Global.OfferType.ArgoSub14DayTrial)
                    {
                        buildSteps.Add(new StepVerifyXeEnumerate());
                    }
                    else
                    {
                        buildSteps.Add(new StepVerifyPremiumSubscription(futureArgoSub, TITLEID));
                    }
					break;
				}
				case Global.MatrixType.MatrixFive:
				{
					if(userAccount == Global.UserAccountType.AccountTypeGold)
					{
                        rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                        timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                        buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                        currentStep++;
                        buildSteps.Add(new StepCancelSubscription(true, Global.OfferType.XeYearlyCC));
                        buildSteps.Add(new StepVerifyFreeOffer(true));
					}
					else
					{
                        rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                        timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                        buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                        currentStep++;
                        buildSteps.Add(new StepPurchaseOffer(RenewalMatrix.Global.OfferType.XeYearlyCC, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
                        buildSteps.Add(new StepVerify(RenewalMatrix.Global.OfferType.XeYearlyCC));						
					}
                    buildSteps.Add(new StepVerifyPremiumSubscription(initialArgoSub, TITLEID));
					rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);                                           
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    if (initialArgoSub == Global.OfferType.ArgoSub14DayTrial)
                        buildSteps.Add(new StepVerifyXeEnumerate()); //cannot clock roll less than 8 days - hence we fall out of the 14 day period
                    else
                    {
                        buildSteps.Add(new StepVerifyPremiumSubscription(initialArgoSub, TITLEID));
                    }
					break;
				}
                case Global.MatrixType.MatrixSix:
                {
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    //buildSteps.Add(new StepCancelSubscription(true,initialArgoSub));
                    buildSteps.Add(new StepOfferingCancel(initialArgoSub));
                    if (Global.IsCreditCardOffer(futureArgoSub))
                    {
                        buildSteps.Add(new StepPurchaseOffer(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
                    }
                    else
                    {
                        buildSteps.Add(new StepPurchaseOffer(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
                    }
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, true);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyPremiumSubscription(futureArgoSub, TITLEID));
                    break;
                }
                case Global.MatrixType.MatrixSeven:
                {
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepPurchaseOfferExpectFail(futureArgoSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
                    rollTime = EstimateRollTime(initialArgoSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyXeEnumerate());
                    break;
                }
			}
			timeRollArrays.Add(timeRollsForCase);
			return(new Case((CaseStep []) buildSteps.ToArray(typeof(CaseStep)), name));
		}

		public ArrayList GetStartOffers(ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList startOffers = new ArrayList();
            if (countryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
            {
                startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSubMonthlyCC);
                startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSubQuarterlyCC);
                //startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSubYearlyCC);
            }
            startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSub1moPrepaid);
            startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSub3moPrepaid);
            startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSub12moPrepaid);
            startOffers.Add(RenewalMatrix.Global.OfferType.ArgoSub14DayTrial);
			return startOffers;
		}

        public ArrayList GetMatrix3FutureOffers(Global.OfferType startOffer, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
        {
            ArrayList futureOffer = new ArrayList();
            switch (startOffer)
            {
                case Global.OfferType.ArgoSub1moPrepaid:
                case Global.OfferType.ArgoSub3moPrepaid:
                case Global.OfferType.ArgoSub12moPrepaid:
                case Global.OfferType.ArgoSub14DayTrial:
                    {
                        futureOffer.Add(Global.OfferType.ArgoSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.ArgoSubQuarterlyCC);
                        //futureOffer.Add(Global.OfferType.ArgoSubYearlyCC);
                        break;
                    }
                case Global.OfferType.ArgoSubMonthlyCC:
                    {
                        futureOffer.Add(Global.OfferType.ArgoSubQuarterlyCC);
                        //futureOffer.Add(Global.OfferType.ArgoSubYearlyCC);
                        break;
                    }
                case Global.OfferType.ArgoSubQuarterlyCC:
                    {
                        futureOffer.Add(Global.OfferType.ArgoSubMonthlyCC);
                        //futureOffer.Add(Global.OfferType.ArgoSubYearlyCC);
                        break;
                    }
                case Global.OfferType.ArgoSubYearlyCC:
                    {
                        futureOffer.Add(Global.OfferType.ArgoSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.ArgoSubQuarterlyCC);
                        break;
                    }
                default:
                    throw new ArgumentException("Illegal ArgoSubscription offer type", "startOffer");
            }
            return futureOffer;
        }

		public ArrayList GetMatrix4FutureOffers(Global.OfferType startOffer, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList futureOffer = new ArrayList();
			switch(startOffer)
			{
                case Global.OfferType.ArgoSubMonthlyCC:
                case Global.OfferType.ArgoSubQuarterlyCC:
                case Global.OfferType.ArgoSubYearlyCC:
                    {            
                        futureOffer.Add(Global.OfferType.ArgoSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.ArgoSubPrepaid);
                        futureOffer.Add(Global.OfferType.ArgoSub14DayTrial);
                        break;
                    }
                case Global.OfferType.ArgoSub1moPrepaid:
                case Global.OfferType.ArgoSub3moPrepaid:
                case Global.OfferType.ArgoSub12moPrepaid:
                case Global.OfferType.ArgoSub14DayTrial:
                    {
                        futureOffer.Add(Global.OfferType.ArgoSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.ArgoSubPrepaid);
                        futureOffer.Add(Global.OfferType.ArgoSub14DayTrial);
                        break;
                    }
				default:
					throw new ArgumentException("Illegal ArgoSubscription offer type","startOffer");
			}
			return futureOffer;
		}

		protected override void Initialize()
		{
            /*******Build the filters to help the user select a SUBSET of testcases rather than running the entire suite******/
            //indictate the Matrix Size and the useraccountype you don't want to include in the test
            scriptHelper = new ScriptHelper(MATRIXSIZE, Global.UserAccountType.AccountTypeMigrated, this.GetType());
            scriptHelper.ObtainTestFilters();
            /******************************************************************************************************************/

			ArrayList startArgoOffers = new ArrayList();
            ArrayList futureMatrix3ArgoOffers = new ArrayList();
			ArrayList futureMatrix4ArgoOffers = new ArrayList();
			ArrayList caseList = new ArrayList();
			timeRollArrays = new ArrayList();

			foreach (ServerTestFramework.LiveService.UserAccount.XeUser.Country cc in Form1.Countries)
			{
                //So far Zune Subscriptions only supported in US
                if (cc != ServerTestFramework.LiveService.UserAccount.XeUser.Country.US)
                    continue;

                /***************************************************/
                //ScriptHelper has a hashtable with the country as key and FilterObject as value
                //corresponding to the use
                FilterObject fObj = scriptHelper.GetObject(cc.ToString());
                //country is not selected by the user
                if (fObj == null)
                    continue;
                int i = 0;
                /**************************************************/
				startArgoOffers = GetStartOffers(cc);
				foreach (Global.MatrixType mt in scriptHelper.Matrices)
				{
                    if (((uint)mt & fObj.MatrixValue) == 0)
                        continue;      

					foreach(Global.UserAccountType uat in scriptHelper.UserAccounts)
					{
                        if (((uint)uat & (uint)fObj.UserAccountValue[i]) == 0)
                            continue; 

						foreach(Global.OfferType ot in startArgoOffers)
						{
							if ( mt == Global.MatrixType.MatrixOne)
                            {
                                //continue;
                                Case caseToAdd = GenerateCase(mt, uat, ot, ot, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }							
							else if ( mt == Global.MatrixType.MatrixTwo )
							{
                                //continue;
                                //matrix 2 Case generation.
                                Case caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSubMinPrepaid, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                                caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSubMaxPrepaid, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);                                
							}
                            else if (mt == Global.MatrixType.MatrixThree)
                            {                                
                                //continue;
                                //matrix 3 case generation.
                                futureMatrix3ArgoOffers = GetMatrix3FutureOffers(ot, cc);
                                foreach (Global.OfferType fo in futureMatrix3ArgoOffers)
                                {
                                    Case caseToAdd = GenerateCase(mt, uat, ot, fo, cc);
                                    if (caseToAdd != null)
                                        caseList.Add(caseToAdd);
                                }
                            }
                            else if(mt == Global.MatrixType.MatrixFour)
							{
                                //continue;                              
								futureMatrix4ArgoOffers = GetMatrix4FutureOffers(ot,cc);
                                foreach (Global.OfferType fo in futureMatrix4ArgoOffers)
								{
									Case caseToAdd = GenerateCase(mt, uat, ot, fo, cc);
									if (caseToAdd != null)
										caseList.Add(caseToAdd);
								}
							}
                            else if (mt == Global.MatrixType.MatrixFive)
                            {
                                //continue;
                                Case caseToAdd = GenerateCase(mt, uat, ot, ot, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }
                            else if (mt == Global.MatrixType.MatrixSix)
                            {
                                //matrix 6 Case generation.
                                Case caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSubPrepaid, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                                caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSubMonthlyCC, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                                caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSubQuarterlyCC, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }
                            else if (mt == Global.MatrixType.MatrixSeven && ot == Global.OfferType.ArgoSub14DayTrial)
                            {
                                //continue;
                                Case caseToAdd = GenerateCase(mt, uat, Global.OfferType.ArgoSubPrepaid, ot, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                                caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.ArgoSub14DayTrial, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }
						} //end startArgoOffers foreach loop

					} //end UserAccounts foreach loop
				
				} // end Matrices foreach loop

			} // end ServerTestFramework.LiveService.UserAccount.XeUser.Country foreach loop
				cases = (Case[]) caseList.ToArray(typeof(Case));
			
		}
	}

  }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\LightweightTracker.cs ===
using System;
using System.Collections;

namespace RenewalMatrix.New_Code
{

	public enum LwoState
	{
		LWO_INITIALIZED,
		LWO_RUNNING,
		LWO_DONE,
		LWO_DONE_WITH_EXCEPTION
	}

	/// <summary>
	/// Summary description for LightweightTracker.
	/// </summary>
	public class LightweightTracker
	{
		private int nextAbsoluteTime; 
		public int lastTimeRan;
		private HeavyweightObject test; // our test
		private string serializedFile;
		private LwoState currentState;
		private string name;

		public string Name
		{
			get
			{
				return name;
			}
		}

		public Case.PassCode Code;
		public Case.PassCode OldCode;

		public LightweightTracker(HeavyweightObject hwo)
		{
			nextAbsoluteTime = 0;
			test = hwo;
			serializedFile = null;
			currentState = LwoState.LWO_INITIALIZED;
			name = hwo.Name;
			OldCode=Case.PassCode.Failed;
			Code=Case.PassCode.NotRunning;
		}

		public bool NeedsToBeProcessed(int absoluteTime)
		{
			if (currentState == LwoState.LWO_INITIALIZED)
			{
				currentState = LwoState.LWO_RUNNING;
			}
			if (currentState != LwoState.LWO_RUNNING)
			{
				return false;
			}
			if (nextAbsoluteTime == -1)
			{
				// We might hit this with the new timeline code
				return false;
				//throw new Exception("Object is done, should no longer be running");
			}
			if (absoluteTime > nextAbsoluteTime)
			{
				throw new ArgumentException("OBJECT HAS BEEN SKIPPED!");
			}
			// Check if we have failed and set the appropriate state
			if ((currentState == LwoState.LWO_RUNNING) &&
				(this.Code == Case.PassCode.Failed))
			{
				currentState = LwoState.LWO_DONE_WITH_EXCEPTION;
				return false;
			}
			if (absoluteTime == nextAbsoluteTime)
			{
				return true;
			}
			return false;
		}

		/// <summary>
		/// Runs on the same thread as free memory
		/// </summary>
		/// <param name="currentTime"></param>
		public void RunTestStepsUntilTimeRoll(int currentTime)
		{
			lastTimeRan = currentTime;
			if (currentState != LwoState.LWO_RUNNING)
			{
				throw new Exception("Object is in incorrect state.  Expecting: " + LwoState.LWO_RUNNING + " Actual:" + currentState);
			}
			if (currentTime != nextAbsoluteTime)
			{
				throw new ArgumentException("OBJECT HAS BEEN SKIPPED!");
			}
			if (test == null)
			{				
				// De-Serialize
				lock(this)
				{
					if (test == null)
					{
						test = HeavyweightObject.Deserialize(serializedFile);
						test.ReInitialize(this);
					}
				}
			}			
			bool exception = true;
			try
			{
				nextAbsoluteTime = test.LoadStepsForAbsoluteTime(currentTime);
				if (nextAbsoluteTime == -1)
				{
					currentState = LwoState.LWO_DONE;
				}
				test.RunSteps();
				exception = false;
			}
			finally 
			{
				if (exception)
				{
					currentState = LwoState.LWO_DONE_WITH_EXCEPTION;
				}
			}
			return;
		}

		public void FreeMemory()
		{
			serializedFile = test.Serialize();
			// Should be an atomic operation
			test = null;
			return;
		}

		/// <summary>
		/// Determines if this test is done
		/// </summary>
		/// <returns></returns>
		public bool IsDone()
		{
			return (currentState == LwoState.LWO_DONE_WITH_EXCEPTION) || (currentState == LwoState.LWO_DONE);
		}

		/// <summary>
		/// Gets the log, may be called asynchronously
		/// </summary>
		/// <returns></returns>
		public ArrayList GetLog()
		{
			lock (this)
			{
				bool hasBeenSerialized = false;
				// De-Serialize
				if (test == null)
				{
					test = HeavyweightObject.Deserialize(serializedFile);
					test.ReInitialize(this);
					hasBeenSerialized = true;
				}
				ArrayList returnVal = test.GetLog();
				// Clear the memory
				if (hasBeenSerialized)
				{
					test = null;
				}
				return returnVal;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\ScriptXePremiumGameSubscriptions.cs ===
using System;
using System.Collections;
using System.Reflection;
using System.Xml;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for ScriptXeGameSubscriptions.
	/// </summary>
	public class ScriptXePremiumGameSubscriptions : Script
	{
		ArrayList timeRollArrays;
		public const uint TITLEID = 0xFFFF0095; //Title which offers the game subscription
		public const uint SERVICEID1 = 0xFFFF0095;// Service associated with the game subscription
        public const int MATRIXSIZE = 5;

        //This class provides the ability to set Country/Matrix/Useraccountype filters to select a subset of test cases
        public RenewalMatrix.New_Code.ScriptHelper scriptHelper;

		public enum RollTimeCmp
		{
			Equal,
			LessThan,
			GreaterThan
		}

		public ScriptXePremiumGameSubscriptions()
		{
			//
			// TODO: Add constructor logic here
			//
			
		}
        
		public override ArrayList GetRolls()
		{
			return timeRollArrays;
		}

		public static string MatrixDescription(Global.MatrixType mt)
		{
			string desc;
			switch(mt)
			{
				case Global.MatrixType.MatrixOne:
				{
					desc = "Initial GameSub Purchase and Default Renewal";
					break;
				}
				case Global.MatrixType.MatrixTwo:
				{
					desc = "Stacking of GameSub Offers";
					break;
				}
				case Global.MatrixType.MatrixThree:
				{
					desc = "GameSub Renewal Change";
					break;
				}
				case Global.MatrixType.MatrixFour:
				{
					desc = "Cancelled GameSub";
					break;
				}
				case Global.MatrixType.MatrixFive:
				{
					desc = "User Account Changes during GameSub";
					break;
				}
				default:
				{
					throw new ArgumentException("Incorrect MatrixType: ");
				}
			}
			return desc;
		}

		protected int EstimateRollTime(Global.OfferType currentOffer, RollTimeCmp timeCmp, out RenewalMatrix.TimeRollType rollType)
		{
			int offerLen = Global.GetOfferLengthFromOffer(currentOffer);
			int estimatedTime = 0;
			rollType = TimeRollType.week;

            //Estimating the clock roll time on the SCG side based on the offerlength.
            //If RollTimeCmp.LessThan implies clock roll is less than or equal to half the offerlength
			if( timeCmp == RollTimeCmp.LessThan)
			{
				switch(offerLen)
				{
					case 1:
					{
						estimatedTime = 2;
						rollType = TimeRollType.week;
						break;
					}
					case 3:
					{
						estimatedTime = 6;
						rollType = TimeRollType.week;
						break;
					}
					case 12:
					{
						estimatedTime = 5;
						rollType = TimeRollType.month;
						break;
					}
				}
			}
            // If RollTimeCmp.GreaterThan implies clock roll is greater than half the offerlength
            else if (timeCmp == RollTimeCmp.GreaterThan)
            {
                switch (offerLen)
                {
                    case 0:
                        {
                            estimatedTime = 2;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 1:
                        {
                            estimatedTime = 3;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 3:
                        {
                            estimatedTime = 8;
                            rollType = TimeRollType.week;
                            break;
                        }
                    case 12:
                        {
                            estimatedTime = 31; // We want it to be less than 8 months!
                            rollType = TimeRollType.week;
                            break;
                        }
                }
            }
            else
            {
                switch (offerLen)
                {
                    case 1:
                        {
                            estimatedTime = 1;
                            rollType = TimeRollType.month;
                            break;
                        }
                    case 3:
                        {
                            estimatedTime = 3;
                            rollType = TimeRollType.month;
                            break;
                        }
                    case 12:
                        {
                            estimatedTime = 12;
                            rollType = TimeRollType.month;
                            break;
                        }
                }
            }
			return estimatedTime;
		}

		public Case GenerateCase(Global.MatrixType matrixType, Global.UserAccountType userAccount, Global.OfferType initialGameSub, Global.OfferType futureGameSub, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList buildSteps = new ArrayList();
			string name; // CASE NAME
			int currentStep = 0;
			// clock roll steps, currently 2 are required for every matrix except 4
			int numSteps = 2;
			if(matrixType == Global.MatrixType.MatrixFour)
			{
				numSteps = 3;
			}
			int rollTime;
			TimeRoll[] timeRollsForCase;
			timeRollsForCase = new TimeRoll[numSteps];
			TimeRollType tRollType;

			try
			{
				name = countryCode.ToString() + ": " + matrixType.ToString() + "(User: " + userAccount.ToString() + ")"+ " - " + MatrixDescription(matrixType) + 
					" Initial GameSub:" + RenewalMatrix.Global.GetOfferFriendlyName(initialGameSub)+ "; " + "Future GameSub:" + RenewalMatrix.Global.GetOfferFriendlyName(futureGameSub);
			}
			catch(Exception)
			{
				throw;
			}
			/***************************************************************************************************************************
			STEP: intial case steps depend on the type of the user 
			******************************************************************************************************************************/
			switch(userAccount)
			{
				case Global.UserAccountType.AccountTypeSilver:
				{
					buildSteps.Add(new StepCreateFreeAccount(countryCode));
					break;
				}
				case Global.UserAccountType.AccountTypeMigrated:
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(RenewalMatrix.Global.OfferType.LaunchOffer),countryCode));
					buildSteps.Add(new StepMigrateAccountToXenon());	// Migrate the account
					break;
				}
				case Global.UserAccountType.AccountTypeGold:
				{
					buildSteps.Add(new StepCreateAccount(RenewalMatrix.Global.GetVoucherFromOffer(RenewalMatrix.Global.OfferType.XeYearlyCC), countryCode, true));
					break;
				}
				default:
				{
					throw new ArgumentException("Invalid UserAccountType!");
				}
			}

			/*****************************************************************************************************************************
			Steps which are common to all the matrices
			STEP: Able to enumerate the game subscription offer
			STEP: Verify whether the service associated with the title FFFF0095 is available to the user - should be NOT GRANTED SERVICE
			STEP: Purchase game subscription based on the initialGameSub
			STEP: Verify the game subscription is the same as purchased
			STEP: Verify whther the service associated with the title FFFF0095 is available to the user - should be GRANTED SERVICE
			******************************************************************************************************************************/
			buildSteps.Add(new StepVerifyXeEnumerate());
			buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, false));
			//TODO: Fix me so that offers can be purchased using tokens
            if(Global.IsCreditCardOffer(initialGameSub))
            {
			    buildSteps.Add(new StepPurchaseOffer(initialGameSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
            }
            else
            {
                buildSteps.Add(new StepPurchaseOffer(initialGameSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
            }
			buildSteps.Add(new StepVerifyPremiumSubscription(initialGameSub,TITLEID));
			buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));

			/***************************************************************************************************************************
			Steps specific to Matrices
			MatrixOne-
				STEP: Clock roll the one-box by a substantial amount of time (less than the offer length)
				STEP: Verify the service is granted to the user.
				STEP: Verify the game subscriptions details matches what was purchased.  i.e. start and end date, default renewal etc.
				STEP: Clock-roll the one-box by a amount of time greater than current offer length, such that the subscription advances into default renewal.
				STEP: Verify that the user has a subscription and the service associated with the title is granted to the user.
			MatrixTwo-CONVERSION
				STEP: Clock-roll the one-box by a substantial amount of time (less than current offer length)
				STEP: Stack another prepaid offer to the current offer and the subscription details should enlist the new offer as the current offer and also increase the subscription period by required amount of time.
				STEP: Clock-roll the one-box by a period such that the date is after the old offer end date and before the new offer end date.
				STEP: Verify the service corresponding to the Title is granted to the user.
			MatrixThree-RENEWAL
				STEP: Clock-roll the one-box by a substantial amount of time ( less than current offer length)
				STEP: Change the default subscription renewal to the one specified in the test case.
				STEP: Verify from the subscription details whether the renewal has been set to the new renewal.
				STEP: Clock-roll the one-box such that renewal sets in.
				STEP: Verify whether the current subscription is the new subscription.
			MatrixFour-
				STEP: Clock-roll the one-box by a substantial amount of time ( > current offer length), so the subscription expires.
				STEP: Cancel the credit card offers (prepaid offers have expired)
				STEP: Clock-roll two weeks.
				STEP: Verify that the service is unavailable to the user.
				STEP: Depending on the Test case purchase or redeem the final game subscription.
				STEP: Clock-roll the one-box by a substantial amount of time ( <  current offer length).
				STEP: Verify that the current offer is the new offer (Offer after Expiration/Cancellation column in the table above) with the corresponding start and end dates.
				STEP: Verify that the user has access to the service corresponding to the game subscription.
			MatrixFive-
				STEP: Clock roll substantial amount of time such that (for Gold account) user has been downgraded. 
					  If Gold then clock roll by a year else clockroll by 2 weeks.
				STEP: For Silver account purchase a live a gold subscription.
				STEP: Verify that user still has access to the game services.	
			****************************************************************************************************************************/

			switch(matrixType)
			{
				case Global.MatrixType.MatrixOne:
				{
					rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime,false);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
					buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));
					rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.GreaterThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, true);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    if (Global.IsCreditCardOffer(initialGameSub))
                    {
                        buildSteps.Add(new StepVerifyService(TITLEID, new uint[] { SERVICEID1 }, true));
                    }
                    else
                    {
                        buildSteps.Add(new StepVerifyService(TITLEID, new uint[] { SERVICEID1 }, false));
                    }
					break;
				}
                case Global.MatrixType.MatrixTwo:
                {
                    rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepSetRenewal(futureGameSub, StepSetRenewal.ExpectConvert.DontCare, countryCode, TITLEID));
                    //buildSteps.Add(new StepVerifyGameSubscription(futureGameSub, TITLEID));
                    rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, true);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyService(TITLEID, new uint[] { SERVICEID1 }, true));
                    break;
                }
                case Global.MatrixType.MatrixThree:
                {
                    rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, false);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepSetRenewal(futureGameSub, StepSetRenewal.ExpectConvert.DontCare, countryCode, TITLEID));                 
                    rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.GreaterThan, out tRollType);
                    timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType, rollTime, true);
                    buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
                    currentStep++;
                    buildSteps.Add(new StepVerifyPremiumSubscription(futureGameSub, TITLEID));
                    break;
                }
				case Global.MatrixType.MatrixFour:
				{
					rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.GreaterThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, false);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
                    //HACK to test OfferingCancel Live server api.
                    //buildSteps.Add(new StepOfferingCancel(initialGameSub));
					buildSteps.Add(new StepCancelSubscription(true,initialGameSub));
					rollTime = EstimateRollTime(initialGameSub,RollTimeCmp.LessThan,out tRollType);
					timeRollsForCase[currentStep] = new TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(), tRollType,rollTime, true);
					buildSteps.Add(new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
					buildSteps.Add(new StepVerifyService(TITLEID, new uint [] {SERVICEID1}, false));				
                    if (Global.IsCreditCardOffer(futureGameSub))
                    {
                        buildSteps.Add(new StepPurchaseOffer(futureGameSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
                    }
                    else
                    {
                        buildSteps.Add(new StepPurchaseOffer(futureGameSub, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.Token));
                    }
					rollTime = EstimateRollTime(futureGameSub, RollTimeCmp.LessThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, true);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
					buildSteps.Add(new StepVerifyPremiumSubscription(futureGameSub, TITLEID));
					buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));
					break;
				}
				case Global.MatrixType.MatrixFive:
				{
					if(userAccount == Global.UserAccountType.AccountTypeSilver)
					{
						rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
						timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, false);
						buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
						currentStep++;
						buildSteps.Add( new StepPurchaseOffer(RenewalMatrix.Global.OfferType.XeYearlyCC, ServerTestFramework.LiveService.Billing.PaymentTypeEnum.CreditCard));
						buildSteps.Add( new StepVerify(RenewalMatrix.Global.OfferType.XeYearlyCC));
					}
					else
					{
						rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
						timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, false);
						buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
						currentStep++;						
						buildSteps.Add(new StepCancelSubscription());						
						buildSteps.Add(new StepVerifyFreeOffer(true));
					}
					buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));
					rollTime = EstimateRollTime(initialGameSub, RollTimeCmp.LessThan, out tRollType);
					timeRollsForCase[currentStep] = new RenewalMatrix.TimeRoll("Roll- " + currentStep + " rolling " + rollTime + tRollType.ToString(),tRollType,rollTime, false);
					buildSteps.Add( new StepWaitForRoll(timeRollsForCase[currentStep]));
					currentStep++;
					buildSteps.Add(new StepVerifyService(TITLEID, new uint[] {SERVICEID1}, true));
					break;
				}
			}
			timeRollArrays.Add(timeRollsForCase);
			return(new Case((CaseStep []) buildSteps.ToArray(typeof(CaseStep)), name));
		}

		public ArrayList GetStartOffers(ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList startOffers = new ArrayList();
			if(countryCode != ServerTestFramework.LiveService.UserAccount.XeUser.Country.KR)
			{
                startOffers.Add(RenewalMatrix.Global.OfferType.GameSubMonthlyCC);
                startOffers.Add(RenewalMatrix.Global.OfferType.GameSubQuarterlyCC);
                startOffers.Add(RenewalMatrix.Global.OfferType.GameSubYearlyCC);
			}
            startOffers.Add(RenewalMatrix.Global.OfferType.GameSub1moPrepaid);
            startOffers.Add(RenewalMatrix.Global.OfferType.GameSub3moPrepaid);
            startOffers.Add(RenewalMatrix.Global.OfferType.GameSub12moPrepaid);
			return startOffers;
		}

        public ArrayList GetMatrix3FutureOffers(Global.OfferType startOffer, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
        {
            ArrayList futureOffer = new ArrayList();
            switch (startOffer)
            {
                case Global.OfferType.GameSub1moPrepaid:
                case Global.OfferType.GameSub3moPrepaid:
                case Global.OfferType.GameSub12moPrepaid:
                    {
                        futureOffer.Add(Global.OfferType.GameSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.GameSubQuarterlyCC);
                        futureOffer.Add(Global.OfferType.GameSubYearlyCC);
                        break;
                    }
                case Global.OfferType.GameSubMonthlyCC:
                    {
                        futureOffer.Add(Global.OfferType.GameSubQuarterlyCC);
                        futureOffer.Add(Global.OfferType.GameSubYearlyCC);
                        break;
                    }
                case Global.OfferType.GameSubQuarterlyCC:
                    {
                        futureOffer.Add(Global.OfferType.GameSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.GameSubYearlyCC);
                        break;
                    }
                case Global.OfferType.GameSubYearlyCC:
                    {
                        futureOffer.Add(Global.OfferType.GameSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.GameSubQuarterlyCC);
                        break;
                    }
                default:
                    throw new ArgumentException("Illegal GameSubscription offer type", "startOffer");
            }
            return futureOffer;
        }

		public ArrayList GetMatrix4FutureOffers(Global.OfferType startOffer, ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			ArrayList futureOffer = new ArrayList();
			switch(startOffer)
			{
                case Global.OfferType.GameSubMonthlyCC:
                case Global.OfferType.GameSubQuarterlyCC:
                case Global.OfferType.GameSubYearlyCC:
                    {            
                        futureOffer.Add(Global.OfferType.GameSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.GameSubPrepaid);                      
                        break;
                    }
                case Global.OfferType.GameSub1moPrepaid:
                case Global.OfferType.GameSub3moPrepaid:
                case Global.OfferType.GameSub12moPrepaid:
                    {
                        futureOffer.Add(Global.OfferType.GameSubMonthlyCC);
                        futureOffer.Add(Global.OfferType.GameSubPrepaid);
                        break;
                    }
				default:
					throw new ArgumentException("Illegal GameSubscription offer type","startOffer");
			}
			return futureOffer;
		}

		protected override void Initialize()
		{
            /*******Build the filters to help the user select a SUBSET of testcases rather than running the entire suite******/
            //indictate the Matrix Size and the useraccountype you don't want to include in the test
            scriptHelper = new ScriptHelper(MATRIXSIZE, Global.UserAccountType.AccountTypeArgo, this.GetType());
            scriptHelper.ObtainTestFilters();
            /******************************************************************************************************************/

			ArrayList startGameOffers = new ArrayList();
            ArrayList futureMatrix3GameOffers = new ArrayList();
			ArrayList futureMatrix4GameOffers = new ArrayList();
			ArrayList caseList = new ArrayList();
			timeRollArrays = new ArrayList();

			foreach (ServerTestFramework.LiveService.UserAccount.XeUser.Country cc in Form1.Countries)
			{   
                /***************************************************/
                //ScriptHelper has a hashtable with the country as key and FilterObject as value
                //corresponding to the use
                FilterObject fObj = scriptHelper.GetObject(cc.ToString());
                //country is not selected by the user
                if (fObj == null)
                    continue;
                int i = 0;
                /**************************************************/

				startGameOffers = GetStartOffers(cc);                
				foreach (Global.MatrixType mt in scriptHelper.Matrices)
				{					                
                    if (((uint) mt & fObj.MatrixValue) == 0)
                        continue;                 
					foreach(Global.UserAccountType uat in scriptHelper.UserAccounts)
					{
                        if (((uint) uat & (uint) fObj.UserAccountValue[i]) == 0)
                            continue;                        
						foreach(Global.OfferType ot in startGameOffers)
						{
							if ( mt == Global.MatrixType.MatrixOne )
                            {
                                //continue;
                                Case caseToAdd = GenerateCase(mt, uat, ot, ot, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }							
							else if ( mt == Global.MatrixType.MatrixTwo )
							{
                                //if (uat != Global.UserAccountType.AccountTypeSilver)
                                //    continue;
                                //continue;
                                //matrix 2 Case generation.
                                Case caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.GameSubMinPrepaid, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                                caseToAdd = GenerateCase(mt, uat, ot, Global.OfferType.GameSubMaxPrepaid, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);                                
							}
                            else if (mt == Global.MatrixType.MatrixThree)
                            {
                                //continue;
                                //matrix 3 case generation.
                                futureMatrix3GameOffers = GetMatrix3FutureOffers(ot, cc);
                                foreach (Global.OfferType fo in futureMatrix3GameOffers)
                                {
                                    Case caseToAdd = GenerateCase(mt, uat, ot, fo, cc);
                                    if (caseToAdd != null)
                                        caseList.Add(caseToAdd);
                                }
                            }
                            else if(mt == Global.MatrixType.MatrixFour)
							{                               
                                //continue;                             
								futureMatrix4GameOffers = GetMatrix4FutureOffers(ot,cc);
                                foreach (Global.OfferType fo in futureMatrix4GameOffers)
								{
									Case caseToAdd = GenerateCase(mt, uat, ot, fo, cc);
									if (caseToAdd != null)
										caseList.Add(caseToAdd);
								}
							}
                            else if (mt == Global.MatrixType.MatrixFive)
                            {
                                //continue;
                                Case caseToAdd = GenerateCase(mt, uat, ot, ot, cc);
                                if (caseToAdd != null)
                                    caseList.Add(caseToAdd);
                            }
						} //end startGameOffers foreach loop

					} //end UserAccounts foreach loop
                    i++;
				} // end Matrices foreach loop

			} // end ServerTestFramework.LiveService.UserAccount.XeUser.Country foreach loop
				cases = (Case[]) caseList.ToArray(typeof(Case));
			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepCreateFreeAccount.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepCreateFreeAccount.
	/// </summary>
	public class StepCreateFreeAccount : CaseStep
	{
		ServerTestFramework.LiveService.UserAccount.XeUser.Country c;
        bool ArgoAcct;
		public StepCreateFreeAccount(ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode)
		{
			this.c = countryCode;
            this.ArgoAcct = false;
		}
        public StepCreateFreeAccount(ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode, bool argoAcct)
        {
            this.c = countryCode;
            this.ArgoAcct = argoAcct;
        }

		public override bool Execute()
		{
            if (!ArgoAcct)
            {
                XeUser user = new XeUser(true, c);
                user.CreateAsGold = false;
                user.OfferId = 0xFFFE07D180000011; // Common code has the wrong offer ID
                user.BillingToken = "";
                user.CreditCardInfo = new ServerTestFramework.LiveService.UserAccount.CreditCardInfoData();
                user.PassportMemberName = "xblrenewtest-" + Guid.NewGuid().ToString() + "@xboxtest.com";
                //TODO: Might need retry logic here
                if (user.Create() == 0)
                    throw new Exception("XeUser.Create() failed: " + user.GetDumpString());

                if (UodbWS.IsUserQueued(user.UserPuid))
                {
                    Parent.Log(Header + " user is queued!");
                    System.Threading.Thread.Sleep(250);
                }

                Parent.Puid = user.UserPuid;
                Parent.Log("User Puid:" + user.UserPuid);
                ulong passportPuid = UodbWS.GetUserPassportUserPuid(Parent.Puid);
                Parent.Log("PassportIdH: " + (int)((passportPuid & 0xffffffff00000000) >> 32) + "PassportLow: " + (int)(passportPuid & 0xffffffff));              
                Parent.GamerTag = user.Gamertag;
                Parent.XenonKey = new byte[user.m_response.XenonKey.Length];
                Array.Copy(user.m_response.XenonKey, Parent.XenonKey, user.m_response.XenonKey.Length);
                Parent.Xenoned = true;
                Parent.AddressInfo = user.AddressInfo;
                Parent.CountryID = (byte)c;
                Parent.LanguageID = user.LanguageId;
            }
            else
            {
                //CREATING ARGO USER!!
                XeUser user = new XeUser(true, this.c);
                user.CreateLiveAccountExtra = new XRLXeCreateLiveAccountExtra();
                user.CreateLiveAccountExtra.CreateArgoProfile = true;

                if (user.Create() == 0)
                    throw new Exception("XeUser.Create() failed: " + user.GetDumpString());

                if (UodbWS.IsUserQueued(user.UserPuid))
                {
                    Parent.Log(Header + " user is queued!");
                    System.Threading.Thread.Sleep(250);
                }
                Parent.Puid = user.UserPuid;
                Parent.GamerTag = user.Gamertag;
                ulong passportPuid = UodbWS.GetUserPassportUserPuid(Parent.Puid);
                Parent.Log(DateTime.Now + " PassportIdH: " + (int)((passportPuid & 0xffffffff00000000) >> 32) + " PassportLow: "+(int)(passportPuid & 0xffffffff));
                Parent.Log("User Puid:" + user.UserPuid + " GamerTag: " + user.Gamertag);
                

                Parent.Xenoned = true;
                Parent.AddressInfo = user.AddressInfo;
                Parent.CountryID = (byte)c;
                Parent.LanguageID = user.LanguageId;
            }
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepLockPointsAccount.cs ===
using System;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepLockPointsAccount.
	/// </summary>
	public class StepLockPointsAccount : CaseStep
	{
		public StepLockPointsAccount()
		{
		}

		public override bool Execute()
		{
			// TODO: Later
			// Need to call SetUserState using the 
			// MPG WSDL
			// Account needs to have permissions to set that state
			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepMigrateAccountToXenonExpectFailure.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepMigrateAccountToXenonExpectFailure.
	/// </summary>
	public class StepMigrateAccountToXenonExpectFailure : CaseStep
	{
		public StepMigrateAccountToXenonExpectFailure()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public override bool Execute()
		{
			XRLXeMigrateXbox1User xemxu = new XRLXeMigrateXbox1User();
			XRLXeMigrateXbox1UserResponse response = new XRLXeMigrateXbox1UserResponse();
			xemxu.LanguageId = Parent.LanguageID;
			if (!Parent.PassportAssociated)
			{
				UacsCommon uc = new UacsCommon();
				Parent.UserPassportMemberName = "xblrenewaltest-" + Guid.NewGuid().ToString() + "@xboxtest.com";
				UacsCommon.PassportUser passportUser = uc.CreatePassportUser(Parent.UserPassportMemberName);
				Log("Member Name:"+passportUser.MemberName);
				Log("Password   :"+passportUser.Password);
				Log("Secret Q	:"+passportUser.SecretQuestion);
				Log("Secret A	:"+passportUser.SecretAnswer);
				Log("PUID		:"+passportUser.PassportPuid);
				if (passportUser.SessionToken.Length != 0)
					Log("Session Tok:"+(int) passportUser.SessionToken[0]+(int)passportUser.SessionToken[passportUser.SessionToken.Length-1]);
				else
					Log("Session Token Empty");
				Parent.SignedUserPassportPuid = passportUser.SessionToken;
				Parent.OwnerForPassport.LinkToPassport(PassportUtilities.GetPuidFromSessionToken(Parent.SignedUserPassportPuid));
				Parent.PassportAssociated = true;
				// Old Code
				xemxu.SignedUserPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.SignedParentPassportPuid = xemxu.SignedUserPassportPuid;
				xemxu.UserPassportMemberName = Parent.UserPassportMemberName;
			}
			else
			{
				xemxu.SignedUserPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.SignedParentPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.UserPassportMemberName = Parent.UserPassportMemberName;
			}
			Log("Attempting Migration, Expecting failure");
			// TODO: I might need to implement retry logic here
			bool result = xemxu.Execute(out response);
			if (result)
			{
				Log("A failure was expected");
				Parent.Xenoned = true;
				return false;
			}
			Log("Migration failed as expected");
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepMigrateAccountToXenon.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Utilities;
using System.Threading;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepMigrateAccountToXenon.
	/// </summary>
	public class StepMigrateAccountToXenon : CaseStep
	{
		public void PrintDebug()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			xrlSE.TitleID = 0;
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("         Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);
			if (xrlGUSDR.ActivationDate == xrlGUSDR.EndDate)
			{
				Log("WARNING: Start and End dates match");
			}
		}

		public StepMigrateAccountToXenon()
		{
		}

		public override bool Execute()
		{
			Log("Migrating user");
			XRLXeMigrateXbox1User xemxu = new XRLXeMigrateXbox1User();
			XRLXeMigrateXbox1UserResponse response = new XRLXeMigrateXbox1UserResponse();
			xemxu.LanguageId = Parent.LanguageID;
			if (!Parent.PassportAssociated)
			{
				UacsCommon uc = new UacsCommon();
				Parent.UserPassportMemberName = "xblrenewaltest-" + Guid.NewGuid().ToString() + "@xboxtest.com";
				UacsCommon.PassportUser passportUser = uc.CreatePassportUser(Parent.UserPassportMemberName);
				Log("Member Name:"+passportUser.MemberName);
				Log("Password   :"+passportUser.Password);
				Log("Secret Q	:"+passportUser.SecretQuestion);
				Log("Secret A	:"+passportUser.SecretAnswer);
				Log("PUID		:"+passportUser.PassportPuid);
				if (passportUser.SessionToken.Length != 0)
					Log("Session Tok:"+(int) passportUser.SessionToken[0]+(int)passportUser.SessionToken[passportUser.SessionToken.Length-1]);
				else
					Log("Session Token Empty");
				Parent.SignedUserPassportPuid = passportUser.SessionToken;
				Parent.OwnerForPassport.LinkToPassport(PassportUtilities.GetPuidFromSessionToken(Parent.SignedUserPassportPuid));
				Parent.PassportAssociated = true;
				// Old Code
				xemxu.SignedUserPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.SignedParentPassportPuid = xemxu.SignedUserPassportPuid;
				xemxu.UserPassportMemberName = Parent.UserPassportMemberName;
			}
			else
			{
				xemxu.SignedUserPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.SignedParentPassportPuid = Parent.SignedUserPassportPuid;
				xemxu.UserPassportMemberName = Parent.UserPassportMemberName;
			}
			Parent.PassportAssociated = true;
			// TODO: I might need to implement retry logic here
			Log("Attempting migration");
			bool result = xemxu.Execute(out response);
			if (!result)
			{
				Log("A failure was not expected");
				Log("XRLXeMigrateXbox1User failed: " + xemxu.GetDumpString());
				return false;
			}
			if (xemxu.XErr != ServerTestFramework.LiveService.HResult.S_OK)
			{
				Log("A failure was not expected");
				Log(String.Format("XRLXeMigrateXbox1User returned XErr=0x{0:x}", xemxu.XErr));
				return false;
			}
			//TODO: Does the UserPuid itself change?
			//Parent.Puid = PassportUtilities.GetPuidFromSessionToken(request.SignedUserPassportPuid);
			PrintDebug();
			Parent.XenonKey = new byte[response.XenonKey.Length];
			Array.Copy(response.XenonKey, Parent.XenonKey, response.XenonKey.Length);
			Log("Migration Succeeded for User Puid:" + Parent.Puid);
			Parent.Xenoned = true;
			
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepOverstackRenewal.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepOverstackRenewal.
	/// </summary>
	public class StepOverstackRenewal : CaseStep
	{
		public StepOverstackRenewal()
		{
		}

		public void PrintDebug()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			xrlSE.TitleID = 0;
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter > 1)
			{
				Log("Too many subscriptions found");
				return;
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("         Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);

		}

		public override bool Execute()
		{
			PrintDebug();
			StepSetRenewal ssr = new StepSetRenewal(Global.OfferType.XeOverstackRenewalValue);			
			ssr.Parent = this.Parent;
			if (!ssr.Execute())
			{
				Log("Error: Setting first renewal failed");
				return false;
			}
			PrintDebug();
			ssr = new StepSetRenewal(Global.OfferType.XeOverstackRenewalValue);			
			ssr.Parent = this.Parent;
			if (!ssr.Execute())
			{
				Log("Error: Setting second renewal failed");
				return false;
			}
			PrintDebug();
			ssr = new StepSetRenewal(Global.OfferType.XeOverstackRenewalValue, StepSetRenewal.ExpectConvert.Failure);			
			ssr.Parent = this.Parent;
			if (!ssr.Execute())
			{
				Log("Error: Setting third renewal succeeded");
				return false;
			}
			PrintDebug();
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepPurchaseOffer.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepPurchaseOffer.
	/// </summary>
	public class StepPurchaseOffer : CaseStep
	{
		public Global.PointsOffer po;
		public uint PurchaseOfferPaymentType;
		public Global.OfferType PurchaseOffer;
		public bool IsPointsOffer = true;

		public StepPurchaseOffer()
		{
		}

		public StepPurchaseOffer(Global.PointsOffer po)
		{
			this.po = po;
			this.PurchaseOfferPaymentType = (uint) PaymentTypeEnum.Points;
			IsPointsOffer = true;
		}

		public StepPurchaseOffer(Global.OfferType ot, PaymentTypeEnum pt)
		{
			this.PurchaseOffer = ot;
			this.PurchaseOfferPaymentType = (uint) pt;
			IsPointsOffer = false;
		}

		public override bool Execute()
		{
			bool result;
			// Guarantee we have a points balance
			    if (IsPointsOffer)
			{
				XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
				XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
				xrlGPB.userPuid = Parent.Puid;
				if (! xrlGPB.Execute(out xrlGPBR))
				{
					string outputString;
					outputString=xrlGPB.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
					Log(outputString);
				}
			}
			else
			{
				Log("Purchasing Offer 0x" + ((ulong) PurchaseOffer).ToString("X") + " using PaymentType = " + PurchaseOfferPaymentType.ToString("X"));				
			}
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			if(IsPointsOffer)
			{
				xeop.OfferID = (ulong) po;
			}
			else
			{
				xeop.OfferID = (ulong) PurchaseOffer;
				//if the payment type is Credit Card then get the payment instrument id for the user.
				if (this.PurchaseOfferPaymentType == (uint) PaymentTypeEnum.CreditCard)
				{
					if ((Parent.PaymentInstrumentId == null) || (Parent.PaymentInstrumentId == ""))
					{				
						XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
						XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
						xrlXGPI.MaxResults = 1;
						xrlXGPI.UserPuid = Parent.Puid;
				
						if (!xrlXGPI.Execute(out xrlXGPIR))
						{
							Parent.Log("Failed getting a payment instrument");
						}
						Parent.Log("Next step");
						if(xrlXGPIR.PaymentInstrumentCount == 0)
						{
							Parent.Log("Payment instrument needed, creating a new one");
							XRLXeAddPaymentInstrument xrlXAPI = new XRLXeAddPaymentInstrument();
							XRLXeAddPaymentInstrumentResponse xrlXAPIR = new XRLXeAddPaymentInstrumentResponse();
							xrlXAPI.UserPuid = Parent.Puid;	
							xrlXAPI.AddressInfo = Parent.AddressInfo;
							xrlXAPI.PaymentInstrumentType = (byte) PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
							xrlXAPI.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
							if (!xrlXAPI.Execute(out xrlXAPIR))
							{
								Parent.Log("Failed adding a payment instrument:"+xrlXAPI.XErr);
							}
					
							Parent.PaymentInstrumentId = xrlXAPIR.PaymentInstrumentId;
						}
						else
						{
							Parent.Log("No new payment instrument needed");
							Parent.PaymentInstrumentId = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
						}
					}
					xeop.PaymentInstrumentID = Parent.PaymentInstrumentId;
				}
                else if (this.PurchaseOfferPaymentType == (uint)PaymentTypeEnum.Token)
                {
                    int i = 0;
                    while (Parent.VouchersUsed[((long)PurchaseOffer).ToString() + (Parent.VoucherNumber % 4).ToString()] != null)
                    {
                        Parent.VoucherNumber++;
                        if (i++ > 4)
                        {
                            break;
                        }
                    }
                    xeop.BillingToken = Global.GetSecondaryVoucher(PurchaseOffer, Parent.VoucherNumber);
                    if (xeop.BillingToken != "")
                        Parent.VouchersUsed[((long)PurchaseOffer).ToString() + (Parent.VoucherNumber % 4).ToString()] = new Object();
                }
			}
			xeop.UserPuid = Parent.Puid;
			xeop.LanguageID = Parent.LanguageID;
			xeop.CountryID = Parent.CountryID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xeop.PaymentType = this.PurchaseOfferPaymentType;
			try 
			{
				result = xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (!result)
			{				
				Log("A failure was not expected");
				string outputString;
				outputString=xeop.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xeop.XErr)+"  HTTP:"+xeop.httpStatus;
				Log(outputString);
				return false;			
			}			
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepPreLinkPassportAccount.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Utilities;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepMigrateAccountToXenon.
	/// </summary>
	public class StepPreLinkPassportAccount : CaseStep
	{
		public StepPreLinkPassportAccount()
		{
		}

		public override bool Execute()
		{
			Log("Pre-linking Passport Account");
			XRLXeMigrateXbox1User xemxu = new XRLXeMigrateXbox1User();
			if (!Parent.PassportAssociated)
			{
				UacsCommon uc = new UacsCommon();
				Parent.UserPassportMemberName = "xblrenewaltest-" + Guid.NewGuid().ToString() + "@xboxtest.com";
				UacsCommon.PassportUser passportUser = uc.CreatePassportUser(Parent.UserPassportMemberName);
				Log("Member Name:"+passportUser.MemberName);
				Log("Password   :"+passportUser.Password);
				Log("Secret Q	:"+passportUser.SecretQuestion);
				Log("Secret A	:"+passportUser.SecretAnswer);
				Log("PUID		:"+passportUser.PassportPuid);
				if (passportUser.SessionToken.Length != 0)
					Log("Session Tok:"+(int) passportUser.SessionToken[0]+(int)passportUser.SessionToken[passportUser.SessionToken.Length-1]);
				else
					Log("Session Token Empty");
				Parent.SignedUserPassportPuid = passportUser.SessionToken;
				Parent.OwnerForPassport.LinkToPassport(PassportUtilities.GetPuidFromSessionToken(Parent.SignedUserPassportPuid));
				Parent.PassportAssociated = true;

				// Old code
//				byte [] SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(xemxu.Slot.Key);
//				Parent.SignedUserPassportPuid = SignedUserPassportPuid;
//				Parent.UserPassportMemberName = "xblrenewaltest-" + Guid.NewGuid().ToString() + Global.PassportMemberDomain;
//				ulong passportPuid = PassportUtilities.GetPuidFromSessionToken(SignedUserPassportPuid);
//				Parent.OwnerForPassport.LinkToPassport(passportPuid);			
			}
			Parent.PassportAssociated = true;
			Log("Finished Pre-linking the account");
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepPurchasePoints.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepPurchasePoints.
	/// </summary>
	public class StepPurchasePoints : CaseStep
	{
		Global.PointsOffer po;

		public StepPurchasePoints() 
		{
		}

		public StepPurchasePoints(Global.PointsOffer po)
		{
			this.po = po;
		}

		public override bool Execute()
		{
			// Guarantee we have a points balance
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
			}
			Log("Purchasing Points using Offer 0x" + ((ulong) po).ToString("X") + " with a credit card:" + (uint) PaymentTypeEnum.CreditCard);
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			bool result;
			xeop.OfferID = (ulong) po;
			xeop.UserPuid = Parent.Puid;
			xeop.PaymentType = (uint) PaymentTypeEnum.CreditCard;
			xeop.BillingToken = null;
			xeop.CountryID = Parent.CountryID;
			if ((Parent.PaymentInstrumentId == null) || (Parent.PaymentInstrumentId == ""))
			{				
				XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
				XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
				xrlXGPI.MaxResults = 1;
				xrlXGPI.UserPuid = Parent.Puid;
				
				if (!xrlXGPI.Execute(out xrlXGPIR))
				{
					Parent.Log("Failed getting a payment instrument");
				}
				Parent.Log("Next step");
				if(xrlXGPIR.PaymentInstrumentCount == 0)
				{
					Parent.Log("Payment instrument needed, creating a new one");
					XRLXeAddPaymentInstrument xrlXAPI = new XRLXeAddPaymentInstrument();
					XRLXeAddPaymentInstrumentResponse xrlXAPIR = new XRLXeAddPaymentInstrumentResponse();
					xrlXAPI.UserPuid = Parent.Puid;					
					xrlXAPI.PaymentInstrumentType = (byte) PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
					xrlXAPI.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
					if (!xrlXAPI.Execute(out xrlXAPIR))
					{
						Parent.Log("Failed adding a payment instrument:"+xrlXAPI.XErr);
					}
					
					Parent.PaymentInstrumentId = xrlXAPIR.PaymentInstrumentId;
				}
				else
				{
					Parent.Log("No new payment instrument needed");
					Parent.PaymentInstrumentId = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
				}
			}
			xeop.PaymentInstrumentID = Parent.PaymentInstrumentId;
			xeop.LanguageID = Parent.LanguageID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);
			try 
			{
				result = xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (!result)
			{
				Log("A failure was not expected");
				string outputString;
				outputString=xeop.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xeop.XErr)+"  HTTP:"+xeop.httpStatus;
				Log(outputString);
				return false;
			}
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepOfferingCancel.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;


namespace RenewalMatrix.New_Code
{
    class StepOfferingCancel : CaseStep
    {
        public Global.OfferType OfferToCancel;

        public StepOfferingCancel(Global.OfferType offerId)
        {
            this.OfferToCancel = offerId;
        }

        public override bool Execute()
        {
            bool result = false;
            XRLOfferingCancel cancelRequest = new XRLOfferingCancel();

            Log("Using DELAYED_EXPIRE to cancel Offer 0x" + ((ulong)OfferToCancel).ToString("X"));	

            cancelRequest.userPuid = Parent.Puid;
            cancelRequest.offeringId = (ulong) OfferToCancel;

            try
            {
                result = cancelRequest.Execute();
            }
            catch (Exception e)
            {
                Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
                throw e;
            }

            if (!result)
            {
                Log("A failure was not expected");
                string outputString;
                outputString = cancelRequest.GetType().Name;
                outputString += " XErr:" + ServerTestFramework.Global.XErrToString(cancelRequest.XErr) + "  HTTP:" + cancelRequest.httpStatus;
                Log(outputString);
                return false;
            }
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepPurchaseOfferExpectFail.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepPurchaseOfferExpectFail.
	/// </summary>
	public class StepPurchaseOfferExpectFail : CaseStep
	{
		public Global.PointsOffer po;
        public uint PurchaseOfferPaymentType;
        public Global.OfferType PurchaseOffer;
        public bool IsPointsOffer = true;
		public StepPurchaseOfferExpectFail(Global.OfferType ot, PaymentTypeEnum pt)
		{
			this.PurchaseOffer = ot;
			this.PurchaseOfferPaymentType = (uint) pt;
			IsPointsOffer = false;
		}

		public StepPurchaseOfferExpectFail(Global.PointsOffer po)
		{
			this.po = po;
            this.PurchaseOfferPaymentType = (uint) PaymentTypeEnum.Points;
			IsPointsOffer = true;
		}

		public override bool Execute()
		{
			bool result;
            if (IsPointsOffer)
            {
                // Guarantee we have a points balance
                XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
                XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
                xrlGPB.userPuid = Parent.Puid;
                if (!xrlGPB.Execute(out xrlGPBR))
                {
                    string outputString;
                    outputString = xrlGPB.GetType().Name;
                    outputString += " XErr:" + ServerTestFramework.Global.XErrToString(xrlGPB.XErr) + "  HTTP:" + xrlGPB.httpStatus;
                    Log(outputString);
                }
                Log("Purchasing Offer 0x" + ((ulong)po).ToString("X") + " using PaymentType = " + PurchaseOfferPaymentType.ToString("X") + " EXPECTING FAILURE");
            }
            else
            {
                Log("Purchasing Offer 0x" + ((ulong)PurchaseOffer).ToString("X") + " using PaymentType = " + PurchaseOfferPaymentType.ToString("X") + " EXPECTING FAILURE");
            }
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			if(IsPointsOffer)
			{
				xeop.OfferID = (ulong) po;
			}
			else
			{
				xeop.OfferID = (ulong) PurchaseOffer;
                //if the payment type is Credit Card then get the payment instrument id for the user.
                if (this.PurchaseOfferPaymentType == (uint)PaymentTypeEnum.CreditCard)
                {
                    if ((Parent.PaymentInstrumentId == null) || (Parent.PaymentInstrumentId == ""))
                    {
                        XRLXeGetPaymentInstruments xrlXGPI = new XRLXeGetPaymentInstruments();
                        XRLXeGetPaymentInstrumentsResponse xrlXGPIR = new XRLXeGetPaymentInstrumentsResponse();
                        xrlXGPI.MaxResults = 1;
                        xrlXGPI.UserPuid = Parent.Puid;

                        if (!xrlXGPI.Execute(out xrlXGPIR))
                        {
                            Parent.Log("Failed getting a payment instrument");
                        }
                        Parent.Log("Next step");
                        if (xrlXGPIR.PaymentInstrumentCount == 0)
                        {
                            Parent.Log("Payment instrument needed, creating a new one");
                            XRLXeAddPaymentInstrument xrlXAPI = new XRLXeAddPaymentInstrument();
                            XRLXeAddPaymentInstrumentResponse xrlXAPIR = new XRLXeAddPaymentInstrumentResponse();
                            xrlXAPI.UserPuid = Parent.Puid;
                            xrlXAPI.AddressInfo = Parent.AddressInfo;
                            xrlXAPI.PaymentInstrumentType = (byte)PaymentInstrumentInfoEx.PaymentInstrumentTypeEnum.CreditCard;
                            xrlXAPI.CreditCardInfo = ServerTestFramework.Utilities.CreditCardRandomizer.GenerateVisaCard();
                            if (!xrlXAPI.Execute(out xrlXAPIR))
                            {
                                Parent.Log("Failed adding a payment instrument:" + xrlXAPI.XErr);
                            }

                            Parent.PaymentInstrumentId = xrlXAPIR.PaymentInstrumentId;
                        }
                        else
                        {
                            Parent.Log("No new payment instrument needed");
                            Parent.PaymentInstrumentId = xrlXGPIR.PaymentInstrumentInfo[0].PaymentInstrumentId;
                        }
                    }
                    xeop.PaymentInstrumentID = Parent.PaymentInstrumentId;
                }
                else if (this.PurchaseOfferPaymentType == (uint)PaymentTypeEnum.Token)
                {
                    int i = 0;
                    while (Parent.VouchersUsed[((long)PurchaseOffer).ToString() + (Parent.VoucherNumber % 4).ToString()] != null)
                    {
                        Parent.VoucherNumber++;
                        if (i++ > 4)
                        {
                            break;
                        }
                    }
                    xeop.BillingToken = Global.GetSecondaryVoucher(PurchaseOffer, Parent.VoucherNumber);
                    if (xeop.BillingToken != "")
                        Parent.VouchersUsed[((long)PurchaseOffer).ToString() + (Parent.VoucherNumber % 4).ToString()] = new Object();
                }
            }
			xeop.UserPuid = Parent.Puid;
			xeop.LanguageID = Parent.LanguageID;
			xeop.CountryID = Parent.CountryID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xeop.PaymentType = this.PurchaseOfferPaymentType;
			try
			{
				result = xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (result)
			{				
				Log("A failure was expected");
				return false;			
			}		
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\ScriptXeCases.cs ===
using System;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;

namespace RenewalMatrix.New_Code
{
	// The following enums are just for labeling
	public enum MatrixType
	{
		Matrix_One___Xbox_To_Xenon_Migration_Tests,
		Matrix_Two___Migration_Offer_Renewal_Paths,
		Matrix_Three_Conversion_Credit,
		Matrix_Four__Renewal_Change,
		Matrix_Five__Upgrade_From_Free,
		Matrix_Six___Accounts_In_Decline,
		Matrix_Seven_Initial_Purchase,
		Points_Matrix_One___Signup_Rewards,
		Points_Matrix_Two___Points_Manipulation,
		Points_Matrix_Three_Expiration,
		Points_Matrix_Four__Invalid_Purchase,
		Points_Matrix_Five__Invalid_Points_Addition
	}

	public enum AccountType
	{
		Free,
		Paid,
		Migrated_Paid
	}

	public enum StageType
	{
		First_Authorization_Attempt,
		Locked_Account,
		Expired_Account
	}

	public enum ActionType
	{
		Add_Promo_Points,
		Purchase_Points_With_CC,
		Add_Points_With_Token,
		Purchase_Item_With_Points,
		Purchase_Multiple_Items,
		Purchase_Offer_With_Reward,
		View_Account_After_Point_Lot_Expiration,
		Verify_Points_Account_Expiration,
		Purchase_Item_With_Insufficient_Points,
		Purchase_Item_With_No_Points,
		Purchase_Item_With_No_Points_Account,
		Purchase_Item_With_User_Account_Locked,
		Consume_Too_Many_Points,
		Exercise_Promotion_Too_Many_Times,
		Exercise_Expired_Promotion,
		Add_More_Than_Max_Points,
		Add_Expired_Points_Token,
		Add_Invalid_Points_Token,
		Add_Redeemed_Points_Token
	}

	public enum OfferType
	{
		Xbox_12_Month_Starter,
		Xbox_12_Month_Prepaid,
		Xbox_3_Month_Prepaid,
		Xbox_2_Month_Trial,
		Xbox_Yearly_CC,
		Xbox_Yearly_CC_Pending,
		Xbox_Yearly_CC_Suspended,
		Xbox_Yearly_CC_Expired,
		Xbox_Yearly_CC_Canceled,
		Xbox_Yearly_CC_Charges_Not_Settled,
		Xbox_Monthly_CC,
		Xbox_Monthly_CC_Pending,
		Xbox_Monthly_CC_Suspended,
		Xbox_Monthly_CC_Expired,
		Xbox_Monthly_CC_Canceled,
		Xbox_Monthly_CC_Charges_Not_Settled,
		Xe_Min_PrePaid,
		Xe_Middle_PrePaid,
		Xe_Max_PrePaid,
		Xe_Random_PrePaid,
		Xe_Another_Random_PrePaid,
		Xe_OverStacked_PrePaid,
		Xe_Two_Same_PrePaid,
		Xe_Two_Different_PrePaid,
		Xe_Monthly_CC,
		Xe_Yearly_CC,
		Xe_Migration,
		Xe_Free,
		Xe_Second_Signup,
		None
	}

	/// <summary>
	/// All Xenon Cases
	/// Note: Test cases should match up to Xe renewal matrix test plan
	/// </summary>
	public class ScriptXeCases : Script
	{
		ArrayList timeRollArrays;

		#region Test Name Functions
		public string GenerateTestName(MatrixType mt, OfferType ot, StageType st, OfferType addedOffer)
		{
			string result;
			result = mt + ": Base Offer - " + ot + " | Stage -" + st + " | Add - " + addedOffer;
			result = result.Replace('_',' ');
			return result;
		}

		public string GenerateTestName(MatrixType mt, AccountType acctType, OfferType previousOffer, OfferType newOffer)
		{
			string result;
			result = mt + ": Account Type - " + acctType + " | Previous Offer - " + previousOffer + " | New Offer -" + newOffer;
			result = result.Replace('_',' ');
			return result;
		}

		public string GenerateTestName(MatrixType mt, OfferType ot, OfferType defaultRenewal, OfferType scheduledRenewal)
		{
			string result;
			result = mt + ": Base Offer - " + ot + " | Default Renewal -" + defaultRenewal + " | Switch to - " + scheduledRenewal;
			result = result.Replace('_',' ');
			return result;
		}

		public string GenerateTestName(MatrixType mt, OfferType ot, OfferType stacked)
		{
			string result;
			result = mt + ": Base Offer - " + ot + " | Stacked Offer -" + stacked;
			result = result.Replace('_',' ');
			return result;
		}

		public string GenerateTestName(MatrixType mt, OfferType ot)
		{
			string result;
			result = mt + ": Initial Offer - " + ot;
			result = result.Replace('_',' ');
			return result;
		}

		public string GenerateTestName(MatrixType mt, ActionType at, AccountType acctType)
		{
			string result;
			result = mt + ": Action - " + at + " | on Account - " + acctType;
			result = result.Replace('_',' ');
			return result;
		}
		#endregion

		override public ArrayList GetRolls()
		{
			return timeRollArrays;
		}

		protected override void Initialize()
		{
			ArrayList caseList = new ArrayList();
			timeRollArrays = new ArrayList();

			ArrayList defaultAutoRenewMonthlyCountries = new ArrayList();
			defaultAutoRenewMonthlyCountries.Add(ServerTestFramework.LiveService.UserAccount.XeUser.Country.JP);

			string countryname;
			ServerTestFramework.LiveService.UserAccount.XeUser.Country countrycode;

			//foreach (byte cc in Owner.Countries)
			{
				byte cc = (byte) ServerTestFramework.LiveService.UserAccount.XeUser.Country.US;
				// Determine the country code and string for this test
				countrycode = (ServerTestFramework.LiveService.UserAccount.XeUser.Country) cc;
				countryname = ((ServerTestFramework.LiveService.UserAccount.XeUser.Country) countrycode).ToString();
			
				// TODO:
				//	 Figure out a way to implement the pending cases
				//   Make time rolls adjustable for Overstacked, Identical, Min, Mid, Max
				
				TimeRoll[] TimeRollsForCase;

				#region Subscription and Renewal Cases
				// Subscription and Renewal test cases
				// Test Matrix 1 - Xbox to Xenon Migration	
				
				#region Test Matrix 1 - Xbox to Xenon Migration
				//TC1				
				TimeRollsForCase = new TimeRoll[3];
				
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);			
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.LaunchOffer*2-2)+" Months",TimeRollType.month,(int)Global.OfferLength.LaunchOffer*2-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Starter, OfferType.Xbox_12_Month_Starter),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode), // Set the initial offer as the starter kit
					new StepSetRenewal		(Global.OfferType.LaunchOffer,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 22 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance to the next month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)						// Verify we have moved to the default renewal offer
					));

				//TC2
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.LaunchOffer+(int)Global.OfferLength.PrepaidCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.LaunchOffer+(int)Global.OfferLength.PrepaidCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Starter, OfferType.Xbox_12_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode), // Set the initial offer as the starter kit
					new StepSetRenewal		(Global.OfferType.PrepaidCard,						// Set the next renewal as the 12 month pre-paid card
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 22 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?		// Verify we have moved to the default renewal offer
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC3
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.LaunchOffer+(int)Global.OfferLength.ThreeMonthCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.LaunchOffer+(int)Global.OfferLength.ThreeMonthCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Starter, OfferType.Xbox_3_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),		// Set the initial offer as the starter kit
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,						// Set the next renewal as the Three month card
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),										// Time advance 1 month
					new StepMigrateAccountToXenon(),												// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),										// Time Advance 13 months 15 days
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),										// Time Advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?			// Verify we have moved to the default renewal offer
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC4
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.LaunchOffer-2)+" Months",TimeRollType.month,(int)Global.OfferLength.LaunchOffer-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Starter, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),		// Set the initial offer as the starter kit
					new StepWaitForRoll(TimeRollsForCase[0]),										// Time advance 1 month
					new StepMigrateAccountToXenon(),												// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),										// Time advance 10 months
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),										// Time advance another month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?			// Verify we have moved to the default xenon renwal
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC5
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.LaunchOffer-2)+" Months",TimeRollType.month,(int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.LaunchOffer-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Prepaid, OfferType.Xbox_12_Month_Starter),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),	// Set the initial offer as the 12 moth pre-paid card
					new StepSetRenewal		(Global.OfferType.LaunchOffer,							// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),										// Time advance 1 month
					new StepMigrateAccountToXenon(),												// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),										// Time advance 22 months
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),										// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)							// Verify we have moved to the default renewal offer
					));

				//TC6
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.PrepaidCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.PrepaidCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Prepaid, OfferType.Xbox_12_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),	// Set the initial offer as the 12 moth pre-paid card
					new StepSetRenewal		(Global.OfferType.PrepaidCard,						// Set the next renewal as the 12 month pre-paid card
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 22 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?		// Verify we have moved to the default renewal offer
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC7
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.ThreeMonthCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.PrepaidCard+(int)Global.OfferLength.ThreeMonthCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Prepaid, OfferType.Xbox_3_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),	// Set the initial offer as the 12 moth pre-paid card
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,						// Set the next renewal as the Three month card
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),										// Time advance 1 month
					new StepMigrateAccountToXenon(),												// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),										// Time Advance 13 months
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),										// Time Advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?			// Verify we have moved to the default renewal offer
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC8
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.PrepaidCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.PrepaidCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_12_Month_Prepaid, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),	// Set the initial offer as the 12 moth pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),										// Time advance 1 month
					new StepMigrateAccountToXenon(),												// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),										// Time advance 10 months
					new StepVerify(Global.OfferType.XeMigration),									// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),										// Time advance another month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?			// Verify we have moved to the default xenon renwal
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC9
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.LaunchOffer-2)+" Months",TimeRollType.month,(int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.LaunchOffer-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_3_Month_Prepaid, OfferType.Xbox_12_Month_Starter),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.ThreeMonthCard),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.LaunchOffer,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 13 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)						// Verify we have moved to the default renewal offer
					));

				//TC10
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.PrepaidCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.PrepaidCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_3_Month_Prepaid, OfferType.Xbox_12_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.ThreeMonthCard),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.PrepaidCard,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 13 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC11
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.ThreeMonthCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.ThreeMonthCard+(int)Global.OfferLength.ThreeMonthCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_3_Month_Prepaid, OfferType.Xbox_3_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.ThreeMonthCard),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 4 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC12
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.ThreeMonthCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.ThreeMonthCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_3_Month_Prepaid, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.ThreeMonthCard),countrycode), // Set the initial offer as the three month pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 1 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC13
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.GameTrial+Global.OfferLength.LaunchOffer-2)+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial+(int)Global.OfferLength.LaunchOffer-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_2_Month_Trial, OfferType.Xbox_12_Month_Starter),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.LaunchOffer,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 12 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)						// Verify we have moved to the default renewal offer
					));

				//TC14
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.GameTrial+Global.OfferLength.PrepaidCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial+(int)Global.OfferLength.PrepaidCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_2_Month_Trial, OfferType.Xbox_12_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.PrepaidCard,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 12 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC15
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.GameTrial+(int)Global.OfferLength.ThreeMonthCard-2)+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial+(int)Global.OfferLength.ThreeMonthCard-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_2_Month_Trial, OfferType.Xbox_3_Month_Prepaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.ThreeMonthCard,						// Set the next renewal as the starter kit
						false),
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 3 months
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are still in the migration offer
					new StepWaitForRoll(TimeRollsForCase[2]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC16
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);

				timeRollArrays.Add(TimeRollsForCase);
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_2_Month_Trial, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),									// Time advance 1 month
					new StepMigrateAccountToXenon(),											// Migrate this account
					new StepVerify(Global.OfferType.XeMigration),								// Verify we are in a Xenon Offer
					new StepWaitForRoll(TimeRollsForCase[1]),									// Time advance 1 month
					new StepVerify(defaultAutoRenewMonthlyCountries.Contains(countrycode) ?		// Verify we are in the default offer
					Global.OfferType.XeMonthlyCC : Global.OfferType.XeYearlyCC)
					));

				//TC17 - NYI ** SPECIAL CASE ** Needs billing queue active
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC_Pending, OfferType.None),
//					null
//					//TODO: Add Steps
//					));

				//TC18
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC_Suspended, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepUpdatePaymentInstrument(true),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));

				//TC19
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 7 days",TimeRollType.day,7, false);

				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC_Expired, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyAccountStatus(Global.AccountStatus.Expired),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepUpdatePaymentInstrument(true					),
					new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)						
					));

				//TC20
				// Timerolling for now
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 12 Months",TimeRollType.month,12);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC_Canceled, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyAccountStatus(Global.AccountStatus.Expired),
					new StepWaitForRoll		(TimeRollsForCase[1]),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled)
					));
				//TC21 - NYI **** SPECIAL CASE ****
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC_Pending, OfferType.None),
//					null
//					//TODO: Add Steps
//					));

				//TC22
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC_Suspended, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepUpdatePaymentInstrument(true),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));

				//TC23
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 7 days",TimeRollType.day,7);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC_Expired, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyAccountStatus(Global.AccountStatus.Expired),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepUpdatePaymentInstrument(true					),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyAccountStatus(Global.AccountStatus.Enabled),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)						
					));

				//TC24
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Months",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC_Canceled, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepPreLinkPassportAccount(),
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyAccountStatus(Global.AccountStatus.Expired),
					new StepWaitForRoll		(TimeRollsForCase[1]),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled),
					new StepMigrateAccountToXenonExpectFailure(),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled)
					));

				//TC25 - TODO: Verify steps
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC_Charges_Not_Settled, OfferType.None),
					new StepCreateAccount	(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card\
					new StepSetRenewal		(Global.OfferType.Monthly599	),
					new StepWaitForRoll		(TimeRollsForCase[0]			),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepCloseBalance	(								),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));

				//TC26 - TODO: Verify steps
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 12 Months",TimeRollType.month,12);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC_Charges_Not_Settled, OfferType.None),
					new StepCreateAccount	(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.Yearly4999	),
					new StepWaitForRoll		(TimeRollsForCase[0]			),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepCloseBalance	(								),
					new StepWaitForRoll		(TimeRollsForCase[1]			),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));

				//TC27
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Monthly_CC, OfferType.None),
					new StepCreateAccount	(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.Monthly599	),
					new StepVerify			(Global.OfferType.GameTrial		),
					new StepWaitForRoll		(TimeRollsForCase[0]			),
					new StepVerify			(Global.OfferType.Monthly599	),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));

				//TC28
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int)Global.OfferLength.GameTrial+" Months",TimeRollType.month,(int)Global.OfferLength.GameTrial);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_One___Xbox_To_Xenon_Migration_Tests, OfferType.Xbox_Yearly_CC, OfferType.None),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.GameTrial),countrycode), // Set the initial offer as the three month pre-paid card
					new StepSetRenewal		(Global.OfferType.Yearly4999	),
					new StepVerify			(Global.OfferType.GameTrial		),
					new StepWaitForRoll		(TimeRollsForCase[0]			),
					new StepVerify			(Global.OfferType.Yearly4999	),
					new StepMigrateAccountToXenon(),
					new StepVerify			(Global.OfferType.XeMigration	)
					));
				
				#endregion
				
				#region Test Matrix 2 - Xe Migration Offer Conversion
				//TC29
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Two___Migration_Offer_Renewal_Paths, OfferType.Xe_Migration, OfferType.Xe_Monthly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepVerify			(Global.OfferType.LaunchOffer),
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepVerify			(Global.OfferType.Monthly599),
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewalIfNecessary(countrycode, Global.OfferType.XeMonthlyCC, defaultAutoRenewMonthlyCountries), // Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMonthlyCC)								// Verify we are in the appropriate renewal offer
					));

				//TC30
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Two___Migration_Offer_Renewal_Paths, OfferType.Xe_Migration, OfferType.Xe_Yearly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepVerify			(Global.OfferType.LaunchOffer),
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepVerify			(Global.OfferType.Monthly599),
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewalIfNecessary(countrycode, Global.OfferType.XeYearlyCC, defaultAutoRenewMonthlyCountries),	// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeYearlyCC)								// Verify we are in the appropriate renewal offer
					));

				//TC31
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Two___Migration_Offer_Renewal_Paths, OfferType.Xe_Migration, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepVerify			(Global.OfferType.LaunchOffer),
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepVerify			(Global.OfferType.Monthly599),
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),						// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMinPrepaid)							// Verify we are in the appropriate renewal offer
					));

				//TC32
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Two___Migration_Offer_Renewal_Paths, OfferType.Xe_Migration, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepVerify			(Global.OfferType.LaunchOffer),
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepVerify			(Global.OfferType.Monthly599),
					new StepMigrateAccountToXenon(),											// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),						// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),									// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMiddlePrepaid)							// Verify we are in the appropriate renewal offer
					));

				//TC33 - NYI
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Two___Migration_Offer_Renewal_Paths, OfferType.Xe_Migration, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepVerify			(Global.OfferType.LaunchOffer),
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepVerify			(Global.OfferType.Monthly599),
					new StepMigrateAccountToXenon(),											// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),							// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),									// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMaxPrepaid)								// Verify we are in the appropriate renewal offer
					));
				
				#endregion
				
				#region Test Matrix 3 - Xe Stacking (Conversion Credit)
				//TC34
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMinPrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMinPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC35
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMaxPrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMaxPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC36 
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMiddlePrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeMiddlePrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC37
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeOverstackRenewal-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeOverstackRenewal-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_OverStacked_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepOverstackRenewal(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeOverstackRenewalValue), // Should map to 12 month renewal
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC38
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeIdenticalRenewal-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeIdenticalRenewal-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_Two_Same_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepStackTwoIdenticalRenewals(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeIdenticalRenewalValue), // Should map to 12 month renewal
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC39
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeDifferentRenewalFirst+(int)Global.OfferLength.XeDifferentRenewalSecond-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid+(int)Global.OfferLength.XeDifferentRenewalFirst+(int)Global.OfferLength.XeDifferentRenewalSecond-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Random_PrePaid, OfferType.Xe_Two_Different_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepStackTwoDifferentRenewals(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeDifferentRenewalSecond), // Should map to the second of the two renewals
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC40
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMinPrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMinPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC41
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMaxPrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMaxPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC42
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMiddlePrepaid-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeMiddlePrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC43
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeOverstackRenewal-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeOverstackRenewal-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_OverStacked_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepOverstackRenewal(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeOverstackRenewalValue), // Should map to 12 month renewal
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC44
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeIdenticalRenewal-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeIdenticalRenewal-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_Two_Same_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepStackTwoIdenticalRenewals(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeIdenticalRenewalValue), // Should map to 12 month renewal
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC45
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeDifferentRenewalFirst+(int)Global.OfferLength.XeDifferentRenewalSecond-2)+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid+(int)Global.OfferLength.XeDifferentRenewalFirst+(int)Global.OfferLength.XeDifferentRenewalSecond-2);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Another_Random_PrePaid, OfferType.Xe_Two_Different_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),									//Create an Xenon account with the first "random" (3 month) prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepStackTwoDifferentRenewals(),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeDifferentRenewalSecond), // Should map to the second of the two renewals
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC46
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(((int) Global.OfferLength.LaunchOffer) - 1)+" Month",TimeRollType.month,(((int) Global.OfferLength.LaunchOffer) - 1));
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - "+(int) Global.OfferLength.XeMinPrepaid+" Month",TimeRollType.month,(int) Global.OfferLength.XeMinPrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),						// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMinPrepaid),							// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC47
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - "+(int) Global.OfferLength.XeMaxPrepaid+" Months",TimeRollType.month,(int) Global.OfferLength.XeMaxPrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),						// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMaxPrepaid),							// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC48
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[2] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeMiddlePrepaid+" Months",TimeRollType.month,(int) Global.OfferLength.XeMiddlePrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),						// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeMiddlePrepaid),							// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC49
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeOverstackRenewal+" Months",TimeRollType.month,(int)Global.OfferLength.XeOverstackRenewal);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_OverStacked_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepOverstackRenewal(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeOverstackRenewalValue),					// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC50
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.XeIdenticalRenewal+" Months",TimeRollType.month,(int) Global.OfferLength.XeIdenticalRenewal);
				TimeRollsForCase[2] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_Two_Same_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepStackTwoIdenticalRenewals(),									// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeIdenticalRenewalValue),					// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC51
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+(int) Global.OfferLength.LaunchOffer+" Month",TimeRollType.month,(int) Global.OfferLength.LaunchOffer);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - "+((int) Global.OfferLength.XeDifferentRenewalFirst+(int) Global.OfferLength.XeDifferentRenewalSecond)+" Months",TimeRollType.month,((int) Global.OfferLength.XeDifferentRenewalFirst+(int) Global.OfferLength.XeDifferentRenewalSecond));
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Migration, OfferType.Xe_Two_Different_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.LaunchOffer),countrycode),									//TODO: how to create with CC - Create an Xbox account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.Monthly599),
					new StepWaitForRoll(TimeRollsForCase[0]),								// Roll to get OUT of the initial offer					
					new StepMigrateAccountToXenon(),										// Migrate the account
					new StepStackTwoDifferentRenewals(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[1]),								// Roll to get OUT of the migration offer -- TODO: Fix document
					new StepVerify(Global.OfferType.XeDifferentRenewalSecond),					// Verify we are in the appropriate renewal offer
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC52
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeMinPrepaid+" Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC53
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeMaxPrepaid+" Months",TimeRollType.month,(int) Global.OfferLength.XeMaxPrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC54
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeMiddlePrepaid+" Months",TimeRollType.month,(int) Global.OfferLength.XeMiddlePrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC55 
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int) Global.OfferLength.XeOverstackRenewal+" Months",TimeRollType.month,(int) Global.OfferLength.XeOverstackRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_OverStacked_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepOverstackRenewal(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeOverstackRenewalValue),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC56
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeIdenticalRenewal+" Month",TimeRollType.month,(int)Global.OfferLength.XeIdenticalRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_Two_Same_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepStackTwoIdenticalRenewals(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeIdenticalRenewalValue),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC57 
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeDifferentRenewal+" Months",TimeRollType.month,(int)Global.OfferLength.XeDifferentRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Monthly_CC, OfferType.Xe_Two_Different_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a monthly CC subscription
					new StepStackTwoDifferentRenewals(),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeDifferentRenewalSecond),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC58
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeMinPrepaid+" Month",TimeRollType.month,(int)Global.OfferLength.XeMinPrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepSetRenewal(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMinPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC59
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeMaxPrepaid+" Month",TimeRollType.month,(int)Global.OfferLength.XeMaxPrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_Max_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepSetRenewal(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMaxPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC60
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeMiddlePrepaid+" Month",TimeRollType.month,(int)Global.OfferLength.XeMiddlePrepaid);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepSetRenewal(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMiddlePrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC61
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeOverstackRenewal+" Month",TimeRollType.month,(int)Global.OfferLength.XeOverstackRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_OverStacked_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepOverstackRenewal(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeOverstackRenewalValue),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC62
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeIdenticalRenewal+" Month",TimeRollType.month,(int)Global.OfferLength.XeIdenticalRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_Two_Same_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepStackTwoIdenticalRenewals(),												// Set the renewal if we need to
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeIdenticalRenewalValue),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));

				//TC63
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+(int)Global.OfferLength.XeDifferentRenewal+" Month",TimeRollType.month,(int)Global.OfferLength.XeDifferentRenewal);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Three_Conversion_Credit, OfferType.Xe_Yearly_CC, OfferType.Xe_Two_Different_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//TODO: how to create with CC - Create an Xenon account with a yearly CC subscription
					new StepStackTwoDifferentRenewals(),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeDifferentRenewalSecond),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer() // Seperate because there is no "Free" offer on the SCG side
					));
				
				#endregion
				
				#region Test Matrix 4 - Xe Renewal Change
				
				//TC64
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int) Global.OfferLength.XeRandomPrepaid-2)+" Month",TimeRollType.month,(int) Global.OfferLength.XeRandomPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				//TODO: Add charge verification?
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Four__Renewal_Change, OfferType.Xe_Random_PrePaid, OfferType.None, OfferType.Xe_Monthly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),									//Create an Xenon account with a 12 month prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));

				//TC65 
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int) Global.OfferLength.XeRandomPrepaid-2)+" Month",TimeRollType.month,(int) Global.OfferLength.XeRandomPrepaid-2);
				TimeRollsForCase[2] = new TimeRoll("3nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				//TODO: Add charge verification?
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Four__Renewal_Change, OfferType.Xe_Random_PrePaid, OfferType.None, OfferType.Xe_Yearly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),									//Create an Xenon account with a 12 month prepaid offer)
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC66
				TimeRollsForCase = new TimeRoll[3];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - One Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 10 Month",TimeRollType.month,10);
				TimeRollsForCase[2] = new TimeRoll("3nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Four__Renewal_Change, OfferType.Xe_Yearly_CC, OfferType.Xe_Yearly_CC, OfferType.Xe_Monthly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),									//Create an Xenon account with a Yearly CC renewal
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));
				
				//TC67
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Four__Renewal_Change, OfferType.Xe_Monthly_CC, OfferType.Xe_Monthly_CC, OfferType.Xe_Yearly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),									//Create an Xenon account with a monthly CC renewal
					new StepSetRenewal(Global.OfferType.XeYearlyCC),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));
					
				#endregion

				#region Test Matrix 5 - Xe Upgrade from Free
		
				//TC68
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Months",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 12 Months",TimeRollType.month,12);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.None, OfferType.Xe_Yearly_CC),
					new StepCreateFreeAccount(countrycode),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeYearlyCC), // Should upgrade
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC69
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Months",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("1st Roll - 3 Months",TimeRollType.month,3);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.None, OfferType.Xe_Monthly_CC),
					new StepCreateFreeAccount(countrycode), 
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC), // Should upgrade
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));

				//TC70
				TimeRollsForCase = new TimeRoll[2];
				// Roll for 1 month less
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+((int)Global.OfferLength.XeRandomPrepaid - 1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid - 1);
				// Then roll for 1 month to hit the new subscription
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.None, OfferType.Xe_Random_PrePaid),
					new StepCreateFreeAccount(countrycode),
					new StepSetRenewal(Global.OfferType.XeRandomPrepaid), // Should upgrade
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer()
					));
				
				//TC71
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid - 1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid - 1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.None, OfferType.Xe_Another_Random_PrePaid),
					new StepCreateFreeAccount(countrycode),
					new StepSetRenewal(Global.OfferType.XeAnotherRandomPrepaid), // Should upgrade
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer()
					));

				//TC72
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - 11 Months",TimeRollType.month,11);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Random_PrePaid, OfferType.Xe_Yearly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid), countrycode,true),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeYearlyCC),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC73
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - End of Month",TimeRollType.end_of_month,0);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Random_PrePaid, OfferType.Xe_Monthly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid), countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));

				//TC74
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - "+((int)Global.OfferLength.XeRandomPrepaid- 1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid - 1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Random_PrePaid, OfferType.Xe_Random_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid), countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));

				//TC75
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid- 1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid - 1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Random_PrePaid, OfferType.Xe_Another_Random_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid), countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));

				//TC76
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("4th Roll - 11 Month",TimeRollType.month,11);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Yearly_CC, OfferType.Xe_Yearly_CC),
					new StepCreateAccount("XeYearlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC77
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - 1 Month",TimeRollType.month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Yearly_CC, OfferType.Xe_Monthly_CC),
					new StepCreateAccount("XeYearlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));

				//TC78
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("4th Roll - "+((int)Global.OfferLength.XeRandomPrepaid-1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid-1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Yearly_CC, OfferType.Xe_Random_PrePaid),
					new StepCreateAccount("XeYearlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));

				//TC79
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("4th Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid-1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid-1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Yearly_CC, OfferType.Xe_Another_Random_PrePaid),
					new StepCreateAccount("XeYearlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));

				//TC80
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - 11 Month",TimeRollType.month,11);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Monthly_CC, OfferType.Xe_Yearly_CC),
					new StepCreateAccount("XeMonthlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC81
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.end_of_month,1, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[3] = new TimeRoll("5th Roll - 1 Month",TimeRollType.end_of_month,1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Monthly_CC, OfferType.Xe_Monthly_CC),
					new StepCreateAccount("XeMonthlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));

				//TC82
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1, false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("4th Roll - "+((int)Global.OfferLength.XeRandomPrepaid-1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeRandomPrepaid-1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Monthly_CC, OfferType.Xe_Random_PrePaid),
					new StepCreateAccount("XeMonthlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));

				//TC83
				TimeRollsForCase = new TimeRoll[4];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Month",TimeRollType.month,1,false);
				TimeRollsForCase[2] = new TimeRoll("4th Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[3] = new TimeRoll("4th Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid-1).ToString()+" Months",TimeRollType.month,(int)Global.OfferLength.XeAnotherRandomPrepaid-1);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Five__Upgrade_From_Free, AccountType.Free, OfferType.Xe_Monthly_CC, OfferType.Xe_Another_Random_PrePaid),
					new StepCreateAccount("XeMonthlyCC", countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepCancelSubscription(true),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer(),
					new StepSetRenewal(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[2]),
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[3]),
					new StepVerifyFreeOffer()
					));
				
				#endregion
			
		
				#region Test Matrix 6 - Xe Accounts in Decline
				//TC84
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.First_Authorization_Attempt, OfferType.None),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(4, true						),
					new StepVerify			(Global.OfferType.XeYearlyCC		)					
					));

				//TC85
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.First_Authorization_Attempt, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(4, true						),
					new StepVerify			(Global.OfferType.XeYearlyCC		),
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid, StepSetRenewal.ExpectConvert.Failure, countrycode),
					new StepUpdatePaymentInstrument(true),					
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid),
					new StepVerify			(Global.OfferType.XeThreeMonthPrepaid)
					));

				//TC86
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.Locked_Account, OfferType.None),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //TODO: Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer()
					));

				//TC87
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.Locked_Account, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //TODO: Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer(),
					new StepUpdatePaymentInstrument(true),
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid),
					new StepVerify			(Global.OfferType.XeThreeMonthPrepaid)
					));

				//TC88
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.Locked_Account, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //TODO: Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer(),
					new StepUpdatePaymentInstrument(true),
					new StepSetRenewal		(Global.OfferType.XeOneMonthPrepaid),
					new StepVerify			(Global.OfferType.XeOneMonthPrepaid)
					));

				//TC89
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Yearly_CC, StageType.Expired_Account, OfferType.None),
					new StepCreateAccount("XeYearlyCC",countrycode,true), //TODO: Create Xe Account in Yearly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled),
					new StepVerifyFreeOffer()
					));

				//TC90
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.First_Authorization_Attempt, OfferType.None),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(4, true						),
					new StepVerify			(Global.OfferType.XeMonthlyCC		)
					));

				//TC91
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.First_Authorization_Attempt, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(4, true						),
					new StepVerify			(Global.OfferType.XeMonthlyCC		),
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid, StepSetRenewal.ExpectConvert.Failure, countrycode),
					new StepUpdatePaymentInstrument(true),					
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid),
					new StepVerify			(Global.OfferType.XeThreeMonthPrepaid)
					));

				//TC92
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.Locked_Account, OfferType.None),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer()
					));

				//TC93 - NYI
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.Locked_Account, OfferType.Xe_Middle_PrePaid),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer(),
					new StepUpdatePaymentInstrument(true),
					new StepSetRenewal		(Global.OfferType.XeThreeMonthPrepaid),
					new StepVerify			(Global.OfferType.XeThreeMonthPrepaid)
					));

				//TC94
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.Locked_Account, OfferType.Xe_Min_PrePaid),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(5, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Suspended),
					new StepVerifyFreeOffer(),
					new StepUpdatePaymentInstrument(true),
					new StepSetRenewal		(Global.OfferType.XeOneMonthPrepaid),
					new StepVerify			(Global.OfferType.XeOneMonthPrepaid)
					));

				//TC95
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Six___Accounts_In_Decline, OfferType.Xe_Monthly_CC, StageType.Expired_Account, OfferType.None),
					new StepCreateAccount("XeMonthlyCC",countrycode,true), //TODO: Create Xe Account in Monthly subscription
					new StepCloseBalance	(								),
					new StepStopPayment		(7, true						),
					new StepVerifyAccountStatus(Global.AccountStatus.Canceled),
					new StepVerifyFreeOffer()
					));
				
				#endregion
					
				#region Test Matrix 7 - Xe Initial Purchase

				//TC96
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeRandomPrepaid-1).ToString()+" Month",TimeRollType.month,((int)Global.OfferLength.XeRandomPrepaid-1));
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Seven_Initial_Purchase, OfferType.Xe_Random_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeRandomPrepaid),countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer()
					));

				//TC97
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - "+((int)Global.OfferLength.XeAnotherRandomPrepaid-1).ToString()+" Months",TimeRollType.month,((int)Global.OfferLength.XeAnotherRandomPrepaid-1));
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Seven_Initial_Purchase, OfferType.Xe_Another_Random_PrePaid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeAnotherRandomPrepaid),countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeAnotherRandomPrepaid),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerifyFreeOffer()
					));

				//TC98
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Month",TimeRollType.month,1);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 11 Months",TimeRollType.month,11);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Seven_Initial_Purchase, OfferType.Xe_Yearly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeYearlyCC),countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeYearlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeYearlyCC)
					));

				//TC99
				TimeRollsForCase = new TimeRoll[2];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 2 Weeks",TimeRollType.week,2);
				TimeRollsForCase[1] = new TimeRoll("2nd Roll - End of Month",TimeRollType.end_of_month,0);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Matrix_Seven_Initial_Purchase, OfferType.Xe_Monthly_CC),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeMonthlyCC),countrycode,true),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerify(Global.OfferType.XeMonthlyCC),
					new StepWaitForRoll(TimeRollsForCase[1]),
					new StepVerify(Global.OfferType.XeMonthlyCC)
					));
				#endregion
				
				#endregion
			
				/*
				#region Points Cases
				
				//Points test cases
				#region Test Matrix 8 - Sign Up Rewards - REMOVED - NOT USED FOR LAUNCH
//				//PTC1
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Min_PrePaid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepVerifyRewardPoints(Global.OfferType.XeOneMonthPrepaid, countrycode)
//					));
//
//				//PTC2
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Middle_PrePaid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeThreeMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeThreeMonthPrepaid),
//					new StepVerifyRewardPoints(Global.OfferType.XeThreeMonthPrepaid, countrycode)
//					));
//
//				//PTC3
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Max_PrePaid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepVerifyRewardPoints(Global.OfferType.XeTwelveMonthPrepaid, countrycode)
//					));
//
//				//PTC4
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Yearly_CC),
//					new StepCreateAccount("",countrycode,true), // TODO: How to create an account using a yearly CC offer
//					new StepVerify(Global.OfferType.XeYearlyCC),
//					new StepVerifyRewardPoints(Global.OfferType.XeYearlyCC, countrycode)
//					));
//
//				//PTC5
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Monthly_CC),
//					new StepCreateAccount("",countrycode,true), // TODO: How to create an account using a monthly CC offer
//					new StepVerify(Global.OfferType.XeMonthlyCC),
//					new StepVerifyRewardPoints(Global.OfferType.XeMonthlyCC, countrycode)
//					));
//
//				//PTC6
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Migration),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepVerifyRewardPoints(Global.OfferType.XeMigration, countrycode)
//					));
//
//				//PTC7
//				TimeRollsForCase = new TimeRoll[1];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 1 Months",TimeRollType.month,1);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_One___Signup_Rewards, OfferType.Xe_Second_Signup),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepVerifyRewardPoints(Global.OfferType.XeOneMonthPrepaid, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerifyFreeOffer(),
//					new StepVerifyRewardPoints(Global.OfferType.XeOneMonthPrepaid, countrycode),
//					new StepSetRenewal(Global.OfferType.XeOneMonthPrepaid),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepVerifyRewardPoints(Global.OfferType.XeOneMonthPrepaid, countrycode)
//					));
				#endregion

				#region Test Matrix 9 - Points Manipulation
//				PROMO POINTS TESTS REMOVED - NOT USED FOR LAUNCH
//				//PTC8
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Promo_Points, AccountType.Free),
//					new StepCreateFreeAccount(countrycode),
//					new StepVerifyFreeOffer(false),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOffer, countrycode)				
//					));
//
//				//PTC9
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Promo_Points, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode)				
//					));
//
//				//PTC10
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Promo_Points, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode)				
//					));
//
				//PTC11
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Points_With_CC, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
					));

				//PTC12
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Points_With_CC, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)
					));
				//PTC13
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Points_With_CC, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)
					));
//          *********** REMOVED, NEED TEST OFFERS IN ALL REGIONS, so PMs are testing actual offers
//				//PTC14
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Points_With_Token, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)					
//					));
//
//				//PTC15
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Points_With_Token, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)
//					));
//
//				//PTC16
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Add_Points_With_Token, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)
//					));

				//PTC17
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Item_With_Points, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode, Global.PointsOffer.ItemToPurchase)
					));

				//PTC18
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Item_With_Points, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode, Global.PointsOffer.ItemToPurchase)
					));

				//PTC19
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Item_With_Points, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode, Global.PointsOffer.ItemToPurchase)
					));

				//PTC20
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Multiple_Items, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepPurchaseOffer(Global.PointsOffer.SecondItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode, Global.PointsOffer.ItemToPurchase, Global.PointsOffer.SecondItemToPurchase)
					));

				//PTC21
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Multiple_Items, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepPurchaseOffer(Global.PointsOffer.SecondItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode, Global.PointsOffer.ItemToPurchase, Global.PointsOffer.SecondItemToPurchase)
					));

				//PTC22
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Multiple_Items, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ItemToPurchase),
					new StepPurchaseOffer(Global.PointsOffer.SecondItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode, Global.PointsOffer.ItemToPurchase, Global.PointsOffer.SecondItemToPurchase)
					));

//				//PTC23
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Offer_With_Reward, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepPurchaseOffer(Global.PointsOffer.OfferWithReward),
//					new StepVerifyPoints(Global.PointsOffer.OfferWithReward, countrycode)
//					));
//
//				//PTC24
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Offer_With_Reward, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepPurchaseOffer(Global.PointsOffer.OfferWithRewardPlusReward),
//					new StepVerifyPoints(Global.PointsOffer.OfferWithRewardPlusReward, countrycode)
//					));
//
//				//PTC25
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Two___Points_Manipulation, ActionType.Purchase_Offer_With_Reward, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepPurchaseOffer(Global.PointsOffer.OfferWithRewardPlusReward),
//					new StepVerifyPoints(Global.PointsOffer.OfferWithRewardPlusReward, countrycode)
//					));
				#endregion

				#region Test Matrix 10 - Expiration
				//				PROMO POINTS TESTS REMOVED - NOT USED FOR LAUNCH
//
//				//PTC26
//				TimeRollsForCase = new TimeRoll[2];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Months",TimeRollType.month,1);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.View_Account_After_Point_Lot_Expiration, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOffer, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerifyFreeOffer(false),
//					new StepVerifyPoints(Global.PointsOffer.PromoOffer, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0)
//					));
//
//				//PTC27
//				TimeRollsForCase = new TimeRoll[2];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Months",TimeRollType.month,1);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.View_Account_After_Point_Lot_Expiration, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerify(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0)
//					));
//
//				//PTC28
//				TimeRollsForCase = new TimeRoll[2];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 1 Months",TimeRollType.month,1);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.View_Account_After_Point_Lot_Expiration, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0)					
//					));
//
//				//PTC29
//				TimeRollsForCase = new TimeRoll[3];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 6 Months",TimeRollType.month,6);
//				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 2 Months",TimeRollType.month,2);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.Verify_Points_Account_Expiration, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOffer, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerifyFreeOffer(false),
//					new StepVerifyPoints(Global.PointsOffer.PromoOffer, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0),
//					new StepWaitForRoll(TimeRollsForCase[2]),
//					new StepVerifyNoPointsAccountPresent(),
//					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
//					));
//
//				//PTC30
//				TimeRollsForCase = new TimeRoll[3];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 6 Months",TimeRollType.month,6);
//				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 2 Months",TimeRollType.month,2);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.Verify_Points_Account_Expiration, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),
//					new StepSetRenewal(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepVerify(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0),
//					new StepWaitForRoll(TimeRollsForCase[2]),
//					new StepVerifyNoPointsAccountPresent(),
//					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
//					));
//
//				//PTC31
//				TimeRollsForCase = new TimeRoll[3];
//				TimeRollsForCase[0] = new TimeRoll("1st Roll - 5 Months",TimeRollType.month,5);
//				TimeRollsForCase[1] = new TimeRoll("2nd Roll - 6 Months",TimeRollType.month,6);
//				TimeRollsForCase[2] = new TimeRoll("3rd Roll - 2 Months",TimeRollType.month,2);
//				timeRollArrays.Add(TimeRollsForCase);
//
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Three_Expiration, ActionType.Verify_Points_Account_Expiration, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepSetRenewal(Global.OfferType.XeTwelveMonthPrepaid),
//					new StepRedeemPromoPoints(Global.PointsOffer.PromoOffer), // Token for promo points
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[0]),
//					new StepVerifyPoints(Global.PointsOffer.PromoOfferPlusReward, countrycode),
//					new StepWaitForRoll(TimeRollsForCase[1]),
//					new StepVerifyPoints(0),
//					new StepWaitForRoll(TimeRollsForCase[2]),
//					new StepVerifyNoPointsAccountPresent(),
//					new StepPurchasePoints(Global.PointsOffer.RegularOffer), // Offer id needed for points
//					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
//					));
				#endregion

				#region Test Matrix 11 - Invalid Purchase
				//PTC32
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_Insufficient_Points, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)					
					));

				//PTC33
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_Insufficient_Points, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)					
					));

				//PTC34
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_Insufficient_Points, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOfferPlusReward, countrycode)					
					));

				//PTC35
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepVerifyPoints(0),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(0)					
					));

				//PTC36
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					//new StepVerifyPoints(Global.PointsOffer.Reward, countrycode),
					//new StepPurchaseOffer(Global.PointsOffer.ItemMatchingRewardValue),
					new StepVerifyPoints(0),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(0)					
					));

				//PTC37
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					//new StepVerifyPoints(Global.PointsOffer.Reward, countrycode),
					//new StepPurchaseOffer(Global.PointsOffer.ItemMatchingRewardValue),
					new StepVerifyPoints(0),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(0)					
					));

				//PTC38
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 13 Months",TimeRollType.month,13);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points_Account, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerifyNoPointsAccountPresent(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyNoPointsAccountPresent()
					));

				//PTC39
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 13 Months",TimeRollType.month,13);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points_Account, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeTwelveMonthPrepaid),countrycode,true),
					new StepSetRenewal(Global.OfferType.XeTwelveMonthPrepaid),
					new StepVerify(Global.OfferType.XeTwelveMonthPrepaid),
					//new StepVerifyPoints(Global.PointsOffer.Reward, countrycode),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerifyNoPointsAccountPresent(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyNoPointsAccountPresent()
					));

				//PTC40
				TimeRollsForCase = new TimeRoll[1];
				TimeRollsForCase[0] = new TimeRoll("1st Roll - 13 Months",TimeRollType.month,13);
				timeRollArrays.Add(TimeRollsForCase);

				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_No_Points_Account, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepSetRenewal(Global.OfferType.XeTwelveMonthPrepaid),
					//new StepVerifyPoints(Global.PointsOffer.Reward, countrycode),
					new StepWaitForRoll(TimeRollsForCase[0]),
					new StepVerifyNoPointsAccountPresent(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyNoPointsAccountPresent()
					));

				//PTC41
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_User_Account_Locked, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode),
					new StepLockPointsAccount(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
					));

				//PTC42
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_User_Account_Locked, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepLockPointsAccount(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
					));

				//PTC43
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Purchase_Item_With_User_Account_Locked, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOffer(Global.PointsOffer.RegularOffer), // Offer id needed for points
					new StepLockPointsAccount(),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.RegularOffer, countrycode)
					));

				// Large offer X2 should be over max but large offer + reward should be under max
				// Large offer == Expensive Item in terms of # of points
				//PTC44
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Consume_Too_Many_Points, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOffer, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOffer, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOffer, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.LargeOffer, countrycode)
					));

				//PTC45
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Consume_Too_Many_Points, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode)
					));

				//PTC46
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Four__Invalid_Purchase, ActionType.Consume_Too_Many_Points, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOffer(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepPurchaseOfferExpectFail(Global.PointsOffer.ExpensiveItemToPurchase),
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode)
					));
				#endregion

				#region Test Matrix 12 - Invalid Add
				//				PROMO POINTS TESTS REMOVED - NOT USED FOR LAUNCH
//				//PTC47
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Promotion_Too_Many_Times, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.MaxedPromo), // Token for promo points offer that has reached its limit
//					new StepVerifyPoints(0)				
//					));
//
//				//PTC48
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Promotion_Too_Many_Times, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.MaxedPromo), // Token for promo points offer that has reached its limit
//					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode )				
//					));
//
//				//PTC49
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Promotion_Too_Many_Times, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.MaxedPromo), // Token for promo points offer that has reached its limit
//					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
//					));
//
//				//PTC50
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Expired_Promotion, AccountType.Free),
//					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
//					new StepVerifyFreeOffer(false),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.ExpiredPromo), // Token for promo points offer that has expired
//					new StepVerifyPoints(0)				
//					));
//
//				//PTC51
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Expired_Promotion, AccountType.Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
//					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.ExpiredPromo), // Token for promo points offer that has expired
//					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
//					));
//
//				//PTC52
//				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Exercise_Expired_Promotion, AccountType.Migrated_Paid),
//					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
//					new StepVerify(Global.OfferType.PrepaidCard),
//					new StepMigrateAccountToXenon(),
//					new StepVerify(Global.OfferType.XeMigration),
//					new StepRedeemPromoPointsExpectFail(Global.PointsOffer.ExpiredPromo), // Token for promo points offer that has expired
//					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
//					));

				//PTC53
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_More_Than_Max_Points, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOffer, countrycode)
					));

				//PTC54
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_More_Than_Max_Points, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode)
					));

				//PTC55
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_More_Than_Max_Points, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOffer(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.LargeOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.LargeOfferPlusReward, countrycode)
					));

				//PTC56
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Expired_Points_Token, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.ExpiredOffer), // Offer id needed for points
					new StepVerifyPoints(0)				
					));

				//PTC57
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Expired_Points_Token, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.ExpiredOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));

				//PTC58
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Expired_Points_Token, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.ExpiredOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));

				//PTC59
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Invalid_Points_Token, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.InvalidOffer), // Offer id needed for points
					new StepVerifyPoints(0)				
					));

				//PTC60
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Invalid_Points_Token, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.InvalidOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));

				//PTC61
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Invalid_Points_Token, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.InvalidOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));

				//PTC62
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Redeemed_Points_Token, AccountType.Free),
					new StepCreateFreeAccount(countrycode), // TODO: How to create a free account
					new StepVerifyFreeOffer(false),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.RedeemedOffer), // Offer id needed for points
					new StepVerifyPoints(0)				
					));

				//PTC63
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Redeemed_Points_Token, AccountType.Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.XeOneMonthPrepaid),countrycode,true),
					new StepVerify(Global.OfferType.XeOneMonthPrepaid),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.RedeemedOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));

				//PTC64
				caseList.Add(new Case(countryname + ": " + GenerateTestName(MatrixType.Points_Matrix_Five__Invalid_Points_Addition, ActionType.Add_Redeemed_Points_Token, AccountType.Migrated_Paid),
					new StepCreateAccount(Global.GetVoucherFromOffer(Global.OfferType.PrepaidCard),countrycode),
					new StepVerify(Global.OfferType.PrepaidCard),
					new StepMigrateAccountToXenon(),
					new StepVerify(Global.OfferType.XeMigration),
					new StepRedeemTokenForOfferExpectFail(Global.PointsOffer.RedeemedOffer), // Offer id needed for points
					new StepVerifyPoints(Global.PointsOffer.Reward,countrycode)				
					));
				#endregion
				
				#endregion
				*/
			}
			cases = (Case[]) caseList.ToArray(typeof(Case));
		}

		public ScriptXeCases()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepRedeemPromoPoints.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepRedeemPromoPoints.
	/// </summary>
	public class StepRedeemPromoPoints : CaseStep
	{
		Global.PointsOffer po = Global.PointsOffer.None;

		public StepRedeemPromoPoints()
		{
		}

		public StepRedeemPromoPoints(Global.PointsOffer po)
		{
			this.po = po;
		}

		public override bool Execute()
		{
			// Guarantee we have a points balance
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
			}
			Log("Attempting to redeem promo points using Offer 0x" + ((ulong) po).ToString("X") + " and voucher " + Global.GetVoucherFromOffer(po));
			bool result;
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			xeop.OfferID = (ulong) po;
			xeop.UserPuid = Parent.Puid;
			xeop.PaymentType = (uint) PaymentTypeEnum.Token;
			xeop.BillingToken = Global.GetVoucherFromOffer(po);
			xeop.BillingTokenLength = (ushort) Global.GetVoucherFromOffer(po).Length;
			xeop.CountryID = Parent.CountryID;
			xeop.LanguageID = Parent.LanguageID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);			
			try 
			{
				result = xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (!result)
			{
				Log("A failure was not expected");
				string outputString;
				outputString=xeop.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xeop.XErr)+"  HTTP:"+xeop.httpStatus;
				Log(outputString);
				return false;
			}
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepRedeemTokenForOfferExpectFail.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepRedeemTokenForOfferExpectFail.
	/// </summary>
	public class StepRedeemTokenForOfferExpectFail : CaseStep
	{
		Global.PointsOffer po;

		public StepRedeemTokenForOfferExpectFail()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public StepRedeemTokenForOfferExpectFail(Global.PointsOffer po)
		{
			this.po = po;
		}

		public override bool Execute()
		{
			// Guarantee we have a points balance
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
			}
			Log("Exchanging a token for points using Offer 0x" + ((ulong) po).ToString("X") + " and voucher " + Global.GetVoucherFromOffer(po) + ", expecting failure");
			bool result;
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			xeop.OfferID = (ulong) po;
			xeop.UserPuid = Parent.Puid;
			xeop.PaymentType = (uint) PaymentTypeEnum.Token;
			xeop.BillingToken = Global.GetVoucherFromOffer(po);
			xeop.BillingTokenLength = (ushort) Global.GetVoucherFromOffer(po).Length;
			xeop.CountryID = Parent.CountryID;
			xeop.LanguageID = Parent.LanguageID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);	
			try 
			{
				result= xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (result)
			{
				Log("A failure was expected");
				return false;
			}
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepRedeemPromoPointsExpectFail.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepRedeemPromoPointsExpectFail.
	/// </summary>
	public class StepRedeemPromoPointsExpectFail : CaseStep
	{
		Global.PointsOffer po;

		public StepRedeemPromoPointsExpectFail()
		{
		}

		public StepRedeemPromoPointsExpectFail(Global.PointsOffer po)
		{
			this.po = po;
		}

		public override bool Execute()
		{
			// Guarantee we have a points balance
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
			}
			Log("Attempting to redeem promo points using Offer 0x" + ((ulong) po).ToString("X") + " and voucher " + Global.GetVoucherFromOffer(po) + ", expecting failure");
			bool result;
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			xeop.OfferID = (ulong) po;
			xeop.UserPuid = Parent.Puid;
			xeop.PaymentType = (uint) PaymentTypeEnum.Token;
			xeop.BillingToken = Global.GetVoucherFromOffer(po);
			xeop.BillingTokenLength = (ushort) Global.GetVoucherFromOffer(po).Length;
			xeop.CountryID = Parent.CountryID;
			xeop.LanguageID = Parent.LanguageID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);
			try 
			{
				result= xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (result)
			{
				Log("A failure was expected");
				return false;
			}
			return true;

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepRedeemTokenForOffer.cs ===
using System;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.Database;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepRedeemTokenForOffer.
	/// </summary>
	public class StepRedeemTokenForOffer : CaseStep
	{
		Global.PointsOffer po;

		public StepRedeemTokenForOffer()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public StepRedeemTokenForOffer(Global.PointsOffer po)
		{
			this.po = po;
		}

		public override bool Execute()
		{
			// Guarantee we have a points balance
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
			}
			Log("Exchanging a token for points using Offer 0x" + ((ulong) po).ToString("X") + " and voucher " + Global.GetVoucherFromOffer(po) + ", expecting failure");
			bool result;
			XRLXeOfferPurchase xeop = new XRLXeOfferPurchase();
			xeop.OfferID = (ulong) po;
			xeop.UserPuid = Parent.Puid;
			xeop.PaymentType = (uint) PaymentTypeEnum.Token;
			xeop.BillingToken = Global.GetVoucherFromOffer(po);
			xeop.BillingTokenLength = (ushort) Global.GetVoucherFromOffer(po).Length;
			xeop.CountryID = Parent.CountryID;
			xeop.LanguageID = Parent.LanguageID;
			xeop.Tier = (byte) UodbWS.GetUserTier(Parent.Puid);	
			try 
			{
				result = xeop.Execute();
			}
			catch (Exception e)
			{
				Log("Exception: " + e.Message + "-\n" + e.StackTrace + "\n" + e.InnerException);
				throw e;
			}
			if (!result)
			{
				Log("A failure was not expected");
				string outputString;
				outputString=xeop.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xeop.XErr)+"  HTTP:"+xeop.httpStatus;
				Log(outputString);
				return false;
			}
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyFreeOffer.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyFreeOffer.
	/// </summary>
	public class StepVerifyFreeOffer : CaseStep
	{
		public Global.OfferType Current;
		bool AcceptDowngrade;

		public StepVerifyFreeOffer()
		{
			this.AcceptDowngrade = true;
			Current = Global.OfferType.XeFree;
		}

		public StepVerifyFreeOffer(bool AcceptDowngrade)
		{
			this.AcceptDowngrade = AcceptDowngrade;
			Current = Global.OfferType.XeFree;
		}

		public override bool Execute()
		{
			bool b = false;			// stores result of request call
			bool globalFailure = false;
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 5;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();

			if (AcceptDowngrade)
			{
				if (Parent.Puid != 0)
				{
					// Need to acknowlege the downgrade before we are in the appropriate
					XRLXeAcknowledgeDowngrade xrlXAD = new XRLXeAcknowledgeDowngrade();
					xrlXAD.UserId = Parent.Puid;
					b = xrlXAD.Execute();
					if (!b)
					{
						string outputString;
						outputString=xrlXAD.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlXAD.XErr)+"  HTTP:"+xrlXAD.httpStatus;
						Log(outputString);
					}
				}
				else
				{
					Log("PUID was 0, ignoring request to accept downgrade.");
				}
			}

			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			//xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			//xrlSE.TitleID = 0; //so that game subscriptions don't get enumerated.
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return false;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter > 1)
			{
				Log("Too many subscriptions found");
				return false;
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return false;
			}

			if (currentOffer!=(ulong) Current)
			{
				Log("Current offer mismatch! (Expected "+((ulong)Current).ToString("X")+" got "+currentOffer.ToString("X")+")");
				globalFailure = true;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return false;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("	      Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : "+xrlGUSDR.RenewalOfferId);
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);
			//TODO: Add more verification
			if (globalFailure)
				b = false;
			return b;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepStackTwoDifferentRenewals.cs ===
using System;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepStackTwoDifferentRenewals.
	/// </summary>
	public class StepStackTwoDifferentRenewals : CaseStep
	{
		public StepStackTwoDifferentRenewals()
		{
		}

		public override bool Execute()
		{
			//Parent.UseDifferentVouchers = true;
			Parent.VoucherNumber = 1;
			StepSetRenewal ssr = new StepSetRenewal(Global.OfferType.XeDifferentRenewalFirst);			
			ssr.Parent = this.Parent;
			if (!ssr.Execute())
			{
				Log("Error: Setting first renewal failed");
				return false;
			}
			ssr = new StepSetRenewal(Global.OfferType.XeDifferentRenewalSecond);			
			ssr.Parent = this.Parent;
			if (!ssr.Execute())
			{
				Log("Error: Setting second renewal failed");
				return false;
			}
			//Parent.UseDifferentVouchers = false;
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepSetRenewalIfNecessary.cs ===
using System;
using System.Collections;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepSetRenewalIfNecessary.
	/// </summary>
	public class StepSetRenewalIfNecessary : CaseStep
	{
		public Global.OfferType offerType;
		public ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode;
		public ArrayList defaultAutoRenewCountries;

		public StepSetRenewalIfNecessary(ServerTestFramework.LiveService.UserAccount.XeUser.Country countryCode, Global.OfferType offerType, ArrayList defaultAutoRenewMonthlyCountries)
		{
			this.offerType = offerType;
			this.countryCode = countryCode;
			defaultAutoRenewCountries = defaultAutoRenewMonthlyCountries;
		}

		public override bool Execute()
		{
			Log("Executing renewal if necessary");
			bool result = true;
			//TODO: Verify
			if (!defaultAutoRenewCountries.Contains(countryCode))
			{
				Log("Renewal was necessary");
				StepSetRenewal ssr = new StepSetRenewal(offerType);			
				ssr.Parent = this.Parent;
				result = ssr.Execute();
			}
			return result;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepStackTwoIdenticalRenewals.cs ===
using System;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepStackTwoIdenticalRenewals.
	/// </summary>
	public class StepStackTwoIdenticalRenewals : CaseStep
	{
		public StepStackTwoIdenticalRenewals()
		{
		}

		public override bool Execute()
		{
			//Parent.UseDifferentVouchers = true;
			Parent.VoucherNumber = 1;
			bool result = true;
			StepSetRenewal ssr = new StepSetRenewal(Global.OfferType.XeIdenticalRenewalValue);			
			ssr.Parent = this.Parent;
			result = ssr.Execute();
			if (!result)
			{
				Log("Error: Setting first renewal failed");
				return false;
			}
			ssr = new StepSetRenewal(Global.OfferType.XeIdenticalRenewalValue);			
			ssr.Parent = this.Parent;
			result = ssr.Execute();
			if (!result)
			{
				Log("Error: Setting second renewal failed");
				return false;
			}
			//Parent.UseDifferentVouchers = false;
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyNoPointsAccountPresent.cs ===
using System;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyNoPointsAccountPresent.
	/// </summary>
	public class StepVerifyNoPointsAccountPresent : CaseStep
	{
		public StepVerifyNoPointsAccountPresent()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public override bool Execute()
		{
			Log("VERIFICATION-NYI");
			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyPoints.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyPoints.
	/// </summary>
	public class StepVerifyPoints : CaseStep
	{
		public int numPoints = 0;

		public StepVerifyPoints()
		{
		}

		public StepVerifyPoints(int numPoints)
		{
			this.numPoints = numPoints;
		}

		public StepVerifyPoints(Global.PointsOffer po, ServerTestFramework.LiveService.UserAccount.XeUser.Country cc)
		{
			numPoints = (int) Global.GetPointsOfferValue(po);
		}

		public StepVerifyPoints(Global.PointsOffer po, ServerTestFramework.LiveService.UserAccount.XeUser.Country cc, params Global.PointsOffer[] purchasedOffers)
		{
			numPoints = (int) Global.GetPointsOfferValue(po);
			if (purchasedOffers != null)
			{
				foreach(Global.PointsOffer pointsOffer in purchasedOffers)
				{
					numPoints-= (int) Global.GetPointsOfferValue(pointsOffer);
				}
			}
		}

		public override bool Execute()
		{
			Log("Verifying points balance is " + numPoints);
			XRLXeGetPointsBalance xrlGPB = new XRLXeGetPointsBalance();
			XRLXeGetPointsBalanceResponse xrlGPBR = new XRLXeGetPointsBalanceResponse();
			xrlGPB.userPuid = Parent.Puid;
			if (! xrlGPB.Execute(out xrlGPBR))
			{
				string outputString;
				outputString=xrlGPB.GetType().Name;
				outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGPB.XErr)+"  HTTP:"+xrlGPB.httpStatus;
				Log(outputString);
				return false;
			}
			if (xrlGPBR.PointsBalance != numPoints)
			{
				Log("Expected:" + numPoints + " Actual:" + xrlGPBR.PointsBalance);
				return false;
			}
			Log("Points balance matched:" + numPoints);
			return true;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyRewardPoints.cs ===
using System;
using ServerTestFramework;
using ServerTestFramework.LiveService.UserAccount;
using RenewalMatrix;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyRewardPoints.
	/// **********NYI***************
	/// Not needed for launch
	/// </summary>
	public class StepVerifyRewardPoints : CaseStep
	{
		public int pointsVal = 0;

		public StepVerifyRewardPoints()
		{
		}

		public StepVerifyRewardPoints(Global.OfferType po, ServerTestFramework.LiveService.UserAccount.XeUser.Country cc)
		{
			//TODO: Map offer type to points offer
			//  Call XRLXeContentDetails and get the details of the offer
			
		}

		public override bool Execute()
		{
			//TODO: Call XRLXeGetPointsBalance to verify the current points balance	== pointsVal
			return false;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyPremiumSubscription.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyPremiumSubscription.
	/// </summary>
	public class StepVerifyPremiumSubscription : CaseStep
	{
		public void PrintDebug()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
			XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

			xrlSE.UserPuid = Parent.Puid;
			xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			xrlSE.CountryID = Parent.CountryID;
			xrlSE.LanguageID = Parent.LanguageID;
			xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//xrlSE.GameRating = 0xFFFF;
			xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			xrlSE.TitleID = TitleID;
			xrlSE.TitleCategories = 0xFFFFFFFF;
			xrlSE.QueryForNew = false;
			xrlSE.QueryForRenewals = false;
			xrlSE.QueryForCurrent = true;
			xrlSE.GameRating = 2;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}
				b = xrlSE.Execute(out xrlSER);
				if (!b)
				{
					string outputString;
					outputString=xrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return;
			}

			retryCount = 0;

			XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
			XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

			xrlGUSD.OfferId = (ulong) currentOffer;
			xrlGUSD.UserPuid = Parent.Puid;

			//Call XRLXeGetUserSubscriptionDetails


			// try up to 5 times when request fails due to timeout, etc.
			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}

				b = xrlGUSD.Execute(out xrlGUSDR);

				if (!b)
				{
					string outputString;
					outputString=xrlGUSD.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			//xrlGUSDR.
			// if we've reached the maximum number of retries and still no success, return failure
			if(!b)
				return;

			Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
			Log("         Description : "+xrlGUSDR.Description);
			Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
			Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
			Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
			Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
			Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
			Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X8"));
			Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
			Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
			Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);

		}


		// I intentionally didn't want to add Ignore as an offer type to prevent
		// users from using it for signups or renewals;
		// NOTE: should be made private once I verify with SOAP serialization that everything works.
		public bool IgnoreNext=false;
		public Global.OfferType Current, Next;
		//Added to enumerate subscription for a partitcular titleid
		public uint TitleID;

		public override bool Execute()
		{
			Parent.Log(Header+" verifying offer 0x"+((ulong)Current).ToString("X")+" / "+Next);
			if (!Parent.Xenoned)
			{
				XRLGetSubscriptionStatus request=new XRLGetSubscriptionStatus();
				XRLGetSubscriptionStatusResponse Head;
				XRLGetSubscriptionStatusDetails []Details;

				request.userPuid=Parent.Puid;

				bool b = false;			// stores result of request call
				uint retryCount = 0;	// allows us to retry several times when a request fails
				uint maxRetries = 5;	// defines how many failures we'll tolerate before giving up
				System.Random randomBackoff = new Random();

				// try up to 5 times when request fails due to timeout, etc.
				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						Thread.Sleep(60000 + randomBackoff.Next(30000));
					}

					b = request.Execute(out Head, out Details);

					if (!b)
					{
						string outputString;
						outputString=request.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(request.XErr)+"  HTTP:"+request.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				// if we've reached the maximum number of retries and still no success, return failure
				if(!b)
					return false;

				Log("    Current offer ID : 0x"+Head.currentOfferId.ToString("X"));
				Log("Current offer status : "+Head.currentOfferStatus);
				Log("          Start date : "+Head.startDate.ToLocalTime());
				Log("            End date : "+Head.endDate.ToLocalTime());
				Log("       Next offer ID : 0x"+Head.renewalOfferId.ToString("X"));
				Log("   Next offer status : "+Head.renewalStatus);
				Log("               Grace : "+Head.renewalGracePeriod);
				if (Head.currentOfferId!=(ulong) Current)
				{
					b=false;
					Parent.Log("Current offer mismatch! (Expected 0x"+((uint)Current).ToString("X")+" ("+Current+") got 0x"+Head.currentOfferId.ToString("X")+")" + Head);
				}
				if (!IgnoreNext)
					if ((Head.renewalStatus != (byte) Global.RenewalStatus.NO_RENEWAL && Next == Global.OfferType.None) || (Head.renewalOfferId!=(ulong) Next))
					{
						b=false;
						Parent.Log("Renewal offer mismatch! (Expected 0x"+((uint)Current).ToString("X")+" ("+Next+") got "+Head.renewalOfferId.ToString("X")+")");
					}

				return b;
			}
			else
			{
				bool b = false;			// stores result of request call
				bool globalFailure = false;
				uint retryCount = 0;	// allows us to retry several times when a request fails
				uint maxRetries = 5;	// defines how many failures we'll tolerate before giving up
				ulong currentOffer = 0;
				System.Random randomBackoff = new Random();

				// ******************* BUG WORKAROUND *********************
				//PrintDebug();
				// ***************** END BUG WORKAROUND *******************

				XRLXeSubscriptionEnumerate xrlSE = new XRLXeSubscriptionEnumerate();
				XRLXeSubscriptionEnumerateResponse xrlSER = new XRLXeSubscriptionEnumerateResponse();

				xrlSE.UserPuid = Parent.Puid;
				xrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
				xrlSE.CountryID = Parent.CountryID;
				xrlSE.LanguageID = Parent.LanguageID;
				xrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
					(uint)PaymentTypeEnum.CreditCard |
					(uint)PaymentTypeEnum.Token;
				//xrlSE.GameRating = 0xFFFF;
				xrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
					(uint) OfferingTypeEnum.Renewal;
				xrlSE.TitleID = TitleID;
				xrlSE.TitleCategories = 0xFFFFFFFF;
				xrlSE.QueryForNew = false;
				xrlSE.QueryForRenewals = false;
				xrlSE.QueryForCurrent = true;
				// HACKHACK - Stf not quite there yet
				//xrlSE.RequestFlags |= 0x0008;
				// /HACKHACK
				xrlSE.GameRating = 2;

				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						Thread.Sleep(60000 + randomBackoff.Next(30000));
					}
					try
					{
						//xrlSE.Timeout = 360000;
						b = xrlSE.Execute(out xrlSER);
					}
					catch (Exception e)
					{
						Log(e.ToString());
					}
					if (!b)
					{
						string outputString;
						outputString=xrlSE.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlSE.XErr)+"  HTTP:"+xrlSE.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				if (!b)
				{
					Log("Enumerating subscriptions failed");
					return false;
				}

				int counter = 0;
				foreach (BasicSubscriptionInfo bsi in xrlSER.Subscriptions)
				{
					
					Log(" --- Offer Enumeration --- ");
					Log("Offer ID           :0x" + bsi.OfferID.ToString("X"));
					Log("Offer Name         :" + bsi.OfferName);
					Log("Offer Type         :" + bsi.OfferType); 
					Log("Convert Mode       :" + bsi.ConvertMode);
					Log("Frequency          :" + bsi.Frequency);
					Log("Duration           :" + bsi.Duration);
					Log("Is User Subscribed :" + bsi.userIsSubscribed);
					if (bsi.userIsSubscribed)
					{
						counter++;
						currentOffer = bsi.OfferID;
					}
					Log("-- Prices --");
					foreach (OfferPrice op in bsi.Prices)
						Log(" -- Price	:" + op.PriceText);					
					Log(" ------------------------- ");
				}

				if (counter > 1)
				{
					Log("Too many subscriptions found");
					return false;
				}

				if (counter == 0)
				{
					Log("No subscription found");
					return false;
				}

				if (currentOffer!=(ulong) Current)
				{
					Log(" ** Current offer mismatch! -Expected "+Current+" (0x"+((uint)Current).ToString("X")+") got 0x"+((uint)currentOffer).ToString("X")+"-");
					globalFailure = true;
				}

				retryCount = 0;

				XRLXeGetUserSubscriptionDetails xrlGUSD = new XRLXeGetUserSubscriptionDetails();
				XRLXeGetUserSubscriptionDetailsResponse xrlGUSDR = new XRLXeGetUserSubscriptionDetailsResponse();

				xrlGUSD.OfferId = (ulong) currentOffer;
				xrlGUSD.UserPuid = Parent.Puid;

				//Call XRLXeGetUserSubscriptionDetails


				// try up to 5 times when request fails due to timeout, etc.
				do
				{
					if(retryCount > 0)
					{
						// Backoff on failures
						Log("Retry #" + retryCount + " of " + maxRetries);
						Log("Backing off for random 60-90 second interval");
						Thread.Sleep(60000 + randomBackoff.Next(30000));
					}

					b = xrlGUSD.Execute(out xrlGUSDR);

					if (!b)
					{
						string outputString;
						outputString=xrlGUSD.GetType().Name;
						outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(xrlGUSD.XErr)+"  HTTP:"+xrlGUSD.httpStatus;
						Log(outputString);
						retryCount++;
					}
				}
				while(!b && retryCount <= maxRetries);

				//xrlGUSDR.
				// if we've reached the maximum number of retries and still no success, return failure
				if(!b)
				{
					Log("Get Subscription Status Failed");
					return true;
				}

				Log("    Subscription ID  : "+xrlGUSDR.SubscriptionId);
				Log("         Description : "+xrlGUSDR.Description);
				Log("Current offer details: "+xrlGUSDR.CurrentOfferDetails.OfferingDetails);
				Log("Current offer status : "+xrlGUSDR.CurrentOfferStatus);
				Log("          Start date : "+xrlGUSDR.ActivationDate.ToLocalTime());
				Log("            End date : "+xrlGUSDR.EndDate.ToLocalTime());
				Log("       Purchase date : "+xrlGUSDR.PurchaseDate.ToLocalTime());
				Log("       Next offer ID : 0x"+xrlGUSDR.RenewalOfferId.ToString("X"));
				Log("   Next offer status : "+xrlGUSDR.RenewalOfferStatus);
				Log("  Next offer details : "+xrlGUSDR.RenewalOfferDetails.OfferingDetails);
				Log("               Grace : "+xrlGUSDR.RenewalGracePeriod);
				GetSubscriptionStatus.Status status;
				GetSubscriptionStatus gss = new GetSubscriptionStatus(new LogDelegate(Log));
				gss.GetStatus(Parent.Puid, false, out status, true, true);
				
				//TODO: Add more verification
				if (!IgnoreNext)
					if ((xrlGUSDR.RenewalOfferStatus != (byte) Global.RenewalStatus.NO_RENEWAL && Next == Global.OfferType.None) || (xrlGUSDR.RenewalOfferId!=(ulong) Next))
					{
						b=false;
						Parent.Log("Renewal offer mismatch! (Expected "+ ((uint) Next).ToString("X")+" got "+xrlGUSDR.RenewalOfferId.ToString("X")+")");
					}
				if (globalFailure)
					return false;
				return b;
			}
		}

		public StepVerifyPremiumSubscription(Global.OfferType current, uint titleID)
		{
			IgnoreNext=true;
			Current=current;
			TitleID= titleID;
		}

		public StepVerifyPremiumSubscription(Global.OfferType current, Global.OfferType next, uint titleID)
		{
			Current=current;
			Next=next;
			TitleID = titleID;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyService.cs ===
using System;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Auth;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Used to verify whether the services associated with the title have been granted access by the XKDC or not.
	/// bServiceGranted = true, expects the XKDC to have granted service to the user, while false expects it to not have granted the service
	/// to the user.
	/// Service's associated with the title have to provided in the uint array and also the title needs to be specified.
	/// Summary description for StepVerifyService.
	/// </summary>
	public class StepVerifyService : CaseStep
	{
		public uint TitleID;
		public bool bServiceGranted;
		public uint [] ServiceIDs;

		public override bool Execute()
		{
			bool retValue = false;
			int i; //for loops
			string logStr;
			if(bServiceGranted)
				logStr = " is ";
			else
				logStr = " is NOT ";
			for (i = 0; i<ServiceIDs.Length; i++)
			{
				Parent.Log(Header + " Verifying: the Service: " + ServiceIDs[i].ToString() + logStr + "granted to the user");
			}
			XkdcClient xkdc = new XkdcClient(new AuthContext(AuthContext.ClientTypes.Xenon));

			xkdc.Context.SetUser(AuthContext.MakeUser(Parent.GamerTag, Parent.XenonKey), 0);
			xkdc.Context.SetTitle(TitleID, 0, 0);	
			//by default the UseXmacsTestKey is set to false - doesn't work for the XBLOB environment
			xkdc.Context.UseXmacsTestKey = true;

			//Not auto-discovering serviceIDs, just looking for the one that is of use to us.
			xkdc.SetRequest(this.ServiceIDs, false); 
			try
			{
				xkdc.SignInXkdc();
			}
			catch(KerbErrException ke)
			{
				Log("Kerberos exception: " + ke.ToString());
				return false;
			}
			catch( LogonException le)
			{
				Log("Logon Exception: +" + le.ToString());
				return false;
			}
			catch(Exception ee)
			{
				Log("StepVerifyService exception: " + ee.ToString());
				return false;
			}

			// The Authdata response from XKDC
			XkdcResult result = xkdc.Context.GetXkdcResult();

			Log(result.ToString());
			//verify whether the service was granted by the XKDC
			if (bServiceGranted)
			{
				for (i = 0; i < result.ServiceHRs.Length; i++)
				{
					if (result.ServiceHRs[i] == 0 && result.ServiceIDs[i] != 0)
					{
						retValue = true;
						Log("Service is Granted!!");
					}
				}				
			}
			else
			{
				for (i = 0; i < result.ServiceHRs.Length; i++)
				{
					if (result.ServiceHRs[i] != 0 && result.ServiceHRs[i] != 1 && result.ServiceIDs[i] != 0)
					{
						retValue = true;
						Log("Service is NOT Granted!!");
					}
				}
			}

			return retValue;
		}

		public StepVerifyService(uint titleID, uint[] serviceIDs, bool bserviceGranted)
		{
			this.TitleID = titleID;
			this.ServiceIDs = new uint[serviceIDs.Length];
			Array.Copy(serviceIDs, ServiceIDs, serviceIDs.Length);
			this.bServiceGranted = bserviceGranted;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\CleanserConnection.cs ===
using System;
using System.Net;
using System.Collections.Generic;
using System.Text;
using xonline.common.config;
using xonline.common.mgmt;
using ServerTestFramework;
using System.Net.Sockets;

namespace ReportingInfrastructureTest
{
    // Component IDs
    // 17 - Presence
    // 7 - XUACS
    // 6 - XBOS
    // 5 - XCBK
    public enum ComponentType
    {
        Presence = 17,
        XUACS = 7,
        XBOS = 6,
        XCBK = 5
    }

    public class CleanserConneciton
    {
        ReportMessageData[] data;
        Socket socket;
        bool fixTimePopulated;
        long fixedTime;
        int counter;
        int messageBufferSize;
        long currentTime;

        public CleanserConneciton(ComponentType ct)
        {
            //TODO: remove magic number
            messageBufferSize = 10000;
            data = new ReportMessageData[messageBufferSize];
            for (int i = 0; i < messageBufferSize; i++)
            {
                data[i] = new ReportMessageData();
            }
            counter = 0;
            currentTime = DateTime.UtcNow.ToFileTimeUtc();
            // TODO: Initialize to appropriate VIP
            // This class will begin as a TCP based class, and will move to the XomLogger once I can get that working
            fixTimePopulated = false;
            InitializeSockets((int)ct);
        }

        ~CleanserConneciton()
        {
            try
            {
                if (socket != null)
                {
                    if (socket.Connected)
                    {
                        socket.Shutdown(SocketShutdown.Both);
                    }
                    socket.Close();
                }
            }
            catch(Exception)
            {
                //TODO: Print error message
            }
        }

        public void InitializeSockets(int componentID)
        {
            socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            // TODO: Fix me: Don't hardcode server name
            IInterfaceInfo face = Config.GetInterface(Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.cleanser)[0], Interface.cleanser);
			IPEndPoint remoteEP = new IPEndPoint(face.IPAddress, face.Port);
			// Connect to the remote endpoint.
            socket.Connect(remoteEP);   

			ReportMessageConnect connect = new  ReportMessageConnect();
			//connect.iServerID = 0;    // ServerID is now deprecated in NPDB
            connect.vcServer = face.ServerName;
            
            connect.iComponentID = componentID;
            Send((byte[])connect);
        }

        public bool Send(byte[] buffer)
        {
            int sizeSent;
            lock (this)
            {
                sizeSent = socket.Send(buffer, SocketFlags.None);
            }
            if (sizeSent != buffer.Length)
            {
                throw new Exception("Failed to send full message: original size = " + buffer.Length + " sent size  = " + sizeSent);
            }
            return true;
        }

        public bool Send(string LogLine)
        {
            return this.Send(LogLine, false);
        }

        // TODO: Needs IOCP
        public bool Send(string LogLine, bool fixTime)
        {
            int sizeSent;
            int current_counter = System.Threading.Interlocked.Increment(ref counter);

            if (fixTime)
            {
                if (!fixTimePopulated)
                {
                    fixedTime = DateTime.UtcNow.ToFileTimeUtc();
                    fixTimePopulated = true;
                }
            }
            else
                fixTimePopulated = false;

            data[current_counter % messageBufferSize].szMessage = LogLine;
            data[current_counter % messageBufferSize].usSize = (ushort)(Encoding.UTF8.GetByteCount(LogLine));
            if (!fixTime)
                data[current_counter % messageBufferSize].llTime = DateTime.UtcNow.ToFileTimeUtc();
            else
                data[current_counter % messageBufferSize].llTime = fixedTime;
            System.Threading.Interlocked.Increment(ref currentTime);
            lock (this)
            {
                sizeSent = socket.Send((byte[])data[current_counter % messageBufferSize], SocketFlags.None);
            }
            if (sizeSent != data[current_counter % messageBufferSize].Size())
            {
                throw new Exception("Failed to send full message: original size = " + data[current_counter % messageBufferSize].Size() + " sent size  = " + sizeSent);
            }
            return true;
        }

        public bool CheckConnection()
        {
            // Not exactly a great test, should send a heartbeat
            return socket.Connected;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\StepVerifyXeEnumerate.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.Database;
using RenewalMatrix;

namespace RenewalMatrix.New_Code
{
	/// <summary>
	/// Summary description for StepVerifyXeEnumerate.
	/// To display the subscription offers for live as well as games.
	/// </summary>
	[Serializable]
	public class StepVerifyXeEnumerate : CaseStep
	{
		public XRLXeSubscriptionEnumerate XrlSE;
		public XRLXeSubscriptionEnumerateResponse XrlSER;

		public StepVerifyXeEnumerate()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		public override bool Execute()
		{
			bool b = false;			// stores result of request call
			uint retryCount = 0;	// allows us to retry several times when a request fails
			uint maxRetries = 3;	// defines how many failures we'll tolerate before giving up
			ulong currentOffer = 0;
			System.Random randomBackoff = new Random();
			XrlSE = new XRLXeSubscriptionEnumerate();
			XrlSER = new XRLXeSubscriptionEnumerateResponse();


			XrlSE.UserPuid = Parent.Puid;
			XrlSE.UserTier = (byte) UodbWS.GetUserTier(Parent.Puid);
			XrlSE.CountryID = Parent.CountryID;
			XrlSE.LanguageID = Parent.LanguageID;
			XrlSE.PaymentType = (uint)PaymentTypeEnum.Points |
				(uint)PaymentTypeEnum.CreditCard |
				(uint)PaymentTypeEnum.Token;
			//XrlSE.GameRating = 0xFFFF;
			XrlSE.OfferType = (uint) OfferingTypeEnum.Subscription |
				(uint) OfferingTypeEnum.Renewal;
			XrlSE.TitleID = 0;
			XrlSE.TitleCategories = 0xFFFFFFFF;
			XrlSE.QueryForNew = true;
			XrlSE.QueryForRenewals = true;
			XrlSE.QueryForCurrent = true;
			XrlSE.GameRating = 255;

			do
			{
				if(retryCount > 0)
				{
					// Backoff on failures
					Log("Retry #" + retryCount + " of " + maxRetries);
					Log("Backing off for random 60-90 second interval");
					Thread.Sleep(60000 + randomBackoff.Next(30000));
				}
				b = XrlSE.Execute(out XrlSER);
				if (!b)
				{
					string outputString;
					outputString=XrlSE.GetType().Name;
					outputString+=" XErr:"+ServerTestFramework.Global.XErrToString(XrlSE.XErr)+"  HTTP:"+XrlSE.httpStatus;
					Log(outputString);
					retryCount++;
				}
			}
			while(!b && retryCount <= maxRetries);

			if (!b)
			{
				Log("Enumerating subscriptions failed");
				return b;
			}

			int counter = 0;
			foreach (BasicSubscriptionInfo bsi in XrlSER.Subscriptions)
			{
					
				Log(" --- Offer Enumeration --- ");
				Log("Offer ID           :" + bsi.OfferID.ToString("X8"));
				Log("Offer Name         :" + bsi.OfferName);
				Log("Offer Type         :" + bsi.OfferType); 
				Log("Convert Mode       :" + bsi.ConvertMode);
				Log("Frequency          :" + bsi.Frequency);
				Log("Duration           :" + bsi.Duration);
				Log("Is User Subscribed :" + bsi.userIsSubscribed);
				if (bsi.userIsSubscribed)
				{
					counter++;
					currentOffer = bsi.OfferID;
				}
				Log("-- Prices --");
				foreach (OfferPrice op in bsi.Prices)
					Log(" -- Price	:" + op.PriceText);					
				Log(" ------------------------- ");
			}

			if (counter == 0)
			{
				Log("No subscription found");
				return false;
			}

			return b;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\New Code\Timeline.cs ===
using System;
using System.Collections;

namespace RenewalMatrix.New_Code
{
	enum TimelineClassState
	{
		TIMELINE_INITIALIZED,
		TIMELINE_BUILDING,
		TIMELINE_RUNNING,
		TIMELINE_FINISHED
	}

	/// <summary>
	/// Summary description for Timeline.
	/// </summary>
	public class Timeline
	{
		System.Collections.Queue absoluteTimeSet;
		System.Collections.Hashtable builderSet;
		// Days is the LCD for this stuff
		int totalTimeInDays;
		int runningTotalTimeInDays;
		TimelineClassState state;
		
		public Timeline()
		{
			state = TimelineClassState.TIMELINE_INITIALIZED;
			absoluteTimeSet = null;
			totalTimeInDays = 0;
			runningTotalTimeInDays = 0;
			builderSet = new Hashtable();
		}

		public int Advance()
		{
			if (state != TimelineClassState.TIMELINE_RUNNING)
			{
				throw new Exception("Timeline class is not in the appropriate state to call this function- Expected:" + TimelineClassState.TIMELINE_RUNNING + " Actual:" + state);
			}
			if (absoluteTimeSet.Count == 0)
			{
				state = TimelineClassState.TIMELINE_FINISHED;
				return -1;
			}
			int currentTimeInDays = (int) absoluteTimeSet.Dequeue() - runningTotalTimeInDays;
			runningTotalTimeInDays += currentTimeInDays;
			return currentTimeInDays;
		}

		public int GetCurrentTime()
		{
			if (state != TimelineClassState.TIMELINE_RUNNING)
			{
				throw new Exception("Timeline class is not in the appropriate state to call this function- Expected:" + TimelineClassState.TIMELINE_RUNNING + " Actual:" + state);
			}
			return runningTotalTimeInDays;
		}

		public Queue BuildTimelineFromTimeRolls(Queue timeRolls, DateTime currentTime)
		{
			if (state == TimelineClassState.TIMELINE_INITIALIZED)
			{
				state = TimelineClassState.TIMELINE_BUILDING;
			}
			if (state != TimelineClassState.TIMELINE_BUILDING)
			{
				throw new Exception("Timeline class is not in the appropriate state to call this function- Expected:" + TimelineClassState.TIMELINE_BUILDING + " Actual:" + state);
			}
			Queue testAbsoluteTimeline = new Queue();
			int absoluteTime = 0;
			int finalTime = 0;
			foreach (TimeRoll t in timeRolls)
			{
				int days = 0;
				switch (t.rollType)
				{
					case TimeRollType.day:
						days = t.rollTime;
						break;
					case TimeRollType.week:
						days = t.rollTime * 7;
						break;
					case TimeRollType.month:
					{
						DateTime newTime = currentTime.AddDays(absoluteTime);							
						TimeSpan ts = newTime.AddMonths(t.rollTime) - newTime;
						days = ts.Days;
					}
						break;
					case TimeRollType.no_roll:
						days = 0;
						break;
					case TimeRollType.end_of_month:
					{
						DateTime newTime = currentTime.AddDays(absoluteTime);
						int starting_day = currentTime.Day;
						int day, month, year;
						day = newTime.Day;
						month = newTime.Month;
						year = newTime.Year;
						if (newTime.Day > starting_day)
						{
							TimeSpan ts = newTime.AddMonths(1) - newTime.AddDays(newTime.Day-starting_day);
							// it's ok if we go a day or two over
							// This is just to map to previous functionality
							days = ts.Days;
						}
						else
						{
							if ((newTime.Day - starting_day) != 0)
							{
								days = starting_day - newTime.Day;
							}
							else
							{
								TimeSpan ts = newTime.AddMonths(t.rollTime) - newTime;
								days = ts.Days;									
							}
						}
						// To allow for EOM adjustments (if we are off for a day or two)
						days += t.rollTime;
					}
					break;
				}
				// Calculate the time in days
				absoluteTime+=days;
				if (t.Buffer)
				{
					if (days > 6)
					{
						/*if (builderSet[absoluteTime-2] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime-2] = new Object();
						}*/
						if (builderSet[absoluteTime-1] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime-1] = new Object();
						}
						if (builderSet[absoluteTime] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime] = new Object();
						}/*
						if (builderSet[absoluteTime+1] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime+1] = new Object();
						}
						if (builderSet[absoluteTime+2] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime+2] = new Object();
						}
						if (builderSet[absoluteTime+3] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime+3] = new Object();
						}
						if (builderSet[absoluteTime+4] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime+4] = new Object();
						}
						testAbsoluteTimeline.Enqueue(absoluteTime+5);
						if (builderSet[absoluteTime+5] == null) // if we don't have it in the timeline
						{
							builderSet[absoluteTime+5] = new Object();
						}*/
                        testAbsoluteTimeline.Enqueue(absoluteTime );

						t.absoluteRollTime = absoluteTime;
						if (t.absoluteRollTime > finalTime)
							finalTime = t.absoluteRollTime;
					}
					else
					{
						throw new System.ArgumentException("Buffered Clock rolls under 7 days no longer supported");
					}
				}
				else
				{
					if (days < 7)
						throw new System.ArgumentException("Unbuffered Clock rolls under 7 days no longer supported");
					t.absoluteRollTime = absoluteTime;
					testAbsoluteTimeline.Enqueue(absoluteTime);
					if (absoluteTime > finalTime)
						finalTime = absoluteTime;

					if (builderSet[absoluteTime] == null) // if we don't have it in the timeline
					{
						builderSet[absoluteTime] = new Object();
					}
				}
			}
			if (finalTime > totalTimeInDays)
			{
				totalTimeInDays = finalTime;
			}
			return testAbsoluteTimeline;
		}

		public void FinalizeTimelineForRun()
		{
			if (state != TimelineClassState.TIMELINE_BUILDING)
			{
				throw new Exception("Timeline class is not in the appropriate state to call this function- Expected:" + TimelineClassState.TIMELINE_BUILDING + " Actual:" + state);
			}
			absoluteTimeSet = new Queue();
			// Ah the way to cheat when you know you've got an integer based item whose maximum value will be small
			for (int i = 0; (i-1) < totalTimeInDays; i++)
			{
				if (builderSet[i] !=null)
					absoluteTimeSet.Enqueue(i);
			}
			state = TimelineClassState.TIMELINE_RUNNING;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reportingtargettestbvt_none_12.4.56.0_none_d5b4a2a96043363c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingtargettestbvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.manifest
XP_MANIFEST_PATH=manifests\msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.cat
XP_CATALOG_PATH=manifests\msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.cat
XP_PAYLOAD_PATH=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingtargettestbvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reportingtargettestbvt_none_12.4.56.0_none_d5b4a2a96043363c
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingtargettestbvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.manifest
XP_MANIFEST_PATH=manifests\msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.cat
XP_CATALOG_PATH=manifests\msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12.cat
XP_PAYLOAD_PATH=msil_reportingtargettestbvt_no-public-key_12.4.56.0_x-ww_21503c12
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingtargettestbvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\WebReferences\com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace RenewalMatrix.com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02 {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    // CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
    public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public bdk() {
//			this.Url = "https://oban3/bdk2/bdk.WSDL";
//			this.Url = "https://XONTEBILLSPS03/bdk2/bdk.WSDL";
//			this.Url = "https://xtiebox4/bdk2/bdk.wsdl";
//			this.Url = "https://XBOXSCS41BOX/bdk2/bdk.wsdl";
//			this.Url = "https://fetest98/bdk2/bdk.wsdl"; 
            this.Url = "https://vm1box/scs/scsapiwebservice.asmx?wsdl";
            //this.Url = "https://andrzejp-t1/scs/scsapiwebservice.asmx?wsdl";
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.Invoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
            object[] results = this.Invoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.Invoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.Invoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.Invoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.Invoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID});
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.Invoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID});
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.Invoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID});
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TestConnection(string bstrInputString, out string pbstrOutputString) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        bstrInputString});
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        bstrInputString}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.Invoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.Invoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.Invoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale});
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
            object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.Invoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid});
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.Invoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId});
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML});
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
            this.Invoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendHCI(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.Invoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML});
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale});
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.Invoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.Invoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory});
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML});
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.Invoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription});
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, out string pbstrErrorXML) {
            object[] results = this.Invoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndActivateToken(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\RenewalMatrixAuto\Web References\com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02\Reference.cs ===
﻿//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//     Runtime Version: 1.1.4322.573
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated by Microsoft.VSDesigner, Version 1.1.4322.573.
// 
namespace RenewalMatrix.com.microsoft.extest.ssd.xontebillspsdom.xontebillsps02 {
    using System.Diagnostics;
    using System.Xml.Serialization;
    using System;
    using System.Web.Services.Protocols;
    using System.ComponentModel;
    using System.Web.Services;
    
    
    /// <remarks/>
    // CODEGEN: The optional WSDL extension element 'binding' from namespace 'http://schemas.microsoft.com/soap-toolkit/wsdl-extension' was not handled.
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    [System.Web.Services.WebServiceBindingAttribute(Name="BDKServerObj2SoapBinding", Namespace="http://tempuri.org/wsdl/")]
    public class bdk : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        /// <remarks/>
        public bdk() {
//			this.Url = "https://oban3/bdk2/bdk.WSDL";
//			this.Url = "https://XONTEBILLSPS03/bdk2/bdk.WSDL";
//			this.Url = "https://xtiebox4/bdk2/bdk.wsdl";
//			this.Url = "https://XBOXSCS41BOX/bdk2/bdk.wsdl";
			this.Url = "https://fetest98/bdk2/bdk.wsdl"; 



        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveRoleAssignment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveRoleAssignment(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrRoleAssignmentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveRoleAssignment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrRoleAssignmentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveRoleAssignment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, string bstrServiceComponentGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow,
                        bstrServiceComponentGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPermitsForObjectId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.Invoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPermitsForObjectId(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPermitsForObjectId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPermitsForObjectId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPermitCount, out string pbstrPermitSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPermitCount = ((int)(results[1]));
            pbstrPermitSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreateAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreateAccount(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPPMemberName, string bstrTrackingGUID, string bstrAccountInfoXML, string bstrPaymentInstrumentXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreateAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPPMemberName,
                        bstrTrackingGUID,
                        bstrAccountInfoXML,
                        bstrPaymentInstrumentXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreateAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountId, out string pbstrPaymentInstrumentId, out string pbstrDate, out string bstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountId = ((string)(results[1]));
            pbstrPaymentInstrumentId = ((string)(results[2]));
            pbstrDate = ((string)(results[3]));
            bstrRequiredPaperWorkURL = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.Invoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateAccountInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateAccountInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateAccountInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateAccountInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrRequiredPaperWorkURL = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseAccount", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseAccount(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseAccount", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseAccount(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SignAgreement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, out string pbstrErrorXML) {
            object[] results = this.Invoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSignAgreement(int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrPolicyGUID, int lPolicyVersion, string bstrSignatureDateTime, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SignAgreement", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSignAgreement(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemoveViolation", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemoveViolation(int lDelegateIdHigh, int lDelegateIdLow, string bstrObjectId, int lViolationId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemoveViolation", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrObjectId,
                        lViolationId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemoveViolation(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrStatusInfoXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrStatusInfoXML = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionStatusFromPaymentInstru" +
"ment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionStatusFromPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrStatusChange, string bstrPaymentInstrumentInfoXML, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionStatusFromPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrStatusChange,
                        bstrPaymentInstrumentInfoXML,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionStatusFromPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromAdminPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromAdminPUID(int lDelegateIdHigh, int lDelegateIdLow, int lSearchPUIDHigh, int lSearchPUIDLow, bool fFullData, int lMax, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromAdminPUID", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lSearchPUIDHigh,
                        lSearchPUIDLow,
                        fFullData,
                        lMax}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromAdminPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.Invoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrAccountId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrAccountId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrPaymentInstrumentId, out string pbstrRequiredPaperWorkURL) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrPaymentInstrumentId = ((string)(results[1]));
            pbstrRequiredPaperWorkURL = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPaymentInstrumentsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.Invoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved});
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPaymentInstrumentsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, bool fReturnRemoved, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPaymentInstrumentsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        fReturnRemoved}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPaymentInstrumentsEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPaymentInstrumentInfoCount, out string pbstrPaymentInstrumentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPaymentInstrumentInfoCount = ((int)(results[1]));
            pbstrPaymentInstrumentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdatePaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdatePaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdatePaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdatePaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.RemovePaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void RemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginRemovePaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("RemovePaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndRemovePaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SettleBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSettleBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SettleBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSettleBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TransferBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTransferBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TransferBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTransferBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CloseBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCloseBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrLineItemId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CloseBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrLineItemId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCloseBalance(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SwitchPaymentInstruments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.Invoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSwitchPaymentInstruments(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrFromPaymentInstrumentId, string bstrToPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SwitchPaymentInstruments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrFromPaymentInstrumentId,
                        bstrToPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSwitchPaymentInstruments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AddComment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAddComment(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddComment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAddComment(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetComments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.Invoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetComments(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetComments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetComments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCommentInfoSetCount, out string pbstrCommentInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCommentInfoSetCount = ((int)(results[1]));
            pbstrCommentInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOffering", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOffering(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOffering", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOffering(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.PurchaseOfferingEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void PurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrSubscriptionId, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceCount, 
                    out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.Invoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginPurchaseOfferingEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    string bstrSubscriptionName, 
                    string bstrAccountId, 
                    string bstrBaseSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrPaymentInstrumentId, 
                    string bstrShippingAddressId, 
                    string bstrActivationDate, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("PurchaseOfferingEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionName,
                        bstrAccountId,
                        bstrBaseSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrPaymentInstrumentId,
                        bstrShippingAddressId,
                        bstrActivationDate,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndPurchaseOfferingEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionId, out string pbstrAmountChargedXML, out int plAddedServiceInstanceCount, out string pbstrAddedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionId = ((string)(results[1]));
            pbstrAmountChargedXML = ((string)(results[2]));
            plAddedServiceInstanceCount = ((int)(results[3]));
            pbstrAddedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.Invoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, bool fComputeOnly, string bstrSubscriptionId, string bstrCancelDate, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        bstrSubscriptionId,
                        bstrCancelDate,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML, out int plRemovedServiceInstanceCount, out string pbstrRemovedServiceInstanceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
            plRemovedServiceInstanceCount = ((int)(results[3]));
            pbstrRemovedServiceInstanceSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SearchAccounts", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML});
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSearchAccounts(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, int lMax, string bstrSearchXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SearchAccounts", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        lMax,
                        bstrSearchXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSearchAccounts(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pfMoreRows, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pfMoreRows = ((int)(results[1]));
            plAccountInfoCount = ((int)(results[2]));
            pbstrAccountInfoSetXML = ((string)(results[3]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptions", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.Invoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptions(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptions", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptions(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plSubscriptionInfoCount, out string pbstrSubscriptionInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plSubscriptionInfoCount = ((int)(results[1]));
            pbstrSubscriptionInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetSubscriptionHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.Invoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetSubscriptionHistory(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetSubscriptionHistory", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetSubscriptionHistory(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plHistoryEventCount, out string pbstrSubscriptionHistoryEventSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plHistoryEventCount = ((int)(results[1]));
            pbstrSubscriptionHistoryEventSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetReferralData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.Invoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetReferralData(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetReferralData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetReferralData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plReferralCount, out string pbstrReferralSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plReferralCount = ((int)(results[1]));
            pbstrReferralSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscription(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ConvertSubscriptionEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    out string pbstrErrorXML, 
                    out string pbstrAmountChargedXML, 
                    out int plAddedServiceInstanceSetCount, 
                    out string pbstrAddedServiceInstanceSet, 
                    out int plRemovedServiceInstanceSetCount, 
                    out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginConvertSubscriptionEx(
                    int lDelegateIdHigh, 
                    int lDelegateIdLow, 
                    int lRequesterIdHigh, 
                    int lRequesterIdLow, 
                    string bstrTrackingGUID, 
                    bool fComputeOnly, 
                    int lConvertMode, 
                    int lOverrideFlags, 
                    string bstrSubscriptionName, 
                    string bstrSubscriptionId, 
                    string bstrOfferingGUID, 
                    int lOverrideAmount, 
                    string bstrSubscriptionEndDate, 
                    string bstrReferralSetXML, 
                    string bstrPaymentInstrumentId, 
                    string bstrTokenId, 
                    string bstrPolicyGUID, 
                    int lPolicyVersion, 
                    string bstrSignatureDateTime, 
                    System.AsyncCallback callback, 
                    object asyncState) {
            return this.BeginInvoke("ConvertSubscriptionEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        fComputeOnly,
                        lConvertMode,
                        lOverrideFlags,
                        bstrSubscriptionName,
                        bstrSubscriptionId,
                        bstrOfferingGUID,
                        lOverrideAmount,
                        bstrSubscriptionEndDate,
                        bstrReferralSetXML,
                        bstrPaymentInstrumentId,
                        bstrTokenId,
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrSignatureDateTime}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndConvertSubscriptionEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UpdateSubscriptionInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUpdateSubscriptionInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, string bstrSubscriptionInfoXML, string bstrReferralSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UpdateSubscriptionInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        bstrSubscriptionInfoXML,
                        bstrReferralSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUpdateSubscriptionInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.Invoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountStatusInfoXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferings(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferings", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBaseOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBaseOfferingsEx(string bstrOfferingGUID, string bstrCategory, string bstrCountry, string bstrLocale, string bstrCurrency, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBaseOfferingsEx", new object[] {
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrCountry,
                        bstrLocale,
                        bstrCurrency,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBaseOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferings", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferings(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferings", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferings(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleOfferingsEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.Invoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId});
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleOfferingsEx(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrAccountId, string bstrOfferingGUID, string bstrCategory, string bstrFilter, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleOfferingsEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrAccountId,
                        bstrOfferingGUID,
                        bstrCategory,
                        bstrFilter,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleOfferingsEx(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plOfferingInfoCount, out string pbstrOfferingInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plOfferingInfoCount = ((int)(results[1]));
            pbstrOfferingInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetServiceComponents", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetServiceComponents(string bstrOfferingGUID, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.Invoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID});
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetServiceComponents(string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetServiceComponents", new object[] {
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetServiceComponents(System.IAsyncResult asyncResult, out string pbstrErrorText, out int plServiceComponentCount, out string pbstrServiceComponentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            plServiceComponentCount = ((int)(results[1]));
            pbstrServiceComponentSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourcePrices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.Invoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID});
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourcePrices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, string bstrOfferingGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourcePrices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        bstrOfferingGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourcePrices(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plCount, out string pbstrResourcePriceSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plCount = ((int)(results[1]));
            pbstrResourcePriceSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ValidateProvisioningData", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginValidateProvisioningData(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, string bstrDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ValidateProvisioningData", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId,
                        bstrDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndValidateProvisioningData(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CheckProvisioningStatus", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.Invoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCheckProvisioningStatus(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceComponentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CheckProvisioningStatus", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceComponentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCheckProvisioningStatus(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrResponseXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrResponseXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ProvisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginProvisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ProvisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndProvisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.DeprovisionServices", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void DeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginDeprovisionServices(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrServiceInstanceSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("DeprovisionServices", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrServiceInstanceSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndDeprovisionServices(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReportUsageEvent", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReportUsageEvent(string bstrTrackingGUID, string bstrUsageSetXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReportUsageEvent", new object[] {
                        bstrTrackingGUID,
                        bstrUsageSetXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReportUsageEvent(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetResourceBalances", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.Invoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID});
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetResourceBalances(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrResourceGUID, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetResourceBalances", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrResourceGUID}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetResourceBalances(System.IAsyncResult asyncResult, out string pbstrErrorText, out int pcResourceInfoCount, out string pbstrResourceInfoSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorText = ((string)(results[0]));
            pcResourceInfoCount = ((int)(results[1]));
            pbstrResourceInfoSet = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustResourceBalance", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustResourceBalance(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrObjectId, string bstrResourceGUID, int lNumberOfUnits, string bstrUnitsOfMeasure, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustResourceBalance", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrObjectId,
                        bstrResourceGUID,
                        lNumberOfUnits,
                        bstrUnitsOfMeasure,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustResourceBalance(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CreditPaymentInstrumentEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCreditPaymentInstrumentEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, string bstrSubscriptionId, int lFinancialReportingCode, string bstrAmount, bool fImmediatelySettle, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CreditPaymentInstrumentEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        bstrSubscriptionId,
                        lFinancialReportingCode,
                        bstrAmount,
                        fImmediatelySettle,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCreditPaymentInstrumentEx(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, out string pbstrError) {
            object[] results = this.Invoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML});
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem(System.IAsyncResult asyncResult, out string pbstrError) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.TestConnection", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void TestConnection(string bstrInputString, out string pbstrOutputString) {
            object[] results = this.Invoke("TestConnection", new object[] {
                        bstrInputString});
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginTestConnection(string bstrInputString, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("TestConnection", new object[] {
                        bstrInputString}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndTestConnection(System.IAsyncResult asyncResult, out string pbstrOutputString) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrOutputString = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanUser(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanUser", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanUser(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanUser", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanUser(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, int lReasonCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lReasonCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.UnbanPaymentInstrument", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void UnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginUnbanPaymentInstrument(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("UnbanPaymentInstrument", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndUnbanPaymentInstrument(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.IsPaymentInstrumentBanned", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void IsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.Invoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginIsPaymentInstrumentBanned(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsPaymentInstrumentBanned", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndIsPaymentInstrumentBanned(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plIsBanned) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plIsBanned = ((int)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.StopPayments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void StopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML) {
            object[] results = this.Invoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginStopPayments(int lDelegateIdHigh, int lDelegateIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("StopPayments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndStopPayments(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReschedulePayment", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.Invoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReschedulePayment(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrPaymentInstrumentId, bool fApplyDeclineEffects, string bstrNewDueDate, bool fStickyDueDate, int lTransactionType, string bstrSettlementDetailsXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReschedulePayment", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrPaymentInstrumentId,
                        fApplyDeclineEffects,
                        bstrNewDueDate,
                        fStickyDueDate,
                        lTransactionType,
                        bstrSettlementDetailsXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReschedulePayment(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedSetXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountActivity", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.Invoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountActivity(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, int lBillingPeriodId, string bstrLocale, bool fDeep, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountActivity", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        lBillingPeriodId,
                        bstrLocale,
                        fDeep}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountActivity(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAccountActivityXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAccountActivityXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetBillingPeriods", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.Invoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale});
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetBillingPeriods(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrObjectId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetBillingPeriods", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrObjectId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetBillingPeriods(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plBillingPeriodCount, out string pbstrBillingPeriodSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plBillingPeriodCount = ((int)(results[1]));
            pbstrBillingPeriodSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetStatement", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.Invoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet});
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetStatement(int delegateIdHigh, int delegateIdLow, int requesterIdHigh, int requesterIdLow, string objectId, System.UInt32 beginBillingPeriodId, System.UInt32 endBillingPeriodId, System.Byte returnStatementSet, bool returnNotificationSet, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetStatement", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        requesterIdHigh,
                        requesterIdLow,
                        objectId,
                        beginBillingPeriodId,
                        endBillingPeriodId,
                        returnStatementSet,
                        returnNotificationSet}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetStatement(System.IAsyncResult asyncResult, out string errorXml, out string accountStatementInfoSetXml, out string userNotificationSetXml) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            accountStatementInfoSetXml = ((string)(results[1]));
            userNotificationSetXml = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SyncUPSCacheForPUID", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, out string pbstrErrorXML) {
            object[] results = this.Invoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSyncUPSCacheForPUID(int lCustomerPUIDHigh, int lCustomerPUIDLow, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SyncUPSCacheForPUID", new object[] {
                        lCustomerPUIDHigh,
                        lCustomerPUIDLow}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSyncUPSCacheForPUID(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetKey", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.Invoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid});
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetKey(int lRequesterIdHigh, int lRequesterIdLow, string bstrKeyGuid, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetKey", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrKeyGuid}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetKey(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrKeyXml) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrKeyXml = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAdjustments", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.Invoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId});
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAdjustments(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAdjustments", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAdjustments(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int pcAppliedAdjustmentCount, out string pbstrAppliedAdjustmentSetXML, out int pcAvailableAdjustmentCount, out string pbstrAvailableAdjustmentSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pcAppliedAdjustmentCount = ((int)(results[1]));
            pbstrAppliedAdjustmentSetXML = ((string)(results[2]));
            pcAvailableAdjustmentCount = ((int)(results[3]));
            pbstrAvailableAdjustmentSetXML = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, int lBillingPeriodId, string bstrAdjustmentGUID, string bstrAmount, string bstrCommentTextXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        lBillingPeriodId,
                        bstrAdjustmentGUID,
                        bstrAmount,
                        bstrCommentTextXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CompleteConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCompleteConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CompleteConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCompleteConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            plAddedServiceInstanceSetCount = ((int)(results[2]));
            pbstrAddedServiceInstanceSet = ((string)(results[3]));
            plRemovedServiceInstanceSetCount = ((int)(results[4]));
            pbstrRemoveServiceInstanceSet = ((string)(results[5]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.CancelConversion", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void CancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.Invoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId});
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginCancelConversion(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTrackingGUID, string bstrSubscriptionId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("CancelConversion", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndCancelConversion(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAddedServiceInstanceSetCount, out string pbstrAddedServiceInstanceSet, out int plRemovedServiceInstanceSetCount, out string pbstrRemoveServiceInstanceSet) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAddedServiceInstanceSetCount = ((int)(results[1]));
            pbstrAddedServiceInstanceSet = ((string)(results[2]));
            plRemovedServiceInstanceSetCount = ((int)(results[3]));
            pbstrRemoveServiceInstanceSet = ((string)(results[4]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ImportSettledBillingItem", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.Invoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML});
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginImportSettledBillingItem(int lDelegateIdHigh, int lDelegateIdLow, string bstrSubscriptionId, string bstrPaymentInstrumentId, string bstrTaxAddressId, string bstrTrackingGUID, string bstrSettledBillingItemXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ImportSettledBillingItem", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrSubscriptionId,
                        bstrPaymentInstrumentId,
                        bstrTaxAddressId,
                        bstrTrackingGUID,
                        bstrSettledBillingItemXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndImportSettledBillingItem(System.IAsyncResult asyncResult, out string pbstrResultXML, out string pbstrNewLineItemsXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrResultXML = ((string)(results[0]));
            pbstrNewLineItemsXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.MatchPaymentInstrumentInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void MatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.Invoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginMatchPaymentInstrumentInfo(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrTelenumericLastName, string bstrZipCode, string bstrPaymentInstrumentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("MatchPaymentInstrumentInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrTelenumericLastName,
                        bstrZipCode,
                        bstrPaymentInstrumentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndMatchPaymentInstrumentInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAdminPUIDHigh, out int plAdminPUIDLow) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAdminPUIDHigh = ((int)(results[1]));
            plAdminPUIDLow = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ReinstateSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.Invoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginReinstateSubscription(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrSubscriptionId, int lReserved, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ReinstateSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrSubscriptionId,
                        lReserved,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndReinstateSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrAmountChargedXML, out string pbstrSubscriptionStatusInfoXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrAmountChargedXML = ((string)(results[1]));
            pbstrSubscriptionStatusInfoXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetEligibleSwitchPITypes", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.Invoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId});
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetEligibleSwitchPITypes(int lDelegateIdHigh, int lDelegateIdLow, int lRequesterIdHigh, int lRequesterIdLow, string bstrPaymentInstrumentId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetEligibleSwitchPITypes", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        bstrPaymentInstrumentId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetEligibleSwitchPITypes(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plPITypeCount, out string pbstrPITypeSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plPITypeCount = ((int)(results[1]));
            pbstrPITypeSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.SendHCI", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void SendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale) {
            this.Invoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale});
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginSendHCI(int lDelegateIdHigh, int lDelegateIdLow, string bstrAccountId, int lBillingPeriodId, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SendHCI", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrAccountId,
                        lBillingPeriodId,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndSendHCI(System.IAsyncResult asyncResult) {
            this.EndInvoke(asyncResult);
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.OffsetLineItem2", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void OffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.Invoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML});
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginOffsetLineItem2(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrLineItemId, int lFinancialReportingCode, bool fImmediatelySettle, string bstrAmount, string bstrCommentInfoXML, string bstrReservedXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("OffsetLineItem2", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrLineItemId,
                        lFinancialReportingCode,
                        fImmediatelySettle,
                        bstrAmount,
                        bstrCommentInfoXML,
                        bstrReservedXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndOffsetLineItem2(System.IAsyncResult asyncResult, out string pbstrError, out string pbstrNewLineItemXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrError = ((string)(results[0]));
            pbstrNewLineItemXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetPolicy", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.Invoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale});
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetPolicy(string bstrPolicyGUID, int lPolicyVersion, string bstrLocale, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetPolicy", new object[] {
                        bstrPolicyGUID,
                        lPolicyVersion,
                        bstrLocale}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetPolicy(System.IAsyncResult asyncResult, out string pbstrPolicyInfoXML, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrPolicyInfoXML = ((string)(results[0]));
            pbstrErrorXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ExtendSubscription", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.Invoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML});
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginExtendSubscription(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrSubscriptionId, int lNumberOfDays, string bstrCommentInfoXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ExtendSubscription", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrSubscriptionId,
                        lNumberOfDays,
                        bstrCommentInfoXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndExtendSubscription(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrNewExpirationDate) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrNewExpirationDate = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetAccountIdFromTokenId", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.Invoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetAccountIdFromTokenId(int lDelegateIdHigh, int lDelegateIdLow, bool fFullData, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetAccountIdFromTokenId", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        fFullData,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetAccountIdFromTokenId(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountInfoCount, out string pbstrAccountInfoSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountInfoCount = ((int)(results[1]));
            pbstrAccountInfoSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfo", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfo(int lDelegateIdHigh, int lDelegateIdLow, string bstrTokenId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfo", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTokenId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfo(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetLineItemHistory", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.Invoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory});
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetLineItemHistory(int delegateIdHigh, int delegateIdLow, string lineItemId, bool returnHistory, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetLineItemHistory", new object[] {
                        delegateIdHigh,
                        delegateIdLow,
                        lineItemId,
                        returnHistory}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetLineItemHistory(System.IAsyncResult asyncResult, out string errorXml, out string lineItemHistorySetXml, out string mcv) {
            object[] results = this.EndInvoke(asyncResult);
            errorXml = ((string)(results[0]));
            lineItemHistorySetXml = ((string)(results[1]));
            mcv = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetExistingAccountsByCriteria", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.Invoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML});
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetExistingAccountsByCriteria(int lDelegateIdHigh, int lDelegateIdLow, string bstrCriteriaXML, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetExistingAccountsByCriteria", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrCriteriaXML}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetExistingAccountsByCriteria(System.IAsyncResult asyncResult, out string pbstrErrorXML, out int plAccountDetailCount, out string pbstrAccountDetailSetXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            plAccountDetailCount = ((int)(results[1]));
            pbstrAccountDetailSetXML = ((string)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.AdjustGotoBAMDate", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void AdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, out string pbstrErrorXML) {
            object[] results = this.Invoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginAdjustGotoBAMDate(int lRequesterIdHigh, int lRequesterIdLow, int lOffset, string bstrObjectId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AdjustGotoBAMDate", new object[] {
                        lRequesterIdHigh,
                        lRequesterIdLow,
                        lOffset,
                        bstrObjectId}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndAdjustGotoBAMDate(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.BlacklistToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void BlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.Invoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription});
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginBlacklistToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, string bstrEffectiveTime, string bstrReason, string bstrDescription, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("BlacklistToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType,
                        bstrEffectiveTime,
                        bstrReason,
                        bstrDescription}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndBlacklistToken(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrBlacklistActionSetXML, out int plBlacklistActionSetCount) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrBlacklistActionSetXML = ((string)(results[1]));
            plBlacklistActionSetCount = ((int)(results[2]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.ActivateToken", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void ActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, out string pbstrErrorXML) {
            object[] results = this.Invoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginActivateToken(int lDelegateIdHigh, int lDelegateIdLow, string bstrTrackingGUID, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("ActivateToken", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrTrackingGUID,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndActivateToken(System.IAsyncResult asyncResult, out string pbstrErrorXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
        }
        
        /// <remarks/>
        [System.Web.Services.Protocols.SoapRpcMethodAttribute("http://tempuri.org/action/BDKServerObj2.GetTokenInfoEx", RequestNamespace="http://tempuri.org/message/", ResponseNamespace="http://tempuri.org/message/")]
        public void GetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.Invoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType});
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
        
        /// <remarks/>
        public System.IAsyncResult BeginGetTokenInfoEx(int lDelegateIdHigh, int lDelegateIdLow, string bstrToken, int lTokenType, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetTokenInfoEx", new object[] {
                        lDelegateIdHigh,
                        lDelegateIdLow,
                        bstrToken,
                        lTokenType}, callback, asyncState);
        }
        
        /// <remarks/>
        public void EndGetTokenInfoEx(System.IAsyncResult asyncResult, out string pbstrErrorXML, out string pbstrTokenOrderXML) {
            object[] results = this.EndInvoke(asyncResult);
            pbstrErrorXML = ((string)(results[0]));
            pbstrTokenOrderXML = ((string)(results[1]));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\ReportingTargetTestInit.cs ===
using System;
using System.Threading;
using System.Data.SqlClient;
using System.Net;
using System.Collections;
//
using ServerTestFramework;
using ServerTestFramework.Utilities;
//
using xonline.common.config;
using xonline.common.mgmt;

[assembly: XomAreaDefinition(XomAreaName.Reporting)]
[assembly: RootNode(typeof(ReportingInfrastructureTest.ReportingInfrTestBVTs))]

namespace ReportingInfrastructureTest
{
    public class ReportingInfrTestBVTs : TestNode
    {				
        public static Random rnd = new Random();
        public static RandomEx RandGen = new RandomEx();
        public static uint DashTitleId_Xbox = 0xFFFE0000;
        public static uint DashTitleId_Xenon = 0xFFFE07D1;

        public ReportingInfrTestBVTs()
        {
            AddChild(new BasePopulate("Base Populate"));
            AddChild(new LiveSvc_XUACS_Logs("LiveSvc_XUACS_Logs"));
            AddChild(new LiveSvc_XPSERVER_Logs("LiveSvc_XPSERVER_Logs"));
            AddChild(new LiveSvc_XBOS_Logs("LiveSvc_XBOS_Logs"));
            AddChild(new LiveSvc_XCBK_Logs("LiveSvc_XCBK_Logs"));
            AddChild(new LiveSvc_STRINGSVR_Logs("LiveSvc_STRINGSVR_Logs"));
            AddChild(new LiveSvc_STATSSVR_Logs("LiveSvc_STATSSVR_Logs"));
        }

        public override void PreRun()
        {
            // Let the fake SG know where to send state updates   
			xonline.common.config.Config.NpdbServer = xonline.common.config.Config.NpdbServer;
                        ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.SetStateEndpoint(Global.XEnv.GetVirtualInterface(xonline.common.config.VirtualInterface.xpnfd_presence).ToString());
			CUtil.Environment = Global.XEnv.GetEnv().ToLower();
			//IBucketServer pBucket = Config.GetBucketServer(Interface.cleanser, (uint)Config.ServerId);		
			// This is the server mapped to the client - used for xmgmt
			//CUtil.CleanserServerName = pBucket.CurrentServerName; 
			CUtil.CleanserServerName = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.cleanser)[0];
            CUtil.CleanserServers = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.cleanser);
			CUtil.log.Debug("All cleanser servers:");
			for(int i=0;i<CUtil.CleanserServers.Length;i++)
				CUtil.log.Debug(CUtil.CleanserServers[i]);
			CUtil.log.Debug("Cleanser server name: " + CUtil.CleanserServerName);

			// For liveservice tests, we need to query the SQL servers that are mapped to the frontdoors
			CUtil.CleanserSQL = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.filterdb);
			CUtil.log.Debug("FilterDB SQL servers:");
			for(int i=0;i<CUtil.CleanserSQL.Length;i++)
				CUtil.log.Debug(CUtil.CleanserSQL[i]);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reporting_common_none_12.4.56.0_none_c1f32d1bb5e86473
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reporting_common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.manifest
XP_MANIFEST_PATH=manifests\msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.cat
XP_CATALOG_PATH=manifests\msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.cat
XP_PAYLOAD_PATH=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reporting_common,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\FilterDBTables.cs ===
using System;

namespace ReportingInfrastructureTest
{
    public class DateRange
    {
        public string dateMin;
        public string dateMax;

        /// <summary>
        /// Constructor for DateRange. Set dateMin and dateMax values.
        /// </summary>        
        /// <param name="minus">Delta to subtract from current time in seconds</param>
        /// <param name="plus">Delta to add to current time in seconds</param>
        public DateRange(int minus, int plus)
        {
            DateTime dtNow = DateTime.Now;
            dateMin = dtNow.AddSeconds(minus*(-1)).ToString("MM/dd/yyyy HH:mm:ss.fff");
            dateMax = dtNow.AddSeconds(plus).ToString("MM/dd/yyyy HH:mm:ss.fff");
        }
    }

    public abstract class FilterDBTable
    {
    }
    
    /// <summary>
	/// Summary description for FilterDBTables.
	/// </summary>

    public class t_usagestore_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_user_puid;
        public string ui_media_instance_id;
        public string i_attribute_id;
        public string i_attribute_value;
        public string dt_date_entry;
        public string i_source_id;
    }

	public class t_provision_fact : FilterDBTable
	{
        public DateRange dt_when;
        public string f_active;
        public string bi_user_puid;
        public string i_from_tier_id;
        public string bi_from_offer_id;
        public string i_to_tier_id;
        public string bi_to_offer_id;
	}
    
    public class t_content_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_machine_puid;
        public string bi_user_puid;
        public string bi_owner_machine_puid;
        public string i_title_id;
        public string bi_offer_id;        
        public string b_content_id;
    }

    public class t_guest_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_user_puid;
        public string i_title_id;
        public string ti_max_guests_count;
    }

    public class t_migrate_account_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string ti_console_type;
        public string bi_user_puid;
        public string bi_user_passport_puid;
    }

    public class t_msg_snd_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_sender_puid;
        public string i_sender_title_id;
        public string si_msg_type;
        public string vc_recipients_list;
    }

    public class t_new_account_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string ti_console_type;
        public string bi_machine_puid;
        public string bi_user_puid;
        public string bi_user_passport_puid;
        public string bi_owner_passport_puid;
        public string ti_country_id;
        public string i_language_id;
        public string i_culture_id;
        public string bi_offer_id;
        public string i_hresult;
    }

    public class t_presence_fact : FilterDBTable
    {
        public DateRange dt_start;
        public string i_duration_ms;
        public string bi_machine_puid;
        public string bi_user_puid;
        public string i_title_id;
        public string bi_xbox_IP;
        public string bi_session_id;
        public string f_playing_now;       
    }

    public class t_purchase_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_machine_puid;
        public string bi_user_puid;
        public string i_tier_id;
        public string ti_country_id;
        public string i_language_id;
        public string i_payment_type_id;
        public string bi_offer_id;
        public string i_price_whole;
        public string i_price_fractional;
    }

    public class t_session_fact : FilterDBTable
    {
        public DateRange dt_start;
        public string bi_machine_puid;
        public string i_duration_ms;
        public string bi_user_puid;
        public string i_title_id;
        public string bi_session_id;
    }

    public class t_video_license_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string ui_wmid;
        public string bi_owner_machine_puid;
        public string bi_current_machine_puid;
        public string bi_current_user_puid;
        public string b_is_preview;
    }

    public class t_fusion_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_user_puid;
        public string i_title_id;
        public string i_hresult;
    }

    public class t_banner_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_hash_path;
        public string bi_user_puid;
        public string i_sequence_number;
        public string ti_banner_type_id;
    }

    public class t_banner_purchase_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_hash_path;
        public string bi_offer_id;
        public string bi_user_puid;
    }

    public class t_fusion_fact_agg : FilterDBTable
    {
        public DateRange dt_when;
	    public string i_title_id;
        public string i_hresult;
        public string bi_fusion_counter; 
    }

    public class t_banner_fact_agg : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_hash_path;
        public string bi_banner_counter;
        public string ti_banner_type_id;
    }

    public class t_banner_purchase_fact_agg : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_hash_path;
        public string bi_offer_id;
        public string bi_banner_counter;
    }

    public class t_geofence_rejection_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string vc_featurearea;
        public string vc_reasoncode;
        public string bi_current_machine_puid;
        public string bi_current_user_puid;
        public string vc_ip_address;
        public string vc_countrycode;
        public string ui_wmid;
        public string bi_offer_id;
        public string i_videotype;
    }

    public class t_argon_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_machine_puid;
        public string vc_argon_data;
        public string i_sequence_num;
    }

    public class t_purchaseoffer_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_user_puid;
        public string bi_machine_puid;
        public string vc_ip_address;
        public string	i_pmt_type	;
        public string	ui_offerinstance_id	;
        public string	i_mediatype_id	;
        public string	i_retail_price_points	;
        public string	i_retail_price	;
        public string	vc_retail_currency	;
        public string	i_wholesale_price	;
        public string	vc_wholesale_currency	;
        public string	ui_promotion_id	;
        public string	i_pricing_rule_id	;
        public string	i_store_source_id	;
    }
    
    public class t_acquirelicense_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string ui_media_instance_id;
        public string ui_offer_instance_id;
        public string bi_purchase_machine_puid;
        public string bi_license_request_puid	;
        public string bi_user_puid	;
    }
    
    public class t_elite_migration_fact : FilterDBTable
    {
        public DateRange dt_when;
        public string bi_sgnonce;
        public string bi_user_puid;
        public string bi_old_machine_puid;
        public string bi_new_machine_puid	;
        public string i_user_licenses	;
        public string i_machine_licenses	;
        public string i_hr	;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reporting_common_none_12.4.56.0_none_c1f32d1bb5e86473
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reporting_common
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.manifest
XP_MANIFEST_PATH=manifests\msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.cat
XP_CATALOG_PATH=manifests\msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f.cat
XP_PAYLOAD_PATH=msil_reporting_common_no-public-key_12.4.56.0_x-ww_f648a29f
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reporting_common,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\SQLDataProvider.cs ===
using System;
using System.Data;
using System.Data.SqlClient;
using System.Collections;

namespace ReportingInfrastructureTest
{
	public class SQLDataProvider
	{
		private SqlConnection m_Conn;
		private SqlCommand m_Cmd;
		private SqlDataReader m_reader;

		public SQLDataProvider() 
		{
			m_Conn = null;
			m_Cmd = null;
		}

		public bool InitializeConnection(
			string server,
			string DB
			)
		{
			bool retval=false;
			try 
			{
				if ((server == "") || (DB == "")) return false;
				m_Conn = new SqlConnection(
					"Data Source=" + server + ";Initial Catalog=" +
					DB + ";Trusted_Connection=Yes"
					);
				m_Conn.Open();
				retval=true;
			}
			catch (Exception e)
			{
				throw(e);
			}
			return retval;
		}

		public Object ExecuteQueryScalar(string cmd)
		{
			if (cmd == "") 
				throw new Exception("SQL command string is empty.");

			m_Cmd = new SqlCommand();
			m_Cmd.Connection = m_Conn;
			m_Cmd.CommandType = CommandType.Text;
			m_Cmd.CommandText = cmd;
			Object obj = m_Cmd.ExecuteScalar ();
			return obj;	
		}

		public SqlDataReader ExecuteQueryReturn(string cmd)
		{
			if (cmd == "") 
				throw new Exception("SQL command string is empty.");

			m_Cmd = new SqlCommand();
			m_Cmd.Connection = m_Conn;
			m_Cmd.CommandType = CommandType.Text;
			m_Cmd.CommandText = cmd;
			m_reader = m_Cmd.ExecuteReader();
			return m_reader;	
		}

		public void ExecuteQuery(string cmd)
		{
			if (cmd == "") 
				throw new Exception("SQL command string is empty.");

			m_Cmd = new SqlCommand();
			m_Cmd.Connection = m_Conn;
			m_Cmd.CommandType = CommandType.Text;
			m_Cmd.CommandText = cmd;			
			m_Cmd.ExecuteNonQuery();
		}

        public void ExecuteSproc(string cmd)
        {
            if (cmd == "") 
                throw new Exception("SQL command string is empty.");

            m_Cmd = new SqlCommand();
            m_Cmd.Connection = m_Conn;
            m_Cmd.CommandType = CommandType.StoredProcedure;
            m_Cmd.CommandText = cmd;			
            m_Cmd.ExecuteNonQuery();
        }

        public void ExecuteSproc(string cmd, int iTimeout)
        {
            if (cmd == "") 
                throw new Exception("SQL command string is empty.");

            m_Cmd = new SqlCommand();
	     m_Cmd.CommandTimeout = iTimeout;
            m_Cmd.Connection = m_Conn;
            m_Cmd.CommandType = CommandType.StoredProcedure;
            m_Cmd.CommandText = cmd;			
            m_Cmd.ExecuteNonQuery();
        }

		/*public bool Write(string tableName, Hashtable cols)
		{
			try
			{
				if ((tableName == "") || (cols.Count == 0))
					return false;
				// Generate random values for each column in cols
				// depending on its data type
				if (tableName == "UODB_Users");
				if (tableName == "UODB_Subscriptions");
				if (tableName == "WEBDB_TitleInfo");
				if (tableName == "WEBDB_TitleNameInfo");

				foreach (DictionaryEntry e in cols)
				{
					if (e.Key == "ti_country_id");
					if (e.Key == "i_offer_type_id");
					if (e.Key == "i_credential_type");
					if (e.Key == "vc_api_name");
					if (e.Key == "i_title_id");
					if (e.Key == "bi_team_puid");
					if (e.Key == "bi_user_puid");
				}
			}
			catch (Exception e)
			{
			}
		}
		
		public bool WriteTableValues(string tableName, string[] valueList)
		{
			bool retval=false;
			try
			{
				if ((tableName == "") || (valueList.Length == 0))
					return false;
				m_Cmd = new SqlCommand();
				m_Cmd.Connection = m_Conn;
				m_Cmd.CommandType = CommandType.Text;
				System.Text.StringBuilder values = new System.Text.StringBuilder();
				int i=0;
				for(i=0;i<valueList.Length;i++)
				{
					values.Append(valueList[i]);
					values.Append(",");
				}
				// Remove last colon
				if (i > 0) 
					values.Remove(values.Length-1,1);
				string cmdText = 
					"INSERT " + tableName + " VALUES(" +
					values + ")";					
				m_Cmd.CommandText = cmdText;
				int numRows = m_Cmd.ExecuteNonQuery();
				if (numRows > 0) 
					retval=true;
				else
					throw new Exception("No rows have been inserted!");
			}
			catch (Exception e)
			{
				throw(e);
			}
			return retval;
		}
		*/
		public void Close()
		{
			if (m_Cmd != null)
				m_Cmd = null;
			if (m_reader != null) m_reader.Close();
			if (m_Conn != null)
			{
				m_Conn.Close();m_Conn=null;
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\common\CUtil.cs ===
using System;
using System.Threading;
using System.Data.SqlClient;
using System.Net;
using System.Collections;
//
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
//
using xonline.common.config;
using xonline.common.mgmt;

namespace ReportingInfrastructureTest
{
	/// <summary>
	/// Summary description for CUtil.
	/// </summary>
    public class CUtil
    {
        public static Report log = new Report("RptTarget_Cleanser_Funcs");			
        public static string CleanserServerName;
        public static string[] CleanserServers;
        public static string[] CleanserSQL;		        
        public static string Environment;
        public static Random rnd = new Random();

        public static bool VerifyFilterDB(string strComponent, string strMessage)
        {
            bool result=false;
            switch(strComponent.ToLower())
            {
                case "test":
                    result = VerifyFilterDB_TEST(strMessage);
                    break;
                default:
                    throw new Exception("Invalid component name.");
            }
            return result;
        }

        public static bool VerifyFilterDB(string strComponent, FilterDBTable tbl)
        {
            bool result=false;
            switch(strComponent.ToLower())
            {
                case "xbos":
                    result = VerifyFilterDB_XBOS((t_content_fact)tbl);
                    break;
                case "xuacs":
                        result = VerifyFilterDB_XUACS((t_new_account_fact)tbl);
                    break;
                case "snd":
                    result = VerifyFilterDB_SND((t_msg_snd_fact)tbl);
                    break;
                case "sesstart":
                case "sesend":
                    result = VerifyFilterDB_SESSION((t_session_fact)tbl);
                    break;
                case "titlestart":
                case "titlend":
                    result = VerifyFilterDB_TITLE((t_presence_fact)tbl);
                    break;
                case "xeop":
                    result = VerifyFilterDB_XBOS_XEOP((t_purchase_fact)tbl);
                    break;
                case "guestchg":
                    result = VerifyFilterDB_XPSERVER_GUESTCHG((t_guest_fact)tbl);
                    break;
                case "xcbk":
                    result = VerifyFilterDB_XCBK((t_provision_fact)tbl);
                    break;
                case "argo":
                    result = VerifyFilterDB_License((t_video_license_fact)tbl);
                    break;
                case "banner":
                    result = VerifyFilterDB_Banner((t_banner_fact)tbl);
                    break;
                case "banneragg":
                    result = VerifyFilterDB_BannerAgg((t_banner_fact_agg)tbl);
                    break;
                case "fusion":
                    result = VerifyFilterDB_Fusion((t_fusion_fact)tbl);
                    break;
                case "fusionagg":
                    result = VerifyFilterDB_FusionAgg((t_fusion_fact_agg)tbl);
                    break;
                case "bannerpurchase":
                    result = VerifyFilterDB_BannerPurchase((t_banner_purchase_fact)tbl);
                    break;
                case "bannerpurchaseagg":
                    result = VerifyFilterDB_BannerPurchaseAgg((t_banner_purchase_fact_agg)tbl);
                    break;
                case "geodenial":
                    result = VerifyFilterDB_GeoDenial((t_geofence_rejection_fact)tbl);
                    break;
                case "argon":
                    result = VerifyFilterDB_Argon((t_argon_fact)tbl);
                    break;
                case "purchaseoffer":
                    result = VerifyFilterDB_PurchaseOffer((t_purchaseoffer_fact)tbl);
                    break;
                case "acquirelicense":
                    result = VerifyFilterDB_AcquireLicense((t_acquirelicense_fact)tbl);
                    break;
                case "elitemigration":
                    result = VerifyFilterDB_EliteMigration((t_elite_migration_fact)tbl);
                    break;
                case "usagestore":
                    result = VerifyFilterDB_UsageStore((t_usagestore_fact)tbl);
                    break;
                default:
                    throw new Exception("Invalid component name.");
            }
            return result;
        }

        private static bool VerifyFilterDB_UsageStore(t_usagestore_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");
            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_usagestore_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_user_puid = " + tbl.bi_user_puid +
                    " AND ui_media_instance_id = '" + tbl.ui_media_instance_id + "'" +
                    " AND i_attribute_id = " + tbl.i_attribute_id +
                    " AND i_attribute_value = " + tbl.i_attribute_value +
                    " AND i_source_id = " + tbl.i_source_id;

               if(tbl.dt_date_entry != "")
                    strCmd += " AND dt_date_entry = '" + tbl.dt_date_entry + "'";

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;
        }

        private static bool VerifyFilterDB_EliteMigration(t_elite_migration_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_elite_migration_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_user_puid = " + tbl.bi_user_puid;

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;

        }
        
        private static bool VerifyFilterDB_AcquireLicense(t_acquirelicense_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_acquirelicense_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_user_puid = " + tbl.bi_user_puid;

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;

        }
        
        private static bool VerifyFilterDB_PurchaseOffer(t_purchaseoffer_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_purchaseoffer_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_user_puid = " + tbl.bi_user_puid;

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;

        }  

        private static bool VerifyFilterDB_Argon(t_argon_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_argon_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_machine_puid = " + tbl.bi_machine_puid +
                    " AND vc_argon_data = '" + tbl.vc_argon_data + "'" +
                    " AND i_sequence_num = " + tbl.i_sequence_num;

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;

        }  

        private static bool VerifyFilterDB_GeoDenial(t_geofence_rejection_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_geofence_rejection_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND vc_featurearea = '" + tbl.vc_featurearea + "'" +
                    " AND vc_reasoncode = '" + tbl.vc_reasoncode + "'" +
                    " AND bi_current_machine_puid = " + tbl.bi_current_machine_puid +
                    " AND bi_current_user_puid = " + tbl.bi_current_user_puid +
                    " AND vc_ip_address = '" + tbl.vc_ip_address + "'" +
                    " AND vc_countrycode = '" + tbl.vc_countrycode + "'" +
                    " AND bi_offer_id = " + tbl.bi_offer_id +
                    " AND i_videotype = " + tbl.i_videotype;
                if (tbl.ui_wmid.Length > 0)
                    strCmd += " AND ui_wmid = '" + tbl.ui_wmid + "'";
                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;

        }        

        private static bool VerifyFilterDB_XBOS_XEOP(t_purchase_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");
			
            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");

                string strCmd =
                    "select * from t_purchase_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_machine_puid = " + tbl.bi_machine_puid +
                    " AND bi_user_puid = " + tbl.bi_user_puid +
                    " AND i_tier_id = " + tbl.i_tier_id +
                    " AND ti_country_id = " + tbl.ti_country_id +
                    " AND i_language_id = " + tbl.i_language_id +
                    " AND i_payment_type_id = " + tbl.i_payment_type_id +
                    " AND bi_offer_id = " + tbl.bi_offer_id +
                    " AND i_price_whole = " + tbl.i_price_whole +
                    " AND i_price_fractional = " + tbl.i_price_fractional;
                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;	

        }

        private static bool VerifyFilterDB_XCBK(t_provision_fact tbl)
        {
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");

            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");


                string strCmd =
                    "select * from t_provision_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    //" dt_when >= '"+tbl.dt_when.dateMin + "'" + 
                    " AND bi_from_offer_id = " + tbl.bi_from_offer_id +
                    " AND bi_to_offer_id = " + tbl.bi_to_offer_id +
                    " AND bi_user_puid = " + tbl.bi_user_puid +
                    " AND f_active = " + tbl.f_active +
                    " AND i_from_tier_id = " + tbl.i_from_tier_id +
                    " AND i_to_tier_id = " + tbl.i_to_tier_id;

                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;	

        }

        private static bool VerifyFilterDB_XBOS(t_content_fact tbl)
        {			
            // Input validation
            //
            if (tbl == null)
                throw new Exception("No data to verify.");
			
            // Establish SQL connection
            //
            SQLDataProvider sql = new SQLDataProvider();
            bool result = false;

            foreach (string cleanserSql in CleanserSQL)
            {
                sql = new SQLDataProvider();
                sql.InitializeConnection(cleanserSql, "FILTERDB");
			
                string strCmd = 
                    "select * from t_content_fact where" +
                    " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                    " AND bi_machine_puid = " + tbl.bi_machine_puid +
                    " AND bi_user_puid = " + tbl.bi_user_puid +
                    " AND bi_owner_machine_puid = " + tbl.bi_owner_machine_puid +
                    " AND i_title_id = " + tbl.i_title_id +
                    " AND bi_offer_id = " + tbl.bi_offer_id +
                    " AND b_content_id = " + tbl.b_content_id;
                CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}",strCmd);            
                SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                result = reader.HasRows;
                sql.Close();
                if (result)
                    break;
            }
            return result;	
        }


        private static bool VerifyFilterDB_XPSERVER_GUESTCHG(t_guest_fact tbl)
        {
            bool result = false;
            
            // Loop through all cleanser servers
            for(int i=0;i<CleanserSQL.Length;i++)
            {
                result = VerifyFilterDB_XPSERVER_GUESTCHG(CleanserSQL[i],tbl);
                if (result) break; // if we found the log, then exit loop
            }                

            return result;
        }
        
        private static bool VerifyFilterDB_XPSERVER_GUESTCHG(string sqlsrv, t_guest_fact tbl)
        {			
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd = 
                        "select * from t_guest_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +										
                        " AND bi_user_puid = " + tbl.bi_user_puid +
                        " AND i_title_id = " + tbl.i_title_id +
                        " AND ti_max_guests_count = " + tbl.ti_max_guests_count;

                    CUtil.log.Debug("(" + sqlsrv + ") Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        private static bool VerifyFilterDB_XUACS(t_new_account_fact tbl)
        {
            /* Format:
             * CREATEACCOUNT|UserPUID|hr|GamerTag|EMail|CountryId|PostalCode|LanguageId|MachinePUID|TitleID|VoucherHash
             * CREATELIVEACCOUNT|MachinePuid|UserPassportPuid|OwnerPassportPuid|UserPuid|hr|Gamertag|Email|PostalCode|CountryId|LanguageId|CultureId|TitleId|OfferId|VoucherHash
             * CREATEXBOXCOMACCOUNT|UserPassportPuid|OwnerPassportPuid|UserPuid|hr|Gamertag|Email|PostalCode|CountryId|LanguageId|CultureId
            */
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd;

                    if (tbl.ti_console_type.CompareTo("1")!=0)
                        strCmd = 
                            "select * from t_new_account_fact where" +
                            " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +					
                            " AND bi_machine_puid = " + tbl.bi_machine_puid +
                            " AND bi_user_passport_puid = " + tbl.bi_user_passport_puid +
                            " AND bi_owner_passport_puid = " + tbl.bi_owner_passport_puid +
                            " AND bi_user_puid = " + tbl.bi_user_puid +					
                            " AND i_hresult = " + tbl.i_hresult +
                            " AND ti_country_id = " + tbl.ti_country_id +
                            " AND i_language_id = " + tbl.i_language_id +
                            " AND i_culture_id = " + tbl.i_culture_id +
                            " AND bi_offer_id = " + tbl.bi_offer_id +					
                            " AND ti_console_type = " + tbl.ti_console_type;
                    else // Don't use the machine puid as .com randomly generates one
                        strCmd =
                            "select * from t_new_account_fact where" +
                            " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                            " AND bi_user_passport_puid = " + tbl.bi_user_passport_puid +
                            " AND bi_owner_passport_puid = " + tbl.bi_owner_passport_puid +
                            " AND bi_user_puid = " + tbl.bi_user_puid +
                            " AND i_hresult = " + tbl.i_hresult +
                            " AND ti_country_id = " + tbl.ti_country_id +
                            " AND i_language_id = " + tbl.i_language_id +
                            " AND i_culture_id = " + tbl.i_culture_id +
                            " AND bi_offer_id = " + tbl.bi_offer_id +
                            " AND ti_console_type = " + tbl.ti_console_type;
                
                    CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        public static bool VerifyFilterDB_XUACS_MIGRATEXBOX1USER(ulong puid)
        {
            /* Format:
             * MIGRATEXBOX1USER             
            */
            bool result = false;
            try
            {

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd = 
                        "select * from t_migrate_account_fact where" +
                        " bi_user_puid = " + puid.ToString();

                    CUtil.log.Debug("(" + cleanserSql + ")Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        private static bool VerifyFilterDB_SESSION(t_session_fact tbl)
        {
            bool result = false;
            
            // Loop through all cleanser servers            
            for(int i=0;i<CleanserSQL.Length;i++)
            {
                result = VerifyFilterDB_SESSION(CleanserSQL[i],tbl);
                if (result) break; // if we found the log, then exit loop
            }                

            return result;
        }

        private static bool VerifyFilterDB_SESSION(string sqlsrv, t_session_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    // Create a range for the duration [-25%,+25%]
                    int durationMin = Convert.ToInt32(tbl.i_duration_ms);
                    durationMin = (int)(durationMin*(0.75)); // subtract 25% from the acceptable duration value
                    int durationMax = Convert.ToInt32(tbl.i_duration_ms);
                    //durationMax = (int)(durationMax*(1.25)) + 3000; // add 25% + 3 sec to the acceptable duration value
                    durationMax = (int)(durationMax * (1.25)) + 5000; // add 25% + 3 sec to the acceptable duration value

                    string strCmd =
                        "select * from t_session_fact where" +
                        " dt_start >= '" + tbl.dt_start.dateMin + "' AND dt_start <= '" + tbl.dt_start.dateMax + "'" +
                        " AND bi_user_puid = " + tbl.bi_user_puid +
                        " AND i_title_id = " + tbl.i_title_id +
                        " AND bi_session_id = " + tbl.bi_session_id +
                        " AND bi_machine_puid = " + tbl.bi_machine_puid;
                        //" AND i_duration_ms >= " + durationMin.ToString() +
                        //" AND i_duration_ms <= " + durationMax.ToString();

                    CUtil.log.Debug("(" + sqlsrv + ") Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	

        }

        private static bool VerifyFilterDB_TITLE(t_presence_fact tbl)
        {
            bool result = false;
            // Loop through all cleanser servers
            for(int i=0;i<CleanserSQL.Length;i++)
            {
                result = VerifyFilterDB_TITLE(CleanserSQL[i],tbl);
                if (result) break; // if we found the log, then exit loop
            }                

            return result;
        }

        private static bool VerifyFilterDB_TITLE(string sqlsrv, t_presence_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    // Create a range for the duration [-25%,+25%]
                    int durationMin = Convert.ToInt32(tbl.i_duration_ms);
                    durationMin = (int)(durationMin*(0.75)); // subtract 25% from the acceptable duration value
                    int durationMax = Convert.ToInt32(tbl.i_duration_ms);
                    //durationMax = (int)(durationMax*(1.25)) + 3000; // add 25% + 3 sec to the acceptable duration value
                    durationMax = (int)(durationMax * (1.25)) + 5000; // add 25% + 3 sec to the acceptable duration value

                    string strCmd =
                        "select * from t_presence_fact where" +
                        " dt_start >= '" + tbl.dt_start.dateMin + "' AND dt_start <= '" + tbl.dt_start.dateMax + "'" +
                        " AND bi_machine_puid = " + tbl.bi_machine_puid +
                        " AND bi_user_puid = " + tbl.bi_user_puid +
                        " AND i_title_id = " + tbl.i_title_id +
                        " AND bi_xbox_IP = " + tbl.bi_xbox_IP +
                        //" AND bi_session_id = 0" + tbl.bi_session_id + // Test does not get back the session id for a title
                        " AND f_playing_now = " + tbl.f_playing_now; //+                    
                        //" AND i_duration_ms >= " + durationMin.ToString() +
                        //" AND i_duration_ms <= " + durationMax.ToString();

                    CUtil.log.Debug("(" + sqlsrv + ") Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	

        }

        private static bool VerifyFilterDB_Banner(t_banner_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_banner_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND bi_hash_path = " + tbl.bi_hash_path +
                        " AND bi_user_puid = " + tbl.bi_user_puid +
                        " AND ti_banner_type_id = " + tbl.ti_banner_type_id;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;
        }

        public static bool VerifyFilterDB_BannerAgg(t_banner_fact_agg tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_banner_agg_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND bi_hash_path = " + tbl.bi_hash_path +
                        " AND bi_banner_counter = " + tbl.bi_banner_counter +
                        " AND ti_banner_type_id = " + tbl.ti_banner_type_id;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;
        }

        private static bool VerifyFilterDB_BannerPurchase(t_banner_purchase_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_banner_purchase_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND bi_hash_path = " + tbl.bi_hash_path +
                        " AND bi_offer_id = " + tbl.bi_offer_id +
                        " AND bi_user_puid = " + tbl.bi_user_puid;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        public static bool VerifyFilterDB_BannerPurchaseAgg(t_banner_purchase_fact_agg tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_banner_purchase_agg_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND bi_hash_path = " + tbl.bi_hash_path +
                        " AND bi_banner_counter = " + tbl.bi_banner_counter +
                        " AND bi_offer_id = " + tbl.bi_offer_id;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        private static bool VerifyFilterDB_Fusion(t_fusion_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_fusion_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND bi_user_puid = " + tbl.bi_user_puid +
                        " AND i_title_id = " + tbl.i_title_id +
                        " AND i_hresult = " + tbl.i_hresult;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        public static bool VerifyFilterDB_FusionAgg(t_fusion_fact_agg tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_fusion_fact_agg where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND i_title_id = " + tbl.i_title_id +
                        " AND i_hresult = " + tbl.i_hresult +
                        " AND bi_fusion_counter = " + tbl.bi_fusion_counter;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;
        }

        private static bool VerifyFilterDB_License(t_video_license_fact tbl)
        {
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd =
                        "select * from t_video_license_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +
                        " AND ui_wmid = '" + tbl.ui_wmid + "'" +
                        " AND bi_owner_machine_puid = " + tbl.bi_owner_machine_puid +
                        " AND bi_current_machine_puid = " + tbl.bi_current_machine_puid +
                        " AND bi_current_user_puid = " + tbl.bi_current_user_puid +
                        " AND b_is_preview = " + tbl.b_is_preview;

                    CUtil.log.Debug("(" + cleanserSql + ") Sending query: {0}", strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch (Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }

        /// <summary>
        /// Return valid user ID that follows the contraint from t_users.
        /// Valid UserID Range is [0x0009000000000000, 0x000A000000000000}
        /// </summary>
        /// <returns>Puid as a string in hex format</returns>
        public static string GetUserID()
        {
            return (0x0009000000000000 + (ulong)(rnd.NextDouble()*(0x000A000000000000 - 0x0009000000000000))).ToString("X");
        }

        private static bool VerifyFilterDB_TEST(string strMessage)
        {
            /* Schema of t_test_fact table:
                create table t_test_fact(
                    dt_when datetime,
                    i_ID int,
                    vc_value char(50))
            */
            bool result = false;
            try
            {
                string[] fields = strMessage.Split(new char[]{'|'});			
                if (fields.Length != 3) 
                    throw new Exception("TEST message contains incorrect number of fields: " + strMessage);			
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");
                    DateTime dtWhen = DateTime.UtcNow;				
                    string strCmd = 
                        "select * from t_test_fact where" +
                        " dt_when >= '" + dtWhen.AddSeconds(-12) + "' AND dt_when <= '" + dtWhen + "'" +
                        " AND i_ID = " + fields[1] +
                        " AND vc_value = '" + fields[2] + "'";
                    CUtil.log.Debug("Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }


        public static void CleanUpDB(string strComponent, string strMessage)
        {
            SQLDataProvider sql = new SQLDataProvider();

            foreach (string cleanserSql in CleanserSQL)
            {
                switch(strComponent.ToLower())
                {
                    case "xbos":
                        // delete existing rows from t_content_fact
                        string[] fields = strMessage.Split(new char[]{'|'});			
                        if (fields.Length != 7) 
                            throw new Exception("CONTENTREF message contains incorrect number of fields: " + strMessage);

                        sql = new SQLDataProvider();
                        sql.InitializeConnection(cleanserSql, "FILTERDB");
                        string strCmd = 
                            "delete t_content_fact where" +
                            " bi_machine_puid = 0x" + fields[3] +
                            " AND bi_user_puid = 0x" + fields[2] +
                            " AND bi_owner_machine_puid = 0x" + fields[3] +
                            " AND i_title_id = 0x" + fields[4] +
                            " AND bi_offer_id = 0x" + fields[5];
                        CUtil.log.Debug("Sending SQLStmt: {0}",strCmd);
                        sql.ExecuteQuery(strCmd);
                        sql.Close();
                        break;
                    case "test":
                        // delete existing rows that match the message passed
                        fields = strMessage.Split(new char[]{'|'});
                        if (fields.Length != 2)
                            throw new Exception("test message contains incorrect number of fields: " + strMessage);			
                        sql = new SQLDataProvider();
                        sql.InitializeConnection(CleanserServerName, "FILTERDB");
                        strCmd = 
                            "delete t_test_fact where" +
                            " i_ID = " + fields[0] +
                            " vc_value = '" + fields[1] + "'";
                        CUtil.log.Debug("Sending SQLStmt: {0}",strCmd);
                        sql.ExecuteQuery(strCmd);
                        sql.Close();
                        break;
                }
            }
        }

        private static bool VerifyFilterDB_SND(t_msg_snd_fact tbl)
        {
            bool result = false;                        
            
            // Loop through all cleanser servers
            for(int i=0;i<CleanserSQL.Length;i++)
            {
                result = VerifyFilterDB_SND(CleanserSQL[i],tbl);
                if (result) break; // if we found the log, then exit loop
            }                

            return result;
        }
        
        private static bool VerifyFilterDB_SND(string sqlsrv, t_msg_snd_fact tbl)
        {
    		/*
                Format of message:
                SND|0:0|9000000001900|0|20B00002|0|A8C0|4|2|9000000001901|0
                SND|address:port|sender|sender context|sender titleID|message flags|ExpireMinutes|cbDetails
                |MessageType|Buffer|HR
             */
            bool result = false;
            try
            {
                // Input validation
                //
                if (tbl == null)
                    throw new Exception("No data to verify.");

                // Establish SQL connection
                //
                SQLDataProvider sql = new SQLDataProvider();

                foreach (string cleanserSql in CleanserSQL)
                {
                    sql = new SQLDataProvider();
                    sql.InitializeConnection(cleanserSql, "FILTERDB");

                    string strCmd = 
                        "select * from t_msg_snd_fact where" +
                        " dt_when >= '" + tbl.dt_when.dateMin + "' AND dt_when <= '" + tbl.dt_when.dateMax + "'" +										
                        " AND bi_sender_puid = " + tbl.bi_sender_puid +
                        " AND i_sender_title_id = " + tbl.i_sender_title_id +
                        " AND si_msg_type = " + tbl.si_msg_type +					
                        " AND vc_recipients_list = '" + tbl.vc_recipients_list + "'";
                    CUtil.log.Debug("(" + sqlsrv + ") Sending query: {0}",strCmd);
                    SqlDataReader reader = sql.ExecuteQueryReturn(strCmd);
                    result = reader.HasRows;
                    sql.Close();
                    if (result)
                        break;
                }
            }
            catch(Exception e)
            {
                log.Error(e.ToString());
                result = false;
            }
            return result;	
        }
		
        /// <summary>
        /// This method should be called before an xmgmt test is run a second time from STFRunner
        /// after the XomLoggingControl was closed.
        /// This will remove the reporting target, so it can be re-added and hence generate
        /// a new Connect message, which should be received by cleanser first before any data
        /// message.
        /// </summary>
        public static void ReloadTarget()
        {
            // Force to send connect msg if test is run a 2nd time
            XomLogArea area = (XomLogArea)XomLoggingControl.Areas["reporting"];
            //IEnumerator enumTargets = area.Targets.GetEnumerator();
            /* Debugging
             while (enumTargets.MoveNext() != false)
            {
                XomLogTarget t = (XomLogTarget)enumTargets.Current;
                ConsoleX.WriteLine(t.Name);
            }*/
            XomLogTarget target = (XomLogTarget)XomLoggingControl.Targets["report"];
            // By removing the target, we force the XomLoggingControl to readd the target and
            // and send a connect msg
            area.RemoveTarget(target);
            XomLoggingControl.Areas["reporting"] = area;
            log.Debug("Reporting target has been reloaded.");
            /* Debugging
            ConsoleX.WriteLine("After removing report target:");
            enumTargets = null;
            enumTargets = area.Targets.GetEnumerator();
            while (enumTargets.MoveNext() != false)
            {
                XomLogTarget t = (XomLogTarget)enumTargets.Current;
                ConsoleX.WriteLine(t.Name);
            }*/
        }

        /// <summary>
        /// In Testnet, each component is mapped to a specific cleanser server. Imitate this same mapping 
        /// when using the XomLoggingControl directly from xonline.
        /// </summary>
        public static void MapTargetByComponent(string componentName)
        {
            // this is for Testnet only
            if (Global.XEnv.GetEnv().ToLower() != "testnet")
                return;
            
            string cleanserServer = "xeclnsinh001";

            SQLDataProvider sql = new SQLDataProvider();
            
            IInterfaceInfo iface = Config.GetSingleInterface(Interface.npdb);
            sql.InitializeConnection(iface.IPAddressString, "npdb");    
        
            string cmd = "update t_interface_buckets set vc_server='" 
                + cleanserServer + "', vc_next_server='" + cleanserServer + "'"
                + " where vc_environment='testnet' and i_bucket=0"
                + " and vc_interface='" + Interface.cleanser.ToString() + "'";
            CUtil.log.Debug("Sending stmt: " + cmd);
            sql.ExecuteQuery(cmd);
            sql.Close();
        }

        public static void Wait(long timeTicks)
        {
            DateTime dt1 = DateTime.Now;
            DateTime dt2 = DateTime.Now;
            // Convert time from ms to ticks
            // 1 tick = 10^-7 second
            // 1 ms = 10^-3 second = 10,000 ticks
            //long timeTicks = timeMs * 10000;
			
            while ((dt2.Ticks - dt1.Ticks) < timeTicks)
            {
                dt2 = DateTime.Now;				
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_replicationfvt_none_12.4.56.0_none_85b328d620e82693
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=replicationfvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.manifest
XP_MANIFEST_PATH=manifests\msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.cat
XP_CATALOG_PATH=manifests\msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.cat
XP_PAYLOAD_PATH=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=replicationfvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\BVT\ReportingTargetTestBVT.cs ===
using System;
using System.ServiceProcess;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Net;
using System.Data.SqlClient;
using System.IO;
using System.Xml;
using System.Data;


using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.StringServer;
using ServerTestFramework.LiveService.Callback;
using ServerTestFramework.LiveService.Auth;
using ServerTestFramework.LiveService.Stats;

using xonline.common.config;
using xonline.common.mgmt;



using Microsoft.XBox.Live.Server.Emulators.Client;
using Microsoft.XBox.Live.Server.Emulators.Framework;

//using live.common;
using live.protocol;
using live.server;
using live.client;
using OfferExpectedPrice = ServerTestFramework.LiveService.Billing.OfferExpectedPrice;

namespace ReportingInfrastructureTest
{
    public class DBInformation
    {
        public class DBInfoPair
        {
            public string classString;
            public int      iCount;
            public System.Collections.Generic.List<DataInfoPair> filterDBTableList;
        }

        public class DataInfoPair
        {
            public int      iSeq;
            public FilterDBTable filterDBTable;
        }

/*
        public struct DBInfoPair
        {
            public FilterDBTable filterDBTable;
            public string classString;
        }
*/
        private static bool initialized = false;
        private static DBInformation current = null;
        private System.Collections.Generic.List<DBInfoPair> dbInfoPairList;
        private System.Collections.Generic.List<IReportingTest> tests;

        public static DBInformation Instance
        {
            get
            {
                DBInformation.Initialize();
                return current;
            }
        }

        DBInformation()
        {
            dbInfoPairList = new List<DBInfoPair>();
            tests = new List<IReportingTest>();
        }

        public TestBase AddTest(IReportingTest test)
        {
            bool remove = false;
            IReportingTest testToRemove = null;
            foreach (IReportingTest storedTest in tests)
            {
                if (storedTest.GetType() == test.GetType())
                {
                    // Flush stored data as it is stale now
                    ClearInfo();
                    // Removed the old instance
                    remove = true;
                    testToRemove = storedTest;
                    break;
                }
            }
            if (remove)
                tests.Remove(testToRemove);
            tests.Add(test);
            return (TestBase) test;
        }

        public System.Collections.Generic.List<IReportingTest> GetEnumerator()
        {
            return tests;
        }

        public void AddDBItem(string ClassID, FilterDBTable Value)
        {
            DBInfoPair dbiUse=null;

            // Find if ClassID exists already
            foreach (DBInfoPair dbi in dbInfoPairList)
            {
                if (dbi.classString.CompareTo(ClassID) == 0)
                {
                    dbiUse = dbi;
                    break;
                }
            }

            // If first
            if(dbiUse == null)
            {
                dbiUse = new DBInfoPair();
                dbiUse.classString = ClassID;
                dbiUse.iCount = 0;
                dbiUse.filterDBTableList = new List<DataInfoPair>();

                dbInfoPairList.Add(dbiUse);
            }


            dbiUse.iCount++;
            DataInfoPair newPair = new DataInfoPair();
            newPair.iSeq = dbiUse.iCount;
            newPair.filterDBTable = Value;
            dbiUse.filterDBTableList.Add(newPair);
        }

/*
        public void AddDBItem(string ClassID, FilterDBTable Value)
        {
            DBInfoPair newPair = new DBInfoPair();
            newPair.filterDBTable = Value;
            newPair.classString = ClassID;
            // TODO: Check and see if it over
            dbInfoPair.Add(newPair);
        }
*/

        public int GetCount(string ClassID)
        {
            foreach (DBInfoPair dbi in dbInfoPairList)
            {
                if (dbi.classString.CompareTo(ClassID) == 0)
                {
                    return dbi.iCount;
                }
            }

            return 0;
        }


        public FilterDBTable RetrieveDBTable(string ClassID)
        {
            return RetrieveDBTable(ClassID, 1);
        }

        public FilterDBTable RetrieveDBTable(string ClassID, int iSeq)
        {
            List<DataInfoPair> dataInfoPairList=null;

            foreach (DBInfoPair dbi in dbInfoPairList)
            {
                if (dbi.classString.CompareTo(ClassID) == 0)
                {
                    dataInfoPairList = dbi.filterDBTableList;
                }
            }

            if(dataInfoPairList == null)
                return null;

            foreach (DataInfoPair dataInfoPair in dataInfoPairList)
            {
                if (dataInfoPair.iSeq == iSeq)
                {
                    return dataInfoPair.filterDBTable;
                }
            }

            return null;
        }

/*
        public FilterDBTable RetrieveDBTable(string ClassID)
        {
            foreach (DBInfoPair dbi in dbInfoPair)
            {
                if (dbi.classString.CompareTo(ClassID) == 0)
                {
                    return dbi.filterDBTable;
                }
            }
            return null;
        }
*/

        public void ClearInfo()
        {
            dbInfoPairList = new List<DBInfoPair>();
        }

        public static void Initialize()
        {
            if (!initialized)
            {
                // A static item we know is initialized.
                lock (ReportingInfrTestBVTs.rnd)
                {
                    if (!initialized)
                    {
                        current = new DBInformation();
                        initialized = true;
                    }
                }
            }
        }
    }


    [TestGroup]
    public class BasePopulate : TestNode
    {
        public BasePopulate()
        {
            Init_TestGroup("");
        }

        public BasePopulate(string name)
        {
            Init_TestGroup(name);
        }
        private void Init_TestGroup(string name)
        {
            AddChild(new BasePopulateForAllTests());
        }
    }

    [TestGroup]
    public class LiveSvc_XUACS_Logs : TestNode
    {
        public LiveSvc_XUACS_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_XUACS_Logs(string name)
        {
            Init_TestGroup(name);
        }
        private void Init_TestGroup(string name)
        {
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XUACS_CreateAccount_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XUACS_CreateLiveAccount_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XUACS_MIGRATEXBOX1USER_Log()));
        }
    }

    [TestGroup]
    public class LiveSvc_XPSERVER_Logs : TestNode
    {

        public LiveSvc_XPSERVER_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_XPSERVER_Logs(string name)
        {
            Init_TestGroup(name);
        }

        private void Init_TestGroup(string name)
        {
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XPSERVER_TITLESTART_TITLEND_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XPSERVER_SESSTART_SESEND_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XPSERVER_SND_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XPSERVER_GUESTCHG_Log()));
            AddChild(new LiveSvc_XPSERVER_SES_ENDBEFORESTART_Log());
            AddChild(new LiveSvc_XPSERVER_TITLE_ENDBEFORESTART_Log());
            AddChild(new LiveSvc_XPSERVER_DUPLICATE_TITLE_START_Log());
            AddChild(new LiveSvc_XPSERVER_HEXIC_IGNORE_Log());
        }
    }

    [TestGroup]
    public class LiveSvc_XBOS_Logs : TestNode
    {
        public LiveSvc_XBOS_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_XBOS_Logs(string name)
        {
            Init_TestGroup(name);
        }
        private void Init_TestGroup(string name)
        {
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_CONTENTREF_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_XECR_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_XEOP_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log()));
            //AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_ACQUIRELICENSE_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log()));
            AddChild(new LiveSvc_acquirelicense_Log());
            AddChild(new LiveSvc_PurchaseOffer_Log());
            AddChild(new LiveSvc_EliteMigration_Log());
        }
    }

    [TestGroup]
    public class LiveSvc_XCBK_Logs : TestNode
    {
        public LiveSvc_XCBK_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_XCBK_Logs(string name)
        {
            Init_TestGroup(name);
        }
        private void Init_TestGroup(string name)
        {
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XCBK_PROVISIONSERVICE_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_XCBK_DEPROVISIONSERVICE_Log()));
        }
    }

    [TestGroup]
    public class LiveSvc_STRINGSVR_Logs : TestNode
    {
        public LiveSvc_STRINGSVR_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_STRINGSVR_Logs(string name)
        {
            Init_TestGroup(name);
        }

        private void Init_TestGroup(string name)
        {
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_CLICK_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_PURCHASE_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_BANNER_VIEW_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_FUSION_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_MULTI_AGG_Log()));
            AddChild(DBInformation.Instance.AddTest(new LiveSvc_STRINGSVR_HARDWAREINFO_Log()));
        }

    }

    [TestGroup]
    public class LiveSvc_STATSSVR_Logs : TestNode
    {
        public LiveSvc_STATSSVR_Logs()
        {
            Init_TestGroup("");
        }

        public LiveSvc_STATSSVR_Logs(string name)
        {
            Init_TestGroup(name);
            //AddChild(DBInformation.Instance.AddTest(new LiveSvc_STATSSVR_USAGESTORE_Log()));
        }

        private void Init_TestGroup(string name)
        {
            AddChild(new LiveSvc_STATSSVR_USAGESTORE_Log());
        }

    }



    [TestCase]
    public class BasePopulateForAllTests : TestBase
    {
        protected override void Execute()
        {
            bool success = true;
            //foreach
            foreach (IReportingTest irt in DBInformation.Instance.GetEnumerator())
            {
                try
                {
                    if (!irt.RunInitialStep(DBInformation.Instance))
                        success = false;
                }
                catch (Exception e)
                {
                    CUtil.log.Error("Exception on initial step:" + e.ToString());
                }
            }
            CUtil.log.Info("Waiting 60 seconds on filter db");
            System.Threading.Thread.Sleep(60000);
            foreach (IReportingTest irt in DBInformation.Instance.GetEnumerator())
            {
                try
                {
                    if (!irt.RunSecondPass())
                        success = false;
                }
                catch (Exception e)
                {
                    CUtil.log.Error("Exception on initial step:" + e.ToString());
                }
            }
            CUtil.log.Info("Waiting 60 seconds on filter db");
            System.Threading.Thread.Sleep(60000);

            if (success)
            {
                CUtil.log.Success("All initial populate steps succeeded.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("All initial populate steps did not succeeded.");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    public interface IReportingTest
    {
        bool RunInitialStep(DBInformation dbi);
        bool RunSecondPass();
    }

    [TestCase]
    public class LiveSvc_STATSSVR_USAGESTORE_Log : TestBase//, IReportingTest
    //public class LiveSvc_STATSSVR_USAGESTORE_Log : TestBase, IReportingTest
    {
        protected static UacsCommon2 UACS = new UacsCommon2();
        DBInformation dbRef;
        ServerTestFramework.LiveService.PresNotiCommon.PNUser user1, user2;


        public bool RunInitialStep(DBInformation dbi)
        {

            CUtil.log.Info("LiveSvc_STATSSVR_USAGESTORE_Log - Initial Step");

            ServerTestFramework.LiveService.Presence.FriendsCommon fc = new ServerTestFramework.LiveService.Presence.FriendsCommon();
            user1 = fc.CreateXenonUser(true);
            user2 = fc.CreateXenonUser(true);

            t_usagestore_fact tbl = new t_usagestore_fact();
            XRLUsageStore xrlUsageStore = new XRLUsageStore();

            string UsageStoreXML;

            UsageStoreXML =   "<UsageStore xmlns=\"http://www.xboxlive.com/usage\">\r\n";
            UsageStoreXML +=    "<User Id=\""+user1.UserId.ToString("X")+"\">\r\n";
            UsageStoreXML +=        "<Media Id=\"01234567-0123-0123-0123-0123456789AB\"  Type=\"1\">\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"1\" Date=\"6/20/2007 2:10:08 PM\" Value=\"5\" Source=\"2\"/>\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"2\" Value=\"1\" Source=\"2\" />\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"3\" Value=\"1\" Source=\"2\" />\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"4\" Value=\"1\" Source=\"2\" />\r\n\r\n" ;
            UsageStoreXML +=        "</Media>\r\n\r\n" ;
            UsageStoreXML +=        "<Media Id=\"01234567-0123-0123-0123-0123456789AC\"  Type=\"2\">\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"1\" Value=\"2\" Source=\"2\" />\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"5\" Value=\"1\" Source=\"2\" />\r\n" ;
            UsageStoreXML +=        "</Media>\r\n\r\n" ;
            UsageStoreXML +=    "</User>\r\n\r\n" ;
            UsageStoreXML +=    "<User Id=\""+user2.UserId.ToString("X")+"\">\r\n";
            UsageStoreXML +=        "<Media Id=\"01234567-0123-0123-0123-0123456789AD\"  Type=\"3\" AdId=\"1\" ProviderId=\"2\">\r\n" ;
            UsageStoreXML +=            "<Attribute Id=\"1\" Date=\"6/20/2007 2:10:08 PM\" Value=\"1\" Source=\"1\" />\r\n" ;
            UsageStoreXML +=        "</Media>\r\n\r\n" ;
            UsageStoreXML +=    "</User>\r\n\r\n" ;
            UsageStoreXML += "</UsageStore>\r\n" ;


            xrlUsageStore.XML = UsageStoreXML;
            xrlUsageStore.xmlLength = xrlUsageStore.XML.Length;

            bool bResult = xrlUsageStore.Execute();
            if(!bResult)
            {
                CUtil.log.Error("ContentReferral request failed.");
                xrlUsageStore.Dump();
                ResultCode = TEST_RESULTS.FAILED;
                return false;
            }

            // 1
            tbl.dt_when = new DateRange(180, 30);
            tbl.bi_user_puid = user1.UserId.ToString();
            tbl.ui_media_instance_id = "01234567-0123-0123-0123-0123456789AB";
            tbl.i_attribute_id = ((int)1).ToString();
            tbl.i_attribute_value = ((int)5).ToString();
            tbl.dt_date_entry = new DateTime(2007,6,20,14,10,8).ToString("MM/dd/yyyy HH:mm:ss.fff");
            tbl.i_source_id = "2";
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            //2
            tbl.i_attribute_id = ((int)2).ToString();
            tbl.i_attribute_value = ((int)1).ToString();
            tbl.dt_date_entry = "";
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            //3
            tbl.i_attribute_id = ((int)3).ToString();
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            //3
            tbl.i_attribute_id = ((int)4).ToString();
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            // 5
            tbl.bi_user_puid = user1.UserId.ToString();
            tbl.ui_media_instance_id = "01234567-0123-0123-0123-0123456789AC";
            tbl.i_attribute_id = "1";
            tbl.i_attribute_value = "2";
            tbl.i_source_id = "2";
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            // 6
            tbl.bi_user_puid = user1.UserId.ToString();
            tbl.ui_media_instance_id = "01234567-0123-0123-0123-0123456789AC";
            tbl.i_attribute_id = "5";
            tbl.i_attribute_value = "1";
            tbl.i_source_id = "2";
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            // 7
            tbl.bi_user_puid = user2.UserId.ToString();
            tbl.ui_media_instance_id = "01234567-0123-0123-0123-0123456789AD";
            tbl.i_attribute_id = "1";
            tbl.i_attribute_value = "1";
            tbl.dt_date_entry = new DateTime(2007,6,20,14,10,8).ToString("MM/dd/yyyy HH:mm:ss.fff");
            tbl.i_source_id = "1";
            dbi.AddDBItem("LiveSvc_USAGESTORE_Log", tbl);

            dbRef = dbi;

            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            ResultCode = TEST_RESULTS.PASSED;

            bool bRet;

            bRet = RunInitialStep(DBInformation.Instance);
            int    iCount = dbRef.GetCount("LiveSvc_USAGESTORE_Log");

            for(int ii=1; ii<=iCount; ii++)
            {
                FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_USAGESTORE_Log", ii);
                CUtil.log.Info("Verify USAGESTORE message in FilterDB.");
                if (CUtil.VerifyFilterDB("usagestore",tbl))
                {
                    CUtil.log.Success("USAGESTORE log data found in FilterDB.");
                }
                else
                {
                    CUtil.log.Error("USAGESTORE log data NOT in FilterDB!");
                    ResultCode = TEST_RESULTS.FAILED;
                }
            }
        }

    }



    [TestCase]
    public class LiveSvc_XPSERVER_SND_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            FriendsCommon fc = new FriendsCommon();
            PNUser user1 = fc.CreateUser(true);
            PNUser user2 = fc.CreateUser(true);
            CUtil.log.Info("LiveSvc_XPSERVER_SND_Log - Initial Step");
            CUtil.log.Info("Sending friend request from " + user1.UserId.ToString() +
                " to " + user2.UserId.ToString());
            user1.AddBuddy(user2);
            user2.AcceptBuddy(user1);
            t_msg_snd_fact tbl = new t_msg_snd_fact();

            tbl.bi_sender_puid = ((Int64)user1.UserId).ToString();
            tbl.i_sender_title_id = ((Int32)FriendsCommon.DefaultXenonTitleId).ToString();
            tbl.si_msg_type = XonPresNoti.MSG_TYPE_FRIEND_REQUEST.ToString();
            tbl.vc_recipients_list = user2.UserId.ToString("X"); // stored in hex format in filterdb
            tbl.dt_when = new DateRange(180, 30);
            dbi.AddDBItem("LiveSvc_XPSERVER_SND_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_SND_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XPSERVER_SND_Log");

            CUtil.log.Info("Verify SND message in FilterDB.");
            if (CUtil.VerifyFilterDB("snd",tbl) ==  true)
            {
                CUtil.log.Success("SND log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("SND log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    public class LiveSvc_XBOS_CONTENTREF_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            UacsCommon UACS = new UacsCommon();
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_CONTENTREF_Log Inital Step \n");

            CUtil.log.Info("Sending content referral request.");
            XRLContentReferral request = new XRLContentReferral();

            ulong puid = UACS.CreateUser();

            request.UserPuid0 = puid;
            request.MachineId = puid;
            request.Rating = 2;
            // Use BVT titleID and offerID
            request.OfferingId = 0xA704995500000001;

            request.TitleId = 0xA7049955;
            if (request.Execute())
            {
                CUtil.log.Info("Content referral request sent.");
                //
                // Verify log entry in FILTERDB
                //
                // Format:
                // CONTENTREF|MachineID|userPUID0|userPUID1|userPUID2|userPUID3|titleID|offerID|hresult|referralNonce|Nonce
                t_content_fact tbl = new t_content_fact();
                tbl.bi_machine_puid = ((Int64)request.MachineId).ToString();
                tbl.bi_user_puid = ((Int64)request.UserPuid0).ToString();
                tbl.bi_owner_machine_puid = ((Int64)request.MachineId).ToString();
                tbl.i_title_id = ((Int32)request.TitleId).ToString();
                tbl.bi_offer_id = ((Int64)request.OfferingId).ToString();
                tbl.b_content_id = "0"; // contentID - for Xenon only
                tbl.dt_when = new DateRange(180, 30);
                dbi.AddDBItem("LiveSvc_XBOS_CONTENTREF_Log", tbl);
                dbRef = dbi;
                return true;
            }
            else
            {
                CUtil.log.Error("ContentReferral request failed.");
                request.Dump();
                ResultCode = TEST_RESULTS.FAILED;
                return false;
            }
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_CONTENTREF_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XBOS_CONTENTREF_Log");
            bool result = CUtil.VerifyFilterDB("xbos", tbl);
            if (result == false)
            {
                CUtil.log.Error("CONTENTREF message was NOT found in FilterDB.");
                ResultCode = TEST_RESULTS.FAILED;
            }
            else
            {
                CUtil.log.Success("CONTENTREF message was found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }

    [TestCase]
    public class LiveSvc_XBOS_XECR_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            const uint TITLE_ID = 0x2b5a78ab;
            const ulong OFFER_ID = 0x7a3aff8d5e0638ba;
            const string CONTENT_XRL1 = "http://www.example.com/7a3aff8d5e0638ba/downloadme1.xui";

            byte[] contentId = null;
            byte[] symKey = null;
            byte[] publicKey = null;
            string[] xrls = new string[1];
            xrls[0] = CONTENT_XRL1;
            int priceWhole = 10;

            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_XECR_Log Initial Step \n");

            Random r = new Random((int)DateTime.UtcNow.Ticks);
            byte[] content_id = new byte[20];
            byte[] sym_key = new byte[16];
            byte[] public_key = new byte[284];
            r.NextBytes(content_id);
            r.NextBytes(sym_key);
            r.NextBytes(public_key);

            ContentOfferLoader.CleanOffers(OFFER_ID);
            ContentOfferLoader.CleanTitle(TITLE_ID);
            ContentOfferLoader.InsertTitle(TITLE_ID);
            ContentOfferLoader.InsertTitleRating(TITLE_ID, 0, 1);
            ContentOfferLoader.InsertTitleCultureDetails(TITLE_ID,
                1033,
                "ContentReferral Test Title",
                "Sell text goes here.",
                "Microsoft",
                "reinouth",
                "TestGenre");

            ContentOfferLoader.AddContent(content_id,
                2000,
                1000,
                sym_key,
                public_key);

            for (int i = 0; i < xrls.Length; i++)
            {
                Global.RO.Info("Adding XRL: " + xrls[i]);
                ContentOfferLoader.AddContentLocations(content_id,
                    i + 1,
                    xrls[i]);
            }


            ContentOfferLoader.AddOffer(TITLE_ID,
                OFFER_ID,
                1000,
                2000,
                0,
                (int)live.common.OfferingTypeEnum.GameTrailer,
                "Test offer for testing XeContentReferral",
                true,
                content_id);
            ContentOfferLoader.AddOfferCultureDetails(
                OFFER_ID,
                1033,
                "Testoffer - XeContentReferral",
                "Sell text goes here");
            ContentOfferLoader.AddOfferRegion(
                OFFER_ID,
                103,
                3,
                (int)live.common.PaymentTypeEnum.Points,
                DateTime.UtcNow.AddYears(-1),
                DateTime.UtcNow.AddYears(1),
                "",
                priceWhole,
                0,
                0);

            contentId = content_id;
            symKey = sym_key;
            publicKey = public_key;

            XRLXeContentReferral request = new XRLXeContentReferral();
            XRLXeContentReferralResponse response = new XRLXeContentReferralResponse();

            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0) throw new UnexpectedTestResultException("XeUser.Create() failed: " + user.GetDumpString());

            // give the user/machine combination the rights to access this content
            ulong machinePuid = user.MachinePuid;
            ContentOfferLoader.GrantContentLicense(user.UserPuid, machinePuid, OFFER_ID);

            request.ContentId = contentId;
            request.UserId = user.UserPuid;

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeContentReferral failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentReferral returned XErr=0x{0:x}", request.XErr));

            if (response.Locations.Length != 1)
                throw new UnexpectedTestResultException("Expected a singe referral location for this content Id.");

            Global.RO.Info("XRL returned = " + response.Locations[0].Xrl);
            if (response.Locations[0].Xrl != xrls[0])
                throw new UnexpectedTestResultException("XRLs don't match.");

            // Format
            // XeContentReferral|machineID|userID|sginfoMachineID|contentID|packageSize|installSize|length|hr|Nonce
            //
            // Nonce is in decimal while all other values are in hex

            // Fields to verify
            t_content_fact tbl = new t_content_fact();
            tbl.b_content_id = "0x" + Hexer.tohex(contentId);
            tbl.bi_machine_puid = "0x" + ServerTestFramework.LiveService.FakeSG.GlobalFakeSG.FakeSG.GetSlot().machinePuid.ToString("X");
            tbl.bi_offer_id = "0"; // not used in Xenon
            tbl.bi_owner_machine_puid = "0x" + machinePuid.ToString("X");
            tbl.bi_user_puid = ((Int64)user.UserPuid).ToString();
            tbl.i_title_id = "0"; // not used in Xenon
            tbl.dt_when = new DateRange(180, 30);
            dbi.AddDBItem("LiveSvc_XBOS_XECR_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_XECR_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XBOS_XECR_Log");

            CUtil.log.Info("Verify XeContentReferral message in FilterDB.");
            if (CUtil.VerifyFilterDB("xbos",tbl) ==  true)
            {
                CUtil.log.Success("XeContentReferral log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("XeContentReferral log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

        }
    }

    [TestCase]
    public class LiveSvc_XUACS_CreateAccount_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            RandomEx rndx = new RandomEx();
            string sName = rndx.GenerateRandomString("rpt", 15);
            Owner owner = new Owner(sName);
            ulong userID = owner.Create();
            CUtil.log.Debug("Created user " + userID.ToString());

            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CreateAccount_Log Initial Step \n");

            t_new_account_fact tbl = new t_new_account_fact();
            tbl.bi_machine_puid = owner.machinePuid.ToString(); // machineID
            tbl.bi_user_passport_puid = "0"; // UserPassportPuid
            tbl.bi_owner_passport_puid = "0"; // OwnerPassportPuid
            tbl.bi_user_puid = ((Int64)userID).ToString();   // UserPuid
            tbl.i_hresult = "0"; // HResult
            tbl.ti_country_id = "103"; // CountryId
            tbl.i_language_id = "1"; // LanguageId
            tbl.i_culture_id = "0"; // CultureId
            tbl.bi_offer_id = "0xFFFE000080000008"; // OfferId
            tbl.ti_console_type = "0"; // consoleType (0:xbox1, 1:xbox.com, 2:xenon)
            tbl.dt_when = new DateRange(180, 30);

            // Format:
            // CREATEACCOUNT|9000000000769|0|Xbos46uo08|xboxstress@winisp.net|103|98014|1|9400000000000|0|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223
            // Verify CREATEACCOUNT log data
            dbi.AddDBItem("LiveSvc_XUACS_CreateAccount_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CreateAccount_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XUACS_CreateAccount_Log");
            CUtil.log.Info("Verify CREATEACCOUNT message.");
            if (CUtil.VerifyFilterDB("xuacs",tbl) ==  true)
            {
                CUtil.log.Success("CREATEACCOUNT log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("CREATEACCOUNT log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    public class LiveSvc_XUACS_CreateLiveAccount_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            XeUser user = new XeUser(true);
            ulong puid = user.Create();
            CUtil.log.Info("Created Xenon user " + puid.ToString());
            CUtil.log.Info("PassportPUID " + user.PassportUserPuid.ToString());
            Thread.Sleep(1000);

            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CreateLiveAccount_Log Inital Step \n");

            t_new_account_fact tbl = new t_new_account_fact();
            tbl.bi_machine_puid = "0xFA00000012341234"; // machineID
            tbl.bi_user_passport_puid = ((Int64)user.PassportUserPuid).ToString(); // UserPassportPuid
            tbl.bi_owner_passport_puid = ((Int64)user.PassportUserPuid).ToString(); // OwnerPassportPuid
            tbl.bi_user_puid = ((Int64)puid).ToString();     // UserPuid
            tbl.i_hresult = "0"; // HResult
            tbl.ti_country_id = user.CountryId.ToString(); // CountryId
            tbl.i_language_id = "1"; // LanguageId
            tbl.i_culture_id = "1033"; // CultureId
            tbl.bi_offer_id = "0xFFFE07D180000011"; // Silver OfferId
            tbl.ti_console_type = "2"; // consoleType (0:xbox1, 1:xbox.com, 2:xenon)
            tbl.dt_when = new DateRange(180, 30);

            // Format:
            // CREATEACCOUNT|9000000000769|0|Xbos46uo08|xboxstress@winisp.net|103|98014|1|9400000000000|0|FFFE000080000008|460d1abd933833bad54f47bc83b04226e9c96223
            // Verify CREATEACCOUNT log data
            dbi.AddDBItem("LiveSvc_XUACS_CreateLiveAccount_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CreateLiveAccount_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XUACS_CreateLiveAccount_Log");

            CUtil.log.Info("Verify CREATELIVEACCOUNT message.");
            if (CUtil.VerifyFilterDB("xuacs",tbl) ==  true)
            {
                CUtil.log.Success("CREATEAvCCOUNT log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("CREATELIVEACCOUNT log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    public class LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log Inital Step \n");

            // Check bug# 25859
            XRLXeCreateXboxComAccount request = new XRLXeCreateXboxComAccount();
            XRLXeCreateXboxComAccountResponse response = new XRLXeCreateXboxComAccountResponse();
            Thread.Sleep(1000);

            // Create passport user
            UacsCommon uc = new UacsCommon();
            UacsCommon.PassportUser passportUser = uc.CreatePassportUser();

            // Set passport user info in request
            request.OwnerPassportPuid = passportUser.PassportPuid;
            request.UserPassportPuid = passportUser.PassportPuid;

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XeCreateXboxComAccount failed: " + request.GetDumpString());

            if (response.UserPuid == 0)
                throw new UnexpectedTestResultException("User puid returned was 0.");

            t_new_account_fact tbl = new t_new_account_fact();
            // No longer valid for machine PUID
            //tbl.bi_machine_puid = "0"; // machineID
            tbl.bi_user_passport_puid = ((Int64)request.UserPassportPuid).ToString(); // UserPassportPuid
            tbl.bi_owner_passport_puid = ((Int64)request.UserPassportPuid).ToString(); // OwnerPassportPuid
            tbl.bi_user_puid = ((Int64)response.UserPuid).ToString();    // UserPuid
            tbl.i_hresult = "0"; // HResult
            tbl.ti_country_id = request.CountryId.ToString(); // CountryId
            tbl.i_language_id = request.LanguageId.ToString(); // LanguageId
            tbl.i_culture_id = "1033"; // CultureId
            tbl.bi_offer_id = "0"; // OfferId
            tbl.ti_console_type = "1"; // consoleType (0:xbox1, 1:xbox.com, 2:xenon)
            tbl.dt_when = new DateRange(180, 30);

            // Format:
            // CREATEXBOXCOMACCOUNT|UserPassportPuid|OwnerPassportPuid|UserPuid|hr
            // |Gamertag|Email|PostalCode|CountryId|LanguageId|CultureId

            dbi.AddDBItem("LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XUACS_CREATEXBOXCOMACCOUNT_Log");

            // Verify CREATEACCOUNT log data
            CUtil.log.Info("Verify CREATEXBOXCOMACCOUNT message.");
            if (CUtil.VerifyFilterDB("xuacs",tbl) ==  true)
            {
                CUtil.log.Success("CREATEXBOXCOMACCOUNT log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("CREATEXBOXCOMACCOUNT log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_XCBK_PROVISIONSERVICE_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XCBK_PROVISIONSERVICE_Log Inital Step \n");

            // PROVISIONSERVICE|billingPUID|userPUID|svcInstanceID|oldOfferID|oldTier|newOfferID|newTier
            RandomEx rndx = new RandomEx();
            string sName = rndx.GenerateRandomString("rpt", 15);
            Owner owner = new Owner(sName);
            ulong userID = owner.Create();
            CUtil.log.Debug("Created user " + userID.ToString());
            Thread.Sleep(2000);
            t_provision_fact tbl = new t_provision_fact();
            tbl.bi_from_offer_id = "0xFFFE000080000008";
            tbl.bi_to_offer_id = "0xFFFE000080000008";
            tbl.bi_user_puid = ((Int64)userID).ToString();
            tbl.dt_when = new DateRange(180, 30);
            tbl.f_active = "1";
            tbl.i_from_tier_id = "6"; // What is it?
            tbl.i_to_tier_id = "6";

            // Format:
            // PROVISIONSERVICE|userPUID|svcInstanceID|oldOfferID|oldTier|newOfferID|newTier
            // Verify PROVISIONSERVICE log data
            dbi.AddDBItem("LiveSvc_XCBK_PROVISIONSERVICE_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XCBK_PROVISIONSERVICE_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XCBK_PROVISIONSERVICE_Log");

            CUtil.log.Info("Verify PROVISIONSERVICE message.");
            if (CUtil.VerifyFilterDB("xcbk",tbl) ==  true)
            {
                CUtil.log.Success("PROVISIONSERVICE log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("PROVISIONSERVICE log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }


    [TestCase]
    class LiveSvc_XCBK_DEPROVISIONSERVICE_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XCBK_DEPROVISIONSERVICE_Log Initial Step \n");
            CUtil.log.Info("TEST CASE: Deprovisioning xbox user.");

            RandomEx rndx = new RandomEx();
            string sName = rndx.GenerateRandomString("rpt", 15);
            Owner owner = new Owner(sName);
            ulong userID = owner.Create();
            CUtil.log.Debug("Created user to deprovision: " + userID.ToString());
            Thread.Sleep(1000);

            SvcProviderWrapper Provider = new SvcProviderWrapper();
            // override IP to point to proxy server
            //Provider.Prov.Url = "https://" + Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.xcbk)[0] + "/xcbk/sprov.asmx";

            //Provider.Prov.Url = "https://10.198.103.102/xcbk/sprov.asmx";
            bool b = false;

            SubscriptionInfo[] si = UodbWS.GetUserServiceIDs(userID);

            string errorString = "";
            CUtil.log.Info("Deprovisioning service for user to render account inactive.");
            b = Provider.DeprovisionService(userID, si[0].serviceInstanceId, false, out errorString);
            if (!b)
            {
                //DumpInfo(Provider);
                throw new UnexpectedTestResultException("DeprovisionService failed: (" + errorString + ")");
            }

            // Check deprovision log in FilterDB
            t_provision_fact tbl = new t_provision_fact();
            tbl.bi_from_offer_id = "0xFFFE000080000008";
            tbl.bi_to_offer_id = "0";
            tbl.bi_user_puid = ((Int64)userID).ToString();
            tbl.dt_when = new DateRange(180, 30);
            tbl.f_active = "0"; // 0 for deprovisioned account
            tbl.i_from_tier_id = "6"; // What is it?
            tbl.i_to_tier_id = "0";

            // Format:
            // DEPROVISIONSERVICE|userPUID|svcInstanceID|oldOfferID|oldTier|newOfferID|newTier
            // Verify DEPROVISIONSERVICE log data
            dbi.AddDBItem("LiveSvc_XCBK_DEPROVISIONSERVICE_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        // PROVISIONSERVICE|billingPUID|userPUID|svcInstanceID|oldOfferID|oldTier|newOfferID|newTier
        // DEPROVISIONSERVICE|billingPUID|userPUID|svcInstanceID|oldOfferID|oldTier|newOfferID|newTier
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XCBK_DEPROVISIONSERVICE_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XCBK_DEPROVISIONSERVICE_Log");

            CUtil.log.Info("Verify DEPROVISIONSERVICE message.");
            if (CUtil.VerifyFilterDB("xcbk",tbl) ==  true)
            {
                CUtil.log.Success("DEPROVISIONSERVICE log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("DEPROVISIONSERVICE log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

        }
    }

    // *********
    //  TODO: Split this into two tests!
    // *********
    [TestCase]
    public class LiveSvc_XPSERVER_TITLESTART_TITLEND_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;
        bool result = true;
        PNUser user;
        DateTime dtNow;
        TimeSpan tsMs;
        int OneDayMs;
        int todayMs;
        int diffMs;
        uint titleid;
        FriendsCommon fc;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_TITLESTART_TITLEND_Log Initial STep \n");

            fc = new FriendsCommon();
            user = fc.CreateXenonUser(true);
            CUtil.log.Info("Created user " + user.UserId.ToString());
            Thread.Sleep(1000);

            // TITLESTART|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey
            t_presence_fact tbl = new t_presence_fact();
            tbl.bi_machine_puid = ((Int64)user.Xbox.XboxId).ToString(); // machine puid
            // tbl.bi_session_id Ignore
            tbl.bi_user_puid = ((Int64)user.UserId).ToString();
            tbl.bi_xbox_IP = ((Int64)user.Xbox.IpSg).ToString();
            tbl.dt_start = new DateRange(360, 240);
            tbl.f_playing_now = "1"; // session hasn't ended yet
            dtNow = DateTime.UtcNow;
            // Total number of milliseconds in a day
            OneDayMs = 24 * 60 * 60 * 1000;
            // Total number of milliseconds today
            tsMs = new TimeSpan(0, dtNow.Hour, dtNow.Minute, dtNow.Second, dtNow.Millisecond);
            todayMs = (int)tsMs.TotalMilliseconds;
            // Remaining milliseconds until midnight
            diffMs = OneDayMs - todayMs;
            tbl.i_duration_ms = diffMs.ToString();
            tbl.i_title_id = ((Int32)FriendsCommon.DefaultXenonTitleId).ToString();
            dbi.AddDBItem("LiveSvc_XPSERVER_TITLESTART_TITLEND_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_TITLESTART_TITLEND_Log Second Step \n");

            t_presence_fact tbl = (t_presence_fact) dbRef.RetrieveDBTable("LiveSvc_XPSERVER_TITLESTART_TITLEND_Log");

            CUtil.log.Info("Verify TITLESTART message.");
            if (CUtil.VerifyFilterDB("titlestart", tbl))
            {
                CUtil.log.Success("TITLESTART log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLESTART log data NOT in FilterDB!");
                result = false;
            }

            titleid = 0xa7049955;
            CUtil.log.Info("Changing titleID from " + FriendsCommon.DefaultXenonTitleId.ToString("X") +
                " to " + titleid.ToString("X") + "...");
            user.Xbox.ChangeTitle(titleid, 0, 0);
            user.SetTitleData(user.State | XonPresNoti.P_STATE_MASK_ONLINE);
            Thread.Sleep(1000);

            tsMs = new TimeSpan(0, dtNow.Hour, dtNow.Minute, dtNow.Second, dtNow.Millisecond);
            todayMs = (int)tsMs.TotalMilliseconds;
            // Remaining milliseconds until midnight
            diffMs = OneDayMs - todayMs;

            // TITLEND|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey|Duration(ms)
            tbl.f_playing_now = "0"; // session ended
            tbl.i_duration_ms = "11000"; // in ms
            tbl.dt_start = new DateRange(360, 240);
            dbRef.AddDBItem("LiveSvc_XPSERVER_TITLESTART_TITLEND_Log_2", tbl);
            return true;
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_TITLESTART_TITLEND_Log Final Step \n");

            t_presence_fact tbl = (t_presence_fact)dbRef.RetrieveDBTable("LiveSvc_XPSERVER_TITLESTART_TITLEND_Log_2");
            CUtil.log.Info("Verify TITLEND message.");

            //TODO: Mark as failed if any of these fail.
            //TODO: Grab table

            if (CUtil.VerifyFilterDB("titlend", tbl))
            {
                CUtil.log.Success("TITLEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLEND log data NOT in FilterDB!");
                result = false;
            }

            tbl.f_playing_now = "1"; // session hasn't ended yet
            tbl.i_duration_ms = diffMs.ToString(); // time until midnight in ms
            tbl.i_title_id = ((Int32)titleid).ToString(); // new title

            CUtil.log.Info("Verify TITLESTART message for NEW Title " + titleid.ToString()
                + " (" + titleid.ToString("X") + ")");
            if( CUtil.VerifyFilterDB("titlestart", tbl))
            {
                CUtil.log.Success("TITLESTART log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLESTART log data NOT in FilterDB!");
            }

            CUtil.log.Info("Logging off user...");
            fc.LogoffUser(user);
            Thread.Sleep(1000);
            tbl.f_playing_now = "0"; // session ended
            tbl.i_duration_ms = "" + (120 + 1000); // in ms
            tbl.dt_start = new DateRange(180, 30);
            CUtil.log.Info("Waiting 10 seconds on filter DB");
            Thread.Sleep(20000);

            CUtil.log.Info("Verify TITLEND message for NEW Title " + titleid.ToString()
                + " (" + titleid.ToString() + ")");

            if (CUtil.VerifyFilterDB("titlend",tbl))
            {
                CUtil.log.Success("TITLEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLEND log data NOT in FilterDB!");
                result = false;
            }

            if (result)
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }

    // *********
    //  TODO: Split this into two tests!
    // *********

    [TestCase]
    public class LiveSvc_XPSERVER_SESSTART_SESEND_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;
        FriendsCommon fc;
        PNUser user1;
        bool result = true;

        public bool RunInitialStep(DBInformation dbi)
        {
            ulong sessionID = 1234;
            t_session_fact tbl = new t_session_fact();
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_SESSTART_SESEND_Log Initial Step \n");

            fc = new FriendsCommon();
            user1 = fc.CreateXenonUser(true);
            CUtil.log.Info("Created user " + user1.UserId + " (" + user1.UserId.ToString("X") + ")");
            CUtil.log.Info("Setting user state to playing...");
            tbl.bi_machine_puid = "0x"+ user1.Xbox.XboxId.ToString("X");
            user1.SetTitleData(user1.State | XonPresNoti.P_STATE_MASK_PLAYING, sessionID, new byte[1]);

            Thread.Sleep(1000);

            // Format:
            // SESSTART|MachinePUID|TitleID|UserPUID|State|SessionID
            // Verify SESSTART log data
            tbl.bi_session_id = sessionID.ToString();
            tbl.bi_user_puid = ((Int64)user1.UserId).ToString();
            tbl.dt_start = new DateRange(360, 240);
            DateTime dtNow = DateTime.UtcNow;
            // Total number of milliseconds in a day
            int OneDayMs = 24 * 60 * 60 * 1000;
            // Total number of milliseconds today
            TimeSpan tsMs = new TimeSpan(0, dtNow.Hour, dtNow.Minute, dtNow.Second, dtNow.Millisecond);
            int todayMs = (int)tsMs.TotalMilliseconds;
            // Remaining milliseconds until midnight
            int diffMs = OneDayMs - todayMs;
            tbl.i_duration_ms = diffMs.ToString();
            tbl.i_title_id = ((Int32)FriendsCommon.DefaultXenonTitleId).ToString();
            dbi.AddDBItem("LiveSvc_XPSERVER_SESSTART_SESEND_Log", tbl);
            dbRef = dbi;
            return false;
        }

        public bool RunSecondPass()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_SESSTART_SESEND_Log Second Step \n");

            t_session_fact tbl = (t_session_fact)dbRef.RetrieveDBTable("LiveSvc_XPSERVER_SESSTART_SESEND_Log");

            CUtil.log.Info("Verify SESSTART message.");
            bool f1 = CUtil.VerifyFilterDB("sesstart", tbl);
            if (f1)
            {
                CUtil.log.Success("SESSTART log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("SESSTART log data NOT in FilterDB!");
                result = false;
            }

            CUtil.log.Info("Logging off user...");
            fc.LogoffUser(user1);
            Thread.Sleep(1000);

            // Format:
            // SESEND|MachinePUID|TitleID|UserPUID|State|SessionID|Duration(ms)
            // Verify SESEND log data
            tbl.dt_start = new DateRange(360, 240);
            tbl.i_duration_ms = "11000"; // 11,000 ms
            dbRef.AddDBItem("LiveSvc_XPSERVER_SESSTART_SESEND_Log_2", tbl);
            return true;
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_SESSTART_SESEND_Log Final Step \n");

            t_session_fact tbl = (t_session_fact)dbRef.RetrieveDBTable("LiveSvc_XPSERVER_SESSTART_SESEND_Log_2");

            CUtil.log.Info("Verify SESEND message.");

            if (CUtil.VerifyFilterDB("sesend",tbl))
            {
                CUtil.log.Success("SESEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("SESEND log data NOT in FilterDB!");
                result = false;
            }

            if (result)
                ResultCode = TEST_RESULTS.PASSED;
            else
                ResultCode = TEST_RESULTS.FAILED;
        }
    }

    [TestCase]
    public class LiveSvc_XPSERVER_GUESTCHG_Log : TestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_GUESTCHG_Log Initial Step \n");

            FriendsCommon fc = new FriendsCommon();
            PNUser user = fc.CreateXenonUser(true);
            CUtil.log.Info("Created user " + user.UserId.ToString());

            CUtil.log.Info("Setting the state mask for guests");
            user.SetTitleData(user.State | XonPresNoti.P_STATE_MASK_GUESTS);

            CUtil.log.Info("Logging off user.");
            fc.LogoffUser(user);

            t_guest_fact t = new t_guest_fact();
            t.bi_user_puid = ((Int64)user.UserId).ToString();
            t.dt_when = new DateRange(180, 180);
            t.i_title_id = ((Int32)FriendsCommon.DefaultXenonTitleId).ToString();
            t.ti_max_guests_count = "3";
            dbi.AddDBItem("LiveSvc_XPSERVER_GUESTCHG_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_GUESTCHG_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XPSERVER_GUESTCHG_Log");

            CUtil.log.Info("Verify GUESTCHG message.");
            if (CUtil.VerifyFilterDB("GUESTCHG", tbl))
            {
                CUtil.log.Success("GUESTCHG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("GUESTCHG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

        }
    }

    // TODO: Move out of the BVT and into a "regression pass" since this can't be split
    [TestCase]
    public class LiveSvc_XPSERVER_SES_ENDBEFORESTART_Log : TestBase
    {
        // Stripped from stress code
        public void CreateSessionStartMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string sessionID)
        {
            logLine.Append("SESSTART|");
            logLine.Append(machineID);
            logLine.Append("|4C410011|");
            logLine.Append(userID);
            logLine.Append("|200|");
            logLine.Append(sessionID);
        }

        public void CreateSessionEndMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string sessionID)
        {
            logLine.Append("SESEND|");
            logLine.Append(machineID);
            logLine.Append("|4C410011|");
            logLine.Append(userID);
            logLine.Append("|200|");
            logLine.Append(sessionID);
            logLine.Append("|EA60");
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_SES_ENDBEFORESTART_Log Test \n");

            CleanserConneciton cc = new CleanserConneciton(ComponentType.Presence);
            StringBuilder sb = new StringBuilder();
            Random rnd = new Random();
            Int32 session = rnd.Next(Int32.MaxValue);
            string sessionID = session.ToString("X");
            string userID;
            string machineID;
            t_session_fact tbl = new t_session_fact();
            UInt64 newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            userID = newInt.ToString("X");
            tbl.bi_user_puid = newInt.ToString();
            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            machineID = newInt.ToString("X");
            tbl.bi_machine_puid = newInt.ToString();
            tbl.bi_session_id = session.ToString();
            tbl.dt_start = new DateRange(90, 0);
            tbl.i_duration_ms = ((Int32) 0xEA60).ToString();
            tbl.i_title_id = ((Int32)0x4C410011).ToString();
            CreateSessionEndMessage(ref sb, ref machineID, ref userID, ref sessionID);
            cc.Send(sb.ToString());
            CUtil.log.Info("Waiting 20 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("sesend", tbl))
            {
                CUtil.log.Success("SESEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("SESEND log data NOT in FilterDB!");
            }
            sb = new StringBuilder();
            CreateSessionStartMessage(ref sb, ref machineID, ref userID, ref sessionID);
            cc.Send(sb.ToString());
            CUtil.log.Info("Waiting 20 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("sesend", tbl))
            {
                CUtil.log.Success("SESEND log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("SESEND log data NOT in FilterDB!");
            }
        }
    }

    // TODO: Move out of the BVT and into a "regression pass"
    [TestCase]
    public class LiveSvc_XPSERVER_TITLE_ENDBEFORESTART_Log : TestBase
    {
        public void CreateTitleStartMessage(ref StringBuilder logLine, ref string machineID, ref string userID)
        {
            logLine.Append("TITLESTART|");
            logLine.Append(machineID);
            logLine.Append("|4C410011|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C");
        }

        public void CreateTitleEndMessage(ref StringBuilder logLine, ref string machineID, ref string userID)
        {
            logLine.Append("TITLEND|");
            logLine.Append(machineID);
            logLine.Append("|4C410011|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C|EA60");
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_TITLE_ENDBEFORESTART_Log Test \n");

            CleanserConneciton cc = new CleanserConneciton(ComponentType.Presence);
            StringBuilder sb = new StringBuilder();
            Random rnd = new Random();
            Int32 session = rnd.Next(Int32.MaxValue);
            string sessionID = session.ToString("X");
            string userID;
            string machineID;
            t_presence_fact tbl = new t_presence_fact();
            UInt64 newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            userID = newInt.ToString("X");
            tbl.bi_user_puid = newInt.ToString();
            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            machineID = newInt.ToString("X");
            tbl.bi_machine_puid = newInt.ToString();

            // ?? What should this be
            tbl.dt_start = new DateRange(90, 30);
            tbl.i_duration_ms = ((Int32)0xEA60).ToString();
            tbl.i_title_id = ((Int32)0x4C410011).ToString();
            // tbl.bi_session_id Ignore
            tbl.bi_session_id = session.ToString();
            tbl.bi_xbox_IP = ((Int64)0x1099).ToString();
            tbl.f_playing_now = "0"; // session hasn't ended yet
            CreateTitleEndMessage(ref sb, ref machineID, ref userID);
            CUtil.log.Info("Sending " + sb.ToString() + "\n");
            cc.Send(sb.ToString());
            CUtil.log.Info("Waiting 10 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("titlend", tbl))
            {
                CUtil.log.Success("TITLEEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLEEND log data NOT in FilterDB!");
            }
            sb = new StringBuilder();
            CreateTitleStartMessage(ref sb, ref machineID, ref userID);
            CUtil.log.Info("Sending " + sb.ToString() + "\n");
            cc.Send(sb.ToString());
            CUtil.log.Info("Waiting 10 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("titlend", tbl))
            {
                CUtil.log.Success("TITLEEND log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("TITLEEND log data NOT in FilterDB!");
            }
        }
    }

    // TODO: Move out of the BVT and into a "regression pass"
    [TestCase]
    public class LiveSvc_XPSERVER_DUPLICATE_TITLE_START_Log : TestBase
    {
        public void CreateTitleStartMessage(ref StringBuilder logLine, ref string machineID, ref string userID, bool useSecondTitle)
        {
            logLine.Append("TITLESTART|");
            logLine.Append(machineID);
            if (!useSecondTitle)
                logLine.Append("|4C410011|");
            else
                logLine.Append("|4C410012|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C");
        }

        public void CreateTitleEndMessage(ref StringBuilder logLine, ref string machineID, ref string userID, bool useSecondTitle)
        {
            logLine.Append("TITLEND|");
            logLine.Append(machineID);
            if (!useSecondTitle)
                logLine.Append("|4C410011|");
            else
                logLine.Append("|4C410012|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C|0");
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_DUPLICATE_TITLE_START_Log Test \n");
            CleanserConneciton cc = new CleanserConneciton(ComponentType.Presence);
            StringBuilder sb = new StringBuilder();
            Random rnd = new Random();
            Int32 session = rnd.Next(Int32.MaxValue);
            string sessionID = session.ToString("X");
            string userID;
            string machineID;
            t_presence_fact tbl = new t_presence_fact();
            UInt64 newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            userID = newInt.ToString("X");
            tbl.bi_user_puid = newInt.ToString();
            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            machineID = newInt.ToString("X");
            tbl.bi_machine_puid = newInt.ToString();

            // ?? What should this be
            tbl.dt_start = new DateRange(300, 30);
            tbl.i_duration_ms = ((Int32)0x0).ToString();
            tbl.i_title_id = ((Int32)0x4C410011).ToString();
            // tbl.bi_session_id Ignore
            tbl.bi_session_id = session.ToString();
            tbl.bi_xbox_IP = ((Int64)0x1099).ToString();
            tbl.f_playing_now = "0"; // session hasn't ended yet
            CreateTitleStartMessage(ref sb, ref machineID, ref userID, false);
            CUtil.log.Info("Sending " + sb.ToString() + "\n");
            cc.Send(sb.ToString(), true);
            sb = new StringBuilder();
            CreateTitleEndMessage(ref sb, ref machineID, ref userID, false);
            CUtil.log.Info("Sending " + sb.ToString() +"\n");
            cc.Send(sb.ToString(), true);
            CUtil.log.Info("Waiting 20 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("titlend", tbl))
            {
                CUtil.log.Success("TITLEEND log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("TITLEEND log data NOT in FilterDB!");
            }
            tbl.i_title_id = ((Int32)0x4C410012).ToString();
            sb = new StringBuilder();
            CreateTitleStartMessage(ref sb, ref machineID, ref userID, true);
            CUtil.log.Info("Sending " + sb.ToString() + "\n");
            cc.Send(sb.ToString(), true);
            sb = new StringBuilder();
            CreateTitleEndMessage(ref sb, ref machineID, ref userID, true);
            CUtil.log.Info("Sending " + sb.ToString() + "\n");
            cc.Send(sb.ToString(), false);
            CUtil.log.Info("Waiting 20 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);
            if (CUtil.VerifyFilterDB("titlend", tbl))
            {
                CUtil.log.Success("TITLEEND log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("TITLEEND log data NOT in FilterDB!");
            }
        }
    }

    // TODO: Move out of the BVT and into a "regression pass"
    [TestCase]
    class LiveSvc_STRINGSVR_MULTI_AGG_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_CL|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            banner_string = banner_string + "\n" + banner_string;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;
            string stringServer2;

            if (CUtil.CleanserSQL.Length == 1) // We are in BVTNet or on an Xblob
            {
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
                stringServer2 = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
            }
            else
            {
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
                stringServer2 = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[1];
            }

            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)banner_string.Length;
            request.logLine = banner_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            for (int i = 0; i < 100; i++)
            {
                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer2)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                // reduce the number of flushes
                if ((i % 10) == 0)
                {
                    // Guarantee Cache is flushed
                    Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");
                    Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer2, "e :stringsvr cacheflush");
                }
            }
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer2, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t_banner_fact_agg t = new t_banner_fact_agg();
            // 2 because each seperate server should get a seperate log line... (no PK violation should result.)
            t.bi_banner_counter = "2";
            t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
            t.dt_when = new DateRange(180, 180);
            t.ti_banner_type_id = "1"; // 1- click 0- view

            dbi.AddDBItem("LiveSvc_STRINGSVR_MULTI_AGG_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_MULTI_AGG_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_MULTI_AGG_Log");

            CUtil.log.Info("Verify BannerAgg message.");
            if (CUtil.VerifyFilterDB("banneragg", tbl) == true)
            {
                CUtil.log.Success("STRINGSVR_MULTI_LOG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_MULTI_LOG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }


    [TestCase]
    class LiveSvc_XBOS_XEOP_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_XEOP_Log test \n");

            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            string paymentInstrumentId = user.AddPaymentInstrumentVisa();

            XRLXeOfferPurchase request = new XRLXeOfferPurchase();

            request.UserPuid = user.UserPuid;
            request.OfferID = 0xFFFE07D180000008;   // monthly cc offer
            request.LanguageID = user.LanguageId;
            request.CountryID = user.CountryId;
            request.Tier = (byte)UodbWS.GetUserTier(user.UserPuid);
            request.PaymentType = (uint)PaymentTypeEnum.CreditCard;
            request.PaymentInstrumentID = paymentInstrumentId;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));
            Thread.Sleep(1000);

            t_purchase_fact t = new t_purchase_fact();
            t.bi_machine_puid = "0xFA00000012341234";
            t.bi_offer_id = "0xFFFE07D180000008";
            t.bi_user_puid = ((Int64)user.UserPuid).ToString();
            t.dt_when = new DateRange(180, 30);
            t.i_language_id = "1";
            t.i_payment_type_id = "1"; // credit card payment type
            t.i_price_fractional = "99";
            t.i_price_whole = "7";
            t.i_tier_id = "3"; // silver
            t.ti_country_id = "103"; // US

            dbi.AddDBItem("LiveSvc_XBOS_XEOP_Log", t);
            dbRef = dbi;
            return false;
        }

        public bool RunSecondPass() { return true; }


        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_XEOP_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XBOS_XEOP_Log");

            CUtil.log.Info("Verify XeOfferPurchase message.");
            if (CUtil.VerifyFilterDB("XEOP", tbl) == true)
            {
                CUtil.log.Success("XeOfferPurchase log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("XeOfferPurchase log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_XUACS_MIGRATEXBOX1USER_Log : UserTestBase, IReportingTest
    {
        Owner owner;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XUACS_MIGRATEXBOX1USER_Log Initial Step \n");

            // create an xbox1 user
            owner = UACS.GenerateOwner();
            if (owner.Create() == 0)
                throw new UnexpectedTestResultException("Owner.Create() failed: " + owner.GetDumpString());
            Global.RO.Info("owner 0x{0:X} created.", owner.UserPuid);

            // migrate the xbox1 user
            XRLXeMigrateXbox1User request = new XRLXeMigrateXbox1User();
            XRLXeMigrateXbox1UserResponse response = new XRLXeMigrateXbox1UserResponse();

            request.SignedUserPassportPuid = PassportUtilities.GenerateSessionToken(request.Slot.Key);
            request.SignedParentPassportPuid = request.SignedUserPassportPuid;
            request.UserPassportMemberName = "xbltest-" + Guid.NewGuid().ToString() + Global.PassportMemberDomain;

            // link the xbox1 account to the web
            ulong passportPuid = PassportUtilities.GetPuidFromSessionToken(request.SignedUserPassportPuid);
            owner.LinkToPassport(passportPuid);

            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeMigrateXbox1User failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeMigrateXbox1User returned XErr=0x{0:x}", request.XErr));

            return true;
        }

        public bool RunSecondPass() { return true; }

        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ MIGRATEXBOX1USER Final Step \n");

            CUtil.log.Info("Verify MIGRATEXBOX1USER message.");
            if (CUtil.VerifyFilterDB_XUACS_MIGRATEXBOX1USER(owner.UserPuid) ==  true)
            {
                CUtil.log.Success("MIGRATEXBOX1USER log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("MIGRATEXBOX1USER log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    // TODO: Fix me
    [TestCase]
    class LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;
        private const string CONTENT_REVENUE_SKU = "XBX-00005";
        private const uint OFFER_CAMPAIGN = 0x00ff1234;
        private const uint DMP_PURCHASES_CAMPAIGN = 0x1;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            XbosOffer.RewardUSUser4000Points(user);

            uint titleID = 0x4D2;   // used for all the tests
            ulong offerID1 = 0x4D288880000;
            ulong offerID2 = 0x4D288880001;

            XbosOffer xbosOffer1 = new XbosOffer(titleID, offerID1);
            XbosOffer xbosOffer2 = new XbosOffer(titleID, offerID2);

            ((XbosOffer.OfferRegion)xbosOffer1.OfferRegions[0]).PriceWhole = 10;
            ((XbosOffer.OfferRegion)xbosOffer2.OfferRegions[0]).PriceWhole = 10;

            xbosOffer1.CreateWithContent();
            xbosOffer2.CreateWithContent();

            // the offers are cached by Offer.CreateInstance(), have to flush them
            Global.XEnv.ExecuteXmgmtCommand(Interface.xbos_billing_offering, "e :xbos CacheFlush");

            XRLXeOfferPurchase request = new XRLXeOfferPurchase();

            request.UserPuid = user.UserPuid;
            request.OfferID = 0;
            request.OfferIDs = new ulong[2];
            request.OfferIDs[0] = offerID1;
            request.OfferIDs[1] = offerID2; // 500 Microsoft Points - online - CC ($6.25US)
            request.LanguageID = user.LanguageId;
            request.CountryID = user.CountryId;
            request.Tier = (byte)UodbWS.GetUserTier(user.UserPuid);
            request.PaymentType = (uint)PaymentTypeEnum.Points;

            if (!request.Execute())
                throw new UnexpectedTestResultException("XRLXeOfferPurchase failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));
            Thread.Sleep(1000);

            t_purchase_fact t = new t_purchase_fact();
            t.bi_machine_puid = "0xFA00000012341234";
            t.bi_offer_id = "0x4D288880000";
            t.bi_user_puid = ((Int64)user.UserPuid).ToString();
            t.dt_when = new DateRange(180, 30);
            t.i_language_id = "1";
            t.i_payment_type_id = "4";
            t.i_price_fractional = "0";
            t.i_price_whole = "10";
            t.i_tier_id = "3"; // silver
            t.ti_country_id = "103"; // US

            dbi.AddDBItem("LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log", t);

            t = new t_purchase_fact();
            t.bi_machine_puid = "0xFA00000012341234";
            t.bi_offer_id = "0x4D288880001";
            t.bi_user_puid = ((Int64)user.UserPuid).ToString();
            t.dt_when = new DateRange(180, 30);
            t.i_language_id = "1";
            t.i_payment_type_id = "4";
            t.i_price_fractional = "0";
            t.i_price_whole = "10";
            t.i_tier_id = "3"; // silver
            t.ti_country_id = "103"; // US

            dbi.AddDBItem("LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log_2", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        // Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log");

            CUtil.log.Info("Verify XeOfferPurchase message.");
            ResultCode = TEST_RESULTS.PASSED;
            if (CUtil.VerifyFilterDB("XEOP", tbl) == true)
            {
                CUtil.log.Success("1st MULTIPLEOFFERPURCHASE log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("1st MULTIPLEOFFERPURCHASE log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

            tbl = dbRef.RetrieveDBTable("LiveSvc_XBOS_MULTIPLEOFFERPURCHASE_Log_2");
            CUtil.log.Info("Verify 2nd XeOfferPurchase message.");
            if (CUtil.VerifyFilterDB("XEOP", tbl) == true)
            {
                CUtil.log.Success("2nd MULTIPLEOFFERPURCHASE log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("2nd MULTIPLEOFFERPURCHASE log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }


    [TestCase]
    class LiveSvc_STRINGSVR_FUSION_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_FUSION_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //FU|TITLEID|ERRORCODE~PUID|TIMESTAMP
            string fusion_string = "FU|FFFF0004|0~" + ((Int64)user.UserPuid).ToString("X") + "|" + "1C6BFEA53A160FD";

            //Grab a server
            string stringServer;

            //if (CUtil.CleanserSQL.Length == 1) // We are in BVTNet or on an Xblob
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
            //else
            //    stringServer = "xepooliis009";

            // Send string
            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)fusion_string.Length;
            request.logLine = fusion_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

            // Guarantee Cache is flushed to cleanser
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t_fusion_fact t = new t_fusion_fact();
            t.bi_user_puid = ((Int64)user.UserPuid).ToString(); // TODO: int64 ToString() this
            t.dt_when = new DateRange(180, 30);
            t.i_hresult = "0"; // HResult.S_OK.ToString();
            t.i_title_id = "0xFFFF0004";

            dbi.AddDBItem("LiveSvc_STRINGSVR_FUSION_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_FUSION_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_FUSION_Log");

            CUtil.log.Info("Verify Fusion message.");
            if (CUtil.VerifyFilterDB("fusion", tbl) == true)
            {
                CUtil.log.Success("STRINGSVR_FUSION log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_FUSION log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_CLICK_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            t_banner_fact t = null;
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_CL|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            //if (CUtil.CleanserSQL.Length == 1) // We are in BVTNet or on an Xblob
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
            //else
                //stringServer = "xepooliis009";

            try
            {
                // Set NPDB to aggregate
                Global.XEnv.OverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", "TESTING", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");

                XRLLogString request = new XRLLogString();
                request.logLinesLength = (ushort)banner_string.Length;
                request.logLine = banner_string;
                CUtil.log.Info("Sending String:" + request.logLine);
                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                // Guarantee Cache is flushed
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");
                //Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh*");

                Thread.Sleep(1000);

                t = new t_banner_fact();
                t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
                t.bi_user_puid = ((Int64)user.UserPuid).ToString();
                t.dt_when = new DateRange(180, 30);
                t.i_sequence_number = sequence_number;
                t.ti_banner_type_id = "1"; // 1- click 0- view
            }
            finally
            {
                // Set NPDB to aggregate
                Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");
            }

            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_CLICK_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_CLICK_Log");

            CUtil.log.Info("Verify Banner message.");
            if (CUtil.VerifyFilterDB("banner", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_VIEW_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            t_banner_fact t;
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_VIEW_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_VW|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            //if (CUtil.CleanserSQL.Length == 1) // We are in BVTNet or on an Xblob
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
            //else
                //stringServer = "xepooliis009";

            try
            {
                // Set NPDB to not aggregate
                Global.XEnv.OverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", "TESTING", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");


                XRLLogString request = new XRLLogString();
                request.logLinesLength = (ushort)banner_string.Length;
                request.logLine = banner_string;
                CUtil.log.Info("Sending String:" + request.logLine);
                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                // Guarantee Cache is flushed
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

                Thread.Sleep(1000);

                t = new t_banner_fact();
                t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
                t.bi_user_puid = ((Int64)user.UserPuid).ToString();
                t.dt_when = new DateRange(180, 30);
                t.i_sequence_number = sequence_number;
                t.ti_banner_type_id = "0"; // 1- click 0- view
            }
            finally
            {
                // Set NPDB to aggregate
                Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");
            }
            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_VIEW_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_VIEW_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_VIEW_Log");

            CUtil.log.Info("Verify Banner message.");
            if (CUtil.VerifyFilterDB("banner", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_VIEW_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            t_banner_fact t = null;
            t_banner_fact t2 = null;
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_VW|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            banner_string = banner_string + "\n" + "BAN_CL|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            //Grab a server
            string stringServer;

            //if (CUtil.CleanserSQL.Length == 1) // We are in BVTNet or on an Xblob
                stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];
            //else
              //  stringServer = "xepooliis009";

            try
            {
                // Set NPDB to not aggregate
                Global.XEnv.OverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", "TESTING", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");


                XRLLogString request = new XRLLogString();
                request.logLinesLength = (ushort)banner_string.Length;
                request.logLine = banner_string;
                CUtil.log.Info("Sending String:" + request.logLine);
                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                // Guarantee Cache is flushed
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

                Thread.Sleep(1000);

                t = new t_banner_fact();
                t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
                t.bi_user_puid = ((Int64)user.UserPuid).ToString();
                t.dt_when = new DateRange(180, 30);
                t.i_sequence_number = sequence_number;
                t.ti_banner_type_id = "0"; // 1- click 0- view

                // Fix me - add second table here
                t2 = new t_banner_fact();
                t2.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
                t2.bi_user_puid = ((Int64)user.UserPuid).ToString();
                t2.dt_when = new DateRange(180, 30);
                t2.i_sequence_number = sequence_number;
                t2.ti_banner_type_id = "1"; // 1- click 0- view

            }
            finally
            {
                // Set NPDB to aggregate
                Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");
            }
            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log", t);
            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log_2", t2);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log");

            CUtil.log.Info("Verify Banner message.");
            ResultCode = TEST_RESULTS.PASSED;
            if (CUtil.VerifyFilterDB("banner", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

            t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_CLICK_AND_VIEW_Log_2");

            if (CUtil.VerifyFilterDB("banner", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER 2 log data found in FilterDB.");
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER 2 log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }


    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log Intial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_CL|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            banner_string = banner_string + "\n" + banner_string;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];

            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)banner_string.Length;
            request.logLine = banner_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

            // Guarantee Cache is flushed
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t_banner_fact_agg t = new t_banner_fact_agg();
            t.bi_banner_counter = "2";
            t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
            t.dt_when = new DateRange(180, 30);
            t.ti_banner_type_id = "1"; // 1- click 0- view

            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_CLICK_AGG_Log");

            CUtil.log.Info("Verify BannerAgg message.");
            if (CUtil.VerifyFilterDB("banneragg", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER_AGG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER_AGG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string sequence_number = "0";
            string banner_string = "BAN_VW|" + banner_hash + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X") + "|" + sequence_number;

            banner_string = banner_string + "\n" + banner_string;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];

            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)banner_string.Length;
            request.logLine = banner_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

            // Guarantee Cache is flushed
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t_banner_fact_agg t = new t_banner_fact_agg();
            t.bi_banner_counter = "2";
            t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
            t.dt_when = new DateRange(180, 30);
            t.ti_banner_type_id = "0"; // 1- click 0- view

            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_VIEW_AGG_Log");

            CUtil.log.Info("Verify BannerAgg message.");
            if (CUtil.VerifyFilterDB("banneragg", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER_AGG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER_AGG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_PURCHASE_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_PURCHASE_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string offer_id = "FFFE07D18000001B";
            string banner_string = "MP_P|" + banner_hash + "|" + offer_id + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X");

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];

            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)banner_string.Length;
            request.logLine = banner_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

            // Guarantee Cache is flushed
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t_banner_purchase_fact t = new t_banner_purchase_fact();
            t.bi_user_puid = ((Int64)user.UserPuid).ToString();
            t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
            t.dt_when = new DateRange(180, 30);
            t.bi_offer_id = "0x" + offer_id; // 1- click 0- view

            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_PURCHASE_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_PURCHASE_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_PURCHASE_Log");

            CUtil.log.Info("Verify BannerAgg message.");
            if (CUtil.VerifyFilterDB("bannerpurchase", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER_AGG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER_AGG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }

        }
    }


    [TestCase]
    class LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            t_banner_purchase_fact_agg t = null;
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string banner_hash = "001B921B594DF660";
            string offer_id = "FFFE07D18000001B";
            string banner_string = "MP_P|" + banner_hash + "|" + offer_id + "~" + ((Int64)user.UserPuid).ToString("X") + "|"
                + ((Int64)DateTime.Now.Ticks).ToString("X");

            banner_string = banner_string + "\n" + banner_string;

            //banner_string = ;
            // View    : "BAN_VW|F213421180449836~9000000146A29|1C6BFEDF3B05EF0|0";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Click   : "BAN_CL|001B921B594DF660~9000000146A29|1C6BFEDFA598A60|2";
            //                   BANNERHASH      |PUID         |TIMESTAMP      |SEQUENCE NUMBER
            // Purchase: "MP_P|001B921B594DF660|FFFE07D18000001B~9000000146A29|1C6BFEDFA598A60";
            //                 BANNERHASH      |OFFER ID        |PUID         |TIMESTAMP

            //Grab a server
            string stringServer;

            stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];

            try
            {
                // Set NPDB to aggregate
                Global.XEnv.OverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", "MP_P", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");

                XRLLogString request = new XRLLogString();
                request.logLinesLength = (ushort)banner_string.Length;
                request.logLine = banner_string;
                CUtil.log.Info("Sending String:" + request.logLine);
                if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                    throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());

                // Guarantee Cache is flushed
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

                Thread.Sleep(1000);

                t = new t_banner_purchase_fact_agg();
                t.bi_banner_counter = "2";
                t.bi_hash_path = ((Int64)0x001B921B594DF660).ToString();
                t.dt_when = new DateRange(180, 30);
                t.bi_offer_id = "0x" + offer_id; // 1- click 0- view

            }
            finally
            {
                // Set NPDB to aggregate
                Global.XEnv.DeleteOverrideSetting("ALL", "ALL", "stringsvr_reportingAggregateKeys", -1);
                Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr configcacherefresh");
            }
            dbi.AddDBItem("LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_BANNER_PURCHASE_AGG_Log");

            CUtil.log.Info("Verify BannerAgg message.");
            if (CUtil.VerifyFilterDB("bannerpurchaseagg", t) == true)
            {
                CUtil.log.Success("STRINGSVR_BANNER_AGG log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("STRINGSVR_BANNER_AGG log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    [TestCase]
    class LiveSvc_XBOS_CONTENTREFERRAL_GEODENIAL_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;
        private static string[] _xrls = new string[1];
        private static string[] _xrls2 = new string[2];
        private static string CONTENT_XRL1 = "http://www.example.com/2D5A7D4100000001/downloadme1.xui";
        private static string CONTENT_XRL2 = "http://www.example.com/2D5A7D4100000001/downloadme2.xui";
        private static byte[] _symKey;
        private static byte[] _publicKey;
        private static byte[] _contentId;
        private static uint TITLE_ID = 0x2D5A7D41;   // used for all the tests
        private static ulong OFFER_ID = 0x2D5A7D4100000001;
        private static int _installSize = 2000;
        private static int _packageSize = 1000;
        private static int CONTENT_REVENUE_SKU_ID = 5001; // using test SKU
        private static int OFFER_CAMPAIGN = 55; // using test Campaign

        public static uint IPAddressToUInt(IPAddress ipAddress)
        {
            // the .net framework frowns on treating ip addresses as uint, and therefore
            // no longer provides an easy way to do it.
            byte[] bytes = ipAddress.GetAddressBytes();
            if (bytes.Length != 4)
            {
                throw new Exception("IPAddress not 4 bytes in length");
            }
            return (uint)((bytes[3] << 24) + (bytes[2] << 16) + (bytes[1] << 8) + bytes[0]);
        }

        private static void AddContentReferralItem(string[] xrls, int priceWhole, ref byte[] contentId, ref byte[] symKey, ref byte[] publicKey, int policyFlag)
        {
            Random r = new Random((int)DateTime.UtcNow.Ticks);
            byte[] content_id = new byte[20];
            byte[] sym_key = new byte[16];
            byte[] public_key = new byte[284];
            r.NextBytes(content_id);
            r.NextBytes(sym_key);
            r.NextBytes(public_key);

            ContentOfferLoader.CleanOffers(OFFER_ID);
            ContentOfferLoader.CleanTitle(TITLE_ID);
            ContentOfferLoader.InsertTitle(TITLE_ID);
            ContentOfferLoader.InsertTitleRating(TITLE_ID, 0, 1);
            ContentOfferLoader.InsertTitleCultureDetails(TITLE_ID,
                1033,
                "ContentReferral Test Title",
                "Sell text goes here.",
                "Microsoft",
                "reinouth",
                "TestGenre");

            ContentOfferLoader.AddContent(content_id,
                _installSize,
                _packageSize,
                sym_key,
                public_key);

            for (int i = 0; i < xrls.Length; i++)
            {
                Global.RO.Info("Adding XRL: " + xrls[i]);
                ContentOfferLoader.AddContentLocations(content_id,
                    i + 1,
                    xrls[i]);
            }

            ContentOfferLoader.AddOffer(TITLE_ID,
                OFFER_ID,
                _packageSize,
                _installSize,
                1,
                (int)OfferingTypeEnum.GameTrailer,
                "Test offer for testing XeContentReferral",
                true,
                content_id, policyFlag, 0);
            ContentOfferLoader.AddOfferCultureDetails(
                OFFER_ID,
                1033,
                "Testoffer - XeContentReferral",
                "Sell text goes here");
            ContentOfferLoader.AddOfferRegion(
                OFFER_ID,
                103,
                3,
                (int)PaymentTypeEnum.Points,
                DateTime.UtcNow.AddYears(-1),
                DateTime.UtcNow.AddYears(1),
                "",
                priceWhole,
                0,
                0);

            ContentOfferLoader.AddOfferSku((int)CONTENT_REVENUE_SKU_ID, OfferingSKUType.RevenueSKU, "XBX-00005", "Test SKU");
            ContentOfferLoader.AddOfferCampaign((int)OFFER_CAMPAIGN, "Test campaign");
            ContentOfferLoader.AddDmpOfferDetails(OFFER_ID, CONTENT_REVENUE_SKU_ID, 2, OFFER_CAMPAIGN);

            contentId = content_id;
            symKey = sym_key;
            publicKey = public_key;
        }

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_CONTENTREFERRAL_GEODENIAL_Log Initial Step \n");
            t_geofence_rejection_fact t = new t_geofence_rejection_fact();

            _xrls[0] = CONTENT_XRL1;
            _xrls2[0] = CONTENT_XRL1;
            _xrls2[1] = CONTENT_XRL2;
            // Shamelessly taken from the Xbos tests...
            // one Xrl location
            AddContentReferralItem(_xrls, 10, ref _contentId, ref _symKey, ref _publicKey,
                (int)OfferPolicies.PerMachineRights | (int)OfferPolicies.RequiresGeoFencing);
            // silver user
            XeUser user = XbosUser.XenonSilverUser();
            user.AddPoints_500();
            // use XeOfferPurchase API
            XbosOffer.OfferPurchase(OFFER_ID, user);

            XRLXeContentReferral request = new XRLXeContentReferral();
            XRLXeContentReferralResponse response = new XRLXeContentReferralResponse();

            request.ContentId = _contentId;
            request.UserId = user.UserPuid;
            request.ManualPopulateSlot();
            request.Slot.ipaI = IPAddressToUInt(IPAddress.Parse("211.189.14.230")); // South Korea

            if (request.Execute(out response))
                throw new UnexpectedTestResultException("Expected XRLXeContentReferral to fail");
            if (request.XErr != HResult.XONLINE_E_GEO_DENIED)
                throw new UnexpectedTestResultException(String.Format("XRLXeContentReferral returned XErr=0x{0:x}, expected XONLINE_E_GEO_DENIED", request.XErr));

            // END shamelessly taken from the xbos tests...
            t.bi_current_machine_puid = ((Int64)user.MachinePuid).ToString();
            t.bi_current_user_puid = ((Int64)user.UserPuid).ToString();
            t.bi_offer_id = OFFER_ID.ToString();
            t.dt_when = new DateRange(30,180);
            t.i_videotype = "0";
            t.ui_wmid = "";
            t.vc_countrycode = "KR";
            t.vc_featurearea = "GeoFenceContentReferral";
            t.vc_ip_address = "211.189.14.230";
            t.vc_reasoncode = "Fenced";

            dbi.AddDBItem("LiveSvc_XBOS_CONTENTREFERRAL_GEODENIAL_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_CONTENTREFERRAL_GEODENIAL_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_XBOS_CONTENTREFERRAL_GEODENIAL_Log");

            if (CUtil.VerifyFilterDB("geodenial", t) == true)
            {
                CUtil.log.Success("Denial log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("Denial log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }
    [TestCase]
    class LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;
        private static uint TITLE_ID = 0x2D5A7D41;   // used for all the tests
        private static int CONTENT_REVENUE_SKU_ID = 5001; // using test SKU
        private static int OFFER_CAMPAIGN = 55; // using test Campaign
        private const string CONTENT_REVENUE_SKU = "XBX-00005";
        private const uint DMP_PURCHASES_CAMPAIGN = 0x1;

        public static uint IPAddressToUInt(IPAddress ipAddress)
        {
            // the .net framework frowns on treating ip addresses as uint, and therefore
            // no longer provides an easy way to do it.
            byte[] bytes = ipAddress.GetAddressBytes();
            if (bytes.Length != 4)
            {
                throw new Exception("IPAddress not 4 bytes in length");
            }
            return (uint)((bytes[3] << 24) + (bytes[2] << 16) + (bytes[1] << 8) + bytes[0]);
        }

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log Initial Step \n");


            //Build table and verify
            t_geofence_rejection_fact t = new t_geofence_rejection_fact();

            // Shamelessly taken from the Xbos tests...
            Global.RO.Info("Creating the german user...");
            XeUser user = XbosUser.XenonGoldUser((XeUser.Country)24, false);
            Global.RO.Info("Giving the user some points...");
            user.AddPoints_500();

            ulong game_demo_offer_id = ((ulong)TITLE_ID << 32) + (ulong)RandGen.Next(1, int.MaxValue);

            Global.RO.Info("Cleaning up any title and offer details...");
            ContentOfferLoader.CleanOffers(game_demo_offer_id);
            ContentOfferLoader.CleanTitle(TITLE_ID);
            Global.RO.Info("Inserting the title...");
            ContentOfferLoader.InsertTitle(TITLE_ID);
            Global.RO.Info("Inserting the german title culture details...");
            ContentOfferLoader.InsertTitleCultureDetails(TITLE_ID, 1031, "German Test title for P_Purchase_GameDemo()", "Test title for P_Purchase_GameDemo()", "Microsoft", "reinouth", "Testing");
            Global.RO.Info("Inserting the title rating...");
            ContentOfferLoader.InsertTitleRating(TITLE_ID, 0, 4); // ESRB - T (Teen) (i_rank = 6)
            Global.RO.Info("Inserting the game demo...");
            ContentOfferLoader.AddOffer(TITLE_ID, game_demo_offer_id, 100, 200, 0x1, (int)OfferingTypeEnum.GameDemo, "Test demo content for P_Purchase_GameDemo()", true,
                null, (int)OfferPolicies.PerMachineRights | (int)OfferPolicies.RequiresGeoFencing, 0);
            Global.RO.Info("Inserting the game demo region...");
            ContentOfferLoader.AddOfferRegion(game_demo_offer_id, 24, 6, (int)PaymentTypeEnum.Points, DateTime.UtcNow.AddYears(-1), DateTime.UtcNow.AddYears(+1), "", 10, 0, 0);
            Global.RO.Info("Inserting the german game demo culture details...");
            ContentOfferLoader.AddOfferCultureDetails(game_demo_offer_id, 1031, "German Test demo content for P_Purchase_GameDemo()", "Test demo content for P_Purchase_GameDemo()");
            Global.RO.Info("Inserting SKU...");
            ContentOfferLoader.AddOfferSku((int)CONTENT_REVENUE_SKU_ID, OfferingSKUType.RevenueSKU, CONTENT_REVENUE_SKU, "Test SKU");
            Global.RO.Info("Inserting the test campaign...");
            ContentOfferLoader.AddOfferCampaign((int)OFFER_CAMPAIGN, "Test campaign");
            Global.RO.Info("Inserting the DMP Offer Details...");
            ContentOfferLoader.AddDmpOfferDetails(game_demo_offer_id, (int)CONTENT_REVENUE_SKU_ID, 2, (int)OFFER_CAMPAIGN);

            XRLXeOfferPurchase purchase_request = new XRLXeOfferPurchase();
            purchase_request.UserPuid = user.UserPuid;
            purchase_request.Tier = 6;
            purchase_request.OfferID = game_demo_offer_id;
            purchase_request.CountryID = 24;
            purchase_request.ManualPopulateSlot();
            purchase_request.Slot.ipaI = IPAddressToUInt(IPAddress.Parse("211.189.14.230")); // South Korea

            Global.RO.Info("Purchasing the game demo...");
            if (purchase_request.Execute())
                throw new UnexpectedTestResultException("Expected XRLXeOfferPurchase() to fail.");
            if (purchase_request.XErr != HResult.XONLINE_E_GEO_DENIED)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchase returned XErr=0x{0:x} instead of HResult.XONLINE_E_GEO_DENIED", purchase_request.XErr));

            Global.RO.Info("Cleaning up...");
            ContentOfferLoader.CleanOffers(game_demo_offer_id);
            ContentOfferLoader.CleanTitle(TITLE_ID);
            // END - Shamelessly taken from the Xbos tests...
            t.bi_current_machine_puid = ((Int64)user.MachinePuid).ToString();
            t.bi_current_user_puid = ((Int64)user.UserPuid).ToString();
            t.bi_offer_id = game_demo_offer_id.ToString();
            t.dt_when = new DateRange(30, 180);
            t.i_videotype = "0";
            t.ui_wmid = "";
            t.vc_countrycode = "KR";
            t.vc_featurearea = "GeoFenceOfferPurchase";
            t.vc_ip_address = "211.189.14.230";
            t.vc_reasoncode = "Fenced";

            dbi.AddDBItem("LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_XBOS_OFFERPURCHASE_GEODENIAL_Log");

            if (CUtil.VerifyFilterDB("geodenial", t) == true)
            {
                CUtil.log.Success("Denial log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("Denial log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }
    }

    // String servers
    // DHW|<machine_puid>|<MSGDATA_ASCIITEXT>
    [TestCase]
    class LiveSvc_STRINGSVR_HARDWAREINFO_Log : UserTestBase, IReportingTest
    {
        DBInformation dbRef;

        public bool RunInitialStep(DBInformation dbi)
        {
            t_argon_fact t = null;
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_HARDWAREINFO_Log Initial Step \n");
            // Create SILVER user
            XeUser user = new XeUser(true);
            user.Create();
            if (user.UserPuid == 0)
                throw new UnexpectedTestResultException("User.Create() failed: " + user.GetDumpString());
            CUtil.log.Info("Created SILVER user " + user.UserPuid.ToString() + " (" +
                user.UserPuid.ToString("X") + ")");

            //Formulate string
            string hw_string = "DHW|" + ((Int64)user.MachinePuid).ToString("X") + "|"
                + "CDCEEFAB3189671309679087DEDCA9247639845762947629ACDDBBBBAAAEECCCDCEEFAB3189671309679087DEDCA92476398457629";

            //Grab a server
            string stringServer = Global.XEnv.GetServerListByInterface(xonline.common.config.Interface.stringsvr)[0];

            XRLLogString request = new XRLLogString();
            request.logLinesLength = (ushort)hw_string.Length;
            request.logLine = hw_string;
            CUtil.log.Info("Sending String:" + request.logLine);
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString first execute failed: " + request.GetDumpString());
            if (!request.Execute(Global.XEnv.GetInterface(Interface.stringsvr, stringServer)))
                throw new UnexpectedTestResultException("XRLLogString second execute failed: " + request.GetDumpString());

            // Guarantee Cache is flushed
            Global.XEnv.ExecuteXmgmtCommandOneServer(stringServer, "e :stringsvr cacheflush");

            Thread.Sleep(1000);

            t = new t_argon_fact();
            t.bi_machine_puid = ((Int64)user.MachinePuid).ToString();
            t.dt_when = new DateRange(180, 30);
            t.i_sequence_num = "0";
            t.vc_argon_data = "CDCEEFAB3189671309679087DEDCA9247639845762947629ACDDBBBBAAAEECCCDCEEFAB3189671309679087DEDCA92476398457629";
            dbi.AddDBItem("LiveSvc_STRINGSVR_HARDWAREINFO_Log", t);

            // This code cannot guarantee a sequence # is generated
            //t = new t_argon_fact();
            //t.bi_machine_puid = ((Int64)user.MachinePuid).ToString();
            //t.dt_when = new DateRange(180, 30);
            //t.i_sequence_num = "1";
            //t.vc_argon_data = "CDCEEFAB3189671309679087DEDCA9247639845762947629ACDDBBBBAAAEECCCDCEEFAB3189671309679087DEDCA92476398457629";

            //dbi.AddDBItem("LiveSvc_STRINGSVR_HARDWAREINFO_Log_2", t);
            dbRef = dbi;
            return true;
        }

        public bool RunSecondPass() { return true; }

        //Done
        override protected void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_STRINGSVR_HARDWAREINFO_Log Final Step \n");

            FilterDBTable t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_HARDWAREINFO_Log");

            CUtil.log.Info("Verify Hardware message.");
            if (CUtil.VerifyFilterDB("argon", t) == true)
            {
                CUtil.log.Success("Hardware Info log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("Hardware Info log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
            // See above comment
            //t = dbRef.RetrieveDBTable("LiveSvc_STRINGSVR_HARDWAREINFO_Log_2");
            //CUtil.log.Info("Verify 2nd Hardware message.");
            //if (CUtil.VerifyFilterDB("argon", t) == true)
            //{
            //    CUtil.log.Success("Hardware Info log data found in FilterDB.");
            //    ResultCode = TEST_RESULTS.PASSED;
            //}
            //else
            //{
            //    CUtil.log.Error("Hardware Info log data NOT in FilterDB!");
            //    ResultCode = TEST_RESULTS.FAILED;
            //}
        }
    }

    [TestCase]
    public class LiveSvc_XPSERVER_HEXIC_IGNORE_Log : TestBase
    {

        public void CreateTitleStartMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string titleID)
        {
            logLine.Append("TITLESTART|");
            logLine.Append(machineID);
            logLine.Append("|");
            logLine.Append(titleID);
            logLine.Append("|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C");
        }

        public void CreateTitleEndMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string titleID)
        {
            logLine.Append("TITLEND|");
            logLine.Append(machineID);
            logLine.Append("|");
            logLine.Append(titleID);
            logLine.Append("|");
            logLine.Append(userID);
            logLine.Append("|200|1099|1021|20C|0");
        }


        // Stripped from stress code
        public void CreateSessionStartMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string sessionID, ref string titleID)
        {
            logLine.Append("SESSTART|");
            logLine.Append(machineID);
            logLine.Append("|");
            logLine.Append(titleID);
            logLine.Append("|");
            logLine.Append(userID);
            logLine.Append("|200|");
            logLine.Append(sessionID);
        }

        public void CreateSessionEndMessage(ref StringBuilder logLine, ref string machineID, ref string userID, ref string sessionID, ref string titleID)
        {
            logLine.Append("SESEND|");
            logLine.Append(machineID);
            logLine.Append("|");
            logLine.Append(titleID);
            logLine.Append("|");
            logLine.Append(userID);
            logLine.Append("|200|");
            logLine.Append(sessionID);
            logLine.Append("|EA60");
        }

        protected override void Execute()
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_XPSERVER_HEXIC_IGNORE_Log Test \n");

            CleanserConneciton cc = new CleanserConneciton(ComponentType.Presence);
            StringBuilder sb = new StringBuilder();
            Random rnd = new Random();
            Int32 session = rnd.Next(Int32.MaxValue);
            string sessionID = session.ToString("X");
            string userID;
            string machineID;
            string TitleID;
            t_session_fact tbl = new t_session_fact();
            UInt64 newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            userID = newInt.ToString("X");
            tbl.bi_user_puid = newInt.ToString();
            newInt = (UInt64)rnd.Next(Int32.MaxValue);
            newInt = newInt >> 32;
            newInt += (UInt64)rnd.Next(Int32.MaxValue);
            machineID = newInt.ToString("X");
            tbl.bi_machine_puid = newInt.ToString();
            tbl.bi_session_id = session.ToString();
            tbl.dt_start = new DateRange(90, 0);
            tbl.i_duration_ms = ((Int32)0xEA60).ToString();
            tbl.i_title_id = ((Int32)0x584107D1).ToString();
            TitleID = ((Int32)0x584107D1).ToString("X");

            // TODO: Create title start and title end messages
            // Just to be sure
            //t_presence_fact pres_tbl = new t_presence_fact();
            //pres_tbl.bi_machine_puid = ((Int64)machineID).ToString(); // machine puid
            //// tbl.bi_session_id Ignore
            //pres_tbl.bi_user_puid = userID;
            //pres_tbl.bi_xbox_IP = ((Int64)200).ToString();
            //pres_tbl.dt_start = new DateRange(360, 240);
            //pres_tbl.f_playing_now = "1"; // session hasn't ended yet
            //dtNow = DateTime.UtcNow;
            //// Total number of milliseconds in a day
            //OneDayMs = 24 * 60 * 60 * 1000;
            //// Total number of milliseconds today
            //tsMs = new TimeSpan(0, dtNow.Hour, dtNow.Minute, dtNow.Second, dtNow.Millisecond);
            //todayMs = (int)tsMs.TotalMilliseconds;
            //// Remaining milliseconds until midnight
            //diffMs = OneDayMs - todayMs;
            //pres_tbl.i_duration_ms = diffMs.ToString();
            //pres_tbl.i_title_id = ((Int32)0x584107D1).ToString();

            CreateSessionStartMessage(ref sb, ref machineID, ref userID, ref sessionID, ref TitleID);
            cc.Send(sb.ToString());
            sb = new StringBuilder();
            CreateSessionEndMessage(ref sb, ref machineID, ref userID, ref sessionID, ref TitleID);
            cc.Send(sb.ToString());

            CUtil.log.Info("Waiting 20 seconds on filter DB");
            System.Threading.Thread.Sleep(20000);

            ResultCode = TEST_RESULTS.PASSED;
            if (!CUtil.VerifyFilterDB("sesstart", tbl))
            {
                CUtil.log.Success("SESEND log data not found in FilterDB.");
            }
            else
            {
                ResultCode = TEST_RESULTS.FAILED;
                CUtil.log.Error("SESEND log data in FilterDB!");
            }
            if (!CUtil.VerifyFilterDB("sesend", tbl))
            {
                CUtil.log.Success("SESEND log data found in FilterDB.");
            }
            else
            {
                ResultCode = TEST_RESULTS.FAILED;
                CUtil.log.Error("SESEND log data in FilterDB!");
            }
            // TODO: cc.Close() // explicitly close the connections
        }
    }

    [TestCase]
    public class LiveSvc_acquirelicense_Log : TestBase//, IReportingTest
    {
        private static Utils.MediaMatrix matrix = new Utils.MediaMatrix();
        DBInformation dbRef;

        private static List<Utils.MediaInformation> PPVOffers;
        private static List<Utils.MediaInformation> DTOOffers;

        protected override void Execute ()
        {
            bool bRet;

            bRet = RunInitialStep(DBInformation.Instance);

            if(bRet == false)
            {
                CUtil.log.Error("\n\n LiveSvc_acquirelicense_Log.RunInitialStep() failed: ");
                //return;
            }

            CUtil.log.Debug("\n\n+++ LiveSvc_acquirelicense_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_acquirelicense_Log");

            // Verify PurchaseOffer log data
            CUtil.log.Info("Verify LiveSvc_acquirelicense_Log message.");
            if (CUtil.VerifyFilterDB("acquirelicense",tbl) ==  true)
            {
                CUtil.log.Success("LiveSvc_acquirelicense_Log log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("LiveSvc_acquirelicense_Log log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        public bool RunInitialStep(DBInformation dbi)
        {
            bool bReturn = true;

            CUtil.log.Debug("\n\n+++ LiveSvc_acquirelicense_Log Initial Step \n");

            live.common.Config.SetConfig(new live.common.STFConfig());
            PPVOffers = new List<Utils.MediaInformation>();
            DTOOffers = new List<Utils.MediaInformation>();

            // These values are dummies so that we can call into PopulateOfferTable
            Xbox360Client client = Utils.CreateMachine();
            //Utils.CreateUser(client, live.common.XblUserTier.Gold, live.common.PassportType.Real);

            // Runs a query against the EMS database to get some offer info for later purchase
            try
            {
                matrix.PopulateOfferTable();
                //Utils.PopulateOfferTable(client, PPVOffers, DTOOffers);
            }
            catch (Exception e)
            {
                bReturn = false;
                CUtil.log.Warn("Exception on Utils.PopulateOfferTable:" + e.ToString());
            }

//
            //Xbox360Client client = Utils.CreateMachine();
            live.common.XblUser user = Utils.CreateUser(client, live.common.XblUserTier.Gold, live.common.PassportType.Real);
            CUtil.log.Info("User created PUID: " + user.Puid + " | Machine PUID: " + client.MachinePuid);

            client.UserLoggingOn(user);

            if (Utils.AddPoints5000(client, user))
            {
                uint numRequested = 1;
                List<Utils.MediaInformation> myMedia = matrix.GetOffers(Utils.VIDEOOFFERTYPE.EMS_PPV, numRequested);
                if (myMedia == null || myMedia.Count != numRequested)
                {
                    bReturn = false;
                    CUtil.log.Warn("GetOffers did not return the requested number of offers. Requested: " + numRequested +
                                        " Received: " + ((myMedia == null) ? 0 : myMedia.Count));

                    //throw new Exception("GetOfferInfo did not return the requested number of offers. Requested: " + numRequested +
                        //                " Received: " + ((myMedia == null) ? 0 : myMedia.Count));
                }

                // Setup the purchase call
                Guid[] offerGuids = new Guid[1];
                uint[] offerPrices = new uint[1];

                // Acknowledge Data
                MediaInstanceIdOfferIdPair[] mediaIds = new MediaInstanceIdOfferIdPair[myMedia.Count];

                for (int i = 0; i < numRequested; i++)
                {
                    // Build the Acquire data
                    offerGuids[i] = myMedia[i].offerId;
                    offerPrices[i] = myMedia[i].pointsPrice;

                    // Build the Acknowledge Data
                    mediaIds[i] = new MediaInstanceIdOfferIdPair();
                    mediaIds[i].miid = myMedia[i].mediaInstanceId;
                    mediaIds[i].oid = myMedia[i].offerId;
                }


                for (int i = 0; i < offerGuids.Length; i++)
                {
                    CUtil.log.Info("Purchasing Offer: " + offerGuids[i] + " | Cost: " + offerPrices[i]);
                }

                uint hr = live.server.next.Billing.PurchaseOffersXrl(client,
                                                                            user,
                                                                            offerGuids,
                                                                            offerPrices,
                                                                            live.common.PaymentTypeEnum.Points,
                                                                            "");
                if (hr != 0)
                {
                    bReturn = false;
                    CUtil.log.Warn(String.Format("Purchase Failed with {0}", hr));
                    for (int i = 0; i < offerGuids.Length; i++)
                    {
                        CUtil.log.Warn("OfferId: " + offerGuids[i] + " | Price: " + offerPrices[i]);
                    }
                    throw new Exception("Offer purchase failed. There is no way the AcquireMediaLicenses call can pass without the purchase.");
                }
                else
                {
                    CUtil.log.Info("Purchase succeeded");
                }

                AcquireMediaLicensesResponse response = Signature.AcquireMediaLicenses(client, user, mediaIds);

                // TODO: Verify the resonse
                if (!Utils.VerifyLicenseResponse(response, new uint[] { 0 }, mediaIds))
                {
                    bReturn = false;
                    CUtil.log.Warn(String.Format("VerifyLicenseResponse Failed"));
                }

/*
                AcknowledgeLicensesDeliveryResponse ackResponse = Signature.AcknowledgeLicensesDelivery(client, user, mediaIds);

                if (!Utils.VerifyAckResponse(ackResponse, new uint[] { 0 }))
                {
                    bReturn = false;
                    CUtil.log.Warn(String.Format("VerifyAckResponse Failed"));
                }

                response = Signature.AcquireMediaLicenses(client, user, mediaIds);
*/
            }
            else
            {
                bReturn = false;
                CUtil.log.Warn(String.Format("AddPoints5000 failed. "));
            }

            t_acquirelicense_fact tbl = new t_acquirelicense_fact();
            tbl.dt_when = new DateRange(180, 30);
            //tbl.bi_machine_puid = owner.machinePuid.ToString(); // machineID
            tbl.bi_user_puid = ((Int64)user.Puid).ToString();    // UserPuid

            dbi.AddDBItem("LiveSvc_acquirelicense_Log", tbl);
            dbRef = dbi;


            return bReturn;
        }

/*        private static List<Utils.MediaInformation> GetOfferInfo ( Utils.VIDEOOFFERTYPE _videoType, uint _count )
        {
            List<Utils.MediaInformation> offers = new List<Utils.MediaInformation>();
            switch (_videoType)
            {
                case Utils.VIDEOOFFERTYPE.VIDEO_PPV:
                    if (_count > PPVOffers.Count)
                    {
                        return null;
                    }
                    for (int i = 0; i < _count; i++)
                    {
                        Utils.MediaInformation temp = new Utils.MediaInformation();

                        temp = PPVOffers[i];
                        offers.Add(temp);
                    }
                    break;
                case Utils.VIDEOOFFERTYPE.VIDEO_DTO:
                    if (_count > DTOOffers.Count)
                    {
                        return null;
                    }
                    for (int i = 0; i < _count; i++)
                    {
                        Utils.MediaInformation temp = new Utils.MediaInformation();

                        temp = DTOOffers[i];
                        offers.Add(temp);
                    }
                    break;
            };
            return offers;
        }

*/
        public class Utils
        {
            public enum VIDEOOFFERTYPE
            {
                EMS_DTO = 0,
                EMS_PPV,
                EMS_SEASON,
                SYNCCAST_DTO,
                SYNCCAST_PPV
            }

            public class MediaMatrix
            {
                // SyncCast Offers
                public List<MediaInformation> SyncCast_DTO_Offers;
                public List<MediaInformation> SyncCast_PPV_Offers;

                // EMS Offers
                public List<MediaInformation> EMS_DTO_Offers;
                public List<MediaInformation> EMS_PPV_Offers;
                public List<MediaInformation> EMS_Season_Offers;

                public MediaInformation HD_Get_SD_Offer;
                public MediaInformation SD_NoGet_HD_Offer;

                public MediaInformation EMS_TVEpisiode_Offer;
                public MediaInformation EMS_Expired_Offer;
                public MediaInformation EMS_PPVMovie_Offer;

                public MediaInformation EMS_Geofenced_Japan_Offer;

                public MediaInformation EMS_Ad_Supported_Video_Offer;

                public MediaMatrix ()
                {
                    SyncCast_DTO_Offers = new List<MediaInformation>();
                    SyncCast_PPV_Offers = new List<MediaInformation>();

                    EMS_DTO_Offers = new List<MediaInformation>();
                    EMS_PPV_Offers = new List<MediaInformation>();
                    EMS_Season_Offers   = new List<MediaInformation>();

                    HD_Get_SD_Offer = null;
                    SD_NoGet_HD_Offer = null;
                    EMS_TVEpisiode_Offer = null;
                    EMS_PPVMovie_Offer = null;
                    EMS_Expired_Offer = null;
                    EMS_Geofenced_Japan_Offer = null;

                    EMS_Ad_Supported_Video_Offer = null;
                }

                /// <summary>
                /// Dumps out the data about each offer that was collected from the query.
                /// </summary>
                public void DumpMediaInfo()
                {
                    Global.RO.Fatal("####[ EMS PPV Offers: {0} ]####", EMS_PPV_Offers.Count);
                    foreach(MediaInformation info in EMS_PPV_Offers)
                        info.Dump();

                    Global.RO.Fatal("####[ EMS DTO Offers: {0} ]####", EMS_DTO_Offers.Count);
                    foreach(MediaInformation info in EMS_DTO_Offers)
                        info.Dump();

                    Global.RO.Fatal("####[ EMS Season Offers: {0} ]####", EMS_Season_Offers.Count);
                    foreach(MediaInformation info in EMS_Season_Offers)
                        info.Dump();

                    Global.RO.Fatal("####[ SyncCast DTO Offers: {0} ]####", SyncCast_DTO_Offers.Count);
                    foreach(MediaInformation info in SyncCast_DTO_Offers)
                        info.Dump();

                    Global.RO.Fatal("####[ SyncCast PPV Offers: {0} ]####", SyncCast_PPV_Offers.Count);
                    foreach(MediaInformation info in SyncCast_PPV_Offers)
                        info.Dump();
                }

                /// <summary>
                ///  Searches the specified list for the offer.
                /// </summary>
                /// <param name="_list">The list to search</param>
                /// <param name="_info">The info to look for</param>
                /// <returns>true if the offer exists</returns>
                private bool OfferExist ( List<MediaInformation> _list, MediaInformation _info )
                {
                    foreach (MediaInformation mediaInfo in _list)
                    {
                        if (mediaInfo.mediaInstanceId == _info.mediaInstanceId && mediaInfo.offerId == _info.offerId)
                            return true;
                    }
                    return false;
                }

                public List<MediaInformation> GetOffers ( VIDEOOFFERTYPE _type, uint _count )
                {
                    List<MediaInformation> results = new List<MediaInformation>();

                    switch (_type)
                    {
                        case VIDEOOFFERTYPE.EMS_DTO:
                            if (EMS_DTO_Offers.Count >= _count)
                            {
                                for (int i = 0; i < _count; i++)
                                {
                                    results.Add(EMS_DTO_Offers[i]);
                                }
                            }
                            break;
                        case VIDEOOFFERTYPE.EMS_PPV:
                            if (EMS_PPV_Offers.Count >= _count)
                            {
                                for (int i = 0; i < _count; i++)
                                {
                                    results.Add(EMS_PPV_Offers[i]);
                                }
                            } break;
                        case VIDEOOFFERTYPE.EMS_SEASON:
                            if (EMS_Season_Offers.Count >= _count)
                            {
                                for (int i = 0; i < _count; i++)
                                {
                                    results.Add(EMS_Season_Offers[i]);
                                }
                            } break;
                        case VIDEOOFFERTYPE.SYNCCAST_DTO:
                            if (SyncCast_DTO_Offers.Count >= _count)
                            {
                                for (int i = 0; i < _count; i++)
                                {
                                    results.Add(SyncCast_DTO_Offers[i]);
                                }
                            } break;
                        case VIDEOOFFERTYPE.SYNCCAST_PPV:
                            if (SyncCast_PPV_Offers.Count >= _count)
                            {
                                for (int i = 0; i < _count; i++)
                                {
                                    results.Add(SyncCast_PPV_Offers[i]);
                                }
                            } break;
                    };

                    return results;
                }


            /// <summary>
            /// Runs a FindVideoOffer query and populates the matrix with the data
            /// it collected.
            /// </summary>
            /// <param name="_client">Client who is running the query</param>
            public void PopulateOfferTable ()
            {
                //// Setup the filter to get the list of movies available
                ////live.common.next.FindVideosFilter filter = new live.common.next.FindVideosFilter();
                ////filter.Locale = "en-US";
                ////filter.LegalLocale = "en-US";
                ////filter.Store = 1;
                ////filter.PageSize = 100;
                ////filter.PageNum = 1;
                ////filter.DetailView = 5;
                ////filter.MediaTypes = ListEx.NewList(2, 3, 8, 10); // Movie, TV, TVEpisode, TVSeason

                //// Send the request with the filter, and get back a HUGE XML blob that needs parsing.
                ////live.protocol.next.CatalogResponse catResponse = live.server.next.Catalog.FindVideos(_client, filter);

                //// Dump out the xml returned for debugging.
                ////Global.RO.Info(catResponse.Response);

                ////ParseXMLResponse(catResponse.Response);

                SyncCast_DTO_Offers.Clear(); ;
                SyncCast_PPV_Offers.Clear();


                EMS_DTO_Offers.Clear();
                EMS_PPV_Offers.Clear();
                EMS_Season_Offers.Clear();


                //
                // This is the query to run to pull the useful information for offers
                //
                //SELECT Distinct o.offerId, mi.mediaInstanceId,oi.pointsPrice,ptmi.licenseTypeId, oi.offerInstanceId, o.mediaId
                //FROM offer o
                //INNER JOIN offerinstance oi on o.offerid = oi.offerid
                //INNER JOIN mediainstance mi on o.mediaid = mi.mediaid
                //INNER JOIN providerTermMediaInstance ptmi on mi.mediaInstanceid = ptmi.mediainstanceid
                //where licenseTypeId = 3 -- 1, 2, 3, 4

                // Storage for all of the offerids since queries hate me.
                // OfferId, MediaInstanceId, PointsPrice, LicenseTypeId
                string[] offers = new string[]{
                                                "9D537A31-5875-429B-85E2-72820DEEB72C", "54E487AA-756F-4245-A466-8955B5E82393", "160", "1",
                                                "AF956372-472A-41B8-BABC-204712F5748F", "DB5B1411-A78C-4200-88F3-050098BBF3B4", "160", "1",
                                                "4F4A111D-5294-400D-BEDC-F9FDAA24031A", "DF370A27-B686-4080-BF38-54E63593002B", "160", "1",
                                                "182F11D9-0BBE-45C0-8A98-F07C4EE7E119", "B8178243-5960-4782-835F-20E354B4A7A5", "320", "2",
                                                "3E9B3109-3743-4332-9372-0CC2403C7C15", "7C055AF4-243E-4EC8-BB8D-BC5757F5A816", "320", "2",
                                                "82A34591-D004-449B-8173-93DA4920673E", "963C855F-FB7E-4BA9-952E-FFEA041E1751", "480", "2",
                                                "D465C4AC-AAB2-4903-BBFE-79C327074F2D", "9508BE91-BB56-4831-81DF-6216EBC74609", "320", "2",
                                                "00020000-0002-0004-0000-000000000000", "00020000-0002-0001-0000-000000000000", "200", "3",
                                                "00020000-0002-0004-0000-000000000100", "00020000-0002-0001-0000-000000000001", "200", "3",
                                                "00020000-0002-0004-0000-000000000101", "00020000-0002-0001-0000-000000000001", "200", "3",
                                                "00020013-0000-0004-0113-000000100001", "00020013-0002-0002-0113-000000000001", "800", "3",
                                                "00030003-0000-0004-0113-000000100127", "DEB17988-5F9F-4ABE-8739-15D9E147552A", "800", "4",
                                                "00030003-0000-0004-0113-000000100129", "F344FB92-D7CC-4333-90AF-FEAF50843C04", "800", "6"
                                                };

                //
                // Manually add the EMS data since it's not pupulated to the DB yet.
                //
                for (int i = 0; i < offers.Length; i += 4)
                {
                    MediaInformation tempMediaInfo = new MediaInformation();
                    tempMediaInfo.offerId = new Guid(offers[i]);
                    tempMediaInfo.mediaInstanceId = new Guid(offers[i + 1]);
                    tempMediaInfo.pointsPrice = Convert.ToUInt32(offers[i + 2]);
                    tempMediaInfo.mediaType = Convert.ToUInt32(offers[i + 3]);

                    switch (tempMediaInfo.mediaType)
                    {
                        case 1: // SyncCast DTO
                            SyncCast_DTO_Offers.Add(tempMediaInfo);
                            break;
                        case 2: // SyncCast PPV
                            SyncCast_PPV_Offers.Add(tempMediaInfo);
                            break;
                        case 3: // EMS DTO
                            EMS_DTO_Offers.Add(tempMediaInfo);
                            break;
                        case 4: // EMS PPV1
                        case 5: // EMS PPV2
                        case 6: // EMS PPV3
                            EMS_PPV_Offers.Add(tempMediaInfo);
                            break;
                    };
                }

                // HD / SD content. Used to test that when you purchase the HD version, you get
                // the SD version, and that when you purchase the SD version, you do not get the
                // HD version.
                HD_Get_SD_Offer = new MediaInformation();
                HD_Get_SD_Offer.offerId = new Guid("69C3D02E-05A9-41CE-9689-DCB5D3356F10");
                HD_Get_SD_Offer.mediaInstanceId = new Guid("7B9AA471-689E-459C-916F-084C33BFA67F");
                HD_Get_SD_Offer.pointsPrice = 0;
                SD_NoGet_HD_Offer = new MediaInformation();
                SD_NoGet_HD_Offer.offerId = new Guid("69C3D02E-05A9-41CE-9689-DCB5D3356F10");
                SD_NoGet_HD_Offer.mediaInstanceId = new Guid("64FEBF4E-99DE-47ED-9574-2AA2C9B5245C");
                SD_NoGet_HD_Offer.pointsPrice = 0;

                EMS_Ad_Supported_Video_Offer = new MediaInformation();
                EMS_Ad_Supported_Video_Offer.offerId = new Guid("00030003-0000-0004-0113-000000100132");
                EMS_Ad_Supported_Video_Offer.mediaInstanceId = new Guid("00030003-0002-0002-0113-000000000124");
                EMS_Ad_Supported_Video_Offer.pointsPrice = 800;


                EMS_Expired_Offer = new MediaInformation();
                EMS_Expired_Offer.offerId = new Guid("00020000-0002-0004-0000-F00000000000");
                EMS_Expired_Offer.mediaInstanceId = new Guid("00020000-0002-0001-0000-000000000000");
                EMS_Expired_Offer.pointsPrice = 200;

                EMS_Geofenced_Japan_Offer = new MediaInformation();
                EMS_Geofenced_Japan_Offer.offerId = new Guid("00020000-0002-0004-0000-000000000100");// new Guid("00020000-0002-0004-0000-000000000500");
                EMS_Geofenced_Japan_Offer.mediaInstanceId = new Guid("00020000-0002-0001-0000-000000000001");// new Guid("00020000-0002-0001-0000-000000000005");
                EMS_Geofenced_Japan_Offer.pointsPrice = 200;



                // Prints out all the different groups of content
                DumpMediaInfo();
            }

                /// <summary>
                /// Parsed through the result of the query and seperates
                /// all the data into their correct matrix location.
                /// </summary>
                /// <param name="_response"></param>
                private void ParseXMLResponse ( string _response)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.LoadXml(_response);

                    MediaInformation tempInfo = null;

                    // Parse the whole file.
                    foreach (XmlNode entryNode in doc.DocumentElement.ChildNodes)
                    {
                        switch (entryNode.Name)
                        {
                            case "entry":
                                tempInfo = new MediaInformation();
                                foreach (XmlNode childNode in entryNode.ChildNodes)
                                {
                                    switch (childNode.Name)
                                    {
                                        case "title":   // Title
                                            tempInfo.title = childNode.InnerText;
                                            break;
                                        case "id":      // Offer ID
                                            string offerId = childNode.InnerText;
                                            offerId = offerId.Substring(offerId.LastIndexOf(':') + 1);
                                            tempInfo.offerId = new Guid(offerId);
                                            break;
                                        case "live:offer": // Offer Details
                                            foreach (XmlNode offerNode in childNode.ChildNodes)
                                            {
                                                switch (offerNode.Name)
                                                {
                                                    case "live:mediaType":
                                                        tempInfo.mediaType = Convert.ToUInt32(offerNode.InnerText);
                                                        break;

                                                    case "live:offerInstances":
                                                        foreach (XmlNode offerInstanceNode in offerNode.ChildNodes)
                                                        {
                                                            switch (offerInstanceNode.Name)
                                                            {
                                                                case "live:offerInstance":

                                                                    foreach (XmlNode videoOfferInstanceNode in offerInstanceNode.ChildNodes)
                                                                    {
                                                                        switch (videoOfferInstanceNode.Name)
                                                                        {
                                                                            case "live:pointsPrice":
                                                                                tempInfo.pointsPrice = Convert.ToUInt32(videoOfferInstanceNode.InnerText);
                                                                                break;
                                                                        };
                                                                    }
                                                                    break;
                                                            };
                                                        }
                                                        break;
                                                };
                                            }
                                            break;
                                        case "live:mediaInstances":
                                            foreach (XmlNode mediaInstanceNode in childNode.ChildNodes)
                                            {
                                                switch (mediaInstanceNode.Name)
                                                {
                                                    case "live:videoMediaInstance":
                                                        MediaInformation.GuidTypePair tempGuidTypePair = new MediaInformation.GuidTypePair();
                                                        foreach (XmlNode videoInstanceNode in mediaInstanceNode.ChildNodes)
                                                        {
                                                            switch (videoInstanceNode.Name)
                                                            {
                                                                case "live:mediaId":
                                                                    string videoMediaId = videoInstanceNode.InnerText;
                                                                    videoMediaId = videoMediaId.Substring(videoMediaId.LastIndexOf(':') + 1);
                                                                    tempGuidTypePair.mediaId = new Guid(videoMediaId);
                                                                    break;
                                                                case "live:videoInstanceId":
                                                                    string offerMediaId = videoInstanceNode.InnerText;
                                                                    offerMediaId = offerMediaId.Substring(offerMediaId.LastIndexOf(':') + 1);
                                                                    tempInfo.mediaInstanceId = new Guid(offerMediaId);
                                                                    break;
                                                                case "live:offerLicenseType":
                                                                    tempGuidTypePair.offerLicenseType = videoInstanceNode.InnerText;
                                                                    break;
                                                            };

                                                        }
                                                        tempInfo.videoInstances.Add(tempGuidTypePair);
                                                        break;
                                                };
                                            }
                                            break;
                                    };
                                }
                                switch (tempInfo.videoInstances[0].offerLicenseType)
                                {
                                    case "SyncCast DTO":
                                        if (!OfferExist(SyncCast_DTO_Offers, tempInfo))
                                            SyncCast_DTO_Offers.Add(tempInfo);
                                        break;
                                    case "SyncCast PPV":
                                        if (!OfferExist(SyncCast_PPV_Offers, tempInfo))
                                            SyncCast_PPV_Offers.Add(tempInfo);
                                        break;
                                    case "Xbox Live Video Marketplace DTO":
                                        if (!OfferExist(EMS_DTO_Offers, tempInfo))
                                            EMS_DTO_Offers.Add(tempInfo);
                                        break;
                                    case "Xbox Live Video Marketplace PPV 1":
                                        if (!OfferExist(EMS_PPV_Offers, tempInfo))
                                            EMS_PPV_Offers.Add(tempInfo);
                                        break;
                                    //case "Xbox Live Video Marketplace DTO Season":
                                    //    if (!OfferExist(EMS_Season_Offers, tempInfo))
                                    //        EMS_Season_Offers.Add(tempInfo);
                                    //    break;
                                };
                                break;
                        };
                    }
                }
            }

            public class MediaInformation
            {
                // Entry
                public string title = null;
                public Guid offerId;

                // Offer
                public uint mediaType = 0;
                public Guid mediaInstanceId;
                public uint pointsPrice = 0;

                // MediaInstances
                public List<GuidTypePair> videoInstances = null;

                public MediaInformation ()
                {
                    videoInstances = new List<GuidTypePair>();
                }

                public void Dump ()
                {
                    Global.RO.Info("--MediaType: " + mediaType);
                    Global.RO.Info("--OfferId: " + offerId);
                    Global.RO.Info("--MediaInstanceId: " + mediaInstanceId);
                    Global.RO.Info("--PointsPrice: " + pointsPrice);
                    foreach (GuidTypePair includedMedia in videoInstances)
                    {
                        Global.RO.Info("---Media Instance");
                        Global.RO.Info("----License Type: " + includedMedia.offerLicenseType);
                        Global.RO.Info("----MediaId: " + includedMedia.mediaId);
                    }
                    Global.RO.Warn("-------------------------------------------------- ");
                }

                public class GuidTypePair
                {
                    public string offerLicenseType = null;
                    public Guid mediaId;
                }
            }

            public static live.common.XblUser CreateUser ( live.common.IClient client, live.common.XblUserTier userType, live.common.PassportType passportType )
            {
                live.common.XblUserSettings settings = new live.common.XblUserSettings(userType, passportType);

                live.common.PassportUtils.CreatePassportAccounts(client, settings, true);

                live.common.XblUser user;
                uint hr = UACS.XeCreateLiveAccount(client, settings, out user);
                if (hr != 0)
                {
                    throw new Exception("Failed to create user; hr = " + hr);
                }

                return user;
            }

            public static Xbox360Client CreateMachine ()
            {
                ulong tempMachinePuid = 0;
                try
                {
                    AuthContext ctx = new AuthContext(AuthContext.ClientTypes.Xenon);
                    ctx.UseXmacsTestKey = true;
                    XmacsClient xmac = new XmacsClient(ctx);
                    xmac.SignInXmacs();
                    Global.RO.Fatal("Machine Account Created. Puid: " + xmac.MachinePuid);
                    tempMachinePuid = xmac.MachinePuid;
                }
                catch
                {
                    Global.RO.Fatal("Machine account could not be made. Using backup PUID. Tests will fail if backup PUID is not in t_machines.");
                    tempMachinePuid = 0xFA00000000000400; // Default PUID
                }

                Xbox360Client client = new Xbox360Client();
                client.TitleId = 0xFFFE07D1;
                client.MachinePuid = tempMachinePuid;
                return client;
            }

            public static bool AddPoints5000 ( Xbox360Client _client, live.common.XblUser _user )
            {
                Global.RO.Info("Attempting to purchase 5000pts for user: " + _user.Puid);
                uint balanceBefore = UACS.XeGetPointsBalance(_client, _user);

                UACS.XeAddPaymentInstrument(_client,
                                            _user,
                                            live.common.Randomizer.CreditCards.CardInfoForPerson(live.common.CreditCardType.Visa,
                                                                                     _user.Settings.PersonalInfo));
                live.server.Billing.XeOfferPurchase(_client,
                                                    _user,
                                                    ServerTestFramework.LiveService.Billing.Offers.GetPointsOfferId(ServerTestFramework.LiveService.Billing.Offers.PointsOffers.CC5000US),
                                                    live.common.PaymentTypeEnum.CreditCard,
                                                    _user.Settings.BillingInfo.ActivePaymentInstrumentId);


                uint balanceAfter = UACS.XeGetPointsBalance(_client, _user);
                Global.RO.Fatal("Points [ Before: " + balanceBefore + " | After: " + balanceAfter + " ]");
                if ((balanceAfter - balanceBefore) != 5000)
                {
                    Global.RO.Error("Points purchase did not award the correct number of points");
                    return false;
                }

                return true;
            }

            public static bool Purchase1Year ( Xbox360Client _client, live.common.XblUser _user )
            {
                Global.RO.Info("Attempting to purchase 1 year sub for user: " + _user.Puid);

                UACS.XeAddPaymentInstrument(_client,
                                            _user,
                                            live.common.Randomizer.CreditCards.CardInfoForPerson(live.common.CreditCardType.Visa,
                                                                                     _user.Settings.PersonalInfo));
                live.server.Billing.XeOfferPurchase(_client,
                                                    _user,
                                                    ServerTestFramework.LiveService.Billing.Offers.GetPremiumSubsOfferId(ServerTestFramework.LiveService.Billing.Offers.PremiumSubsOffers.CC1Year),
                                                    live.common.PaymentTypeEnum.CreditCard,
                                                    _user.Settings.BillingInfo.ActivePaymentInstrumentId);
                return true;
            }

            /// <summary>
            ///  Dumps out the error code in hex
            /// </summary>
            public static void DumpError ( uint _error, string _failureText )
            {
                string error = string.Format("0x{0:x8}", _error);
                Global.RO.Error(_failureText + " | Error: " + error);
            }

            public static bool VerifyAckResponse ( live.protocol.AcknowledgeLicensesDeliveryResponse _response, uint[] _expectedResults )
            {
                bool isVerified = true;
                Global.RO.Info("Verifying Acknowledgement Response...");

                if (_response.acknowledgementsLength != _expectedResults.Length)
                {
                    Global.RO.Error("Number of licenses acknowledgements returned and the expected number are not the same.");
                    Global.RO.Error("Returned: " + _response.acknowledgementsLength + " | Expected: " + _expectedResults.Length);
                    return false;
                }

                // Check each ack that came back.
                for (int i = 0; i < _response.acknowledgementsLength; i++)
                {
                    Global.RO.Info("* Expected: 0x{0:x8} Received: 0x{1:x8}", _expectedResults[i], _response.acknowledgements[i].hr);
                    if (_response.acknowledgements[i].hr != _expectedResults[i])
                    {
                        DumpError(_response.acknowledgements[i].hr, "Acknowledgement Failure: ");
                        DumpError(_expectedResults[i], "Expected Result: ");
                        Global.RO.Error("Media Id: " + _response.acknowledgements[i].idPair.miid + " | OfferId: " + _response.acknowledgements[i].idPair.oid);
                        isVerified = false;
                    }
                    else
                    {
                        Global.RO.Success("Media Id: " + _response.acknowledgements[i].idPair.miid + " | OfferId: " + _response.acknowledgements[i].idPair.oid);
                    }
                }
                if (!isVerified)
                {
                    Global.RO.Error("One or more license acknowledgements failed.");
                }

                return isVerified;
            }

            public static bool VerifyLicenseResponse ( AcquireMediaLicensesResponse _response, uint[] _expectedResults, MediaInstanceIdOfferIdPair[] _mediaInfo )
            {
                bool isVerified = true;
                Global.RO.Info("Verifying Acquire Response...");

                if (_response.mediaLicensesLength != _expectedResults.Length)
                {
                    Global.RO.Error("Number of licenses returned and the expected number are not the same.");
                    Global.RO.Error("Returned: " + _response.mediaLicensesLength + " | Expected: " + _expectedResults.Length + " |" + _response.mediaLicenses.Length);
                    return false;
                }

                // Check each license that came back
                for (int i = 0; i < _response.mediaLicensesLength; i++)
                {
                    for(int j = 0; j< _mediaInfo.Length; j++)
                    {
                        if(_response.mediaLicenses[i].idPair.miid == _mediaInfo[j].miid
                            && _response.mediaLicenses[i].idPair.oid == _mediaInfo[j].oid)
                        {
                            Global.RO.Info("* Expected: 0x{0:x8} Received: 0x{1:x8}", _expectedResults[j], _response.mediaLicenses[i].hr);
                            if (_response.mediaLicenses[i].hr != _expectedResults[j])
                            {
                                DumpError(_response.mediaLicenses[i].hr, "Medialicese Failure: ");
                                DumpError(_expectedResults[j], "Expected Result: ");
                                Global.RO.Error("MediaId: " + _response.mediaLicenses[i].idPair.miid + " | OfferId: " + _response.mediaLicenses[i].idPair.oid);
                                isVerified = false;
                            }
                            else
                            {
                                Global.RO.Success("MediaId: " + _response.mediaLicenses[i].idPair.miid + " | OfferId: " + _response.mediaLicenses[i].idPair.oid);
                            }
                            break;
                        }
                    }
                }

                if (!isVerified)
                {
                    Global.RO.Error("One or more media licenses were not granted.");
                }

                return isVerified;
            }
/*
            public static bool VerifyLicenseResponse ( AcknowledgeLicensesDeliveryResponse _response, uint[] _expectedResults )
            {
                bool isVerified = true;
                Global.RO.Info("Verifying License Response...");

                if (_response.mediaLicensesLength != _expectedResults.Length)
                {
                    Global.RO.Error("Number of licenses returned and the expected number are not the same.");
                    Global.RO.Error("Returned: " + _response.mediaLicensesLength + " | Expected: " + _expectedResults.Length + " |" + _response.mediaLicenses.Length);
                    return false;
                }

                // Check each license that came back
                for (int i = 0; i < _response.mediaLicensesLength; i++)
                {
                    Global.RO.Info("* Expected: 0x{0:x8} Received: 0x{1:x8}", _expectedResults[i], _response.mediaLicenses[i].hr);
                    if (_response.mediaLicenses[i].hr != _expectedResults[i])
                    {
                        DumpError(_response.mediaLicenses[i].hr, "Medialicese Failure: ");
                        DumpError(_expectedResults[i], "Expected Result: ");
                        Global.RO.Error("MediaId: " + _response.mediaLicenses[i].idPair.miid + " | OfferId: " + _response.mediaLicenses[i].idPair.oid);
                        isVerified = false;
                    }
                    else
                    {
                        Global.RO.Success("MediaId: " + _response.mediaLicenses[i].idPair.miid + " | OfferId: " + _response.mediaLicenses[i].idPair.oid);
                    }
                }

                if (!isVerified)
                {
                    Global.RO.Error("One or more media licenses were not granted.");
                }

                return isVerified;
            }
*/
        }

    }
    [TestCase]
    public class LiveSvc_PurchaseOffer_Log : TestBase//, IReportingTest
    {
        DBInformation dbRef;

        XeUser user;

        protected override void Execute ()
        {
            bool bRet;

            bRet = RunInitialStep(DBInformation.Instance);

            if(bRet == false)
            {
                CUtil.log.Error("\n\n LiveSvc_PurchaseOffer_Log.RunInitialStep() failed: ");
                return;
            }

            CUtil.log.Debug("\n\n+++ LiveSvc_PurchaseOffer_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_PurchaseOffer_Log");

            // Verify PurchaseOffer log data
            CUtil.log.Info("Verify LiveSvc_PurchaseOffer_Log message.");
            if (CUtil.VerifyFilterDB("purchaseoffer",tbl) ==  true)
            {
                CUtil.log.Success("LiveSvc_PurchaseOffer_Log log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("LiveSvc_PurchaseOffer_Log log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_PurchaseOffer_Log Initial Step \n");

            try{
                user = XbosUser.XenonSilverUser();
                CUtil.log.Debug("Created user " + user.UserPuid.ToString());

                user.AddPoints_500();
            }
            catch
            {
                ;
            }

            string szServer = null;

            // Get available offer id and price
            Guid offerId = new Guid();
            if(!GetAvailbleOfferId(ref offerId, ref szServer))
            {
                CUtil.log.Warn("\n\n GetAvailbleOfferId failed: ");
                return false;
            }

            uint price = GetPrice(szServer, offerId);

            XRLPurchaseOffers request = new XRLPurchaseOffers();

            request.UserPuid = user.UserPuid;
            request.Offers = new OfferExpectedPrice[1];
            request.Offers[0] = new OfferExpectedPrice();
            request.Offers[0].offerId = offerId;
            request.Offers[0].expectedPrice = price;

            request.Offers[0].offerId = new Guid("00010011-0008-0004-0000-000a01010001");
            request.Offers[0].expectedPrice = 400;

            if (!request.Execute())
            {
                CUtil.log.Warn("\n\n XRLXeOfferPurchase failed: " + request.GetDumpString());

                return false;
            }
            if (request.XErr != HResult.S_OK)
            {
                CUtil.log.Warn(String.Format("\n\n XRLXeOfferPurchase returned XErr=0x{0:x}", request.XErr));

                return false;
            }

            t_purchaseoffer_fact tbl = new t_purchaseoffer_fact();
            tbl.dt_when = new DateRange(180, 30);
            tbl.bi_user_puid = ((Int64)user.UserPuid).ToString();    // UserPuid

            dbi.AddDBItem("LiveSvc_PurchaseOffer_Log", tbl);
            dbRef = dbi;
            return true;
        }

        public static bool GetAvailbleOfferId(ref Guid offerId, ref string szAvailableServer)
        {
            bool bReturn = true;

            CUtil.log.Debug("\n\n+++ GetAvailbleOfferId \n");

            string[] szServers;
            IInterfaceInfo iiInfo;
            SqlConnection Connection=null;
            bool    bConnectionOpen=false;

            // Connect to fecatalogdbxbox
            szServers = Config.GetServerListByInterface(Interface.fecatalogdbxbox);

            for(int ii=0; ii<szServers.Length; ii++)
            {
                iiInfo = Config.GetInterface( szServers[ii], Interface.fecatalogdbxbox );
                Connection = new SqlConnection("server=" + szServers[ii] + ";database=" + iiInfo.DBName + ";Integrated Security=SSPI");
                try{
                    Connection.Open();
                    CUtil.log.Info("Succeeded to open {0}:{1}", szServers[ii], iiInfo.DBName);
                    bConnectionOpen = true;
                    szAvailableServer = szServers[ii];
                    break;
                }
                catch
                {
                    CUtil.log.Warn("Failed to open {0}:{1}", szServers[ii], iiInfo.DBName);
                }
            }

            if(!bConnectionOpen)
            {
                CUtil.log.Warn("No servers are available");
                return false;
             }

            SqlCommand cmd;

            cmd = new SqlCommand();
            cmd.Connection = Connection;
            cmd.CommandType = CommandType.Text;

            string query = string.Format("SELECT top 1 o.offerId, oi.pointsPrice FROM offer o INNER JOIN offerinstance oi on o.offerid = oi.offerid WHERE oi.pointsPrice < 500");

            cmd.CommandText = query;
            Object obj = cmd.ExecuteScalar ();

            if(obj == null)
            {
                bReturn = false;
                CUtil.log.Warn("No offer id.");
            }
            else
                offerId = (Guid) obj ;

            Connection.Close();

            return bReturn;
        }

        public static uint GetPrice(string szServer, Guid offerId)
        {
            IInterfaceInfo iiInfo;

            // Connect to fecatalogdbxbox
            iiInfo = Config.GetInterface( szServer, Interface.fecatalogdbxbox );

            SqlConnection Connection = new SqlConnection("server=" + szServer + ";database=" + iiInfo.DBName + ";Integrated Security=SSPI");
            Connection.Open();

            SqlCommand cmd;

            cmd = new SqlCommand();
            cmd.Connection = Connection;
            cmd.CommandType = CommandType.Text;

            string query = string.Format("SELECT top 1 oi.pointsPrice FROM offer o INNER JOIN offerinstance oi on o.offerid = oi.offerid WHERE o.offerId = '{0}'", offerId);

            cmd.CommandText = query;
            Object obj = cmd.ExecuteScalar ();

            int price = (int) obj ;

            Connection.Close();

            return (uint)price;
        }

    }

    [TestCase]
    public class LiveSvc_EliteMigration_Log : TestBase//, IReportingTest
    {
        DBInformation dbRef;

        private const uint _consumableTitle = 0x584907D3;  // Alaska tool title
        private const ulong _consumableOffer = 0x584907D30BB00001;
        private const uint _assetId = 1;

        // prepare two tokens for this consumable offer
        private static string _voucherCode = null;
        private static string VoucherCode
        {
            get
            {
                if (_voucherCode == null)
                {
                    // the use count -1 means unlimit uses
                    TokendbWS.AddVoucherForOffer(XbosOffer.OFFER_VOUCHER_HASH, _consumableOffer, -1, 0, 2);
                    _voucherCode = XbosOffer.OFFER_VOUCHER_CODE;
                }
                return _voucherCode;
            }
        }

        private static string _voucherCode2 = null;
        private static string VoucherCode2
        {
            get
            {
                if (_voucherCode2 == null)
                {
                    // the use count -1 means unlimit uses
                    TokendbWS.AddVoucherForOffer(XbosOffer.OFFER_VOUCHER_HASH2, _consumableOffer, -1, 0, 2);
                    _voucherCode2 = XbosOffer.OFFER_VOUCHER_CODE2;
                }
                return _voucherCode2;
            }
        }

        // 4 offers we can use for this API testing
        //private const ulong FreeOfferId = XeContentRefreshLicense.OFFER_ID_TRIAL; // 0x584107D800000000; // JOUST free trial with unrestricted license. license bit 0
        //private const ulong PaidOfferId = XeContentRefreshLicense.OFFER_ID;  // 0x584107D800000001; // Joust paid offer,  license bit 1
        private static readonly byte[] JoustContentId = new byte[] { 0x49, 0xA4, 0x30, 0x28, 0xF0, 0xD5, 0x6A, 0x4B, 0xC7, 0x55, 0xC1, 0x4B, 0x36, 0x3E, 0x42, 0xB8, 0xC8, 0x44, 0xFC, 0x11 }; // the correct content id

        private static ulong _gameOffer1 = 0;
        private static ulong _gameOffer2 = 0;
        private static byte[] Game1ContentId;
        private static byte[] Game2ContentId;

        public UacsCommon2 Uacs = null;

        protected ulong machinePuidOld = 0;
        protected ulong machinePuidNew = 0;
        protected string consoleOld = "";
        protected string consoleNew = "";
        protected bool OldMachineElite = false;
        protected bool NewMachineElite = true;
        protected LicenseType OldMachineLicense = LicenseType.BothLicenses;
        protected LicenseType NewMachineLicense = LicenseType.NoLicense;
        protected bool NewMachineSameLicense = false;

//        protected VideoInfo video1 = new VideoInfo();
//        protected VideoInfo video1New = new VideoInfo();
//        protected VideoInfo video2 = new VideoInfo();
//        protected VideoInfo video3 = new VideoInfo();

        protected XeUser user = null;
        protected XeUser user2 = null;
        protected XeUser user3 = null;

        public ServerTestFramework.LiveService.Billing.Asset[] before = null;
        public ServerTestFramework.LiveService.Billing.Asset[] after = null;
        public XRLTransferMachineLicense request = null;

        protected int TokenCount = 1;

        public enum LicenseType : int
        {
            NoLicense = 0,
            GameLicenseOnly = 1,
            VideoLicenseOnly = 2,
            BothLicenses = 3,
        }

        private static ulong GameOffer1
        {
            get
            {
                if (_gameOffer1 == 0 || _gameOffer2 == 0)
                {
                    CreateTwoOffers();
                }
                return _gameOffer1;
            }
        }
        private static ulong GameOffer2
        {
            get
            {
                if (_gameOffer1 == 0 || _gameOffer2 == 0)
                {
                    CreateTwoOffers();
                }
                return _gameOffer2;
            }
        }

        private const uint _defaultTitle = 0x2D5A7B21;

        private static void CreateTwoOffers()
        {
            XbosTitle title = new XbosTitle(_defaultTitle, false);
            title.Create();
            // first offer for the title
            XbosOffer offer1 = new XbosOffer(title);
            offer1.CleanOffer = false;
            offer1.CreateWithContent();
            _gameOffer1 = offer1.OfferId;
            Game1ContentId = offer1.OfferContent.ContentId;

            // second offer for the same title
            XbosOffer offer2 = new XbosOffer(title);
            offer2.CleanOffer = false;
            offer2.CreateWithContent();
            _gameOffer2 = offer2.OfferId;
            Game2ContentId = offer2.OfferContent.ContentId;
        }

        protected override void Execute ()
        {
            bool bRet;

            bRet = RunInitialStep(DBInformation.Instance);

            if(bRet == false)
            {
                CUtil.log.Error("\n\n LiveSvc_EliteMigration_Log.RunInitialStep() failed: ");
                return;
            }

            CUtil.log.Debug("\n\n+++ LiveSvc_EliteMigration_Log Final Step \n");

            FilterDBTable tbl = dbRef.RetrieveDBTable("LiveSvc_EliteMigration_Log");

            // Verify EliteMigration log data
            CUtil.log.Info("Verify LiveSvc_EliteMigration_Log message.");
            if (CUtil.VerifyFilterDB("elitemigration",tbl) ==  true)
            {
                CUtil.log.Success("LiveSvc_EliteMigration_Log log data found in FilterDB.");
                ResultCode = TEST_RESULTS.PASSED;
            }
            else
            {
                CUtil.log.Error("LiveSvc_EliteMigration_Log log data NOT in FilterDB!");
                ResultCode = TEST_RESULTS.FAILED;
            }
        }

        public bool RunInitialStep(DBInformation dbi)
        {
            CUtil.log.Debug("\n\n+++ LiveSvc_EliteMigration_Log Initial Step \n");

//            int tokenCount=1;
//            LicenseType oldMachineLicense=LicenseType.BothLicenses;
//            LicenseType newMachineLicense=LicenseType.NoLicense;
//            bool newMachineSameLicense=false;

            Init();

            //user = XbosUser.XenonSilverUser();
            //CUtil.log.Debug("Created user " + user.UserPuid.ToString());

            t_elite_migration_fact tbl = new t_elite_migration_fact();
            tbl.dt_when = new DateRange(180, 30);
            tbl.bi_user_puid = ((Int64)user.UserPuid).ToString();    // UserPuid

            dbi.AddDBItem("LiveSvc_EliteMigration_Log", tbl);
            dbRef = dbi;

            return true;
        }

        public void Init()
        {
            Uacs = new UacsCommon2();

            // create two machine account. We always use new machine puid in each test.
            machinePuidOld = XOn.XboxId.XenonMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong());
            consoleOld = "XE.2" + RandomEx.GlobalRandGen.GenerateNumberString(10);
            consoleOld = consoleOld + XbosOffer.GetConsoleIdLastDigit(consoleOld).ToString();
            string partOld = "";
            machinePuidNew = XOn.XboxId.XenonMachineBase | (~XOn.XboxId.Mask & RandomEx.GlobalRandGen.NextUlong());
            consoleNew = "XE.2" + RandomEx.GlobalRandGen.GenerateNumberString(10);
            consoleNew = consoleNew + XbosOffer.GetConsoleIdLastDigit(consoleNew).ToString();
            string partNew = "";

            string[] ElitePartNumbers = Global.XEnv.GetSetting("billing_eliteSkuPartNumbers").Split(new char[] {','});
            //string[] ElitePartNumbers = new string[] { "X804311-002", "X804311-003" };
            int count = ElitePartNumbers.GetLength(0);
            string ProPartNumberOld = "X804311-001";  // old Pro SKu
            string ProPartNumberNew = "X804311-002";  // old Pro SKu

            // prepare old machine
            // add consoleId and part number
            if (OldMachineElite)
                partOld = ElitePartNumbers[RandomEx.GlobalRandGen.Next(0, count)];
            else
                partOld = ProPartNumberOld;
            XbosWS.AddConsoleId(machinePuidOld, consoleOld, partOld);

            // prepare new machine
            // add consoleId and part number
            if (NewMachineElite)
                partNew = ElitePartNumbers[RandomEx.GlobalRandGen.Next(0, count)];
            else
                partNew = ProPartNumberNew;
            XbosWS.AddConsoleId(machinePuidNew, consoleNew, partNew);

            // create two users on old machine, most the time the two users should be created on two different partitions
            //XblUser user = Uacs.CreateUser(UserT, true);
            user = XbosUser.XenonSilverUser(machinePuidOld);
            user2 = XbosUser.XenonSilverUser(machinePuidOld);
            XbosOffer.RewardUSUser4000Points(user);
            XbosOffer.RewardUSUser4000Points(user2);

            // the request
            request = new XRLTransferMachineLicense();
            request.Slot.titleId = _consumableTitle;
            request.UserPuid = user.UserPuid;
            request.MachinePuidOld = machinePuidOld;
            request.MachinePuidNew = machinePuidNew;

            bool ret = request.Execute();
            if (request.XErr == HResult.S_OK)
                CUtil.log.Info("request.Execute() returned HResult.S_OK.");
            else
                CUtil.log.Warn("request.Execute() returned {0}.", request.XErr);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\ReplicationTestBase.cs ===
using Microsoft.SqlServer.Dts.Runtime;

using Microsoft.SqlServer.Management.Common;
using Microsoft.SqlServer.Management.Smo;
using Microsoft.SqlServer.Management.Smo.Agent;
using Microsoft.SqlServer.Replication;
using Microsoft.SqlServer.Server;

using System;
using System.ServiceProcess;
using System.Threading;
using System.Collections;
using System.Collections.Generic;
//using System.Diagnostics;
using System.Text;
//using System.Net;
using System.Data;
using System.Data.SqlClient;
using System.IO;
using System.Data.SqlTypes;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Database;
//using ServerTestFramework.LiveService;
//using ServerTestFramework.LiveService.Presence;
//using ServerTestFramework.LiveService.PresNotiCommon;
//using ServerTestFramework.Utilities;
//using ServerTestFramework.LiveService.Billing;
//using ServerTestFramework.LiveService.UserAccount;
//using ServerTestFramework.LiveService.UserSettings;
//using ServerTestFramework.LiveService.Feedback;

// SchemaDiff
using Microsoft.Webstore.Test.SchemaDiffAPI;

using xonline.common.config;
//using xonline.common.config;
using xonline.common.mgmt;
//using xonline.common.config;
using ServerTestFramework.STFLive.Reporting;

//[assembly: XomAreaDefinition(XomAreaName.Reporting)]
[assembly: RootNode(typeof(ReportingInfrastructureTest.ReplicationTestSuite))]

namespace ReportingInfrastructureTest
{
    public class ReplicationTestSuite : TestNode
    {
        public static Report cUtilLog = new Report("ReplicationTest");
    }

    [TestGroup]
    public class ReplicationTestBaseGroup : TestNode
    {
        public static Report cUtilLog = new Report("ReplicationTest");
        public static Hashtable replicatedTables_RDB = new Hashtable();
        public static Hashtable replicatedTables_ADB = new Hashtable();

        protected static ReportingCommon reportingcommon;   // Reference to Reporting common test object

        public override void PreRun()
        {
            ReportingCommon.ClearInstance(false);     // Get instance to common object
            reportingcommon = ReportingCommon.Instance;
            
            // Delete Diff directory if it exists
            try
            {
                if (System.IO.Directory.Exists(System.IO.Directory.GetCurrentDirectory() + SchemaDiffDir))
                {
                    string[] dirList = System.IO.Directory.GetDirectories(System.IO.Directory.GetCurrentDirectory() + SchemaDiffDir);
                    foreach (string dir in dirList)
                    {
                        string[] fileList = System.IO.Directory.GetFiles(dir);

                        foreach (string filename in fileList)
                        {
                            System.IO.File.Delete(filename);
                        }
                    }
                    System.IO.Directory.Delete(System.IO.Directory.GetCurrentDirectory() + SchemaDiffDir, true);
                }// if directory exists
            }
            catch (Exception exce)
            {
                Console.WriteLine("Error on initial directory cleanup: " + exce.Message);
            }
        }

        // Replication XML file locations
        protected static string reportingXML = @"c:\\rpttest\\replicationtest\\reporting.xml";
        protected static string securityXML = @"c:\\rpttest\\replicationtest\\security.xml";
        protected static string xboxcomXML = @"c:\\rpttest\\replicationtest\\Xboxcom.xml";
        protected static string corecatalogXML = @"c:\\rpttest\\replicationtest\\CoreCatalogDB.xml";
        
        // SchemaDiff result directory
        protected static string SchemaDiffDir = @"\\ReplicationSchemaDiff";


        public class ReplicationTestBase : TestBase
        {
            public ReplicationTestBase()
            {
                ResultCode = TEST_RESULTS.PASSED;

            }
            protected override void Execute()
            {
                Console.WriteLine("ReplicationTestBase is starting.");
                Console.WriteLine("ReplicationTestBase is ending.");
                //throw new Exception("The method or operation is not implemented.");
            }
            protected int GetTableSize(string szServer, string szDB, string szTable)
            {
                SqlConnection conn = new SqlConnection("server=" + szServer + ";database=" + szDB + ";Integrated Security=SSPI");
                int iRet = -1;
                try
                {
                    conn.Open();
                    SqlCommand comnd = new SqlCommand();
                    comnd.CommandType = CommandType.Text;
                    comnd.CommandTimeout = 3000000;
                    comnd.Connection = conn;

                    string query;
                    //SQLDataProvider sProvider = new SQLDataProvider();
                    //sProvider.InitializeConnection(szServer, szDB);

                    query = string.Format("SELECT count(*) FROM {0} with (nolock)", szTable);
                    //int iRet = (int)sProvider.ExecuteQueryScalar(query);

                    comnd.CommandText = query;
                    iRet = (int)comnd.ExecuteScalar();
                }
                catch (Exception exce)
                {
                    iRet = -1;
                    LogError(exce.Message + "\n" + exce.StackTrace);
                }
                finally
                {
                    conn.Close();
                }
                //sProvider.Close();

                return iRet;
            }
            protected int GetTableSize(ReportingDatabase szDB, string szTable)
            {
                string iRet = string.Empty; int retVal = -1;

                // Get new reference object and execute query
                TestRefObject trefo = new TestRefObject();
                trefo.DebugQuery = string.Format("SELECT count(*) FROM {0} with (nolock)", szTable);
                iRet = szDB.RunDebugQuery(trefo);

                try
                {
                    retVal = int.Parse(iRet);
                }
                catch (FormatException exce) // Format Exceptions occur if result is not a number or if it's null
                {
                    LogError("Error executing query: " + trefo.DebugQuery + "\n" + exce.Message);
                    retVal = -1;
                }
                return retVal;
            }


            //public void LogError(string message)
            public void LogError(string format, params object[] args)
            {
                //cUtilLog.Error(message);
                cUtilLog.Error(format, args);
                ResultCode = TEST_RESULTS.FAILED;
            }

            public void LogSuccess(string format, params object[] args)
            {
                cUtilLog.Success(format, args);
            }

            public void LogInfo(string format, params object[] args)
            {
                cUtilLog.Info(format, args);
            }

            public void LogWarn(string format, params object[] args)
            {
                cUtilLog.Warn(format, args);
            }

            //protected void GetCount(string szServer, string szDB, Hashtable hTable)
            //{
            //    SQLDataProvider sProvider = new SQLDataProvider();
            //    sProvider.InitializeConnection(szServer, szDB);
            //    ICollection szTables = hTable.Keys;

            //    // Save table list in tableArrayList
            //    ArrayList szTableArrayList = new ArrayList();
            //    foreach (string szTable in szTables)
            //    {
            //        szTableArrayList.Add(szTable);
            //    }

            //    foreach (string szTable in szTableArrayList)
            //    {

            //        string query = "SELECT count(*) FROM [" + szTable + "]";

            //        int iRet = (int)sProvider.ExecuteQueryScalar(query);

            //        hTable.Remove(szTable);
            //        hTable.Add(szTable, iRet);
            //    }

            //    sProvider.Close();
            //}

            /// <summary>
            /// Perform a Table Data and basic Schema comparison
            /// </summary>
            /// <param name="sourceServer">Replication source server</param>
            /// <param name="sourceDB">Replication source database</param>
            /// <param name="sourceTable">Replication source table</param>
            /// <param name="targetServer">Replication target server</param>
            /// <param name="targetDB">Replication target database</param>
            /// <param name="targetTable">Replication target table</param>
            /// <returns>True if success</returns>
            protected bool CompareTables(string sourceServer, string sourceDB, string sourceTable, string targetServer, string targetDB, string targetTable)
            {
                bool retVal = false;
                ConnectionOptions opt, opt2;
                opt = new ConnectionOptions();

                // Set output folder for SchemaDiff errors
                Microsoft.Webstore.Test.SchemaDiffAPI.Data.OutputFolder = System.IO.Directory.GetCurrentDirectory() + SchemaDiffDir;

                // Connect to first database
                Microsoft.Webstore.Test.SchemaDiffAPI.Database database1 = new Microsoft.Webstore.Test.SchemaDiffAPI.Database(sourceDB);
                // Set connection options
                opt.DatabaseName = sourceDB; opt.ServerName = sourceServer;

                // Connect to second database
                Microsoft.Webstore.Test.SchemaDiffAPI.Database database2 = new Microsoft.Webstore.Test.SchemaDiffAPI.Database(targetDB);
                // Set connection options
                opt2 = new ConnectionOptions();
                opt2.DatabaseName = targetDB; opt2.ServerName = targetServer;
                
                // Connect
                if (!database2.Register(opt2) || !database1.Register(opt))
                {
                    LogError("Error connecting to databases. Compare table schema failed!");
                    return false;
                }

                // Get table1
                Microsoft.Webstore.Test.SchemaDiffAPI.Table tab1 = new Microsoft.Webstore.Test.SchemaDiffAPI.Table(database1, sourceTable);
                
                // Get table 2
                Microsoft.Webstore.Test.SchemaDiffAPI.Table tab2 = new Microsoft.Webstore.Test.SchemaDiffAPI.Table(database2, targetTable);

                try
                {
                    // Load table data
                    tab1.Load();
                    tab2.Load();

                    // Compare tables
                    retVal = Data.CompareTable(tab1, tab2, tab1.Keys);
                }
                catch (Exception exce)
                {
                    retVal = false;
                    LogError("Error comparing table schemas: \n" + exce.Message + "\n" + exce.StackTrace);
                }
                return retVal;
            }

            /// <summary>
            /// Print any errors detailed in the result file from SchemaDiffAPI calls.
            /// </summary>
            protected void PrintSchemaDiffErrors()
            {
                string targetDir = System.IO.Directory.GetCurrentDirectory() + SchemaDiffDir;
                string[] fileList, directoryList;
                XmlDocument dom; XmlReader reader; XmlNodeList differenceList, differenceTypes, valueList; XmlNode temp = null;

                // Check if folder exists
                if(!System.IO.Directory.Exists(targetDir) )
                {
                    return;
                }

                // Get all directories and files and loop through each
                directoryList = System.IO.Directory.GetDirectories(targetDir);
                dom = new XmlDocument();
                foreach (string currentDir in directoryList)
                {
                    fileList = System.IO.Directory.GetFiles(currentDir);

                    foreach (string currentFile in fileList)
                    {
                        reader = null;
                        // Load xml
                        try
                        {
                            reader = XmlReader.Create(currentFile);
                            dom.Load(reader);

                            LogError(currentFile + " - Schema or Data errors:");

                            differenceList = dom.SelectNodes("/table/Differences/Difference");
                            // Loop through all differences found
                            foreach (XmlNode currentDifference in differenceList)
                            {
                                LogError("Difference in table: " + currentDifference.Attributes.GetNamedItem("ExistsIn").Value);

                                // Loop through all column differences
                                differenceTypes = currentDifference.ChildNodes;
                                foreach (XmlNode currentType in differenceTypes)
                                {
                                    if (currentType.Name != "Values")
                                        continue;

                                    valueList = currentType.ChildNodes;

                                    if (valueList.Count > 0)
                                        temp = valueList.Item(0);
                                    foreach (XmlNode currentColumn in valueList)
                                    {

                                        // First check if both nodes refer to same column
                                        if (currentColumn.Attributes.GetNamedItem("name").Value != temp.Attributes.GetNamedItem("name").Value)
                                        {
                                            temp = currentColumn;
                                            continue;
                                        }// Check if nodes refer to the same column and table
                                        else if (currentColumn.Attributes.GetNamedItem("name").Value == temp.Attributes.GetNamedItem("name").Value &&
                                            currentColumn.Attributes.GetNamedItem("location").Value == temp.Attributes.GetNamedItem("location").Value)
                                        {
                                            continue;
                                        }
                                        else if (currentColumn.Attributes.GetNamedItem("name").Value == temp.Attributes.GetNamedItem("name").Value &&
                                            currentColumn.Attributes.GetNamedItem("location").Value != temp.Attributes.GetNamedItem("location").Value)
                                        {
                                            // If they refer to same column and different tables, then compare data
                                            if (temp.InnerText != currentColumn.InnerText)
                                            {
                                                // If data is different, then print
                                                LogError("Error in column: " + currentColumn.Attributes.GetNamedItem("name").Value + " | Values: Source = " + temp.InnerText + " Target = " + currentColumn.InnerText);
                                            }
                                        }
                                        else
                                        {

                                        }

                                    }//foreach(currentColumn)
                                }
                            }//foreach(currentDifference)

                        }
                        catch (Exception exce)
                        {
                            LogError("Error parsing SchemaDiff output: \n" + exce.Message + "\n" + exce.StackTrace);
                        }
                        finally
                        {
                            if(reader != null)
                                reader.Close();
                            reader = null;
                        }
                    }//foreach(currentfile in filelist)

                }//foreach(currentdirectory)
                dom = null;
            }//PrintSchemaDiffErrors()


            protected bool Compare()
            {
                bool bReturn = true;
                ICollection szTables = replicatedTables_RDB.Keys;

                foreach (string szTable in szTables)
                {
                    if ((int)replicatedTables_RDB[szTable] == (int)replicatedTables_ADB[szTable])
                    {
                        cUtilLog.Info("Count of {0} is {1}.", szTable, replicatedTables_RDB[szTable]);
                    }
                    else
                    {
                        bReturn = false;
                        cUtilLog.Warn("Count of {0} in RDB is {1}.", szTable, replicatedTables_RDB[szTable]);
                        cUtilLog.Warn("Count of {0} in ADB is {1}.", szTable, replicatedTables_ADB[szTable]);
                    }
                }

                return bReturn;
            }
            public bool VerifyTableCount(XmlNode xGroupNode, string szSrc)
            {
                List<IReportingComponent> sourceDBs, tempList;
                List<string> sourceServerNames = new List<string>(5);
                ReportingDatabase destinationDb;

                bool bResult = true, reportingSource = false; 
                XmlNodeList xmlList;

                IInterfaceInfo iiSource;
                IInterfaceInfo iiTarget;
                string[] rgszServers;

                xmlList = xGroupNode.SelectNodes("Replication");

                LogInfo("Testing replication table count on:");
                LogInfo("===============================");

                foreach (XmlNode xPublication in xmlList)
                {
                    string szSource = xPublication.Attributes["SourceInterface"].Value;
                    string szTarget = xPublication.Attributes["TargetInterface"].Value;

                    if (szSource != szSrc)
                        continue;

                    string szPublication = xPublication.Attributes["Publication"].Value;
                    bool fMultisource = (null != xPublication.Attributes["Multisource"]) && bool.Parse(xPublication.Attributes["Multisource"].Value);

                    XmlNodeList xmlArticleList = xPublication.SelectNodes("Articles/Article");

                    if (0 == xmlArticleList.Count)
                    {
                        LogWarn(string.Format("There are 0 articles for replication for the {0} publication.", szPublication));
                        bResult = false;
                        continue;
                    }

                    rgszServers = Config.GetServerListByInterface(xPublication.Attributes["TargetInterface"].Value);
                    iiTarget = Config.GetInterface(rgszServers[0], xPublication.Attributes["TargetInterface"].Value);

                    // Get target DB
                    tempList = reportingcommon.FindObjectByInterface(xPublication.Attributes["TargetInterface"].Value);
                    if (tempList.Count <= 0)
                    {
                        // Interface not found in common object, print error and continue to next
                        LogError("Interface not found in common object: " + xPublication.Attributes["TargetInterface"].Value);
                        bResult = false;
                        continue;
                    }
                    destinationDb = (ReportingDatabase)tempList[0]; // This is pretty safe since our target database will always be a reporting database

                    // Get Source server list
                    sourceDBs = reportingcommon.FindObjectByInterface(xPublication.Attributes["SourceInterface"].Value);
                    sourceServerNames.Clear();
                    reportingSource = false;
                    if (sourceDBs.Count <= 0)
                    {
                        // Replication source is a non-reporting server
                        rgszServers = Config.GetServerListByInterface(xPublication.Attributes["SourceInterface"].Value);
                        foreach (string szServer in rgszServers)
                        {
                            sourceServerNames.Add(szServer);
                        }
                    }
                    else{
                        // Copy server name list
                        foreach (IReportingComponent sourceComponent in sourceDBs)
                        {
                            sourceServerNames.Add(sourceComponent.ComponentName);
                        }
                        reportingSource = true;
                    }

                    // Loop for each source server (Ex. FilterDBs)
                    //foreach (string szServer in rgszServers)
                    foreach (string szServer in sourceServerNames)
                    {
                        //string szServer = sourceDB.ComponentName;

                        bool bFlag = true;
                        iiSource = Config.GetInterface(szServer, xPublication.Attributes["SourceInterface"].Value);

                        LogInfo(string.Format("{0}:{1} to {2}:{3} for Publication:{4}", iiSource.ServerName,
                            iiSource.DBName, iiTarget.ServerName, iiTarget.DBName, szPublication));

                        //LogInfo(string.Format("{0}:{1} to {2}:{3} for Publication:{4}", sourceDB.ComponentName,
                        //    sourceDB.DatabaseName, destinationDb.ComponentName, destinationDb.DatabaseName, szPublication));

                        // Loop through each Article (table) in the replication publication
                        foreach (XmlNode xArticle in xmlArticleList)
                        {
                            string szArticleSrc = xArticle.Attributes["Name"].Value;
                            string szArticleTgt = xArticle.Attributes["Name"].Value;

                            if (null != xArticle.Attributes["Target"])
                                szArticleTgt = xArticle.Attributes["Target"].Value;
                            //LogInfo(string.Format("    Testinging article {0} on publication {1}", szArticle, szPublication));

                            // Get publisher table count
                            int iSource = 0;
                            if (!reportingSource)
                            {
                                iSource = GetTableSize(iiSource.ServerName, iiSource.DBName, szArticleSrc);
                            }
                            else
                            {
                                ReportingDatabase sourceDB;
                                foreach(IReportingComponent t in sourceDBs)
                                {
                                    if(t.ComponentName != szServer)
                                        continue;
                                    
                                    sourceDB = (ReportingDatabase) t;
                                    iSource = GetTableSize(sourceDB, szArticleSrc);
                                    break;
                                }
                            }
                            // Append server name to table if multisource replication (Ex. FilterDB - ReportingDB)
                            if (fMultisource)
                                szArticleTgt = szArticleTgt + "_" + szServer; //szArticleSrc = szArticleSrc + "_" + szServer;

                            // Get subscriber count
                            //int iTarget = GetTableSize(iiTarget.ServerName, iiTarget.DBName, szArticleTgt);
                            int iTarget = GetTableSize(destinationDb, szArticleTgt);

                            // Compare results
                            if ((iSource == iTarget) && (CompareTables(iiSource.ServerName, iiSource.DBName, szArticleSrc, destinationDb.ComponentName, destinationDb.DatabaseName, szArticleTgt)) )
                            {
                                LogSuccess(string.Format("Record count match: [" + szArticleSrc + "] Source and Target : {0}", iSource));
                                if (iSource == 0)
                                    LogWarn(string.Format("\t\t[" + szArticleSrc + "] - Record Count: 0 : Source {0} : Target {1}", iSource, iTarget));
                            }
                            else
                            {
                                LogError(string.Format("Record count does not match : [" + szArticleSrc + "] Source {0} : Target {1}", iSource, iTarget));
                                PrintSchemaDiffErrors();
                                bResult = false;
                                bFlag = false;
                            }
                        }//foreach(article)
                        if (bFlag == false)
                            LogError(string.Format("Publication from {0} to {1} failed: server {2}", szSource, szTarget, szServer));
                        else
                            LogInfo(string.Format("Publication from {0} to {1} succeeded: server {2}", szSource, szTarget, szServer));
                    }

                }

                return bResult;
            }

        }

        //////////////////////////////////////////////////////////////////////////////////////
        [TestCase]
        public class FilterDBTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("FilterDBTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(reportingXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "filterdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("FilterDBTest passed");
                else
                    LogError("FilterDBTest failed");


            }

        }
        [TestCase]
        public class ProductDBTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("ProductDBTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(reportingXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "productdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("ProductDBTest passed");
                else
                    LogError("ProductDBTest failed");


            }

        }
        [TestCase]
        public class WebDBTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("WebDBTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(reportingXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "webdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("WebDBTest passed");
                else
                    LogError("WebDBTest failed");


            }

        }
        [TestCase]
        public class ReportingDBTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("ReportingDBTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(reportingXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "reportingdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("ReportingDBTest passed");
                else
                    LogError("ReportingDBTest failed");


            }

        }
        [TestCase]
        public class ReportSSISDBTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("ReportSSISDBTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(reportingXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "reportssisdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("ReportSSISDBTest passed");
                else
                    LogError("ReportSSISDBTest failed");


            }

        }
        [TestCase]
        public class CoreCatalogdbTest : ReplicationTestBase
        {
            protected override void Execute()
            {
                LogInfo("CoreCatalogdbTest is starting............");
                ResultCode = TEST_RESULTS.PASSED;

                bool bResult = true;

                XmlDocument xmlDoc;
                XmlNodeList xmlList;

                xmlDoc = new XmlDocument();
                xmlDoc.Load(corecatalogXML);

                if (0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup").Count ||
                    0 == xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup/Replication").Count)
                {
                    LogError("Unable to find any replication objects to create. Are you using a valid XML file?");
                    return;
                }

                xmlList = xmlDoc.SelectNodes("/ReplicationTopology/ReplicationGroup");
                foreach (XmlNode xNode in xmlList)
                {
                    bResult = VerifyTableCount(xNode, "corecatalogdb");
                    if (bResult == false)
                        break;
                }

                if (bResult == true)
                    LogSuccess("CoreCatalogdbTest passed");
                else
                    LogError("CoreCatalogdbTest failed");


            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTargetTest\replication\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_replicationfvt_none_12.4.56.0_none_85b328d620e82693
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=replicationfvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.manifest
XP_MANIFEST_PATH=manifests\msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.cat
XP_CATALOG_PATH=manifests\msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb.cat
XP_PAYLOAD_PATH=msil_replicationfvt_no-public-key_12.4.56.0_x-ww_afa44efb
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=replicationfvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\CleanserFVTSuite.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;
using System.Management;
using System.ServiceProcess;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.config;



namespace CleanserFVT
{
   

    /// <summary>
    /// Test group for verifying the file logging of the cleanser is correct. Contains shared code etc.
    /// </summary>
    [TestGroup, Owner("pedrofv"), TestFrequency("Regression"), EnvRequirement("DVT")]
    public partial class CleanserFVTGroup : TestNode
    {

        static Report log = new Report("CleanserMessageFunctionalTest");
        static float SERVICE_RESPONSE_TIMEOUT = 60.0f; //Seconds
        static int FILEWAITSLEEPTIME = 60000; //ms

        #region sharedcode
        /// <summary>
        /// Pull the cleanser log directory from NPDB and return it
        /// </summary>
        /// <param name="machine"></param>
        /// <returns></returns>
        private static string GetCleanserDataLogUNC(string machine)
        {
            string logRoot = Config.GetSetting(Setting.setup_logroot);
            string ConfigString = Config.GetSetting(Setting.cleanser_log_target);


            ConfigString = ConfigString.Replace("#LOGROOT#", logRoot);
            ConfigString = ConfigString.Replace("#COMPONENT#", "cleanser");

            //find the location of #NEWLOGPREFIX# and take the substring up to that for the log directory
            int rootLoc = ConfigString.IndexOf("#NEWLOGPREFIX#", 0);
           
            Debug.Assert(rootLoc > 0);

            string logRootUNC = ConfigString.Substring(0, rootLoc);
            logRootUNC = logRootUNC.Replace(":", "$");      //UNC-ify this so it works with UNC paths

            int pathStart = logRootUNC.IndexOf("$") - 1;    //Take 1 off to ensure we keep the drive letter

            Debug.Assert(pathStart > 0);

            logRootUNC = logRootUNC.Remove(0, pathStart);


            logRootUNC = string.Format(@"\\{0}\{1}", machine, logRootUNC);

            return logRootUNC;
        }


        /// <summary>
        /// Returns the file system/real prefix of a message from the enumeration
        /// </summary>
        /// <param name="type"></param>
        private static string GetMessagePrefixFilesystemName(MessageType type)
        {
            string prefix = type.ToString();

            //Build a list of messages who's enumeration name is different from the actual prefix. This happens since
            //enum keys are not allowed to contain '-' whereas prefixes do in fact contain them
            Dictionary<MessageType, string> specialMessages = new Dictionary<MessageType, string>();
            specialMessages.Add(MessageType.LSA_BAN_CL, "LSA-BAN_CL");
            specialMessages.Add(MessageType.LSA_BAN_VW, "LSA-BAN_VW");
            specialMessages.Add(MessageType.LSA_MP_P, "LSA-MP_P");
            specialMessages.Add(MessageType.LSA_FU, "LSA-FU");
            specialMessages.Add(MessageType.LS_DHW, "LS-DHW");
            specialMessages.Add(MessageType.LS_BAN_VW, "LS-BAN_VW");
            specialMessages.Add(MessageType.LS_BAN_CL, "LS-BAN_CL");
            specialMessages.Add(MessageType.LS_MP_P, "LS-MP_P");
            specialMessages.Add(MessageType.LS_FU, "LS-FU");
            specialMessages.Add(MessageType.GENERICMSG, "GenericHeader");

            if (specialMessages.ContainsKey(type))
            {
                //if this is one of those that has '-'s in it
                prefix = specialMessages[type];
            }

            return prefix;
        }


        private static string GetCleanserLogHeaderLogUNC(string logroot, MessageType type)
        {

            DateTime now = DateTime.Now;
            string year = now.Year.ToString();
            string month = now.Month.ToString();
            string day = now.Day.ToString();
            string prefix = GetMessagePrefixFilesystemName(type);

            return string.Format(@"{0}\{1}\{2}\{3}\{4}", logroot, prefix, year, month, day);

        }


        /// <summary>
        /// Deletes all the data from the cleanser log directory on the target computer
        /// </summary>
        /// <param name="logPath"></param>
        private static void ClearDataOnTarget(string logPath)
        {

            DirectoryInfo di = new DirectoryInfo(logPath);

            if (false == Directory.Exists(logPath))
            {
                log.Warn("Log path: " + logPath + " not found. Assuming it is simply deleted and no file deletion necessary.");
                return;
            }

            //Nuke Subdirectories

            foreach (DirectoryInfo directory in di.GetDirectories())
            {
                try
                {
                    Directory.Delete(directory.FullName, true);
                }
                catch (IOException)
                {
                    log.Info("Problem deleting " + directory.FullName + " as it appreas to be in use. Waiting 15 seconds to retry");
                    Thread.Sleep(15000);

                    //this without another try catch so the test will bomb if this fails
                    Directory.Delete(directory.FullName, true);
                   


                }

            }

            //INV: Should now have an empty data directory (or whatever the data root target in NPDB is)
        }


        private static bool StopCleanserServiceOnTarget(string machine)
        {
            ServiceController sc = new ServiceController("Xbox Live Reporting Cleanser Service", machine);

            if (sc.Status == ServiceControllerStatus.Running)
            {
                sc.Stop();

                try
                {

                    sc.WaitForStatus(ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(SERVICE_RESPONSE_TIMEOUT));

                }
                catch (System.ServiceProcess.TimeoutException)
                {
                    log.Fatal("Unable to stop the cleanser service in " + SERVICE_RESPONSE_TIMEOUT + " seconds!");
                    throw;
                }

            }

            return true;

        }

        private static bool StartCleanserServiceOnTarget(string machine)
        {
            ServiceController sc = new ServiceController("Xbox Live Reporting Cleanser Service", machine);

            

            if (sc.Status != ServiceControllerStatus.Running)
            {
                try
                {
                    sc.Start();

                    sc.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(SERVICE_RESPONSE_TIMEOUT));
                }
                catch (System.ServiceProcess.TimeoutException)
                {
                    log.Fatal("Unable to start the cleanser service in " + SERVICE_RESPONSE_TIMEOUT + " seconds!");
                    throw;
                }
                catch (System.InvalidOperationException ioe)
                {
                    log.Info("Unable to start the cleanser. Current state is: " + sc.Status.ToString() + " " + ioe.ToString() );

                }
            }

            return true;
        }


        #endregion


        public partial class CleanserMessageFunctionalTest : TestBase
        {
           
            //See CleanserMessageFunctionalTest.cs
        }

/* TODO
        public partial class CleanserMessageFidelityTest : TestBase
        {
            //See CleanserMessageFidelityTest.cs
        }

        public partial class FileSizeRolloverFunctionalTest : TestBase
        {
            //See CleanserMessageFidelityTest.cs
        }

        public partial class FileTimeRolloverFunctionalTest : TestBase
        {
            //See CleanserMessageFidelityTest.cs
        }


        public partial class CleanserDroppedLinesFunctionalTest : TestBase
        {
            //See CleanserMessageFidelityTest.cs
        }
 * */

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\CleanserMessageFidelityFunctionalTest.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;
using System.Management;
using System.ServiceProcess;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.mgmt;
using xonline.common.config;


namespace CleanserFVT
{

    public partial class CleanserFVTGroup : TestNode
    {



        /// <summary>
        ///Verifies that each and every message is logged for each message type
        /// </summary>
        [TestCase, Description("Test case that verifies the all messages of all types are sent to cleanser, and logged correctly")]
        public partial class CleanserMessageFidelityFunctionalTest : TestBase
        {

            static MessageGenerator msgGen = null;
            string machine = "";
            const int MESSAGE_COUNT = 1000;   //1000 of each type logged
            Dictionary<string,List<string>> m_sent_messages = null;


            public override void PreRun(RUN_TYPE runType)
            {
                msgGen = MessageGenerator.Instance;
                base.PreRun(runType);
            }


            protected override void Execute()
            {

                string[] szServers = Global.XEnv.GetServerListByInterface(Interface.cleanser);

                if (szServers.Length == 0)
                {
                    log.Fatal("Unable to find the cleanser. Check NPDB");
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                machine = szServers[0];

                log.Info("Cleanser target is: " + machine);

                
                StopCleanserServiceOnTarget(machine);

                log.Info("Cleanser Stopping. Waiting for " + (FILEWAITSLEEPTIME / 1000) + " seconds to release file handles etc");
                Thread.Sleep(FILEWAITSLEEPTIME);

                string path = GetCleanserDataLogUNC(machine);

                ClearDataOnTarget(path);

                StartCleanserServiceOnTarget(machine);

                RandomEx rnd = new RandomEx();

                
                    try
                    {

                        m_sent_messages = new Dictionary<string, List<string>>();

                        foreach (int val in Enum.GetValues(typeof(MessageType)))
                        {
                            
                            MessageType msgType = (MessageType)val;
                            ServiceComponentType ct = msgGen.MessageToServiceComponentType(msgType);
                            CleanserConnection con = new CleanserConnection(CleanserConnectionType.FirstCleanser, ct);

                            List<string> messages = new List<string>();

                            string logline = string.Empty;

                            for (int i = 0; i < MESSAGE_COUNT; ++i)
                            {
                               
                                ulong puid = rnd.GenerateRandomPuid();
                                logline = msgGen.BuildMessage(msgType, puid);
                                con.Send(logline);

                                Thread.Sleep(1);    //slow the send a tiny bit
                               
                                messages.Add(logline);
                                
                            }

                            //stuff the new list and the text version of the message prefix into
                            //our list
                            string[] items = logline.Split('|');

                            m_sent_messages.Add(items[0], messages);

                            if (messages.Count != MESSAGE_COUNT)
                            {
                                string err = string.Format("Messages sent do not euqal what was expected. Actual count for message type {0} is {1}, expected {2}",items[0],messages.Count,MESSAGE_COUNT);
                                log.Error(err);
                            }

                            con.Close();
                        }

                    }
                    catch (SocketException e)
                    {
                        log.Fatal("Unable to communicate with the cleanser. Is the service running on " + machine + "?  " + e.ToString());
                        ResultCode = TEST_RESULTS.FAILED;
                    }


                 
                StopCleanserServiceOnTarget(machine);
                log.Info("Cleanser Stopping. Waiting for " + (FILEWAITSLEEPTIME / 1000) + " seconds to release file handles etc - Post Message Sends");
                Thread.Sleep(FILEWAITSLEEPTIME);

                bool failed = false;
                List<MessageType> failMessages = new List<MessageType>();


                foreach (int val in Enum.GetValues(typeof(MessageType)))
                {
                    
                    MessageType msgType = (MessageType)val;

                    string filepath = GetCleanserLogHeaderLogUNC(GetCleanserDataLogUNC(machine), msgType);
                    DirectoryInfo di = new DirectoryInfo(filepath);

                    string prefix = GetMessagePrefixFilesystemName(msgType);
                    string namePattern = string.Format("*.log", prefix);

                    FileInfo[] rgFiles = null;

                    try
                    {
                        rgFiles = di.GetFiles(namePattern, SearchOption.AllDirectories);
                    }
                    catch (DirectoryNotFoundException de)
                    {
                        log.Error("DirectoryNotFoundException: " + de.ToString() + " Test Failed");
                        failed = true;
                        failMessages.Add(msgType);
                        continue;
                    }
                    catch(Exception e)
                    {
                        log.Fatal("Unknown error enumerating files: " + e.ToString() );
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }

                    if (rgFiles.Length == 0)
                    {
                        log.Fatal("For Message Type '" + msgType.ToString() + "' there was no file created");
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }

 
                    int count = 0;

                    foreach (FileInfo file in rgFiles)
                    {

                        //do a little hueristic for dealing with locked files
                        int retries = 0;
                        while (retries <= 10)
                        {
                            try
                            {
                                retries++;
                                FileStream f = File.OpenRead(file.FullName);
                                f.Close();
                                break;
                            }
                            catch (Exception)
                            {
                                log.Info("Unable to open " + file.FullName + " for read. Trying again. Try " + retries.ToString() + " of 10");
                                Thread.Sleep(1000); //wait one second
                            }

                        }

                        StreamReader rdr = null;
                        FileStream fs = null;
                        try
                        {

                            //rdr = File.OpenText(file.FullName);
                            fs = File.OpenRead(file.FullName);
                            rdr = new StreamReader(fs);


                            while (!rdr.EndOfStream)
                            {
                                string line = rdr.ReadLine();

                                //verify that this log line was in fact sent, and that
                                //each and every field is identical to what was sent, and in the 
                                //right order
                                bool res = VerifyLogLine(line);
                                if (res == false)
                                {
                                    log.Fatal("logline in file does not match what was sent: " + line.ToString());
                                    ResultCode = TEST_RESULTS.FAILED;
                                    return;
                                }

                                count++;
                            }


                        }
                        catch (FileNotFoundException fnf)
                        {
                            log.Fatal(fnf.ToString());
                        }
                        catch (Exception e)
                        {
                            log.Fatal(e.ToString());
                        }
                        finally
                        {
                            rdr.Close();
                            fs.Close();
                        }
                    }

                    if (count != MESSAGE_COUNT)
                    {
                        failed = true;
                        failMessages.Add(msgType);
                        log.Error("Incorrect Line Count for message type: " + msgType.ToString());
                        
                    }


                }

                if (failed)
                {
                    string message = string.Empty;

                    foreach (MessageType s in failMessages)
                    {
                        message += s.ToString() + "\r\n";
                    }

                    log.Fatal("One or more messages are not logging entirely: " + message);
                    ResultCode = TEST_RESULTS.FAILED;

                }
                else
                {
                    ResultCode = TEST_RESULTS.PASSED;
                }

                
                StartCleanserServiceOnTarget(machine);
            }


            /// <summary>
            /// 
            /// </summary>
            /// <param name="line"></param>
            /// <param name="m_sent_messages"></param>
            /// <returns></returns>
            private bool VerifyLogLine(string line)
            {
                string[] items = line.Split('|');

                Debug.Assert(items.Length > 2, "Invalid log line passed to VerifyLogLine");

                string[] choppedItems = new string[items.Length - 1];

                //chop off the first element of the array so it matches the incoming line
                for (int i = 0; i < choppedItems.Length; i++)
                {
                    choppedItems[i] = items[i + 1];
                }


                //find out what type this is (0 and 1 are timestamps)
                string type = choppedItems[0];

               

                List<string> itemsList = m_sent_messages[type];

                Debug.Assert(itemsList != null);

                bool ret = false;

                //go through each item in the list, split it, and find a match
                //TODO: build a hash of some kind for matching purposes if perf is a problem
                foreach (string listLine in itemsList)
                {
                    string[] lineItems = listLine.Split('|');
                    int numLineItems = lineItems.Length;

                    bool[] matching = new bool[numLineItems];

                    if (choppedItems.Length != lineItems.Length)
                    {
                        //obviously not a match :)
                        continue;
                    }

                    for (int i = 0; i < lineItems.Length; i++)
                    {
                        if (choppedItems[i] == lineItems[i])
                        {
                            matching[i] = true;
                        }
                    }

                    bool allMatch = true;
                    for (int k = 0; k < numLineItems; k++)
                    {
                        if (matching[k] == false)
                        {
                            allMatch = false;
                            break;
                        }
                    }

                    if (allMatch == true)
                    {
                        ret = true;
                        break;
                    }
                    
                }

                return ret;
               
            }





        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_cleanserfvt_none_12.4.56.0_none_589737d1188fa314
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cleanserfvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.manifest
XP_MANIFEST_PATH=manifests\msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.cat
XP_CATALOG_PATH=manifests\msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.cat
XP_PAYLOAD_PATH=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cleanserfvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\CleanserMessageFunctionalTest.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;
using System.Management;
using System.ServiceProcess;


using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.mgmt;
using xonline.common.config;

using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;


namespace CleanserFVT
{

    public partial class CleanserFVTGroup : TestNode
    {
 
     

        /// <summary>
        ///This test sends one of each core type of message to the cleanser and ensures that at least one file is created. The fidelity test tests the contents
        /// </summary>
        [TestCase, Owner("pedrofv"), Description("This test sends one of each core type of message to the cleanser and ensures that at least one file is created.")]
        public partial class CleanserMessageFunctionalTest : TestBase
        {
            
            static MessageGenerator msgGen = null;
            string machine = "";

            public override void PreRun(RUN_TYPE runType)
            {
                msgGen = MessageGenerator.Instance;
 	            base.PreRun(runType);
            }


            protected override void Execute()
            {
                
                string[] szServers = Global.XEnv.GetServerListByInterface(Interface.cleanser);

                if (szServers.Length == 0)
                {
                    log.Fatal("Unable to find the cleanser. Check NPDB");
                    ResultCode = TEST_RESULTS.FAILED;
                    return;
                }

                machine = szServers[0];

                log.Info("Cleanser target is: " + machine);

                StopCleanserServiceOnTarget(machine);

                log.Info("Cleanser Stopping. Waiting for " + (FILEWAITSLEEPTIME / 1000) + " seconds to release file handles etc");
                Thread.Sleep(FILEWAITSLEEPTIME);

                string path = GetCleanserDataLogUNC(machine);

                ClearDataOnTarget(path);

                StartCleanserServiceOnTarget(machine);

                RandomEx rnd = new RandomEx();

                try
                {

                    foreach (int val in Enum.GetValues(typeof(MessageType)))
                    {
                        MessageType msgType = (MessageType)val;

                        ulong puid = rnd.GenerateRandomPuid();

                        string logline = msgGen.BuildMessage(msgType, puid);
                        ServiceComponentType ct = msgGen.MessageToServiceComponentType(msgType);

                        CleanserConnection con = new CleanserConnection(CleanserConnectionType.FirstCleanser, ct);
                        con.Send(logline);
                        con.Close();
                    }
                }
                catch (SocketException e)
                {
                    log.Fatal("Unable to communicate with the cleanser. Is the service running on " + machine + "?  " + e.ToString());
                    ResultCode = TEST_RESULTS.FAILED;
                }


                StopCleanserServiceOnTarget(machine);

                log.Info("Waiting " + (FILEWAITSLEEPTIME / 1000) + " seconds for flush and file handle release on host machine...");
                Thread.Sleep(FILEWAITSLEEPTIME);    //sleep 10 seconds

                
                foreach (int val in Enum.GetValues(typeof(MessageType)))
                {
                    MessageType msgType = (MessageType)val;

                    string filepath = GetCleanserLogHeaderLogUNC(GetCleanserDataLogUNC(machine), msgType);
                    DirectoryInfo di = new DirectoryInfo(filepath);

                    string prefix = GetMessagePrefixFilesystemName(msgType);
                    string namePattern = string.Format("*cleanser.{0}*.log",prefix);

                    FileInfo[] rgFiles = di.GetFiles(namePattern, SearchOption.AllDirectories);

                    if (rgFiles.Length == 0)
                    {
                        log.Fatal("For Message Type '" + msgType.ToString() + "' there was no file created");
                        ResultCode = TEST_RESULTS.FAILED;
                        return;
                    }
                    
                }

                StartCleanserServiceOnTarget(machine);

                ResultCode = TEST_RESULTS.PASSED;
            }

        }




        [TestCase, Owner("pedrofv"), Description("use presence to send a friend invite and accept to test C++ component connectivity")]
        public class Cleanser_SND_FVT : TestBase
        {

            protected override void Execute()
            {
                //augment these later in their test suite to test 
                FriendsCommon fc = new FriendsCommon();
                PNUser user1 = fc.CreateUser(true);
                PNUser user2 = fc.CreateUser(true);
                
                user1.AddBuddy(user2);
                user2.AcceptBuddy(user1);

                ResultCode = TEST_RESULTS.PASSED;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\CleanserFVT\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_cleanserfvt_none_12.4.56.0_none_589737d1188fa314
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=cleanserfvt
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.manifest
XP_MANIFEST_PATH=manifests\msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.cat
XP_CATALOG_PATH=manifests\msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0.cat
XP_PAYLOAD_PATH=msil_cleanserfvt_no-public-key_12.4.56.0_x-ww_edf0b8f0
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=cleanserfvt,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_modifyssisdb_none_12.4.56.0_none_0ed65de79342472f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=modifyssisdb
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.manifest
XP_MANIFEST_PATH=manifests\msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.cat
XP_CATALOG_PATH=manifests\msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.cat
XP_PAYLOAD_PATH=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=modifyssisdb,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_modifyssisdb_none_12.4.56.0_none_0ed65de79342472f
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=modifyssisdb
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.manifest
XP_MANIFEST_PATH=manifests\msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.cat
XP_CATALOG_PATH=manifests\msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5.cat
XP_PAYLOAD_PATH=msil_modifyssisdb_no-public-key_12.4.56.0_x-ww_c2a2f2a5
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=modifyssisdb,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\ModifySSISDB\ModifySSISDB.cs ===
using System;
using System.IO;
using System.Threading;
using System.Collections;
using System.Net;
using System.Xml;
using System.Data;
using System.Data.SqlClient;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Database;
using ServerTestFramework.STFLive.Reporting;
using ServerTestFramework.STFLive.Reporting.Tables;

using xonline.common.config;

[assembly: RootNode(typeof(ReportingTestNameSpace.ModifySSISDBSuite))]

namespace ReportingTestNameSpace
{
    /// <summary>
    /// SSISDBSuite
    /// </summary>
    public class ModifySSISDBSuite : TestNode
    {
        public static Report Log = new Report("ModifySSISDBSuite");
    }

    [TestGroup, Owner("PedroFV")]
    public class ModifySSISDBGroup : TestNode
    {
        public static Report Log = new Report("ModifySSISDBGroup");
        public static long[] _bi_users;
        private static  string _szReportSSISDB, _szReportingDB;
        private static  int _iNumOfLoop, _iNumOfUODB;
        private static  int _iInsertRatio_t_users, _iUpdateRatio_t_users;
        private static  int _iInsertRatio_t_machines, _iUpdateRatio_t_machines;
        private static  int _iInsertRatio_t_subscriptions, _iUpdateRatio_t_subscriptions;
        private static  int _iInsertRatio_t_xmsg_user_titles, _iUpdateRatio_t_xmsg_user_titles;
        private static  int _iInsertRatio_t_achievements, _iUpdateRatio_t_achievements;
        private static  int _iInsertRatio_t_user_musicnet_accounts, _iUpdateRatio_t_user_musicnet_accounts;
        private static  int _iUpdateTimeSpanMin,_iUpdateTimeSpanSec;

        /// <summary>
        /// ReadUsers
        /// 
        /// </summary>
        private static void ReadXml(string szXmlFile)
        {
            XmlDocument doc;
            XmlReader reader=null;        

            reader = XmlReader.Create(szXmlFile);
            doc = new XmlDocument();
            doc.Load(reader);

            _szReportSSISDB = ReportingHelper.GetArgumentString(doc, "ReportSSISDB");
            _szReportingDB = ReportingHelper.GetArgumentString(doc, "ReportingDB");
            

            _iNumOfLoop = ReportingHelper.GetArgumentInt(doc, "NumOfLoop");
            _iNumOfUODB = ReportingHelper.GetArgumentInt(doc, "NumOfUODB");
            _iInsertRatio_t_users = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_users") / _iNumOfUODB;
            _iUpdateRatio_t_users = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_users") / _iNumOfUODB;
            _iInsertRatio_t_machines = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_machines") / _iNumOfUODB;
            _iUpdateRatio_t_machines = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_machines") / _iNumOfUODB;
            _iInsertRatio_t_subscriptions = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_subscriptions") / _iNumOfUODB;
            _iUpdateRatio_t_subscriptions = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_subscriptions") / _iNumOfUODB;
            _iInsertRatio_t_xmsg_user_titles = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_xmsg_user_titles") / _iNumOfUODB;
            _iUpdateRatio_t_xmsg_user_titles = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_xmsg_user_titles") / _iNumOfUODB;
            _iInsertRatio_t_achievements = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_achievements") / _iNumOfUODB;
            _iUpdateRatio_t_achievements = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_achievements") / _iNumOfUODB;
            _iInsertRatio_t_user_musicnet_accounts = ReportingHelper.GetArgumentInt(doc, "InsertRatio_t_user_musicnet_accounts") / _iNumOfUODB;
            _iUpdateRatio_t_user_musicnet_accounts = ReportingHelper.GetArgumentInt(doc, "UpdateRatio_t_user_musicnet_accounts") / _iNumOfUODB;
            
            _iUpdateTimeSpanMin = ReportingHelper.GetArgumentInt(doc, "UpdateTimeSpanMin");
            _iUpdateTimeSpanSec = ReportingHelper.GetArgumentInt(doc, "UpdateTimeSpanSec");
        }

            
        /// <summary>
        /// ReadUsers
        /// 
        /// </summary>
        [TestCase]
        public class ReadUsers : TestBase
        {
            protected override void Execute()   
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                Log.Info("ReadUsers is starting.");

                //
                _bi_users = new long[400000];

                FileInfo sourceFile= new FileInfo("SuitesData\\user.txt");
                StreamReader reader = sourceFile.OpenText();
                string szTemp;

                int ii=0;
                
                szTemp = reader.ReadLine();
                while (szTemp != "END")
                {
                    _bi_users[ii++] = Convert.ToInt64(szTemp);
                    
                    szTemp = reader.ReadLine();
                }
                

                Log.Info("ReadUsers is ending.");
            }

        }
        /// <summary>
        /// RunModifySSISDB
        /// 
        /// Insert/Update SSISDB UODB daily tables for 5 hours
        /// </summary>
        [TestCase]
        public class RunModifySSISDB : TestBase
        {
            protected override void Execute()   
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                Log.Info("RunModifySSISDB is starting.");

                // Read from configuration file
                ReadXml("ModifySSISDB.xml");

                // Connect to ReportSSISDB                
                string[] szRdbServers;
                ReportingSSIS ssisdb = new ReportingSSIS();

                szRdbServers = Global.XEnv.GetServerListByInterface(Interface.reportssisdb);
                ssisdb.ConnectToServer(szRdbServers[0], _szReportSSISDB);

                // Connect to ReportingDB                
                ReportingDB rdb = new ReportingDB();

                szRdbServers = Global.XEnv.GetServerListByInterface(Interface.reportingdb);
                rdb.ConnectToServer(szRdbServers[0], _szReportingDB);

                try
                {
                    for(int ii=0; ii<_iNumOfLoop; ii++)
                    {                
                        // Set dtStart
                        DateTime dtStart = DateTime.UtcNow;
                        Log.Info("dtStart : {0}", dtStart);

                        // Generate a base offer id
                        T_base_offers t_base_offers = new T_base_offers();
                        long biBaseOfferId = t_base_offers.AddOneRow(rdb.Connection);

                        //
                        // t_users
                        //
                        T_users t_users = new T_users();

                        long biMaxId = t_users.GetMaxUserPUID(ssisdb.Connection);   
                        long biMinId = t_users.GetMinUserPUID(ssisdb.Connection);   
                        long biIdInsert = biMaxId;   
                        long biIdUpdate = biMinId;   

                        long biNewUserIdStart = biMaxId+1;

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;

                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            for(int kk=0; kk<_iInsertRatio_t_users; kk++)
                            {
                                biIdInsert++;
                                t_users.AddOneRow(Cmd, biIdInsert);   
                            }

                            transaction.Commit();

                            Log.Info("t_users : {0} rows are inserted UserID less than {1}", _iInsertRatio_t_users, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            for(int kk=0; kk<_iUpdateRatio_t_users; kk++)
                            {
                                //biIdUpdate = t_users.FindNextUserID(Cmd, biIdUpdate);
                                t_users.UpdateOneRow(Cmd, _bi_users[jj*_iUpdateRatio_t_users+kk]);   
                                //t_users.UpdateOneRow(Cmd, biIdUpdate);   
                            }

                            transaction.Commit();

                            Log.Info("t_users : {0} rows are updated", _iUpdateRatio_t_users);
                        }

                        //
                        // t_subscriptions
                        //
                        T_subscriptions t_subscriptions = new T_subscriptions();

                        biMaxId = biNewUserIdStart;   
                        //biMaxId = t_subscriptions.GetMaxUserPUID(ssisdb.Connection);   
                        biIdInsert = biMaxId;   

                        biMinId = t_subscriptions.GetMinUserPUID(ssisdb.Connection);   
                        biIdUpdate = biMinId;

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;
                            
                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            for(int kk=0; kk<_iInsertRatio_t_subscriptions; kk++)
                            {
                                t_subscriptions.AddOneRow(Cmd, biIdInsert, biBaseOfferId);
                                biIdInsert++;
                            }

                            transaction.Commit();

                            Log.Info("t_subscriptions : {0} rows are inserted UserID less than {1}", _iInsertRatio_t_subscriptions, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;
                            
                            for(int kk=0; kk<_iUpdateRatio_t_subscriptions; kk++)
                            {
                                //biIdUpdate = t_subscriptions.FindNextUserID(Cmd, biIdUpdate);
                                t_subscriptions.UpdateOneRow(Cmd,  _bi_users[jj*_iUpdateRatio_t_subscriptions+kk]);   
                                //t_subscriptions.UpdateOneRow(Cmd, biIdUpdate);   
                            }

                            transaction.Commit();

                            Log.Info("t_subscriptions : {0} rows are updated", _iUpdateRatio_t_subscriptions);
                        }

/* Removing this since these are not it Fall2006 backup
                        //
                        // t_machines
                        //
                        T_machines t_machines = new T_machines();

                        try
                        {
                            biMaxId = t_machines.GetMaxMachinePUID(ssisdb.Connection);   
                        }
                        catch(Exception e)
                        {
                            if(e.Message.Contains("No data at t_machines"))
                            {
                                biMaxId = 0x0019F00000000000;   
                            }
                            else
                            {
                                throw;
                            }
                            
                        }
                        biIdInsert = biMaxId;   

                        biMinId = t_machines.GetMinMachinePUID(ssisdb.Connection);   
                        biIdUpdate = biMinId;   


                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;
                            
                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;
                            
                            for(int kk=0; kk<_iInsertRatio_t_machines; kk++)
                            {
                                biIdInsert++;
                                t_machines.AddOneRow(Cmd, biIdInsert);   
                            }


                            transaction.Commit();

                            Log.Info("t_machines : {0} rows are inserted less than {1}", _iInsertRatio_t_machines, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            for(int kk=0; kk<_iUpdateRatio_t_machines; kk++)
                            {
                                biIdUpdate = t_machines.FindNextMachineID(Cmd, biIdUpdate);
                                t_machines.UpdateOneRow(Cmd, biIdUpdate);   
                            }


                            transaction.Commit();

                            Log.Info("t_machines : {0} rows are update less than {1}", _iUpdateRatio_t_machines, biIdUpdate);
                        }
*/

                        //
                        // t_xmsg_user_titles
                        //
                        T_xmsg_user_titles t_xmsg_user_titles = new T_xmsg_user_titles();


                        T_titles t_titles = new T_titles();
                        int i_title_id = t_titles.GetOneTitle(rdb.Connection, 2);

                        biIdInsert = biNewUserIdStart;   

                        biMinId = t_xmsg_user_titles.GetMinUserPUID(ssisdb.Connection);   
                        biIdUpdate = biMinId;   

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;
                            
                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;
                            
                            for(int kk=0; kk<_iInsertRatio_t_xmsg_user_titles; kk++)
                            {
                                t_xmsg_user_titles.AddOneRow(Cmd, biIdInsert, i_title_id);   
                                biIdInsert++;
                            }


                            transaction.Commit();
                            
                            Log.Info("t_xmsg_user_titles : {0} rows are inserted UserID less than {1}", _iInsertRatio_t_xmsg_user_titles, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;


                            for(int kk=0; kk<_iUpdateRatio_t_xmsg_user_titles; kk++)
                            {
                                //biIdUpdate = t_xmsg_user_titles.FindNextUserID(Cmd, biIdUpdate);
                                t_xmsg_user_titles.UpdateOneRow(Cmd, _bi_users[jj*_iUpdateRatio_t_xmsg_user_titles+kk]);   
                                //t_xmsg_user_titles.UpdateOneRow(Cmd, biIdUpdate);   
                            }


                            transaction.Commit();

                            Log.Info("t_xmsg_user_titles : {0} rows are updated ", _iUpdateRatio_t_xmsg_user_titles);
                        }

/* Removing this since these are not it Fall2006 backup
                        //
                        // t_achievements
                        //
                        T_achievements t_achievements = new T_achievements();

                        biIdInsert = biNewUserIdStart;   

                        biMinId = t_achievements.GetMinUserPUID(ssisdb.Connection);   
                        biIdUpdate = biMinId;   

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;
                            
                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;
                            
                            for(int kk=0; kk<_iInsertRatio_t_achievements; kk++)
                            {
                                biIdInsert++;
                                t_achievements.AddOneRow(Cmd, i_title_id, biIdInsert, 123);   
                            }


                            transaction.Commit();

                            Log.Info("t_achievements : {0} rows are inserted less than {1}", _iInsertRatio_t_achievements, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;


                            for(int kk=0; kk<_iUpdateRatio_t_achievements; kk++)
                            {
                                biIdUpdate = t_achievements.FindNextUserID(Cmd, biIdUpdate);
                                t_achievements.UpdateOneRow(Cmd, biIdUpdate);   
                            }


                            transaction.Commit();

                            Log.Info("t_achievements : {0} rows are update less than {1}", _iUpdateRatio_t_achievements, biIdUpdate);
                        }

                        //
                        // t_user_musicnet_accounts
                        //
                        T_user_musicnet_accounts t_user_musicnet_accounts = new T_user_musicnet_accounts();

                        biIdInsert = biNewUserIdStart;   

                        biMinId = t_user_musicnet_accounts.GetMinUserPUID(ssisdb.Connection);   
                        biIdUpdate = biMinId;   

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;
                            
                            // Insert 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;
                            
                            for(int kk=0; kk<_iInsertRatio_t_user_musicnet_accounts; kk++)
                            {
                                biIdInsert++;
                                t_user_musicnet_accounts.AddOneRow(Cmd, biIdInsert);   
                            }


                            transaction.Commit();

                            Log.Info("t_user_musicnet_accounts : {0} rows are inserted less than {1}", _iInsertRatio_t_user_musicnet_accounts, biIdInsert);

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            
                            for(int kk=0; kk<_iUpdateRatio_t_user_musicnet_accounts; kk++)
                            {
                                biIdUpdate = t_user_musicnet_accounts.FindNextUserID(Cmd, biIdUpdate);
                                t_user_musicnet_accounts.UpdateOneRow(Cmd, biIdUpdate);   
                            }


                            transaction.Commit();

                            Log.Info("t_user_musicnet_accounts : {0} rows are update less than {1}", _iUpdateRatio_t_user_musicnet_accounts, biIdUpdate);
                        }
*/
/*
                        //
                        // Calculate sleeping time and sleep
                        //
                        DateTime dtEnd = DateTime.UtcNow;
                        Log.Info("dtEnd : {0}", dtEnd);

                        TimeSpan duration = dtEnd.Subtract(dtStart);

                        Log.Info("Loop {0} took {1}:{2}:{3}", ii, duration.Hours, duration.Minutes, duration.Seconds);

    
                        TimeSpan tsLimit = new TimeSpan(0, 20, 0);


                        if(TimeSpan.Compare(duration, tsLimit) > 0)
                        {
                            // Test blocker. Stop this testing.
                            Log.Warn("Duration is bigger than 20 mins");
                            //throw new Exception("Duration is bigger than one hour");
                        }
                        else
                        {
                            TimeSpan tsSleep = tsLimit.Subtract(duration);

                            Log.Info("Sleeping for {0} secs", tsSleep.TotalSeconds);
                            Thread.Sleep(tsSleep);
                        }
*/

                        //
                        // Calculate sleeping time and sleep
                        //
                        DateTime dtEnd = DateTime.UtcNow;
                        Log.Info("dtEnd : {0}", dtEnd);

                        TimeSpan duration = dtEnd.Subtract(dtStart);

                        Log.Info("Loop {0} took {1}:{2}:{3}", ii, duration.Hours, duration.Minutes, duration.Seconds);
                        
                        TimeSpan ts = new TimeSpan(0, _iUpdateTimeSpanMin, _iUpdateTimeSpanSec);

                        if(TimeSpan.Compare(duration, ts) < 0)
                        {
                            TimeSpan tsSleep = ts.Subtract(duration);

                            Log.Info("Sleeping for {0} secs", tsSleep.TotalSeconds);
                            Thread.Sleep(tsSleep);
                        }



                        
                    }
                }
                catch(Exception e)
                {
                    if(e.Message.Contains("Duration is bigger than one hour"))
                    {
                        ResultCode = TEST_RESULTS.FAILED;
                    }
                    else
                    {
                        throw;
                    }
                    
                }
                finally
                {
                    ssisdb.Close();
                }

                Log.Info("RunModifySSISDB is ending.");
            }

           
        }

        /// <summary>
        /// TUsersOnly
        /// 
        /// </summary>
        [TestCase]
        public class TUsersOnly : TestBase
        {
            protected override void Execute()   
            {
                ResultCode = TEST_RESULTS.PASSED;
                
                Log.Info("TUsersOnly is starting.");

                // Read from configuration file
                ReadXml("ModifySSISDB.xml");

                // Connect to ReportSSISDB                
                string[] szRdbServers;
                ReportingSSIS ssisdb = new ReportingSSIS();

                szRdbServers = Global.XEnv.GetServerListByInterface(Interface.reportssisdb);
                ssisdb.ConnectToServer(szRdbServers[0], _szReportSSISDB);

                // Connect to ReportingDB                
                ReportingDB rdb = new ReportingDB();

                szRdbServers = Global.XEnv.GetServerListByInterface(Interface.reportingdb);
                rdb.ConnectToServer(szRdbServers[0], _szReportingDB);

                try
                {
                    for(int ii=0; ii<_iNumOfLoop; ii++)
                    {                
                        // Set dtStart
                        DateTime dtStart = DateTime.UtcNow;
                        Log.Info("dtStart : {0}", dtStart);


                        //
                        // t_users
                        //
                        T_users t_users = new T_users();

                        long biMaxId = t_users.GetMaxUserPUID(ssisdb.Connection);   
                        long biMinId = t_users.GetMinUserPUID(ssisdb.Connection);   
                        long biIdInsert = biMaxId;   
                        long biIdUpdate = biMinId;   

                        long biNewUserIdStart = biMaxId+1;

                        for(int jj=0; jj<_iNumOfUODB; jj++)
                        {                
                            SqlCommand Cmd = ssisdb.Connection.CreateCommand();
                            SqlTransaction transaction;

                            // update 
                            transaction = ssisdb.Connection.BeginTransaction("Transaction");
                            Cmd.Connection = ssisdb.Connection;
                            Cmd.Transaction = transaction;

                            biIdUpdate = 0x0009F00000000000;

                            for(int kk=0; kk<_iUpdateRatio_t_users; kk++)
                            {
                                t_users.UpdateOneRow(Cmd, biIdUpdate);   
                                biIdUpdate++;
                            }

                            transaction.Commit();

                            Log.Info("t_users : {0} rows are updated ", _iUpdateRatio_t_users);
                        }

                        //
                        // Calculate sleeping time and sleep
                        //
                        DateTime dtEnd = DateTime.UtcNow;
                        Log.Info("dtEnd : {0}", dtEnd);

                        TimeSpan duration = dtEnd.Subtract(dtStart);

                        Log.Info("Loop {0} took {1}:{2}:{3}", ii, duration.Hours, duration.Minutes, duration.Seconds);
                        TimeSpan ts = new TimeSpan(0, _iUpdateTimeSpanMin, _iUpdateTimeSpanSec);


                        if(TimeSpan.Compare(duration, ts) < 0)
                        {
                            TimeSpan tsSleep = ts.Subtract(duration);

                            Log.Info("Sleeping for {0} secs", tsSleep.TotalSeconds);
                            Thread.Sleep(tsSleep);
                        }


                    }
                }
                finally
                {
                    ssisdb.Close();
                }

                Log.Info("TUsersOnly is ending.");
            }


           
        }
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\CleanserStress\CleanserStress.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.mgmt;
//using xonline.common.config;
//using xonline.common.sql.sqlclient;
using xonline.common.config;



namespace CleanserStress
{


    public class CleanserLogLine
    {

        private string m_prepuid = "";
        private string m_postpuid = "";

        public string LogLine
        {
            get 
            {
                StringBuilder line = new StringBuilder();
                line.Append(m_prepuid);
                line.Append(GenerateRandomPuid());
                line.Append(m_postpuid);
                return line.ToString(); 
            }
            
        }
        private ServiceComponentType m_compID = ServiceComponentType.Unknown;    //impersonated componentID

        public ServiceComponentType CompID
        {
            get { return m_compID; }
            set { m_compID = value; }
        }

    

        public CleanserLogLine(ServiceComponentType compID, string prepuid,string postpuid)
        {
            m_compID = compID;
            m_prepuid = prepuid;
            m_postpuid = postpuid;
        }

        /// <summary>
        /// Helper function to generate a random puid
        /// </summary>
        /// <returns></returns>
        static string GenerateRandomPuid()
        {
            RandomEx rand = new RandomEx();
            return rand.GenerateRandomPuid().ToString();
        }
    }

    /// <summary>
    /// This test group contains a series of tests for stressing the cleanser/filter mechanism within the reporting system. 
    /// This functionality it destined for obsoletion soon, but having something to test metrics with is important until 
    /// that day arrives.
    /// //
    /// //This class randomizes the puid for each message since messages are bucketed by puid at the cleanser. 
    /// </summary>
   [TestGroup]
    public partial class CleanserStressGroup : TestNode
    {

        //stress traffic to one cleanser
        public partial class SingleCleanserTrafficStress : TestBase
        {
            //See SingleCleanserTrafficStress.cs
        }
       


        //stress traffic to vip
        public partial class CleanserVipTrafficStress : TestBase
        {
            //See CleanserVipTrafficStress.cs
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\obj\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reportingstresstests_none_12.4.56.0_none_75f83b3837a5b4e6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingstresstests
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.manifest
XP_MANIFEST_PATH=manifests\msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.cat
XP_CATALOG_PATH=manifests\msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.cat
XP_PAYLOAD_PATH=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingstresstests,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\CleanserStress\CleanserStressSingleton.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;
using xonline.common.mgmt;
using xonline.common.config;


namespace CleanserStress
{
    //typedef this to simplify useage
    using CleanserConnectionList = List<CleanserConnection>;
    

    /// <summary>
    /// Allows for test cases to easily request message creation and sending without 
    /// mucking with connections, sockets etc.
    /// </summary>
    public sealed class CleanserStressSingleton : IDisposable
    {
        private static volatile bool m_initialized = false;

        private static int MAX_CONNECTIONS = 10;

        private Dictionary<ServiceComponentType, CleanserConnectionList> m_connections = null;

        private static object ConnectionLock = new object();

        //The current connection for each type. Every time someone calls GetConnection this rotates
        //to the next one in the list for the service component specified in GetConnection()
        private Hashtable m_currentConnections = null;


        //Log target for all tests to use
        private Report m_log = null;
        public  Report Log
        {
            get { return m_log; }
            
        }
        
        

        #region Singleton Pattern Impl
       
        private static volatile CleanserStressSingleton m_instance = null;
        private static object SyncRoot = new object();

        private volatile bool disposed = false;

        public static CleanserStressSingleton Instance
        {
            get
            {
                // only create a new instance if one doesn't already exist.
                if (m_instance == null)
                {
                    // use this lock to ensure that only one thread is access
                    // this block of code at once.
                    lock (SyncRoot)
                    {
                        if (m_instance == null)
                        {
                            m_instance = new CleanserStressSingleton();
                            m_initialized = true;

                        }
                    }
                }
                // return instance where it was just created or already existed.
                return m_instance;
            }
        }

        #endregion


        private CleanserStressSingleton()
        {
            lock (this)
            {
                if (m_initialized == true)
                {
                    Debug.Assert(false, "Initialize somehow called twice!");
                    return;
                }

                m_log = new Report("CleanserStress");

                //fire up the requisite connection types
                //TODO Model the topology of prod to simulate the actual ratio of connections from each 
                //server type
                m_connections = new Dictionary<ServiceComponentType, List<CleanserConnection>>();


                //initialize all the lists in our dictionary
                m_connections.Add(ServiceComponentType.Unknown, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.xcbk, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.xbos, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.xuacs, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.stringsvr, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.xstatsfd, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.presence, new CleanserConnectionList());
                m_connections.Add(ServiceComponentType.sg, new CleanserConnectionList());

                //the current round robin counters for each type
                m_currentConnections = new Hashtable();


                //now go through and load up MAX_CONNECTIONS worth of cleanserconnections
                //for each message type. This speeds things up by not needing to create new
                //connection each run
                foreach (ServiceComponentType s in m_connections.Keys)
                {
                    CleanserConnectionList ccl = m_connections[s];

                    for (int i = 0; i < MAX_CONNECTIONS; ++i)
                    {
                        CleanserConnection c = new CleanserConnection(CleanserConnectionType.VipConnection,s);
                        ccl.Add(c);
                    }

                    //set the counter to be 0 for each type
                    m_currentConnections.Add(s, 0);

                }


            }
            
        }
           
            
        /// <summary>
        /// Impliment the IDisposeable interface so we can deterministcally clean 
        /// up all these connections we are making
        /// </summary>
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        // Dispose(bool disposing) executes in two distinct scenarios.
        // If disposing equals true, the method has been called directly
        // or indirectly by a user's code. Managed and unmanaged resources
        // can be disposed.
        // If disposing equals false, the method has been called by the 
        // runtime from inside the finalizer and you should not reference 
        // other objects. Only unmanaged resources can be disposed.
        private void Dispose(bool disposing)
        {

            // Check to see if Dispose has already been called.
            if (!this.disposed)
            {
                if (disposing)
                {

                    foreach(CleanserConnectionList ccl in m_connections.Values)
                    {
                        foreach (CleanserConnection conn in ccl)
                        {

                            if (conn != null)
                            {
                                try
                                {
                                    conn.Close();
                                    
                                }
                                catch (Exception e) 
                                {
                                    m_log.Error("Exception caught trying to close cleanserconnections: " + e.ToString() );
                                }

                            }
                        }

                    }//foreach

                }

            } //if(!disposed)
            disposed = true;



        }

        //do proper finalization
        ~CleanserStressSingleton()
        {
            Dispose(false);

        }


        /// <summary>
        /// Retrieve the next Cleanser Connection for the specified type from the list and then
        /// rotate to the next one for subsequent calls
        /// </summary>
        /// <param name="sct"></param>
        /// <returns></returns>
        public CleanserConnection GetConnection(ServiceComponentType sct)
        {
      
            lock (ConnectionLock)
            {
                ServiceComponentType sourceComponentType = sct;

                //HACKHACK - Remove this once the npdb si_component_id for LICENSE_REQUEST is changed from 13 to 6
                //For some reason right now the componentid is set to 13 in npdb but this is an xbos message...
                if ((int)sourceComponentType == 13) sourceComponentType = ServiceComponentType.xbos;


                CleanserConnection current = null;

                object t = m_currentConnections[sourceComponentType];

                if (t == null)
                {
                    return null;
                }

                int index = (int)t;

                current  = m_connections[sourceComponentType][index];

                index = index + 1;

                //wrap around to bottom of the list again
                if (index == MAX_CONNECTIONS)
                {
                    index = 0;
                }

                m_currentConnections[sourceComponentType] = index;

                return current;

            }

           
        }


        private string GetLogLine(MessageType msgType,ulong puid)
        {
            
                return MessageGenerator.Instance.BuildMessage(msgType, puid);
           
        }

    } //end class declaration




}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("Microsoft(R) Xbox(TM)")]
[assembly:System.Reflection.AssemblyCopyright("Copyright (c) Microsoft Corporation. All rights reserved.")]
[assembly:System.Reflection.AssemblyCompany("Microsoft Corporation")]
[assembly:System.Reflection.AssemblyFileVersion("12.4.56.0")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\objd\i386\_asmid.inc ===
ASSEMBLY_IDENTITY_KEY_FORM=msil_reportingstresstests_none_12.4.56.0_none_75f83b3837a5b4e6
ASSEMBLY_IDENTITY_XP_KEY_FORM=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
ASSEMBLY_IDENTITY_CULTURE=
ASSEMBLY_IDENTITY_NAME=reportingstresstests
ASSEMBLY_IDENTITY_PROCESSOR_ARCHITECTURE=msil
ASSEMBLY_IDENTITY_PUBLIC_KEY=
ASSEMBLY_IDENTITY_PUBLIC_KEY_TOKEN=
ASSEMBLY_IDENTITY_TYPE=
ASSEMBLY_IDENTITY_TYPE_NAME=
ASSEMBLY_IDENTITY_VERSION=12.4.56.0
XP_KEY_FORM=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
XP_MANIFEST_DIRECTORY=manifests
XP_MANIFEST_NAME=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.manifest
XP_MANIFEST_PATH=manifests\msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.manifest
XP_CATALOG_DIRECTORY=manifests
XP_CATALOG_NAME=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.cat
XP_CATALOG_PATH=manifests\msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2.cat
XP_PAYLOAD_PATH=msil_reportingstresstests_no-public-key_12.4.56.0_x-ww_a4eddaa2
_DELAY_SIGN=0
!if [set _ASMIDTOATTRIBS_TLBIMP=]
!endif
CODESIGN_TESTKEY=
_TLBIMP_FLAGS=$(_TLBIMP_FLAGS)  /asmversion:12.4.56.0
_ASSEMBLY_IDENTITY=reportingstresstests,processorArchitecture=msil,version=12.4.56.0,publicKeyToken=neutral
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\CleanserStress\SingleCleanserTrafficStress.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.mgmt;
//using xonline.common.config;
//using xonline.common.sql.sqlclient;
using xonline.common.config;


/*
namespace CleanserStress
{
    public partial class CleanserStressGroup : TestNode
    {
        [StressTest(Priority = 0, TargetTPS = 5000)]
        public partial class SingleCleanserTrafficStress : TestBase
        {
            //See SingleCleanserTrafficStress.cs
        }
    }

}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ReportingTest\Stress\CleanserStress\CleanserVipTrafficStress.cs ===
using System;
using System.IO;
using System.Net;
using System.Text;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Threading;
using System.Net.Sockets;
using System.Collections;
using System.Collections.Generic;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.STFLive.Reporting;


using xonline.common.mgmt;
using xonline.common.config;


namespace CleanserStress
{
    public partial class CleanserStressGroup : TestNode
    {

        /// <summary>
        /// This class makes a good number of connections to the vip and sends all known data types through those connections
        /// in a round robin manner.
        /// </summary>
        [StressTest(Priority = 100, TargetTPS = 3000)]
        public partial class CleanserVipTrafficStress : TestBase
        {

            static RandomEx rand = new RandomEx();
            static object RandSync = new object();

            static MessageGenerator msgGen = null;
            static Report log = new Report("CleanserVipStress");

            CleanserStressSingleton cleanserStress = null;

            Stopwatch s = new Stopwatch();
                    

            private static long GetNextRand()
            {
                lock (RandSync)
                {
                    return rand.Next();
                }
            }

            public override void PreRun()
            {
                try
                {

                    msgGen = MessageGenerator.Instance;
                    cleanserStress = CleanserStressSingleton.Instance;
                    base.PreRun();
                }
                catch (SocketException se)
                {
                    //catch the case where the cleanser is down
                    log.Fatal("Could not connect to cleanser. Is the service running?");
                    log.Fatal(se.ToString());
                    throw;
                }
            }

            protected override void Execute()
            {

                CleanserConnection con = null;
                
                //TODO: Simulate estimated mix ratio (80% presence and session, 20% other)

                long val = GetNextRand() % Enum.GetValues(typeof(MessageType)).Length;

                //get the val-th value
                Array arr = Enum.GetValues(typeof(MessageType));
                MessageType mt = (MessageType)arr.GetValue(val);
                ServiceComponentType ty = msgGen.MessageToServiceComponentType(mt);

                //per Joe's request, no SG messages as we don't import them anyway (componentID 23)
                //TODO: remove SG messages from the profile so this condition is never hit
                while (ty == ServiceComponentType.sg)
                {
                    val = GetNextRand() % Enum.GetValues(typeof(MessageType)).Length;
                    arr = Enum.GetValues(typeof(MessageType));
                    mt = (MessageType)arr.GetValue(val);
                    ty = msgGen.MessageToServiceComponentType(mt);

                }

                ulong puid = rand.GenerateRandomPuid();
                string mess = msgGen.BuildMessage(mt,puid);
                

                //If the cleanserStress singleton was not able to be created, there is a good chance it has to do 
                //with the connections within it not being made (Exception during creation)
                //Should change this object to a create + init model
                if (cleanserStress == null)
                {
                    throw new UnexpectedTestResultException("Unable to get cleanser connection. Is the service running?");
                }

                con = cleanserStress.GetConnection(ty);

                con.Send(mess);
            }

            public override void OneTimeCleanup()
            {
                cleanserStress.Dispose();
                base.OneTimeCleanup();
            }

        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\AttrAliases.cs ===
using System;

namespace ServerTestFramework
{
    /// <summary>
    /// allow an alias for Attribute "[TestCase]" to be "[Test]", like NUnit
    /// Deprecated.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=true)]
    public class TestAttribute : TestCaseAttribute
    {
        public TestAttribute()
        {
            CoreGlobal.RO.Warn("[Test]Attribute is deprecated");
        }
    }

    /// <summary>
    /// allow an alias for Attribute "[TestGroup]" to be "[TestFixture]", like NUnit
    /// Deprecated.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, Inherited=true)]
    public class TestFixtureAttribute : TestGroupAttribute
    {
        public TestFixtureAttribute()
        {
            CoreGlobal.RO.Warn("[TestFixture]Attribute is deprecated");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Report.cs ===
using System;
using System.Text;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Threading;

using ServerTestFramework.Utilities;

#pragma warning disable 420 //CS0420: a reference to a volatile field will not be treated as volatile

namespace ServerTestFramework
{
    public class Report : InfiniteLifetimeMarshalByRefObject
    {
        /// <summary>
        /// Bit flags used for specifying the logging level of a report.
        /// </summary>
        public const uint DEBUG     = 0x1;
        public const uint INFO      = 0x2;
        public const uint WARN      = 0x4;
        public const uint ERROR     = 0x8;
        public const uint FATAL     = 0x10;
        public const uint SUCCESS   = 0x20;

        public const uint FILTER_ALL = DEBUG | INFO | WARN | ERROR | FATAL | SUCCESS;

        /// <summary>
        /// Interfaced needed to a log message sink.
        /// </summary>
        public interface Destination
        {
            void Log(uint level, string path, string message, string testName, System.DateTime date);
        }

        /// <summary>
        /// Interfaced to log many lines at once.  This interface is optional.
        /// </summary>
        public interface BulkDestination: Destination
        {
            void LogBulk(LinkedList<ReportLine> lines);
        }

        /// <summary>
        /// A single line stored from the report output
        /// </summary>
        [Serializable]
        public class ReportLine
        {
            public System.DateTime Date;
            public uint Level;
            public string Path;
            public string Message;
            public string TestName;

            public ReportLine()
            {
            }
            public ReportLine(uint level, string path, string message, string testName, System.DateTime date)
            {
                Date=date;
                Level=level;
                Path=path;
                Message=message;
                TestName=testName;
            }
        }

        /// <summary>
        /// This controls the prefix format of log lines.
        /// Example: "[%level%] [%date%] [%path%] "
        /// </summary>
        public static string GlobalCustomPrefixFormat
        {
            get { return customPrefixFormat; }
            set
            {
                customPrefixFormat=value;
                RecomputeCachedFormat();
            }
        }

        /// <summary>
        /// This controls the format of the date used in loglines, using the standard .NET date format specifiers.  Specifying null will use the system default.
        /// Example: "yyyy'-'M'-'d' 'H':'mm':'ss"
        /// </summary>
        public static string GlobalCustomPrefixDateFormat
        {
            get { return customPrefixDateFormat; }
            set
            {
                customPrefixDateFormat=value;
            }
        }

        //logline format data
        private static string customPrefixFormat="[%level% %date% %path%] ";
        private static string customPrefixDateFormat=null;
        private static string customFormatCached=null;
        private static bool customFormatConainsLevelPrefix=false;

        //converts the original format to a version usable by string.Format() in FormatLogLine().
        private static void RecomputeCachedFormat()
        {
            customFormatCached=customPrefixFormat.Replace("%level%", "{0}").Replace("%date%", "{1}").Replace("%path%", "{2}")+"{3}";
            customFormatConainsLevelPrefix=customPrefixFormat.Contains("%level%");
        }

        // create the root report
        static Report   _Root = new Report();

        Report          _Parent;
        string          _Name;
        LinkedList<Destination> _Destinations = new LinkedList<Destination>();
        object          _DestLock = new object();
        uint            _Filter;

        bool            _QueueToThread = false;
        bool            _QueueThreadEnd = false;
        object          _QueueLock = new object();
        LinkedList<ReportLine> _QueuedLines;
        AutoResetEvent  _QueueThreadBlocker;
        AutoResetEvent  _QueueThreadFinished;
        Thread          _QueueThread;
        volatile int    _QueueDataProcessing = 0;
        volatile int    _LogInProgress = 0;

        LinkedList<Thread> _AdderThreads=null; //threads currently waiting to add data
        object _AdderThreadsLock=null;
        AutoResetEvent _WaitYourTurn=null;

        public string Name
        {
            get {return _Name;}
        }

        public uint Filter
        {
            get {return _Filter;}
        }

        /// <summary>
        /// Get the global root reporting destination.
        /// </summary>
        public static Report GetRoot()
        {
            return _Root;
        }

        // Default constructor only to be called by the static initializer to create the root.
        protected Report()
        {
            _Parent = null;
            _Name = "";
            _Filter = FILTER_ALL;

            //the root queues things for a thread to process
            _QueueToThread = true;
            _QueuedLines = new LinkedList<ReportLine>();
            _QueueThreadBlocker = new AutoResetEvent(true);
            _QueueThreadFinished = new AutoResetEvent(true);
            _WaitYourTurn = new AutoResetEvent(true);
            _AdderThreads = new LinkedList<Thread>(); //only the root maintains a queue
            _AdderThreadsLock=new object();
            _QueueThread=ThreadMaker.CreateThread(LogThreadProc);
            _QueueThread.IsBackground=true;
            _QueueThread.Start();
        }

        /// <summary>
        /// Create a new report that inherits it's properties (minus filter) from
        /// a parent report. Name must be specified for every report seperately.
        /// </summary>
        /// <param name="parent">Report to inherit properties from</param>
        public Report(Report parent, string Name)
        {
            _Parent = parent;
            _Filter = FILTER_ALL;
            _Name = Name;
        }

        /// <summary>
        /// Create a new default style report with a given name and unspecified
        /// category. This report will automatically be attached to the root 
        /// reporting object.
        /// </summary>
        /// <param name="Name">Name of this report.</param>
        public Report(string Name)
        {
            _Parent = Report.GetRoot();
            _Filter = FILTER_ALL;
            _Name = Name;
        }

        /// <summary>
        /// Add a new reporting destination to the internal list of reporters.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol Destination</param>
        public void AddReportDestination(Destination dest)
        {
            lock (_DestLock)
            {
                _Destinations.AddLast(dest);
            }
        }

        /// <summary>
        /// Removeo a new reporting destination by reference.
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol Destination</param>
        public void RemoveReportDestination(Destination dest)
        {
            lock (_DestLock)
            {
                _Destinations.Remove(dest);
            }
        }

        /// <summary>
        /// Returns true if this object contains a reference to a specific reporting destination 
        /// </summary>
        /// <param name="dest">Class conforming to abstract protocol Destination</param>
        public bool ContainsReportDestination(Destination dest)
        {
            if (dest == null)
                return false;

            lock (_DestLock)
            {
                return _Destinations.Contains(dest);
            }
        }

        /// <summary>
        /// Remove all reporting destinations.
        /// </summary>
        public void ResetDestinations()
        {
            lock (_DestLock)
            {
                _Destinations.Clear();
            }
        }

        /// <summary>
        /// Change the level of reporting that will be written.
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void SetLevelFilter(uint filter)
        {
            _Filter = filter;
        }

        /// <summary>
        /// Shortcut to enable only a specific set of filters
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void EnableFilter(uint filter)
        {
            _Filter |= filter;
        }

        /// <summary>
        /// Shortcut to disable only a specific set of filters
        /// </summary>
        /// <param name="filter">Log level bitflags</param>
        public void DisableFilter(uint filter)
        {
            _Filter &= ~filter;
        }

        //
        void Log(uint level, string name, string message, System.DateTime date)
        {
            //we may need to just discard it
            if ((((uint)level&_Filter)==0) || (_Destinations.Count==0 && _Parent==null))
            {
                return;
            }

            try
            {
                System.Threading.Interlocked.Increment(ref _LogInProgress);
                System.Threading.Interlocked.Increment(ref _QueueDataProcessing);

                //fill in the automatic values
                if (date==System.DateTime.MinValue)
                {
                    date=System.DateTime.Now;
                }

                string testName;
                ThreadTracker.GetTest(out testName);
                Thread currentThread=Thread.CurrentThread;

                //we may be able te queue it to a thread and be done with it
                if (_QueueToThread)
                {
                    //put me in line to add my data
                    bool isMyTurn=false;
                    string unexpectedError=null;
                    try
                    {
                        lock (_AdderThreadsLock)
                        {
                            _AdderThreads.AddLast(currentThread);
                            if (_AdderThreads.First.Value==currentThread)
                            {
                                isMyTurn=true;
                            }
                        }

                        //do the add work
                        while (true)
                        {
                            if (isMyTurn)
                            {
                                lock (_QueueLock)
                                {
                                    if (_QueuedLines.Count>250) //if there's already 250 queued, wait for the thread to catch up
                                    {
                                        _QueueThreadBlocker.Set();
                                    }
                                    else //there's room in the queue, so add it
                                    {
                                        _QueuedLines.AddLast(new ReportLine(level, name, message, testName, date));
                                        if (unexpectedError!=null)
                                        {
                                            _QueuedLines.AddLast(new ReportLine(ERROR,"*Report Internal*", unexpectedError, "_", System.DateTime.Now));
                                        }
                                        break;
                                    }
                                }

                                _QueueThreadFinished.WaitOne();
                            }
                            else
                            {
                                lock (_AdderThreadsLock)
                                {
                                    if (_AdderThreads.First.Value==currentThread)
                                    {
                                        isMyTurn=true;
                                    }

                                    if (!_AdderThreads.First.Value.IsAlive)
                                    {
                                        unexpectedError="First thread in the waiting adder queue is not alive.  This should never happen.  Removing it.";
                                        _AdderThreads.RemoveFirst();
                                    }
                                }

                                if (!isMyTurn)
                                {
                                    _WaitYourTurn.WaitOne(new System.TimeSpan(0,0,0,0,5), false);
                                }
                            }
                        }
                    }
                    finally
                    {
                        //next in queue can go now
                        lock (_AdderThreadsLock)
                        {
                            if (_AdderThreads.Count>0)
                            {
                                if (_AdderThreads.First.Value==currentThread)
                                {
                                    _AdderThreads.RemoveFirst();
                                }
                            }
                        }
                        _WaitYourTurn.Set();
                    }

                    //poke the worker
                    _Root._QueueThread.IsBackground=false;
                    _QueueThreadBlocker.Set();
                }
                else
                {
                    //it wasn't queue'd, so we need to handle the line normally
                    if (_Destinations.Count>0)
                    {
                        lock (_DestLock)
                        {
                            foreach (Destination dest in _Destinations)
                            {
                                DoSingleLog(level, Name, message, testName, date, dest);
                            }
                        }
                    }
                }

                //send to parent
                if(_Parent!=null)
                {
                    _Parent.Log(level, name, message, date);
                }
            }
            finally
            {
                System.Threading.Interlocked.Decrement(ref _LogInProgress);
            }
        }

        //handle processing a single line for a single destination
        private void DoSingleLog(uint level, string path, string message, string testName, DateTime date, Destination dest)
        {
            try
            {
                dest.Log(level, path, message, testName, date);
            }
            catch (Exception e)
            {
                string errmsg="Error logging to Report destination "+dest.GetType().ToString()+": "+e;

                //log an error to any debugger, since we can't send a line to the report and recurse on the problem till we blow up
                System.Diagnostics.Debugger.Log(0, "ReportError", errmsg);
            }
        }

        //handle processing a bulk of logs for the Root object
        private void DoBulkLog(LinkedList<ReportLine> lines, BulkDestination dest)
        {
            try
            {
                dest.LogBulk(lines);
            }
            catch (Exception e)
            {
                string errmsg="Error logging to Report bulk destination "+dest.GetType().ToString()+": "+e;

                //log an error to any debugger, since we can't send a line to the report and recurse on the problem till we blow up
                System.Diagnostics.Debugger.Log(0, "ReportError", errmsg);
            }
        }

        //
        public void LogThreadProc()
        {
            LinkedList<ReportLine> localLines=new LinkedList<ReportLine>();

            while (!_QueueThreadEnd)
            {
                _Root._QueueThread.IsBackground=false;
                System.Threading.Interlocked.Increment(ref _QueueDataProcessing);

                //swap our buffer with the main buffer
                lock (_QueueLock)
                {
                    LinkedList<ReportLine> temp=_QueuedLines;
                    _QueuedLines=localLines;
                    localLines=temp;
                }

                //copy the dest list to a local list so we don't have to lock on the list
                //also sort them into bulk destinations and single destinations
                LinkedList<Destination> singleDests=new LinkedList<Destination>();
                LinkedList<BulkDestination> bulkDests=new LinkedList<BulkDestination>();
                lock (_DestLock)
                {
                    foreach(Destination dest in _Destinations)
                    {
                        if (dest is BulkDestination)
                        {
                            bulkDests.AddLast((BulkDestination)dest);
                        }
                        else
                        {
                            singleDests.AddLast(dest);
                        }
                    }
                }

                //process the lines for single targets
                foreach (ReportLine line in localLines)
                {
                    foreach (Destination dest in singleDests)
                    {
                        DoSingleLog(line.Level, line.Path, line.Message, line.TestName, line.Date, dest);
                    }
                }

                //process the lines for bulk targets
                foreach (BulkDestination bdest in bulkDests)
                {
                    DoBulkLog(localLines, bdest);
                }

                localLines.Clear();

                //delay a moment so we don't totally slam targets that do things like steal/lockout the gui thread to do output
                System.Threading.Thread.Sleep(50);

                //go back to sleep
                _QueueThreadFinished.Set();
                _WaitYourTurn.Set();

                lock (_QueueLock)
                {
                    //more could have been added as I did work
                    if (_QueuedLines.Count>0)
                    {
                        continue;
                    }
                    else
                    {
                        _Root._QueueThread.IsBackground=true;
                    }
                }

                _QueueDataProcessing=0;
                _QueueThreadBlocker.WaitOne();
                _QueueThreadBlocker.Reset();
            }
        }

        /// <summary>
        /// Log a message at debug priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Debug(string message)
        {
            Log(DEBUG, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at debug priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Debug(string format, params object[] args)
        {
            Log(DEBUG, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at info priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Info(string message)
        {
            Log(INFO, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at info priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Info(string format, params object[] args)
        {
            Log(INFO, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at warning priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Warn(string message)
        {
            Log(WARN, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at warning priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Warn(string format, params object[] args)
        {
            Log(WARN, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at error priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Error(string message)
        {
            Log(ERROR, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at error priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Error(string format, params object[] args)
        {
            Log(ERROR, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at fatal priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Fatal(string message)
        {
            Log(FATAL, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at fatal priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Fatal(string format, params object[] args)
        {
            Log(FATAL, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// Log a message at success priority.
        /// </summary>
        /// <param name="message">String to send to logs.</param>
        public void Success(string message)
        {
            Log(SUCCESS, _Name, message, System.DateTime.MinValue);
        }

        /// <summary>
        /// Log a message at success priority.
        /// </summary>
        /// <param name="format">Format string applied to objets.</param>
        /// <param name="arguments">Object paramaters to use in format string.</param>
        public void Success(string format, params object[] args)
        {
            Log(SUCCESS, _Name, String.Format(format, args), System.DateTime.MinValue);
        }

        /// <summary>
        /// Formats and timestamps a log line nicely.
        /// </summary>
        public static string FormatLogLine(uint level, string path, string message)
        {
            return FormatLogLine(DateTime.MinValue, level, path, message);
        }
        public static string FormatLogLine(System.DateTime date, uint level, string path, string message)
        {
            if (path==null)
            {
                path="";
            }

            if (message==null)
            {
                message="";
            }

            //build the cached the formater if needed
            if (customFormatCached==null)
            {
                RecomputeCachedFormat();
            }

            //get the level name, if used
            string levelName="";
            if (customFormatConainsLevelPrefix)
            {
                switch(level)
                {
                    case Report.DEBUG:
                        levelName="DBG";
                        break;
                    case Report.INFO:
                        levelName="INF";
                        break;
                    case Report.WARN:
                        levelName="WRN";
                        break;
                    case Report.ERROR:
                        levelName="ERR";
                        break;
                    case Report.FATAL:
                        levelName="FTL";
                        break;
                    case Report.SUCCESS:
                        levelName="SUC";
                        break;
                    default:
                        levelName="???";
                        break;
                }
            }

            //get a string for the date
            string dateString="";
            if (date!=System.DateTime.MinValue)
            {
                if (customPrefixDateFormat==null) //use system default
                {
                    dateString=date.ToString();
                }
                else //custom format
                {
                    dateString=date.ToString(customPrefixDateFormat);
                }
            }

            //format the whole logline.  the cached format uses: 0=level, 1=date, 2=path, 3=message
            string logLine=string.Format(customFormatCached, levelName,  dateString, path, message);
            return logLine;
        }

        /// <summary> Blocks until all loglines currently queued up have been processed. </summary>
        public void BlockUntilQueuedLinesAreProcessed()
        {
            if (this!=GetRoot())
            {
                GetRoot().BlockUntilQueuedLinesAreProcessed();
            }
            else
            {
                const int DeadlockBreakSeconds=10;
                System.DateTime startWaitTime=System.DateTime.UtcNow;

                do
                {
                    if (System.DateTime.UtcNow-startWaitTime>new System.TimeSpan(0, 0, DeadlockBreakSeconds))
                    {
                        CoreGlobal.RO.Warn("BlockUntilQueuedLinesAreProcessed: Still blocked after "+DeadlockBreakSeconds+" seconds, possibly deadlocked.  Aborting block.  A processing count may be wrong, this is unexpected.");
                        break;
                    }

                    _QueueThreadBlocker.Set();
                    WaitHandle.WaitAny(new WaitHandle[]{_QueueThreadFinished, _QueueThreadBlocker}, new System.TimeSpan(0, 0, 0, 0, 50), false);
                } while (_QueueDataProcessing!=0 || _LogInProgress!=0);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\AttrExcepts.cs ===
using System;
using System.Net;

namespace ServerTestFramework
{
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple=false, Inherited=false)]
    public class DescriptionAttribute : Attribute
    {
        protected string desc;
        public string Desc
        {
            get {return desc;}
        }

        public DescriptionAttribute(string desc)
        {
            this.desc = desc;
        }
    }

    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple=false, Inherited=true)]
    public class TestCaseAttribute : Attribute
    {
        public TestCaseAttribute()
        {
        }
        public TestCaseAttribute(int bugID)
        {
            BugID = bugID;
        }
        public TestCaseAttribute(System.Type expectedException)
        {
            ExpectedException = expectedException;
        }
        public TestCaseAttribute(System.Type expectedException, int bugID)
        {
            ExpectedException = expectedException;
            BugID = bugID;
        }
        public TestCaseAttribute (System.Type expectedException, int bugID, string bugDB)
        {
            ExpectedException = expectedException;
            BugID = bugID;
            BugDatabase = bugDB;
        }

        public int BugID = 0;
        public string BugDatabase = null;
        public System.Type ExpectedException = null;
        public int Timeout = System.Threading.Timeout.Infinite;
    }

    /// <summary>
    /// marks a function as a setup method.  These methods are executed
    /// just before a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupSetupAttribute : Attribute
    {
    }

    /// <summary>
    /// marks a function as an tear-down method.  These methods are executed
    /// just after a set of tests are run.
    /// </summary> 
    [AttributeUsage(AttributeTargets.Method)]
    public class TestGroupTearDownAttribute : Attribute
    {
    }

    /// <summary>
    /// Indicates that the node contains a group of other nodes, and is not a test by itself.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public class TestGroupAttribute : Attribute
    {
    }

    /// <summary>
    /// Indicates that a test is to be used for stress.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple=false, Inherited=true)]
    public class StressTestAttribute : Attribute
    {
        public float TargetTPS = 0;
        public float Priority = 0;

        public StressTestAttribute()
        {
        }

        public StressTestAttribute(float priority)
        {
            this.Priority = priority;
        }

        public StressTestAttribute(float priority, float tps)
        {
            this.Priority = priority;
            this.TargetTPS = tps;
        }
    }

    /// <summary>
    /// Indicates that when running a stress test, that each run should occur on a unique instance of the node.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple=false, Inherited=true)]
    public class StressInstantiateAttribute : Attribute
    {
    }

    /// <summary>
    /// This feature should be used to temporarily not run a TestCase or TestGroup. 
    /// This is a better mechanism than commenting out the testCase/testGroup,
    /// since the tests will be compiled with the rest of the code and there is an 
    /// indication at run time that a test is not being run. This insures that tests will not be forgotten.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple=false, Inherited=false)]
    public class IgnoreAttribute : Attribute
    {
        public IgnoreAttribute()
        {
        }

        public IgnoreAttribute(string desc)
        {
        }
    }

    /// <summary>
    /// A generic marker than can be placed on a test or group.  This can be used for filtering or reporting.
    /// A tag string may be of the following forms:
    ///    NameOfTag
    ///    NameOfTag=value
    ///    NameOfTag=value0, value1, etc
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, AllowMultiple = true, Inherited = true)]
    public class TestTagAttribute: Attribute
    {
        public string Tag;
        public string []Values;

        //tag with comma separated value(s) as a parameter
        public TestTagAttribute(string tag, string values)
        {
            Init(tag, values);
        }

        //tag with no parameters or tag followed by = then comma separated value(s)
        public TestTagAttribute(string tag)
        {
            if (!tag.Contains("=")) //simple form without values
            {
                Init(tag, new string[0]);
            }
            else //has one or more values
            {
                //split it into the tag and value halves
                string []parts=tag.Split(new char[]{'='});
                if (parts.Length>2)
                {
                    CoreGlobal.RO.Warn("Invalid TestTagAttribute string, portions beyond the second = will be ignored: "+tag);
                }

                Init(parts[0], parts[1]);
            }
        }

        //tag with a single value, using ToString on an object
        public TestTagAttribute(string tag, object value)
        {
            Init(tag, value.ToString().Replace(",",""));
        }

        //tag with a set of values using ToString on each object
        public TestTagAttribute(string tag, System.Collections.IList values)
        {
            string []stringValues=new string[values.Count];
            for (int i=0; i<values.Count; ++i)
            {
                stringValues[i]=values[i].ToString();
            }

            Init(tag, stringValues);
        }

        //parses comma separated string form
        private void Init(string tag, string values)
        {
            if (values==null)
            {
                Init(tag, new string[0]);
            }
            else
            {
                string []valuesParts=values.Split(new char[]{','});
                Init(tag, valuesParts);
            }
        }

        //stores values into this instance
        private void Init(string tag, string []values)
        {
            Tag=tag.Trim();

            System.Collections.Generic.List<string> valueList=new System.Collections.Generic.List<string>();
            foreach (string v in values)
            {
                string valTrimmed=v.Trim();
                if (valTrimmed.Length>0)
                {
                    valueList.Add(valTrimmed);
                }
            }

            Values=valueList.ToArray();
        }
    }

    /// <summary>
    /// On a test case, tests with the same AsyncGroup value can run at the same time.  On a group this sets the default AsyncGroup value for all tests in that group.
    /// Test groups with the same AsyncSet value can be run at the same time. (AsyncSet has no meaning for a test case)
    /// A value of 0 means don't run async.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=false, AllowMultiple=false)]
    public class AsyncGroupAttribute: Attribute
    {
        //parallel groups
        protected int childrenAsyncGroup=-1;
        public int ChildrenAsyncGroup { get {return childrenAsyncGroup;} }

        //parallel test cases within a group
        protected int asyncGroup;
        public int AsyncGroup { get {return asyncGroup;} }

        protected bool _applyToAllDescendents = false;
        public bool ApplyToAllDescendents { get { return _applyToAllDescendents; } }

        //
        public AsyncGroupAttribute(int group)
        {
            asyncGroup=group;
        }
        public AsyncGroupAttribute(int children, int group)
        {
            asyncGroup=group;
            childrenAsyncGroup=children;
        }
        public AsyncGroupAttribute (int children, int group, bool applyToAllDescendents)
        {
            asyncGroup = group;
            childrenAsyncGroup = children;
            _applyToAllDescendents = applyToAllDescendents;
        }
    };

    /// <summary>
    /// Attribute for a test group for how many threads within the group are allowed to run at the same time.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=false, AllowMultiple=false)]
    public class AsyncThreadCountAttribute: Attribute
    {
        protected uint threadCount;
        public uint ThreadCount { get {return threadCount;} }

        public AsyncThreadCountAttribute(uint tcount)
        {
            threadCount=tcount;
        }
    };

    /// <summary>
    /// Attribute for a test group.  Controls the delay (in ms) between thread creations for tests within the group.
    /// This can be useful for preventing a ton of tests from slamming the network system at the exact same moment.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=false, AllowMultiple=false)]
    public class AsyncThreadDelayAttribute: Attribute
    {
        protected uint threadDelay;
        public uint ThreadDelay { get {return threadDelay;} }

        public AsyncThreadDelayAttribute(uint tdelay)
        {
            threadDelay=tdelay;
        }
    };

    /// <summary>
    /// Attribute for groups and cases.  This specifies that the test case should never be automatically retried if it fails.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=true, AllowMultiple=false)]
    public class DoNotRetryAttribute: Attribute
    {
    };

    /// <summary>
    /// Attribute for groups and cases.  Each instance of CompoundTestBase class that use this will cause multiple instances of TestBase's to be created.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, Inherited=false, AllowMultiple=true)]
    public class CompoundCaseAttribute: Attribute
    {
        public string Name;
        public object []Values;
        public int BugID=-1; //override the root test's bug id for a specific instance
        public string BugDatabase = null;
        public int Timeout = System.Threading.Timeout.Infinite;
        public string Tags=""; //Use the following form: "Tag0=Value0;Tag1=Value1,Value2"

        public CompoundCaseAttribute(string name, params object []values)
        {
            Name=name;
            Values = values ?? new object[1] { null };

            try
            {
                // try to treat the name as a format string that gets applied to the input objects
                Name = string.Format(Name, Values);
            }
            catch (FormatException fe)
            {
                // failure should leave the name un-formatted
                CoreGlobal.RO.Warn("Formatting exception encountered on name \"" + Name + "\", defaulting to name as provided: " + fe.ToString());
            }
            catch (ArgumentNullException ane)
            {
                // failure should leave the name un-formatted
                CoreGlobal.RO.Warn("Formatting exception encountered on name \"" + Name + "\", defaulting to name as provided: " + ane.ToString());
            }
        }

        private byte _parsed = 0;
        private double _val;

        internal bool IsNumber
        {
            get
            {
                if (_parsed == 0) { ParseName(); }
                return (_parsed == 1);
            }
        }

        internal double Number
        {
            get
            {
                if (_parsed == 0) { ParseName(); }
                return _val;
            }
        }

        private void ParseName ()
        {
            if (Name == null)
            {
                _parsed = 2;
                return;
            }
            _parsed = (byte)(double.TryParse(Name, out _val) ? 1 : 2);
        }
    };

    /// <summary>
    /// Marks a functional test as not being able to run until a specific other test has run.
    /// The string may be either of:
    /// - The fully-qualified name of a leaf node or the name of a sibling.
    /// - The non-qualified name of a sibling node (does not have to be a leaf).
    /// </summary>
    [AttributeUsage(AttributeTargets.Class|AttributeTargets.Method, Inherited=false, AllowMultiple=true)]
    public class RunDependencyAttribute: Attribute
    {
        public string Dependency;

        public RunDependencyAttribute(string depends)
        {
            Dependency=depends;
        }
    };

    /// <summary>
    /// Indicates that the node is a test group, and that all direct sub-nodes must all be either enabled or disabled.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public class AtomicBranchAttribute: Attribute
    {
    }

    /// <summary>
    /// This attribute can be placed on the assembly to declare a single group node that is to become the root of the assembly's tree.
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple=false)]
    public class RootNodeAttribute: Attribute
    {
        public Type RootType;
        public RootNodeAttribute(Type typeOfRootNode)
        {
            RootType=typeOfRootNode;
        }
    }

    //
    public class UnexpectedTestResultException : Exception
    {
        public UnexpectedTestResultException() : base() {}
        public UnexpectedTestResultException(string message) : base(message) {}
        public UnexpectedTestResultException(string message, Exception inner) : base(message, inner) {}
    }

    /// <summary>
    /// Custom Excption class to convey excpetions at the test suite load and run states.
    /// Deprecated.
    /// </summary>
    public class TestSuiteException : Exception
    {
        public TestSuiteException( string message) : base(message) {}
        public TestSuiteException( string message, Exception inner) : base(message, inner) {}
    }

    /// <summary>
    /// Custom Exception class to carry and identify failures with an Http Status code
    /// </summary>
    public class HttpStatusCodeException : Exception
    {
        public HttpStatusCode StatusCode; 
        public HttpStatusCodeException( HttpStatusCode code ) : base() { StatusCode = code; }
        public HttpStatusCodeException( HttpStatusCode code, string message) : base(message) { StatusCode = code; }
        public HttpStatusCodeException( HttpStatusCode code, string message, Exception inner) : base(message, inner) { StatusCode = code; }
    }

    /// <summary>
    /// Custom Exception class to identify time out failures
    /// </summary>
    public class TimeOutException : Exception
    {
        public ushort WaitSec; 
        public TimeOutException( ushort waitSec ) : base() { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message) : base(message) { WaitSec = waitSec; }
        public TimeOutException( ushort waitSec, string message, Exception inner) : base(message, inner) { WaitSec = waitSec; }
    }

    /// <summary>
    /// Custom Excption class to carry and identify failures matching a named value.
    /// </summary>
    public class ExpectedValueCheckException : Exception
    {
        public ExpectedValueCheckException(String msg) : base(msg) { }
        public ExpectedValueCheckException(String name, Object expected, Object got)
            : base(String.Format("{0}. Expected: {1}, Got: {2}", name, expected ?? "null", got ?? "null")) { }
    }

    /// <summary>
    /// Custom Excption class to carry and identify failures matching a named value.
    /// </summary>
    public class ExpectedNotValueCheckException : ExpectedValueCheckException
    {
        public ExpectedNotValueCheckException(String msg) : base(msg) { }
        public ExpectedNotValueCheckException(String name, Object expected, Object got)
            : base(String.Format("{0}. Did not expect: {1}, Got: {2}", name, expected ?? "null", got ?? "null")) { }
    }

    /// <summary>
    /// Generic exception wrapper, allows parameters in the message string. Think of it as
    /// an Exception++.
    /// Deprecated.
    /// </summary>
    public class StfException : Exception
    {
        public StfException(string message) : base(message)
        {

            if (CoreGlobal.RO != null)
            {
                CoreGlobal.RO.Warn("StfException is deprecated.");
                CoreGlobal.RO.Error(message);
            }
        }
        public StfException(string format, params object[] args) : base(String.Format(format, args))
        {
            if (CoreGlobal.RO != null)
            {
                CoreGlobal.RO.Warn("StfException is deprecated.");
                CoreGlobal.RO.Error(format, args);
            }
        }
    }

    /// <summary> If this exception is thrown by a test then the test will be counted as having not been run at all, rather than failed. </summary>
    public class DidNotExecuteException: Exception
    {
        public DidNotExecuteException(string message): base(message) {}
        public DidNotExecuteException(string message, Exception inner): base(message, inner) {}
    }

    /// <summary>
    /// This exception should be thrown when a test encounters conditions that indicate a known bug.
    /// </summary>
    public class KnownBugException : Exception
    {
        /// <summary>The default message format string.</summary>
        private const string DefaultMessageFormat = "A known bug was identified [{0} {1}]";

        /// <summary>The string to use if the bug database is null.</summary>
        private const string EmptyBugDatabase = "<Unknown>";

        /// <summary>
        /// Gets the default message for a KnownBugException.
        /// </summary>
        protected static string GetDefaultMessage (int bugID, string bugDatabase)
        {
            return string.Format(DefaultMessageFormat, bugDatabase ?? EmptyBugDatabase, bugID);
        }

        /// <summary>The bug identifier; ex the PS bug number.</summary>
        public int BugID
        {
            get;
            set;
        }

        /// <summary>The bug database name; ex the PS database.</summary>
        public string BugDatabase
        {
            get;
            set;
        }

        /// <summary>
        /// Creates a KnownBugException from a bug id and database.
        /// </summary>
        public KnownBugException (int bugID, string bugDatabase)
            : this(bugID, bugDatabase, GetDefaultMessage(bugID, bugDatabase), null) { }

        /// <summary>
        /// Creates a KnownBugException from a bug id and database, with a custom message.
        /// </summary>
        public KnownBugException (int bugID, string bugDatabase, string message)
            : this(bugID, bugDatabase, message, null) { }

        /// <summary>
        /// Creates a KnownBugException from a bug id and database, with an inner exception.
        /// </summary>
        public KnownBugException (int bugID, string bugDatabase, Exception innerException)
            : this(bugID, bugDatabase, GetDefaultMessage(bugID, bugDatabase), innerException) { }

        /// <summary>
        /// Creates a KnownBugException from a bug id and database, with a custom message and inner exception.
        /// </summary>
        public KnownBugException (int bugID, string bugDatabase, string message, Exception innerException)
            : base(message, innerException)
        {
            BugID = bugID;
            BugDatabase = bugDatabase;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\CoreGlobals.cs ===
namespace ServerTestFramework
{
    public static class CoreGlobal
    {
        // -- public globals


        /// <summary>
        /// The default config file to load.
        /// </summary>
        public static string DefaultConfigFile = "stf.xml";

        /// <summary>
        /// The current config set.
        /// </summary>
        public static ServerTestFramework.Runner.StfXmlDoc Config;

        //
        public delegate void VoidFunctionType();

        /// <summary> Provides a way to request that the current application to discard all TestNode trees and recreate them.  Not all applications support this (in which case they will ignore it). </summary>
        public static event VoidFunctionType ReloadAllTestTrees;

        /// <summary> Calls ReloadAllTestTrees. </summary>
        public static void CallReloadAllTestTrees()
        {
            if (ReloadAllTestTrees!=null)
            {
                ReloadAllTestTrees();
            }
        }

        public class TestNodeTreeSourceInfo
        {
            public System.Reflection.Assembly Assembly;
            public string AssemblyFile;
        }

        public delegate void TestNodeTreePreloadDelegate (TestNodeTreeSourceInfo sourceInfo);

        /// <summary>
        /// Called before a TestNode tree is loaded with information about the source of the tree.
        /// </summary>
        public static event TestNodeTreePreloadDelegate TestNodeTreePreload;

        internal static void OnTestNodeTreePreload (TestNodeTreeSourceInfo sourceInfo)
        {
            if (TestNodeTreePreload != null)
            {
                TestNodeTreePreload(sourceInfo);
            }
        }

        //
        public delegate void VoidTestNodeFunctionType(TestNode root);

        /// <summary> This is called whenever a test tree is created.  Note that if nodes are reloaded, a new tree from the same assembly will likely be passed to this. </summary>
        public static event VoidTestNodeFunctionType TestNodeTreeLoaded;

        /// <summary> Calls TestNodeTreeLoaded. </summary>
        internal static void CallTestNodeTreeLoaded(TestNode root)
        {
            if (TestNodeTreeLoaded!=null)
            {
                TestNodeTreeLoaded(root);
            }
        }

        /// <summary> This is called when all references to a test tree should be removed. </summary>
        public static event VoidTestNodeFunctionType TestNodeTreeUnloaded;

        /// <summary> Calls TestNodeTreeUnloaded to indicate that everything should remove all references to the test node tree. </summary>
        public static void CallTestNodeTreeUnload(TestNode root)
        {
            if (TestNodeTreeUnloaded!=null)
            {
                TestNodeTreeUnloaded(root);
            }
        }

        /// <summary>
        /// Returns the assembly of STFCore.
        /// </summary>
        public static System.Reflection.Assembly GetCoreAssembly()
        {
            return System.Reflection.Assembly.GetExecutingAssembly();
        }

        /// <summary>
        /// Check the versions of other assemblies linked against us, to make sure there's not a mismatch between the version they linked with and our version.
        /// </summary>
        public static void CheckAssemblyVersion(System.Reflection.Assembly asm)
        {
            //get our stfcore version
            System.Reflection.Assembly myAsm=System.Reflection.Assembly.GetExecutingAssembly();
            System.Reflection.AssemblyName myAsmName=myAsm.GetName();
            string ourName="STFCore";

            //check for stf referances
            System.Reflection.AssemblyName []refAsmNames=asm.GetReferencedAssemblies();
            foreach (System.Reflection.AssemblyName rAsmName in refAsmNames)
            {
                if (rAsmName.Name==ourName)
                {
                    if (myAsmName.Version != rAsmName.Version)
                    {
                        CoreGlobal.RO.Warn("Assembly \"" + asm.GetName().Name + "\" was linked against a different version of "+ourName+".dll than the currently loaded version.");
                        CoreGlobal.RO.Warn("This is usually harmless, but it can sometimes result in unusual problems (such as referances to fields or methods that don't exist).");
                        CoreGlobal.RO.Warn(asm.GetName().Name + " linked against "+ourName+".dll version: " + rAsmName.Version);
                        CoreGlobal.RO.Warn(ourName+".dll version currently loaded: " + myAsmName.Version);
                    }
                }

                //try to recurse into that to check it's referances too
                try
                {
                    if (!(rAsmName.Name.StartsWith("System.") || rAsmName.Name=="System" || rAsmName.Name=="WstClient")) //exclude these from recursion
                    {
                        System.Reflection.Assembly recAsm=System.Reflection.Assembly.ReflectionOnlyLoad(rAsmName.Name);
                        CheckAssemblyVersion(recAsm);
                    }
                }
                catch
                { }
            }
        }

        // -- one of these Initialize functions must be called before stf can be used.

        /// <summary>
        /// Load xml config from a file.
        /// </summary>
        public static void Initialize(string fileName)
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config=new ServerTestFramework.Runner.StfXmlDoc(fileName);
            DoInitialize();
        }

        /// <summary>
        /// Initialize the framework using a pre-created XML config document.
        /// </summary>
        public static void Initialize(System.Xml.XmlDocument config)
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config=new ServerTestFramework.Runner.StfXmlDoc();
            Config.Merge(config, "/");
            DoInitialize();
        }

        /// <summary>
        /// Initialize the framework using a pre-created XML config document.
        /// </summary>
        public static void Initialize(ServerTestFramework.Runner.StfXmlDoc config)
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config=config;
            DoInitialize();
        }

        /// <summary>
        /// Initialize the framework using the default config file.
        /// </summary>
        public static void Initialize()
        {
            CheckAssemblyVersion(System.Reflection.Assembly.GetCallingAssembly());
            Config=new ServerTestFramework.Runner.StfXmlDoc(DefaultConfigFile);
            DoInitialize();
        }

        /// <summary> Called to uninitialize the framework. </summary>
        public static void Uninitialize()
        {
            Config=null;
            for (int i=stfUninitFuncs.Count-1; i>=0; --i)
            {
                stfUninitFuncs[i]();
            }
            isInit=false;
        }

        // -- system for handling initialization of all parts of stf

        private static System.Collections.Generic.List<VoidFunctionType> stfInitFuncs=new System.Collections.Generic.List<VoidFunctionType>();
        private static System.Collections.Generic.List<VoidFunctionType> stfUninitFuncs=new System.Collections.Generic.List<VoidFunctionType>();
        private static bool isInit=false;

        /// <summary> Other libraries that depend on STF being initialized can call this to be notified when initialization occurs </summary>
        public static void RegisterInitializationCallback(VoidFunctionType initFunc)
        {
            stfInitFuncs.Add(initFunc);

            //if we are already initialized when this is called, call their callback immediately
            if (isInit)
            {
                initFunc();
            }
        }

        /// <summary> Other libraries that depend on STF being initialized can call this to be notified when initialization occurs </summary>
        public static void RegisterUninitializationCallback(VoidFunctionType uninitFunc)
        {
            stfUninitFuncs.Add(uninitFunc);
        }

        // Internal initialize after we have a valid xml document (CoreGlobal.Config)
        private static void DoInitialize()
        {
            if (isInit)
            {
                return;
            }

            //load core settings
            System.Xml.XmlNodeList coreNodes=Config.GetElementsByTagName("core");
            if (coreNodes!=null && coreNodes.Count>0)
            {
                if (coreNodes.Count>1)
                {
                    RO.Warn("There is more than one <core> section in the configuration file.  All but the first will be ignored.");
                }

                System.Xml.XmlNode coreNode=coreNodes.Item(0);

                //logline prefix format
                System.Xml.XmlNode logFormatNode=coreNode.SelectSingleNode("LogLinePrefix");
                if (logFormatNode!=null)
                {
                    if (logFormatNode.Attributes["LineFormat"]!=null)
                    {
                        Report.GlobalCustomPrefixFormat=logFormatNode.Attributes["LineFormat"].Value;
                    }

                    if (logFormatNode.Attributes["DateFormat"]!=null)
                    {
                        Report.GlobalCustomPrefixDateFormat=logFormatNode.Attributes["DateFormat"].Value;
                        if (Report.GlobalCustomPrefixDateFormat!=null && Report.GlobalCustomPrefixDateFormat.Length==0)
                        {
                            Report.GlobalCustomPrefixDateFormat=null;
                        }
                    }
                }

                //test assembly load method
                System.Xml.XmlNode asmLoadMethodNode=coreNode.SelectSingleNode("LoadAssembliesDirectly");
                if (asmLoadMethodNode!=null)
                {
                    bool defaultToLoadingAssemblyDirectly;
                    if (System.Boolean.TryParse(asmLoadMethodNode.InnerXml, out defaultToLoadingAssemblyDirectly))
                    {
                        ServerTestFramework.Utilities.AssemblyUtils.DefaultToLoadingAssemblyDirectly=defaultToLoadingAssemblyDirectly;
                    }
                }
            }

            //callbacks
            foreach (VoidFunctionType func in stfInitFuncs)
            {
                func();
            }

            isInit=true;
        }

        // -- core-only globals

        //reporting object for the core
        internal static Report RO = new Report("Core");
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\obj\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\ThreadBase.cs ===
using System;
using System.Threading;

namespace ServerTestFramework
{
    /// <summary>
    /// Utility function to just create a System.Thread (this internally updates the thread tracker automatically).
    /// (You must still call .Start() on it like normal)
    /// </summary>
    public class ThreadMaker
    {
        // -- Public

        public delegate void EmptyThreadProcDelegate();
        public delegate void ObjectThreadProcDelegate(object obj);

        //creates a thread with a proc that takes no parameters
        public static System.Threading.Thread CreateThread(EmptyThreadProcDelegate threadProc)
        {
            ThreadProc info=new ThreadProc();
            info.threadTracker = ThreadTracker.GetThreadTrackerData();
            info.isObject=false;
            info.proc=threadProc;
            return new Thread(new ThreadStart(info.Proc));
        }

        //creates a thread with a proc that takes an object as a parameter
        public static System.Threading.Thread CreateThread(ObjectThreadProcDelegate threadProc, object obj)
        {
            ThreadProc info=new ThreadProc();
            info.threadTracker = ThreadTracker.GetThreadTrackerData();
            info.isObject=true;
            info.param=obj;
            info.proc=threadProc;
            return new Thread(new ThreadStart(info.Proc));
        }
        
        // -- Internal

        //local info for the thread, and it's real proc
        private class ThreadProc
        {
            public bool isObject;
            public object proc;
            public object param;

            public object threadTracker;

            public void Proc()
            {
                ThreadTracker.SetThreadTrackerData(threadTracker);

                try
                {
                    if (isObject)
                    {
                        (proc as ObjectThreadProcDelegate)(param);
                    }
                    else
                    {
                        (proc as EmptyThreadProcDelegate)();
                    }
                }
                catch (System.Threading.ThreadAbortException) //from user calling Abort, this is ok
                {
                }
                catch (Exception e) //any other exception is not expected
                {
                    CoreGlobal.RO.Error("ThreadMaker thread crash:\n"+e);
                }
            }
        };
    };


    /// <summary>
    /// Represents a class with a worker thread (this internally updates the thread tracker automatically).
    /// </summary>
    public abstract class ThreadBase
    {
        // thread tracking object of the starting thread
        private object threadTracker;

        //implement this:
        protected abstract void ThreadBody();

        //
        public Thread TaskThread=null;

        //Starts the worker thread.  If it was already running, this request is ignored.
        public virtual void Go()
        {
            if (TaskThread==null || TaskThread.IsAlive==false)
            {
                TaskThread=new Thread(new ThreadStart(TaskThreadStarter));
                threadTracker = ThreadTracker.GetThreadTrackerData();
                TaskThread.Start();
            }
        }

        //Stops the worker thread (raises an abort exception in it)
        public virtual void Stop()
        {
            if (TaskThread != null)
                TaskThread.Abort();
            TaskThread=null;
        }

        //Blocks and waits for the thread to finish running.
        public virtual void Join()
        {
            if (TaskThread != null)
            {
                TaskThread.Join();
            }
            TaskThread=null;
        }

        //return whether the thread is still running.
        public bool IsAlive
        {
            get
            {
                if (TaskThread==null)
                    return false;
                return TaskThread.IsAlive;
            }
        }

        //used internally to call the user thread procedure
        private void TaskThreadStarter()
        {
            //set this thread's tracker data
            ThreadTracker.SetThreadTrackerData(threadTracker);

            //run it
            try
            {
                ThreadBody();
            }
            catch (System.Threading.ThreadAbortException) //from user calling Abort, this is ok
            {
            }
            catch (Exception e) //any other exception is not expected
            {
                string testName;
                ThreadTracker.GetTest(out testName);
                CoreGlobal.RO.Error("ThreadBase worker thread crash, name="+testName+":\n"+e);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\ThreadCaseTracker.cs ===
using System;
using System.Collections.Generic;

namespace ServerTestFramework
{
    /// <summary>
    /// Thread static storage for data that should be used across an individual test case run.
    /// For use and managed by the framework.
    /// </summary>
    public static class ThreadTracker
    {
        // -- Public

        #region Test Case Name Legacy

        //sets which suite/group/case the caller thread belongs to
        public static void SetTest(string fullName)
        {
            Set(TestCaseNameKey, fullName);
        }

        //gets the current test this thread belongs to
        public static void GetTest(out string fullName)
        {
            //if not initialized yet, set to default
            if (!TryGet<string>(TestCaseNameKey, out fullName) || string.IsNullOrEmpty(fullName))
            {
                fullName = DefaultFullName;
            }
        }

        /// <summary>The dictionary key for the current test case full name.</summary>
        public const string TestCaseNameKey = "TestCaseFullName";

        //default name to place unknown threads in
        public static string DefaultFullName="_";

        #endregion

        #region Generic Thread Data

        /// <summary>
        /// Sets a value within the thread tracking data container.
        /// </summary>
        /// <param name="key">The key to use for the value.</param>
        /// <param name="value">The value to associate with the key.</param>
        public static void Set (string key, object value)
        {
            Dictionary<string, object> data = ThreadTrackData;

            lock (data)
            {
                data[key] = value;
            }

            VerboseOutput(key, value);
        }

        /// <summary>
        /// Attempts to get a value out of the thread tracking data container.
        /// </summary>
        /// <typeparam name="T">The type of value that is expected.</typeparam>
        /// <param name="key">The key to use when looking in the container.</param>
        /// <param name="value">The value will be set to this out parameter.</param>
        /// <returns>True if the container has the key; false if it does not.</returns>
        public static bool TryGet<T> (string key, out T value)
        {
            Dictionary<string, object> data = ThreadTrackData;
            bool isThere = false;
            object inThere = null;

            lock (data)
            {
                isThere = data.TryGetValue(key, out inThere);
            }

            // dictionary doesn't have the key
            if (!isThere)
            {
                value = default(T);
                return false;
            }

            // has the key, just doesn't have any data
            if (inThere == null)
            {
                value = default(T);
                return true;
            }

            // check for type compatability
            if (typeof(T).IsAssignableFrom(inThere.GetType()))
            {
                value = (T)inThere;
                return true;
            }

            // value was wrong type
            throw new InvalidCastException("Cannot cast " + inThere.GetType().FullName + " to " + typeof(T).FullName);
        }

        /// <summary>
        /// Attempts to get a value out of the thread tracking data container; if it does not contain the key, 
        /// add it (atomically) using the default value provided.
        /// </summary>
        /// <typeparam name="T">The type of value that is expected.</typeparam>
        /// <param name="key">The key to use when looking in the container.</param>
        /// <param name="value">The value will be set to this out parameter.</param>
        /// <param name="defaultValue">The default value to use if the key is not present in the container.</param>
        /// <returns>True if the container already had the key; false if it did not.</returns>
        public static bool TryGetSetDefault<T> (string key, out T value, T defaultValue)
        {
            Dictionary<string, object> data = ThreadTrackData;
            object inThere = null;

            lock (data)
            {
                if (!data.TryGetValue(key, out inThere))
                {
                    // dictionary doesn't have the key, add it with the default value
                    data.Add(key, defaultValue);
                    value = defaultValue;
                    return false;
                }
            }

            // has the key, just doesn't have any data
            if (inThere == null)
            {
                value = default(T);
                return true;
            }

            // check for type compatability
            if (typeof(T).IsAssignableFrom(inThere.GetType()))
            {
                value = (T)inThere;
                return true;
            }

            // value was wrong type
            throw new InvalidCastException("Cannot cast " + inThere.GetType().FullName + " to " + typeof(T).FullName);
        }

        /// <summary>
        /// Resets the thread tracking data.
        /// </summary>
        public static void Reset ()
        {
            lock (_threadDataCreationLock)
            {
                _threadTrackData = null;
            }
        }

        /// <summary>
        /// Gets the thread tracking data container, for use in passing data to another thread.
        /// </summary>
        /// <returns>The thread tracking data object.</returns>
        public static object GetThreadTrackerData ()
        {
            return ThreadTrackData;
        }

        /// <summary>
        /// Sets the thread tracking data, for use in passing data to another thread.
        /// </summary>
        /// <param name="data">The thread tracking data object.</param>
        public static void SetThreadTrackerData (object data)
        {
            if (data == null)
            {
                throw new ArgumentNullException("data");
            }

            if (typeof(Dictionary<string, object>) != data.GetType())
            {
                throw new ArgumentException("Argument is the wrong type", "data");
            }

            lock (_threadDataCreationLock)
            {
                if (_threadTrackData != null)
                {
                    throw new InvalidOperationException("Cannot set the thread tracking data, it has already been initialized.");
                }

                _threadTrackData = (Dictionary<string, object>)data;
            }
        }

        #endregion

        // -- Internal

        /// <summary>Keeps dictionary creation thread safe.</summary>
        private static object _threadDataCreationLock = new object();

        /// <summary>Backing for ThreadTrackData.</summary>
        [ThreadStatic]
        private static Dictionary<string, object> _threadTrackData;

        /// <summary>
        /// The thread tracking data dictionary.
        /// </summary>
        private static Dictionary<string, object> ThreadTrackData
        {
            get
            {
                Dictionary<string, object> ans = _threadTrackData;

                if (ans == null)
                {
                    lock (_threadDataCreationLock)
                    {
                        ans = _threadTrackData;

                        if (ans == null)
                        {
                            _threadTrackData = ans = new Dictionary<string, object>();
                        }
                    }
                }

                return ans;
            }
        }

        //Output any changes to debug
        private static void VerboseOutput (string key, object value)
        {
#if false
            Global.RO.Debug(key + " set to: " + value.ToString());
#endif
        }
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\NodeTaggingData.cs ===
using System;
using System.Collections.Generic;
using ServerTestFramework.Utilities;

namespace ServerTestFramework
{
    /// <summary> Manages changing and searching for tags on a node or node tree. </summary>
    public class NodeTaggingData
    {
        private TestNode owner;
        private Dictionary<string, ValueSet> tags=new Dictionary<string, ValueSet>(StringComparer.InvariantCultureIgnoreCase);

        /// <summary> Represents a value of a tag. </summary>
        public class Value: IEquatable<Value>
        {
            public Value(string value)
            {
                initValue=value.Trim();
            }

            public Value(long value)
            {
                initValue=value.ToString();
            }

            public Value(bool value)
            {
                initValue=(value?"true":"false");
            }

            public bool Equals(Value other)
            {
                return initValue.ToLower().Equals(other.initValue.ToLower());
            }

            public long ToInteger()
            {
                try
                {
                    if (initValue.StartsWith("0x") || initValue.StartsWith("0X"))
                    {
                        return unchecked((long)Hexer.fromhex(initValue));
                    }

                    return long.Parse(initValue);
                }
                catch
                {}

                return 0;
            }

            public bool ToBool()
            {
                if (initValue.ToLower().Trim()=="true")
                {
                    return true;
                }

                return false;
            }

            public override string ToString()
            {
                return initValue;
            }

            private string initValue;
        }; //class Value

        /// <summary> A collection of values. </summary>
        public class ValueSet: List<Value> //A HashSet would be better, except Value is a reference type so we gain nothing by using it
        {
            //add all non-duplicates from another set into this set
            public void MergeFrom(ValueSet otherSet)
            {
                foreach (Value val in otherSet)
                {
                    MergeFrom(val);
                }
            }

            public void MergeFrom(Value otherVal)
            {
                if (!ContainsValue(otherVal))
                {
                    Add(otherVal);
                }
            }

            public bool ContainsValue(Value otherVal)
            {
                foreach (Value myVal in this)
                {
                    if (myVal.ToString().ToLower()==otherVal.ToString().ToLower())
                    {
                        return true;
                    }
                }

                return false;
            }
        }; //class ValueSet

        /// <summary> Constructs the list of tags and their values for a node. </summary>
        public NodeTaggingData(TestNode testNodeOwner)
        {
            owner=testNodeOwner;

            object []attr=owner.GetAttributes(typeof(TestTagAttribute));
            for (int i=0; i<attr.Length; ++i)
            {
                TestTagAttribute tta=(TestTagAttribute)attr[i];
                if (!tags.ContainsKey(tta.Tag))
                {
                    tags.Add(tta.Tag, new ValueSet());
                }

                foreach (string val in tta.Values)
                {
                    Value expVal=new Value(val);
                    tags[tta.Tag].MergeFrom(expVal);
                }
            }
        }

        /// <summary> Duplicates the tagging data and assigns a new owner to the duplicate. </summary>
        public NodeTaggingData Clone(TestNode newOwner)
        {
            NodeTaggingData newData=(NodeTaggingData)this.MemberwiseClone();

            //manually duplicate reference types that should not be shared
            newData.owner=newOwner;

            newData.tags=new Dictionary<string, ValueSet>(StringComparer.InvariantCultureIgnoreCase);
            foreach (string key in tags.Keys)
            {
                foreach (Value v in tags[key])
                {
                    newData.AddTagValue(key, v);
                }
            }

            return newData;
        }

#region Add tags and tag values

        /// <summary> Adds a new valueless tag. </summary>
        public void AddTag(string tag)
        {
            AddTagValue(tag, (string)null);
        }

        /// <summary> Adds a new value tag. </summary>
        public void AddTagValue(string tag, string values)
        {
            TestTagAttribute tta=new TestTagAttribute(tag+(values!=null?"="+values:""));

            if (!tags.ContainsKey(tta.Tag))
            {
                tags.Add(tta.Tag, new ValueSet());
            }

            foreach (string val in tta.Values)
            {
                AddTagValue(tta.Tag, new Value(val));
            }
        }

        /// <summary> Adds a new value tag. </summary>
        public void AddTagValue(string tag, Value value)
        {
            if (!tags.ContainsKey(tag))
            {
                tags.Add(tag, new ValueSet());
            }

            tags[tag].MergeFrom(value);
        }

#endregion //Add tags and tag values

#region Retrieve tags and tag values

        /// <summary> Returns a list of all tags and their values that are assigned directly to this node. </summary>
        public Dictionary<string, ValueSet> GetNodeTags()
        {
            return tags;
        }

        /// <summary> Returns a list of tags and their values in this node and all parent nodes. </summary>
        public Dictionary<string, ValueSet> GetAllTrunkTags()
        {
            Dictionary<string, ValueSet> combinedTags=new Dictionary<string, ValueSet>(StringComparer.InvariantCultureIgnoreCase);

            TestNode n=owner;
            while (n!=null)
            {
                Dictionary<string, ValueSet> nodeTags=n.TaggingData.GetNodeTags();
                foreach (string key in nodeTags.Keys)
                {
                    if (!combinedTags.ContainsKey(key))
                    {
                        combinedTags.Add(key, new ValueSet());
                    }

                    foreach (Value v in nodeTags[key])
                    {
                        combinedTags[key].MergeFrom(v);
                    }
                }

                n=n.Parent;
            }

            return combinedTags;
        }

        /// <summary> Returns a list of tags and their values in this node and all child nodes. </summary>
        public Dictionary<string, ValueSet> GetAllBranchTags()
        {
            Dictionary<string, ValueSet> combinedTags=new Dictionary<string, ValueSet>(StringComparer.InvariantCultureIgnoreCase);

            //copy us
            foreach (string key in tags.Keys)
            {
                combinedTags.Add(key, new ValueSet());

                foreach (Value v in tags[key])
                {
                    combinedTags[key].Add(v);
                }
            }

            //copy children
            foreach (TestNode child in owner.Children)
            {
                Dictionary<string, ValueSet> childTags=child.TaggingData.GetAllBranchTags();
                foreach (string key in childTags.Keys)
                {
                    if (!combinedTags.ContainsKey(key))
                    {
                        combinedTags.Add(key, new ValueSet());
                    }

                    foreach (Value v in childTags[key])
                    {
                        combinedTags[key].MergeFrom(v);
                    }
                }
            }

            return combinedTags;
        }

        /// <summary> Returns a list of tags and their values in this node, all parents, and all child nodes. </summary>
        public Dictionary<string, ValueSet> GetAllTreeTags()
        {
            Dictionary<string, ValueSet> combinedTags=GetAllBranchTags();
            Dictionary<string, ValueSet> parentTags=GetAllTrunkTags();

            foreach (string key in parentTags.Keys)
            {
                if (!combinedTags.ContainsKey(key))
                {
                    combinedTags.Add(key, new ValueSet());
                }

                foreach (Value v in parentTags[key])
                {
                    combinedTags[key].MergeFrom(v);
                }
            }

            return combinedTags;
        }

        /// <summary> Walks up the tree (including the current node) and returns the the nearest values for each type of tag. </summary>
        public Dictionary<string, ValueSet> GetNearestTrunkTags()
        {
            Dictionary<string, ValueSet> combinedTags=new Dictionary<string, ValueSet>(StringComparer.InvariantCultureIgnoreCase);

            TestNode n=owner;
            while (n!=null)
            {
                Dictionary<string, ValueSet> nodeTags=n.TaggingData.GetNodeTags();
                foreach (string key in nodeTags.Keys)
                {
                    if (!combinedTags.ContainsKey(key))
                    {
                        combinedTags.Add(key, new ValueSet());

                        foreach (Value v in nodeTags[key])
                        {
                            combinedTags[key].Add(v);
                        }
                    }
                }

                n=n.Parent;
            }

            return combinedTags;
        }

        /// <summary> Returns the values for a tag on a specific node. </summary>
        public ValueSet GetNodeValues(string tagName)
        {
            if (tags.ContainsKey(tagName))
            {
                return tags[tagName];
            }

            return new ValueSet();
        }

        /// <summary> Returns a list of values in this node and all parent nodes for a specific tag name. </summary>
        public ValueSet GetAllTrunkValues(string tagName)
        {
            ValueSet values=new ValueSet();

            TestNode n=owner;
            while (n!=null)
            {
                ValueSet nVals=n.TaggingData.GetNodeValues(tagName);
                foreach (Value v in nVals)
                {
                    values.MergeFrom(v);
                }

                n=n.Parent;
            }

            return values;
        }

        /// <summary> Walks up the tree (including the current node) and returns the values for the first occurance of a tag. </summary>
        public ValueSet GetNearestTrunkValues(string tagName)
        {
            TestNode n=owner;
            while (n!=null)
            {
                ValueSet nVals=n.TaggingData.GetNodeValues(tagName);
                if (nVals.Count!=0)
                {
                    return nVals;
                }

                n=n.Parent;
            }

            return new ValueSet();
        }

        /// <summary> Returns a list of values in this node and all child nodes for a specific tag name. </summary>
        public ValueSet GetAllBranchValues(string tagName)
        {
            ValueSet values=new ValueSet();

            Dictionary<string, ValueSet> childData=GetAllBranchTags();
            if (childData.ContainsKey(tagName))
            {
                return childData[tagName];
            }

            return new ValueSet();
        }

        /// <summary> Returns a list of values in this node, all parent nodes, and all child nodes for a specific tag name. </summary>
        public ValueSet GetAllTreeValues(string tagName)
        {
            ValueSet values=new ValueSet();

            Dictionary<string, ValueSet> childData=GetAllTreeTags();
            if (childData.ContainsKey(tagName))
            {
                return childData[tagName];
            }

            return new ValueSet();
        }

#endregion //Retrieve tags and tag values

#region Expressions

        /// <summary> Thrown when an expression is parsed that is not valid. </summary>
        public class InvalidExpressionException: System.Exception
        {
            public string BadExpression;
            public int BadCharacterStart;
            public int BadCharacterEnd;
            public string ErrorDescription;

            public InvalidExpressionException(string badExp, int badStart, int badEnd, string desc)
            {
                BadExpression=badExp;
                BadCharacterStart=badStart;
                BadCharacterEnd=badEnd;
                ErrorDescription=desc;
            }

            protected string GetBadExpressionPart()
            {
                if (BadExpression.Length==0)
                {
                    return "";
                }
                else if (BadCharacterEnd>BadCharacterStart && BadCharacterStart>=0 && BadCharacterEnd<=BadExpression.Length-1) //a valid range is set
                {
                    return BadExpression.Substring(BadCharacterStart, BadCharacterEnd-BadCharacterStart);
                }
                else //we know the start, have to guess on the rest
                {
                    int middle=BadCharacterStart;
                    if (middle<0)
                    {
                        middle=0;
                    }
                    else if (middle>BadExpression.Length-1)
                    {
                        middle=BadExpression.Length-1;
                    }

                    int start=middle-16;
                    if (start<0)
                    {
                        start=0;
                    }

                    int end=middle+16;
                    if (end>BadExpression.Length-1)
                    {
                        end=BadExpression.Length-1;
                    }

                    string s=BadExpression.Substring(start, middle-start);
                    s+="<HERE>";
                    s+=BadExpression.Substring(middle, end-middle);
                    return s;
                }
            }

            public override string Message
            {
                get { return "Error parsing at character "+BadCharacterStart+": "+ErrorDescription+"\nBad part:"+GetBadExpressionPart()+"\nFull Expression: "+BadExpression; }
            }
        }

        /// <summary> Thrown when an expression cannot be evaluated. </summary>
        public class ExpressionEvaluationException: InvalidExpressionException
        {
            public override string Message
            {
                get { return "Error evaluating at character "+BadCharacterStart+": "+ErrorDescription+"\nBad part:"+GetBadExpressionPart()+"\nFull Expression: "+BadExpression; }
            }

            public ExpressionEvaluationException(string badExp, int badStart, int badEnd, string desc): base(badExp, badStart, badEnd, desc)
            {
            }
        }

        public enum ExpressionType
        {
            Tags, //One or more tag names are stored in this
            Values, //Values represents the value of this expression
            BoolBinaryOperations, //Parameters are 1 or more expressions separated by Parameters.Length-1 Operators, all return bool
            BoolUnaryOperation, //Parameters[0] is an expression with Operator[0] applied, all bool
            TagsFunction, //this is a function call that returns one or more tag names
            ValuesFunction, //this is a function call that returns one or more values
            BoolFunction, //this is a function call that returns a bool
            Invalid
        };

        /// <summary> An expression that can be evaluated. </summary>
        public class Expression
        {
            private ExpressionType type=ExpressionType.Invalid;
            private Expression []parameters;
            private Delegate []Operations; //function delegates
            private string []Tags;
            private ValueSet Values;

            private string sourceString="";
            private int sourceStringStart;
            private int sourceStringEnd;

            //accessors
            public ExpressionType Type
            {
                get { return type; }
            }

            public Expression[] Parameters
            {
                get { return parameters; }
            }

            public string SourceString
            {
                get { return sourceString; }
            }

            public int SourceStringStart
            {
                get { return sourceStringStart; }
            }

            public int SourceStringEnd
            {
                get { return sourceStringEnd; }
            }

            //constructors
            public Expression(string str)
            {
                ParseExpressionSequence(str, 0, str.Length);
            }

            private Expression()
            {
            }

            //
            private void CopyFrom(Expression other)
            {
                type=other.Type;
                parameters=other.Parameters;
                Operations=other.Operations;
                Tags=other.Tags;
                Values=other.Values;

                sourceString=other.sourceString;
                sourceStringStart=other.sourceStringStart;
                sourceStringEnd=other.sourceStringEnd;
            }

            private void ParseExpressionSequence(string str, int start, int end)
            {
                sourceString=str;
                sourceStringStart=start;
                sourceStringEnd=end;

                //
                bool expressionNext=true; //whether the next piece must be an expression

                int pos=start;
                int chunkStart=start, chunkEnd=start;

                //parse it all into temporary lists
                List<Expression> workingParameters=new List<Expression>();
                List<Delegate> operations=new List<Delegate>();

                type=ExpressionType.BoolBinaryOperations; //will be this unless it's a single expression, which will override the type

                while (true)
                {
                    pos=chunkEnd; //continue after the last piece that was found

                    //grab a chunk
                    GetNextChunk(str, pos, end, out chunkStart, out chunkEnd);

                    //check if it's the end
                    if (chunkStart==chunkEnd)
                    {
                        if (!expressionNext)
                        {
                            break;
                        }
                        else
                        {
                            throw new InvalidExpressionException(str, chunkStart, chunkEnd, "Unexpected end of expression");
                        }
                    }
                    string chunk=str.Substring(chunkStart, chunkEnd-chunkStart);

                    //see what we got
                    BoolBinaryOperatorDelegate binOp=FindBinaryOperator(chunk);
                    if (expressionNext) //expression
                    {
                        if (binOp!=null)
                        {
                            throw new InvalidExpressionException(str, chunkStart, chunkEnd, "Unexpected binary operator.");
                        }

                        Expression exp=new Expression();
                        exp.ParseSingleExpression(str, chunkStart, end, out chunkEnd);
                        workingParameters.Add(exp);

                        expressionNext=false;
                    }
                    else //binary operator
                    {
                        if (binOp==null)
                        {
                            throw new InvalidExpressionException(str, chunkStart, chunkEnd, "Expected binary operator or end of expression.");
                        }

                        operations.Add(binOp);

                        expressionNext=true;
                    }
                }

                //convert the temporary lists to arrays
                parameters=workingParameters.ToArray();
                Operations=operations.ToArray();

                if (Operations.Length==0 && Parameters.Length==1) //rather than making a dummy pass through entry, move the one parameter expression to ourself
                {
                    CopyFrom(Parameters[0]);
                }
            }

            private void ParseSingleExpression(string str, int start, int end, out int foundEnd)
            {
                sourceString=str;
                sourceStringStart=start;
                sourceStringEnd=end;

                //grab a chunk
                int chunkStart=start, chunkEnd=start;
                GetNextChunk(str, start, end, out chunkStart, out chunkEnd);

                //check if it's the end
                if (chunkStart==chunkEnd)
                {
                    throw new InvalidExpressionException(str, chunkStart, chunkEnd, "An empty expression is not valid here");
                }
                string chunk=str.Substring(chunkStart, chunkEnd-chunkStart);
                string lowerChunk=chunk.ToLower();

                //check if it's a group
                if (chunk[0]=='(')
                {
                    Expression tempGroup=new Expression();
                    tempGroup.ParseExpressionSequence(str, chunkStart+1, chunkEnd-1);
                    CopyFrom(tempGroup);
                    foundEnd=chunkEnd;
                    return;
                }

                //check if we got a unary operator
                BoolUnaryOperatorDelegate unaryOp=FindBoolUnaryOperator(chunk);
                if (unaryOp!=null)
                {
                    type=ExpressionType.BoolUnaryOperation;

                    Operations=new Delegate[1];
                    Operations[0]=unaryOp;

                    parameters=new Expression[1]{new Expression()};
                    parameters[0].ParseSingleExpression(str, chunkEnd, end, out foundEnd);
                    return;
                }

                //check if this is a bool function name
                if (BoolFunctionDictionary.ContainsKey(lowerChunk))
                {
                    FunctionInformation boolFunc=BoolFunctionDictionary[lowerChunk];
                    type=ExpressionType.BoolFunction;

                    Operations=new Delegate[1];
                    Operations[0]=boolFunc.CallFunction;

                    //parse parameters then validate the parameters work for this function
                    int paramStart, paramEnd;
                    GetNextChunk(str, chunkEnd, end, out paramStart, out paramEnd);
                    if (paramStart==paramEnd || str[paramStart]!='(')
                    {
                        throw new InvalidExpressionException(str, chunkEnd, end, "Expected '('");
                    }

                    parameters=ParseCommaSeparatedExpressions(str, paramStart+1, paramEnd-1);
                    boolFunc.ValidationFunction(Parameters, str, chunkStart, paramEnd);

                    foundEnd=paramEnd;
                    return;
                }

                //check if this is a values function name
                if (ValuesFunctionDictionary.ContainsKey(lowerChunk))
                {
                    FunctionInformation valuesFunc=ValuesFunctionDictionary[lowerChunk];
                    type=ExpressionType.ValuesFunction;

                    Operations=new Delegate[1];
                    Operations[0]=valuesFunc.CallFunction;

                    //parse parameters then validate the parameters work for this function
                    int paramStart, paramEnd;
                    GetNextChunk(str, chunkEnd, end, out paramStart, out paramEnd);
                    if (paramStart==paramEnd || str[paramStart]!='(')
                    {
                        throw new InvalidExpressionException(str, chunkEnd, end, "Expected '('");
                    }

                    parameters=ParseCommaSeparatedExpressions(str, paramStart+1, paramEnd-1);
                    valuesFunc.ValidationFunction(Parameters, str, chunkStart, paramEnd);

                    foundEnd=paramEnd;
                    return;
                }

                //check if this is a value declaration
                if (chunk.ToLower()=="val")
                {
                    int paramStart, paramEnd;
                    GetNextChunk(str, chunkEnd, end, out paramStart, out paramEnd);
                    if (paramStart==paramEnd || str[paramStart]!='(')
                    {
                        throw new InvalidExpressionException(str, chunkEnd, end, "Expected '('");
                    }

                    type=ExpressionType.Values;
                    string []vals=ParseCommaSeparatedStrings(str, paramStart+1, paramEnd-1);
                    if (vals.Length==0)
                    {
                        throw new InvalidExpressionException(str, paramStart+1, paramEnd-1, "value declarator must contain at least one value");
                    }

                    Values=new ValueSet();
                    foreach (string v in vals)
                    {
                        Values.Add(new Value(v));
                    }

                    foundEnd=paramEnd;
                    return;
                }

                //check if it's a tag name declaration
                if (chunk.ToLower()=="tag")
                {
                    int paramStart, paramEnd;
                    GetNextChunk(str, chunkEnd, end, out paramStart, out paramEnd);
                    if (paramStart==paramEnd || str[paramStart]!='(')
                    {
                        throw new InvalidExpressionException(str, chunkEnd, end, "Expected '('");
                    }

                    type=ExpressionType.Tags;
                    Tags=ParseCommaSeparatedStrings(str, paramStart+1, paramEnd-1);
                    if (Tags.Length==0)
                    {
                        throw new InvalidExpressionException(str, paramStart+1, paramEnd-1, "tag declarator must contain at least one name");
                    }

                    foundEnd=paramEnd;
                    return;
                }

                //it didn't match anything known
                throw new InvalidExpressionException(str, chunkStart, chunkEnd, "Unknown function or operator: "+chunk);
            }

            private static Expression[] ParseCommaSeparatedExpressions(string str, int start, int end)
            {
                //find the pieces
                int stringCount;
                int []stringStarts;
                int []stringEnds;
                ParseCommaSeparatedStrings(str, start, end, out stringCount, out stringStarts, out stringEnds);

                //process all the pieces
                List<Expression> expressions=new List<Expression>();

                for (int s=0; s<stringCount; ++s)
                {
                    Expression exp=new Expression();
                    exp.ParseExpressionSequence(str, stringStarts[s], stringEnds[s]);
                    expressions.Add(exp);
                }

                return expressions.ToArray();
            }

            private static string[] ParseCommaSeparatedStrings(string str, int start, int end)
            {
                int stringCount;
                int []stringStarts;
                int []stringEnds;
                ParseCommaSeparatedStrings(str, start, end, out stringCount, out stringStarts, out stringEnds);

                List<string> strings=new List<string>();

                for (int s=0; s<stringCount; ++s)
                {
                    strings.Add(str.Substring(stringStarts[s], stringEnds[s]-stringStarts[s]));
                }

                return strings.ToArray();
            }

            private static void ParseCommaSeparatedStrings(string str, int start, int end, out int outStringCount, out int []outStringStarts, out int []outStringEnds)
            {
                //empty list is ok here
                int chunkStart=start, chunkEnd=start;
                GetNextChunk(str, start, end, out chunkStart, out chunkEnd);
                if (chunkStart==chunkEnd)
                {
                    outStringCount=0;
                    outStringStarts=new int[0];
                    outStringEnds=new int[0];
                    return;
                }

                //process all the pieces
                List<int> stringStarts=new List<int>();
                List<int> stringEnds=new List<int>();

                int pos=start;
                while (pos<end)
                {
                    int paramEnd=FindNextComma(str, pos, end);

                    stringStarts.Add(pos);
                    stringEnds.Add(paramEnd);

                    if (str[paramEnd]==',') //verify that this is not a dangling comma
                    {
                        GetNextChunk(str, paramEnd+1, end, out chunkStart, out chunkEnd);
                        if (chunkStart==chunkEnd)
                        {
                            throw new InvalidExpressionException(str, paramEnd, end, "Expected expression after ','");
                        }
                    }

                    pos=paramEnd+1; //skip the comma
                }

                outStringCount=stringStarts.Count;
                outStringStarts=stringStarts.ToArray();
                outStringEnds=stringEnds.ToArray();
            }

            private static void GetNextChunk(string str, int inputStart, int inputEnd, out int foundStart, out int foundEnd)
            {
                if (inputStart>inputEnd)
                {
                    inputStart=inputEnd;
                }

                foundStart=SkipWhiteSpace(str, inputStart, inputEnd);
                foundEnd=foundStart;
                if (foundStart==inputEnd)
                {
                    return;
                }

                if (str[foundStart]=='(') //sub-expression
                {
                    foundEnd=FindMatchingCloseBracket(str, foundStart, inputEnd);
                }
                else //normal search
                {
                    bool isCharacterString=false;
                    bool isSymbolString=false;

                    for (foundEnd=foundStart; foundEnd<inputEnd; ++foundEnd)
                    {
                        if (IsWhiteSpace(str[foundEnd])) //end of chunk
                        {
                            return;
                        }
                        else if (IsValidAlphaNumeric(str[foundEnd]) || str[foundEnd]=='.') //we allow . so that node names can be used as strings
                        {
                            if (isSymbolString) //we were walking symbols and hit a non-symbol
                            {
                                return;
                            }

                            isCharacterString=true;
                        }
                        else if (IsValidSymbol(str[foundEnd]))
                        {
                            if (isCharacterString) //we were walking characters and hit a non-character
                            {
                                return;
                            }

                            isSymbolString=true;

                            //if we form a known symbol then stop
                            string chunk=str.Substring(foundStart, foundEnd-foundStart);
                            if (FindBinaryOperator(chunk)!=null || FindBoolUnaryOperator(chunk)!=null || str[foundEnd]=='(')
                            {
                                //There are some two digit operators whole first character matches a one digit operator.  Check for that and favor the two digit ones if found.
                                if (foundEnd<inputEnd)
                                {
                                    string chunkPlusOne=str.Substring(foundStart, foundEnd-foundStart+1);
                                    if (FindBinaryOperator(chunkPlusOne)!=null || FindBoolUnaryOperator(chunkPlusOne)!=null)
                                    {
                                        ++foundEnd;
                                    }
                                }

                                return;
                            }
                        }
                        else
                        {
                            throw new InvalidExpressionException(str, foundEnd, foundEnd, "Invalid character '"+str[foundEnd]+"'");
                        }
                    }
                }
            }

            private static int SkipWhiteSpace(string str, int start, int end)
            {
                int pos=start;
                while (pos<end)
                {
                    if (!IsWhiteSpace(str[pos]))
                    {
                        return pos;
                    }
                    ++pos;
                }

                return pos;
            }

            //finds the next comma.  if it encounters a ( it will skip until the matching ) is found.
            private static int FindNextComma(string str, int start, int end)
            {
                int pos=start;
                while (pos<end)
                {
                    if (str[pos]=='(')
                    {
                        pos=FindMatchingCloseBracket(str, pos, end);
                    }
                    else if (str[pos]==',')
                    {
                        return pos;
                    }
                    ++pos;
                }

                if (pos>end)
                {
                    pos=end;
                }

                return pos;
            }

            private static int FindMatchingCloseBracket(string str, int start, int end)
            {
                int depth=1;

                for (int pos=start+1; pos<end; ++pos)
                {
                    if (str[pos]=='(')
                    {
                        ++depth;
                    }
                    else if (str[pos]==')')
                    {
                        --depth;
                        if (depth==0)
                        {
                            return pos+1;
                        }
                    }
                }

                throw new InvalidExpressionException(str, start, end, "No matching ')' found");
            }

            private static bool IsValidSymbol(char c)
            {
                if (c=='&' || c=='|' || c=='^' || c=='(' || c==')' || c==',' || c=='!' || c=='=' || c=='<' || c=='>')
                {
                    return true;
                }

                return false;
            }

            private static bool IsValidAlphaNumeric(char c)
            {
                if ((c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9') || c=='_')
                {
                    return true;
                }

                return false;
            }

            private static bool IsWhiteSpace(char c)
            {
                if (c==' ' || c=='\t' || c=='\n' || c=='\r')
                {
                    return true;
                }

                return false;
            }

            private static BoolBinaryOperatorDelegate FindBinaryOperator(string chunk)
            {
                if (chunk=="&&")
                {
                    return BoolBinaryEvaluateAnd;
                }
                else if (chunk=="||")
                {
                    return BoolBinaryEvaluateOr;
                }
                else if (chunk=="^^")
                {
                    return BoolBinaryEvaluateXor;
                }
                else if (chunk=="==")
                {
                    return BoolBinaryEvaluateEqual;
                }
                else if (chunk=="!=")
                {
                    return BoolBinaryEvaluateNotEqual;
                }
                else if (chunk=="<")
                {
                    return BoolBinaryEvaluateLess;
                }
                else if (chunk=="<=")
                {
                    return BoolBinaryEvaluateLessEqual;
                }
                else if (chunk==">")
                {
                    return BoolBinaryEvaluateGreater;
                }
                else if (chunk==">=")
                {
                    return BoolBinaryEvaluateGreaterEqual;
                }

                return null;
            }

            private static BoolUnaryOperatorDelegate FindBoolUnaryOperator(string chunk)
            {
                if (chunk=="!")
                {
                    return BoolUnaryEvaluateNot;
                }

                return null;
            }

            //binary operator evaluators
            private static bool BoolBinaryEvaluateAnd(TestNode node, Expression e1, Expression e2)
            {
                return e1.EvaluateBool(node) && e2.EvaluateBool(node);
            }

            private static bool BoolBinaryEvaluateOr(TestNode node, Expression e1, Expression e2)
            {
                return e1.EvaluateBool(node) || e2.EvaluateBool(node);
            }

            private static bool BoolBinaryEvaluateXor(TestNode node, Expression e1, Expression e2)
            {
                return e1.EvaluateBool(node) ^ e2.EvaluateBool(node);
            }

            private static bool BoolBinaryEvaluateEqual(TestNode node, Expression e1, Expression e2)
            {
                ValueSet leftValues=e1.EvaluateValues(node);
                ValueSet rightValues=e2.EvaluateValues(node);

                if (leftValues.Count!=rightValues.Count)
                {
                    return false;
                }

                foreach (Value lv in leftValues)
                {
                    if (!rightValues.ContainsValue(lv))
                    {
                        return false;
                    }
                }

                return true;
            }

            private static bool BoolBinaryEvaluateNotEqual(TestNode node, Expression e1, Expression e2)
            {
                return !BoolBinaryEvaluateEqual(node, e1, e2);
            }

            private static bool BoolBinaryEvaluateLess(TestNode node, Expression e1, Expression e2)
            {
                ValueSet leftValues=e1.EvaluateValues(node);
                ValueSet rightValues=e2.EvaluateValues(node);

                if (leftValues.Count==0 || rightValues.Count==0)
                {
                    return false;
                }

                foreach (Value lv in leftValues)
                {
                    foreach (Value rv in rightValues)
                    {
                        if (!(lv.ToInteger()<rv.ToInteger()))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            private static bool BoolBinaryEvaluateLessEqual(TestNode node, Expression e1, Expression e2)
            {
                ValueSet leftValues=e1.EvaluateValues(node);
                ValueSet rightValues=e2.EvaluateValues(node);

                if (leftValues.Count==0 || rightValues.Count==0)
                {
                    return false;
                }

                foreach (Value lv in leftValues)
                {
                    foreach (Value rv in rightValues)
                    {
                        if (!(lv.ToInteger()<=rv.ToInteger()))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            private static bool BoolBinaryEvaluateGreater(TestNode node, Expression e1, Expression e2)
            {
                ValueSet leftValues=e1.EvaluateValues(node);
                ValueSet rightValues=e2.EvaluateValues(node);

                if (leftValues.Count==0 || rightValues.Count==0)
                {
                    return false;
                }

                foreach (Value lv in leftValues)
                {
                    foreach (Value rv in rightValues)
                    {
                        if (!(lv.ToInteger()>rv.ToInteger()))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            private static bool BoolBinaryEvaluateGreaterEqual(TestNode node, Expression e1, Expression e2)
            {
                ValueSet leftValues=e1.EvaluateValues(node);
                ValueSet rightValues=e2.EvaluateValues(node);

                if (leftValues.Count==0 || rightValues.Count==0)
                {
                    return false;
                }

                foreach (Value lv in leftValues)
                {
                    foreach (Value rv in rightValues)
                    {
                        if (!(lv.ToInteger()>=rv.ToInteger()))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            //unary operator evaluators
            private static bool BoolUnaryEvaluateNot(TestNode node, Expression exp)
            {
                return !exp.EvaluateBool(node);
            }

            //delegates for operators
            private delegate bool BoolBinaryOperatorDelegate(TestNode node, Expression left, Expression right);
            private delegate bool BoolUnaryOperatorDelegate(TestNode node, Expression left);

            //function information and delegates
            public delegate bool BoolFunctionDelegate(TestNode node, Expression []parameters);
            public delegate string[] TagsFunctionDelegate(TestNode node, Expression []parameters);
            public delegate ValueSet ValuesFunctionDelegate(TestNode node, Expression []parameters);

            public delegate void ValidateFunctionParametersDelegate(Expression []parameters, string expStr, int expStart, int expEnd); //the last 3 parameters to all of these are purely so that a correct InvalidExpressionException can be thrown.

            public class FunctionInformation
            {
                public ValidateFunctionParametersDelegate ValidationFunction;
                public Delegate CallFunction;

                public string HelpText;

                public FunctionInformation(ValidateFunctionParametersDelegate validation, Delegate call, string helpText)
                {
                    ValidationFunction=validation;
                    CallFunction=call;
                    HelpText=helpText;
                }
            };

            public static void RegisterCustomBoolFunction(string name, FunctionInformation fi)
            {
                string lowerName=name.ToLower();
                if (!BoolFunctionDictionary.ContainsKey(lowerName))
                {
                    BoolFunctionDictionary.Add(lowerName, fi);
                }
                else
                {
                    BoolFunctionDictionary[lowerName]=fi;
                }
            }

            public static void RegisterCustomValuesFunction(string name, FunctionInformation fi)
            {
                string lowerName=name.ToLower();
                if (!ValuesFunctionDictionary.ContainsKey(lowerName))
                {
                    ValuesFunctionDictionary.Add(lowerName, fi);
                }
                else
                {
                    ValuesFunctionDictionary[lowerName]=fi;
                }
            }

            //backing and setup for built-in functions
            private static Dictionary<string, FunctionInformation> BoolFunctionDictionary=new Dictionary<string, FunctionInformation>();
            private static Dictionary<string, FunctionInformation> ValuesFunctionDictionary=new Dictionary<string, FunctionInformation>();

            static Expression()
            {
                //bool functions
                RegisterCustomBoolFunction("nodehastag", new FunctionInformation(SingleTagParameter_Validate, new BoolFunctionDelegate(NodeHasTag_Call), "NodeHasTag(tag)   Returns true if the node has a specific tag on it."));
                RegisterCustomBoolFunction("trunkhastag", new FunctionInformation(SingleTagParameter_Validate, new BoolFunctionDelegate(TrunkHasTag_Call), "TrunkHasTag(tag)   Returns true if the node or any parent node has a specific tag on it."));
                RegisterCustomBoolFunction("branchhastag", new FunctionInformation(SingleTagParameter_Validate, new BoolFunctionDelegate(BranchHasTag_Call), "BranchHasTag(tag)   Returns true if the node or any child nodes have a specific tag on it."));
                RegisterCustomBoolFunction("treehastag", new FunctionInformation(SingleTagParameter_Validate, new BoolFunctionDelegate(TreeHasTag_Call), "TreeHasTag(tag)   Returns true if the node, any parent nodes, or any child nodes have a specific tag on it."));
                RegisterCustomBoolFunction("isleafnode", new FunctionInformation(NoParameter_Validate, new BoolFunctionDelegate(IsLeafNode_Call), "IsLeafNode()   Returns true if the node is a leaf in the tree."));

                //values functions
                RegisterCustomValuesFunction("nodevalues", new FunctionInformation(TagsParameter_Validate, new ValuesFunctionDelegate(NodeValues_Call), "NodeValues(tags)   Returns the values for a tag on a node."));
                RegisterCustomValuesFunction("nearesttrunkvalues", new FunctionInformation(TagsParameter_Validate, new ValuesFunctionDelegate(NearestTrunkValues_Call), "NearestTrunkValues(tags)   Searches the node and up the tree from the node and returns the values for the first instance of a tag that is found."));
                RegisterCustomValuesFunction("trunkvalues", new FunctionInformation(TagsParameter_Validate, new ValuesFunctionDelegate(TrunkValues_Call), "TrunkValues(tags)   Returns the values for a tag from a node and all parent nodes."));
                RegisterCustomValuesFunction("branchvalues", new FunctionInformation(TagsParameter_Validate, new ValuesFunctionDelegate(BranchValues_Call), "TrunkValues(tags)   Returns the values for a tag from a node and all child nodes."));
                RegisterCustomValuesFunction("treevalues", new FunctionInformation(TagsParameter_Validate, new ValuesFunctionDelegate(TreeValues_Call), "TrunkValues(tags)   Returns the values for a tag from a node, all parent nodes, and all child nodes."));
                RegisterCustomValuesFunction("nodename", new FunctionInformation(NoParameter_Validate, new ValuesFunctionDelegate(NodeName_Call), "NodeName()   Returns the individual name of the node."));
                RegisterCustomValuesFunction("nodefullname", new FunctionInformation(NoParameter_Validate, new ValuesFunctionDelegate(NodeFullName_Call), "NodeFullName()   Returns the fully-qualified name of the node within the tree."));
            }

            //validation of functions
            public static void SingleTagParameter_Validate(Expression []parameters, string expStr, int expStart, int expEnd)
            {
                if (parameters.Length!=1)
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 1 parameter.");
                }

                if (!(parameters[0].Type==ExpressionType.Tags || parameters[0].Type==ExpressionType.TagsFunction))
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function parameter 0 must be a tag.");
                }

                if (parameters[0].Type==ExpressionType.Tags && parameters[0].Tags.Length!=1)
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 1 tag as a parameter.");
                }
            }

            public static void TagsParameter_Validate(Expression []parameters, string expStr, int expStart, int expEnd)
            {
                if (parameters.Length!=1)
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 1 parameter.");
                }

                if (!(parameters[0].Type==ExpressionType.Tags || parameters[0].Type==ExpressionType.TagsFunction))
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function parameter 0 must be a tag.");
                }
            }

            public static void NoParameter_Validate(Expression []parameters, string expStr, int expStart, int expEnd)
            {
                if (parameters.Length!=0)
                {
                    throw new InvalidExpressionException(expStr, expStart, expEnd, "Function requires exactly 0 parameters.");
                }
            }

            //implementation of bool functions
            public static bool NodeHasTag_Call(TestNode node, Expression []parameters)
            {
                string []tagToFind=parameters[0].EvaluateTags(node);
                if (tagToFind.Length!=1)
                {
                    throw new ExpressionEvaluationException(parameters[0].SourceString, parameters[0].SourceStringStart, parameters[0].SourceStringEnd, "NodeHasTag requires exactly 1 tag as a parameter.");
                }

                return node.TaggingData.GetNodeTags().ContainsKey(tagToFind[0]);
            }

            public static bool TrunkHasTag_Call(TestNode node, Expression []parameters)
            {
                string []tagToFind=parameters[0].EvaluateTags(node);
                if (tagToFind.Length!=1)
                {
                    throw new ExpressionEvaluationException(parameters[0].SourceString, parameters[0].SourceStringStart, parameters[0].SourceStringEnd, "NodeHasTag requires exactly 1 tag as a parameter.");
                }

                return node.TaggingData.GetAllTrunkTags().ContainsKey(tagToFind[0]);
            }

            public static bool BranchHasTag_Call(TestNode node, Expression []parameters)
            {
                string []tagToFind=parameters[0].EvaluateTags(node);
                if (tagToFind.Length!=1)
                {
                    throw new ExpressionEvaluationException(parameters[0].SourceString, parameters[0].SourceStringStart, parameters[0].SourceStringEnd, "NodeHasTag requires exactly 1 tag as a parameter.");
                }

                return node.TaggingData.GetAllBranchTags().ContainsKey(tagToFind[0]);
            }

            public static bool TreeHasTag_Call(TestNode node, Expression []parameters)
            {
                string []tagToFind=parameters[0].EvaluateTags(node);
                if (tagToFind.Length!=1)
                {
                    throw new ExpressionEvaluationException(parameters[0].SourceString, parameters[0].SourceStringStart, parameters[0].SourceStringEnd, "NodeHasTag requires exactly 1 tag as a parameter.");
                }

                return node.TaggingData.GetAllTreeTags().ContainsKey(tagToFind[0]);
            }

            public static bool IsLeafNode_Call(TestNode node, Expression []parameters)
            {
                return (node.ChildrenCount==0);
            }

            //implementation of values functions
            public static ValueSet NodeValues_Call(TestNode node, Expression []parameters)
            {
                string []tagsToFind=parameters[0].EvaluateTags(node);

                ValueSet values=new ValueSet();
                foreach (string tag in tagsToFind)
                {
                    ValueSet curValues=node.TaggingData.GetNodeValues(tag);
                    values.MergeFrom(curValues);
                }

                return values;
            }

            public static ValueSet NearestTrunkValues_Call(TestNode node, Expression []parameters)
            {
                string []tagsToFind=parameters[0].EvaluateTags(node);

                ValueSet values=new ValueSet();
                foreach (string tag in tagsToFind)
                {
                    ValueSet curValues=node.TaggingData.GetNearestTrunkValues(tag);
                    values.MergeFrom(curValues);
                }

                return values;
            }

            public static ValueSet TrunkValues_Call(TestNode node, Expression []parameters)
            {
                string []tagsToFind=parameters[0].EvaluateTags(node);

                ValueSet values=new ValueSet();
                foreach (string tag in tagsToFind)
                {
                    ValueSet curValues=node.TaggingData.GetAllTrunkValues(tag);
                    values.MergeFrom(curValues);
                }

                return values;
            }

            public static ValueSet BranchValues_Call(TestNode node, Expression []parameters)
            {
                string []tagsToFind=parameters[0].EvaluateTags(node);

                ValueSet values=new ValueSet();
                foreach (string tag in tagsToFind)
                {
                    ValueSet curValues=node.TaggingData.GetAllBranchValues(tag);
                    values.MergeFrom(curValues);
                }

                return values;
            }

            public static ValueSet TreeValues_Call(TestNode node, Expression []parameters)
            {
                string []tagsToFind=parameters[0].EvaluateTags(node);

                ValueSet values=new ValueSet();
                foreach (string tag in tagsToFind)
                {
                    ValueSet curValues=node.TaggingData.GetAllTreeValues(tag);
                    values.MergeFrom(curValues);
                }

                return values;
            }

            public static ValueSet NodeName_Call(TestNode node, Expression []parameters)
            {
                ValueSet values=new ValueSet();
                values.Add(new Value(node.Name));
                return values;
            }

            public static ValueSet NodeFullName_Call(TestNode node, Expression []parameters)
            {
                ValueSet values=new ValueSet();
                values.Add(new Value(node.FullName));
                return values;
            }

            //functions to evaluate an expression as a specific type
            public ValueSet EvaluateValues(TestNode node)
            {
                if (Type==ExpressionType.Tags)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate tags as values");
                }
                else if (Type==ExpressionType.Values)
                {
                    return Values;
                }
                else if (Type==ExpressionType.BoolBinaryOperations)
                {
                    BoolBinaryOperatorDelegate callDelegate=(BoolBinaryOperatorDelegate)Operations[0];
                    bool lastResult=callDelegate(node, Parameters[0], Parameters[1]);

                    for (int ops=1; ops<Operations.Length; ++ops)
                    {
                        //wrap the last result in an expression so we call use it is a parameter
                        Expression lastResultExp=new Expression();
                        lastResultExp.type=ExpressionType.Values;
                        lastResultExp.Values=new ValueSet();
                        lastResultExp.Values.Add(new Value(lastResult));

                        //call it
                        callDelegate=(BoolBinaryOperatorDelegate)Operations[ops];
                        lastResult=callDelegate(node, lastResultExp, Parameters[ops+1]);
                    }

                    ValueSet values=new ValueSet();
                    values.Add(new Value(lastResult));
                    return values;
                }
                else if (Type==ExpressionType.BoolUnaryOperation)
                {
                    BoolUnaryOperatorDelegate callDelegate=(BoolUnaryOperatorDelegate)Operations[0];
                    bool value=callDelegate(node, Parameters[0]);

                    ValueSet values=new ValueSet();
                    values.Add(new Value(value));
                    return values;
                }
                else if (Type==ExpressionType.TagsFunction)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate tags as values");
                }
                else if (Type==ExpressionType.ValuesFunction)
                {
                    ValuesFunctionDelegate callDelegate=(ValuesFunctionDelegate)Operations[0];
                    ValueSet values=callDelegate(node, Parameters);

                    return values;
                }
                else if (Type==ExpressionType.BoolFunction)
                {
                    BoolFunctionDelegate callDelegate=(BoolFunctionDelegate)Operations[0];
                    bool value=callDelegate(node, Parameters);

                    ValueSet values=new ValueSet();
                    values.Add(new Value(value));
                    return values;
                }
                else
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Unhandled expression type: "+Type);
                }
            }

            public bool EvaluateBool(TestNode node)
            {
                ValueSet values=EvaluateValues(node);
                if (values.Count!=1)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Must have exactly 1 value to evaluate as a bool");
                }

                return values[0].ToBool();
            }

            public long EvaluateInteger(TestNode node)
            {
                ValueSet values=EvaluateValues(node);
                if (values.Count!=1)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Must have exactly 1 value to evaluate as an integer");
                }

                return values[0].ToInteger();
            }

            public string EvaluateString(TestNode node)
            {
                ValueSet values=EvaluateValues(node);
                if (values.Count!=1)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Must have exactly 1 value to evaluate as a string");
                }

                return values[0].ToString();
            }

            public string[] EvaluateTags(TestNode node)
            {
                if (Type==ExpressionType.Tags)
                {
                    return Tags;
                }
                else if (Type==ExpressionType.Values)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate a value as tag");
                }
                else if (Type==ExpressionType.BoolBinaryOperations)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate a boolean binary operation as a tag");
                }
                else if (Type==ExpressionType.BoolUnaryOperation)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate a unary function as a tag");
                }
                else if (Type==ExpressionType.TagsFunction)
                {
                    TagsFunctionDelegate callDelegate=(TagsFunctionDelegate)Operations[0];
                    return callDelegate(node, Parameters);
                }
                else if (Type==ExpressionType.ValuesFunction)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate a values function as a tag");
                }
                else if (Type==ExpressionType.BoolFunction)
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Cannot evaluate a boolean as a tag");
                }
                else
                {
                    throw new ExpressionEvaluationException(sourceString, sourceStringStart, sourceStringEnd, "Unhandled expression type: "+Type);
                }
            }

            //Retrieves a help string describing how to use expressions
            public static string GetHelpText()
            {
                string help="";
                help+="Expressions allow you specify a filter for an operation that will be applied to a set of TestNodes.  The final result of an expression is a boolean.  If it evaluates to true for a TestNode, the specified operation will be applied to that TestNode.\n\n";

                help+="Expressions are comprised of literal declarations, binary operations, unary operations, grouping, and functions.  There are two types that an expression or part of an expression can evaluate to: Tags or Values.  Values themself are stored as a string, but can be interpreted as a boolean or integer in some contexts.\n\n";

                help+="--Literal Declarations--\n";
                help+="    Tag(Name, [Name2], [...])   Declares one or more tags.\n";
                help+="    Val(Value, [Value2], [...])   Declares one or more values.\n\n";

                help+="--Binary operations--\n";
                help+="All Binary operations return a value type, representing a boolean result.\n";
                help+="IMPORTANT: Binary operations are evaluated left to right with NO operator precedence.  Use grouping when neccesary.\n";
                help+="    exp == exp   Returns true if both expressions contain all the same values.\n";
                help+="    exp != exp   Returns true if either expression contains different values.\n";
                help+="    exp < exp   Both expressions are evaluated as integers.  Returns true if all values in the left set are less than all values in the right set.\n";
                help+="    exp > exp   Both expressions are evaluated as integers.  Returns true if all values in the left set are greater than all values in the right set.\n";
                help+="    exp <= exp   Both expressions are evaluated as integers.  Returns true if all values in the left set are less than or equal to all values in the right set.\n";
                help+="    exp >= exp   Both expressions are evaluated as integers.  Returns true if all values in the left set are greater than or equal to all values in the right set.\n";
                help+="    exp && exp   Both expressions are evaluated as boolean, and must be a single value.  Returns true if both sides are true.\n";
                help+="    exp || exp   Both expressions are evaluated as boolean, and must be a single value.  Returns true if either side is true.\n";
                help+="    exp ^^ exp   Both expressions are evaluated as boolean, and must be a single value.  Returns true if exactly one side is true.\n\n";

                help+="--Unary operations--\n";
                help+="All Unary operations return a value type, representing a boolean result.\n";
                help+="    !exp   Expression is evaluated as a boolean and must be a single value.  Returns true if the expression is false.\n\n";

                help+="--Grouping operations--\n";
                help+="    ()   Parethesis can be placed around parts of expressions to specific grouping or order of operations.\n\n";

                help+="--Boolean functions--\n";
                help+="All of these return a single value that represents a boolean.\n";
                foreach (KeyValuePair<string,FunctionInformation> fi in BoolFunctionDictionary)
                {
                    help+="    "+fi.Value.HelpText+"\n";
                }
                help+="\n";

                help+="--Value functions--\n";
                help+="These can return any number of values.\n";
                foreach (KeyValuePair<string,FunctionInformation> fi in ValuesFunctionDictionary)
                {
                    help+="    "+fi.Value.HelpText+"\n";
                }
                help+="\n";

                return help;
            }
        }; //class Expression
#endregion Expressions
    }; //class NodeTaggingData
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\objd\i386\_generated.cs ===
[assembly:System.Runtime.InteropServices.ComVisible(false)]
[assembly:System.Reflection.AssemblyVersion("12.4.56.0")]
[assembly:System.Reflection.AssemblyProduct("DEPOT")]
[assembly:System.Reflection.AssemblyCopyright("")]
[assembly:System.Reflection.AssemblyCompany("")]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Plugins\Plugins.cs ===
using System.Xml;
using ServerTestFramework;

/*
 You may implement one or more of the interfaces defined here to piece together
 the functionality you require.  Methods will be called in the following order
 over the life of the app:

while (app is running)
{
    IPluginSetup.Initialize (one time only)

    for (every newly loaded extension)
    {
        IPluginExtension.PluginLoaded (once for each plugin that is extended)
    }

    for (every newly loaded suite)
    {
        IPluginSuiteLoadedNotification.SuiteLoaded (once for each suite)
    }
}

IPluginSetup.Shutdown (one time only)
*/

namespace ServerTestFramework.Plugins
{
    /// <summary>
    /// Implement this to add new components or functionality.
    /// Only one instance of the class will ever be instantiated.  Ever.
    /// </summary>
    public interface IPlugin
    {
    }

    /// <summary>
    /// Do not implement this, this is used to easily determine if a class 
    /// extends from the generic IPluginExtension interface.
    /// </summary>
    public interface IPluginExtension : IPlugin
    {
    }

    /// <summary>
    /// Implement this to extend an existing plugin.  The derived class will 
    /// only be instantiated if one of the the plugins it extends is loaded.
    /// Only one instance of a derived class will ever be instantiated (even if
    /// a class extends multiple plugins).
    /// </summary>
    public interface IPluginExtension<PluginType> : IPluginExtension
        where PluginType : IPlugin
    {
        /// <summary>
        /// This will be called to inform the extension of the existance of a
        /// plugin that it extends.
        /// </summary>
        void PluginLoaded(PluginType plugin);
    };

    /// <summary>
    /// Implement this if you require setup and cleanup steps for your plugin or
    /// extension, including the ability to save/restore global settings.
    /// </summary>
    public interface IPluginSetup : IPlugin
    {
        /// <summary>
        /// This will be called after the gui loads, as soon as the class is 
        /// instantiated. Settings can be loaded from the provided xml object.
        /// </summary>
        void Initialize(XmlNode pluginSettings, string []commandlineParameters);

        /// <summary>
        /// This will be called when the gui is about to close down.
        /// Settings can be stored in the provided xml object.
        /// </summary>
        void Shutdown(XmlNode pluginSettings);
    };

    /// <summary>
    /// Implement this if you require notifications when a module is about to be
    /// loaded or after a new suite is loaded from a module.
    /// </summary>
    public interface IPluginModuleLoadNotification : IPlugin
    {
        /// <summary>
        /// This is called when a module(which may contain suites or plugins) is
        /// about to be loaded.  When a plugin is initially created, and already
        /// loaded modules will also be passed.
        /// </summary>
        void ModuleLoading(string fileName);

        /// <summary>
        /// This is called after a new suite is loaded from a module.  You will
        /// be passed the already-constructed tree.  When a plugin is initially
        /// created, and already-loaded suites will also be passed.
        /// </summary>
        void SuiteLoaded(TestNode rootNode);

        /// <summary> This is called when a suite is being unloaded. </summary>
        void SuiteUnloading(TestNode rootNode);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Plugins\PluginHandler.cs ===
//#define DEBUG_PLUGIN_LOADING

using System;
using System.Reflection;
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Plugins
{
    public class PluginHandler
    {
        #region Types

        /// <summary>
        /// A wrapper around a pluggable item that allows you to find out 
        /// information about what type of item it is
        /// </summary>
        protected class PluggableItem
        {
            public Type ItemType;               //type of the item
            public string NameWithVersion = "?";  //name and version of the item (used to prevent double loading)
            public string FriendlyName = "?";     //name of the item to use in messages

            protected Object item = null;
            /// <summary>
            /// Represents the instance of the actual item.  An instance of a 
            /// class that derives from something we're interested in like 
            /// Plugin, IPluginPreferences, etc. (defined in Plugins.cs)
            /// </summary>
            public virtual Object Item
            {
                get { return item; }
                set
                {
                    item = value;
                    AsIPluginSetup = item as IPluginSetup;
                    AsIPluginExtension = item as IPluginExtension;
                    AsIPluginModuleLoadNotification = item as IPluginModuleLoadNotification;
                }
            }

            public bool IsIPluginSetup { get { return AsIPluginSetup != null; } }
            public bool IsIPluginExtension { get { return AsIPluginExtension != null; } }
            public bool IsIPluginModuleLoadNotification { get { return AsIPluginModuleLoadNotification != null; } }

            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginSetup
            /// </summary>
            public IPluginSetup AsIPluginSetup = null;
            /// <summary>
            /// The item represented by this pluggable object as an IPluginExtension
            /// </summary>
            public IPluginExtension AsIPluginExtension = null;
            /// <summary>
            /// Returns the pluggable item as a PluginExtension of the requested
            /// type.  This is required to be a method because the the parameter
            /// is generic and there is no way to make a generic property
            /// </summary>
            /// <typeparam name="PluginType">The type of plugin that this extension extends</typeparam>
            /// <returns>The item respreseted by this pluggable object as an IPluginExtension</returns>
            public IPluginExtension<PluginType> AsIPluginExt<PluginType> ()
                where PluginType : IPlugin
            {
                return AsIPluginExtension as IPluginExtension<PluginType>;
            }
            /// <summary>
            /// The item respreseted by this pluggable object as an IPluginModuleLoadNotification
            /// </summary>
            public IPluginModuleLoadNotification AsIPluginModuleLoadNotification = null;

            /// <summary>
            /// Indicates if IPluginSetup.Initialize has been called yet
            /// </summary>
            public bool DidInit = false;
        }

        #endregion

        #region Fields

        protected XmlDocument SettingsDoc;
        protected static Report ro = new Report("PluginHandler");

        /// <summary>
        /// These are the items that have been loaded and setup already
        /// </summary>
        protected List<PluggableItem> loadedItems = new List<PluggableItem>();
        /// <summary>
        /// These are the items that were found but haven't been loaded yet
        /// </summary>
        protected List<PluggableItem> deferredItems = new List<PluggableItem>();

        /// <summary>
        /// Command line parameters that are targetted at any plugins;
        /// </summary>
        protected Dictionary<string, List<string>> pluginParams = new Dictionary<string, List<string>>();

        /// <summary>
        /// Names of all modules that have already been loaded
        /// </summary>
        protected List<string> loadedModuleNames = new List<string>();

        /// <summary>The TestNode roots that we have been notified of.</summary>
        protected List<TestNode> loadedSuites = new List<TestNode>();

        #endregion

        #region Constructor

        //ctor
        public PluginHandler (XmlDocument settings, string[] parametersForPlugins)
        {
            SettingsDoc = settings;

            //parse the params into plugin buckets
            foreach (string s in parametersForPlugins)
            {
                int indOfColon = s.IndexOf(':');
                if (indOfColon == -1)
                {
                    ro.Error("Plugin parameter is malformed (no colon separater): " + s);
                }
                else
                {
                    string pluginName = s.Substring(0, indOfColon).ToLower();
                    string param = s.Substring(indOfColon + 1);
                    if (!pluginParams.ContainsKey(pluginName))
                    {
                        pluginParams.Add(pluginName, new List<string>());
                    }
                    pluginParams[pluginName].Add(param);
                }
            }
        }

        #endregion

        #region Plugin Events

        /// <summary>
        /// Called before a new module is loaded that might contain plugins or suites.
        /// </summary>
        public void NotifyModuleLoading(string fileName)
        {
            foreach (PluggableItem item in loadedItems)
            {
                try
                {
                    if (item.IsIPluginModuleLoadNotification)
                    {
                        item.AsIPluginModuleLoadNotification.ModuleLoading(fileName);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception calling ModuleLoading on "+item.FriendlyName+": "+e);
                }
            }

            loadedModuleNames.Add(fileName);
        }

        /// <summary>
        /// Called after a suite is loaded.
        /// </summary>
        public void NotifySuiteLoaded(TestNode suite)
        {
            if (suite == null)
            {
                return;
            }

            loadedSuites.Add(suite);

            foreach (PluggableItem item in loadedItems)
            {
                try
                {
                    if (item.IsIPluginModuleLoadNotification)
                    {
                        item.AsIPluginModuleLoadNotification.SuiteLoaded(suite);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception calling SuiteLoaded on "+item.FriendlyName+": "+e);
                }
            }
        }

        /// <summary>
        /// Called when a suite is being unloaded to tell the plugin to remove all references to it.
        /// </summary>
        public void NotifySuiteUnloading(TestNode suite)
        {
            if (suite == null)
            {
                return;
            }

            loadedSuites.Remove(suite);

            foreach (PluggableItem item in loadedItems)
            {
                try
                {
                    if (item.IsIPluginModuleLoadNotification)
                    {
                        item.AsIPluginModuleLoadNotification.SuiteUnloading(suite);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception calling SuiteUnloading on "+item.FriendlyName+": "+e);
                }
            }
        }

        #endregion

        #region Plugin Loading/Unloading

        /// <summary>
        /// Called whenever the gui is wanting to close.
        /// </summary>
        public void UnloadAllPlugins ()
        {
            while (loadedItems.Count>0)
            {
                PluggableItem item=GetNextUnloadablePluggable();

                if (item==null)
                {
                    ro.Fatal("There are pluggables still loaded but GetNextUnloadablePluggable returned null.  This is very bad.");
                }

                DebugMessage("unloading pluggable "+item.FriendlyName);

                if (item.IsIPluginSetup)
                {
                    try
                    {
                        item.AsIPluginSetup.Shutdown(GetPluginSettingsNode(item));
                    }
                    catch (Exception e)
                    {
                        ro.Fatal("Failed to shutdown pluggable "+item.FriendlyName+": "+e);
                    }
                }

                loadedItems.Remove(item);
            }
        }

        /// <summary>
        /// Loads all configured plugins.
        /// </summary>
        public void LoadPluginFiles()
        {
            //get a list of plugins to load from config
            XmlNode groupNode = SettingsDoc.DocumentElement.SelectSingleNode("PluginHandler");
            if (groupNode==null)
            {
                groupNode = SettingsDoc.CreateNode("element", "PluginHandler", "");
                SettingsDoc.DocumentElement.AppendChild(groupNode);
            }

            bool saveNewPluginList=false;
            List<string> initPluginFiles = new List<string>();
            foreach(XmlNode n in groupNode.ChildNodes)
            {
                if (n.Name=="LoadPlugin")
                {
                    initPluginFiles.Add(n.InnerXml);
                }
            }

            if (initPluginFiles.Count==0) //if none are configured, search the current directory
            {
                saveNewPluginList=true;
                initPluginFiles.AddRange(GetDefaultPluginsList());
            }

            //Load all plugins
            List<string> finalPluginFiles = new List<string>();
            foreach (string plugfile in initPluginFiles)
            {
                NotifyModuleLoading(plugfile);

                try
                {
                    Assembly asm=Assembly.LoadFrom(plugfile);
                    bool found=LoadAllPluginsInAssembly(asm);
                    if (found)
                    {
                        finalPluginFiles.Add(plugfile);
                    }
                }
                catch (Exception e)
                {
                    ro.Fatal("Exception loading plugin file "+plugfile+": "+e);
                }
            }

            //if we had to search to find these, save them into the config
            if (saveNewPluginList)
            {
                foreach (string s in finalPluginFiles)
                {
                    XmlNode n = SettingsDoc.CreateNode(XmlNodeType.Element, "LoadPlugin", "");
                    n.InnerXml=s;
                    groupNode.AppendChild(n);
                }
            }
        }

        /// <summary>
        /// Loads all plugins and other pluggable item types in an assembly
        /// </summary>
        /// <param name="asm">The assembly to load the types from</param>
        /// <returns>True if any plugin types were loaded, false otherwise</returns>
        public bool LoadAllPluginsInAssembly(Assembly asm)
        {
            bool anyQueued = false;
            Type[] assemblyTypes = null;

            try
            {
                // Grab all the visible types from the assembly
                assemblyTypes = asm.GetTypes();
            }
            catch (ReflectionTypeLoadException rtle)
            {
                ro.Warn("Not all types in " + asm.FullName + " could be loaded.");
                assemblyTypes = rtle.Types;
            }

            foreach (Type t in assemblyTypes)
            {
                if (t == null)
                {
                    continue;
                }

                if (QueuePlugin(t, asm) != null)
                {
                    anyQueued = true;
                }
            }

            ProcessQueuedPluggables();
            return anyQueued;
        }

        /// <summary>
        /// Creates a PluggableItem from a type (if not already loaded) and adds
        /// it to the list of items to process.
        /// </summary>
        /// <param name="pluginType">The type of item to try to create with</param>
        /// <param name="asm">The assembly that contains the type</param>
        /// <returns>The instance of the pluggable item </returns>
        private PluggableItem QueuePlugin(Type pluginType, Assembly asm)
        {
            // If it's a pluggable object, it should implement IPlugin
            if (!pluginType.IsClass || !typeof(IPlugin).IsAssignableFrom(pluginType))
            {
                // This is going to happen with lots of types so just return
                // null.  We don't need an error message.
                return null;
            }

            //check if we already loaded it
            string itemNameWithVersion = pluginType.FullName + " version " + asm.GetName().Version;
            if (IsAlreadyLoaded(itemNameWithVersion))
            {
                DebugMessage("NOT queueing already loaded " + itemNameWithVersion);
                return null;
            }

            //set up the PluggableItem for it
            PluggableItem item = NewPluggableItem();
            item.ItemType = pluginType;
            item.NameWithVersion = itemNameWithVersion;
            item.FriendlyName = pluginType.FullName;

            // Get the default constructor
            ConstructorInfo constructor = item.ItemType.GetConstructor(Type.EmptyTypes);

            if (constructor == null)
            {
                // This is a pluggable object that we can't create.
                ro.Fatal("Unable to instantiate plugin " + item.FriendlyName + " because it has no default constructor.");
                return null;
            }

            try
            {
                // Create an instance of the item
                item.Item = constructor.Invoke(null);
            }
            catch (Exception e)
            {
                ro.Fatal("Failed to instantiate pluggable " + item.FriendlyName + "\n" + e.ToString());
                return null;
            }

            // Add it to the list
            deferredItems.Add(item);
            DebugMessage("Queued pluggable item " + item.FriendlyName);
            return item;
        }

        //returns whether a specific item is already loaded
        private bool IsAlreadyLoaded(string itemNameWithVersion)
        {
            foreach (PluggableItem item in deferredItems)
            {
                if (item.NameWithVersion==itemNameWithVersion)
                {
                    return true;
                }
            }

            foreach (PluggableItem item in loadedItems)
            {
                if (item.NameWithVersion==itemNameWithVersion)
                {
                    return true;
                }
            }

            return false;
        }

        //processes the pluggables queue and loads pluggables that are able to be loaded
        private void ProcessQueuedPluggables()
        {
            //process 1 pluggable each loop
            bool anyProcessed = true;
            while (anyProcessed)
            {
                anyProcessed = false;

                PluggableItem item = GetNextProcessablePluggable();

                //remove it now so if it blows up, we don't keep retrying it
                deferredItems.Remove(item);

                if (item != null)
                {
                    ro.Info("Loading "+item.NameWithVersion);

                    anyProcessed = true;

                    //construct it
                    bool success=false;
                    DateTime dtStartLoad = System.DateTime.UtcNow;
                    do //we'll break out if we choose to skip the item
                    {
                        PreProcessPluggable(item);

                        //initialize it if it wants that
                        if (item.IsIPluginSetup)
                        {
                            List<string> commandlineParams=new List<string>();
                            if (pluginParams.ContainsKey(item.ItemType.FullName.ToLower())) //match full name
                            {
                                commandlineParams.AddRange(pluginParams[item.ItemType.FullName.ToLower()]);
                            }
                            if (item.ItemType.FullName!=item.ItemType.Name && pluginParams.ContainsKey(item.ItemType.Name.ToLower())) //match short name
                            {
                                commandlineParams.AddRange(pluginParams[item.ItemType.Name.ToLower()]);
                            }

                            DebugMessage("Initializing "+item.FriendlyName+" with "+commandlineParams.Count+" commandline parameters.");

                            try
                            {
                                item.AsIPluginSetup.Initialize(GetPluginSettingsNode(item), commandlineParams.ToArray());
                                item.DidInit=true;
                            }
                            catch (Exception e)
                            {
                                ro.Fatal("Failed to initialize pluggable "+item.FriendlyName+": "+e);
                                break;
                            }
                        }

                        PostSetupProcessPluggable(item);

                        //tell it about the plugin it was extended for
                        if (item.IsIPluginExtension)
                        {
                            //look for loaded plugins that we extend
                            bool foundAnyExtends = false;

                            foreach (Type extendedType in GetPluginExtendeeTypes(item))
                            {
                                PluggableItem extendee = loadedItems.Find(pi => pi.ItemType == extendedType);

                                if (extendee != null)
                                {
                                    DebugMessage("Loading Extension " + item.FriendlyName + " for " + extendee.FriendlyName);
                                    foundAnyExtends = true;
                                    try
                                    {
                                        MethodInfo mi = item.ItemType.GetMethod("PluginLoaded");
                                        mi.Invoke(item.Item, new object[] { extendee.Item });
                                        break;
                                    }
                                    catch (Exception e)
                                    {
                                        ro.Fatal("Exception extending " + extendee.FriendlyName + " with " + item.FriendlyName + ": " + e);
                                    }
                                }
                            }

                            if (!foundAnyExtends)
                            {
                                ro.Error("PluginHandler bug: We instantiated "+item.FriendlyName+" which extends a plugin that was not found.");
                            }
                        }

                        //tell it about any already-loaded module names or suites
                        if (item.IsIPluginModuleLoadNotification)
                        {
                            //module
                            try
                            {
                                foreach (string module in loadedModuleNames)
                                {
                                    item.AsIPluginModuleLoadNotification.ModuleLoading(module);
                                }
                            }
                            catch (Exception e)
                            {
                                ro.Fatal("Exception calling ModuleLoading on pluggable "+item.FriendlyName+": "+e);
                            }

                            //suites
                            try
                            {
                                foreach (TestNode suite in loadedSuites)
                                {
                                    item.AsIPluginModuleLoadNotification.SuiteLoaded(suite);
                                }
                            }
                            catch (Exception e)
                            {
                                ro.Fatal("Exception calling SuiteLoaded on pluggable "+item.FriendlyName+": "+e);
                            }
                        }

                        //add it to the loaded list
                        loadedItems.Add(item);
                        success=true;
                    } while (false);

                    //if we failed, clean it up if we set it up
                    if (!success && item.Item!=null && item.DidInit)
                    {
                        try
                        {
                            item.AsIPluginSetup.Shutdown(GetPluginSettingsNode(item));
                        }
                        catch (Exception e)
                        {
                            ro.Fatal("Failed to shutdown a failed pluggable "+item.FriendlyName+": "+e);
                        }
                    }

                    // See if we already loaded any plugins that extend this one
                    if (success)
                    {
                        foreach (PluggableItem loadedPlugin in loadedItems)
                        {
                            foreach (Type extendedType in GetPluginExtendeeTypes(loadedPlugin))
                            {
                                if (extendedType == item.ItemType)
                                {
                                    DebugMessage("Loading Extension " + loadedPlugin.FriendlyName + " for " + item.FriendlyName);
                                    try
                                    {
                                        MethodInfo mi = loadedPlugin.ItemType.GetMethod("PluginLoaded");
                                        mi.Invoke(loadedPlugin.Item, new object[] { item.Item });
                                        break;
                                    }
                                    catch (Exception e)
                                    {
                                        ro.Fatal("Exception extending " + item.FriendlyName + " with " + loadedPlugin.FriendlyName + ": " + e);
                                    }
                                }
                            }
                        }

                        PostProcessPluggable(item);

                        DateTime dtEndLoad = System.DateTime.UtcNow;
                        ro.Debug(item.FriendlyName+" loaded in "+(dtEndLoad-dtStartLoad).TotalSeconds+"s");
                    }
                }
            }
        }

        #endregion

        #region Helpers

        /// <summary>
        /// Outputs debug spec during plugin loading.  Only occurs if 
        /// DEBUG_PLUGIN_LOADING is enabled.
        /// </summary>
        /// <param name="s">The debug string to output</param>
        [System.Diagnostics.Conditional("DEBUG_PLUGIN_LOADING")]
        protected void DebugMessage (string s)
        {
            ro.Debug(s);
        }

        protected Type[] GetPluginExtendeeTypes(PluggableItem pluggable)
        {
            List<Type> extendeeTypes = new List<Type>();

            if (pluggable.IsIPluginExtension)
            {
                Type extenderType = pluggable.ItemType;

                // Loop through all the plugin interfaces
                foreach (Type extensionType in extenderType.GetInterfaces())
                {
                    // If this is a plugin extension type
                    if (extensionType.IsGenericType && typeof(IPluginExtension).IsAssignableFrom(extensionType))
                    {
                        // Get the type it's extending and add it to the list
                        extendeeTypes.Add(extensionType.GetGenericArguments()[0]);

                    }
                }

                if (extendeeTypes.Count == 0)
                {
                    ro.Fatal("Unable to find any extendee types in the plugin extension " + pluggable.FriendlyName);
                    // Don't do anything else, just return the empty array which should be handled gracefully
                }
            }

            return extendeeTypes.ToArray();
        }

        //returns a pluggable to process from the deferred list, if any can be
        protected PluggableItem GetNextProcessablePluggable()
        {
            // First load any plugins that are not extensions
            foreach (PluggableItem item in deferredItems)
            {
                if (!item.IsIPluginExtension)
                {
                    return item;
                }
            }

            //now load anything else
            foreach (PluggableItem item in deferredItems)
            {
                if (item.IsIPluginExtension) //extesions are only applicable if at least 1 extendee is loaded
                {
                    Type[] extendedTypes = GetPluginExtendeeTypes(item);

                    foreach (PluggableItem loadedPlugin in loadedItems)
                    {
                        foreach (Type extendedType in extendedTypes)
                        {
                            if (extendedType == loadedPlugin.ItemType)
                            {
                                DebugMessage("Loading plugin extension from " + loadedPlugin.FriendlyName + " for " + item.FriendlyName);
                                return item;
                            }
                        }
                    }

                    // Note: This plugin will be kept in the deferred items 
                    // until it eventually gets loaded by something
                    DebugMessage("Unable to load plugin extension: " + item.FriendlyName);
                }
                else
                {
                    return item;
                }
            }

            return null;
        }

        //returns the next loaded plugable that can be unloaded
        protected PluggableItem GetNextUnloadablePluggable()
        {
            foreach (PluggableItem item in loadedItems)
            {
                bool isExtended = false;

                foreach (PluggableItem loadedPlugin in loadedItems)
                {
                    if (item != loadedPlugin && loadedPlugin.IsIPluginExtension)
                    {
                        foreach (Type extendedType in GetPluginExtendeeTypes(loadedPlugin))
                        {
                            // If loadedPlugin is an extension for this item
                            if (item.ItemType == extendedType)
                            {
                                isExtended = true;
                                break;
                            }
                        }

                        if (isExtended)
                        {
                            break;
                        }
                    }
                }

                if (!isExtended)
                {
                    return item;
                }
                else
                {
                    DebugMessage("cannot unload " + item.FriendlyName + " yet");
                }
            }

            return null;
        }

        //retrieves the settings node for a plugin or creates one if it does not exist
        protected XmlNode GetPluginSettingsNode(PluggableItem item)
        {
            XmlNode groupNode = XmlUtil.GetGroupNode(SettingsDoc.DocumentElement, "Plugins");
            XmlNode pluginNode=XmlUtil.GetGroupNode(groupNode, item.FriendlyName);
            return pluginNode;
        }

        #endregion

        #region Virtual Methods

        /// <summary>
        /// Override to generate a list of default plugins that should be loaded.
        /// Only called when no list is supplied by the settings document.
        /// </summary>
        /// <returns>A list of plugin file names.</returns>
        protected virtual IEnumerable<string> GetDefaultPluginsList ()
        {
            return new string[0];
        }

        /// <summary>
        /// Override to make your own PluggableItem.
        /// </summary>
        /// <returns>A new PluggableItem.</returns>
        protected virtual PluggableItem NewPluggableItem ()
        {
            return new PluggableItem();
        }

        /// <summary>
        /// Override to do some work on the PluggableItem before the base handler.
        /// </summary>
        /// <param name="item">The PluggableItem to process.</param>
        protected virtual void PreProcessPluggable (PluggableItem item)
        {
        }

        /// <summary>
        /// Override to do some work on the PluggableItem after the IPluginSetup function is handled.
        /// </summary>
        /// <param name="item">The PluggableItem to process.</param>
        protected virtual void PostSetupProcessPluggable (PluggableItem item)
        {
        }

        /// <summary>
        /// Override to do some work on the PluggableItem after the base handler.
        /// </summary>
        /// <param name="item">The PluggableItem to process.</param>
        protected virtual void PostProcessPluggable (PluggableItem item)
        {
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\RunningAverage.cs ===
using System;
using System.Collections;

namespace ServerTestFramework.Runner
{
    public class RunningAverage
    {
        int length;
        int validData;
        int nextWritePosition;
        double[] data;

        public RunningAverage(int length)
        {
            this.length=length;
            data=new double[length];
            validData=0;
            nextWritePosition=0;
        }

        public void Add(double val)
        {
            data[nextWritePosition++]=val;
            if (nextWritePosition>=length)
                nextWritePosition=0;
            if (validData<length)
                validData++;
        }

        public void Add(float val)
        {
            Add((double)val);
        }

        public double Get()
        {
            int i;
            double avg=0;

            if (validData==0)
                return 0;

            for (i=0; i<validData; i++)
                avg+=data[i];
            return avg/validData;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\FuncCommon.cs ===
using System;
using System.Collections.Generic;
using System.Text;

using ServerTestFramework;
using ServerTestFramework.Utilities;

//This can be moved into the Runner namespace once we finish removing the back-compat classes.
namespace ServerTestFramework
{
    /// <summary>
    /// The result of a single execution of a run.
    /// These should be changed to proper case at some point.
    /// </summary>
    public enum TEST_RESULTS
    {
        NOT_EXECUTED,
        PASSED,
        FAILED
    };
}

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Information that each node needs to be used by the functional scheduler.
    /// This is reset everytime a new run is started.
    /// </summary>
    [Serializable]
    public class FunctionalSchedulerNodeData
    {
        public TEST_RESULTS RunResult = TEST_RESULTS.NOT_EXECUTED; //The result returned from running this node        
        public bool IsProcessed;            //If the scheduler has already touched the node during a run (used for parallel run code only)
        public volatile bool InProgress;    //If the scheduler is currently running the node
        public bool IsRun;                  //If the scheduler has already tried to run the node
        public bool IsPrerunning;           //If the scheduler has the node going through the prerun.
        public bool IsPostrunning;          //If the scheduler has the node going through the postrun.
        public DateTime StartTime;          //Time the run attempt for the node was started
        public DateTime EndTime;            //Time the run attempt for the node finished
        public TimeSpan TotalTime;          //Total time for all attempts this run (not counting prerun/postrun for a leaf node)
        public int NumberPassed;            //Number that passed
        public int NumberFailed;            //Number that failed
        public int NumberFailedWithBug;     //Number that failed with a bug
        public int NumberSkipped;           //Number that skipped
        public int NumberPreFailed;         //Number of prerun failures
        public int NumberPostFailed;        //Number of postrun failures
        public int NumberTimeOutFailed;     //Number of timeout failures
        public int NumberTotal;             //Total number of nodes that tried to run (may not add up to the sum of the above counts)
        //The exception returned from running this node. It doesn't need to be serialized.
        [System.Xml.Serialization.XmlIgnore]
        public Exception RunException = null;

        public FunctionalSchedulerNodeData()
        {
            Reset();
        }

        public void Reset()
        {
            IsProcessed = false;
            InProgress = false;
            IsRun = false;
            IsPrerunning = false;
            IsPostrunning = false;

            StartTime = DateTime.MinValue;
            EndTime = DateTime.MaxValue;
            TotalTime = TimeSpan.Zero;

            RunResult = TEST_RESULTS.NOT_EXECUTED;
            RunException = null;
            NumberPassed = 0;
            NumberFailed = 0;
            NumberFailedWithBug = 0;
            NumberSkipped = 0;
            NumberPreFailed = 0;
            NumberPostFailed = 0;
            NumberTimeOutFailed = 0;
            NumberTotal = 0;
        }

        public override string ToString()
        {
            return "RunResult="+RunResult+"\n"+
                   "IsProcessed="+IsProcessed+"\n"+
                   "InProgress="+InProgress+"\n"+
                   "IsRun="+IsRun+"\n"+
                   "IsPrerunning="+IsPrerunning+"\n"+
                   "StartTime="+StartTime+"\n"+
                   "EndTime="+EndTime+"\n"+
                   "TotalTime="+TotalTime+"\n"+
                   "NumberPassed="+NumberPassed+"\n"+
                   "NumberFailed="+NumberFailed+"\n"+
                   "NumberFailedWithBug="+NumberFailedWithBug+"\n"+
                   "NumberSkipped="+NumberSkipped+"\n"+
                   "NumberPreFailed="+NumberPreFailed+"\n"+
                   "NumberPostFailed="+NumberPostFailed+"\n"+
                   "NumberTimeOutFailed="+NumberTimeOutFailed+"\n"+
                   "NumberTotal="+NumberTotal+"\n"+
                   "RunException="+RunException;
        }
    }

    /// <summary>
    /// Sends events for the functional scehduler.
    /// </summary>
    public class FuncSchedulerEvents
    {
        private TestEventListener eventListener;

        public void Initialize(TestEventListener listener)
        {
            eventListener=listener;
        }

        //Called when a group is being started
        public void NodeGroupStart(TestNode node)
        {
            CoreGlobal.RO.Info("Starting Group "+node.FullName);
            eventListener.OnTestEvent(new TestEventArgs(node, "Starting a group", TestAction.Start));
        }

        //Called when a group finishes
        public void NodeGroupFinish(TestNode node)
        {
            //determine whether the anything failed in the group to see if we failed
            bool anyFailed=false;
            bool anyPassed=false;
            foreach (TestNode child in node.Children)
            {
                if (child.FunctionalData!=null)
                {
                    anyFailed=anyFailed || child.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.FAILED;
                    anyPassed=anyPassed || child.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.PASSED;
                }
            }

            //
            if (anyFailed)
            {
                node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.FAILED;
                CoreGlobal.RO.Error("Group "+node.FullName+" FAILED in "+(node.FunctionalData.SchedulerData.TotalTime).TotalSeconds+"s");
                eventListener.OnTestEvent(new TestEventArgs(node, "Group Failed", TestAction.Fail));
            }
            else if (anyPassed)
            {
                node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.PASSED;
                CoreGlobal.RO.Success("Group "+node.FullName+" PASSED in "+(node.FunctionalData.SchedulerData.TotalTime).TotalSeconds+"s");
                eventListener.OnTestEvent(new TestEventArgs(node, "Group Passed", TestAction.Pass));
            }
            else //in this case, a group contained tests, but none of them were able to run
            {
                node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.NOT_EXECUTED;

                CoreGlobal.RO.Warn("Group "+node.FullName+" HAD NO EXECUTION in "+(node.FunctionalData.SchedulerData.TotalTime).TotalSeconds+"s");
                eventListener.OnTestEvent(new TestEventArgs(node, "Group Had No Execution", TestAction.Fail));
            }
        }

        //Called when the whole run is starting
        public void WholeRunStarting()
        {
            eventListener.OnTestEvent(new TestEventArgs(null, "Starting run", TestAction.StartAll));
        }

        //Called when the whole run is finishing
        public void WholeRunEnding()
        {
            eventListener.OnTestEvent(new TestEventArgs(null, "Finished run", TestAction.StopAll));
        }

        //Called when the test node's PreRun is being called
        public void NodeResultPreStart(TestNode node)
        {
            CountTowardsTotal(node);

            eventListener.OnTestEvent(new TestEventArgs(node, "Pre-Running a node", TestAction.PreStart));
        }

        //Called when the test node's PostRun is being called
        public void NodeResultPostStart(TestNode node)
        {
            eventListener.OnTestEvent(new TestEventArgs(node, "Post-Running a node", TestAction.PostStart));
        }

        //Called when the test node's Run is being called
        public void NodeResultStart(TestNode node)
        {
            CoreGlobal.RO.Info("Running {0}", node.FullName);
            eventListener.OnTestEvent(new TestEventArgs(node, "Running a node", TestAction.Start));
        }

        //Called when the test run is paused while processing a node.
        public void NodePause(TestNode node)
        {
            CoreGlobal.RO.Info("Paused running on {0}", node.FullName);
            eventListener.OnTestEvent(new TestEventArgs(node, "Paused run", TestAction.Pause));
        }

        //Called when the test run is resumed after being paused while processing a node.
        public void NodeResume(TestNode node)
        {
            CoreGlobal.RO.Info("Resumed running on {0}", node.FullName);
            eventListener.OnTestEvent(new TestEventArgs(node, "Resumed run", TestAction.Resume));
        }

        //Called when a test node is being retried
        public void NodeResultRetry(TestNode node)
        {
            if (node.ChildrenCount==0)
            {
                bool hasBug = false;
                if (node.FunctionalData.SchedulerData.NumberFailedWithBug != 0)
                {
                    hasBug = true;
                }

                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Decrement(ref cur.FunctionalData.SchedulerData.NumberFailed);
                    if (hasBug)
                    {
                        System.Threading.Interlocked.Decrement(ref cur.FunctionalData.SchedulerData.NumberFailedWithBug);
                    }

                    cur=cur.Parent;
                }
            }

            CoreGlobal.RO.Info("Retrying "+node.FullName);
            eventListener.OnTestEvent(new TestEventArgs(node, "Retrying a node", TestAction.Retry));
        }

        //Fails a test node with exception details
        public void NodeResultFail(TestNode node, string reason, Exception e)
        {
            // determine if a known bug was involved
            KnownBugException kbe = e as KnownBugException;
            int bugid = 0;
            string bugdb = null;

            if (kbe != null)
            {
                bugid = kbe.BugID;
                bugdb = kbe.BugDatabase;
            }
            else if (node.FunctionalData.BugID != 0)
            {
                bugid = node.FunctionalData.BugID;
                bugdb = node.FunctionalData.BugDatabase;
                CoreGlobal.RO.Warn(node.FullName+" has failed with a non-KnownBugException and the BugID field set.  Please update this test to throw a KnownBugException if this is actually a known bug.");
            }

            // update results throughout the tree
            if (node.ChildrenCount==0)
            {
                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberFailed);
                    if (bugid != 0)
                    {
                        System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberFailedWithBug);
                    }

                    cur=cur.Parent;
                }
            }

            node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.FAILED;
            if (reason!=null && reason.Length>0)
            {
                CoreGlobal.RO.Error(reason+(e!=null?"\n"+e:""));
            }
            CoreGlobal.RO.Error(node.FullName+" FAILED in "+(node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime).TotalSeconds+"s");

            eventListener.OnTestEvent(new TestEventArgs(node, reason, e, TestAction.Fail, bugid, bugdb));
        }

        //Passes a test node
        public void NodeResultPass(TestNode node)
        {
            if (node.ChildrenCount==0)
            {
                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberPassed);

                    cur=cur.Parent;
                }
            }

            node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.PASSED;
            CoreGlobal.RO.Success(node.FullName+" PASSED in "+(node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime).TotalSeconds+"s");
            eventListener.OnTestEvent(new TestEventArgs(node, "", TestAction.Pass));
        }

        //Test node time out
        public void NodeResultTimeOut(TestNode node)
        {
            TestNode cur = node;
            while (cur != null)
            {
                System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberTimeOutFailed);

                cur = cur.Parent;
            }

            node.FunctionalData.SchedulerData.RunResult = TEST_RESULTS.FAILED;
            CoreGlobal.RO.Error(node.FullName + " exceeded execution timeout period.");
            eventListener.OnTestEvent(new TestEventArgs(node, "Timed Out", TestAction.Timeout));
        }

        //A test node was skipped, either by an ignore attribute or because it returned that it didn't run
        public void NodeResultSkip(TestNode node, string reason)
        {
            if (node.FunctionalData==null || !node.FunctionalData.SchedulerData.IsProcessed)
                return;

            UncountTowardsTotal(node);

            if (node.ChildrenCount==0)
            {
                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberSkipped);

                    cur=cur.Parent;
                }
            }

            node.FunctionalData.SchedulerData.RunResult = TEST_RESULTS.NOT_EXECUTED;

            CoreGlobal.RO.Info(String.Format("{0} SKIPPED({1}) in {2}s", node.FullName, reason, (node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime).TotalSeconds));
            eventListener.OnTestEvent(new TestEventArgs(node, String.Format(reason), TestAction.Ignore));

            //mark all children as skipped as well
            foreach (TestNode child in node.Children)
                NodeResultSkip(child, reason);
        }

        //Indicates that a PreRun failed on a node (or a dependency was not met, in which case this is called without a preceding PreRun start event)
        public void NodePreRunFailed(TestNode node, string reason, System.Exception e, bool outputMessage)
        {
            CountTowardsTotal(node);

            TestNode cur=node;
            while (cur!=null)
            {
                System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberPreFailed);

                cur=cur.Parent;
            }

            if (outputMessage)
            {
                CoreGlobal.RO.Error(reason+(e!=null?"\n"+e:""));
            }

            node.FunctionalData.SchedulerData.RunResult=TEST_RESULTS.FAILED;
            if (e!=null)
            {
                eventListener.OnTestEvent(new TestEventArgs(node, reason, e, TestAction.PreFail));
            }
            else
            {
                eventListener.OnTestEvent(new TestEventArgs(node, reason, TestAction.PreFail));
            }
        }

        //Indicates that a PostRun failed on a node
        public void NodePostRunFailed(TestNode node, string reason, System.Exception e)
        {
            CountTowardsTotal(node); //normally way may not have counted a node that returned not executed... however, it postrun fails we will count it anyways, since something is wrong

            TestNode cur=node;
            while (cur!=null)
            {
                System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberPostFailed);

                cur=cur.Parent;
            }

            eventListener.OnTestEvent(new TestEventArgs(node, reason, e, TestAction.PostFail));
        }

        //Called when the test run has completely finished processing a node.
        public void NodeFinish(TestNode node)
        {
            eventListener.OnTestEvent(new TestEventArgs(node, "Node finished", TestAction.Finish));
        }

        //causes a node to be counted as part of the total
        private void CountTowardsTotal(TestNode node)
        {
            if (node.ChildrenCount==0 && node.FunctionalData.SchedulerData.NumberTotal==0)
            {
                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Increment(ref cur.FunctionalData.SchedulerData.NumberTotal);

                    cur=cur.Parent;
                }
            }
        }

        //if a node is counted towards the total right now, remove that count
        private void UncountTowardsTotal(TestNode node)
        {
            if (node.ChildrenCount==0 && node.FunctionalData.SchedulerData.NumberTotal==1)
            {
                TestNode cur=node;
                while (cur!=null)
                {
                    System.Threading.Interlocked.Decrement(ref cur.FunctionalData.SchedulerData.NumberTotal);

                    cur=cur.Parent;
                }
            }
        }
    }

    /// <summary>
    /// Misc helpers for the functional scheduler.
    /// </summary>
    public class FuncSchedulerHelpers
    {
        //Prints out a summary of the run
        public static void PrintRunSummary(TestNode root, int indentLevel)
        {
            if (root.ChildrenCount==0 || root.FunctionalData==null || root.FunctionalData.SchedulerData==null || root.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.NOT_EXECUTED)
            {
                return;
            }

            //print us
            string prefix="";
            for (int i=0; i<indentLevel; ++i)
            {
                prefix+="  ";
            }

            string text=prefix+root.Name;
            text+=" - Passed: "+root.FunctionalData.SchedulerData.NumberPassed+"/"+root.FunctionalData.SchedulerData.NumberTotal;
            if (root.FunctionalData.SchedulerData.NumberTotal>0)
            {
                text+=" ("+(int)((100.0f*root.FunctionalData.SchedulerData.NumberPassed/root.FunctionalData.SchedulerData.NumberTotal))+"%)";
            }

            if (root.FunctionalData.SchedulerData.NumberFailed>0)
            {
                text+=",  Failed: " + root.FunctionalData.SchedulerData.NumberFailed + "/" + root.FunctionalData.SchedulerData.NumberTotal;

                if (root.FunctionalData.SchedulerData.NumberFailedWithBug > 0)
                {
                    text += " (Bugs: " + root.FunctionalData.SchedulerData.NumberFailedWithBug + ")";
                }
            }

            if (root.FunctionalData.SchedulerData.NumberPreFailed>0)
            {
                text+=",  PreFailed: " + root.FunctionalData.SchedulerData.NumberPreFailed;
            }

            if (root.FunctionalData.SchedulerData.NumberPostFailed>0)
            {
                text+=",  PostFailed: " + root.FunctionalData.SchedulerData.NumberPostFailed;
            }

            if (root.FunctionalData.SchedulerData.NumberSkipped>0)
            {
                text+=",  Skipped: " + root.FunctionalData.SchedulerData.NumberSkipped;
            }

            if (root.FunctionalData.SchedulerData.NumberTimeOutFailed > 0)
            {
                text += ",  Timed out: " + root.FunctionalData.SchedulerData.NumberTimeOutFailed + "/" + root.FunctionalData.SchedulerData.NumberTotal;
            }

            text+=",  Time: "+root.FunctionalData.SchedulerData.TotalTime.TotalSeconds+"s";

            if (root.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.FAILED)
            {
                CoreGlobal.RO.Error(text);
            }
            else if (root.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.PASSED)
            {
                CoreGlobal.RO.Success(text);
            }
            else
            {
                CoreGlobal.RO.Warn(text);
            }

            //print children
            foreach (TestNode child in root.Children)
            {
                PrintRunSummary(child, indentLevel+1);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\FuncScheduler.cs ===
using System;
using System.IO;
using System.Threading;
using System.Collections.Generic;
using System.Text;
using System.Xml.Serialization;

using ServerTestFramework;
using ServerTestFramework.Utilities.AsyncUtils;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core.Utilities;


namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Overall parameters to the functional scheduler.
    /// </summary>
    public class FunctionalSchedulerSettings
    {
        public int    TimesToTryRun   = 1;             //The number of times to try prerun, run, and postrun (for purposes of retrying failures).
        public bool   AllowAsync      = true;          //Allow nodes to run in parallel if they are marked for it.
        public bool   RunLooped       = false;         //Run tests in a loop until told to stop.
        public bool   DryRun          = false;         //If true, the scheduler is run normally (including generating events), but no Run/PreRun/PostRun methods are actually called on the tests, and everything returns passed.
        public bool   SkipPreRun      = false;         //If true, PreRun will not be called and no events will be generated for PreRun
        public bool   SkipPostRun     = false;         //If true, PostRun will not be called and no events will be generated for PostRun
    }

    /// <summary>
    /// The functional scheduler.
    /// </summary>
    public class FuncScheduler: TestScheduler
    {
        //Stored data we need
        FuncSchedulerEvents EventSender=new FuncSchedulerEvents();
        IEnumerable<TestNode> roots;
        FunctionalSchedulerSettings settings;
        MemoryReportDestination rootLogDestination;

        bool isStopping=false;
        volatile bool isRunning=false;
        volatile Thread runnerThread=null;
        object runnerThreadLock=new object();
        Dictionary<string, Dictionary<string, bool>> NodePrerequisitesDatas=null;
        bool isPaused=false;
        ManualResetEvent pauseBlocker=new ManualResetEvent(true);


        #region Scheduler Interface Implementation

        //Set up the scheduler.
        public void Initialize(FunctionalSchedulerSettings schedSettings, TestEventListener listener, IEnumerable<TestNode> rootNodes)
        {
            //store important parts
            roots=rootNodes;
            settings=schedSettings;

            //set up event listener
            if (listener==null)
            {
                listener=new MultiTestEventListener();
            }

            EventSender.Initialize(listener);
        }

        //Run the tests and block until either someone calls Stop or the tests finish.
        public void Run()
        {
            if (!settings.RunLooped && !settings.DryRun)
            {
                rootLogDestination = new MemoryReportDestination();
                Report.GetRoot().AddReportDestination(rootLogDestination);
            }

            isStopping=false;
            isRunning=true;
            Resume(); //clear out any stray paused state

            try
            {
                //clean it up for each new run.
                if (NodePrerequisitesDatas != null)
                {
                    NodePrerequisitesDatas.Clear();
                }

                //do run
                do
                {
                    ResetNodeData(roots);
                    EventSender.WholeRunStarting();

                    DateTime startTime=DateTime.Now;
                    bool aborted=false;
                    try
                    {
                        runnerThread=Thread.CurrentThread;

                        try
                        {
                            RunNodeList(roots);
                            CoreGlobal.RO.Info("");
                        }
                        catch (ThreadAbortException)
                        {
                            aborted=true;
                            Thread.ResetAbort();
                        }
                        catch (Exception runExc)
                        {
                            CoreGlobal.RO.Fatal("Unexpected exception in functional scheduler: "+runExc);
                            isStopping=true;
                        }
                    }
                    finally
                    {
                        //lock (runnerThreadLock)
                        {
                            runnerThread=null;
                        }
                    }

                    DateTime endTime=DateTime.Now;
                    EventSender.WholeRunEnding();

                    //print results
                    if (isStopping)
                    {
                        aborted=true;
                    }

                    CoreGlobal.RO.Info("Functional Run "+(aborted?"aborted after":"completed in")+" "+(endTime-startTime).TotalSeconds+"s");
                    foreach (TestNode root in roots)
                    {
                        FuncSchedulerHelpers.PrintRunSummary(root, 0);
                    }
                    if (!settings.RunLooped && !settings.DryRun)
                        SerializeRun();
                } while (settings.RunLooped && !isStopping);
            }
            catch (Exception fre)
            {
                CoreGlobal.RO.Error("Unexpected exception in functional runner: "+fre);
            }
            finally
            {
                isRunning=false;

                Report root = Report.GetRoot();

                root.BlockUntilQueuedLinesAreProcessed();

                if (root.ContainsReportDestination(rootLogDestination))
                    root.RemoveReportDestination(rootLogDestination);
            }
        }

        //Pause running tests.
        public void Pause()
        {
            if (isPaused || !isRunning)
            {
                return;
            }

            isPaused=true;
            pauseBlocker.Reset();
        }

        //Resume running tests if paused.
        public void Resume()
        {
            isPaused=false;
            pauseBlocker.Set();
        }

        //Abort running tests.
        public void Stop()
        {
            isStopping=true;

            Resume(); //need to unpause if we are paused so the manual reset event unblocks so that thread abort can be processed.

            if (runnerThread!=null && isRunning)
            {
                //lock (runnerThreadLock)
                {
                    if (runnerThread!=null && isRunning)
                    {
                        runnerThread.Abort();
                    }
                }
            }

            while (isRunning)
            {
                //TODO: using a blocking object so Run can signal us when done
                System.Threading.Thread.Sleep(50);
            }
        }

        public bool IsPaused()
        {
            return isPaused;
        }

        //Validates that the current scheduler settings are valid.
        public bool ValidateParameters()
        {
            if (roots==null || settings==null)
                return false;
            else
                return true;
        }

        #endregion //Scheduler Interface Implementation

        #region Running Code

        //Prepares a tree to be used by the functional scheduler by initializing all node-specific data
        private void ResetNodeData(IEnumerable<TestNode> nodes)
        {
            foreach (TestNode node in nodes)
            {
                if (node.FunctionalData!=null)
                {
                    node.FunctionalData.SchedulerData=new FunctionalSchedulerNodeData();

                    ResetNodeData(node.Children);
                }
            }
        }

        private void WaitForPause(TestNode node)
        {
            if (isPaused)
            {
                EventSender.NodePause(node);
                pauseBlocker.WaitOne();
                EventSender.NodeResume(node);
            }
        }

        //Processes a single node, including pre/post setup.
        private void RunNode(TestNode node)
        {
            if (isStopping)
            {
                return;
            }

            //we only care about functional nodes
            if (node.FunctionalData==null)
            {
                return;
            }

            //check if this node is elligable to be run
            if (!node.FunctionalData.Enabled || node.FunctionalData.SchedulerData.IsRun) //if not enabled or already run
            {
                return;
            }

            node.FunctionalData.SchedulerData.IsRun=true;
            node.FunctionalData.SchedulerData.IsProcessed=true; //we're processing it now

            if (node.FunctionalData.Ignored) //ignored
            {
                EventSender.NodeResultSkip(node, "The node is marked as Ignored");
                return;
            }

            //run it
            node.FunctionalData.SchedulerData.InProgress=true;
            ThreadTracker.Reset();
            ThreadTracker.SetTest(node.FullName); //set this test name to this thread

            WaitForPause(node);

            try
            {
                //make sure all dependencies run first
                if (node.FunctionalData.Dependencies.Count>0)
                {
                    foreach (string dependantName in node.FunctionalData.Dependencies)
                    {
                        //find the node we are dependant on
                        TestNode dependantNode=null;
                        if (!dependantName.Contains(".")) //refers to a sibling
                        {
                            if (node.Parent!=null)
                            {
                                dependantNode=TestNode.FindNode(node.Parent, node.Parent.Name+"."+dependantName);
                            }
                        }
                        else //fully qualitfied name
                        {
                            foreach (TestNode treeRoots in roots)
                            {
                                dependantNode=TestNode.FindNode(treeRoots, dependantName);
                                if (dependantNode!=null) break;
                            }
                        }

                        if (dependantNode==null)
                        {
                            EventSender.NodePreRunFailed(node, node.FullName+" cannot run because it depends on a node that does not exist: "+dependantName, null, true);
                            return;
                        }

                        if (dependantNode.FunctionalData==null)
                        {
                            EventSender.NodePreRunFailed(node, node.FullName+" cannot run because it depends on a node that is not a functional node: "+dependantName, null, true);
                            return;
                        }

                        //now run the dependant node
                        if (!dependantNode.FunctionalData.Enabled)
                        {
                            dependantNode.FunctionalData.Enabled=true;
                        }
                        RunNode(dependantNode);

                        ThreadTracker.Reset();
                        ThreadTracker.SetTest(node.FullName); //set this test name back to this thread, since running the other node probably changed it

                        do //TODO: use a blocking object here to wait instead of this
                        {
                            System.Threading.Thread.Sleep(10);
                        } while (dependantNode.FunctionalData.SchedulerData.InProgress);

                        if (dependantNode.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.FAILED)
                        {
                            EventSender.NodePreRunFailed(node, node.FullName+" cannot run because a dependent node failed: "+dependantName, null, true);
                            return;
                        }

                        if (dependantNode.FunctionalData.SchedulerData.RunResult==TEST_RESULTS.NOT_EXECUTED)
                        {
                            EventSender.NodePreRunFailed(node, node.FullName+" cannot run because a dependent node was not run: "+dependantName, null, true);
                            return;
                        }
                    }
                }

                //now do the actual node
                try
                {
                    System.Exception prerunException=null;
                    if (!settings.SkipPreRun)
                    {
                        node.FunctionalData.SchedulerData.IsPrerunning=true;
                        EventSender.NodeResultPreStart(node);
                        prerunException=TryNodePreRun(node);
                        node.FunctionalData.SchedulerData.IsPrerunning=false;
                    }

                    if (prerunException==null)
                    {
                        //if the node has children, we need to run those instead, else we just run the node
                        if (node.ChildrenCount>0)
                        {
                            RunNodeList(node.Children);
                        }
                        else
                        {
                            RunNodeSingle(node);
                        }
                    }
                    else //prerun failed
                    {
                        if (prerunException is DidNotExecuteException)
                        {
                            EventSender.NodeResultSkip(node, prerunException.Message);
                        }
                        else
                        {
                            EventSender.NodePreRunFailed(node, "PreRun (Prerequisites) failed.", prerunException, false);
                        }
                    }
                }
                finally
                {
                    node.FunctionalData.SchedulerData.IsPrerunning=false;

                    if (!settings.SkipPostRun)
                    {
                        try
                        {
                            node.FunctionalData.SchedulerData.IsPostrunning=true;
                            EventSender.NodeResultPostStart(node);
                            System.Exception postrunException=TryNodePostRun(node);
                            node.FunctionalData.SchedulerData.IsPostrunning=false;
                            if (postrunException != null)
                            {
                                if (postrunException is DidNotExecuteException)
                                {
                                    EventSender.NodeResultSkip(node, postrunException.Message);
                                }
                                else
                                {
                                    EventSender.NodePostRunFailed(node, "PostRun (Cleanup) failed.", postrunException);
                                }
                            }
                        }
                        finally
                        {
                            node.FunctionalData.SchedulerData.IsPostrunning=false;
                        }
                    }
                }
            }
            finally
            {
                node.FunctionalData.SchedulerData.InProgress=false;
                EventSender.NodeFinish(node);

                ThreadTracker.Reset();

                // set thread's test name to parent
                if (node.Parent!=null)
                {
                    ThreadTracker.SetTest(node.Parent.FullName);
                }
            }
        }

        /// <summary>
        /// Returns a serializable dictionary which contains the contents of the functional
        /// scheduler node data of a subtree which is passed in.
        /// </summary>
        /// <param name="rootNode"></param>
        /// <returns></returns>
        private SerializableDictionary<string, FunctionalSchedulerNodeData> GetSerializableFunctionalData(TestNode rootNode)
        {
            if (rootNode == null)
                return null;

            List<TestNode> nodes = new List<TestNode>();
            rootNode.GetFlattenedSubtree(ref nodes);
            SerializableDictionary<string, FunctionalSchedulerNodeData> data = new SerializableDictionary<string, FunctionalSchedulerNodeData>();
            foreach (TestNode node in nodes)
            {
                if (node.FunctionalData != null)
                {
                    FunctionalSchedulerNodeData nd = node.FunctionalData.SchedulerData;
                    if (nd != null && nd.IsRun)
                        data.Add(node.FullName, nd);
                }
            }

            return data;
        }

        /// <summary>
        /// Takes the first node's name (for convenience and assuming that most runs are a single-dll)
        /// and serializes the current run's results to a file in the format 
        /// SuiteNameSerializedRunResultsTimestamp.xml. Saves into the FuncOutput\SerializedRunResults path.
        /// </summary>
        public void SerializeRun()
        {
            string path = null;
            try
            {
                IEnumerator<TestNode> localRoots = roots.GetEnumerator();
                localRoots.MoveNext();

                string name = String.Empty;
                if (localRoots.Current != null)
                {
                    TestNode last;
                    do
                    {
                        name += localRoots.Current.Name;
                        last = localRoots.Current;
                        localRoots.MoveNext();
                    }
                    while (localRoots.Current != last);

                    name = name.Substring(0, (name.Length > 100) ? 100 : name.Length); //El Truncate-o.

                    string timeStamp = DateTime.Now.ToString("MMddyyyyHHmmss");

                    path = String.Format("FuncOutput\\SerializedRunResults\\{0}{1}.serializedresult_xml", name, timeStamp);                    
                }
            }
            catch (Exception ex)
            {
                CoreGlobal.RO.Warn("Error while setting up the file to serialize the test run. This can be ignored for testing purposes but probably indicates a bug in STF.");
                CoreGlobal.RO.Warn(ex.Message);
                CoreGlobal.RO.Warn(ex.StackTrace);
            }
            if (!String.IsNullOrEmpty(path))
                SerializeRun(path);
        }

        /// <summary>
        /// Takes the root loglines and the test case functional scheduler node data and serializes them into a file.        
        /// </summary>
        /// <param name="path"></param>
        public void SerializeRun(string path)
        {
            FileStream resultsStream = null;
            try
            {
                if (!Directory.Exists("FuncOutput\\SerializedRunResults"))
                    Directory.CreateDirectory("FuncOutput\\SerializedRunResults");
                resultsStream = File.Create(path);

                SerializedRunResults results = new SerializedRunResults();
                List<SerializableDictionary<string, FunctionalSchedulerNodeData>> data = new List<SerializableDictionary<string, FunctionalSchedulerNodeData>>();
                foreach (TestNode node in roots)
                {
                    data.Add(GetSerializableFunctionalData(node));
                }

                results.SchedulerData = data;
                results.LogLines = rootLogDestination.LogLines;

                XmlSerializer serializer = new XmlSerializer(typeof(SerializedRunResults));
                serializer.Serialize(resultsStream, results);
            }
            catch (Exception ex)
            {
                CoreGlobal.RO.Warn("Error while serializing the test case run. This can be ignored for testing purposes but probably indicates a bug in STF.");
                CoreGlobal.RO.Warn(ex.Message);
                CoreGlobal.RO.Warn(ex.StackTrace);   
            }
            finally
            {
                try { resultsStream.Close(); } catch (Exception) { }//*GULP*. Don't want to risk it.
            }
        }

        /// <summary>
        /// Collect Prerequisites Data.
        /// </summary>
        private void CollectNodePrerequisitesData(TestNode root)
        {
            CollectNodePrerequisitesDataRecurse(root.Children);
        }

        /// <summary>
        /// Traverse the nodes tree to populate NodePrerequisitesData.
        /// </summary>
        /// <param name="nodes"></param>
        private void CollectNodePrerequisitesDataRecurse(System.Collections.Generic.IEnumerable<TestNode> nodes)
        {
            foreach (TestNode node in nodes)
            {
                if (node.FunctionalData != null)
                {
                    if (node.ChildrenCount > 0) //group node
                    {
                        CollectNodePrerequisitesDataRecurse(node.Children);
                    }
                    else //leaf node
                    {
                        //check if this node is elligable to be run
                        //if not enabled or already run or ignored, skip
                        if (!node.FunctionalData.Enabled
                            || node.FunctionalData.SchedulerData.IsRun
                            || node.FunctionalData.Ignored)
                        {
                            continue;
                        }

                        NodeTaggingData.ValueSet nodeReqs = node.TaggingData.GetAllTrunkValues("Prerequisite");


                        if (nodeReqs.Count > 0)
                        {
                            foreach (NodeTaggingData.Value myReq in nodeReqs)
                            {
                                string key = myReq.ToString().ToLower();
                                if (!NodePrerequisitesDatas[node.ContainingDll].ContainsKey(key))
                                {
                                    //Initalize the value to be true so that by default all the envrequirements are met.
                                    NodePrerequisitesDatas[node.ContainingDll].Add(key, true);
                                }
                            }
                        }
                    }
                }
            }
        }

        //Attempts to run the setup steps for a node.  Returns null on success, else returns the exception that was thrown.
        private System.Exception TryNodePreRun(TestNode node)
        {
            System.Exception exception=null;
            int tryCount=(node.FunctionalData.AllowRetries?settings.TimesToTryRun:1);
            for (int retry=0; retry<tryCount; ++retry)
            {
                if (retry>0)
                {
                    CoreGlobal.RO.Info("Retrying PreRun.");
                }

                WaitForPause(node);

                try
                {
                    if (!settings.DryRun)
                    {
                        if (node.Parent == null)
                        {
                            lock (runnerThreadLock)
                            {
                                if (NodePrerequisitesDatas == null)
                                    NodePrerequisitesDatas = new Dictionary<string, Dictionary<string, bool>>();
                                if (!NodePrerequisitesDatas.ContainsKey(node.ContainingDll))
                                {
                                    NodePrerequisitesDatas.Add(node.ContainingDll, new Dictionary<string, bool>());
                                }
                                Dictionary<string, bool> NodePrerequisitesData = NodePrerequisitesDatas[node.ContainingDll];
                                NodePrerequisitesData.Clear();

                                // We do the Prerequisite at suite level in order to
                                // - avoid duplicate check
                                // - find out what is missing as soon as possible
                                CollectNodePrerequisitesData(node);
                                // Leave the actual Prerequisite check to each of the suite
                                // so, each of the suite can decide what I want to check.
                                if (!node.Prerequisites(ref NodePrerequisitesData))
                                {
                                    CoreGlobal.RO.Warn("Prerequisites Check for suite " + node.ContainingDll + " failed. Some of tests may fail.");
                                }
                            }
                        }
                        else
                        {
                            // We will check prerequisites flag at testcases/testgroup level and see if it is being met.
                            // If not, skip node run.
                            NodeTaggingData.ValueSet nodeReqs = node.TaggingData.GetAllTrunkValues("Prerequisite");

                            foreach (NodeTaggingData.Value myReq in nodeReqs)
                            {
                                string key = myReq.ToString().ToLower();

                                if (NodePrerequisitesDatas[node.ContainingDll].ContainsKey(key))
                                {
                                    if (!NodePrerequisitesDatas[node.ContainingDll][key])
                                    {
                                        throw new TestSuiteException("Prerequisites Check failed. Skip the node. Please check the status: " + key + ".");
                                    }
                                }
                                else
                                {
                                    //We shouldn't be here
                                    throw new StfException(key + " was not found in NodePrerequisitesData. What's up?");
                                }
                            }
                        }
                        node.Scheduler_DoPreRun(RUN_TYPE.FUNCTIONAL);
                    }
                    return null;
                }
                catch (ThreadAbortException)
                {
                    EventSender.NodeResultSkip(node, "The run was aborted"); //mark it as skipped if it was interrupted
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Error("PreRun (Prerequisites) failed on "+node.FullName+": "+e);
                    exception=e;
                }
            }

            return exception;
        }

        //Attempts to run the cleanup steps for a node.  Returns null on success, else returns the exception that was thrown.
        private System.Exception TryNodePostRun(TestNode node)
        {
            System.Exception exception=null;
            int tryCount=(node.FunctionalData.AllowRetries?settings.TimesToTryRun:1);
            for (int retry=0; retry<tryCount; ++retry)
            {
                if (retry>0)
                {
                    CoreGlobal.RO.Info("Retrying PostRun.");
                }

                WaitForPause(node);

                try
                {
                    if (!settings.DryRun)
                    {
                        node.Scheduler_DoPostRun(RUN_TYPE.FUNCTIONAL);
                    }
                    return null;
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Warn("Node PostRun failed on "+node.FullName+": "+e);
                    exception=e;
                }
            }

            return exception;
        }
        //Thread to run a single node
        private static void RunNodeSingle_ThreadProc(object data)
        {
            TestNode node=(TestNode)data;
            node.FunctionalData.SchedulerData.RunException=null;
            try
            {
                node.Run(RUN_TYPE.FUNCTIONAL);
            }
            catch (Exception e)
            {
                node.FunctionalData.SchedulerData.RunException=e;
            }
        }

        //Runs the contents (not pre/post) of an actual test node
        private void RunNodeSingle(TestNode node)
        {
            EventSender.NodeResultStart(node);

            int tryCount=(node.FunctionalData.AllowRetries?settings.TimesToTryRun:1);
            int timeOut=node.FunctionalData.Timeout;
            for (int retry=0; retry<tryCount; ++retry)
            {
                if (retry>0)
                {
                    EventSender.NodeResultRetry(node);
                }

                WaitForPause(node);

                //run it
                Exception runException=null;
                bool isTimeOut=false;
                try
                {
                    Thread runNodeSingleThread=null;
                    try
                    {
                        node.FunctionalData.SchedulerData.StartTime=DateTime.Now;
                        if (!settings.DryRun)
                        {
                            runNodeSingleThread = ThreadMaker.CreateThread(RunNodeSingle_ThreadProc, (object)node);
                            runNodeSingleThread.IsBackground=true;
                            runNodeSingleThread.Start();
                            runNodeSingleThread.Join(timeOut);

                            if (runNodeSingleThread.IsAlive)
                            {
                                isTimeOut = true;
                            }
                            else
                            {
                                runException=node.FunctionalData.SchedulerData.RunException;
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        runException=new DidNotExecuteException(e.Message);
                        throw;
                    }
                    finally
                    {
                        node.FunctionalData.SchedulerData.EndTime=DateTime.Now;
                        node.FunctionalData.SchedulerData.TotalTime+=(node.FunctionalData.SchedulerData.EndTime-node.FunctionalData.SchedulerData.StartTime);
                        if (runNodeSingleThread!=null && runNodeSingleThread.IsAlive)
                        {
                            //Timed out or stopped
                            runNodeSingleThread.Abort();
                            // Wait for the thread to terminate.
                            runNodeSingleThread.Join();
                        }
                    }
                }
                catch (ThreadAbortException)
                {
                    EventSender.NodeResultSkip(node, "The run was aborted");
                }

                //determine if this is "pass" or skip, and break if it is
                if (runException!=null && runException is DidNotExecuteException)
                {
                    EventSender.NodeResultSkip(node, runException.Message);
                    break;
                }
                else if (node.FunctionalData.ExpectedException==null || settings.DryRun) //we expect no exception
                {
                    if (runException!=null) //got an unexpected exception
                    {
                        EventSender.NodeResultFail(node, "An exception was thrown.", runException);
                    }
                    else //and we got no exception
                    {
                        //If timeout, just break and no retry
                        if (isTimeOut)
                        {
                            EventSender.NodeResultTimeOut(node);
                            break;
                        }

                        //it passed
                        EventSender.NodeResultPass(node);
                        break;
                    }
                }
                else //we expect an exception
                {
                    if (runException==null) //we got none
                    {
                        EventSender.NodeResultFail(node, "No exception thrown, but we expected one of type "+node.FunctionalData.ExpectedException.Name, null);
                    }
                    else if (runException.GetType()!=node.FunctionalData.ExpectedException) //got wrong one
                    {
                        EventSender.NodeResultFail(node, "Expected an exception of type "+node.FunctionalData.ExpectedException.Name+", but got one of type "+runException.GetType().Name+": "+runException, runException);
                    }
                    else //got expected one
                    {
                        EventSender.NodeResultPass(node);
                        break;
                    }
                }
            }
        }

        //Runs a list of nodes
        private void RunNodeList(IEnumerable<TestNode> nodes)
        {
            TestNode groupNode=null;
            foreach (TestNode node in nodes)
            {
                groupNode=node.Parent;
                break;
            }

            if (groupNode!=null)
            {
                EventSender.NodeGroupStart(groupNode);
                groupNode.FunctionalData.SchedulerData.StartTime=DateTime.Now;
            }

            //run them
            try
            {
                foreach (TestNode node in nodes)
                {
                    if (node.FunctionalData!=null) //functional nodes only
                    {
                        if (!node.FunctionalData.SchedulerData.IsProcessed) //if we have not already processed this node
                        {
                            if (!settings.AllowAsync || node.FunctionalData.AsyncGroup==0) //it should run alone
                            {
                                RunNode(node);
                            }
                            else //it should run as part of a parallel group
                            {
                                //collect all nodes in the list that belong to the same group
                                List<TestNode> parallelList=new List<TestNode>();
                                foreach (TestNode ps in nodes)
                                {
                                    if (ps.FunctionalData!=null && ps.FunctionalData.AsyncGroup==node.FunctionalData.AsyncGroup)
                                    {
                                        ps.FunctionalData.SchedulerData.IsProcessed=true; //we are handling this now
                                        if (ps.FunctionalData.Enabled)
                                        {
                                            parallelList.Add(ps);
                                        }
                                    }
                                }

                                //run that group of them
                                uint maxThreads = 64;
                                uint threadDelay = 10;

                                if (node.Parent!=null)
                                {
                                    maxThreads=node.Parent.FunctionalData.ChildrenMaxParallelThreads;
                                    threadDelay=node.Parent.FunctionalData.ChildrenParallelThreadDelay;
                                }

                                if (parallelList.Count>0)
                                {
                                    ParallelRunner.Run(AsyncRunNodeCallback, (uint)parallelList.Count, maxThreads, parallelList.ToArray(), threadDelay);
                                }
                            }
                        }
                    }
                }
            }
            finally
            {
                if (groupNode!=null)
                {
                    groupNode.FunctionalData.SchedulerData.EndTime=DateTime.Now;
                    groupNode.FunctionalData.SchedulerData.TotalTime+=(groupNode.FunctionalData.SchedulerData.EndTime-groupNode.FunctionalData.SchedulerData.StartTime);
                    EventSender.NodeGroupFinish(groupNode);
                }
            }
        }

        //Callback for running nodes in parallel
        public void AsyncRunNodeCallback(uint num, object array)
        {
            RunNode(((TestNode[])array)[(int)num]);
        }

        #endregion // Running Code
    }

    /// <summary>
    /// Used to serialize a single run's worth of data to a file.
    /// </summary>
    [Serializable]
    public class SerializedRunResults
    {
        public List<SerializableDictionary<string, FunctionalSchedulerNodeData>> SchedulerData { get; set; }
        public List<Report.ReportLine> LogLines { get; set; }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerCommon.cs ===
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;
using System.IO;
using System.Threading;
using System;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    /// <summary> Current state of the scheduler. </summary>
    public enum StressSchedulerStage
    {
        NotStarted,
        Running
    };

    /// <summary>
    /// Interface for stress test schedulers.
    /// </summary>
    public interface StressTestScheduler
    {
        /// <summary>
        /// Called to set up the scheduler.
        /// </summary>
        void Initialize(StfXmlDoc config, StressJobList jobListReference, StressSettingsCommon initialCommonSettings);

        /// <summary>
        /// Shuts down the scheduler.
        /// </summary>
        void Shutdown();

        /// <summary>
        /// This call will block and run tests and block until someone calls Stop.
        /// </summary>
        void Run();

        /// <summary>
        /// Stop running tests.
        /// </summary>
        void Stop();

        /// <summary>
        /// Gets the control associated with the scheduler.
        /// </summary>
        Control SchedulerControl
        {
            get;
        }

        /// <summary>
        /// May be called regularly by anything using the scheduler.  For instance can be used to update the
        /// control with status information.
        /// </summary>
        void Tick ();

        /// <summary>
        /// Gets a scale value from a stress job.
        /// </summary>
        /// <param name="job">The job to get from.</param>
        /// <returns>The scale value from the stress job.</returns>
        float GetScaleValue (StressJob job);

        /// <summary>
        /// Sets a scale value on a stress job.
        /// </summary>
        /// <param name="job">The job to set on.</param>
        /// <param name="val">The scale value to set.</param>
        void SetScaleValue (StressJob job, float val);

        /// <summary>
        /// The name of the scale value used by this scheduler.  Displayed on GUI elements.
        /// </summary>
        string ScaleName
        {
            get;
        }

        /// <summary>
        /// Load settings from an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        void LoadSettings(XmlNode node);

        /// <summary>
        /// Save settings to an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        void SaveSettings(XmlNode node);

        /// <summary> Returns the settings used by the current scheduler. </summary>
        StressSettingsCommon GetSettings();

        /// <summary>
        /// Number of threads in use by this scheduler that are currently active (not stopped)
        /// </summary>
        int ActiveThreads { get; }
    }

    /// <summary> Settings shared by all stress schedulers. </summary>
    public class StressSettingsCommon
    {
        //common settings
        public bool SkipPreRun=false;   //prevents calling PreRun when stress starts
        public bool SkipPostRun=false;  //prevents calling PostRun when stress stops

        //not really a setting, but the base for the actual schedulers is an interface which can't declare members, so putting it here for now
        public volatile StressSchedulerStage Stage=StressSchedulerStage.NotStarted;

        /// <summary> Copies all our members in from another settings object. </summary>
        public void CopyFrom(StressSettingsCommon other)
        {
            SkipPreRun=other.SkipPreRun;
            SkipPostRun=other.SkipPostRun;
        }
    }

    /// <summary> Helpers for doing things with the stress schedulers. </summary>
    public static class StressSchedulerHelpers
    {
        /// <summary> Starts a stress scheduler and blocks until it stops running. </summary>
        public static void RunScheduler(StressTestScheduler scheduler, StressJobList stressJobs)
        {
            //Don't allow start if it's already running.
            if (scheduler.GetSettings().Stage!=StressSchedulerStage.NotStarted)
            {
                CoreGlobal.RO.Error("Unable to start Stress Scheduler("+scheduler.GetType()+") because it is not in the NotStarted stage.  It is: "+scheduler.GetSettings().Stage);
                return;
            }

            //Now run
            try
            {
                //Run (blocks until done)
                CoreGlobal.RO.Info("Running Stress.");
                scheduler.GetSettings().Stage=StressSchedulerStage.Running;
                scheduler.Run();
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Error("An error occured running stress:\n" + e.ToString());
            }

            // in case Run fails for some reason, won't hurt if stress has already stopped
            scheduler.GetSettings().Stage=StressSchedulerStage.NotStarted;
            StopScheduler(scheduler);
        }

        /// <summary> Stop a scheduler that is running.  This blocks until the scheduler is finished stopping. </summary>
        public static void StopScheduler(StressTestScheduler scheduler)
        {
            if (scheduler.GetSettings().Stage!=StressSchedulerStage.Running)
            {
                return;
            }

            try
            {
                scheduler.Stop();
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Error("Exception trying to stop scheduler("+scheduler.GetType()+"):\n"+e);
            }

            if (scheduler.GetSettings().Stage!=StressSchedulerStage.NotStarted)
            {
                CoreGlobal.RO.Debug("Waiting on stress scheduler to return to the Not Started stage...");
                //TODO: use blocking objects rather than busy loop
                while (scheduler.GetSettings().Stage!=StressSchedulerStage.NotStarted)
                {
                    Thread.Sleep(100);
                }
            }

            CoreGlobal.RO.Debug("Stress scheduler has finished running.");
        }

        /// <summary> Verifies and performs if needed the PreRun steps for a node and any of its parents. </summary>
        public static bool VerifyOrPerformPreRun(TestNode node, StressSettingsCommon stressSettings)
        {
            //check global settings first
            if (stressSettings.SkipPreRun)
            {
                return true;
            }

            //return instantly for nonactionable states (we don't want to take a lock normally)
            if (node.StressData.RunStatus==StressNodeData.StressRunStatus.Runnable)
            {
                return true;
            }
            else if (node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunFailed || node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunInProgress)
            {
                return false;
            }

            lock (node.StressData.RunStatusLock)
            {
                //check again now that we have the lock
                if (node.StressData.RunStatus==StressNodeData.StressRunStatus.Runnable)
                {
                    return true;
                }
                else if (node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunFailed || node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunInProgress)
                {
                    return false;
                }

                //now kick off the prerun on another thread
                if (node.StressData.RunStatus!=StressNodeData.StressRunStatus.NotStarted)
                {
                    CoreGlobal.RO.Warn("VerifyOrPerformPreRun: Expected status to be NotStarted.  This should never happen.  NOT performing PreRun...");
                    return false;
                }

                node.StressData.RunStatus=StressNodeData.StressRunStatus.PreRunInProgress;
                ThreadMaker.CreateThread(VerifyOrPerformPreRun_ThreadProc, node).Start();
            }

            return node.StressData.RunStatus==StressNodeData.StressRunStatus.Runnable;
        }

        //work performed on a separate thread for VerifyOrPerformPreRun
        private static void VerifyOrPerformPreRun_ThreadProc(object data)
        {
            TestNode node=(TestNode)data;

            lock (node.StressData.RunStatusLock)
            {
                //verify we're in a state that's valid to try this from
                if (!(node.StressData.RunStatus==StressNodeData.StressRunStatus.NotStarted || node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunInProgress))
                {
                    return;
                }

                node.StressData.RunStatus=StressNodeData.StressRunStatus.PreRunInProgress;

                //parents have to be ready first
                if (node.Parent!=null)
                {
                    VerifyOrPerformPreRun_ThreadProc(node.Parent);

                    if (node.Parent.StressData.RunStatus!=StressNodeData.StressRunStatus.Runnable) //if the parent prerun failed, we can't try ours
                    {
                        node.StressData.RunStatus=StressNodeData.StressRunStatus.PreRunFailed;
                        return;
                    }
                }

                //try the PreRun
                try
                {
                    node.Scheduler_DoPreRun(RUN_TYPE.STRESS);
                    node.StressData.RunStatus=StressNodeData.StressRunStatus.Runnable;
                }
                catch (System.Exception e)
                {
                    CoreGlobal.RO.Error("PreRun(Stress) failed for node "+node.FullName+".  This node and any children will not be runnable.\n"+e);
                    node.StressData.RunStatus=StressNodeData.StressRunStatus.PreRunFailed;
                }
            }
        }

        /*/// <summary> Cleans up a node and parents (by running post-run on nodes that failed prerun) so that they may have their PreRun step attempted again. </summary>
        public static void PrepareNodeForRetry(TestNode node)
        {
            if (node.StressData.RunStatus!=StressNodeData.StressRunStatus.PreRunFailed)
            {
                return;
            }

            //todo
        }*/

        /// <summary> Performs PostRun steps for all jobs. </summary>
        public static void PerformPostRun(StressJobList stressJobs, StressSettingsCommon stressSettings)
        {
            //check global settings first
            if (stressSettings.SkipPostRun)
            {
                return;
            }

            //
            CoreGlobal.RO.Info("Calling PostRun on relevent stress nodes...");

            LinkedList<TestNode> preRanNodes=new LinkedList<TestNode>();
            LinkedList<TestNode> parentsToRun=new LinkedList<TestNode>();

            //pre or post run every node
            foreach (StressJob job in stressJobs)
            {
                TestNode node=job.BaseNode;

                for (int i=0; i<2; ++i) //2 passes
                {
                    bool parentPass=(i!=0);

                    if (parentPass) //do parents
                    {
                        parentsToRun.Clear();
                        TestNode parentCur=node.Parent;
                        while (parentCur!=null)
                        {
                            parentsToRun.AddLast(parentCur);
                            parentCur=parentCur.Parent;
                        }

                        foreach (TestNode parent in parentsToRun)
                        {
                            if (!preRanNodes.Contains(parent)) //only if we haven't already done it
                            {
                                preRanNodes.AddFirst(parent);

                                try
                                {
                                    if (parent.StressData.RunStatus!=StressNodeData.StressRunStatus.NotStarted)
                                    {
                                        WaitForPreRunToComplete(parent);
                                        parent.StressData.RunStatus=StressNodeData.StressRunStatus.NotStarted;
                                        parent.Scheduler_DoPostRun(RUN_TYPE.STRESS);
                                    }
                                }
                                catch (System.Exception exc)
                                {
                                    CoreGlobal.RO.Warn("PostRun failed on "+parent+":\n"+exc);
                                }
                            }
                        }
                    }
                    else //do us
                    {
                        try
                        {
                            if (node.StressData.RunStatus!=StressNodeData.StressRunStatus.NotStarted)
                            {
                                WaitForPreRunToComplete(node);
                                node.StressData.RunStatus=StressNodeData.StressRunStatus.NotStarted;
                                node.Scheduler_DoPostRun(RUN_TYPE.STRESS);
                            }
                        }
                        catch (System.Exception exc)
                        {
                            CoreGlobal.RO.Warn("PostRun failed on "+node+":\n"+exc);
                        }
                    }
                }
            }
        }

        //waits on a node to complete the PreRun it has in progress, if any.
        private static void WaitForPreRunToComplete(TestNode node)
        {
            if (node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunInProgress)
            {
                CoreGlobal.RO.Debug("Waiting on "+node.FullName+" to complete PreRun...");
            }

            while (node.StressData.RunStatus==StressNodeData.StressRunStatus.PreRunInProgress)
            {
                System.Threading.Thread.Sleep(50); //todo: use blocking objects instead.  this is a rare condition only on stopping stress, so for now its good enough.
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressJobList.cs ===
using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Xml;
using System.Reflection;
using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    public class StressJob
    {
        // Member vars
        private string          name;
        private bool            IsDynamicTest = false;
        private ConstructorInfo ci;
        private TestResult      results = null;

        public double           TriggerTimeLeft; //used by the TPS scheduler (measured in seconds)

        private TestNode        testbase = null;

        // Properties
        public string       Name            {get {return name;}}
        public TestResult   Results         {get {return results;}}
        public TestNode     BaseNode        { get { return testbase; } }

        // Setting this to true will create a new test object  for every transaction.  Setting to false will cause us to cache the object and re-use it, saving lots and lots of instantiations.  I personally went from 6,800 TPS to 10,500 TPS clientside with this one change.
        public bool AlwaysInstantiate
        {
            get { return testbase.StressData.AlwaysInstantiate; }
            set { testbase.StressData.AlwaysInstantiate = value; }
        }

        public float TargetTPS
        {
            get 
            {
                return testbase.StressData.TargetTPS;
            } 
            set 
            {
                testbase.StressData.TargetTPS = value; 
                if (results != null) 
                    results.TargetTps = value; 
            }
        }

        public float Priority
        {
            get
            {
                return testbase.StressData.Priority;
            }
            set
            {
                float delta = value - testbase.StressData.Priority;
                testbase.StressData.Priority = value;
                if (PriorityChanged != null)
                    PriorityChanged(this, delta);
            }
        }

        public bool Succeeded
        {
            get
            {
                return (
                    Results.Passed >= BaseNode.StressData.Validation.MinPassed &&
                    Results.Failed <= BaseNode.StressData.Validation.MaxFailed &&
                    Results.TotalTPS >= BaseNode.StressData.Validation.MinTotalTPS &&
                    Results.RunningTPS >= BaseNode.StressData.Validation.MinRunningTPS
                    );
            }
        }

        /// <summary>
        /// Constructor for dynamic test cases
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="priority"></param>
        /// <param name="testname"></param>
        /// <param name="allResults"></param>
        public StressJob(TestNode node, float priority, string testname, TestResultCollection allResults)
        {
            testbase=node;
            ci = node.GetType().GetConstructor(Type.EmptyTypes);
            Priority = priority;
            name =testname;
            IsDynamicTest=true;
            results = allResults.CreateTestResult(Name);
        }

        /// <summary>
        /// Regular constructor
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="priority"></param>
        /// <param name="allResults"></param>
        public StressJob(TestNode node, float priority, TestResultCollection allResults)
        {
            name = node.FullName;
            testbase=node;
            ci = node.GetType().GetConstructor(Type.EmptyTypes);
            Priority = priority;
            results = allResults.CreateTestResult(Name);
        }

        /// <summary>
        /// Regular constructor
        /// </summary>
        /// <param name="suiteName"></param>
        /// <param name="type"></param>
        /// <param name="allResults"></param>
        public StressJob(Type type, TestResultCollection allResults)
        {
            name = type.Name;
            ci = type.GetConstructor(Type.EmptyTypes);
            Priority = 0;
            results = allResults.CreateTestResult(Name);
        }

        public TestNode CreateInstance()
        {
            // We are not supposed to cache the object, we should create it every
            // single time.
            if (AlwaysInstantiate)
            {
                if (IsDynamicTest)
                {
                    /*DynamicStressTestBase tbDynamic =(DynamicStressTestBase)ci.Invoke(null);
                    tbDynamic.Initialize(name);
                    return tbDynamic;*/
                    CoreGlobal.RO.Fatal("If you see this, contact the maintainers.  'IsDynamicTest' has unknown purpose and isn't handled.");
                }
                else 
                {
                    TestNode tb = (TestNode)testbase.Clone(); //clone rather than construct, so we have all our prerun and type-specific data still
                    return tb;
                }
            }

                // If we haven't stored the testbase yet, let's call the constructor and
                // store the object. Once. Be careful of multithreading.
            else if (testbase == null)
            {
                // I don't want to lock the obect every time this function gets called --
                // it gets called a lot. We only need the lock for the constructor call.
                // So we're moving the lock to after the check, then we'll have to check 
                // again after acquiring the lock. 
                lock (this)
                {
                    if (testbase != null)
                        return testbase;

                    //How could this happen?  Creating it directly doesn't sound right...
                    CoreGlobal.RO.Warn("Unexpected null case hit in StressJobList");
                    testbase = (TestNode)ci.Invoke(null);
                }
            }
            // Else return cached object.
            return testbase;
        }

        public event PriorityChangedHandler PriorityChanged;
    }

    public delegate void PriorityChangedHandler(StressJob sj, float oldPrioity);

    public class StressJobList : CollectionBase, IEnumerable
    {
        #region Properties and Backing

        //used by the priority scheduler only
        private float totalPriority = 0;
        public float TotalPriority {get {return totalPriority;}}

        private TestResultCollection _test_results;

        /// <summary>
        /// The test results used by this job list.
        /// </summary>
        public TestResultCollection TestResults
        {
            get { return _test_results; }
            set { _test_results = value; }
        }

        #endregion

        /// <summary>
        /// Creates an empty job list.
        /// </summary>
        public StressJobList()
        {
            _test_results = new TestResultCollection();
        }

        /// <summary>
        /// Adds a node to this job list.
        /// </summary>
        /// <param name="node">The node to add.</param>
        /// <returns>A List of the StressJobs added.</returns>
        public List<StressJob> AddNode (TestNode node)
        {
            return AddNodes(new TestNode[] { node });
        }

        /// <summary>
        /// Adds nodes to this job list.
        /// </summary>
        /// <param name="rootNodes">The nodes to add.</param>
        /// <returns>A List of the StressJobs added.</returns>
        public List<StressJob> AddNodes (IEnumerable<TestNode> rootNodes)
        {
            //first flatten the tree into a list of stress nodes
            List<TestNode> flatList = new List<TestNode>();

            foreach (TestNode node in rootNodes)
            {
                FindStressCases(node, flatList);
            }

            //add them
            List<StressJob> ans = new List<StressJob>(flatList.Count);

            foreach (TestNode item in flatList)
            {
                float priority = item.StressData.Priority;
                float targetTPS = item.StressData.TargetTPS;

                StressJob sj = new StressJob(item, priority, TestResults);
                sj.TargetTPS = targetTPS;
                totalPriority += priority;
                sj.PriorityChanged += new PriorityChangedHandler(sj_PriorityChanged);

                List.Add(sj);
                ans.Add(sj);
            }

            return ans;
        }

        /// <summary> Removes a specific root node and all children from the list. </summary>
        public void RemoveNode(TestNode root)
        {
            //first flatten the tree into a list of stress nodes
            List<TestNode> flatList = new List<TestNode>();
            FindStressCases(root, flatList);

            //find all the stress jobs for these nodes
            List<StressJob> ans = new List<StressJob>(flatList.Count);

            foreach (StressJob job in List)
            {
                foreach (TestNode n in flatList)
                {
                    if (n.FullName==job.Name)
                    {
                        ans.Add(job);
                    }
                }
            }

            //remove them
            foreach (StressJob job in ans)
            {
                List.Remove(job);
            }
        }

        /// <summary>
        /// Recursively finds the stress tests for the given node, adding them to the list.
        /// </summary>
        /// <param name="node">The node to search.</param>
        /// <param name="list">The place to add stress nodes to.</param>
        internal void FindStressCases(TestNode node, List<TestNode> list)
        {
            if (node.StressData==null) return;

            if (node.ChildrenCount>0) //we have children to do
            {
                foreach (TestNode child in node.Children)
                {
                    FindStressCases(child, list);
                }
            }
            else //we are a leaf
            {
                list.Add(node);
            }
        }

        public void AddJob(StressJob sj)
        {
            totalPriority += sj.Priority;
            List.Add(sj);
        }

        private void sj_PriorityChanged(StressJob sj, float delta)
        {
            totalPriority += delta;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerDestroyer.cs ===
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;

using ServerTestFramework;
using ServerTestFramework.Utilities;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Settings for the Destroyer Scheduler
    /// </summary>
    public class StressSettingsDestroyer: StressSettingsTPS
    {
        //Settings
        public float ScaleIncreaseRatePerMinute=0.5f; //per minute
        public float MinAcceptablePassRate=0.98f; //pass% we want. If we are above this then tps will increase.  If we are below this then tps will decrease.
        public float MaxAcceptableThreadUse=0.90f; //we also consider it failing if % threads used is above this

        //Current Status (updated by the scheduler regularly)
        public float Status_CurrentPassRate=1;
    }

    /// <summary>
    /// The destroyer scheduler is based on the TPS scheduler.
    /// It is designed to increase load until a set amount of failures occur.
    /// </summary>
    public class StressSchedulerDestroyer: StressSchedulerTPS
    {
        public override void Initialize(StfXmlDoc config, StressJobList jobListReference, StressSettingsCommon initialCommonSettings)
        {
            lastStateUpdate=System.DateTime.UtcNow;

            if (initialCommonSettings==null)
            {
                Settings2=new StressSettingsDestroyer();
            }

            base.Initialize(config, jobListReference, Settings2);

            Settings2.MaxThreads=500;
            Settings2.HangTime=20; //be more aggresive in getting rid of potentially stuck threads, since we expect failures at some point
            Settings2.ReserveHighTPSThreadRatio=0; //disable reserved threads feature
            Settings2.StartRampTime=1.0f; //I'm feeling a little kind at least?

            forceGuiUpdate=true;
            Tick();
        }

        //This call should block and run tests and block until someone calls Stop.
        public override void Run()
        {
            base.Run();
        }

        //Stop running tests.
        public override void Stop()
        {
            base.Stop();
        }

        //update the world
        public override void Tick()
        {
            //update settings from the gui
            if (labPassRate!=null)
            {
                if (labPassRate.IsHandleCreated)
                {
                    labPassRate.Invoke(new InvokeCode(delegate
                    {
                        //update settings from gui
                        Settings2.MinAcceptablePassRate=(float)nudAcceptablePassRate.Value/100.0f;
                        Settings2.ScaleIncreaseRatePerMinute=(float)nudScaleChangeRate.Value;
                        Settings2.MaxThreads=(int)nudMaxThreads.Value;
                        Settings2.HangTime=(int)nudThreadLife.Value;
                    }));
                }
            }

            //see how much time we need to update for
            double timePassed=(System.DateTime.UtcNow-lastStateUpdate).TotalSeconds;
            if (forceGuiUpdate)
            {
                timePassed=0;
            }
            else
            {
                if (timePassed<0.1f) //no need to adjust that fast
                {
                    return;
                }
                lastStateUpdate=System.DateTime.UtcNow;

                if (timePassed>60) //60s? no way... not reasonable.  something odd happened
                {
                    CoreGlobal.RO.Warn("StressSchedulerDestroyer: Tick() went over 1 minute without being called.");
                    return;
                }

                if (!running)
                {
                    return;
                }
            }

            //determine the current recent pass rate and thread use
            float passCount=0;
            float failCount=0;
            foreach (StressJob job in jobList)
            {
                passCount+=job.Results.RunningPasses30;
                failCount+=job.Results.RunningFails30;
            }

            if (passCount+failCount<0.5f) //low enough that basically nothing happened... assume we are good
            {
                Settings2.Status_CurrentPassRate=1.0f;
            }
            else //calc the pass rate
            {
                Settings2.Status_CurrentPassRate=passCount/(passCount+failCount);
            }

            float threadPercentUse=(float)Settings2.Status_CurrentThreads/Settings2.MaxThreads;

            //adjust our speed scale
            bool passRateGood=Settings2.Status_CurrentPassRate >= Settings2.MinAcceptablePassRate;
            bool threadUseGood=threadPercentUse < Settings2.MaxAcceptableThreadUse;
            bool cpuUseGood=(System.DateTime.UtcNow-Settings2.Status_Last_CPU_Bottleneck).TotalSeconds > 1.1f;

            if (!passRateGood || !threadUseGood || !cpuUseGood) //we broke them, so scale backwards
            {
                Settings2.ScaleTPS -= (Settings2.ScaleIncreaseRatePerMinute/60.0f)*timePassed;
            }
            else //they're good, so onwards!
            {
                Settings2.ScaleTPS += (Settings2.ScaleIncreaseRatePerMinute/60.0f)*timePassed;
            }

            if (Settings2.ScaleTPS<0.5f)
            {
                Settings2.ScaleTPS=0.5f;
            }

            //update gui
            if (labPassRate!=null)
            {
                if (labPassRate.IsHandleCreated)
                {
                    labPassRate.Invoke(new InvokeCode(delegate
                    {
                        //update labels
                        labPassRate.Text="Pass Rate: "+string.Format("{0:F1}",100*Settings2.Status_CurrentPassRate)+"%";
                        labPassRate.ForeColor=(passRateGood?System.Drawing.Color.Green:System.Drawing.Color.Red);
                        labThreadUse.Text="Local Threads Used: "+(int)(100*threadPercentUse)+"%";
                        labThreadUse.ForeColor=(threadUseGood?System.Drawing.Color.Green:System.Drawing.Color.Red);
                        labCPUUse.Text="Local CPU Use: "+(cpuUseGood?"OK":"MAX");
                        labCPUUse.ForeColor=(cpuUseGood?System.Drawing.Color.Green:System.Drawing.Color.Red);
                        labScale.Text="Scale: "+string.Format("{0:F3}",Settings2.ScaleTPS);
                    }));
                }
            }

            forceGuiUpdate=false;
        }

        public override void SaveSettings(XmlNode node)
        {
            //hrm
            if (Settings==null)
            {
                node.RemoveAll();
                return;
            }

            //
            XmlUtil.SetChildNodeValue(node, "MaxThreads", Settings2.MaxThreads);
            XmlUtil.SetChildNodeValue(node, "HangTime", Settings2.HangTime);

            XmlUtil.SetChildNodeValue(node, "ScaleIncreaseRatePerMinute", Settings2.ScaleIncreaseRatePerMinute);
            XmlUtil.SetChildNodeValue(node, "MinAcceptablePassRate", Settings2.MinAcceptablePassRate);
            XmlUtil.SetChildNodeValue(node, "MaxAcceptableThreadUse", Settings2.MaxAcceptableThreadUse);
        }

        public override void LoadSettings(XmlNode node)
        {
            if (Settings == null)
            {
                Settings = new StressSettingsTPS();
            }

            //load settings
            Settings2.MaxThreads = XmlUtil.GetChildNodeValue(node, "MaxThreads", Settings2.MaxThreads);
            Settings2.HangTime = XmlUtil.GetChildNodeValue(node, "HangTime", Settings2.HangTime);

            Settings2.ScaleIncreaseRatePerMinute = XmlUtil.GetChildNodeValue(node, "ScaleIncreaseRatePerMinute", Settings2.ScaleIncreaseRatePerMinute);
            Settings2.MinAcceptablePassRate = XmlUtil.GetChildNodeValue(node, "MinAcceptablePassRate", Settings2.MinAcceptablePassRate);
            Settings2.MaxAcceptableThreadUse = XmlUtil.GetChildNodeValue(node, "MaxAcceptableThreadUse", Settings2.MaxAcceptableThreadUse);

            //push them to the ui
            if (labPassRate!=null)
            {
                if (labPassRate.IsHandleCreated)
                {
                    labPassRate.Invoke(new InvokeCode(delegate
                    {
                        //update settings from gui
                        nudAcceptablePassRate.Value=(decimal)(Settings2.MinAcceptablePassRate*100.0f);
                        nudScaleChangeRate.Value=(decimal)Settings2.ScaleIncreaseRatePerMinute;
                        nudMaxThreads.Value=Settings2.MaxThreads;
                        nudThreadLife.Value=Settings2.HangTime;
                    }));
                }
            }

            forceGuiUpdate=true;
            Tick();
        }

        #region Gui Control

        public override Control SchedulerControl
        {
            get
            {
                if (Settings2==null)
                {
                    Settings2=new StressSettingsDestroyer();
                }

                Panel mainPanel=new Panel();
                mainPanel.Size=new System.Drawing.Size(300, 600);
                mainPanel.Dock=DockStyle.Fill;

                labPassRate=new Label();
                labPassRate.Size=new System.Drawing.Size(300, 20);
                labPassRate.Location=new System.Drawing.Point(5, 5);
                labPassRate.Text="Pass Rate:";
                mainPanel.Controls.Add(labPassRate);

                labThreadUse=new Label();
                labThreadUse.Size=new System.Drawing.Size(300, 20);
                labThreadUse.Location=new System.Drawing.Point(5, 25);
                labThreadUse.Text="Local Threads Used:";
                mainPanel.Controls.Add(labThreadUse);

                labCPUUse=new Label();
                labCPUUse.Size=new System.Drawing.Size(300, 20);
                labCPUUse.Location=new System.Drawing.Point(5, 45);
                labCPUUse.Text="Local CPU Use:";
                mainPanel.Controls.Add(labCPUUse);

                labScale=new Label();
                labScale.Size=new System.Drawing.Size(300, 20);
                labScale.Location=new System.Drawing.Point(5, 65);
                labScale.Text="Scale:";
                mainPanel.Controls.Add(labScale);

                labAcceptablePassRate=new Label();
                labAcceptablePassRate.Size=new System.Drawing.Size(103, 20);
                labAcceptablePassRate.Location=new System.Drawing.Point(2, 97);
                labAcceptablePassRate.Text="Acceptable Pass %";
                mainPanel.Controls.Add(labAcceptablePassRate);

                nudAcceptablePassRate=new NumericUpDown();
                nudAcceptablePassRate.Size=new System.Drawing.Size(50, 25);
                nudAcceptablePassRate.Location=new System.Drawing.Point(105, 95);
                nudAcceptablePassRate.Value=(decimal)(Settings2.MinAcceptablePassRate*100);
                nudAcceptablePassRate.DecimalPlaces=1;
                nudAcceptablePassRate.Increment=1;
                mainPanel.Controls.Add(nudAcceptablePassRate);

                labScaleChangeRate=new Label();
                labScaleChangeRate.Size=new System.Drawing.Size(103, 20);
                labScaleChangeRate.Location=new System.Drawing.Point(2, 122);
                labScaleChangeRate.Text="Scale Change Rate";
                mainPanel.Controls.Add(labScaleChangeRate);

                nudScaleChangeRate=new NumericUpDown();
                nudScaleChangeRate.Size=new System.Drawing.Size(50, 25);
                nudScaleChangeRate.Location=new System.Drawing.Point(105, 120);
                nudScaleChangeRate.Value=(decimal)(Settings2.ScaleIncreaseRatePerMinute);
                nudScaleChangeRate.DecimalPlaces=2;
                nudScaleChangeRate.Increment=(decimal).1f;
                mainPanel.Controls.Add(nudScaleChangeRate);

                labScaleChangeRateUnitInfo=new Label();
                labScaleChangeRateUnitInfo.Size=new System.Drawing.Size(90, 20);
                labScaleChangeRateUnitInfo.Location=new System.Drawing.Point(157, 122);
                labScaleChangeRateUnitInfo.Text="(per minute)";
                mainPanel.Controls.Add(labScaleChangeRateUnitInfo);

                labMaxThreads=new Label();
                labMaxThreads.Size=new System.Drawing.Size(103, 20);
                labMaxThreads.Location=new System.Drawing.Point(2, 147);
                labMaxThreads.Text="Max Threads";
                mainPanel.Controls.Add(labMaxThreads);

                nudMaxThreads=new NumericUpDown();
                nudMaxThreads.Size=new System.Drawing.Size(50, 25);
                nudMaxThreads.Location=new System.Drawing.Point(105, 145);
                nudMaxThreads.DecimalPlaces=0;
                nudMaxThreads.Increment=(decimal)1;
                nudMaxThreads.Minimum=1;
                nudMaxThreads.Maximum=600;
                nudMaxThreads.Value=(decimal)(Settings2.MaxThreads);
                mainPanel.Controls.Add(nudMaxThreads);

                labThreadLife=new Label();
                labThreadLife.Size=new System.Drawing.Size(103, 20);
                labThreadLife.Location=new System.Drawing.Point(2, 172);
                labThreadLife.Text="Thread Life";
                mainPanel.Controls.Add(labThreadLife);

                nudThreadLife=new NumericUpDown();
                nudThreadLife.Size=new System.Drawing.Size(50, 25);
                nudThreadLife.Location=new System.Drawing.Point(105, 170);
                nudThreadLife.Minimum=1;
                nudThreadLife.Maximum=6000;
                nudThreadLife.Value=(decimal)(Settings2.HangTime);
                nudThreadLife.DecimalPlaces=0;
                nudThreadLife.Increment=(decimal)1;
                mainPanel.Controls.Add(nudThreadLife);

                labThreadLifeUnitInfo=new Label();
                labThreadLifeUnitInfo.Size=new System.Drawing.Size(90, 20);
                labThreadLifeUnitInfo.Location=new System.Drawing.Point(157, 172);
                labThreadLifeUnitInfo.Text="(seconds)";
                mainPanel.Controls.Add(labThreadLifeUnitInfo);

                butResetScale=new Button();
                butResetScale.Size=new System.Drawing.Size(115, 25);
                butResetScale.Location=new System.Drawing.Point(3, 200);
                butResetScale.Text="Reset Current Scale";
                butResetScale.Click+=ButtonScaleReset_Click;
                mainPanel.Controls.Add(butResetScale);

                nudResetScale=new NumericUpDown();
                nudResetScale.Size=new System.Drawing.Size(50, 25);
                nudResetScale.Location=new System.Drawing.Point(135, 202);
                nudResetScale.Minimum=(decimal)0.5f;
                nudResetScale.Maximum=5000;
                nudResetScale.Value=(decimal)1;
                nudResetScale.DecimalPlaces=1;
                nudResetScale.Increment=(decimal)0.5f;
                mainPanel.Controls.Add(nudResetScale);

                labResetScaleTo=new Label();
                labResetScaleTo.Size=new System.Drawing.Size(20, 20);
                labResetScaleTo.Location=new System.Drawing.Point(118, 205);
                labResetScaleTo.Text="to:";
                mainPanel.Controls.Add(labResetScaleTo);

                return mainPanel;
            }
        }

        Label labPassRate;
        Label labThreadUse;
        Label labCPUUse;
        Label labScale;

        Label labAcceptablePassRate;
        NumericUpDown nudAcceptablePassRate;

        Label labScaleChangeRate;
        NumericUpDown nudScaleChangeRate;
        Label labScaleChangeRateUnitInfo;

        Label labMaxThreads;
        NumericUpDown nudMaxThreads;

        Label labThreadLife;
        NumericUpDown nudThreadLife;
        Label labThreadLifeUnitInfo;

        Button butResetScale;
        Label labResetScaleTo;
        NumericUpDown nudResetScale;

        public delegate void InvokeCode();

        private void ButtonScaleReset_Click(object sender, System.EventArgs e)
        {
            Settings2.ScaleTPS=(float)nudResetScale.Value;
            forceGuiUpdate=true;
            Tick();
        }

        private bool forceGuiUpdate=false;

        #endregion //Gui Control

        // -- state

        System.DateTime lastStateUpdate;

        protected /*override*/ StressSettingsDestroyer Settings2 //grr at C# not supporting co/contra-varient return types
        {
            get { return (StressSettingsDestroyer)base.Settings; }
            set
            {
                base.Settings=value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerTPS.cs ===
using System.Collections.Generic;
using System.Windows.Forms;
using System.Xml;
using System.IO;
using System.Threading;
using System;

using ServerTestFramework;
using ServerTestFramework.Utilities;

#pragma warning disable 0420 //a reference to a volatile field will not be treated as volatile

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Settings and Status for the TPS based scheduler.
    /// </summary>
    public class StressSettingsTPS: StressSettingsCommon
    {
        //Settings - all times are in seconds
        public int MaxThreads=100;
        public double ScaleTPS=1.0f;
        public int HangTime=120; //time until a thread is considered "hung"
        public float ReserveHighTPSThreadRatio=0.05f; //portion of the threads that are reserved for running non-slow tests
        public float StartRampTime=5.0f;

        //Settings for sin wave scaling
        /// <summary>
        /// Period of the sine wave, in seconds.
        /// </summary>
        /// <remarks>
        /// Should be a factor of 60*60*24; in other words an integral number of periods should pass in a 
        /// single day.  Thus, 24 hours, 12 hours, 8 hours, 6 hours, etc.  If this assumption is not held,
        /// the wave will not stay consistent when the day resets (midnight).
        /// </remarks>
        public float SinWavePeriod=60*60*24; //24 hour by default
        public float SinWavePhase=(float)System.Math.PI/2; //peek at midnight GMT by default
        public float SinWaveMagnitude=0.5f;
        public bool SinWaveEnabled=false;

        //Current Status (updated by the scheduler regularly)
        public int Status_CurrentThreads=0;
        public float Status_CurrentSinScalar=1.0f;
        public float Status_StartRampScale=1.0f;
        public System.DateTime Status_Last_CPU_Bottleneck=System.DateTime.MinValue; //last time we couldn't run fast enough

        //Scheduler behavior, mainly for debugging spikies issue
        public int SchedulerSleepTimeMs=0;
        public int SchedulerDelayTimeUs=0;
    }

    /// <summary>
    /// The TPS based stress scheduler.
    /// </summary>
    public class StressSchedulerTPS: StressTestScheduler
    {
#if INSTRUMENTED_SCHEDULER
        private List<string> _TraceStrings;
        private StreamWriter _TraceFile; 
        private long         _LastTraceTime;
#endif

        // -- interface implementation

        //Called to set up the scheduler.
        public virtual void Initialize(StfXmlDoc config, StressJobList jobListReference, StressSettingsCommon initialCommonSettings)
        {
            jobList=jobListReference;

            if (initialCommonSettings==null)
            {
                Settings=new StressSettingsTPS();
            }
            else
            {
                if (initialCommonSettings is StressSettingsTPS)
                {
                    Settings=(StressSettingsTPS)initialCommonSettings;
                }
                else
                {
                    Settings=new StressSettingsTPS();
                    Settings.CopyFrom(initialCommonSettings);
                }
            }
        }

        public StressSettingsCommon GetSettings()
        {
            return Settings;
        }

        private void StartTrace()
        {
#if INSTRUMENTED_SCHEDULER
            // Maybe append a unique number onto the end?  or a timestamp?
            string fn = "StressSchedulerTPS.log";
            _TraceStrings = new List<string>();
            _TraceFile = new StreamWriter(fn);
            _LastTraceTime = Timing.QueryPerformanceCounter();
#endif
        }

        private void StopTrace()
        {
#if INSTRUMENTED_SCHEDULER
            FlushTrace(true);
            _TraceFile.Close();
#endif
        }

        private void Trace(string fmt, params object[] args)
        {
#if INSTRUMENTED_SCHEDULER
            long now = Timing.QueryPerformanceCounter();
            lock (_TraceStrings)
            {
                double ms = Timing.CalculatePerformanceDelta(_LastTraceTime, now) * 1000.0;
                _TraceStrings.Add(ms.ToString("f3") + "|" + String.Format(fmt, args));
            }
            _LastTraceTime = now;
#endif
        }

        private void FlushTrace(bool fForceDiskFlush)
        {
#if INSTRUMENTED_SCHEDULER
            lock (_TraceStrings)
            {
                for (int i = 0; i < _TraceStrings.Count; i++)
                {
                    _TraceFile.WriteLine(_TraceStrings[i]);
                }
                _TraceStrings.Clear();
            }

            if (fForceDiskFlush)
            {
                _TraceFile.Flush();
            }
#endif
        }

        //Shuts down the scheduler.
        public virtual void Shutdown()
        {
            Stop();
        }

        //This call should block and run tests and block until someone calls Stop.
        public virtual void Run()
        {
            StartTrace();
            Thread.CurrentThread.Priority = ThreadPriority.BelowNormal;

            running=true;

            // - prepare to run

            // set async callback function
            AsyncStressTestNode.AsyncFinish = TestCallback;

            //setup the initial trigger time on each job
            System.Random rand=new System.Random();
            foreach (StressJob job in jobList)
            {
                if (job.TargetTPS<1) job.TriggerTimeLeft=(float)rand.NextDouble();
                else job.TriggerTimeLeft=job.TargetTPS * (float)rand.NextDouble();
            }

            // - main loop
            long startTime, lastTime, lastIterationTime;
            startTime = lastTime = lastIterationTime = Timing.QueryPerformanceCounter();

            while (running)
            {
                double sleepTime=MaxLagTime/2; //time in seconds the time we'll end up sleeping after this pass

                //calc the number of threads reserved for non-slow cases and the average threads-per-case assuming even distribution
                int reservedFastThreads=(int)(Settings.ReserveHighTPSThreadRatio*Settings.MaxThreads);
                if (reservedFastThreads<1) reservedFastThreads=1;
                if (Settings.ReserveHighTPSThreadRatio==0.0f || Settings.MaxThreads<=1) reservedFastThreads=0;

                int totalActiveJobs=0;
                foreach (StressJob job in jobList)
                {
                    if (job.TargetTPS>0.0f) ++totalActiveJobs;
                }
                if (totalActiveJobs<=1)
                {
                    totalActiveJobs=1;
                    reservedFastThreads=0;
                }
                float evenThreadsPerJob=(float)Settings.MaxThreads/totalActiveJobs;

                //calc the sin wave tps scalar
                float sinTPSScalar=1.0f;
                if (Settings.SinWaveEnabled)
                {
                    //calc seconds since midnight
                    System.DateTime now=System.DateTime.UtcNow;
                    System.DateTime dayStart=now-new System.TimeSpan(0,now.Hour,now.Minute,now.Second,now.Millisecond);
                    float seconds=(float)((now-dayStart).TotalSeconds);

                    //
                    sinTPSScalar=1.0f + (float)System.Math.Sin(Settings.SinWavePhase+(1/Settings.SinWavePeriod)*seconds*System.Math.PI*2)*Settings.SinWaveMagnitude;
                }

                Settings.Status_CurrentSinScalar=sinTPSScalar;

                //calc the start ramp up scalar
                long dtNow = Timing.QueryPerformanceCounter();
                double secsSinceStart = Timing.CalculatePerformanceDelta(startTime, dtNow);

                if (Settings.StartRampTime==0 || secsSinceStart>=Settings.StartRampTime)
                {
                    Settings.Status_StartRampScale=1.0f;
                }
                else
                {
                    Settings.Status_StartRampScale=(float)(secsSinceStart/Settings.StartRampTime);
                }

                //check for hung threads
                lock (activeThreads)
                {
                    try
                    {
                        foreach (TPSWorker worker in activeThreads)
                        {
                            double threadTime = Timing.CalculatePerformanceDelta(worker.startTime, dtNow);
                            if (threadTime>Settings.HangTime)
                            {
                                if (worker.job!=null)
                                {
                                    CoreGlobal.RO.Warn("Aborting stuck("+(int)threadTime+"s) thread: "+worker.job.Name);
                                    worker.job.Results.Deadlock();
                                }

                                //totally get rid of the thread to be on the safe side
                                if (worker.node!=null) activeThreads.Remove(worker.node);
                                DestroyWorker(worker);
                                System.Threading.Interlocked.Decrement(ref totalWorkersCount);
                                sleepTime=0;
                                break;
                            }
                        }
                    }
                    catch (System.Exception e)
                    {
                        CoreGlobal.RO.Warn("Scheduler error while checking for hung threads: "+e.Message);
                    }
                }

                //sort the jobs so that the most-starved jobs are first in the list
                System.Collections.Generic.List<StressJob> sortedJobs=new List<StressJob>();
                foreach (StressJob job in jobList)
                {
                    sortedJobs.Add(job);
                }
                sortedJobs.Sort(SortStressJobsByTriggerTime);

                //figure out how much time has really passed since the last pass
                dtNow = Timing.QueryPerformanceCounter();
                double timePassed=Timing.CalculatePerformanceDelta(lastTime, dtNow);
                lastTime=dtNow;

                //go through each job
                foreach (StressJob job in sortedJobs)
                {
                    if (!running) break;

                    //if it's disabled, don't process it
                    float jobTPS=(float)(job.TargetTPS * Settings.ScaleTPS * sinTPSScalar * Settings.Status_StartRampScale);

                    if (jobTPS<=0.0f)
                    {
                        continue;
                    }

                    if (jobTPS>50000000) //50 million sanity cap
                    {
                        jobTPS=50000000;
                    }

                    double iterTime=1/jobTPS; //time required for a single case run

                    //pass time
                    job.TriggerTimeLeft-=timePassed;

                    //if there are fewer threads available than the number reserved for non-slow jobs
                    int availableThreads=Settings.MaxThreads-activeThreads.Count;
                    if (availableThreads<0) availableThreads=0;
                    if (job.TriggerTimeLeft<0 && availableThreads<reservedFastThreads)
                    {
                        //if this job is hogging more than its share of threads, it is not allowed to run
                        float consumedThreads=job.Results.Threads;
                        if (consumedThreads>evenThreadsPerJob*2)
                        {
                            job.TriggerTimeLeft=0;

                            //warn about it, but no more than once per 2 seconds
                            if (System.DateTime.UtcNow-lastOutOfFastThreadsWarnTime >= new System.TimeSpan(0,0,2))
                            {
                                lastOutOfFastThreadsWarnTime=System.DateTime.UtcNow;
                                CoreGlobal.RO.Warn("Scheduler warning: A thread-heavy job is being skipped because the reserve thread limit was reached ("+availableThreads+" threads are available)");
                            }

                            continue;
                        }
                    }

                    //don't lag behind if we can't keep up
                    if (job.TriggerTimeLeft<-MaxLagTime)
                    {
                        job.TriggerTimeLeft=-MaxLagTime;

                        //warn about it
                        if (System.DateTime.UtcNow-lastOutOfCPUWarnTime >= new System.TimeSpan(0,0,2))
                        {
                            lastOutOfCPUWarnTime=System.DateTime.UtcNow;
                            CoreGlobal.RO.Warn("Scheduler warning: Not enough CPU time to run jobs at the desired speed.");
                            Settings.Status_Last_CPU_Bottleneck=System.DateTime.UtcNow;
                        }

                        //wiggle the exact wait time to help mix up the list so 1 case doesn't steal it all
                        job.TriggerTimeLeft+=ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(MaxLagTime/5);
                    }

                    //verify preruns steps were executed and run them if they have not
                    if (StressSchedulerHelpers.VerifyOrPerformPreRun(job.BaseNode, Settings))
                    {
                        //spawn instances of this job until we've made as many as we need since the last iteration
                        System.DateTime jobSpawnStartTime=System.DateTime.UtcNow;

                        while (job.TriggerTimeLeft<0 && running)
                        {
                            //if we have too many of it made for the reserve limit, don't make anymore; next cycle will catch and warn about it if needed
                            if (job.Results.Threads>=Settings.MaxThreads-reservedFastThreads)
                            {
                                //If reserved is set to 0%, don't ever block
                                if (reservedFastThreads!=0)
                                {
                                    job.TriggerTimeLeft+=MaxLagTime/4;
                                    break;
                                }
                            }

                            //don't ever spend more than .5 seconds in one pass on spawning a single job
                            if (System.DateTime.UtcNow-jobSpawnStartTime > new System.TimeSpan(0,0,0,0,500))
                            {
                                break;
                            }

                            //for very fast jobs, it's more effecient to have a thread do several tasks, so calculate how many we should do each
                            double maxJobsForTime=-job.TriggerTimeLeft/iterTime;
                            uint jobCount=(uint)(maxJobsForTime/System.Environment.ProcessorCount);
                            if (jobCount<1) jobCount=1;
                            if (jobCount>1000) jobCount=1000;

                            bool spawnSucceeded=true;

                            if (!SpawnJob(job,jobCount)) //out of threads
                            {
                                System.Threading.Thread.Sleep(0); //yield in case we just tried to do too much at once on a uniprocessor system, then try again
                                if (!SpawnJob(job,jobCount)) //out of threads
                                {
                                    spawnSucceeded=false;

                                    if (job.TriggerTimeLeft<-MaxLagTime/2) //only try to back off if it is clear we are starting to fall behind
                                    {
                                        //back it off just a little, but try again sooner
                                        job.TriggerTimeLeft+=MaxLagTime/4;
                                        if (job.TriggerTimeLeft<-MaxLagTime/2) job.TriggerTimeLeft=-MaxLagTime/2;
                                        sleepTime/=2;

                                        //warn about it, but no more than once per 2 seconds
                                        if (System.DateTime.UtcNow-lastOutOfThreadsWarnTime >= new System.TimeSpan(0,0,2))
                                        {
                                            lastOutOfThreadsWarnTime=System.DateTime.UtcNow;
                                            CoreGlobal.RO.Warn("Scheduler warning: Not enough threads available to spawn another instance of a job.");
                                        }
                                    }

                                    break;
                                }
                            }

                            if (spawnSucceeded)
                            {
                                job.TriggerTimeLeft+=iterTime*jobCount;
                            }

    #if INSTRUMENTED_SCHEDULER
                            long now = Timing.QueryPerformanceCounter();
                            for (int j = 0; j < jobCount; j++)
                            {
                                Trace("{0:f4}|{1:f3}",
                                    Timing.CalculatePerformanceDelta(startTime, now),
                                    job.TriggerTimeLeft * 1000);
                            }
    #endif
                        }
                    }
                    else //prerun isn't ready yet, so clear any time accumulated
                    {
                        job.TriggerTimeLeft=0;
                    }

                    if (job.TriggerTimeLeft<sleepTime) sleepTime=job.TriggerTimeLeft;

                    //if the user updated any jobs, their next trigger time will be too high, so fix that up if it's unreasonable
                    if (job.TriggerTimeLeft>iterTime*2) job.TriggerTimeLeft=iterTime*2;
                }

                //update status and nap
                Settings.Status_CurrentThreads=activeThreads.Count;

                FlushTrace(false);

                if (Settings.SchedulerDelayTimeUs > 0)
                {
                    while ((Timing.SecondsElapsedSince(lastIterationTime) * 1000000) < Settings.SchedulerDelayTimeUs)
                    {
                        // bake a pie? crochet? feed the llama?
                        System.Threading.Thread.Sleep(0);
                    }
                }
                lastIterationTime = Timing.QueryPerformanceCounter();

                // 0 is the best value to avoid a case of the spikies

#if INSTRUMENTED_SCHEDULER
                System.Threading.Thread.Sleep(Settings.SchedulerSleepTimeMs);
#else

                // On Win2K3, it is impossible to sleep for less than 15ms, since that is 
                // the clock interrupt frequency. It is vitally important that we not get 
                // synched to that period, since the Win2k3 thread cpu accounting will get 
                // thrown off and we'll see the odd spikes in cpu time.
                //
                // so, if our next action is over 15ms, we will sleep. But then we'll spin 
                // loop to achieve any wait between 0ms and 15ms, because we don't want to 
                // overshoot it.
                int msSleep = (int)(sleepTime*1000);
                if (msSleep > 15)
                {
                    int msToSleep = 15 * (int)(msSleep / 15);
                    System.Threading.Thread.Sleep(msToSleep);
                }
                else 
                {
                    // just yield briefly and keep on chugging, we don't want to get in 
                    // lock-step with the system timer.
                    System.Threading.Thread.Sleep(0);
                }
#endif
            }

            //wait for all threads to end then clean them up
            CoreGlobal.RO.Debug("Waiting on stress threads to return...");
            int tries=50; // 5 seconds before we just abort them
            while ((activeThreads.Count > 0 || IsInProgress) && tries > 0)
            {
                System.Threading.Thread.Sleep(100);
                Settings.Status_CurrentThreads=activeThreads.Count;
                --tries;
            }

            WipeThreadLists();

            //at this point there might still be async tests in progress, so wait for them
            if (IsInProgress)
            {
                CoreGlobal.RO.Debug("Waiting on async stress cases to finish running...");
                while (IsInProgress)
                {
                    System.Threading.Thread.Sleep(100);
                }
            }

            //we should have 0 threads now
            Settings.Status_CurrentThreads=activeThreads.Count;
            if (Settings.Status_CurrentThreads!=0)
            {
                CoreGlobal.RO.Warn("Exiting scheduler, but we have threads still alive.  This should never happen.");
            }

            StressSchedulerHelpers.PerformPostRun(jobList, Settings);
        }

        //Stop running tests.
        public virtual void Stop()
        {
            running=false;
            StopTrace();
        }

        /// <summary>
        /// Checks the job list for in progress tests, if there are any, return true.
        /// </summary>
        public bool IsInProgress
        {
            get
            {
                foreach (StressJob job in jobList)
                {
                    if (job.Results.InProgress > 0)
                    {
                        return true;
                    }
                }

                return false;
            }
        }

        /// <summary>
        /// Gets the StressSchedulerTPSControl.
        /// </summary>
        public virtual Control SchedulerControl
        {
            get
            {
                if (control == null)
                {
                    lock (control_lock)
                    {
                        if (control == null)
                        {
                            control = new StressSchedulerTPSControl();
                            if (Settings == null) { Settings = new StressSettingsTPS(); }
                            control.Settings = Settings;
                        }
                    }
                }

                return control;
            }
        }

        /// <summary>
        /// Timer services provided by our owner.
        /// </summary>
        public virtual void Tick()
        {
            if (SchedulerControl!=null && SchedulerControl is StressSchedulerTPSControl)
            {
                ((StressSchedulerTPSControl) SchedulerControl).SyncWithSettingsStatus();
            }
        }

        /// <summary>
        /// Gets a scale value from a stress job.
        /// </summary>
        /// <param name="job">The job to get from.</param>
        /// <returns>The scale value from the stress job.</returns>
        public virtual float GetScaleValue (StressJob job)
        {
            return job.TargetTPS;
        }

        /// <summary>
        /// Sets a scale value on a stress job.
        /// </summary>
        /// <param name="job">The job to set on.</param>
        /// <param name="val">The scale value to set.</param>
        public virtual void SetScaleValue (StressJob job, float val)
        {
            job.TargetTPS = val;
        }

        /// <summary>
        /// The name of the scale value used by this scheduler.  Displayed on GUI elements.
        /// </summary>
        public virtual string ScaleName
        {
            get
            {
                return "Target";
            }
        }

        /// <summary>
        /// Load settings from an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        public virtual void LoadSettings(XmlNode node)
        {
            if (Settings == null) { Settings = new StressSettingsTPS(); }

            Settings.MaxThreads = XmlUtil.GetChildNodeValue(node, "MaxThreads", Settings.MaxThreads);
            Settings.HangTime = XmlUtil.GetChildNodeValue(node, "HangTime", Settings.HangTime);

            XmlNode sine_wave = XmlUtil.GetGroupNode(node, "SineScaling");
            Settings.SinWaveEnabled = XmlUtil.GetAttributeValue(sine_wave, "Enabled", Settings.SinWaveEnabled);
            Settings.SinWaveMagnitude = XmlUtil.GetAttributeValue(sine_wave, "Magnitude", Settings.SinWaveMagnitude);
            Settings.SinWavePeriod = XmlUtil.GetAttributeValue(sine_wave, "Period", Settings.SinWavePeriod);
            Settings.SinWavePhase = XmlUtil.GetAttributeValue(sine_wave, "Phase", Settings.SinWavePhase);

            Settings.ReserveHighTPSThreadRatio = 
                XmlUtil.GetChildNodeValue(node, "ReservedThreads", Settings.ReserveHighTPSThreadRatio);
            Settings.ScaleTPS = XmlUtil.GetChildNodeValue(node, "ScaleTPS", (float)Settings.ScaleTPS);
            Settings.StartRampTime = XmlUtil.GetChildNodeValue(node, "RampUpTime", (float)Settings.StartRampTime);

            // make sure the UI is showing everything properly
            if (SchedulerControl!=null && SchedulerControl is StressSchedulerTPSControl)
            {
                ((StressSchedulerTPSControl)SchedulerControl).Settings = Settings;
            }
        }

        /// <summary>
        /// Save settings to an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        public virtual void SaveSettings(XmlNode node)
        {
            // suppose we will not save anything if we are just using the defaults anyway
            if (Settings == null)
            {
                node.RemoveAll();
                return;
            }

            XmlUtil.SetChildNodeValue(node, "MaxThreads", Settings.MaxThreads);
            XmlUtil.SetChildNodeValue(node, "HangTime", Settings.HangTime);

            XmlNode sine_wave = XmlUtil.GetGroupNode(node, "SineScaling");
            XmlUtil.SetAttributeValue(sine_wave, "Enabled", Settings.SinWaveEnabled);
            XmlUtil.SetAttributeValue(sine_wave, "Magnitude", Settings.SinWaveMagnitude);
            XmlUtil.SetAttributeValue(sine_wave, "Period", Settings.SinWavePeriod);
            XmlUtil.SetAttributeValue(sine_wave, "Phase", Settings.SinWavePhase);

            XmlUtil.SetChildNodeValue(node, "ReservedThreads", Settings.ReserveHighTPSThreadRatio);
            XmlUtil.SetChildNodeValue(node, "ScaleTPS", (float)Settings.ScaleTPS);
            XmlUtil.SetChildNodeValue(node, "RampUpTime", (float)Settings.StartRampTime);
        }

        // -- private helpers

        //spawns a new thread to run a job
        private bool SpawnJob(StressJob job, uint count)
        {
            //if over max, bad
            if (activeThreads.Count>=Settings.MaxThreads) return false;

            //find a worker, or make one if needed
            TPSWorker worker=null;
            if (idleThreads.Count>0)
            {
                lock (idleThreads)
                {
                    //pull from idle pool
                    if (idleThreads.Count>0)
                    {
                        worker=idleThreads.First.Value;
                        idleThreads.RemoveFirst();
                    }
                }

                lock (activeThreads)
                {
                    worker.node=activeThreads.AddFirst(worker);
                }
            }

            if (worker==null)
            {
                if (totalWorkersCount>=Settings.MaxThreads) return false;

                System.Threading.Interlocked.Increment(ref totalWorkersCount);
                worker=new TPSWorker();
                lock (activeThreads)
                {
                    worker.node=activeThreads.AddFirst(worker);
                }
            }

            //set up the worker
            worker.job=job;
            worker.startTime=Timing.QueryPerformanceCounter();
            worker.count=count;

            if (worker.thread!=null)
            {
                worker.are.Set();
            }
            else //we need to setup the thread
            {
                worker.thread=ThreadMaker.CreateThread(SpawnThreadProc, worker);
                worker.thread.Start();
            }
            return true;
        }

        //procedure to run a test
        private void SpawnThreadProc(object o)
        {
            TPSWorker worker=(TPSWorker)o;
            try
            {
                while (true)
                {
                    //see if we have a job
                    if (!running) break;

                    if (worker.job==null)
                    {
                        worker.are.WaitOne();
                        continue;
                    }

                    StressJob job=worker.job;
                    job.Results.AddThread();

                    try
                    {
                        //get the test, and run it (CreateInstance will return a shared instance if it should)
                        for (uint number=0; number<worker.count; ++number)
                        {
                            if (!running) break;

                            TestNode tb=job.CreateInstance();

                            System.DateTime startDateTime=System.DateTime.UtcNow;
                            if (tb is AsyncStressTestNode)
                            {
                                AsyncStressTestNode astb = (AsyncStressTestNode)tb;

                                long dtStart=Timing.QueryPerformanceCounter();
                                try
                                {
                                    job.Results.BeginInProgress();
                                    astb.Begin(job);
                                }
                                catch (System.Exception e)
                                {
                                    float elapsedTime=(float)Timing.CalculatePerformanceDelta(dtStart, Timing.QueryPerformanceCounter());
                                    job.Results.CountLatencyMeasure(elapsedTime);
                                    job.Results.EndInProgress();
                                    job.Results.Fail();
                                    CoreGlobal.RO.Error(job.Name + " failed:\n" + e.ToString());
                                }
                            }
                            else
                            {
                                job.Results.BeginInProgress();
                                long dtStart=Timing.QueryPerformanceCounter();
                                long dtEnd;
                                System.DateTime endDateTime=System.DateTime.UtcNow;

                                try
                                {
                                    tb.Run(RUN_TYPE.STRESS);
                                    job.Results.Pass();
                                }
                                catch (DidNotExecuteException)
                                {
                                    job.Results.Skip();
                                }
                                catch (System.Exception e)
                                {
                                    job.Results.FailTrace(startDateTime, endDateTime, e);
                                    CoreGlobal.RO.Error(job.Name + " failed" + (e == null ? "." : ":\n" + e.ToString()));
                                }
                                finally
                                {
                                    dtEnd=Timing.QueryPerformanceCounter();
                                    job.Results.EndInProgress();
                                    float elapsedTime=(float)Timing.CalculatePerformanceDelta(dtStart, dtEnd);
                                    job.Results.CountLatencyMeasure(elapsedTime);
                                }
                            }
                        }
                    }
                    finally
                    {
                        job.Results.SubtractThread();
                    }

                    //move us from the active to the idle list
                    lock (activeThreads)
                    {
                        activeThreads.Remove(worker.node);
                    }

                    worker.job=null;

                    lock (idleThreads)
                    {
                        worker.node=idleThreads.AddFirst(worker);
                    }

                    //time to nap
                    if (!running) break;
                    worker.are.WaitOne();
                }
            }
            finally
            {
                //remove us from any list we belong to
                if (worker!=null && worker.node!=null && worker.node.List!=null)
                {
                    lock (worker.node.List)
                    {
                        worker.node.List.Remove(worker.node);
                    }
                }
            }
        }

        /// <summary>
        /// The callback used by async tests to report success or failure.
        /// </summary>
        /// <param name="state">The state object that was passed to Begin.</param>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception, if any, that occured during the asynchronous portions of the test.</param>
        /// <param name="startTime">Time the test started (from QueryPerformanceCounter).</param>
        private void TestCallback (object state, System.Exception exc, long startTime)
        {
            float elapsedTime=(float)Timing.CalculatePerformanceDelta(startTime, Timing.QueryPerformanceCounter());

            StressJob job = (StressJob) state;

            job.Results.EndInProgress();
            job.Results.CountLatencyMeasure(elapsedTime);

            // handle the results of the run
            if (exc==null)
            {
                job.Results.Pass();
            }
            else if (exc is DidNotExecuteException)
            {
                job.Results.Skip();
            }
            else
            {
                job.Results.Fail();
                CoreGlobal.RO.Error(job.Name + " failed" + (exc == null ? "." : ": " + exc));
            }
        }

        //clears out thread lists
        void WipeThreadLists()
        {
            lock (activeThreads)
            {
                lock (idleThreads)
                {
                    while (activeThreads.Count>0)
                    {
                        if (activeThreads.First!=null)
                        {
                            activeThreads.First.Value.node=null;
                            DestroyWorker(activeThreads.First.Value);
                        }
                        else
                        {
                            CoreGlobal.RO.Warn("Scheduler anomaly: activeThreads list has a null entry.");
                        }
                        activeThreads.RemoveFirst();
                    }

                    while (idleThreads.Count>0)
                    {
                        if (idleThreads.First!=null)
                        {
                            idleThreads.First.Value.node=null;
                            DestroyWorker(idleThreads.First.Value);
                        }
                        else
                        {
                            CoreGlobal.RO.Warn("Scheduler anomaly: idleThreads list has a null entry.");
                        }
                        idleThreads.RemoveFirst();
                    }
                }
            }

            totalWorkersCount=0;
        }

        //Destroys a worker thread
        void DestroyWorker(TPSWorker w)
        {
            if (w.are!=null)
            {
                w.are.Set();
                if (w.thread!=null && !running) System.Threading.Thread.Sleep(1); //that might have been enough to end them.. give them a little chance.
            }

            if (w.thread!=null)
            {
                w.thread.Abort();
            }

            //clear contents to help out the evil garbage collector
            w.thread=null;
            w.are=null;
            w.node=null;
            w.job=null;
        }

        //Used to sort stress jobs
        public static int SortStressJobsByTriggerTime(StressJob x, StressJob y)
        {
            if (x.TriggerTimeLeft<y.TriggerTimeLeft) return -1;
            else if (x.TriggerTimeLeft>y.TriggerTimeLeft) return 1;
            else
            {
                //this breaks C#'s sorter... grr
                //if they are the same, randomly choose a direction, to help mix them up more
                //if (ServerTestFramework.Core.Utilities.RandomEx.GlobalRandGen.Next(100)<50) return -1;
                //else return 1;
                return 0;
            }
        }

        // -- private members

        //
        protected StressSettingsTPS _settings;
        protected virtual StressSettingsTPS Settings
        {
            get { return _settings; }
            set
            {
                _settings = value;
                if (control != null)
                {
                    control.Settings = _settings;
                }
            }
        }

        protected StressJobList jobList;

        protected object control_lock = new object();
        protected StressSchedulerTPSControl control = null;

        System.DateTime lastOutOfThreadsWarnTime=System.DateTime.UtcNow;
        System.DateTime lastOutOfFastThreadsWarnTime=System.DateTime.UtcNow;
        System.DateTime lastOutOfCPUWarnTime=System.DateTime.UtcNow;

        //switch to cause us to stop running
        volatile protected bool running;

        //list of threads
        class TPSWorker
        {
            public long startTime;
            public System.Threading.Thread thread;
            public volatile StressJob job;
            public uint count; //number of times the worker should execute this job

            public LinkedListNode<TPSWorker> node; //node in the list that I'm currently in

            public System.Threading.AutoResetEvent are=new System.Threading.AutoResetEvent(true);
        }

        LinkedList<TPSWorker> activeThreads=new LinkedList<TPSWorker>(); //running threads
        LinkedList<TPSWorker> idleThreads=new LinkedList<TPSWorker>(); //idle threads
        volatile int totalWorkersCount=0;

        public int ActiveThreads
        {
            get
            {
                return activeThreads.Count;
            }
        }

        //maximum lag time for test case spawning
        public const float MaxLagTime=0.5f;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerPriControl.cs ===
﻿using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;

namespace ServerTestFramework.Runner
{
    public partial class StressSchedulerPriControl : UserControl
    {
        public StressSchedulerPriControl ()
        {
            InitializeComponent();
        }

        public StressSchedulerPriority Scheduler
        {
            get { return _scheduler; }
            set
            {
                _scheduler = value;
                SyncWithScheduler();
            }
        }

        private StressSchedulerPriority _scheduler = null;

        private void nupMaxThreads_ValueChanged (object sender, EventArgs e)
        {
            if (_scheduler != null)
            {
                _scheduler.MaxThreads = Convert.ToInt32(nudMaxThreads.Value);
            }
        }

        public void SyncWithScheduler ()
        {
            if (_scheduler == null)
            {
                return;
            }

            lblCurrentThreads.Text = _scheduler.NumThreads.ToString();
            nudMaxThreads.Value = Convert.ToDecimal(_scheduler.MaxThreads);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerPri.cs ===
//this is the old priority based schedular

using System;
using System.Collections;
using System.Diagnostics;
using System.Xml;
using System.Threading;
using System.Windows.Forms;
using System.IO;

using ServerTestFramework;
using ServerTestFramework.Runner;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core.Utilities;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Settings for the ancient scheduler.
    /// </summary>
    public class StressSettingsPriority: StressSettingsCommon
    {
        private XmlDocument config;

        public int Threads;
        public bool UseResultsHtml;
        public bool UseThrottling;
        public volatile int ThrottlingTps;
        public bool VerboseExceptions;

        public StressSettingsPriority(XmlDocument config)
        {
            this.config = config;

            Threads = GetInt32OptionDefault("initialthreads", 1);
            UseResultsHtml = GetBoolOptionDefault("resultshtml", false);
            UseThrottling = GetBoolOptionDefault("usethrottling", false);
            ThrottlingTps = GetInt32OptionDefault("throttlingtps", 10);
            VerboseExceptions = GetBoolOptionDefault("verboseexceptions", true);
        }

        private string LookupXmlOption(string name)
        {
            try
            {
                XmlNode xn = config.SelectSingleNode("/stf/config/stress/option[@name='" + name + "']");
                if (xn == null)
                    return null;

                XmlAttribute xa = xn.Attributes["value"];
                if (xa == null)
                    return null;

                return xa.Value;
            }
            catch (Exception)
            {
                return null;
            }
        }

        private int GetInt32OptionDefault(string option, int def)
        {
            string s = LookupXmlOption(option);
            if (s == null)
                return def;
            return Convert.ToInt32(s);
        }
        
        private bool GetBoolOptionDefault(string option, bool def)
        {
            string s = LookupXmlOption(option);
            if (s == null)
                return def;

            if (s != "true" && s != "false")
                throw new ArgumentException("Xml boolean values must be 'true' or 'false'.");

            return s == "true";
        }

        private void WriteOptionToXml(StfXmlDoc doc, string name, string val)
        {
            XmlNode option = doc.AddPath("/stf/config/stress/option");

            XmlAttribute attrName = doc.CreateAttribute("name");
            attrName.Value = name;
            option.Attributes.Append(attrName);

            XmlAttribute attrValue = doc.CreateAttribute("value");
            attrValue.Value = val;
            option.Attributes.Append(attrValue);
        }

        private void WriteToXmlDoc(StfXmlDoc doc)
        {
            WriteOptionToXml(doc, "initialthreads", Threads.ToString());
            WriteOptionToXml(doc, "resultshtml", UseResultsHtml.ToString());
            WriteOptionToXml(doc, "usethrottling", UseThrottling.ToString());
            WriteOptionToXml(doc, "throttlingtps", ThrottlingTps.ToString());
            WriteOptionToXml(doc, "verboseexceptions", VerboseExceptions.ToString());
        }
    }

    /// <summary>
    /// Ye Aulde stress schedular apparently uses this.
    /// </summary>
    public class StressThread
    {
        private StressSchedulerPriority scheduler;
        private Thread thread = null;
        private bool running = false;
        public bool Running {get {return running;}}
        private DateTime updated = DateTime.UtcNow; // last update time
        public DateTime Updated {get {return updated;}}
        private StressJob currentJob = null;

        public System.Threading.ThreadState ThreadState {get {return thread.ThreadState;}}
        public StressJob CurrentJob {get {return currentJob;}}

        public StressThread(StressSchedulerPriority scheduler)
        {
            this.scheduler = scheduler;
        }

        /// <summary>
        /// Sets the terminate flag, the thread will stop after the current job is complete.
        /// </summary>
        public void SoftTerminate()
        {
            running = false;
        }

        /// <summary>
        /// Kills the thread.
        /// </summary>
        public void Terminate()
        {
            thread.Abort();
        }

        public Thread Start()
        {
            running = true;
            updated = DateTime.UtcNow;

            thread = new Thread(new ThreadStart(StressThreadFunc));
            thread.Start();

            return thread;
        }

        public bool Join()
        {
            // Wait 10 seconds for thread to abort
            return thread.Join(10000);
        }

        virtual protected void StressThreadFunc()
        {
            TestNode tb = null;
            float elapsedTime = 0;
            try
            {
                while (Running)
                {
                    try
                    {
                        currentJob = scheduler.PickTest();
                        if (currentJob==null)
                        {
                            System.Threading.Thread.Sleep(100);
                            continue;
                        }

                        if (!StressSchedulerHelpers.VerifyOrPerformPreRun(currentJob.BaseNode, scheduler.GetSettings()))
                        {
                            continue;
                        }

                        tb = currentJob.CreateInstance();

                        elapsedTime = 0;
                        currentJob.Results.AddThread();
                        currentJob.Results.BeginInProgress();
                        updated = DateTime.UtcNow;
                        long instanceRunStart=Timing.QueryPerformanceCounter();
                        try
                        {
                            tb.Run(RUN_TYPE.STRESS);
                        }
                        finally
                        {
                            elapsedTime = (float)Timing.CalculatePerformanceDelta(instanceRunStart, Timing.QueryPerformanceCounter());
                            currentJob.Results.CountLatencyMeasure(elapsedTime);
                            currentJob.Results.SubtractThread();
                            currentJob.Results.EndInProgress();
                        }

                        Pass(1);
                    }
                    catch (DidNotExecuteException)
                    {
                        Skip(1);
                    }
                    catch (ThreadAbortException)
                    {
                        throw;  // This is to make sure the outer handler catches this instead of the general one below
                    }
                    catch (Exception e)
                    {
                        Fail(e, 1);
                    }
                }
            }
            catch (ThreadAbortException)
            {
                running = false;
            }
        }

        protected void Pass(int count)
        {
            for (int i = 0; i < count; i++)
            {
                currentJob.Results.Pass();
            }
        }

        protected void Fail(Exception e, int count)
        {
            if (count <= 0)
                return;

            DateTime dtNow = DateTime.UtcNow;
            for (int i = 0; i < count; i++)
            {
                currentJob.Results.FailTrace(updated, dtNow, e);
            }

            bool emptyException = e == null || e.Message == null || e.Message == "";
            string execTime="("+Convert.ToInt32((dtNow-updated).TotalSeconds*1000)+" msecs)";
            if (!emptyException)
            {
                CoreGlobal.RO.Error("  Test " + currentJob.Name + " failed (" + count + ") "+execTime+" - " + e.GetType().Name + ": " + e.Message);
                if (scheduler.ShowDetailedExceptions)
                    CoreGlobal.RO.Error("  " + e.ToString().Replace("\n", "\n  "));
            }
            else
            {
                CoreGlobal.RO.Error("  Test " + currentJob.Name + " failed (" + count + ") "+execTime);
            }
        }

        protected void Skip(int count)
        {
            for (int i = 0; i < count; i++)
            {
                currentJob.Results.Skip();
            }
        }
    }

    /// <summary>
    /// The ancient priority-based stress scheduler.
    /// </summary>
    public class StressSchedulerPriority: StressTestScheduler
    {
        public StressSettingsPriority Settings;
        protected StressJobList stressJobs;
        public bool ShowDetailedExceptions = true;
        public int DeadlockSeconds = 120;

        protected static RandomEx RandGen = new RandomEx();
        protected bool running = false;
        protected DateTime startTime = DateTime.UtcNow;
        protected int initThreads;

        private ArrayList threads = new ArrayList();
        private ArrayList terminationList = new ArrayList();
        private object throttleLock = new object();
        private bool throttlingEnabled = false;
        public double ThrottlingDelay = 100;

        private TestResultCollection AllResults = new TestResultCollection();

        private StfXmlDoc Config;

        public bool ThrottlingEnabled
        {
            get{return throttlingEnabled;}
            set{throttlingEnabled=value; Settings.UseThrottling=value;}
        }

        //eh?
        public Control SchedulerControl
        {
            get
            {
                if (control == null)
                {
                    lock (control_lock)
                    {
                        if (control == null)
                        {
                            control = new StressSchedulerPriControl();
                            control.Scheduler = this;
                        }
                    }
                }

                return control;
            }
        }

        protected object control_lock = new object();
        protected StressSchedulerPriControl control = null;

        //so...
        public void Tick()
        {
            if (control != null)
            {
                control.SyncWithScheduler();
            }
        }

        /// <summary>
        /// Gets a scale value from a stress job.
        /// </summary>
        /// <param name="job">The job to get from.</param>
        /// <returns>The scale value from the stress job.</returns>
        public float GetScaleValue (StressJob job)
        {
            return job.Priority;
        }

        /// <summary>
        /// Sets a scale value on a stress job.
        /// </summary>
        /// <param name="job">The job to set on.</param>
        /// <param name="val">The scale value to set.</param>
        public void SetScaleValue (StressJob job, float val)
        {
            job.Priority = val;
        }

        /// <summary>
        /// The name of the scale value used by this scheduler.  Displayed on GUI elements.
        /// </summary>
        public string ScaleName
        {
            get
            {
                return "Priority";
            }
        }

        /// <summary>
        /// Load settings from an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        public void LoadSettings(XmlNode node)
        {
            int temp = XmlUtil.GetChildNodeValue(node, "MaxThreads", -1);

            if (temp >= 0)
            {
                MaxThreads = temp;
            }
        }

        /// <summary>
        /// Save settings to an xml fragment.
        /// </summary>
        /// <param name="node">The root of the settings.</param>
        public void SaveSettings(XmlNode node)
        {
            XmlUtil.SetChildNodeValue(node, "MaxThreads", MaxThreads);
        }

        public int NumThreads {get {return threads.Count + terminationList.Count;}}
        public bool Running {get {return running;}}

        public int ActiveThreads
        {
            get
            {
                return NumUnstoppedThreads;
            }
        }
        
        public int NumUnstoppedThreads
        {
            get
            {
                int num = 0;

                foreach (StressThread thread in threads)
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        num++;

                foreach (StressThread thread in terminationList)
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        num++;

                return num;
            }
        }

        public TimeSpan GetElapsed()
        {
            return DateTime.UtcNow-startTime;
        }

        public int MaxThreads
        {
            get
            {
                lock (threads)
                {
                    if (!running)
                        return initThreads;

                    return threads.Count;
                }
            }
            set
            {
                lock (threads)
                {
                    Settings.Threads = value;

                    if (!running)
                    {
                        initThreads = value;
                        return;
                    }

                    int numNewThreads = value - threads.Count;
                    if (numNewThreads >= 0)
                    {
                        // Need to create additional threads
                        for (int i = 0; i < numNewThreads; i++)
                        {
                            StressThread st = new StressThread(this);
                            threads.Add(st);
                            st.Start();
                        }
                    }
                    else
                    {
                        // Need to kill some threads
                        TerminateThreads(-numNewThreads);
                    }
                }
            }
        }

        private object waitTimeLastChangeLock = new object();
        private DateTime waitTimeLastChange = DateTime.UtcNow;
        private bool WaitTimeChangeAllowed()
        {
            if ((DateTime.UtcNow - startTime).TotalSeconds < 20)
            {
                return(false);
            }
            lock(waitTimeLastChangeLock)
            {
                if ((DateTime.UtcNow - waitTimeLastChange).TotalSeconds >= 1)
                {
                    return(true);
                }
            }
            return(false);
        }

        private volatile bool _waitTimeMsInited = false;
        private object _waitTimeMsLock = new object();
        private volatile int _waitTimeMs = 0;
        private int waitTimeMs
        {
            get
            {
                lock(_waitTimeMsLock)
                {
                    // Initialize the waitTimeMs if it hasn't already been
                    if (_waitTimeMsInited == false)
                    {
                        if (Settings.ThrottlingTps <= 0)
                        {
                            throw new Exception("Throttling TPS cannot be equal to or less than 0");
                        }
                        _waitTimeMs = (int)Math.Ceiling(1000.0 / Settings.ThrottlingTps * NumThreads);
                        _waitTimeMsInited = true;
                        CoreGlobal.RO.Debug("_waitTimeMs initialized to {0}", _waitTimeMs);
                    }
                    return(_waitTimeMs);
                }
            }
            set
            {
                lock(_waitTimeMsLock)
                {
                    if (WaitTimeChangeAllowed())
                    {
                        _waitTimeMs = value;
                        lock(waitTimeLastChangeLock)
                        {
                            waitTimeLastChange = DateTime.UtcNow;
                        }
                    }
                }
            }
        }

        private const int waitMsStep = 1;

        virtual public StressJob PickTest()
        {
            try
            {
                while (stressJobs.TotalPriority == 0)
                    Thread.Sleep(200);

                float testToRun = RandGen.Next(stressJobs.TotalPriority);

                foreach (StressJob job in stressJobs)
                {
                    testToRun -= job.Priority;
                    if (job.Priority > 0f && testToRun <= 0)
                        return job;
                }

            }
            catch (Exception e)
            {
                CoreGlobal.RO.Error("Caught exception {0}", e.ToString());
            }

            CoreGlobal.RO.Error("StressScheduler.PickTest didn't find a test to run!");
            return null;
        }

        //
        public void Initialize(StfXmlDoc config, StressJobList jobListReference, StressSettingsCommon initialCommonSettings)
        {
            Settings=new StressSettingsPriority(config);

            if (initialCommonSettings!=null)
            {
                Settings.CopyFrom(initialCommonSettings);
            }

            Config = config;
            stressJobs=jobListReference;

            //
            MaxThreads = Settings.Threads;
            ThrottlingDelay=1000.0/(double)Settings.ThrottlingTps;
        }

        public StressSettingsCommon GetSettings()
        {
            return Settings;
        }

        //Shuts down the scheduler.
        public void Shutdown()
        {
            
        }

        //This call should block and run tests and block until someone calls Stop.
        public void Run()
        {
            if (stressJobs.Count == 0)
            {
                CoreGlobal.RO.Warn("Stress can not start because no stress jobs are set to run.");
                return;
            }

            BeginStress();
        }

        //Stop running tests.
        public void Stop()
        {
            running = false;
        }

        public bool ValidateParameters()
        {
            return true;
        }

        /// <summary>
        /// Called by AsyncButtonClickAction when Start button is clicked. This is when we
        /// actually start doing the stress test work.
        /// </summary>
        protected void BeginStress()
        {
            startTime = DateTime.UtcNow;

            // Create threads. By setting MaxThreads, it will create all of the threads, but
            // it will only do this if running=true.  Convoluted.
            lock (threads)
            {
                running = true;
                MaxThreads = initThreads;
            }

            // Main loop
            while (running)
            {
                Thread.Sleep(1000);

                HandleDeadlocks();

                CleanTerminationList();

                //VerifyThreadsAreRunning(); //hrm

                if (stressJobs.TotalPriority == 0)
                {
                    CoreGlobal.RO.Warn("No jobs are scheduled to run.  Please check your priorities.");
                    Thread.Sleep(500);
                }
            }

            CoreGlobal.RO.Debug("Stopping stress threads...");
            TerminateAllThreads();
            CoreGlobal.RO.Debug("Threads stopped.");

            StressSchedulerHelpers.PerformPostRun(stressJobs, Settings);
        }


        /// <summary>
        /// Terminate some number of threads gently. 
        /// </summary>
        /// <param name="count"></param>
        protected void TerminateThreads(int count)
        {
            lock (threads)
            {
                ArrayList removalList = new ArrayList();

                for (int i = 0; i < count; i++)
                {
                    ((StressThread)threads[i]).SoftTerminate();
                    removalList.Add(threads[i]);
                }

                foreach (StressThread thread in removalList)
                {
                    terminationList.Add(thread);
                    threads.Remove(thread);
                }
            }
        }

        /// <summary>
        /// Terminate all threads, used when stopping stress run.
        /// </summary>
        protected void TerminateAllThreads()
        {
            lock (threads)
            {
                // Softly abort all threads
                TerminateThreads(threads.Count);

                // Then wait a bit for them to stop executing
                int waitTime = 10;
                bool threadsStillRunning = true;
                for (int termSecs = 0; termSecs < waitTime && threadsStillRunning; termSecs++)
                {
                    // TODO: put in a ticker here
                    System.Threading.Thread.Sleep(1000);

                    threadsStillRunning = false;
                    foreach (StressThread thread in terminationList)
                        if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                            threadsStillRunning = true;
                }

                foreach (StressThread thread in terminationList)
                {
                    // We've given the thread some time to shut itself down. It hasn't.
                    // So let's force it to terminate. MSDN says this technique will
                    // "usually" terminate a thread.
                    if (thread.ThreadState != System.Threading.ThreadState.Stopped)
                        thread.Terminate();
                }

                // After aborting the threads, we're going to call Join() which 
                // will wait for them to abort.  
                // TODO: It appears this will happen sequentially, which probably
                // isn't desirable.
                foreach (StressThread thread in terminationList)
                {
                    if (!thread.Join())
                    {
                        CoreGlobal.RO.Warn("Failed to forcefully terminate thread {0}", thread.ToString());
                    }
                }

                CleanTerminationList();
            }
        }

        protected void HandleDeadlocks()
        {
            lock (threads)
            {
                for (int i = 0; i < threads.Count; i++)
                {
                    StressThread thread = (StressThread)threads[i];
                    if (DateTime.UtcNow > thread.Updated + new TimeSpan(0, 0, DeadlockSeconds))
                    {
                        thread.Terminate();

                        if (thread.CurrentJob != null)
                            thread.CurrentJob.Results.Deadlock();

                        thread = new StressThread(this);
                        thread.Start();
                        threads[i] = thread;
                    }
                }
            }
        }

        protected void CleanTerminationList()
        {
            lock (threads)
            {
                bool itemRemovedFromTerminationList = true;
                while (itemRemovedFromTerminationList)
                {
                    itemRemovedFromTerminationList = false;
                    foreach (StressThread thread in terminationList)
                    {
                        if (thread.ThreadState != System.Threading.ThreadState.Running)
                        {
                            terminationList.Remove(thread);
                            itemRemovedFromTerminationList = true;
                            break;
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerTPSControl.cs ===
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;

namespace ServerTestFramework.Runner
{
    public partial class StressSchedulerTPSControl : UserControl
    {
        #region Fields

        protected struct PeriodValue
        {
            public float PeriodInSeconds;
            public string PeriodName;

            public PeriodValue (float pis, string pn)
            {
                PeriodInSeconds = pis;
                PeriodName = pn;
            }
        }

        protected List<PeriodValue> Periods;

        #endregion

        #region Properties

        private StressSettingsTPS settings = null;

        /// <summary>
        /// The settings object used by the scheduler that owns this control.
        /// </summary>
        public StressSettingsTPS Settings
        {
            get
            {
                return settings;
            }
            set
            {
                settings = value;
                SyncWithSettings();
            }
        }

        #endregion

        public StressSchedulerTPSControl()
        {
            InitializeComponent();

            Periods = new List<PeriodValue>();

            Periods.Add(new PeriodValue(60f * 60f * 24f, "24 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 12f, "12 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 8f, "8 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 6f, "6 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 4f, "4 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 3f, "3 hrs"));
            Periods.Add(new PeriodValue(60f * 60f * 2f, "2 hrs"));
            Periods.Add(new PeriodValue(60f * 60f, "60 mins"));
            Periods.Add(new PeriodValue(60f * 30f, "30 mins"));
            Periods.Add(new PeriodValue(60f * 20f, "20 mins"));
            Periods.Add(new PeriodValue(60f * 15f, "15 mins"));
            Periods.Add(new PeriodValue(60f * 12f, "12 mins"));
            Periods.Add(new PeriodValue(60f * 10f, "10 mins"));
            Periods.Add(new PeriodValue(60f * 6f, "6 mins"));
            Periods.Add(new PeriodValue(60f * 5f, "5 mins"));
            Periods.Add(new PeriodValue(60f * 4f, "4 mins"));
            Periods.Add(new PeriodValue(60f * 3f, "3 mins"));
            Periods.Add(new PeriodValue(60f * 2f, "2 mins"));
            Periods.Add(new PeriodValue(60f, "60 secs"));
            Periods.Add(new PeriodValue(30f, "30 secs"));
            Periods.Add(new PeriodValue(20f, "20 secs"));
            Periods.Add(new PeriodValue(15f, "15 secs"));
            Periods.Add(new PeriodValue(12f, "12 secs"));
            Periods.Add(new PeriodValue(10f, "10 secs"));

            trkSineWavePeriod.Maximum = Periods.Count - 1;
        }

        /// <summary>
        /// Syncs the various child controls with the settings object.
        /// </summary>
        public void SyncWithSettings ()
        {
            StressSettingsTPS sst = Settings;
            if (sst == null) { return; }

            nudMaxThreads.Value = Convert.ToDecimal(sst.MaxThreads);
            chkSineWave.Checked = sst.SinWaveEnabled;
            SyncSineTrackers();
            trkSineWaveMagnitude.Value = (int) (sst.SinWaveMagnitude * 100);
            SyncSineMagnitudeLabel();
            trkSineWavePeriod.Value = PeriodFloatToInt(sst.SinWavePeriod);
            SyncSinePeriodLabel();
            trkSineWavePhase.Value = PhaseFloatToInt(sst.SinWavePhase);
            SyncSinePhaseLabel();
            trkReservedThreads.Value = (int) (sst.ReserveHighTPSThreadRatio * 100);
            SyncReservedThreadsLabel();
            trkScaleTPS.Value = (int) (sst.ScaleTPS * 100);
            SyncScaleTPSLabel();
            nudThreadLife.Value=sst.HangTime;
            nudRampTime.Value=(decimal)sst.StartRampTime;

            nudSleepTime.Value=(decimal)sst.SchedulerSleepTimeMs;
            nudDelayTime.Value=(decimal)sst.SchedulerDelayTimeUs;

            _SyncWithSettingsStatus(sst);
        }

        /// <summary>
        /// Syncs the status labels with the settings values.
        /// </summary>
        public void SyncWithSettingsStatus ()
        {
            StressSettingsTPS sst = Settings;
            if (sst == null) { return; }

            _SyncWithSettingsStatus(sst);
        }

        private void _SyncWithSettingsStatus (StressSettingsTPS sst)
        {
            lblActiveThreads.Text = sst.Status_CurrentThreads.ToString();
            lblSineWaveScale.Text = sst.Status_CurrentSinScalar.ToString("F4");
            lblRampScale.Text=(int)(100*sst.Status_StartRampScale)+"%";
        }

        protected void SyncSineTrackers ()
        {
            bool temp = chkSineWave.Checked;
            trkSineWaveMagnitude.Enabled = temp;
            trkSineWavePeriod.Enabled = temp;
            trkSineWavePhase.Enabled = temp;
        }

        protected void SyncSineMagnitudeLabel ()
        {
            lblSineWaveMagnitude.Text = trkSineWaveMagnitude.Value.ToString() + "%";
        }

        protected void SyncSinePeriodLabel ()
        {
            lblSineWavePeriod.Text = Periods[(Periods.Count - 1) - trkSineWavePeriod.Value].PeriodName;
        }

        protected void SyncSinePhaseLabel ()
        {
            lblSineWavePhase.Text = (trkSineWavePhase.Value * 90).ToString() + "\x00b0";
        }

        protected void SyncReservedThreadsLabel ()
        {
            lblReservedThreads.Text = trkReservedThreads.Value.ToString() + "%";
        }

        protected void SyncScaleTPSLabel ()
        {
            lblScaleTPS.Text = trkScaleTPS.Value.ToString() + "%";
        }

        #region Settings Conversion Functions

        protected int PeriodFloatToInt (float period)
        {
            int ans = 0;
            float diff = float.MaxValue;

            for (int i = 0; i < Periods.Count; ++i)
            {
                float temp_diff = Math.Abs(period - Periods[i].PeriodInSeconds);
                if (temp_diff < diff)
                {
                    ans = i;
                    diff = temp_diff;
                }
            }

            // reverse it, as this is how it was done for some reason, by me...
            return (Periods.Count - 1) - ans;
        }

        protected int PhaseFloatToInt (float phase)
        {
            float pi = Convert.ToSingle(Math.PI);
            float two_pi = pi * 2f;
            float degrees45 = pi / 4f;

            while (phase > two_pi) { phase -= two_pi; }
            while (phase < 0) { phase += two_pi; }

            if (Math.Abs(phase - (pi * 3f) / 2f) < degrees45) { return 3; }
            if (Math.Abs(phase - pi) < degrees45) { return 2; }
            if (Math.Abs(phase - pi / 2f) < degrees45) { return 1; }
            return 0;
        }

        #endregion

        #region GUI Input Handlers

        private void nudMaxThreads_ValueChanged (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;
            if (sst == null) { return; }

            sst.MaxThreads = Convert.ToInt32(nudMaxThreads.Value);
        }

        private void chkSineWave_CheckedChanged (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SinWaveEnabled = chkSineWave.Checked;
            }

            SyncSineTrackers();
        }

        private void trkSineWaveMagnitude_Scroll (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SinWaveMagnitude = trkSineWaveMagnitude.Value / 100.0f;
            }

            SyncSineMagnitudeLabel();
        }

        private void trkSineWavePeriod_Scroll (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SinWavePeriod = Periods[(Periods.Count - 1) - trkSineWavePeriod.Value].PeriodInSeconds;
            }

            SyncSinePeriodLabel();
        }

        private void trkSineWavePhase_Scroll (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SinWavePhase = Convert.ToSingle((trkSineWavePhase.Value * Math.PI) / 2);
            }

            SyncSinePhaseLabel();
        }

        private void trkReservedThreads_Scroll (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.ReserveHighTPSThreadRatio = trkReservedThreads.Value / 100f;
            }

            SyncReservedThreadsLabel();
        }

        private void trkScaleTPS_Scroll (object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.ScaleTPS = trkScaleTPS.Value / 100f;
            }

            SyncScaleTPSLabel();
        }

        private void nudThreadLife_ValueChanged(object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.HangTime = (int)(nudThreadLife.Value);
            }
        }

        private void nudRampTime_ValueChanged(object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.StartRampTime = (float)(nudRampTime.Value);
            }
        }

        private void nudSleepTime_ValueChanged(object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SchedulerSleepTimeMs = (int)(nudSleepTime.Value);
            }
        }

        private void nudDelayTime_ValueChanged(object sender, EventArgs e)
        {
            StressSettingsTPS sst = Settings;

            if (sst != null)
            {
                sst.SchedulerDelayTimeUs = (int)(nudDelayTime.Value);
            }
        }

        #endregion
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\TestNode.cs ===
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Threading;
using System.Xml;
using ServerTestFramework.Utilities;
using ServerTestFramework.Core.Utilities;

namespace ServerTestFramework
{
    /// <summary>
    /// Type of execution being run.
    /// These should be changed to proper case at some point.
    /// </summary>
    public enum RUN_TYPE
    {
        FUNCTIONAL,
        STRESS,

        RUN_TYPE_COUNT
    };

    #region TestNode - The basic unit of life, the universe, everything
    /// <summary>
    /// The fundamental unit that makes up test groups and test cases.
    /// A node can be either be executed or can contain any number of other nodes as children.
    /// </summary>
    public class TestNode: IDisposable
    {
        #region Data

        //common properties of all nodes
        public string Name               //the local name of this node
        {
            get { return name; }
            set
            {
                if (value==null || value.Length==0)
                {
                    throw new System.Exception("A TestNode's Name may not be null or empty.");
                }

                name=value.Replace('.',' ');
            }
        }
        private string name;
        private string desc      = "";    //a description of the node
        public object []MyValues = null;  //these are the values assigned to each instance of a test node that has multiple instances

        private Dictionary<string,object> ContextData = null; //data shared between tests is stored here.  at the least the root will always have one.

        //A node can be used for either functional or stress or both.
        //We store properties specific to each of those here.  It will be null if it's not of that type.
        public FunctionalNodeData FunctionalData = null;
        public StressNodeData     StressData     = null;

        //generic tagging information, used for filtering or external reporting
        public NodeTaggingData TaggingData = null;

        /// <summary>
        /// The parent node of this node in the tree.
        /// </summary>
        public TestNode Parent
        {
            get { return parent; }
        }

        /// <summary>
        /// The children nodes of this node in the tree.
        /// </summary>
        public IEnumerable<TestNode> Children
        {
            get { return children; }
        }

        public int ChildrenCount
        {
            get { return children.Count; }
        }

        private TestNode             parent;
        private LinkedList<TestNode> children = new LinkedList<TestNode>();

        //these are used to prevent extra pre/post runs from occuring (such as if both stress and functionals are running)
        private bool isOneTimeSetupPerformed = false; //for parameterless call
        private bool []oneTimeSetupTypePerformed = new bool[(int)RUN_TYPE.RUN_TYPE_COUNT];
        private int preRunCount = 0;

        public delegate void TestSetupDelegate();
        private LinkedList<TestSetupDelegate> TestSetupMethods=new LinkedList<TestSetupDelegate>();

        public delegate void TestTearDownDelegate();
        private LinkedList<TestTearDownDelegate> TestTearDownMethods=new LinkedList<TestTearDownDelegate>();

        //for if the node is intended to represent a different (for example a wrapper class that doesn't derive from TestNode)
        private Type representedType=null;
        private object representedObject=null;
        private bool isDummyContainer=false;

        /// <summary>
        /// Description of the test case
        /// </summary>
        public string Desc
        {
            get
            {
                return desc;
            }

            set
            {
                desc = value;
                if (desc==null)
                {
                    desc="";
                }
            }
        }

        /// <summary>
        /// The fully qualified name of the node, which uniquely identifies it in the tree.
        /// </summary>
        public string FullName
        {
            get
            {
                if (Parent == null)
                    return Name;
                else
                    return Parent.FullName + "." + Name;
            }
        }

        /// <summary>
        /// Stores the dll that this node belongs to.
        /// </summary>
        public string ContainingDll
        {
            get
            {
                if (containingDll==null && Parent!=null)
                {
                    return Parent.ContainingDll;
                }
                else
                {
                    return containingDll;
                }
            }
        }
        private string containingDll=null;

        /// <summary>
        /// Returns whether an attribute is present on this node.
        /// </summary>
        public virtual bool HasAttribute(Type t)
        {
            return GetActualType().GetCustomAttributes(t, true).Length > 0;
        }

        /// <summary>
        /// Returns a list of all attributes on this node.
        /// </summary>
        public object[] GetAttributes(Type t)
        {
            return GetAttributes(t, true);
        }

        /// <summary>
        /// Returns a list of all attributes on this node.
        /// </summary>
        public virtual object[] GetAttributes(Type t, bool inherited)
        {
            return GetActualType().GetCustomAttributes(t, inherited);
        }

        public TAttributeType[] GetAttributes<TAttributeType>()
            where TAttributeType : Attribute
        {
            Object[] attrs = GetActualType().GetCustomAttributes(typeof(TAttributeType), true);
            TAttributeType[] typedAttrs = new TAttributeType[attrs.Length];
            for (int i = 0; i < attrs.Length; i++)
            {
                typedAttrs[i] = attrs[i] as TAttributeType;
            }

            return typedAttrs;
        }

        /// <summary>
        /// Returns a single attribute of the requested type
        /// </summary>
        /// <typeparam name="TAttributeType">The type of attribute to get</typeparam>
        /// <returns>An attribute of the given type if it exists, or null otherwise</returns>
        public TAttributeType GetAttribute<TAttributeType>()
            where TAttributeType : Attribute
        {
            Object[] attributes = GetAttributes(typeof(TAttributeType));
            TAttributeType attribute = ((attributes.Length > 0) ? attributes[0] : null) as TAttributeType;

            return attribute;
        }

        //Load our initial attributes that are not type-specific
        protected virtual void LoadAttributes()
        {
            object[] attr=GetAttributes(typeof(DescriptionAttribute));
            if (attr.Length>0)
            {
                DescriptionAttribute da=(DescriptionAttribute)attr[0];
                Desc=da.Desc;
            }

            //search for the setup and teardown attributes on our members
            foreach (MethodInfo mi in GetActualType().GetMethods(BindingFlags.NonPublic|BindingFlags.Public|BindingFlags.Static|BindingFlags.Instance))
            {
                bool isSetup=mi.GetCustomAttributes(typeof(TestGroupSetupAttribute), true).Length > 0;
                bool isTeardown=mi.GetCustomAttributes(typeof(TestGroupTearDownAttribute), true).Length > 0;

                if (isSetup)
                {
                    if (mi.IsStatic)
                    {
                        TestSetupMethods.AddLast((TestSetupDelegate)Delegate.CreateDelegate(typeof(TestSetupDelegate), mi));
                    }
                    else
                    {
                        TestSetupMethods.AddLast((TestSetupDelegate)Delegate.CreateDelegate(typeof(TestSetupDelegate), GetActualInstance(), mi));
                    }
                }

                if (isTeardown)
                {
                    if (mi.IsStatic)
                    {
                        TestTearDownMethods.AddLast((TestTearDownDelegate)Delegate.CreateDelegate(typeof(TestTearDownDelegate), mi));
                    }
                    else
                    {
                        TestTearDownMethods.AddLast((TestTearDownDelegate)Delegate.CreateDelegate(typeof(TestTearDownDelegate), GetActualInstance(), mi));
                    }
                }
            }

            //load tags
            TaggingData=new NodeTaggingData(this);
        }

        /// <summary>
        /// Returns the type of the class represented by the TestNode (which may be a wrapper around the real class)
        /// </summary>
        public Type GetActualType()
        {
            return (representedType==null?GetType():representedType);
        }

        /// <summary>
        /// /// Returns the class represented by the TestNode (which may be a wrapper around the real class)
        /// </summary>
        public object GetActualInstance()
        {
            return (representedObject==null?this:representedObject);
        }

        /// <summary>
        /// Creates context data on a node.  This is useful for overiding values for a specific branch of the tree.
        /// If it already exists it is cleared.
        /// </summary>
        public void CreateContextData()
        {
            ContextData=new Dictionary<string,object>();
        }

        /// <summary>
        /// Destroys context data on a node.  The context on the root node may not be destroyed
        /// </summary>
        public void DestroyContextData()
        {
            if (Parent==null)
            {
                throw new Exception("The root node's context data may not be destroyed.");
            }
            ContextData=null;
        }

        /// <summary>
        /// Searches ourself and then up the tree looking for a specifically named piece of data.
        /// Returns null if not found.
        /// </summary>
        public object GetContextData(string name)
        {
            TestNode cur=this;
            while (cur!=null)
            {
                if (cur.ContextData!=null)
                {
                    lock (cur.ContextData)
                    {
                        object data;
                        if (cur.ContextData.TryGetValue(name, out data))
                        {
                            return data;
                        }
                    }
                }

                cur=cur.Parent;
            }

            return null;
        }

        /// <summary>
        /// Sets data into the first context that is found from searching ourself and then up the tree.
        /// </summary>
        public void SetContextData(string name, object data)
        {
            TestNode cur=this;
            while (cur!=null)
            {
                if (cur.ContextData!=null)
                {
                    lock (cur.ContextData)
                    {
                        cur.ContextData[name]=data;
                        return;
                    }
                }

                cur=cur.Parent;
            }
        }

        /// <summary>
        /// Retrieves a flattened list of all nodes under this one, including itself.
        /// </summary>
        /// <param name="allNodes"></param>
        public void GetFlattenedSubtree(ref List<TestNode> allNodes)
        {
            allNodes.Add(this);
            if (children.Count != 0)
            {
                foreach (TestNode tn in Children)
                {
                    tn.GetFlattenedSubtree(ref allNodes);
                }
            }
        }

        #endregion //Data

        //ctors
        public TestNode()
        {
            Name = GetActualType().Name;
            LoadAttributes();
        }
        public TestNode(string name)
        {
            Name = name;
            LoadAttributes();
        }

        /// <summary>
        /// Creates a test node with the given children.
        /// </summary>
        /// <param name="name">The name of the test node.</param>
        /// <param name="children">The children to give the test node.</param>
        /// <param name="addFunctionalData">If true, adds functional data to the nodes.</param>
        /// <param name="addStressData">If true, adds stress data to the nodes.</param>
        /// <remarks>
        /// Attempting to pass the Children from another TestNode may not work, as the enumeration object
        /// may not function properly when its container is modified by the AddChild function.
        /// </remarks>
        public TestNode (string name, IEnumerable<TestNode> children, bool addFunctionalData, bool addStressData) : this(name)
        {
            foreach (TestNode node in children)
            {
                AddChild(node, addFunctionalData, addStressData);
            }
        }

        public TestNode(object containedObject)
        {
            representedType=containedObject.GetType();
            representedObject=containedObject;
            Name = GetActualType().Name;
            LoadAttributes();
        }

        #region Tree Generation and Searching

        /// <summary>
        /// Returns a list of all top level nodes, which have had all child nodes fully populated.
        /// </summary>
        public static TestNode GenerateNodeTree(string assemblyName)
        {
            //instantiate the assembly
            Assembly asm;
            if (assemblyName==null)
            {
                asm=Assembly.GetCallingAssembly();
                assemblyName=asm.FullName.Split(new char[]{','})[0];
            }
            else
            {
                try
                {
                    asm=AssemblyUtils.LoadAssemblyUsingDefaultMethod(assemblyName);
                }
                catch(Exception e)
                {
                    CoreGlobal.RO.Fatal("Failed to load assembly \""+assemblyName+"\": "+e);
                    return new TestNode("Failed To Load "+assemblyName);
                }
            }

            // trigger event
            try
            {
                CoreGlobal.TestNodeTreeSourceInfo si = new CoreGlobal.TestNodeTreeSourceInfo();
                si.Assembly = asm;
                si.AssemblyFile = assemblyName;
                CoreGlobal.OnTestNodeTreePreload(si);
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Warn("Exception calling the TestNodeTreePreload event:\n" + e);
            }

            //find and create a root node and populate it
            Type rootType=null;
            object []objTypes=asm.GetCustomAttributes(typeof(RootNodeAttribute), false);
            if (objTypes.Length>0)
            {
                rootType=((RootNodeAttribute)objTypes[0]).RootType;
            }

            TestNode root=null;
            if (rootType!=null)
            {
                try
                {
                    root=ConstructFromType(rootType);
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Fatal("Exception constructing a root node of type "+rootType+": "+e);
                    CoreGlobal.RO.Warn("A dummy root node will be made in place of the root that failed to construct.");

                    root=new TestNode(assemblyName);
                    root.isDummyContainer=true;
                }
            }

            if (root==null)
            {
                root=new TestNode(assemblyName);
            }

            root.Name=asm.GetName().Name; //root is always named after the assembly
            root.CreateContextData(); //the root always has context data

            try
            {
                root.PopulateNode(asm);

                if (root.ChildrenCount==0) //if none were found from an assembly top-level search, try searching my nested classes
                {
                    root.PopulateNode(null);
                }
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Fatal("Exception trying to populate children of the root node from "+assemblyName+": "+e);
            }

            root.DoPostProcessBranch();
            root.containingDll=assemblyName;

            try
            {
                CoreGlobal.CallTestNodeTreeLoaded(root);
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Warn("Exception calling the TestNodeTreeLoaded event:\n"+e);
            }

            return root;
        }

        /// <summary>
        /// This will be called once on all node instances after the full tree has been constructed and linked together.
        /// A node may use this to make changes to itself or its children.  This includes adding/removing children and changing data members.
        /// </summary>
        protected virtual void PostProcessBranchConstruction()
        {
        }

        /// <summary>
        /// Used to sort the compound cases.
        /// </summary>
        private int CompoundCaseComparison (CompoundCaseAttribute x, CompoundCaseAttribute y)
        {
            if (x.IsNumber && y.IsNumber)
            {
                if (x.Number == y.Number) { return 0; }
                return (x.Number < y.Number ? -1 : 1);
            }
            else if (x.IsNumber)
            {
                return -1;
            }
            else if (y.IsNumber)
            {
                return 1;
            }
            else
            {
                return string.Compare(x.Name, y.Name, true);
            }
        }

        //populates a node from either an assembly if one was provided, or the current type if not
        private void PopulateNode(Assembly asm)
        {
            //determine if we need to do compound expansion
            bool doCompExpansion=false;
            TestNode []instances=null;
            if (!hasUpdatedInstances)
            {
                //go over the attributes
                CompoundCaseAttribute []compCases=(CompoundCaseAttribute[])GetAttributes(typeof(CompoundCaseAttribute), false);

                // provide some stability and sense
                Array.Sort<CompoundCaseAttribute>(compCases, CompoundCaseComparison);

                foreach (CompoundCaseAttribute cca in compCases)
                {
                    TestNode_AddInstance(cca);
                }

                //now get the instances; we only expand if we have any
                instances=GenerateTestInstances();
                if (instances!=null && instances.Length>0)
                {
                    doCompExpansion=true;
                    isCompoundRoot=true;
                }
            }

            //
            if (doCompExpansion) //do compound expansion on the node if needed
            {
                foreach (TestNode tni in instances)
                {
                    AddChild(tni, false, false);
                }
            }
            else //search us for children
            {
                //check all our nested types for other nodes
                bool allowNestedType=true;
                Type[] eTypes;
                if (asm!=null)
                {
                    allowNestedType=false;

                    try
                    {
                        eTypes=asm.GetTypes();
                    }
                    catch (ReflectionTypeLoadException rle)
                    {
                        CoreGlobal.RO.Warn("Not all types in "+asm.FullName+" could be loaded.");
                        eTypes=rle.Types;
                    }
                }
                else
                {
                    eTypes=ReflectionUtils.GetNestedTypesInInheritanceTree(GetActualType(), BindingFlags.NonPublic|BindingFlags.Public);
                }

                foreach (Type t in eTypes)
                {
                    try
                    {
                        if (t!=null && ((allowNestedType || (!allowNestedType && !t.IsNested))))
                        {
                            //to be picked up, it must have either [TestCase], [TestGroup], or [StressTest]
                            bool isGroup = false;
                            bool isFunc = false;
                            bool isStress = false;
                            object[] custattr = t.GetCustomAttributes(false);

                            for (int i = 0; i < custattr.Length; ++i)
                            {
                                object o = custattr[i];
                                if (!isGroup && (o is TestGroupAttribute))
                                {
                                    isGroup = true;
                                    continue;
                                }
                                if (!isFunc && (o is TestCaseAttribute))
                                {
                                    isFunc = true;
                                    continue;
                                }
                                if (!isStress && (o is StressTestAttribute))
                                {
                                    isStress = true;
                                    continue;
                                }
                            }

                            if (isGroup || isFunc || isStress)
                            {
                                //warn about the impossible - you can't be both a group and a test
                                if (isGroup && (isFunc || isStress))
                                {
                                    CoreGlobal.RO.Warn("Node "+t.FullName+" is trying to be both a group and a test case.  It will act like a group only.");
                                    isFunc=false;
                                    isStress=false;
                                }

                                TestNode newNode;
                                try
                                {
                                    newNode=ConstructFromType(t);
                                }
                                catch (Exception e)
                                {
                                    string useNames=(isGroup?"group":"");
                                    if (isFunc)
                                    {
                                        useNames+=(useNames.Length>0?", ":"")+"functional";
                                    }
                                    if (isStress)
                                    {
                                        useNames+=(useNames.Length>0?", ":"")+"stress";
                                    }

                                    CoreGlobal.RO.Fatal("Exception trying to create a TestNode("+useNames+") for type "+t.FullName+(asm!=null?" in "+asm.FullName:"")+":\n"+e);

                                    if (isGroup)
                                    {
                                        CoreGlobal.RO.Warn("A dummy group node will be made in place of the group that failed to construct.");
                                        newNode=new TestNode(t.Name);
                                        newNode.representedType=t;
                                        newNode.representedObject=null;
                                        newNode.isDummyContainer=true;
                                        newNode.LoadAttributes(); //Normally this is called by the constructor, but the type's constructor failed in this case so call it manually
                                    }
                                    else
                                    {
                                        continue;
                                    }
                                }

                                //add it
                                AddChild(newNode, isFunc, isStress);
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        CoreGlobal.RO.Warn("Unhandled exception in "+asm.FullName+" for type "+t+":\n"+e.ToString());
                    }
                }

                //check all our nested functions for cases
                foreach (MethodInfo mi in GetActualType().GetMethods())
                {
                    bool isFunc = false;
                    bool isStress = false;
                    object[] custattr = mi.GetCustomAttributes(false);

                    for (int i = 0; i < custattr.Length; ++i)
                    {
                        object o = custattr[i];
                        if (!isFunc)
                        {
                            if (o is TestCaseAttribute) { isFunc = true; continue; }
                        }
                        if (!isStress)
                        {
                            if (o is StressTestAttribute) { isStress = true; continue; }
                        }
                    }

                    if (isFunc || isStress)
                    {
                        //make a function container node for it
                        object testNodeDelegate=null;
                        if (mi.IsStatic)
                        {
                            testNodeDelegate=Delegate.CreateDelegate(typeof(TestNodeFunction.TestNodeDelegateTestNode), mi, false);
                            if (testNodeDelegate==null)
                            {
                                testNodeDelegate=Delegate.CreateDelegate(typeof(TestNodeFunction.TestNodeDelegateVoid), mi, false);
                            }
                        }
                        else
                        {
                            if (!isDummyContainer)
                            {
                                testNodeDelegate=Delegate.CreateDelegate(typeof(TestNodeFunction.TestNodeDelegateTestNode), GetActualInstance(), mi.Name, false, false);
                                if (testNodeDelegate==null)
                                {
                                    testNodeDelegate=Delegate.CreateDelegate(typeof(TestNodeFunction.TestNodeDelegateVoid), GetActualInstance(), mi.Name, false, false);
                                }
                            }
                            else
                            {
                                CoreGlobal.RO.Fatal("Unable to create a function-declared test named "+mi.Name+" in "+GetActualType().FullName+", because we do not have an instance of the group.");
                            }
                        }

                        if (testNodeDelegate!=null)
                        {
                            TestNodeFunction newNode=new TestNodeFunction(testNodeDelegate, mi, mi.Name);

                            //link it in
                            AddChild(newNode, isFunc, isStress);
                        }
                        else
                        {
                            CoreGlobal.RO.Fatal("Unabled to create a test case for function "+mi.Name+" because it does not have the correct signature.");
                        }
                    }
                }
            }

            //populate our children.
            LinkedListNode<TestNode> node = children.First;
            while (node != null)
            {
                try
                {
                    node.Value.PopulateNode(doCompExpansion?asm:null);
                }
                catch (Exception e)
                {
                    CoreGlobal.RO.Fatal("Exception trying to populate children of node "+node.Value.FullName+": "+e);
                }
                node = node.Next;
            }

            //if I have children, I may need type-specific nodes on myself
            if (children.Count>0)
            {
                if (FunctionalData==null && SearchForFunctionalChildren())
                {
                    FunctionalData=new FunctionalNodeData(this);
                }
                if (StressData==null && SearchForStressChildren())
                {
                    StressData=new StressNodeData(this);
                }
            }
        }

        //searches children for the existance of type-specific nodes
        private bool SearchForFunctionalChildren()
        {
            if (FunctionalData!=null)
                return true;

            foreach (TestNode child in Children)
            {
                if (child.SearchForFunctionalChildren())
                    return true;
            }

            return false;
        }
        private bool SearchForStressChildren()
        {
            if (StressData!=null)
                return true;

            foreach (TestNode child in Children)
            {
                if (child.SearchForStressChildren())
                    return true;
            }

            return false;
        }

        //calls postprocess on all nodes in a tree
        private void DoPostProcessBranch()
        {
            try
            {
                PostProcessBranchConstruction();
            }
            catch (Exception e)
            {
                CoreGlobal.RO.Error("Exception post-processing tree construction for node "+FullName+": "+e);
            }

            foreach (TestNode child in Children)
            {
                child.DoPostProcessBranch();
            }
        }

        /// <summary>
        /// Generates a copy of the node without sharing references.
        /// This new node is not immediately linked into any tree.
        /// </summary>
        public TestNode Clone()
        {
            TestNode n=(TestNode)this.MemberwiseClone();

            //linkage in the tree should not be implicitely shared
            n.children=new LinkedList<TestNode>();
            n.parent=null;

            //tagging, functional-specific and stress-specific properties should copied, not be shared
            if (FunctionalData!=null) n.FunctionalData=FunctionalData.Clone(n);
            if (StressData!=null) n.StressData=StressData.Clone(n);
            n.TaggingData=TaggingData.Clone(n);

            //copy known reference types in the base
            n.oneTimeSetupTypePerformed=(bool[])oneTimeSetupTypePerformed.Clone();

            return n;
        }

        /// <summary>
        /// Constructs a Clone() of this node, and also of all child nodes, which are linked back together as a branch of a new tree.
        /// </summary>
        public TestNode CloneBranch()
        {
            TestNode newNode=Clone();
            foreach (TestNode child in Children)
            {
                newNode.AddChild(child.CloneBranch(), child.FunctionalData!=null, child.StressData!=null);
            }
            return newNode;
        }

        /// <summary>
        /// Obliterates the node and all of its children
        /// </summary>
        public virtual void Dispose()
        {
            //
            foreach (TestNode child in Children)
            {
                child.Dispose();
            }

            //call one time cleanup
            for (int rt=0; rt<(int)RUN_TYPE.RUN_TYPE_COUNT; ++rt)
            {
                if (oneTimeSetupTypePerformed[rt])
                {
                    OneTimeCleanup((RUN_TYPE)rt);
                }
            }
        }

        /// <summary>
        /// Constructs a basic node with no linkage and no use-specific data from a type.
        /// If the type isn't derived from TestNode, it will be wrapped as a fake group.
        /// </summary>
        public static TestNode ConstructFromType(Type t)
        {
            //call the default constructor to instantiate it
            ConstructorInfo con=t.GetConstructor(Type.EmptyTypes);
            if(con==null)
            {
                throw new Exception("Could not create a TestNode because there is no default constructor for type "+t.FullName);
            }
            object obj=con.Invoke(Type.EmptyTypes);

            //either return that or wrap it
            if (t.IsSubclassOf(typeof(TestNode)))
            {
                return (TestNode)obj;
            }
            else
            {
                return new TestNode(obj);
            }
        }

        /// <summary>
        /// Adds a child node to this node's children.
        /// It optionally adds stress/functional-specific data to the node as well (if it does not already exist).
        /// Only valid during construction of a node or before that node's children have started populating.
        /// </summary>
        protected virtual void AddChild(TestNode n, bool addFunctionalData, bool addStressData)
        {
            //verify that we do not already have a child by that name
            foreach (TestNode kid in Children)
            {
                if (kid.Name.ToLower() == n.Name.ToLower())
                {
                    CoreGlobal.RO.Fatal("Failed add a child node named " + n.Name + " to " + FullName + ", because it already has a child by that name.");
                    return;
                }
            }

            //add it
            if (n.parent != null)
            {
                n.parent.children.Remove(this);
            }

            n.parent = this;
            this.children.AddLast(n);

            //set up it's type-specific data
            if (addFunctionalData && n.FunctionalData==null)
            {
                n.FunctionalData=new FunctionalNodeData(n);
            }

            if (addStressData && n.StressData==null)
            {
                n.StressData=new StressNodeData(n);
            }
        }

        /// <summary>
        /// Adds a child node to this node's children.
        /// It optionally adds functional-specific data to the node as well (if it does not already exist).
        /// Only valid during construction of a node or before that node's children have started populating.
        /// </summary>
        protected void AddChild(TestNode n)
        {
            AddChild(n, true, false);
        }

        /// <summary>
        /// Removes a child from this node.
        /// Only valid during construction of a node or before that node's children have started populating.
        /// </summary>
        protected void RemoveChild(TestNode child)
        {
            if (!children.Remove(child))
            {
                throw new Exception("Attempt to remove child "+child.FullName+" that was not found inside "+FullName);
            }

            child.parent=null;
        }

        /// <summary>
        /// Searches a tree for a node based on it's name.
        /// </summary>
        public static TestNode FindNode(TestNode rootNode, string fullNameToSearch)
        {
            string []nodeNameParts=fullNameToSearch.Split(new char []{'.'});
            return rootNode.InternalSearchTree(nodeNameParts,0);
        }

        //Helper used in searching the tree for a node
        private TestNode InternalSearchTree(string []nameParts, int partsIndex)
        {
            if (Name==nameParts[partsIndex]) //it's either me or inside of me
            {
                if (partsIndex<nameParts.Length-1) //there's more to go, so it's a child
                {
                    foreach (TestNode tn in Children)
                    {
                        TestNode found=tn.InternalSearchTree(nameParts, partsIndex+1);
                        if (found!=null)
                        {
                            return found;
                        }
                    }
                }
                else //it's me!
                {
                    return this;
                }
            }

            return null;
        }

        #region Test Node Instancing

        /// <summary>
        /// This can optionally be implemented to manually tweak how instances are generated.
        /// It is passed the list of instances that were specified from attributes.  You can then add or remove from this list.
        /// TODO: This list was meant to be a "linked" list, not a vector.  It would be a breaking change now though...
        /// </summary>
        protected virtual void EditInstances(ref System.Collections.Generic.List<CompoundCaseAttribute> instances)
        {
        }

        //Generate a TestNode for every instance the test represents.
        private TestNode[] GenerateTestInstances()
        {
            //ask them to update the list if we haven't yet
            lock (testNodeInstances)
            {
                if (!hasUpdatedInstances)
                {
                    hasUpdatedInstances=true;
                    try
                    {
                        EditInstances(ref testNodeInstances);
                    }
                    catch (Exception e)
                    {
                        //just swallow it and use what we got
                        CoreGlobal.RO.Fatal("Call to a EditInstances on Node "+FullName+" threw: "+e);
                    }

                    //resolve duplicate names
                    foreach (CompoundCaseAttribute cc1 in testNodeInstances)
                    {
                        int dupeNum=0;
                        foreach (CompoundCaseAttribute cc2 in testNodeInstances)
                        {
                            if (cc1==cc2) continue;

                            if (cc1.Name==cc2.Name)
                            {
                                CoreGlobal.RO.Warn("Compound Node " + Name + " has a duplicate instance name: " + cc1.Name + ".  The duplicate has been renamed.");
                                cc2.Name+=" " + ++dupeNum;
                            }
                        }
                    }
                }
            }

            //generate
            if (testNodeInstances.Count<=0)
            {
                return null;
            }

            TestNode []tbList=new TestNode[testNodeInstances.Count];
            int tbNum=0;
            foreach (CompoundCaseAttribute cc in testNodeInstances)
            {
                tbList[tbNum]=CloneBranch();
                tbList[tbNum].Name = cc.Name;
                tbList[tbNum].MyValues=cc.Values;
                if (tbList[tbNum].FunctionalData != null && cc.BugID != -1)
                {
                    tbList[tbNum].FunctionalData.BugID = cc.BugID;

                    if (cc.BugDatabase != null)
                    {
                        tbList[tbNum].FunctionalData.BugDatabase = cc.BugDatabase;
                    }
                }
                if (tbList[tbNum].FunctionalData != null && cc.Timeout != System.Threading.Timeout.Infinite)
                {
                    tbList[tbNum].FunctionalData.Timeout = cc.Timeout;
                }

                string []instanceTags=cc.Tags.Split(new char[]{';'});
                foreach (string tag in instanceTags)
                {
                    if (tag.Trim().Length>0)
                    {
                        tbList[tbNum].TaggingData.AddTag(tag);
                    }
                }

                ++tbNum;
            }

            //i should not actually have any children at this point; soon I'll have the instances I just made
            while (children.Count>0)
            {
                RemoveChild(children.First.Value);
            }

            return tbList;
        }

        //
        private bool hasUpdatedInstances=false;
        private System.Collections.Generic.List<CompoundCaseAttribute> testNodeInstances=new System.Collections.Generic.List<CompoundCaseAttribute>();
        private bool isCompoundRoot=false;

        //Should only be called by TestNode - adds an instance to the instance list during expansion
        private void TestNode_AddInstance(CompoundCaseAttribute instance)
        {
            testNodeInstances.Add(instance);

            if (hasUpdatedInstances) //should never happen, just here for sanity
            {
                CoreGlobal.RO.Warn("Instance added to a CompoundTest '" + FullName + "' after the instances were already instantiated.  The new instance won't be used.");
            }
        }

        #endregion //Test Node Instancing

        #endregion //Tree Generation and Searching

        #region Execution

        /// <summary>
        /// Called before Run is called and before child nodes are run.
        /// </summary>
        public virtual void PreRun() //SOON TO BE RENAMED to: Setup()
        {
        }
        /// <summary>
        /// Called before Run is called and before child nodes are run.
        /// You may optionally implement this INSTEAD of the parameterless PreRun.
        /// </summary>
        public virtual void PreRun(RUN_TYPE runType) //SOON TO BE RENAMED to: Setup()
        {
            PreRun();
        }

        /// <summary>
        /// Called after Run has been called and after child nodes have run.
        /// </summary>
        public virtual void PostRun() //SOON TO BE RENAMED to: Cleanup()
        {
        }
        /// <summary>
        /// Called after Run has been called and after child nodes have run.
        /// You may optionally implement this INSTEAD of the parameterless PostRun.
        /// </summary>
        public virtual void PostRun(RUN_TYPE runType) //SOON TO BE RENAMED to: Cleanup()
        {
            PostRun();
        }

        /// <summary>
        /// Similar to and called before Setup, except it is normally only ever called once.
        /// </summary>
        public virtual void OneTimeSetup()
        {
        }
        /// <summary>
        /// Similar to and called before Setup, except it is normally only ever called once.
        /// You may optionally implement this INSTEAD of the parameterless OneTimeSetup.  It may be called once for each type.
        /// </summary>
        public virtual void OneTimeSetup(RUN_TYPE runType)
        {
            if (!isOneTimeSetupPerformed)
            {
                isOneTimeSetupPerformed=true;
                OneTimeSetup();
            }
        }

        /// <summary>
        /// Similar to and called after Cleanup, except it is normally only ever called once.
        /// </summary>
        public virtual void OneTimeCleanup()
        {
        }
        /// <summary>
        /// Similar to and called after Cleanup, except it is normally only ever called once.
        /// You may optionally implement this INSTEAD of the parameterless OneTimeCleanup.  It may be called once for each type.
        /// </summary>
        public virtual void OneTimeCleanup(RUN_TYPE runType)
        {
            if (isOneTimeSetupPerformed)
            {
                isOneTimeSetupPerformed=false;
                OneTimeCleanup();
            }
        }

        /// <summary>
        /// Called to execute the test.
        /// </summary>
        public virtual void Run()
        {
            throw new System.NotImplementedException("Run method must be implemented in the derived class.");
        }
        /// <summary>
        /// Called to execute the test.
        /// You may optionally implement this INSTEAD of the parameterless Run.
        /// </summary>
        public virtual void Run(RUN_TYPE runType)
        {
            Run();
        }

        /// <summary>
        /// Functional:
        /// This is called when a functional run for a suite is started and before Initialize.
        /// </summary>
        virtual public bool Prerequisites(ref Dictionary<string, bool> data)
        {
            return true;
        }

        // --

        //the schedulers should call this to handle perform the OneTimeSetup if needed and also the PreRun.
        //if PreRun is called, PostRun MUST also be.
        public void Scheduler_DoPreRun(RUN_TYPE runType)
        {
            if (isCompoundRoot)
            {
                return;
            }

            int curPreRunCount=System.Threading.Interlocked.Increment(ref preRunCount);
            if (curPreRunCount>1) //someone else has already done
            {
                return;
            }

            if (!oneTimeSetupTypePerformed[(int)runType])
            {
                oneTimeSetupTypePerformed[(int)runType]=true;
                OneTimeSetup(runType);
            }

            PreRun(runType);

            foreach (TestSetupDelegate sd in TestSetupMethods)
            {
                sd();
            }
        }

        //the schedulers should call this to perform PostRun.
        public void Scheduler_DoPostRun(RUN_TYPE runType)
        {
            if (isCompoundRoot)
            {
                return;
            }

            int curPreRunCount=System.Threading.Interlocked.Decrement(ref preRunCount);
            if (curPreRunCount>0) //someone else is still running
            {
                return;
            }

            foreach (TestTearDownDelegate td in TestTearDownMethods)
            {
                td();
            }

            PostRun(runType);
        }

        #endregion //Execution
    }
    #endregion //TestNode - The basic unit of life, the universe, everything

    #region TestNode Wrappers

    /// <summary>
    /// Wrap a method that represents a test case and present it as a TestNode
    /// </summary>
    public class TestNodeFunction: TestNode
    {
        public delegate void TestNodeDelegateVoid();
        public delegate void TestNodeDelegateTestNode(TestNode thisNode);

        //testCase must either be TestNodeDelegateVoid or TestNodeDelegateTestNode
        public TestNodeFunction(object testCase, MemberInfo minfo, string name)
        {
            if (testCase is TestNodeDelegateTestNode)
            {
                testCaseTestNode=(TestNodeDelegateTestNode)testCase;
            }
            else if (testCase is TestNodeDelegateVoid)
            {
                testCaseVoid=(TestNodeDelegateVoid)testCase;
            }
            else
            {
                throw new System.Exception("testCase must either be TestNodeDelegateVoid or TestNodeDelegateTestNode.");
            }

            mi = minfo;
            Name = name;

            LoadAttributes();
        }

        public override void Run()
        {
            if (testCaseTestNode!=null)
            {
                testCaseTestNode(this);
            }
            else
            {
                testCaseVoid();
            }
        }

        public override bool HasAttribute(Type t)
        {
            if (mi==null) //not constructed yet
            {
                return false;
            }

            return mi.GetCustomAttributes(t, false).Length > 0;
        }

        public override object[] GetAttributes(Type t, bool inherited)
        {
            if (mi==null) //not constructed yet
            {
                return new object[0];
            }

            return mi.GetCustomAttributes(t, false);
        }

        private TestNodeDelegateVoid testCaseVoid;
        private TestNodeDelegateTestNode testCaseTestNode;
        private MemberInfo mi;
    }

    #endregion //TestNode Wrappers

    #region AsyncStressTestNode

    /// <summary>
    /// A stress base for doing asynchronous tests.  Derived classes must implement their Begin function
    /// in a thread safe manner, as only one actual object will ever be created.
    /// The Run function allows the async tests to run synchronously if the scheduler does not
    /// have support for async tests.
    /// </summary>
    public abstract class AsyncStressTestNode: TestNode
    {
        /// <summary>
        /// An object that may be useful for debugging and will be used for running synchronously.
        /// </summary>
        public class AsyncStressTracking
        {
            public long ID = 0;
            public ManualResetEvent WaitEvent = null;
            public object ExternalState = null;
            public long StartTime = Timing.QueryPerformanceCounter();

            /// <summary>
            /// The ID value position, each tracker gets its own number until we wrap.
            /// </summary>
            protected static long IDVal = 0;

            public AsyncStressTracking ()
            {
                ID = Interlocked.Increment(ref IDVal);
            }

            public AsyncStressTracking (object state)
            {
                ID = Interlocked.Increment(ref IDVal);
                ExternalState = state;
            }
        }

        #region Sync Functions

        /// <summary>
        /// The maximum time to wait when running synchronously.
        /// </summary>
        public static int MaximumWaitTimeMilliseconds = 110000;

        /// <summary>
        /// The Run function allows the async tests to run synchronously if the scheduler does not
        /// have support for async tests.
        /// </summary>
        /// <returns>The result of running the test.</returns>
        public sealed override void Run()
        {
            AsyncStressTracking tracker = new AsyncStressTracking();
            tracker.WaitEvent = GetWaitEvent();

            Begin(tracker);

            tracker.WaitEvent.WaitOne(MaximumWaitTimeMilliseconds, false);
            ReleaseWaitEvent(tracker.WaitEvent);
        }

        /// <summary>
        /// The queue of ManualResetEvents to be used when running synchronously.
        /// </summary>
        private Queue<ManualResetEvent> WaitEventQ = new Queue<ManualResetEvent>();

        /// <summary>
        /// Gets a ManualResetEvent from the queue, or creates one if it is empty.
        /// </summary>
        /// <returns>A ManualResetEvent.</returns>
        private ManualResetEvent GetWaitEvent ()
        {
            lock (WaitEventQ)
            {
                if (WaitEventQ.Count == 0)
                {
                    return new ManualResetEvent(false);
                }
                else
                {
                    ManualResetEvent mre = WaitEventQ.Dequeue();
                    mre.Reset();
                    return mre;
                }
            }
        }

        /// <summary>
        /// Returns a ManualResetEvent to the queue.
        /// </summary>
        /// <param name="mre">The ManualResetEvent to return.</param>
        private void ReleaseWaitEvent (ManualResetEvent mre)
        {
            if (mre == null)
            {
                return;
            }

            lock (WaitEventQ)
            {
                WaitEventQ.Enqueue(mre);
            }
        }

        #endregion

        #region Async Functions

        /// <summary>
        /// The main entry point for external callers that are aware of AsyncStressTestBase.
        /// </summary>
        /// <param name="state">A state object that will be passed back to the external caller.</param>
        public void Begin (object state)
        {
            Begin(new AsyncStressTracking(state));
        }

        /// <summary>
        /// This is the entry point for the test case.  Remember that it must be thread safe.
        /// All tests should call End to report the result of running the test.
        /// </summary>
        /// <param name="tracker">The state object used to track this test run.</param>
        public abstract void Begin (AsyncStressTracking tracker);

        /// <summary>
        /// The delegate type that is used to notify the scheduler of the async test completing.
        /// </summary>
        /// <param name="state">A state object that will be passed back to the external caller.</param>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception, if any, that occured.</param>
        /// <param name="startTime">The time the test was started (from QueryPerformanceCounter).</param>
        public delegate void AsyncCompletion (object state, Exception exc, long startTime);

        /// <summary>
        /// The function that will be called by the test to report its result.
        /// The scheduler should set this value on startup to receive callbacks.
        /// </summary>
        public static AsyncCompletion AsyncFinish = null;

        /// <summary>
        /// Reports the test result given to it.
        /// </summary>
        /// <param name="result">The result of running the test.</param>
        /// <param name="tracker">The state object used to track this test run.</param>
        public void End (AsyncStressTracking tracker)
        {
            End(null, tracker);
        }

        /// <summary>
        /// Reports the test result and updates the tracker.
        /// </summary>
        /// <param name="result">The result of running the test.</param>
        /// <param name="exc">The exception that occured.</param>
        /// <param name="tracker">The state object used to track this test run.</param>
        public void End (Exception exc, AsyncStressTracking tracker)
        {
            if (tracker.WaitEvent != null)
            {
                if (!(tracker.WaitEvent.Set()))
                {
                    CoreGlobal.RO.Error("Could not set the event wait handle for run {0}, that thread will probably be permanently locked.");
                }

                // this means we are in sync mode, so no need to call back to AsyncFinish
                return;
            }

            if (AsyncFinish == null)
            {
                CoreGlobal.RO.Error("No AsyncFinish function is defined, AsynStressTests will not be correctly " +
                    "reporting results.");
            }
            else
            {
                AsyncFinish(tracker.ExternalState, exc, tracker.StartTime);
            }
        }

        #endregion
    }

    #endregion //AsyncStressTestNode

    #region Functional-Specific Data
    /// <summary>
    /// Data about a node that is specific to functional tests.
    /// Note that if A node has functional data, its parent is guarenteed to also.
    /// </summary>
    public class FunctionalNodeData
    {
        //public properties
        public TestNode Owner;
        public bool Ignored = false;
        public int ChildrenAsyncGroupDefault=-1; //default AsyncGroup for children that don't specify
        public bool ApplyChildrenAsyncGroupToAllDescendents = false; // causes ChildrenAsyncGroupDefault to apply deeper than one level
        public int DirectAsyncGroup=-1; //my direct value, not my derived value
        public Runner.FunctionalSchedulerNodeData SchedulerData; //If we ever add a second functional scheduler, this will become an object.
        public uint ChildrenMaxParallelThreads = 64;
        public uint ChildrenParallelThreadDelay = 10; //in ms
        public int BugID = 0;
        public string BugDatabase = null;
        public int Timeout = System.Threading.Timeout.Infinite; 
        public Type ExpectedException = null;
        public bool AllowRetries = true;
        public List<string> Dependencies=new List<string>();
        public bool AtomicGroup; //applicable to group nodes only - whether all children must be enabled/disabled together

        //data only touchable through accessors
        private bool enabled = false;

        //accessors
        public bool IsInAtomicGroup
        {
            get
            {
                if (Owner.Parent!=null)
                {
                    if (Owner.Parent.FunctionalData.AtomicGroup)
                    {
                        return true;
                    }
                    return Owner.Parent.FunctionalData.IsInAtomicGroup;
                }
                return false;
            }
        }

        public bool Enabled
        {
            get { return enabled; }
            set
            {
                enabled=value;

                //if I'm inside an atomic group, changing me changes my whole atomic group
                if (IsInAtomicGroup)
                {
                    //work up the tree changing anything not in our branch
                    TestNode ignoreNode=Owner; //the branch we exist in we ignore
                    TestNode containingNode=Owner.Parent;
                    while (containingNode!=null && ignoreNode.FunctionalData.IsInAtomicGroup)
                    {
                        foreach (TestNode sibling in containingNode.Children)
                        {
                            if (sibling.FunctionalData!=null && sibling.FunctionalData.Enabled!=value && sibling!=ignoreNode)
                            {
                                sibling.FunctionalData.Enabled=value;
                            }
                        }

                        ignoreNode=containingNode;
                        containingNode=containingNode.Parent;
                    }
                }

                //set all children too
                foreach (TestNode child in Owner.Children)
                {
                    if (child.FunctionalData!=null)
                    {
                        child.FunctionalData.Enabled=value;
                    }
                }

                //if enabling, then enable parent's exact node up the tree
                if (value && Owner.Parent!=null && !Owner.Parent.FunctionalData.enabled)
                {
                    TestNode parentNode=Owner.Parent;
                    while (parentNode!=null)
                    {
                        parentNode.FunctionalData.enabled=true;
                        parentNode=parentNode.Parent;
                    }
                }

                //If me or my parents have nothing enabled, disable them
                if (!value)
                {
                    TestNode parentNode=Owner.Parent;
                    while (parentNode!=null && parentNode.ChildrenCount>0)
                    {
                        bool hasEnabledChild=false;
                        foreach (TestNode child in parentNode.Children)
                        {
                            if (child.FunctionalData!=null && child.FunctionalData.Enabled)
                            {
                                hasEnabledChild=true;
                                break;
                            }
                        }
                        if (!hasEnabledChild)
                        {
                            parentNode.FunctionalData.enabled=false;
                        }
                        else
                        {
                            break;
                        }
                        parentNode=parentNode.Parent;
                    }
                }
            }
        }

        public int AsyncGroup
        {
            get
            {
                //my value takes precedence, else we use our parent's default for us
                if (DirectAsyncGroup>=0)
                {
                    return DirectAsyncGroup;
                }
                else if (Owner.Parent!=null && Owner.Parent.FunctionalData.ChildrenAsyncGroupDefault>0)
                {
                    return Owner.Parent.FunctionalData.ChildrenAsyncGroupDefault;
                }
                else if (Owner.Parent != null)
                {
                    TestNode ancestor = Owner.Parent.Parent;

                    while (ancestor != null)
                    {
                        if (ancestor.FunctionalData.ApplyChildrenAsyncGroupToAllDescendents &&
                            ancestor.FunctionalData.ChildrenAsyncGroupDefault > 0)
                        {
                            return ancestor.FunctionalData.ChildrenAsyncGroupDefault;
                        }

                        ancestor = ancestor.Parent;
                    }
                }

                return 0;
            }
            set
            {
                DirectAsyncGroup=value;
            }
        }

        public FunctionalNodeData(TestNode owner)
        {
            Owner=owner;

            //pull initial settings from attributes
            object []attr=owner.GetAttributes(typeof(TestCaseAttribute));
            if (attr.Length>0)
            {
                TestCaseAttribute tca=(TestCaseAttribute)attr[0];
                //BugID=tca.BugID;
                //BugDatabase=tca.BugDatabase;
                ExpectedException=tca.ExpectedException;
                Timeout = (tca.Timeout >= 0 ? tca.Timeout : System.Threading.Timeout.Infinite);
            }

            GetBugInfo(owner);

            if (Timeout == System.Threading.Timeout.Infinite)
            {
                Timeout = (int)TimeSpan.FromMinutes(30).TotalMilliseconds;       // 30mins
            }
            else if(Timeout == 0)
            {
                Timeout = System.Threading.Timeout.Infinite;
            }

            Ignored=owner.HasAttribute(typeof(IgnoreAttribute));

            AtomicGroup=owner.HasAttribute(typeof(AtomicBranchAttribute));

            AllowRetries=!owner.HasAttribute(typeof(DoNotRetryAttribute));

            attr=owner.GetAttributes(typeof(AsyncGroupAttribute));
            if (attr.Length>0)
            {
                AsyncGroupAttribute aga=(AsyncGroupAttribute)attr[0];
                DirectAsyncGroup=aga.AsyncGroup;
                ChildrenAsyncGroupDefault=aga.ChildrenAsyncGroup;
                ApplyChildrenAsyncGroupToAllDescendents = aga.ApplyToAllDescendents;
            }

            attr=owner.GetAttributes(typeof(AsyncThreadCountAttribute));
            if (attr.Length>0)
            {
                AsyncThreadCountAttribute atca=(AsyncThreadCountAttribute)attr[0];
                ChildrenMaxParallelThreads=atca.ThreadCount;
            }

            attr=owner.GetAttributes(typeof(AsyncThreadDelayAttribute));
            if (attr.Length>0)
            {
                AsyncThreadDelayAttribute atca=(AsyncThreadDelayAttribute)attr[0];
                ChildrenParallelThreadDelay=atca.ThreadDelay;
            }

            attr=owner.GetAttributes(typeof(RunDependencyAttribute));
            for (int i=0; i<attr.Length; ++i)
            {
                RunDependencyAttribute rda=(RunDependencyAttribute)attr[i];
                Dependencies.Add(rda.Dependency);
            }
        }

        public FunctionalNodeData Clone(TestNode owner)
        {
            FunctionalNodeData newData=(FunctionalNodeData)this.MemberwiseClone();
            newData.Owner=owner;

            return newData;
        }

        public void GetBugInfo(TestNode node)
        {
            TestNode currNode = node;

            while (currNode != null)
            {
                // Check the TestCase attribute
                TestCaseAttribute testCaseAttribute = currNode.GetAttribute<TestCaseAttribute>();
                if (testCaseAttribute != null)
                {
                    BugID = testCaseAttribute.BugID;
                    BugDatabase = testCaseAttribute.BugDatabase;

                    // If this Bug ID has been set break out of the look
                    if (BugID != 0)
                    {
                        break;
                    }
                }

                /*
                TestGroupAttribute testGroupAttribute = currNode.GetAttribute<TestGroupAttribute>();
                if (testGroupAttribute != null)
                {
                    BugID = testGroupAttribute.BugID;
                    BugDatabase = testGroupAttribute.BugDatabase;

                    if (BugID != 0)
                    {
                        break;
                    }
                }
                 */

                currNode = currNode.Parent;
            }
        }
    }
    #endregion //Functional-Specific Data

    #region Stress-Specific Data
    /// <summary>
    /// Data about a node that is specific to stress tests.
    /// </summary>
    public class StressNodeData
    {
        public TestNode Owner;
        public bool  AlwaysInstantiate = false;
        public float Priority  = 0;
        public float TargetTPS = 0;

        public struct ValidationData
        {
            public float MinTotalTPS;
            public float MinRunningTPS;
            public int MaxFailed;
            public int MinPassed;

            public ValidationData(XmlNode jobNode)
            {
                MinTotalTPS = XmlUtil.GetAttributeValue(jobNode, "MinTotalTPS", 0.0f);
                MinRunningTPS = XmlUtil.GetAttributeValue(jobNode, "MinRunningTPS", 0.0f);
                MaxFailed = XmlUtil.GetAttributeValue(jobNode, "MaxFailed", Int32.MaxValue);
                MinPassed = XmlUtil.GetAttributeValue(jobNode, "MinPassed", 0);
            }
        };

        public ValidationData Validation;

        public enum StressRunStatus
        {
            NotStarted,
            PreRunInProgress,
            PreRunFailed,
            Runnable
        };

        public volatile StressRunStatus RunStatus=StressRunStatus.NotStarted;

        public object RunStatusLock=new object();

        //
        public StressNodeData(TestNode owner)
        {
            Owner=owner;

            //from StressTest
            object []attr=owner.GetAttributes(typeof(StressTestAttribute));
            if (attr.Length>0)
            {
                StressTestAttribute sta=(StressTestAttribute)attr[0];
                TargetTPS=sta.TargetTPS;
                Priority=sta.Priority;
            }

            Validation.MinTotalTPS = 0;
            Validation.MinRunningTPS = 0;
            Validation.MaxFailed = Int32.MaxValue;
            Validation.MinPassed = 0;

            //
            AlwaysInstantiate=owner.HasAttribute(typeof(StressInstantiateAttribute));
        }

        public StressNodeData Clone(TestNode owner)
        {
            StressNodeData newData=(StressNodeData)this.MemberwiseClone();
            newData.Owner=owner;

            return newData;
        }
    }
    #endregion //Stress-Specific Data

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\StressSchedulerPriControl.Designer.cs ===
﻿namespace ServerTestFramework.Runner
{
    partial class StressSchedulerPriControl
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose (bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent ()
        {
            System.Windows.Forms.Label label1;
            System.Windows.Forms.Label label2;
            System.Windows.Forms.Label label3;
            this.lblCurrentThreads = new System.Windows.Forms.Label();
            this.nudMaxThreads = new System.Windows.Forms.NumericUpDown();
            label1 = new System.Windows.Forms.Label();
            label2 = new System.Windows.Forms.Label();
            label3 = new System.Windows.Forms.Label();
            ((System.ComponentModel.ISupportInitialize) (this.nudMaxThreads)).BeginInit();
            this.SuspendLayout();
            // 
            // label1
            // 
            label1.AutoSize = true;
            label1.Location = new System.Drawing.Point(3, 0);
            label1.Name = "label1";
            label1.Size = new System.Drawing.Size(82, 13);
            label1.TabIndex = 0;
            label1.Text = "Current threads:";
            // 
            // label2
            // 
            label2.AutoSize = true;
            label2.Location = new System.Drawing.Point(17, 22);
            label2.Name = "label2";
            label2.Size = new System.Drawing.Size(68, 13);
            label2.TabIndex = 2;
            label2.Text = "Max threads:";
            // 
            // label3
            // 
            label3.Anchor = ((System.Windows.Forms.AnchorStyles) ((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)
                        | System.Windows.Forms.AnchorStyles.Left)
                        | System.Windows.Forms.AnchorStyles.Right)));
            label3.Location = new System.Drawing.Point(3, 58);
            label3.Name = "label3";
            label3.Size = new System.Drawing.Size(148, 56);
            label3.TabIndex = 4;
            label3.Text = "Throttling was not ported, please use the TPS scheduler for this functionality.";
            // 
            // lblCurrentThreads
            // 
            this.lblCurrentThreads.AutoSize = true;
            this.lblCurrentThreads.Location = new System.Drawing.Point(91, 0);
            this.lblCurrentThreads.Name = "lblCurrentThreads";
            this.lblCurrentThreads.Size = new System.Drawing.Size(10, 13);
            this.lblCurrentThreads.TabIndex = 1;
            this.lblCurrentThreads.Text = "-";
            // 
            // nudMaxThreads
            // 
            this.nudMaxThreads.Location = new System.Drawing.Point(91, 20);
            this.nudMaxThreads.Maximum = new decimal(new int[] {
            600,
            0,
            0,
            0});
            this.nudMaxThreads.Name = "nudMaxThreads";
            this.nudMaxThreads.Size = new System.Drawing.Size(57, 20);
            this.nudMaxThreads.TabIndex = 3;
            this.nudMaxThreads.ValueChanged += new System.EventHandler(this.nupMaxThreads_ValueChanged);
            // 
            // StressSchedulerPriControl
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.AutoScroll = true;
            this.AutoScrollMinSize = new System.Drawing.Size(154, 114);
            this.Controls.Add(label3);
            this.Controls.Add(this.nudMaxThreads);
            this.Controls.Add(label2);
            this.Controls.Add(this.lblCurrentThreads);
            this.Controls.Add(label1);
            this.Name = "StressSchedulerPriControl";
            this.Size = new System.Drawing.Size(154, 114);
            ((System.ComponentModel.ISupportInitialize) (this.nudMaxThreads)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblCurrentThreads;
        private System.Windows.Forms.NumericUpDown nudMaxThreads;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\TestScheduler.cs ===
using System;
using System.Windows.Forms;
using System.Xml;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Functional test schedular interface.
    /// </summary>
    public interface TestScheduler
    {
        /// <summary>
        /// Called to set up the scheduler.
        /// </summary>
        void Initialize(FunctionalSchedulerSettings schedSettings, TestEventListener listener, System.Collections.Generic.IEnumerable<TestNode> rootNodes);

        /// <summary>
        /// This call will block and run tests and block until either someone calls Stop or the tests finish.
        /// </summary>
        void Run();

        /// <summary>
        /// Stop running tests.
        /// </summary>
        void Stop();

        /// <summary>
        /// Validates that the current scheduler settings are valid.
        /// </summary>
        /// <returns>true if they are valid</returns>
        bool ValidateParameters();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Runner\TestEventListener.cs ===
using System;
using System.Collections;
using ServerTestFramework;

namespace ServerTestFramework.Runner
{
    /// <summary>
    /// Specific types of events that occur inside of the test scheduler.
    /// </summary>
    public enum TestAction
    {
        PreStart,   /// Test case started pre-run.
        Start,      /// Test case started running the actual test.
        PostStart,  /// Test case started post-run.
        Pause,      /// Test run paused on a node.
        Resume,     /// Test run resumed on a node.
        Pass,       /// Test returned a passed result.
        Fail,       /// Test case returned a failed result.
        Timeout,    /// Test case timed out.
        PreFail,    /// Prerun setup steps for the test failed.
        PostFail,   /// Postrun cleanup steps for the test failed.
        Retry,      /// A test case that previously failed is now being re-run.
        Ignore,     /// Test case was not completely executed (or returned not executed).
        Finish,     /// Test case completely finished.

        StartAll,   /// Tests begin running. Details will contain a count of running tests.  Node will be null for this.
        StopAll     /// Tests all fininished. Details will contain a count of all ran tests.  Node will be null for this.
    };

    /// <summary>
    /// Event arguments notifying listeners of a test result.
    /// </summary>
    [Serializable]
    public class TestEventArgs
    {
        public TestNode Node;
        public string Details;
        public TestAction Action;
        public string Message;
        public string Stack;
        public Exception Exception;
        public int BugID;
        public string BugDatabase;

        public TestEventArgs (TestNode node, string details, TestAction action)
            : this(node, details, null, action) { }

        public TestEventArgs (TestNode node, string details, System.Exception exception, TestAction action)
            : this(node, details, exception, action, 0, null) { }

        public TestEventArgs (TestNode node, string details, System.Exception exception, TestAction action, int bugID, string bugDatabase)
        {
            Node = node;
            Details = details;
            Action = action;
            if (exception != null)
            {
                Message = exception.Message;
                Stack = exception.StackTrace;
            }
            Exception = exception;
            BugID = bugID;
            BugDatabase = bugDatabase;
        }
    }

    /// <summary>
    /// This interface should be implemented by any class that would be notified by a functional test scheduler of events
    /// as it is running tests.
    /// </summary>
    public interface TestEventListener
    {
        void OnTestEvent(TestEventArgs eventArgs);
    }

    /// <summary>
    /// Allows test events to be distributed to multiple destinations.
    /// </summary>
    public class MultiTestEventListener: TestEventListener
    {
        private ArrayList _listeners = new ArrayList();

        public virtual void OnTestEvent(TestEventArgs eventArgs)
        {
            foreach (TestEventListener listener in _listeners)
            {
                listener.OnTestEvent(eventArgs);
            }
        }

        public void Add(TestEventListener listener)
        {
            _listeners.Add(listener);
        }

        public void Remove(TestEventListener listener)
        {
            _listeners.Remove(listener);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\test\StfTests\ServerTestFramework\STFCore\Utilities\ArrayEx.cs ===
using System;
using System.Text;
using System.Collections.Generic;

namespace ServerTestFramework
{
	public class ArrayEx
	{
        public static bool Compare(Array a, Array b)
        {
            if (a == null && b == null)
            {
                return true;
            }

            if (a == null || b == null)
            {
                return false;
            }

            if (a.Length != b.Length)
            {
                return false;
            }

            for (int i = 0; i < a.Length; ++i)
            {
                if (!a.GetValue(i).Equals(b.GetValue(i)))
                    return false;
            }

            return true;
        }

        /// <summary>
        /// Check i two arrays of the same type are equal.  Much faster than the non-generic version
        /// </summary>
        /// <typeparam name="T">The type of array to compare</typeparam>
        /// <param name="a">The first array to compare</param>
        /// <param name="b">The second array to compare</param>
        /// <returns>True if the arrays are equal, false otherwise</returns>
        public static bool Equals<T>(T[] a, T[] b)
        {
            if (a == null && b == null)
            {
                return true;
            }

            if (a == null || b == null)
            {
                return false;
            }

            if (a.Length != b.Length)
            {
                return false;
            }

            for (int i = 0; i < a.Length; ++i)
            {
                if (!a[i].Equals(b[i]))
                {
                    return false;
                }
            }

            return true;
        }

		public static string ToString( Array a )
		{
			StringBuilder sb = new StringBuilder( "{" );
			for( int i = 0; i < a.Length; ++i )
			{
				sb.Append( a.GetValue( i ) );
				if( i+1 != a.Length )
					sb.Append( "," );
			}
			sb.Append( "}" );
			return( sb.ToString() );
		}

		public static bool SubArrayCompare(Array a, long astart, long aend, Array b, long bstart, long bend)
		{
			int adir = aend > astart ? 1 : -1;
			int bdir = bend > bstart ? 1 : -1;
			long alen = (aend > astart ? aend - astart : astart - aend);
			long blen = (bend > bstart ? bend - bstart : bstart - bend);
			
			if(aend < 0 || bend < 0 || astart < 0 || bstart < 0 ||
				aend > a.LongLength || bend > b.LongLength || astart > a.LongLength || bstart > b.LongLength)
			{
				throw new ArgumentOutOfRangeException("One of the parameters passed is out of range for the array.");
			}

			if(alen != blen)
			{
				//throw new ArgumentException("The lengths to compare for the two arrays don't match. A.length(" + alen + ") != B.length(" + blen + ")");
				return false;
			}

			for(long l = 0; l < alen; l++)
			{
				if(!a.GetValue(astart + l * adir