(vertexnum+1,vertexnum+3,vertexnum+2,++face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  AddFace(vertexnum+2,vertexnum+3,vertexnum,++face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  if (indir.inaxis)
  { pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,r1,W,indir);
	pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,r2,W,indir);
	pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,r3,W,indir);
	pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,r4,W,indir);
  }
  else
  {
  tmp=(*pt)+r1;
  AVertex[0]=tmp.x;AVertex[1]=tmp.y;AVertex[2]=tmp.z;
  RotateOnePoint(AVertex,&pt->x,&W.x,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  tmp=(*pt)+r2;
  AVertex[0]=tmp.x;AVertex[1]=tmp.y;AVertex[2]=tmp.z;
  RotateOnePoint(AVertex,&pt->x,&W.x,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  tmp=(*pt)+r3;
  AVertex[0]=tmp.x;AVertex[1]=tmp.y;AVertex[2]=tmp.z;
  RotateOnePoint(AVertex,&pt->x,&W.x,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  tmp=(*pt)+r4;
  AVertex[0]=tmp.x;AVertex[1]=tmp.y;AVertex[2]=tmp.z;
  RotateOnePoint(AVertex,&pt->x,&W.x,Angle);
  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
  }
}
							 
void PlotTriangle(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir)
{float radius_33,radius_5;
 Matrix3By4 VertexPts;

  radius_33=radius*0.33f;
  radius_5=0.5f*radius;
  AddFace(vertexnum,vertexnum+1,vertexnum+2,face,pm,curmtl);
  pm->faces[face].setEdgeVisFlags(1,1,1);
  if (indir.inaxis)
  {pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(radius_5,-radius_33,0.0f),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f,2*radius_33,0.0f),W,indir);
   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(-radius_5,-radius_33,0.0f),W,indir);
  }
  else
  {
  VertexPts[0][0]=pt->x+radius_5;
  VertexPts[1][0]=pt->x;
  VertexPts[2][0]=pt->x-radius_5;
  VertexPts[1][1]=pt->y+2*radius_33;
  VertexPts[0][1]=VertexPts[2][1]=pt->y-radius_33;
  VertexPts[0][2]=VertexPts[1][2]=VertexPts[2][2]=pt->z;
  VertexPts[0][3]=VertexPts[1][3]=VertexPts[2][3]=1.0f;
  RotatePoint(VertexPts,&pt->x,W,Angle);
  pm->verts[vertexnum++]=Point3(VertexPts[0][0],VertexPts[0][1],VertexPts[0][2]);
  pm->verts[vertexnum++]=Point3(VertexPts[1][0],VertexPts[1][1],VertexPts[1][2]);
  pm->verts[vertexnum++]=Point3(VertexPts[2][0],VertexPts[2][1],VertexPts[2][2]);
  }
}
void GetMeshInfo(int type,int count,Mesh *pm,int *numF,int *numV)
{	if (type==RENDTYPE1) 
	{   pm->setNumFaces(count);
		pm->setNumVerts(count*3);
		pm->setNumTVerts(count);
		pm->setNumTVFaces(count);
		*numV=3;*numF=1;
	}
	else if (type==RENDTYPE2)
	{	pm->setNumFaces(count*12);
		pm->setNumVerts(count*8);
		pm->setNumTVerts(count);
		pm->setNumTVFaces(count*12);
		*numV=8;*numF=12;
	}
	else if (type==RENDTYPE3)
	{	pm->setNumFaces(count*6);
		pm->setNumVerts(count*12);
		pm->setNumTVerts(count);
		pm->setNumTVFaces(count*6);
		*numV=12;*numF=6;
	}
	else if (type==RENDTYPE5)
	{	pm->setNumFaces(count*2);
		pm->setNumVerts(count*4);
		pm->setNumTVerts(count);
		pm->setNumTVFaces(count*2);
		*numV=4;*numF=2;
	}
	else if (type==RENDTYPE6)
	{	pm->setNumFaces(count*10);
		pm->setNumVerts(count*11);
		pm->setNumTVerts(count);
		pm->setNumTVFaces(count*10);
		*numV=11;*numF=10;
	}
	else if (type==RENDTET)
	{ pm->setNumFaces(count*4);
	  pm->setNumVerts(count*4);
	  pm->setNumTVerts(2);
	  pm->setNumTVFaces(count*4);
	  pm->tVerts[0]=Point3(0.0f,0.5f,0.0f);
	  pm->tVerts[1]=Point3(1.0f,0.5f,0.0f);
      *numV=4;*numF=4;
	}
	else if (type==REND6PT)
	{ pm->setNumFaces(count*2);
	  pm->setNumVerts(count*6);
	  pm->setNumTVerts(count);
	  pm->setNumTVFaces(count*2);
      *numV=6;*numF=2;
	}
	else if (type==RENDSPHERE)
	{ int segs=10,rows=(segs/2-1);
	  int nverts = rows * segs + 2;
	  int tnf,nfaces = rows * segs * 2;
	  pm->setNumVerts(count*nverts);
	  pm->setNumFaces(tnf=count*nfaces);
	  pm->setNumTVerts(count);
	  pm->setNumTVFaces(tnf);
      *numV=nverts;*numF=nfaces;
	}
}
void PlotFacing(int type,float radius,int vertexnum,int face,Mesh *pm,float Angle,int curmtl,Point3* pt,Point3 camV,Point3 a,Point3 b)
{ 	Point3 v, v0,v1;
	if (RENDTYPE5==type)
	{  v  = Normalize(camV-(*pt));
	   v0 = Normalize(Point3(0,0,1)^v) * radius;
	   v1 = Normalize(v0^v) * radius;}
	else
	{ float R=Length((*pt)-camV);
	  v0=radius*R*a;
	  v1=radius*R*b;
    }
   pm->verts[vertexnum] = ((*pt)+v0+v1);
   pm->verts[vertexnum+1] = ((*pt)-v0+v1);
   pm->verts[vertexnum+2] = ((*pt)-v0-v1);
   pm->verts[vertexnum+3] = ((*pt)+v0-v1);
   if (type==RENDTYPE5)
   { for (int l=0;l<4;l++)
       RotateOnePoint(pm->verts[vertexnum+l],&pt->x,&v.x,Angle);
     AddFace(vertexnum+3,vertexnum+2,vertexnum+1,face,pm,curmtl);
     AddFace(vertexnum+1,vertexnum,vertexnum+3,face+1,pm,curmtl);
   }
   else
   {AddFace(vertexnum,vertexnum+1,vertexnum+2,face,pm,curmtl);
    AddFace(vertexnum+2,vertexnum+3,vertexnum,face+1,pm,curmtl);
   }
}

void PlotCustom(float radius,int i,int vertexnum,Mesh *pm, float Angle,float *W,Mesh *clst,Point3* pt,int nv,InDirInfo indir)
{ Point3 nextpt,pt1;

  for (int j=0;j<nv;j++)
  if (indir.inaxis)
  {pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,radius*clst->verts[j],W,indir);
  }
  else
  { nextpt=(radius*clst->verts[j])+(*pt);
    RotateOnePoint(&nextpt.x,&pt->x,W,Angle);
    pm->verts[vertexnum++]=nextpt;
  }
}

void PlotSphere(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir)
{	int segs=10;
radius*=0.5f;
	float delta,delta2,alt;float AVertex[3];

	delta  = 2.0f*PI/(float)segs;
	delta2 = delta;
	int rows=(segs/2-1);
	int nverts = rows * segs + 2;
	float startAng = HALFPI;
	int nc,jx,ix;
	// Make top conic cap
	for(ix=1; ix<=segs; ++ix)
	{	nc=(ix==segs)?1:ix+1;
		AddFace(vertexnum,vertexnum+ix,vertexnum+nc,face,pm,curmtl);
		pm->faces[face].setSmGroup(1);
		face++;
	}
	/* Make midsection */
	int na,nb,nd;
	for(ix=1; ix<rows; ++ix)
	{	jx=(ix-1)*segs+1;
		for(int kx=0; kx<segs; ++kx) 
		{	na = jx+kx;
			nb = na+segs;
			nc = (kx==(segs-1))? jx+segs: nb+1;
			nd = (kx==(segs-1))? jx : na+1;	
			AddFace(vertexnum+na,vertexnum+nb,vertexnum+nc,face,pm,curmtl);
			pm->faces[face].setSmGroup(1);
			face++;
			AddFace(vertexnum+na,vertexnum+nc,vertexnum+nd,face,pm,curmtl);
			pm->faces[face].setSmGroup(1);
			face++;
		}
	}
	// Make bottom conic cap
	na = nverts-1;
	jx = (rows-1)*segs+1;
	for(ix=0; ix<segs; ++ix)
	{	nc = ix + jx;
		nb = (ix==segs-1)?jx:nc+1;
		AddFace(vertexnum+na, vertexnum+nb, vertexnum+nc,face,pm,curmtl);
		pm->faces[face].setSmGroup(1);
		face++;
	} face--;

	// Top vertex 
	 if (indir.inaxis)
	   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f, 0.0f,radius),W,indir);
	 else
	 { AVertex[0]=pt->x;AVertex[1]=pt->y;AVertex[2]=pt->z+radius;
       RotateOnePoint(AVertex,&pt->x,W,Angle);
       pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
	 }
	// Middle vertices 
	alt=delta;
	float a,b,c,secrad,secang;
	for(ix=1; ix<=rows; ix++) {		
		a = (float)cos(alt)*radius;		
		secrad = (float)sin(alt)*radius;
		secang = startAng; //0.0f
		for(int jx=0; jx<segs; ++jx) {
			b = (float)cos(secang)*secrad;
			c = (float)sin(secang)*secrad;
			if (indir.inaxis)
			  pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(b,c,a),W,indir);
			else
			{ AVertex[0]=pt->x+b;AVertex[1]=pt->y+c;AVertex[2]=pt->z+a;
			  RotateOnePoint(AVertex,&pt->x,W,Angle);
			  pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
			}
			secang+=delta2;
			}		
		alt+=delta;		
		}
	/* Bottom vertex */
	 if (indir.inaxis)
	   pm->verts[vertexnum++]=RotateAboutAxis(Angle,*pt,Point3(0.0f, 0.0f,-radius),W,indir);
	 else
	 { AVertex[0]=pt->x;AVertex[1]=pt->y;AVertex[2]=pt->z-radius;
       RotateOnePoint(AVertex,&pt->x,W,Angle);
       pm->verts[vertexnum++]=Point3(AVertex[0],AVertex[1],AVertex[2]);
	 }
}
void CacheData(ParticleSys *p0,ParticleSys *p1)
{ p1->SetCount(p0->points.Count(),PARTICLE_VELS|PARTICLE_AGES|PARTICLE_RADIUS|PARTICLE_TENSION);
  if (p0->points.Count()>0)
  {	for (int pc=0;pc<p0->points.Count();pc++)
		p1->points[pc]=p0->points[pc];
	for (pc=0;pc<p0->points.Count();pc++)
		p1->vels[pc]=p0->vels[pc];
    p1->ages.SetCount(p0->ages.Count());
	for (pc=0;pc<p0->ages.Count();pc++)
		p1->ages[pc]=p0->ages[pc];
    p1->radius.SetCount(p0->radius.Count());
	for (pc=0;pc<p0->radius.Count();pc++)
		p1->radius[pc]=p0->radius[pc];
    p1->tension.SetCount(p0->tension.Count());
	for (pc=0;pc<p0->tension.Count();pc++)
		p1->tension[pc]=p0->tension[pc];
  }
}
int TimeFound(TimeLst times,int showframe,int gen)
{ int found=0,n=0,tnums=0;
  if (times.tl.Count()>0) 
  { tnums=times.tl.Count();
    while ((n<tnums)&&(!found))
    { found=((gen==times.tl[n].gennum)&&(showframe==times.tl[n].tl));
	  n++;
	}
	n--;
  } else {found=1;n=0;}
  return (found?n:NoAni);
}

TimeValue GetCurTime(TimeValue showframe,TimeValue ages,int anifr)
{ TimeValue tframe=showframe+ages;
//  if ((tframe>=anifr)&&(anifr!=0)) tframe=tframe % anifr;
  return tframe;
}

void VectorVar(Point3 *vel,float R,float MaxAngle)
{ Point3 X=Point3(RND11(),RND11(),RND11());
  Point3 c=Normalize(X^*vel);
  float Theta=MaxAngle*R*RND01();
  Point3 zero=Zero;
  RotateOnePoint(&(*vel).x,&zero.x,&c.x,Theta);
}

Point3 DoSpawnVars(SpawnVars spvars,Point3 pv,Point3 holdv,float *radius,Point3 *sW)
{ Point3 vels=holdv;
  if (!FloatEQ0(spvars.dirchaos))
    VectorVar(&vels,spvars.dirchaos,PI);
  float dovar=(spvars.spsign==0?-RND01():(spvars.spsign==1?RND01():RND11()));
  if (spvars.spconst) dovar=(dovar>0.0f?1.0f:-1.0f);
  float tmp=(1+dovar*spvars.spchaos);
  vels*=(tmp<0.0f?0.0f:tmp);
  dovar=(spvars.scsign==0?-RND01():(spvars.scsign==1?RND01():RND11()));
  if (spvars.scconst) dovar=(dovar>0.0f?1.0f:-1.0f);
  tmp=(1.0f+dovar*spvars.scchaos);
  (*radius)*=(tmp<0.0f?0.0f:tmp);
  if (spvars.invel) vels+=pv;
  if (spvars.axisentered==2)
  {	*sW=Normalize(spvars.Axis);
	if (spvars.axisvar>0.0f)
		VectorVar(sW,spvars.axisvar,PI);
  }
  else *sW=Normalize(Point3(RND11(),RND11(),RND11()));
  return vels;
} 

float Smallest(Point3 pmin) {return (pmin.x<pmin.y?(pmin.z<pmin.x?pmin.z:pmin.x):(pmin.z<pmin.y?pmin.z:pmin.y));}
float Largest(Point3 pmax) {return (pmax.x>pmax.y?(pmax.z>pmax.x?pmax.z:pmax.x):(pmax.z>pmax.y?pmax.z:pmax.y));}

TriObject *TriIsUseable(Object *pobj,TimeValue t)
{ 
  	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  return NULL;
}
void SpinStuff(HWND hWnd,BOOL ison,BOOL isphase)
{ if (ison)
 {SpinnerOn(hWnd,IDC_SP_SPINAXISXSPIN,IDC_SP_SPINAXISX);
  SpinnerOn(hWnd,IDC_SP_SPINAXISYSPIN,IDC_SP_SPINAXISY);
  SpinnerOn(hWnd,IDC_SP_SPINAXISZSPIN,IDC_SP_SPINAXISZ);
  SpinnerOn(hWnd,IDC_SP_SPINAXISVARSPIN,IDC_SP_SPINAXISVAR);
 } else
 { SpinnerOff(hWnd,IDC_SP_SPINAXISXSPIN,IDC_SP_SPINAXISX);
   SpinnerOff(hWnd,IDC_SP_SPINAXISYSPIN,IDC_SP_SPINAXISY);
   SpinnerOff(hWnd,IDC_SP_SPINAXISZSPIN,IDC_SP_SPINAXISZ);
   SpinnerOff(hWnd,IDC_SP_SPINAXISVARSPIN,IDC_SP_SPINAXISVAR);
 }
 if (isphase)
 { SpinnerOn(hWnd,IDC_SP_SPINPHASPIN,IDC_SP_SPINPHA);
   SpinnerOn(hWnd,IDC_SP_SPINPHAVARSPIN,IDC_SP_SPINPHAVAR);
 }
 else
 { SpinnerOff(hWnd,IDC_SP_SPINPHASPIN,IDC_SP_SPINPHA);
   SpinnerOff(hWnd,IDC_SP_SPINPHAVARSPIN,IDC_SP_SPINPHAVAR);
 }
}
void SpinMainStuff(HWND hWnd,BOOL ison)
{if (ison)
 { SpinnerOn(hWnd,IDC_SP_SPINSPIN,IDC_SP_SPIN);
   SpinnerOn(hWnd,IDC_SP_SPINVARSPIN,IDC_SP_SPINVAR);
 } else
 { SpinnerOff(hWnd,IDC_SP_SPINSPIN,IDC_SP_SPIN);
   SpinnerOff(hWnd,IDC_SP_SPINVARSPIN,IDC_SP_SPINVAR);
 }
 EnableWindow(GetDlgItem(hWnd,IDC_AP_PARTICLEDIRRND),ison);
 EnableWindow(GetDlgItem(hWnd,IDC_AP_PARTICLEDIRUSER),ison);
}

void StdStuff(HWND hWnd,BOOL ison)
{ EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPETRI),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPECUB),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPESPC),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPEFAC),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPEPIX),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPE6PNT),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPETET),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_TYPESPHERE),ison);
}

void MetaOff(HWND hWnd)
{ SpinnerOff(hWnd,IDC_SP_METTENSSPIN,IDC_SP_METTENS);
  SpinnerOff(hWnd,IDC_SP_METTENSVARSPIN,IDC_SP_METTENSVAR);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_AUTOCOARSE),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_DRAFTMODE),FALSE);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MANYBLOBS),FALSE);
  SpinnerOff(hWnd,IDC_SP_METCOURSESPIN,IDC_SP_METCOURSE);
  SpinnerOff(hWnd,IDC_SP_METCOURSEVSPIN,IDC_SP_METCOURSEV);
}

void InstStuff(HWND hWnd,BOOL ison,HWND hparam,HWND spawn,BOOL dist)
{ EnableWindow(GetDlgItem(hWnd,IDC_AP_INSTANCESRCNAME),ison);
  TurnButton(hWnd,IDC_AP_OBJECTPICK,ison);
  TurnButton(hWnd,IDC_AP_TREEPICK,ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_USESUBTREE),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_NOANIOFF),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_ANIOFFBIRTH),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_ANIOFFRND),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_SP_MAPCUSTOMINST),ison);
//  if (!dist) EnableWindow(GetDlgItem(hWnd,IDC_AP_CUSTOMMTLL2),ison);
  EnableWindow(GetDlgItem(hparam,IDC_SP_VIEWDISPBOX),ison);
  EnableWindow(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),ison);
if (ison)
  SpinnerOn(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);  
else
  SpinnerOff(hWnd,IDC_AP_ANIRNDFRSPIN,IDC_AP_ANIRNDFR);  
}
void SpawnWithStype(int stype,HWND spawn,int repi)
{ EnableWindow(GetDlgItem(spawn,IDC_AP_OBJECTQUEUE),stype>1);
  TurnButton(spawn,IDC_AP_OBJECTQUEUEPICK,(stype>1));
   TurnButton(spawn,IDC_AP_OBJQUEUEREPLACE,(stype>1)&&(repi>-1));
   TurnButton(spawn,IDC_AP_OBJQUEUEDELETE,(stype>1)&&(repi>-1));
}

void ObjectMutQueOn(int stype,HWND spawn,int repi)
{ SpawnWithStype(stype,spawn,repi);
}

void ObjectMutQueOff(HWND spawn)
{ TurnButton(spawn,IDC_AP_OBJECTQUEUE,FALSE);
  TurnButton(spawn,IDC_AP_OBJECTQUEUEPICK,FALSE);
  TurnButton(spawn,IDC_AP_OBJQUEUEREPLACE,FALSE);
  TurnButton(spawn,IDC_AP_OBJQUEUEDELETE,FALSE);
}

void SpawnStuff(HWND hWnd,int stype)
{ BOOL ison=(stype>1);
  if (ison)
  { SpinnerOn(hWnd,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);  
	SpinnerOn(hWnd,IDC_AP_NUMBERVARSPIN,IDC_AP_NUMBERVAR);  
	SpinnerOn(hWnd,IDC_AP_PARENTPERCENTSPIN,IDC_AP_PARENTPERCENT);  
	SpinnerOn(hWnd,IDC_AP_NUMBERVARVARSPIN,IDC_AP_NUMBERVARVAR);  
	SpinnerOn(hWnd,IDC_AP_CHAOSANGLESPIN,IDC_AP_CHAOSANGLE);  
	SpinnerOn(hWnd,IDC_AP_CHAOSSPEEDSPIN,IDC_AP_CHAOSSPEED);  
	SpinnerOn(hWnd,IDC_AP_CHAOSSCALESPIN,IDC_AP_CHAOSSCALE);  
	SpinnerOn(hWnd,IDC_AP_QUEUELIFESPANSPIN,IDC_AP_QUEUELIFESPAN);  
  }
  else 
  { SpinnerOff(hWnd,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);  
	SpinnerOff(hWnd,IDC_AP_NUMBERVARSPIN,IDC_AP_NUMBERVAR);  
	SpinnerOff(hWnd,IDC_AP_PARENTPERCENTSPIN,IDC_AP_PARENTPERCENT);  
	SpinnerOff(hWnd,IDC_AP_NUMBERVARVARSPIN,IDC_AP_NUMBERVARVAR);  
	SpinnerOff(hWnd,IDC_AP_CHAOSANGLESPIN,IDC_AP_CHAOSANGLE);  
	SpinnerOff(hWnd,IDC_AP_CHAOSSPEEDSPIN,IDC_AP_CHAOSSPEED);  
	SpinnerOff(hWnd,IDC_AP_CHAOSSCALESPIN,IDC_AP_CHAOSSCALE);  
	SpinnerOff(hWnd,IDC_AP_QUEUELIFESPANSPIN,IDC_AP_QUEUELIFESPAN);  
	EnableWindow(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),FALSE);
 }
  if (stype==1)
  { SpinnerOn(hWnd,IDC_AP_MAXSPAWNDIEAFTERSPIN,IDC_AP_MAXSPAWNDIEAFTER);
	SpinnerOn(hWnd,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,IDC_AP_MAXSPAWNDIEAFTERVAR);
  }
  else 
  { SpinnerOff(hWnd,IDC_AP_MAXSPAWNDIEAFTERSPIN,IDC_AP_MAXSPAWNDIEAFTER);
	SpinnerOff(hWnd,IDC_AP_MAXSPAWNDIEAFTERVARSPIN,IDC_AP_MAXSPAWNDIEAFTERVAR);
  }
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPEEDLESS),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPEEDMORE),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPEEDBOTH),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPAWNSUMV),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPAWNSPEEDFIXED),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SCALEDOWN),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SCALEUP),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SCALEBOTH),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPAWNSCALEFIXED),ison);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_LIFEQUEUE),ison);
  TurnButton(hWnd,IDC_AP_LIFEQUEUEADD,ison);
  TurnButton(hWnd,IDC_AP_LIFEQUEUEDEL,ison);
  TurnButton(hWnd,IDC_AP_LIFEQUEUEREPL,ison);
  if (stype==4)
	  SpinnerOff(hWnd,IDC_AP_MAXSPAWNGENSSPIN,IDC_AP_MAXSPAWNGENS);
 /*  EnableWindow(GetDlgItem(hWnd,IDC_AP_OBJECTQUEUE),ison);
  TurnButton(hWnd,IDC_AP_OBJECTQUEUEPICK,ison);
  TurnButton(hWnd,IDC_AP_OBJQUEUEDELETE,ison);
  TurnButton(hWnd,IDC_AP_OBJQUEUEREPLACE,ison);*/
}

void AllSpawnBad(HWND hWnd,int stype,BOOL notbad)
{ SpawnStuff(hWnd,stype);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_COLLIDESPAWN),notbad);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_DEATHSPAWN),notbad);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_SPAWNTRAILS),notbad);
  EnableWindow(GetDlgItem(hWnd,IDC_AP_COLLIDEDIE),notbad);
}

void IPCControls(HWND hWnd,HWND spwnd,int stype,BOOL ison)
{ if (ison)
  { SpinnerOn(hWnd,IDC_INTERP_NSTEPSSPIN,IDC_INTERP_NSTEPS);
    SpinnerOn(hWnd,IDC_INTERP_BOUNCESPIN,IDC_INTERP_BOUNCE);
    SpinnerOn(hWnd,IDC_INTERP_BOUNCEVARSPIN,IDC_INTERP_BOUNCEVAR);
	AllSpawnBad(spwnd,0,FALSE);
  }
  else
  { SpinnerOff(hWnd,IDC_INTERP_NSTEPSSPIN,IDC_INTERP_NSTEPS);
    SpinnerOff(hWnd,IDC_INTERP_BOUNCESPIN,IDC_INTERP_BOUNCE);
    SpinnerOff(hWnd,IDC_INTERP_BOUNCEVARSPIN,IDC_INTERP_BOUNCEVAR);
	AllSpawnBad(spwnd,stype,TRUE);
  }
}

BOOL IsStdMtl(INode *cnode)
{ Mtl *mtl;
  int nummtls,multi=0;
  if (!cnode) return(TRUE);
  mtl=cnode->GetMtl();
  if (mtl)
  { Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
    Class_ID oc=mtl->ClassID();
	if (multi=(oc==mc))
	{ nummtls=mtl->NumSubMtls();if (nummtls==0) multi=0;}
  }
  return (!multi);
}

void MakeNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t)
{ int nc;
  if (subtree)
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	  MakeNodeList(node->GetChildNode(j),ntab,subtree,t);
  TriObject *triOb=NULL;
  Object *pobj=NULL;
  if ((!node->IsGroupHead())&&((triOb=TriIsUseable(pobj = node->EvalWorldState(t).obj,t))!=NULL))
   (*ntab).Append(1,&node,0);
  if ((triOb) &&(triOb!=pobj)) triOb->DeleteThis();
}

void MakeGroupNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t)
{ int nc;
  if ((nc=node->NumberOfChildren())>0)
	for (int j=0;j<nc;j++)
	{ INode *nxtnode=node->GetChildNode(j);
	  if (nxtnode->IsGroupHead()) MakeGroupNodeList(nxtnode,ntab,subtree,t);
	  else if ((subtree)||(nxtnode->IsGroupMember())) MakeNodeList(nxtnode,ntab,subtree,t);
	}
}

void FormatName(TCHAR *name)
{ int len= _tcslen(name);
  if (len>MAXNAME) name[MAXNAME]='\0';
}

ParticleMtl::ParticleMtl():Material() {
	Kd[0] = PARTICLE_R;
	Kd[1] = PARTICLE_G;
	Kd[2] = PARTICLE_B;
	Ks[0] = PARTICLE_R;
	Ks[1] = PARTICLE_G;
	Ks[2] = PARTICLE_B;
	shininess = (float)0.0;
	shadeLimit = GW_WIREFRAME;
	selfIllum = (float)1.0;
	}
void SetFlag(ULONG &flags,ULONG f, ULONG val) {
	if (val) flags|=f; 
	else flags &= ~f;
	}
void ZeroMesh(Mesh *pm)
{ pm->setNumVerts(0);
  pm->setNumFaces(0);
  pm->setNumTVerts(0);
  pm->setNumTVFaces(0);
}
BOOL ReadInt(int *buf,FILE *f)
{ return(fread(buf,isize,1,f)==1);
}
BOOL WriteInt(int *buf,FILE *f)
{ return(fwrite(buf,isize,1,f)==1);
}

BOOL GenNewSaveFile(int osize,int size,int custsettings,FILE *f,TCHAR *filename,int vers)
{ int future=0;BOOL ok=TRUE;
  fclose(f);
  if ((f = _tfopen(filename, _T("r+b"))) == NULL) return FALSE;
  ok=(WriteInt(&custsettings,f)&&WriteInt(&vers,f)&&WriteInt(&size,f)&&WriteInt(&future,f));
 if (custsettings>0)
 { int cset=(custsettings-1),odata=osize+NLEN;
   AName Name;int ofs=(size-osize),tofs=cset*ofs;
   BYTE *data=new BYTE[size];for (int x=0;x<size;x++) data[x]=0;
   cset*=odata;cset+=HLEN;
   while (cset>=HLEN)
   { fseek(f,cset,SEEK_SET);
      if (fread(Name,NLEN,1,f)==1)
	 { if (fread(data,osize,1,f)!=1) goto badend;
       fseek(f,cset+tofs,SEEK_SET);
		if (fwrite(Name,1,NLEN,f)!=NLEN) goto badend;
	   if (fwrite(data,size,1,f)!=1) goto badend;
	 } else goto badend;
	 cset-=odata;tofs-=ofs;
   }
   delete[] data;
   rewind(f);
 }
 return ok;
badend: fclose(f);return FALSE;
 }

void SwitchVerts(Mesh *pm)
{ int numf=pm->getNumFaces(),tmpv;
  for (int i=0;i<numf;i++) 
  { tmpv=pm->faces[i].v[1];
    pm->faces[i].v[1]=pm->faces[i].v[2];
	pm->faces[i].v[2]=tmpv;
  }
}
BOOL CheckMtlChange(Mtl *mtl,BOOL wasmulti)
{ BOOL multi=FALSE;
  if (mtl)
  { Class_ID mc=Class_ID(MULTI_CLASS_ID,0);
    Class_ID oc=mtl->ClassID();
    if (multi=(oc==mc))
    { if (mtl->NumSubMtls()==0) multi=0;}
  }
  return (wasmulti!=multi);
}
float GetLen(Point3 vels,int K)
{ float len=Length(vels);
  int aframe=GetTicksPerFrame();
  if (FloatEQ0(len*aframe)) len=1.0f;
  len=((len*aframe-1.0f)*K+100.0f)/100.0f;
  return len;
}
int __cdecl limsort( const void *arg1, const void *arg2 )
{  float v1=((limdata *)arg1)->val,v2=((limdata *)arg2)->val;
	if (v1<v2) return 1;
	if (v1==v2) return 0;
	return -1;
}
int __cdecl pairsort( const void *arg1, const void *arg2 )
{ int p11=((pairs *)arg1)->p1,p12=((pairs *)arg1)->p2;
  int p21=((pairs *)arg2)->p1,p22=((pairs *)arg2)->p2;
  if (p11<p12) return 1;
  if (p11==p12) return (p12<p22?1:(p12==p22?0:-1));
  return -1;
}
int CountLive(ParticleSys &parts)
{	int c=0;
	for (int i=0; i<parts.Count(); i++)
	  {if (parts.Alive(i)) c++;}
	return c;
}

void fillinBB(boxplus *bbox,ParticleSys &parts,int dt)
{ int c=0;
  for (int i=0;i<parts.Count();i++)
  { if (parts.Alive(i))
	{ Point3 pos=(float)dt*parts.vels[i];
	  bbox[c].refnum=i;
      bbox[c].bbox.MakeCube(parts.points[i],parts.radius[i]);
      if (parts.vels[i].x<0) bbox[c].bbox.pmin.x+=pos.x;else bbox[c].bbox.pmax.x+=pos.x;
      if (parts.vels[i].y<0) bbox[c].bbox.pmin.y+=pos.y;else bbox[c].bbox.pmax.y+=pos.y;
      if (parts.vels[i].z<0) bbox[c].bbox.pmin.z+=pos.z;else bbox[c].bbox.pmax.z+=pos.z;
	  c++;
	}
  }
}
void AddToActive(int *active,BOOL *inlist,int &num,int partnum)
{ active[num]=partnum;
  inlist[partnum]=TRUE;
  num++;
}
void RemFromActive(int *active,BOOL *inlist,int &len,int partnum)
{ for (int i=0;(i<len)&&(active[i]!=partnum);i++);
  int mnum=len-i-1;
  if (mnum>0) { memcpy(&active[i],&active[i+1],isize*mnum);}
  inlist[partnum]=FALSE;
  len--;
}

void CollideParticle::PossibleCollide(int *active,BOOL *used,int acount)
{ int last=acount-1;
  used[active[last]]=TRUE;
  for (int i=0;i<last;i++)
  { if (xcnt==xmaxlen) 
	{ int oldlen=xmaxlen;xmaxlen+=count;pairs *tmp=xlst;xlst=new pairs[xmaxlen];assert(xlst);
	  memcpy(xlst,tmp,oldlen*sizeof(pairs));delete[] tmp;
	}
	if (active[i]<active[last]) {xlst[xcnt].p1=active[i];xlst[xcnt].p2=active[last];}
    else {xlst[xcnt].p1=active[last];xlst[xcnt].p2=active[i];}
	xcnt++;
	used[active[i]]=TRUE;
  }
}

int CollideParticle::FindXLst(int &pos,int num)
{ while (pos<xcnt)
  { if (xlst[pos].p1==num) return xlst[pos].p2; 
    if (xlst[pos].p2==num) return xlst[pos].p1;
	pos++;
  }
  return -1;
}

void CollideParticle::PossibleYZCollide(int *active,BOOL *used,int acount,int num)
{ int i=0,cpos=0,last=acount-1,tstnum=0;BOOL found=FALSE,ok=TRUE;
  while (ok && (i<acount))
  { if (ok=((tstnum=FindXLst(cpos,num))>-1))
	{ while ((i<acount)&&(tstnum>active[i])) i++;
	  if (i<acount)
	  { if (tstnum==active[i]) found=TRUE;
	    else
		{ int dist=xcnt-cpos-1;
		  if (dist) memcpy(&xlst[cpos],&xlst[cpos+1],sizeof(pairs)*dist);
		  xcnt--;
		}
		i++;
	  } 
	}
  }
  if (!found) used[num]=FALSE;
  else
  {	if (num<active[acount-1])
	{ int i=acount-2;
      while ((i>-1)&&(num<active[i])) i--;
	  i++;
      memcpy(&active[i+1],&active[i],isize*(acount-i));
	 } else i=acount;
	active[i]=num;
	acount++;
  }
}

void CollideParticle::RemoveThisPart(int num)
{ int i=0;
  while (i<xcnt)
  { if ((xlst[i].p1==num)||(xlst[i].p2==num))
	{ int dist=xcnt-i-1;
	  if (dist) memcpy(&xlst[i],&xlst[i +1],sizeof(pairs)*dist);
	  xcnt--;
	} else i++;
  }
}

int CollideParticle::PredetectParticleCollisions()
{ int acount=0;xcnt=0;
  int limnum=2*count;limdata *limits=new limdata[limnum];assert(limits);
  int j=0;
  for (int i=0;i<count;i++) 
  { limits[j].val=bbox[i].bbox.pmin.x;limits[j].num=i;j++;
    limits[j].val=bbox[i].bbox.pmax.x;limits[j].num=i;j++;
  }
  qsort(limits,j,sizeof(limdata),limsort);
  int *active=new int[count];assert(active);memset(active,0,isize*count);
  int *inlist=new BOOL[count];assert(inlist);memset(inlist,0,bsize*count);
  BOOL *used=new BOOL[count];assert(used);memset(used,0,bsize*count);
  for (i=0;i<limnum;i++)
  { int num=limits[i].num;
    if (inlist[num]) RemFromActive(active,inlist,acount,num);
	else 
	{ AddToActive(active,inlist,acount,num);
	  if (acount>1) PossibleCollide(active,used,acount);
	}
  }
  qsort(xlst,xcnt,sizeof(pairs),pairsort);
  BOOL added=FALSE;
  for (int k=0;(xcnt>0)&&(k<2);k++)
  { j=0;
	for (i=0;i<count;i++) 
	{ limits[j].val=(k==0?bbox[i].bbox.pmin.y:bbox[i].bbox.pmin.z);limits[j].num=i;j++;
	limits[j].val=(k==0?bbox[i].bbox.pmax.y:bbox[i].bbox.pmax.z);limits[j].num=i;j++;
	} 
	acount=0;
    qsort(limits,j,sizeof(limdata),limsort);
    for (i=0;(xcnt>0)&&(i<limnum);i++)
	{ int num=limits[i].num;
	  if (used[num])
	  { if (inlist[num]) 
		{ if ((acount==1)&&added)
		  { used[num]=FALSE;RemoveThisPart(num);}
		  RemFromActive(active,inlist,acount,num);added=FALSE;
		}
		else
		{ if (acount>0) PossibleYZCollide(active,used,acount,num);
		  AddToActive(active,inlist,acount,num);
		  added=TRUE;
		}
	  }
	}
  }
  if (limits) delete[] limits;
  if (active) delete[] active;
  if (inlist) delete[] inlist;
  if (used) delete[] used;
  return xcnt;
}

TimeValue CollideParticle::DetectParticleCollsion(ParticleSys &parts,pairs x,int t,float B,float Vb,mindata &tmpdata)
{ float width1=parts.radius[bbox[x.p1].refnum],width2=parts.radius[bbox[x.p2].refnum];
  float L=(width1+width2)/2.0f;
  Point3 v1=parts.vels[bbox[x.p1].refnum],v2=parts.vels[bbox[x.p2].refnum];
  Point3 Aj=parts.points[bbox[x.p1].refnum], Am=parts.points[bbox[x.p2].refnum],Bj=Aj+v1*(float)t,Bm=Am+v2*(float)t;
  Point3 V=Aj-Am;float tmpl=Length(V);
  if (Length(V)<L) return -1;
  Point3 Va=Bj-Aj+Am-Bm;
  float AA=LengthSquared(Va),BB=2.0f*(Va.x*V.x+Va.y*V.y+Va.z*V.z),CC=LengthSquared(V)-L*L;
  float BBSQ=BB*BB,AC=4.0f*AA*CC;
  if ((BBSQ-AC)<0.0f) return -1;
  float A2=2.0f*AA;
  float mult=(float)sqrt(BBSQ-AC);
  float alpha1=(-BB+mult)/A2,alpha2=(-BB-mult)/A2,alpha;
  if ((alpha1>1.0f)&&(alpha2>1.0f)) return -1;
  if ((alpha1<0.0f)&&(alpha2<0.0f)) return -1;
  alpha=(alpha1<alpha2?(alpha1>0.0f?alpha1:alpha2):(alpha2<0.0f?alpha1:alpha2));
  Aj+=v1*alpha;Am+=v2*alpha;
  Point3 collx=Normalize(Am-Aj);
  float size1=parts.radius[bbox[x.p1].refnum],size2=parts.radius[bbox[x.p2].refnum];
  float mass1=size1*size1*size1,mass2=size2*size2*size2;
  float eps=B*(1.0f-Vb*RND11());
  float vmag1=DotProd(collx,v1),vmag2=DotProd(collx,v2);
  Point3 V1=vmag1*collx,V2=vmag2*collx;
  v1-=V1;v2-=V2;
  float mass=mass1/mass2;
  float vmag11=(vmag1*mass+vmag2-eps*vmag1+eps*vmag2)/(1.0f+mass);
  float vmag21=eps*(vmag1-vmag2)+vmag11;
  v1+=vmag11*collx;v2+=vmag21*collx;
  tmpdata.svel1=v1;tmpdata.svel2=v2;tmpdata.spos1=Aj;tmpdata.spos2=Am;
  return (int)alpha;
}

TimeValue CollideParticle::FindMinPartCollide(ParticleSys &parts,int remtime,float B,float Vb)
{	TimeValue tmptime=0,smalltime=remtime;
	mindata tmpdata;
	for (int i=0;i<xcnt;i++)
	{	if ((tmptime=DetectParticleCollsion(parts,xlst[i],remtime,B,Vb,tmpdata)) > -1)
			if (tmptime<smalltime)
			{	minpt=tmpdata;
				minpt.min=xlst[i].p1;
				minpt.min2=xlst[i].p2;
			}; // is this semicol necessary?
	}
	return smalltime;
}

BOOL MaybeStuck(int hit,int colobj,stuck sl,int max)
{ int found=FALSE;int i=0;
  while ((i<max)&&(!(found=((hit==sl.ppts[i].p1)&&(colobj==sl.ppts[i].p2)) ))  ) i++;
  return (found);
}

mindata CollideParticle::InterPartCollide(ParticleSys &parts,Tab<CollisionObject*> &cobjs,int &remtime,int &stepnum,float B,float Vb,int &t,oldipc &l)
{	count = CountLive(parts);
	xlst = new pairs[count];
	xmaxlen = count;
	BOOL found = FALSE;
	bbox = new boxplus[count];
	assert(bbox);
	fillinBB(bbox,parts,remtime);
    int possible = PredetectParticleCollisions();
/*f (minpt.collide>-1) 
	{	l.lastmin = minpt.min;
		l.lastcollide = minpt.collide;
	}*/
	if (!(stucklist.stuckt==t)) 
	{ stucklist.stuckt=t;sused=0;
	}
    minpt.min = -1;
	minpt.min2 = -1;
	minpt.mintime = -1;
	minpt.collide = -1;
	int alivep=0;
	float tleft;
    minpt.mintime = FindMinPartCollide(parts,remtime,B,Vb);
    for (int j=0; j<parts.Count(); j++)
	{	if (parts.Alive(j))
		{	for (int k=0; k<cobjs.Count(); k++)
			{	BOOL duplicateCobj = FALSE;
				for (int kk=0; kk<k; kk++)
				{ if (cobjs[k]->GetSWObject()==cobjs[kk]->GetSWObject())
					{	duplicateCobj = TRUE;
						break;
					}
				}
				if (!duplicateCobj)
				{	Point3 pos = parts.points[j],
						   vel = parts.vels[j];
					float tmpt = (float)remtime;
					tleft = tmpt;
					BOOL stuck = MaybeStuck(bbox[alivep].refnum,k,stucklist,sused);
					if (!stuck)
					{ BOOL atlast=(l.lastmin==bbox[alivep].refnum)&&(k==l.lastcollide);
					  if (atlast) 
					  {	pos += vel;
						tleft--;
						int num=sused;sused++; 
						if (sused>=ssize) {ssize+=5;stucklist.ppts.Resize(ssize);}
						stucklist.ppts.SetCount(sused);
						stucklist.ppts[num].p1=bbox[alivep].refnum;stucklist.ppts[num].p2=k;
					  }
					  if ((tleft>0)&&(cobjs[k]->CheckCollision(t,pos,vel,tleft, j,&tmpt,FALSE)) )
					  {	if (atlast) tmpt += 1;
						if ((minpt.min < 0) || (tmpt < minpt.mintime))
						{	minpt.mintime = (TimeValue)tmpt;
							minpt.spos1 = pos;
							minpt.svel1 = vel;
							minpt.min = alivep;
							minpt.min2 = -1;
							minpt.collide = k;
						}
					  }
					}
				}
			}
			alivep++;
		}
	}
	if (minpt.min>-1)
	{	parts.points[bbox[minpt.min].refnum] = minpt.spos1;
		parts.vels[bbox[minpt.min].refnum] = minpt.svel1;
		minpt.min = bbox[minpt.min].refnum;
		l.lastmin=minpt.min;l.lastcollide=minpt.collide;
		if (minpt.min2>-1)
		{	parts.points[bbox[minpt.min2].refnum] = minpt.spos2;
			parts.vels[bbox[minpt.min2].refnum] = minpt.svel2;
			minpt.min2=bbox[minpt.min2].refnum;
		}
		found=TRUE;
	} 
	remtime -= minpt.mintime;
	t += minpt.mintime;
	if (bbox) 
		delete[] bbox;
	if (remtime==0) 
		stepnum++;
	if (xlst) 
		delete[] xlst;
	return minpt;
}

BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->IsParticleSystem()) return FALSE;
    if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

void MirrorFace(Face *f)
{ int tmp=f->v[1];
  f->v[1]=f->v[2];
  f->v[2]=tmp;
  f->setEdgeVisFlags(f->getEdgeVis(2),f->getEdgeVis(1),f->getEdgeVis(0));
}

void MirrorTVs(TVFace *f)
{ int tmp=f->t[1];
  f->t[1]=f->t[2];
  f->t[2]=tmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\SurfWrap\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SurfWrap.rc
//
#define IDS_AP_PARAMETERS               1
#define IDS_AP_SWRAPOBJ                 2
#define IDS_AP_SWRAP                    3
#define IDS_AP_SWRAPMOD                 4
#define IDS_AP_SWRAPBINDING             5
#define IDS_AP_CREATE                   6
#define IDS_AP_OBJECTSTR                7
#define IDS_AP_NONE                     8
#define IDS_AP_TOP                      9
#define IDS_AP_KIDEFAULT                10
#define IDS_AP_SELVERTS                 11
#define IDS_AP_ICONSIZE                 12
#define IDS_AP_DEF2                     13
#define IDS_AP_STANDOFF                 14
#define IDS_AP_MSWRAPMOD                15
#define IDS_AP_DEFDEFORMATIONS          16
#define IDS_AP_GIZMO                    17
#define IDS_AP_SURFWRAPLIB              18
#define IDS_AP_PICKMODE                 19
#define IDD_SW_DESC                     108
#define IDD_AP_SURFWRAP                 116
#define IDD_AP_SURFWRAPM                117
#define IDC_CROSS_HAIR                  156
#define IDC_AP_KIDEFAULT                1000
#define IDC_AP_STANDOFF                 1001
#define IDC_AP_KIDEFAULTSPIN            1011
#define IDC_AP_STANDOFFSPIN             1012
#define IDC_AP_USESELVERTS              1018
#define IDC_SP_CHUNKPICKOBJECT          1030
#define IDC_AP_WRAPPICKOBJ              1030
#define IDC_AP_ICONSIZE                 1048
#define IDC_AP_ICONSIZESPIN             1049
#define IDC_SP_CHUNKPICKBUTTON          1051
#define IDC_AP_WRAPBUTTON               1051

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\udeflect.cpp ===
/**********************************************************************
 *<
	FILE: udeflect.cpp

	DESCRIPTION: Turns Any Mesh Into a Deflector

	CREATED BY: Audrey Peterson

	HISTORY: 1/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "suprprts.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "texutil.h"
#include "interpik.h"

#define PBLK		0
#define CUSTNODE 	1


static Class_ID UNIDEF_CLASS_ID(0x28497b68, 0);
static Class_ID UNIDEFMOD_CLASS_ID(0x4d456b2d, 0);


class VNormal {
	public:
		Point3 norm;
		DWORD smooth;
		VNormal *next;
		BOOL init;

		VNormal() {smooth=0;next=NULL;init=FALSE;norm=Point3(0,0,0);}
		VNormal(Point3 &n,DWORD s) {next=NULL;init=TRUE;norm=n;smooth=s;}
		~VNormal() {delete next;}
		void AddNormal(Point3 &n,DWORD s);
		Point3 &GetNormal(DWORD s);
		void Normalize();
	};

void VNormal::AddNormal(Point3 &n,DWORD s)
	{
	if (!(s&smooth) && init) {
		if (next) next->AddNormal(n,s);
		else {
			next = new VNormal(n,s);
			}
	} else {
		norm   += n;
		smooth |= s;
		init    = TRUE;
		}
	}

Point3 &VNormal::GetNormal(DWORD s)
	{
	if (smooth&s || !next) return norm;
	else return next->GetNormal(s);	
	}

void VNormal::Normalize()
	{
	VNormal *ptr = next, *prev = this;
	while (ptr) {
		if (ptr->smooth&smooth) {
			norm += ptr->norm;			
			prev->next = ptr->next;
			delete ptr;
			ptr = prev->next;
		} else {
			prev = ptr;
			ptr  = ptr->next;
			}
		}
	norm = ::Normalize(norm);
	if (next) next->Normalize();
	}

class UniPickOperand;

class UniDefObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		static HWND hParams;
					
		INode *custnode;
		int lastrnd;
		TimeValue t;
		TSTR custname;
		UniDefObject();
		~UniDefObject();
		Mesh *dmesh;
		int nv,nf;
		VNormal *vnorms;
		Point3 *fnorms;
		Matrix3 tm,ptm,invtm,tmNoTrans,invtmNoTrans;
		Interval tmValid,mValid;
		Point3 dvel;

		static BOOL creating;
		static UniPickOperand pickCB;

		void ShowName();
		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		Class_ID ClassID() {return UNIDEF_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_UNIDEFLECTOR);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	};
class UniPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		UniDefObject *po;
		
		UniPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};
class CreateUDeflectPickNode : public RestoreObj {
	public:   		
		UniDefObject *obj;
		INode *oldn;
		CreateUDeflectPickNode(UniDefObject *o, INode *n) {
			obj = o; oldn=n;
			}
		void Restore(int isUndo) {
			if (obj->custnode) 
			{ obj->custname = TSTR(obj->custnode->GetName());
			}
			else 
			{ obj->custname=TSTR(_T(""));
			}
			obj->ShowName();
			}
		void Redo() 
		{ obj->custname = TSTR(oldn->GetName());
		if (obj->hParams)
	{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (oldn ? obj->custname : TSTR(GetString(IDS_AP_NONE)));
	SetWindowText(GetDlgItem(obj->hParams, IDC_PCLOUD_PCUST), name);
		}
			}
		TSTR Description() {return GetString(IDS_AP_UDEFPICK);}
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *UniDefObject::ip        = NULL;
IParamMap *UniDefObject::pmapParam = NULL;
HWND       UniDefObject::hSot      = NULL;
HWND       UniDefObject::hParams      = NULL;
BOOL UniDefObject::creating    = FALSE;
UniPickOperand UniDefObject::pickCB;

class UniDeflectorClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new UniDefObject;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_UNIDEFLECTOR_CLASS);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return UNIDEF_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(SPACEWARPS_FOR_PARTICLES);}
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};
static UniDeflectorClassDesc UnideflectDesc;
ClassDesc* GetUniDefDesc() {return &UnideflectDesc;}

//--- DeflectMod -----------------------------------------------------

class UniDeflectorField : public CollisionObject {
	public:		
		UniDefObject *obj;
		INode *node;
		int badmesh;
		BOOL CheckCollision(TimeValue t,Point3 &pos, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide);;
		Object *GetSWObject();
	};

class UniDeflectMod : public SimpleWSMMod {
	public:				
		UniDeflectorField deflect;

		UniDeflectMod() {}
		UniDeflectMod(INode *node,UniDefObject *obj);	


		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_UNIDEFMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return UNIDEFMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_UNIDEFBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class UniDeflectorModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new UniDeflectMod;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_UNIDEFMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return UNIDEFMOD_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static UniDeflectorModClassDesc UnideflectModDesc;
ClassDesc* GetUniDefModDesc() {return &UnideflectModDesc;}
//--- UniDefObject Parameter map/block descriptors ------------------

#define PB_BOUNCE	 0
#define PB_BVAR		 1
#define PB_CHAOS	 2
#define PB_RADIUS	 3
#define PB_FRICTION	 4
#define PB_VELOCITY	 5

static ParamUIDesc descUniParam[] = {
	// Bounce
	ParamUIDesc(
		PB_BOUNCE,
		EDITTYPE_FLOAT,
		IDC_SPHDEFLECT_BOUNCE,IDC_SPHDEFLECT_BOUNCESPIN,
		0.0f, 9999999.0f,
		0.01f),
	
	// Bounce Var
	ParamUIDesc(
		PB_BVAR,
		EDITTYPE_FLOAT,
		IDC_SPHDEFLECT_BOUNCEVAR,IDC_SPHDEFLECT_BOUNCEVARSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
	
	// Chaos
	ParamUIDesc(
		PB_CHAOS,
		EDITTYPE_FLOAT,
		IDC_SPHDEFLECT_CHAOS,IDC_SPHDEFLECT_CHAOSSPIN,
		0.0f,100.0f,
		1.0f,
		stdPercentDim),
	// Deflector Friction
	ParamUIDesc(
		PB_FRICTION,
		EDITTYPE_FLOAT,
		IDC_SPHDEFLECT_FRICTION,IDC_SPHDEFLECT_FRICTIONSPIN,
		0.0f, 100.0f,
		1.0f,
		stdPercentDim),

	// Radius
	ParamUIDesc(
		PB_RADIUS,
		EDITTYPE_UNIVERSE,
		IDC_SPHDEFLECT_RADIUS,IDC_SPHDEFLECT_RADIUSSPIN,
		0.0f, 9999999.0f,
		SPIN_AUTOSCALE),

	// Velocity Inheritance
	ParamUIDesc(
		PB_VELOCITY,
		EDITTYPE_FLOAT,
		IDC_SPHDEFLECT_VEL,IDC_SPHDEFLECT_VELSPIN,
		0.0f, 1000.0f,SPIN_AUTOSCALE),
	};

#define PARAMDESC_UNILENGTH	6

ParamBlockDescID descUniVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },	//Bounce
	{ TYPE_FLOAT, NULL, FALSE, 1 },	//Bounce Var
	{ TYPE_FLOAT, NULL, TRUE, 2 },	//Chaos
	{ TYPE_FLOAT, NULL, FALSE, 3 },	//Radius
	{ TYPE_FLOAT, NULL, TRUE, 4 },	//Deflector Friction
	{ TYPE_FLOAT, NULL, TRUE, 5 }};	//Velocity Inheritance

#define PBLOCK_UNILENGTH	6

#define CURRENT_VERSION	0

//--- Universal Deflect object methods -----------------------------------------
class CreateUniObjectProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *CloudNode;
		UniDefObject *UniObj;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square,dostuff;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)CloudNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { CloudNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateUniObjectProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATEUniObjectMODE	CID_USER + 12

class CreateUniObjectMode : public CommandMode {		
	public:		
		CreateUniObjectProc proc;
		IObjParam *ip;
		UniDefObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,UniDefObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATEUniObjectMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() 
		{ GetCOREInterface()->PushPrompt(GetString(IDS_AP_CREATEMODE));
		  SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
		}
		void ExitMode() {GetCOREInterface()->PopPrompt();SetCursor(LoadCursor(NULL, IDC_ARROW));}
	};
static CreateUniObjectMode theCreateUniObjectMode;

RefResult CreateUniObjectProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( UniObj && CloudNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (UniObj && CloudNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (UniObj->creating) 
						{  theCreateUniObjectMode.JumpStart(UniObj->ip,UniObj);
						   createInterface->SetCommandMode(&theCreateUniObjectMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				UniObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				UniObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				UniObj  = NULL;				
				CloudNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateUniObjectProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	CloudNode         = NULL;
	UniObj       = NULL;
	dostuff=0;
	CreateNewObject();
	}
void CreateUniObjectProc::CreateNewObject()
	{
	UniObj = (UniDefObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( UniObj ) {
		UniObj->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		UniObj->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateUniObjectProc::End()
{ if ( UniObj ) 
	{
  #ifdef _OSNAP
		UniObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		UniObj->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete UniObj;
			UniObj = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		} 
 else if ( CloudNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
	}
}

void CreateUniObjectMode::JumpStart(IObjParam *i,UniDefObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int UniDeflectorClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateUniObjectMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateUniObjectMode);
	return TRUE;
	}

int UniDeflectorClassDesc::EndCreate(Interface *i)
	{
	theCreateUniObjectMode.End();
	i->RemoveMode(&theCreateUniObjectMode);
	return TRUE;
	}

int CreateUniObjectProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				UniObj->pblock->SetValue(PB_RADIUS,0,0.01f);
				UniObj->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				UniObj->pblock->SetValue(PB_RADIUS,0,(float)fabs(p1.x-p0.x));
				UniObj->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}

int CreateUniObjectProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif
	if (!dostuff)
	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( UniObj );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
				   		UniObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						if (CloudNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates UniObj
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					CloudNode = createInterface->CreateObjectNode( UniObj);
					attachedToNode = TRUE;
					assert( CloudNode );					
					createCB = NULL;
					createInterface->SelectNode( CloudNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, CloudNode);
					theHold.Resume();
					mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
					createInterface->SetNodeTMRelConstPlane(CloudNode, mat);
					dostuff=1;
					res = TRUE;
					break;
					
				}			
			break;

		case MOUSE_MOVE:
			//mat[3] = vpx->GetPointOnCP(m);
			mat.SetTrans(vpx->SnapPoint(m,m,NULL,snapdim));
			createInterface->RedrawViews(createInterface->GetTime());	   
			res = TRUE;
			break;

		case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
				res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;

	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
		case MOUSE_ABORT: goto abort;
		}
	int result; 
	if (dostuff)
	{ result=createmethod(vpx,msg,point,flag,m,mat);
//	  UniObj->BuildEmitter(createInterface->GetTime(),UniObj->);
	  createInterface->RedrawViews(createInterface->GetTime()); 
	  if (result==CREATE_STOP)
	  { res=FALSE;dostuff=0;				
#ifdef _OSNAP
         UniObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	  theHold.Accept(GetString(IDS_DS_CREATE));	} 
	  else if (result==CREATE_ABORT)
	  { dostuff=0;
	    goto abort;}
	}
	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
	abort:
		assert( UniObj );
#ifdef _OSNAP
		UniObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		UniObj->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the Cloudera and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		CloudNode = NULL;			
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		goto done;
	}
static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL UniPickOperand::Filter(INode *node)
	{
	if ((node)&&(!node->IsGroupHead())) {
		ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
		if (os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

BOOL UniPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if ((node)&&(!node->IsGroupHead())) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
		if ((os.obj->SuperClassID()!=GEOMOBJECT_CLASS_ID)||(!IsGEOM(os.obj))) {
			node = NULL;
			return FALSE;
			}
		}

	return node ? TRUE : FALSE;
	}

void UniDefObject::ShowName()
{TSTR name; 
 FormatName(name= TSTR(GetString(IDS_AP_ITEMSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE))));
SetWindowText(GetDlgItem(hParams, IDC_PCLOUD_PCUST), name);
}

BOOL UniPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{BOOL groupflag=0;
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	if (node->IsGroupMember()) 
	{ groupflag=1;
	  while (node->IsGroupMember()) node=node->GetParentNode();
	}
	int subtree=0;
	if (groupflag) MakeGroupNodeList(node,&nodes,subtree,ip->GetTime());
	else{ nodes.SetCount(1);nodes[0]=node;}
	ip->FlashNodes(&nodes);
	theHold.Begin();
	theHold.Put(new CreateUDeflectPickNode(po,node));

//	po->custnode=node;
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	theHold.Accept(GetString(IDS_AP_UDEFPICK));
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->ShowName();	
	if (po->creating) {
		theCreateUniObjectMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateUniObjectMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void UniPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_MTRACK_PICK));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void UniPickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_MTRACK_PICK));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
class UniObjectDlgProc : public ParamMapUserDlgProc {
	public:
		UniDefObject *po;

		UniObjectDlgProc(UniDefObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};
void UniObjectDlgProc::Update(TimeValue t)
{	po->ShowName();
	float size;
	po->pblock->GetValue(PB_RADIUS,0,size,FOREVER);
	TurnButton(po->hParams,IDC_MTRACK_PICK,(size>=0.01f));
}

BOOL UniObjectDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_MTRACK_PICK));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			po->hParams=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{    case IDC_MTRACK_PICK:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateUniObjectMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateUniObjectMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}

			}
			break;	
		}
	return TRUE;
	}

UniDefObject::UniDefObject()
	{
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(descUniVer0, PBLOCK_UNILENGTH, CURRENT_VERSION));
	assert(pblock);	

	pblock->SetValue(PB_BOUNCE,0,1.0f);
	pblock->SetValue(PB_BVAR,0,0.0f);
	pblock->SetValue(PB_CHAOS,0,0.0f);
	pblock->SetValue(PB_VELOCITY,0,0.0f);
	pblock->SetValue(PB_FRICTION,0,0.0f);
	pblock->SetValue(PB_RADIUS,0,0.0f);
	dmesh=NULL;
	vnorms=NULL;
	fnorms=NULL;
	srand(lastrnd=12345);
	t=99999;
	custname=TSTR(_T(" "));
	custnode=NULL;
	nv=0;nf=0;
	}

UniDefObject::~UniDefObject()
{   DeleteAllRefsFromMe();
	pblock=NULL;
	if (vnorms) delete[] vnorms;
	if (fnorms) delete[] fnorms;
   if (dmesh) delete dmesh;
}
Modifier *UniDefObject::CreateWSMMod(INode *node)
	{
	return new UniDeflectMod(node,this);
	}

RefTargetHandle UniDefObject::Clone(RemapDir& remap) 
	{
	UniDefObject* newob = new UniDefObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	newob->custname=custname;
	newob->dmesh=NULL;
	newob->vnorms=NULL;
	newob->fnorms=NULL;
	return newob;
	}

void UniDefObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	SimpleWSMObject::BeginEditParams(ip,flags,prev);
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_RB_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descUniParam,PARAMDESC_UNILENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_UNIVDEFL),
			GetString(IDS_RB_PARAMETERS),
			0);
		}
		if (pmapParam)
			pmapParam->SetUserDlgProc(new UniObjectDlgProc(this));
	}

void UniDefObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void UniDefObject::BuildMesh(TimeValue t)
	{
	ivalid = FOREVER;
	float length;
	pblock->GetValue(PB_RADIUS,t,length,ivalid);
	length/=2.0f;

	mesh.setNumVerts(11);
	mesh.setNumFaces(5);

	mesh.setVert(0,Point3(length,length,0.0f));
	mesh.setVert(1,Point3(-length,length,0.0f));
	mesh.setVert(2,Point3(length,-length,0.0f));
	mesh.setVert(3,Point3(-length,-length,0.0f));
	mesh.setVert(4,Point3(0.0f,0.0f,0.0f));
	mesh.setVert(5,Point3(0.0f,length,length));
	mesh.setVert(6,Point3(0.0f,-length,length));
	mesh.setVert(7,Point3(0.0f,10.0f/8.0f*length,length));
	mesh.setVert(8,Point3(0.0f,length,length*10.0f/8.0f));
	mesh.setVert(9,Point3(0.0f,-length,length*6.0f/8.0f));
	mesh.setVert(10,Point3(0.0f,-6.0f/8.0f*length,length));
	mesh.faces[0].setVerts(0,1,2);
	mesh.faces[0].setEdgeVisFlags(1,0,1);
	mesh.faces[0].setSmGroup(0);
	mesh.faces[1].setVerts(1,3,2);
	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[2].setVerts(4,5,6);
	mesh.faces[2].setEdgeVisFlags(1,0,1);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[3].setVerts(5,7,8);
	mesh.faces[3].setEdgeVisFlags(1,0,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[4].setVerts(6,9,10);
	mesh.faces[4].setEdgeVisFlags(1,0,1);
	mesh.faces[4].setSmGroup(0);  
	mesh.InvalidateGeomCache();
	}

void UniDefObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *UniDefObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_BVAR:
		case PB_CHAOS:
		case PB_FRICTION:
				 return stdPercentDim;
		case PB_RADIUS:
				 return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR UniDefObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_BOUNCE: 	return GetString(IDS_RB_BOUNCE);
		case PB_BVAR:		return GetString(IDS_RB_BVAR);
		case PB_CHAOS:		return GetString(IDS_RB_CHAOS);
		case PB_RADIUS:		return GetString(IDS_AP_ICONSIZE);
		case PB_FRICTION:	return GetString(IDS_AP_FRICTION);
		case PB_VELOCITY:	return GetString(IDS_AP_VELOCITY);
		default: 			return TSTR(_T(""));
		}
	}


//--- DeflectMod methods -----------------------------------------------

UniDeflectMod::UniDeflectMod(INode *node,UniDefObject *obj)
	{	
//	MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
		pblock = NULL;
	obRef=NULL;
	}

Interval UniDeflectMod::GetValidity(TimeValue t) 
	{
	if (obRef && nodeRef) {
		Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		UniDefObject *obj = (UniDefObject*)GetWSMObject(t);
		obj->pblock->GetValue(PB_BOUNCE,t,f,valid);
		obj->pblock->GetValue(PB_CHAOS,t,f,valid);
		obj->pblock->GetValue(PB_RADIUS,t,f,valid);
		obj->pblock->GetValue(PB_FRICTION,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		
		return valid;
	} else {
		return FOREVER;
		}
	}

class UniDeflectDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static UniDeflectDeformer Uniddeformer;

Deformer& UniDeflectMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return Uniddeformer;
	}

RefTargetHandle UniDeflectMod::Clone(RemapDir& remap) 
	{
	UniDeflectMod *newob = new UniDeflectMod(nodeRef,(UniDefObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}

void UniDeflectMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
	{
	ParticleObject *obj = GetParticleInterface(os->obj);
	if (obj) {
		deflect.obj  = (UniDefObject*)GetWSMObject(t);
		deflect.node = nodeRef;
		deflect.obj->tmValid.SetEmpty();		
		deflect.obj->mValid.SetEmpty();
		deflect.badmesh=(deflect.obj->custnode==NULL);
		if (t<=deflect.obj->t) deflect.obj->lastrnd=12345;
		deflect.obj->t=t;
/*		if (deflect.obj->dmesh) delete deflect.obj->dmesh;
		deflect.obj->dmesh=NULL;
		deflect.obj->vnorms.ZeroCount();deflect.obj->vnorms.Shrink();
		deflect.obj->fnorms.ZeroCount();deflect.obj->fnorms.Shrink();
		deflect.obj->nv=0;deflect.obj->nf=0;
		*/
		deflect.obj->dvel=Zero;
		obj->ApplyCollisionObject(&deflect);
		}
	}
 static TriObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}

 #define EPSILON	0.0001f

int RayIntersect(Ray& ray, float& at, Point3& norm,Mesh *amesh,VNormal* vnorms,Point3 *fnorms)
	{
	DWORD fi;
	Point3 bary;
	Face *face = amesh->faces;	
	Point3 v0, v1, v2;
	Point3 n, sum, p, bry;
	float d, rn, a;
	Matrix3 vTM(1);
	BOOL first = FALSE;
	fi = 0xFFFFFFFF;

	for (int i=0; i<amesh->getNumFaces(); i++,face++) {
		n = fnorms[i];
		
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (rn > -EPSILON) continue;
		
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);

		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;

		// Must be positive...
		if (a < 0.0f) continue;

		// Must be closer than the closest at so far
		if (first) {
			if (a > at) continue;
			}

		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;

		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);

		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;

		// Hit!
		first = TRUE;		
		at    = a;
		fi    = (DWORD)i;		
//		bary.x  = bry.z;
//		bary.y  = bry.x;
//		bary.z  = bry.y;
		bary  = bry;	// DS 3/8/97
		
		// Use interpolated normal instead.
		if (!face->smGroup) {
			norm  = n;
		} else {
			norm = 
				vnorms[face->v[0]].GetNormal(face->smGroup) * bary.x +
				vnorms[face->v[1]].GetNormal(face->smGroup) * bary.y +
				vnorms[face->v[2]].GetNormal(face->smGroup) * bary.z;
			norm = Normalize(norm);
			}
		}

	return first;
	}

void GetVFLst(Mesh* dmesh,VNormal* vnorms,Point3* fnorms)	 
{ int nv=dmesh->getNumVerts();	
  int nf=dmesh->getNumFaces();	
  Face *face = dmesh->faces;
  for (int i=0; i<nv; i++) 
    vnorms[i] = VNormal();
  Point3 v0, v1, v2;
  for (i=0; i<nf; i++,face++) 
  {	// Calculate the surface normal
	v0 = dmesh->verts[face->v[0]];
	v1 = dmesh->verts[face->v[1]];
	v2 = dmesh->verts[face->v[2]];
	fnorms[i] = (v1-v0)^(v2-v1);
	for (int j=0; j<3; j++) 
	   vnorms[face->v[j]].AddNormal(fnorms[i],face->smGroup);
    fnorms[i] = Normalize(fnorms[i]);
  }
  for (i=0; i<nv; i++) 
	vnorms[i].Normalize();
}

void AddMesh(UniDefObject *obj,TriObject *triOb,Matrix3 tm,BOOL nottop)
{ int lastv=obj->nv,lastf=obj->nf;
  obj->nv+=triOb->GetMesh().getNumVerts();
  obj->nf+=triOb->GetMesh().getNumFaces();
  if (!nottop)
    obj->dmesh->DeepCopy(&triOb->GetMesh(),PART_GEOM|PART_TOPO);
  else
  {obj->dmesh->setNumFaces(obj->nf,obj->dmesh->getNumFaces());
   obj->dmesh->setNumVerts(obj->nv,obj->dmesh->getNumVerts());
   tm=tm*obj->invtm;
   for (int vc=0;vc<triOb->GetMesh().getNumFaces();vc++)
   { obj->dmesh->faces[lastf]=triOb->GetMesh().faces[vc];
     for (int vs=0;vs<3;vs++) 
	   obj->dmesh->faces[lastf].v[vs]+=lastv;
     lastf++;}
  }
   for (int vc=0;vc<triOb->GetMesh().getNumVerts();vc++)
   { if (nottop) obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc]*tm;
	 else obj->dmesh->verts[lastv]=triOb->GetMesh().verts[vc];
     lastv++;}
}  

Object *UniDeflectorField::GetSWObject()
{ return obj;
}

BOOL UniDeflectorField::CheckCollision(
		TimeValue t,Point3 &inp, Point3 &vel, float dt, int index,float *ct,BOOL UpdatePastCollide)
{ 	if (badmesh) 
		return(0);
	if (!((obj->mValid.InInterval(t))&&(obj->tmValid.InInterval(t))))
	{	obj->tmValid=FOREVER;
		obj->tm=obj->custnode->GetObjectTM(t,&obj->tmValid);
		obj->tmNoTrans=obj->tm;
		obj->tmNoTrans.NoTrans();
		obj->invtm=Inverse(obj->tm);
		obj->invtmNoTrans=Inverse(obj->tmNoTrans);
		if (obj->dmesh) 
			delete obj->dmesh;
		obj->dmesh=new Mesh;obj->dmesh->setNumFaces(0);
		if (obj->vnorms) 
		{	delete[] obj->vnorms;obj->vnorms=NULL;}
		if (obj->fnorms) 
		{	delete[] obj->fnorms;obj->fnorms=NULL;}
		obj->nv=(obj->nf=0);
		Interval tmpValid=FOREVER;
		obj->ptm=obj->custnode->GetObjectTM(t+(TimeValue)dt,&tmpValid);
		obj->dvel=(Zero*obj->ptm-Zero*obj->tm)/dt;
		Object *pobj; 
		pobj = obj->custnode->EvalWorldState(t).obj;
		obj->mValid=pobj->ObjectValidity(t);
		TriObject *triOb=NULL;
		badmesh=TRUE;
		if ((triOb=IsUseable(pobj,t))!=NULL) 
			AddMesh(obj,triOb,obj->tm,FALSE);
		if (obj->custnode->IsGroupHead())
		{	for (int ch=0;ch<obj->custnode->NumberOfChildren();ch++)
			{	INode *cnode=obj->custnode->GetChildNode(ch);
				if (cnode->IsGroupMember())
				{	pobj = cnode->EvalWorldState(t).obj;
					if ((triOb=IsUseable(pobj,t))!=NULL)
					{	Matrix3 tm=cnode->GetObjectTM(t,&obj->tmValid);
						obj->mValid=obj->mValid & pobj->ObjectValidity(t);
						AddMesh(obj,triOb,tm,TRUE);
					}
				}
			}
		}
		if (obj->nf>0)
		{	obj->vnorms=new VNormal[obj->nv];
			obj->fnorms=new Point3[obj->nf];
			GetVFLst(obj->dmesh,obj->vnorms,obj->fnorms);
			badmesh=FALSE;
		}
		if ((triOb)&&(triOb!=pobj)) 
			triOb->DeleteThis();
 	}
	if (badmesh) 
		return 0;
	float chaos, bounce,bvar,friction,pvel;
	Point3 NVrelL,Vrel,VrelL,pos;
	pos = inp*obj->invtm;
	Vrel=vel-obj->dvel;
	pvel=Length(Vrel);
	VrelL=Vrel*obj->invtmNoTrans;
	NVrelL=Normalize(VrelL);
	Ray ray;
	ray.dir=NVrelL;
	ray.p=pos;
	float at,vinher;Point3 norm;
	int kfound=RayIntersect(ray,at,norm,obj->dmesh,obj->vnorms,obj->fnorms);
	if (!kfound) 
		return 0;

	obj->pblock->GetValue(PB_BOUNCE,t,bounce,FOREVER);
	if (bounce<0.001f) 
		bounce+=0.001f;
	obj->pblock->GetValue(PB_BVAR,t,bvar,FOREVER);
	obj->pblock->GetValue(PB_CHAOS,t,chaos,FOREVER);
	obj->pblock->GetValue(PB_FRICTION,t,friction,FOREVER);
	obj->pblock->GetValue(PB_VELOCITY,t,vinher,FOREVER);
	vinher/=100.0f;

	Point3 id,iw=(id=pos+at*NVrelL)*obj->tm;
	float delta=Length(iw-inp);
	if (delta>dt*pvel) 
		return 0;

	float dti=delta/pvel;
	Point3 wnorm=norm*obj->tmNoTrans;
	Point3 c1,Vreln=Vrel/pvel;
	Point3 Vdirbase=Normalize(Vreln);
	Point3 Vt,c2;
	float q1=DotProd(-Vdirbase,wnorm);
	float theta=(float)acos(q1);
	if (theta>=HalfPI) 
		theta-=PI;
	Point3 zero=Zero;
	if (theta<FLOAT_EPSILON) 
		vel=-vel;
	else 
	{	c1=Normalize((-vel)^wnorm);
		c2=Normalize(wnorm^c1);
		vel=-vel;
		Vt=c2*DotProd(c2,vel);
		RotateOnePoint(&vel.x,&zero.x,&c1.x,2*theta);
		vel=vel+friction*Vt;
	}
    srand(obj->lastrnd);
	vel=vel*bounce*(1-bvar*RND01());
	if (!FloatEQ0(chaos))
	{	theta=(HalfPI-theta)*chaos*RND01();
		Point3 d=Point3(RND11(),RND11(),RND11());
		Point3 c=Normalize(vel^d);
		RotateOnePoint(&vel.x,&zero.x,&c.x,theta);
	}
	if (vinher>0.0f)
	{	Point3 dvel=obj->dvel*vinher; 
		vel=vel+friction*dvel+(1-friction)*DotProd(dvel,wnorm)*wnorm;
	}

	if (UpdatePastCollide)
	{	inp = iw+(dt-dti)*vel;
		if (ct) (*ct) = dt;
	}
	else
	{	inp = iw;
		if (ct) (*ct) = dti;
	}

	obj->lastrnd=rand();
	return TRUE;
}

RefTargetHandle UniDefObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return NULL;
		}
	}

void UniDefObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		}
	}

RefResult UniDefObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) custnode=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				}
			  break;
			}
		default: SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}
#define UNIDEF_CUSTNAME_CHUNK	0x0100

IOResult UniDefObject::Save(ISave *isave)
	{
	isave->BeginChunk(UNIDEF_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();
	return IO_OK;
	}

IOResult UniDefObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	// Default names
	custname = TSTR(_T(" "));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case UNIDEF_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\suprprts\suprprts.h ===
#ifndef __SUPERPRTS__H
#define __SUPERPRTS__H

#include "Max.h"
#include "sprts.h"
#include "Simpobj.h"

TCHAR *GetString(int id);

extern ClassDesc* GetPArrayDesc();
extern ClassDesc* GetPBombObjDesc();
extern ClassDesc* GetPBombModDesc();
extern ClassDesc* GetSphereDefDesc();
extern ClassDesc* GetSphereDefModDesc();
extern ClassDesc* GetSuprSprayDesc();
extern ClassDesc* GetBlizzardDesc();
extern ClassDesc* GetPFollowDesc();
extern ClassDesc* GetPFollowModDesc();
extern ClassDesc* GetUniDefDesc();
extern ClassDesc* GetUniDefModDesc();
extern ClassDesc* GetPCloudDesc();
#define A_RENDER			A_PLUGIN1
#define A_NOTREND			A_PLUGIN2

#define APRTS_ROLLUP1_OPEN  (1<<0)
#define APRTS_ROLLUP2_OPEN  (1<<1)
#define APRTS_ROLLUP3_OPEN  (1<<2)
#define APRTS_ROLLUP4_OPEN  (1<<3)
#define APRTS_ROLLUP5_OPEN  (1<<4)
#define APRTS_ROLLUP6_OPEN  (1<<5)
#define APRTS_ROLLUP7_OPEN  (1<<6)
#define APRTS_ROLLUP8_OPEN  (1<<7)

#define APRTS_ROLLUP_FLAGS (APRTS_ROLLUP1_OPEN)

extern HINSTANCE hInstance;
extern int RNDSign();
extern float RND01();
extern float RND11();
extern int RND0x(int maxnum);
extern void slrand (unsigned int seed);
extern int hrand (void);
const float FLOAT_EPSILON=0.005f;
const float HalfPI=1.570796327f;
const float PIOver5=0.62831853f;
const float FTOIEPS=0.000001f;
const float PRECISION_LIMIT=1.0e-15f;
const float SQR2=1.1414f;
//const float SMALL_EPSILON=0.00002f;
const float SMALL_EPSILON=0.005f;
const int row3size=3*sizeof(float);
const Point3 v111=Point3(0.450f,0.218f,0.732f);
const Point3 Zero=Point3(0.0f,0.0f,0.0f); 
const Point3 deftex=Point3(0.5f,0.5f,0.0f);
const int NoAni=-9999;

typedef float Matrix4By4[4][4];
typedef float Matrix3By4[3][4];
typedef struct{
  Point3 spos1,svel1;
  Point3 spos2,svel2;
  int min,min2;
  TimeValue mintime;
  int collide;
} mindata;
typedef struct{
  int lastmin,lastcollide;
}oldipc;
typedef struct
{ Point3 vel;
  int K;
  TimeValue oneframe;
  BOOL inaxis;
}InDirInfo;
typedef struct{
 TimeValue tl;
 int gennum;
} TimeAndGen;
typedef struct{
  Tab<TimeAndGen> tl;
} TimeLst;
typedef Tab<Mtl *>Mtllst;
typedef struct
{ Point3 pts[8];
  Point3 Suboffset;}
ptlst;
typedef struct
{  Tab<ptlst> bpts;
   int numboxes;
} boxlst;
typedef struct
{ float dirchaos,spchaos,scchaos;
  int spsign,scsign,invel,spconst,scconst,axisentered;
  Point3 Axis;
  float axisvar;
} SpawnVars;
typedef struct{
 float val;
 int num;
} limdata;
typedef struct{
 int p1,p2;
} pairs;
typedef struct{
 Box3 bbox;
 int refnum;
}boxplus;
typedef struct{
  TimeValue stuckt;
  Tab<pairs> ppts;
} stuck;

class CollideParticle {
public:
	CollideParticle() {xlst=NULL;bbox=NULL;minpt.collide=-1;stucklist.stuckt=-1;stucklist.ppts.SetCount(5);
						sused=0;ssize=5;}
	~CollideParticle() {stucklist.ppts.SetCount(0);stucklist.ppts.Shrink();}
	pairs *xlst;
	boxplus *bbox;
	int xmaxlen,count,xcnt;
	mindata minpt;
	stuck stucklist;
	int sused,ssize;
	mindata InterPartCollide(ParticleSys &parts,Tab<CollisionObject*> &cobjs,int &remtime,int &stepnum,float B,float Vb,int &t,oldipc &l);
	TimeValue DetectParticleCollsion(ParticleSys &parts,pairs x,int t,float B,float Vb,mindata &tmpdata);
	TimeValue FindMinPartCollide(ParticleSys &parts,int remtime,float B,float Vb);
	int PredetectParticleCollisions();
	void PossibleCollide(int *active,BOOL *used,int acount);
	int FindXLst(int &pos,int num);
	void PossibleYZCollide(int *active,BOOL *used,int acount,int num);
	void RemoveThisPart(int num);
};


class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};
class ParticleMtl: public Material {
	public:
	ParticleMtl();
	};
static ParticleMtl particleMtl;
static Matrix3 ident(1);

#define PARTICLE_R	float(1.0)
#define PARTICLE_G	float(1.0)
#define PARTICLE_B	float(0.0)
#define COLLIDE 2
#define ONDEATH 3
#define EMIT 4

#define NUMNODES 40
#define LOTSOFACES	2000
const int isize=sizeof(int);
const int fsize=sizeof(float);
const int bsize=sizeof(BOOL);
const int NLEN=16;
const int HLEN=4*isize;
typedef TCHAR AName[NLEN];
const float coursedivider=6.0f;


extern void Mult4X4(Matrix4By4 A,Matrix4By4 B,Matrix4By4 C);
extern void RotatePoint(Matrix3By4 Pin,float *Q, float *W,float Theta);
extern void RotateOnePoint(float *Pin,float *Q, float *W,float Theta);
extern float sign(float sval);
extern void MakeInterpRotXform(Matrix3 InTmBegin,Matrix3 InTmEnd,float portion,Matrix3& OutTm);
extern int FloatEQ0(float number);
extern int SmallerEQ0(float number);
extern int FGT0(Point3 p1);
extern void Mult4X1(float *A,Matrix4By4 B,float *C);
extern int MatrixInvert(Matrix4By4 in,Matrix4By4 out);
extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
extern void TurnButton(HWND hWnd,int SpinNum,BOOL ison);
extern void SpinnerOn(HWND hWnd,int SpinNum,int Winnum);
extern void SpinnerOff(HWND hWnd,int SpinNum,int Winnum);
extern Point3 CalcSpread(float divangle,Point3 oldnorm);
const float M=0.1f;
const int RENDTYPE1=0;
const int RENDTYPE2=1;
const int RENDTYPE3=2;
const int RENDTYPE5=3;
const int RENDTYPE6=4;
const int RENDTET=5;
const int REND6PT=6;
const int RENDSPHERE=7;
#define MAXNAME 24
extern float FigureOutSize(TimeValue age,float size,TimeValue grow,TimeValue fade,TimeValue life,float grate,float frate);
extern void AddFace(int a, int b, int c,int face,Mesh *pm,int curmtl);
extern void PlotSpecial(float radius,int vertexnum,int face,Mesh *pm,float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir);
extern void PlotCube8(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3* pt,InDirInfo indir);
extern void Plot6PT(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3* pt,InDirInfo indir);
extern void PlotTet(float radius,int vertexnum,int face, Mesh *pm, float Angle,Point3 W,int curmtl,Point3* pt,InDirInfo indir);
extern void PlotTriangle(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir);
extern void PlotCustom(float radius,int i,int vertexnum,Mesh *pm, float Angle,float *W,Mesh *clst,Point3* pt,int nv,InDirInfo indir);
extern void GetMeshInfo(int type,int count,Mesh *pm,int *numF,int *numV);
extern void PlotFacing(int type,float radius,int vertexnum,int face,Mesh *pm,float Angle,int curmtl,Point3* pt,Point3 camV,Point3 a,Point3 b);
extern void PlotSphere(float radius,int vertexnum,int face, Mesh *pm, float Angle,float *W,int curmtl,Point3 *pt,InDirInfo indir);
extern Point3 RotateAboutAxis(float Angle,Point3 C,Point3 L,Point3 W,InDirInfo indir);
extern void CacheData(ParticleSys *p0,ParticleSys *p1);
extern int TimeFound(TimeLst times,int showframe,int gen);
extern TimeValue GetCurTime(TimeValue showframe,TimeValue ages,int anifr);
extern float Smallest(Point3 pmin);
extern float Largest(Point3 pmax);
extern TriObject *TriIsUseable(Object *pobj,TimeValue t);
extern void VectorVar(Point3 *vel,float R,float MaxAngle);
extern Point3 DoSpawnVars(SpawnVars spvars,Point3 pv,Point3 holdv,float *radius,Point3 *sW);
extern void SpinStuff(HWND hWnd,BOOL ison,BOOL isphase);
extern void StdStuff(HWND hWnd,BOOL ison);
extern void MetaOff(HWND hWnd);
extern void InstStuff(HWND hWnd,BOOL ison,HWND hparam,HWND spawn,BOOL dist=0);
extern void SpawnStuff(HWND hWnd,int stype);
extern void SpinMainStuff(HWND hWnd,BOOL ison);
extern BOOL IsStdMtl(INode *cnode);
extern void MakeNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t);
extern void MakeGroupNodeList(INode *node,INodeTab *ntab,int subtree,TimeValue t);
extern void FormatName(TCHAR *name);
extern void SpawnWithStype(int stype,HWND spawn,int repi);
extern void ObjectMutQueOn(int stype,HWND spawn,int repi);
extern void ObjectMutQueOff(HWND spawn);
extern void SetFlag(ULONG &flags,ULONG f, ULONG val);
extern void ZeroMesh(Mesh *pm);
extern BOOL ReadInt(int *buf,FILE *f);
extern BOOL WriteInt(int *buf,FILE *f);
extern BOOL GenNewSaveFile(int osize,int size,int custsettings,FILE *f,TCHAR *filename,int vers);
extern void SwitchVerts(Mesh *pm);
extern void AllSpawnBad(HWND hWnd,int stype,BOOL notbad);
extern BOOL CheckMtlChange(Mtl *mtl,BOOL wasmulti);
extern float GetLen(Point3 vels,int K);
extern void IPCControls(HWND hWnd,HWND spwnd,int stype,BOOL ison);
extern BOOL IsGEOM(Object *obj);
extern void MirrorFace(Face *f);
extern void MirrorTVs(TVFace *f);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\SurfWrap\wrap.h ===
#ifndef __WRAP__H
#define __WRAP__H

#include "Max.h"
#include "resource.h"

extern HINSTANCE hInstance;

const float EPS=0.1f;
#define BIGFLOAT	float(999999)
TCHAR *GetString(int id);
extern float Check1to1(float x);

extern ClassDesc* GetSWrapDesc();
extern ClassDesc* GetSWrapModDesc();
//extern ClassDesc* GetMSWrapModDesc();

extern BOOL CALLBACK DefaultSOTProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\SurfWrap\surfwrap.cpp ===
/**********************************************************************
 *<
	FILE: surfwrap.cpp

	DESCRIPTION: Wrap one surface over another space warp

	CREATED BY: Audrey Peterson

	HISTORY: 1/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "wrap.h"
#include "iparamm.h"
#include "simpmod.h"
#include "simpobj.h"
#include "shape.h"
#include "spline3d.h"
#include "splshape.h"
#include "texutil.h"
#include "surf_api.h"

#define PBLK		0
#define CUSTNODE 		1
#define DU 0.001f
static Point3 Zero=Point3(0.0f,0.0f,0.0f);
static Class_ID SWRAP_CLASS_ID(0x3de109fc, 0x40371016);
static Class_ID SWRAPMOD_CLASS_ID(0x20dc0b59, 0x437a5d7c);

class VNormal {
	public:
		Point3 norm;
		DWORD smooth;
		VNormal *next;
		BOOL init;

		VNormal() {smooth=0;next=NULL;init=FALSE;norm=Point3(0,0,0);}
		VNormal(Point3 &n,DWORD s) {next=NULL;init=TRUE;norm=n;smooth=s;}
		~VNormal() {delete next;}
		void AddNormal(Point3 &n,DWORD s);
		Point3 &GetNormal(DWORD s);
		void Normalize();
	};

void VNormal::AddNormal(Point3 &n,DWORD s)
	{
	if (!(s&smooth) && init) {
		if (next) next->AddNormal(n,s);
		else {
			next = new VNormal(n,s);
			}
	} else {
		norm   += n;
		smooth |= s;
		init    = TRUE;
		}
	}

Point3 &VNormal::GetNormal(DWORD s)
	{
	if (smooth&s || !next) return norm;
	else return next->GetNormal(s);	
	}

void VNormal::Normalize()
	{
	VNormal *ptr = next, *prev = this;
	while (ptr) {
		if (ptr->smooth&smooth) {
			norm += ptr->norm;			
			prev->next = ptr->next;
			delete ptr;
			ptr = prev->next;
		} else {
			prev = ptr;
			ptr  = ptr->next;
			}
		}
	norm = ::Normalize(norm);
	if (next) next->Normalize();
	}

class SWrapPickOperand;

class SWrapObject : public SimpleWSMObject {	
	public:		
		static IParamMap *pmapParam;
		static IObjParam *ip;
		static HWND hSot;
		static HWND hParams;
		Interval cmValid;
		Mesh *cmesh;
		Matrix3 tm;
		Tab<VNormal> vnorms;
		Tab<Point3> fnorms;

		INode *custnode;
		TSTR custname;
		SWrapObject();
		~SWrapObject();
		static BOOL creating;
		static SWrapPickOperand pickCB;

		void ShowName();
		// From Animatable		
		void DeleteThis() {delete this;}		
		void BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);		
		Class_ID ClassID() {return SWRAP_CLASS_ID;}		
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_SWRAPOBJ);}
				
		// from object		
		CreateMouseCallBack* GetCreateMouseCallBack() {return NULL;}
		
		// From SimpleWSMObject		
		void InvalidateUI();		
		void BuildMesh(TimeValue t);
		ParamDimension *GetParameterDim(int pbIndex);
		TSTR GetParameterName(int pbIndex);		
		
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		// From WSMObject
		Modifier *CreateWSMMod(INode *node);		
		int NumRefs() {return 2;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);		
		RefResult NotifyRefChanged( Interval changeInt,RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);
	};
class SWrapPickOperand : 
		public PickModeCallback,
		public PickNodeCallback {
	public:		
		SWrapObject *po;
		
		SWrapPickOperand() {po=NULL;}

		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);

		void EnterMode(IObjParam *ip);
		void ExitMode(IObjParam *ip);

		BOOL RightClick(IObjParam *ip, ViewExp *vpt) { return TRUE; }
		BOOL Filter(INode *node);
		
		PickNodeCallback *GetFilter() {return this;}
	};

//--- ClassDescriptor and class vars ---------------------------------

IObjParam *SWrapObject::ip        = NULL;
IParamMap *SWrapObject::pmapParam = NULL;
HWND       SWrapObject::hSot      = NULL;
HWND       SWrapObject::hParams      = NULL;
BOOL SWrapObject::creating    = FALSE;
SWrapPickOperand SWrapObject::pickCB;

class SWrapClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) { return new SWrapObject;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_SWRAP);}
	SClass_ID		SuperClassID() {return WSM_OBJECT_CLASS_ID; }
	Class_ID		ClassID() {return SWRAP_CLASS_ID;}
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	int 			BeginCreate(Interface *i);
	int 			EndCreate(Interface *i);
	};
static SWrapClassDesc SWrapDesc;
ClassDesc* GetSWrapDesc() {return &SWrapDesc;}

//--- DeflectMod -----------------------------------------------------

class SWrapMod : public SimpleWSMMod {
	public:				

		SWrapMod() {}
		SWrapMod(INode *node,SWrapObject *obj);	

		// From Animatable
		void GetClassName(TSTR& s) {s= GetString(IDS_AP_SWRAPMOD);}
		SClass_ID SuperClassID() {return WSM_CLASS_ID;}
		void DeleteThis() {delete this;}
		Class_ID ClassID() { return SWRAPMOD_CLASS_ID;}
		RefTargetHandle Clone(RemapDir& remap = NoRemap());
		TCHAR *GetObjectName() {return GetString(IDS_AP_SWRAPBINDING);}

		void ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);

		// From SimpleWSMMod		
		Interval GetValidity(TimeValue t);		
		Deformer& GetDeformer(TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat);
	};

//--- ClassDescriptor and class vars ---------------------------------

class SWrapModClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 0;}
	void *			Create(BOOL loading = FALSE) { return new SWrapMod;}
	const TCHAR *	ClassName() {return GetString(IDS_AP_SWRAPMOD);}
	SClass_ID		SuperClassID() {return WSM_CLASS_ID; }
	Class_ID		ClassID() {return SWRAPMOD_CLASS_ID;}
	const TCHAR* 	Category() {return GetSpaceWarpCatString(SPACEWARP_CAT_GEOMDEF);}
	};

static SWrapModClassDesc SWrapModDesc;
ClassDesc* GetSWrapModDesc() {return &SWrapModDesc;}
//--- Parameter map/block descriptors -------------------------------

#define PB_KIDEFAULT		0
#define PB_USESELVERTS		1
#define PB_ICONSIZE			2
#define PB_STANDOFF			3

//
//
// Parameters

static ParamUIDesc descParam[] = {
	// Default Projection Distance Ki
	ParamUIDesc(
		PB_KIDEFAULT,
		EDITTYPE_FLOAT,
		IDC_AP_KIDEFAULT,IDC_AP_KIDEFAULTSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Use Selected Vertices ONLY
	ParamUIDesc(PB_USESELVERTS,TYPE_SINGLECHEKBOX,IDC_AP_USESELVERTS),

	// Icon Size
	ParamUIDesc(
		PB_ICONSIZE,
		EDITTYPE_FLOAT,
		IDC_AP_ICONSIZE,IDC_AP_ICONSIZESPIN,
		0.0f,BIGFLOAT,
		SPIN_AUTOSCALE),

	// Standoff Distance
	ParamUIDesc(
		PB_STANDOFF,
		EDITTYPE_FLOAT,
		IDC_AP_STANDOFF,IDC_AP_STANDOFFSPIN,
		-BIGFLOAT,BIGFLOAT,
		SPIN_AUTOSCALE),
	};
#define PARAMDESC_LENGTH 4


static ParamBlockDescID SWrapdescVer0[] = {
	{ TYPE_FLOAT, NULL, TRUE, 0 },
	{ TYPE_INT, NULL, TRUE, 1 },
	{ TYPE_FLOAT, NULL, FALSE, 2 }, //ICON size
	{ TYPE_FLOAT, NULL, TRUE, 3 },
	};

#define PBLOCK_LENGTH	4

#define NUM_OLDVERSIONS	0

// Current version
#define CURRENT_VERSION	0

static ParamVersionDesc curVersion(SWrapdescVer0,PBLOCK_LENGTH,CURRENT_VERSION);

class CreateSWrapObjectProc : public MouseCallBack,ReferenceMaker {
	private:
		IObjParam *ip;
		void Init(IObjParam *i) {ip=i;}
		CreateMouseCallBack *createCB;	
		INode *SWrapNode;
		SWrapObject *SWrapObj;
		int attachedToNode;
		IObjCreate *createInterface;
		ClassDesc *cDesc;
		Matrix3 mat;  // the nodes TM relative to the CP
		Point3 p0,p1;
		IPoint2 sp0, sp1;
		BOOL square,dostuff;

		int ignoreSelectionChange;

		int lastPutCount;
		void CreateNewObject();	

		int NumRefs() { return 1; }
		RefTargetHandle GetReference(int i) { return (RefTargetHandle)SWrapNode; } 
		void SetReference(int i, RefTargetHandle rtarg) { SWrapNode = (INode *)rtarg; }

		// StdNotifyRefChanged calls this, which can change the partID to new value 
		// If it doesnt depend on the particular message& partID, it should return
		// REF_DONTCARE
		BOOL SupportAutoGrid(){return TRUE;}
	    RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
	public:
		void Begin( IObjCreate *ioc, ClassDesc *desc );
		void End();
		
		CreateSWrapObjectProc()
			{
			ignoreSelectionChange = FALSE;
			}
		int createmethod(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat);
		int proc( HWND hwnd, int msg, int point, int flag, IPoint2 m );
	};


#define CID_CREATESWRAPOBJECTMODE	CID_USER + 25

class CreateSWrapObjectMode : public CommandMode {		
	public:		
		CreateSWrapObjectProc proc;
		IObjParam *ip;
		SWrapObject *obj;
		void Begin( IObjCreate *ioc, ClassDesc *desc ) { proc.Begin( ioc, desc ); }
		void End() { proc.End(); }
		void JumpStart(IObjParam *i,SWrapObject*o);

		int Class() {return CREATE_COMMAND;}
		int ID() { return CID_CREATESWRAPOBJECTMODE; }
		MouseCallBack *MouseProc(int *numPoints) {*numPoints = 10000; return &proc;}
		ChangeForegroundCallback *ChangeFGProc() {return CHANGE_FG_SELECTED;}
		BOOL ChangeFG( CommandMode *oldMode ) { return (oldMode->ChangeFGProc() != CHANGE_FG_SELECTED); }
		void EnterMode() {/*MakeRefByID(FOREVER,0,svNode);*/}
		void ExitMode() {/*DeleteAllRefsFromMe();*/}
	};
static CreateSWrapObjectMode theCreateSWrapObjectMode;

RefResult CreateSWrapObjectProc::NotifyRefChanged(
	Interval changeInt, 
	RefTargetHandle hTarget, 
	PartID& partID,  
	RefMessage message) 
	{
	switch (message) {
		case REFMSG_PRENOTIFY_PASTE:
		case REFMSG_TARGET_SELECTIONCHANGE:
		 	if ( ignoreSelectionChange ) {
				break;
				}
		 	if ( SWrapObj && SWrapNode==hTarget ) {
				// this will set camNode== NULL;
				theHold.Suspend();
				DeleteReference(0);
				theHold.Resume();
				goto endEdit;
				}
			// fall through

		case REFMSG_TARGET_DELETED:		
			if (SWrapObj && SWrapNode==hTarget ) {
				endEdit:
				if (createInterface->GetCommandMode()->ID() == CID_STDPICK) 
				{ if (SWrapObj->creating) 
						{  theCreateSWrapObjectMode.JumpStart(SWrapObj->ip,SWrapObj);
							createInterface->SetCommandMode(&theCreateSWrapObjectMode);
					    } 
				  else {createInterface->SetStdCommandMode(CID_OBJMOVE);}
				}
#ifdef _OSNAP
				SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				SWrapObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
				SWrapObj  = NULL;				
				SWrapNode    = NULL;
				CreateNewObject();	
				attachedToNode = FALSE;
				}
			break;		
		}
	return REF_SUCCEED;
	}

void CreateSWrapObjectProc::Begin( IObjCreate *ioc, ClassDesc *desc )
	{
	createInterface = ioc;
	cDesc           = desc;
	attachedToNode  = FALSE;
	createCB        = NULL;
	SWrapNode         = NULL;
	SWrapObj       = NULL;
	dostuff=0;
	CreateNewObject();
	}
void CreateSWrapObjectProc::CreateNewObject()
	{
	SWrapObj = (SWrapObject*)cDesc->Create();
	lastPutCount  = theHold.GetGlobalPutCount();
	
	// Start the edit params process
	if ( SWrapObj ) {
		SWrapObj->BeginEditParams( (IObjParam*)createInterface, BEGIN_EDIT_CREATE, NULL );
#ifdef _OSNAP
		SWrapObj->SetAFlag(A_OBJ_LONG_CREATE);
#endif
		}	
	}

//LACamCreationManager::~LACamCreationManager
void CreateSWrapObjectProc::End()
{ if ( SWrapObj ) { 
#ifdef _OSNAP
		SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
	SWrapObj->EndEditParams( (IObjParam*)createInterface, 
	                    	          END_EDIT_REMOVEUI, NULL);
		if ( !attachedToNode ) 
		{	// RB 4-9-96: Normally the hold isn't holding when this 
			// happens, but it can be in certain situations (like a track view paste)
			// Things get confused if it ends up with undo...
			theHold.Suspend(); 
			delete SWrapObj;
			SWrapObj = NULL;
			theHold.Resume();
			if (theHold.GetGlobalPutCount()!=lastPutCount) 
				GetSystemSetting(SYSSET_CLEAR_UNDO);
		} 
 else if ( SWrapNode ) {
			 // Get rid of the reference.
			theHold.Suspend();
			DeleteReference(0);  // sets camNode = NULL
			theHold.Resume();
			}
	}
}

void CreateSWrapObjectMode::JumpStart(IObjParam *i,SWrapObject *o)
	{
	ip  = i;
	obj = o;
	//MakeRefByID(FOREVER,0,svNode);
	obj->BeginEditParams(i,BEGIN_EDIT_CREATE,NULL);
	}


int SWrapClassDesc::BeginCreate(Interface *i)
	{	
	IObjCreate *iob = i->GetIObjCreate();
	theCreateSWrapObjectMode.Begin(iob,this);
	iob->PushCommandMode(&theCreateSWrapObjectMode);
	return TRUE;
	}

int SWrapClassDesc::EndCreate(Interface *i)
	{
	theCreateSWrapObjectMode.End();
	i->RemoveMode(&theCreateSWrapObjectMode);
	return TRUE;
	}

int CreateSWrapObjectProc::createmethod(
		ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
	{	Point3 d;

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif

#ifdef _OSNAP
	if (msg == MOUSE_FREEMOVE)
	{ vpt->SnapPreview(m,m,NULL, snapdim);
	}
#endif
	if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
		switch(point) {
			case 0:
				sp0 = m;
				p0  = vpt->SnapPoint(m,m,NULL,snapdim);
				mat.SetTrans(p0);
				SWrapObj->pblock->SetValue(PB_ICONSIZE,0,0.01f);
				SWrapObj->pmapParam->Invalidate();
				break;

			case 1: {
				mat.IdentityMatrix();
				sp1 = m;
				p1  = vpt->SnapPoint(m,m,NULL,snapdim);
				Point3 center = (p0+p1)/float(2);
				mat.SetTrans(center);
				SWrapObj->pblock->SetValue(PB_ICONSIZE,0,Length(p1-p0));
				SWrapObj->pmapParam->Invalidate();

				if (msg==MOUSE_POINT) {
					if (Length(m-sp0)<3) {						
						return CREATE_ABORT;
					} else {
					ICustButton *iBut = GetICustButton(GetDlgItem(SWrapObj->hParams,IDC_AP_WRAPBUTTON));
					iBut->Enable();
					ReleaseICustButton(iBut);
						return CREATE_STOP;
						}
					}
				break;
				}

			}
	} else {
		if (msg == MOUSE_ABORT)
			return CREATE_ABORT;
		}	
	return TRUE;
	}

int CreateSWrapObjectProc::proc(HWND hwnd,int msg,int point,int flag,
				IPoint2 m )
{	int res=TRUE;	
	ViewExp *vpx = createInterface->GetViewport(hwnd); 
	assert( vpx );

#ifdef _3D_CREATE
	DWORD snapdim = SNAP_IN_3D;
#else
	DWORD snapdim = SNAP_IN_PLANE;
#endif
	switch ( msg ) {
		case MOUSE_POINT:
			switch ( point ) {
				case 0:
					assert( SWrapObj );					
					vpx->CommitImplicitGrid(m, flag );
					if ( createInterface->SetActiveViewport(hwnd) ) {
						return FALSE;
						}

					if (createInterface->IsCPEdgeOnInView()) { 
						res = FALSE;
						goto done;
						}

					if ( attachedToNode ) {
				   		// send this one on its way
#ifdef _OSNAP
                    SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
				   		SWrapObj->EndEditParams( (IObjParam*)createInterface, 0, NULL);
						if (SWrapNode) {
							theHold.Suspend();
							DeleteReference(0);
							theHold.Resume();
							}

						// new object
						CreateNewObject();   // creates SWrapObj
						}

				   	theHold.Begin();	 // begin hold for undo
					mat.IdentityMatrix();

					// link it up
					SWrapNode = createInterface->CreateObjectNode( SWrapObj);
					attachedToNode = TRUE;
					assert( SWrapNode );					
					createCB = NULL;
					createInterface->SelectNode( SWrapNode );
					
					// Reference the new node so we'll get notifications.
					theHold.Suspend();
					MakeRefByID( FOREVER, 0, SWrapNode);
					theHold.Resume();
					mat.IdentityMatrix();
				default:				
					res = createmethod(vpx,msg,point,flag,m,mat);
					createInterface->SetNodeTMRelConstPlane(SWrapNode, mat);
					if (res==CREATE_ABORT)
						goto abort;
					if (res==CREATE_STOP){
#ifdef _OSNAP
                        SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
						theHold.Accept(GetString(IDS_AP_CREATE));	
					}
					createInterface->RedrawViews(createInterface->GetTime()); 
					break;
				}			
			break;

		case MOUSE_MOVE:
			res = createmethod(vpx,msg,point,flag,m,mat);
			createInterface->SetNodeTMRelConstPlane(SWrapNode, mat);
			if (res==CREATE_ABORT)
				goto abort;
			if (res==CREATE_STOP){
#ifdef _OSNAP
               SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
			   theHold.Accept(GetString(IDS_AP_CREATE));	
			}
			createInterface->RedrawViews(createInterface->GetTime()); 
		break;

/*			res = createmethod(vpx,msg,point,flag,m,mat);
			createInterface->SetNodeTMRelConstPlane(SWrapNode, mat);
			if (res==CREATE_ABORT)
				goto abort;
			if (res==CREATE_STOP)
				theHold.Accept(GetString(IDS_AP_CREATE));	
			createInterface->RedrawViews(createInterface->GetTime()); 
		break;*/
	case MOUSE_PROPCLICK:
		createInterface->SetStdCommandMode(CID_OBJMOVE);
		break;
	case MOUSE_ABORT: 
	abort:
		assert( SWrapObj );
#ifdef _OSNAP
			SWrapObj->ClearAFlag(A_OBJ_LONG_CREATE);
#endif
		SWrapObj->EndEditParams( (IObjParam*)createInterface,0,NULL);
		theHold.Cancel();	 // deletes both the object and target.
		if (theHold.GetGlobalPutCount()!=lastPutCount) 
					GetSystemSetting(SYSSET_CLEAR_UNDO);
		SWrapNode = NULL;			
		createInterface->RedrawViews(createInterface->GetTime()); 
		CreateNewObject();	
		attachedToNode = FALSE;
		res = FALSE;
		break;
	case MOUSE_FREEMOVE:
			SetCursor(LoadCursor(hInstance, MAKEINTRESOURCE(IDC_CROSS_HAIR)));
#ifdef _OSNAP  //PREVIEW SNAP
			res = createmethod(vpx,msg,point,flag,m,mat);
#endif
		vpx->TrackImplicitGrid(m);
			break;

		}
	done:
	if ((res == CREATE_STOP)||(res==CREATE_ABORT))
		vpx->ReleaseImplicitGrid();
	createInterface->ReleaseViewport(vpx); 
	return res;
	}

static BOOL IsGEOM(Object *obj)
{ if (obj!=NULL) 
  { if (obj->SuperClassID()==GEOMOBJECT_CLASS_ID)
    { if (obj->IsSubClassOf(triObjectClassID)) 
        return TRUE;
      else 
	  { if (obj->CanConvertToType(triObjectClassID)) 
	  	return TRUE;			
	  }
	}
  }
  return FALSE;
}

BOOL SWrapPickOperand::Filter(INode *node)
	{
	if (node)
	{ ObjectState os = node->GetObjectRef()->Eval(po->ip->GetTime());
	  if (!IsGEOM(os.obj)) 
	  {		node = NULL;
			return FALSE;
	  }
	node->BeginDependencyTest();
	po->NotifyDependents (FOREVER, 0, REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;

	}
	return node ? TRUE : FALSE;
	}

BOOL SWrapPickOperand::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{	
	INode *node = ip->PickNode(hWnd,m,this);
	
	if (node) 
	{	ObjectState os = node->GetObjectRef()->Eval(ip->GetTime());
	  if (!IsGEOM(os.obj)) 
		{	node = NULL;
			return FALSE;
			}
	node->BeginDependencyTest();
	po->NotifyDependents(FOREVER,0,REFMSG_TEST_DEPENDENCY);
	if (node->EndDependencyTest()) return FALSE;
	}
	return node ? TRUE : FALSE;
	}

void SWrapObject::ShowName()
{TSTR name=TSTR(GetString(IDS_AP_OBJECTSTR)) + (custnode ? custname : TSTR(GetString(IDS_AP_NONE)));
SetWindowText(GetDlgItem(hParams, IDC_AP_WRAPPICKOBJ), name);
}

BOOL SWrapPickOperand::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	assert(node);
	INodeTab nodes;
	nodes.SetCount(1);nodes[0]=node;
	ip->FlashNodes(&nodes);
	if (po->custnode) po->ReplaceReference(CUSTNODE,node,TRUE);
	else po->MakeRefByID(FOREVER,CUSTNODE,node);	
	po->custname = TSTR(node->GetName());
	// Automatically check show result and do one update
	po->cmValid.SetEmpty();
	po->pmapParam->Invalidate();
	po->ShowName();	
	po->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
	if (po->creating) {
		theCreateSWrapObjectMode.JumpStart(ip,po);
		ip->SetCommandMode(&theCreateSWrapObjectMode);
		ip->RedrawViews(ip->GetTime());
		return FALSE;
	} else {
		return TRUE;
		}
	}

void SWrapPickOperand::EnterMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_AP_WRAPBUTTON));
	if (iBut) iBut->SetCheck(TRUE);
	ReleaseICustButton(iBut);
	GetCOREInterface()->PushPrompt(GetString(IDS_AP_PICKMODE));
	}

void SWrapPickOperand::ExitMode(IObjParam *ip)
	{
	ICustButton *iBut;
	iBut=GetICustButton(GetDlgItem(po->hParams,IDC_AP_WRAPBUTTON));
	if (iBut) iBut->SetCheck(FALSE);
	ReleaseICustButton(iBut);
    GetCOREInterface()->PopPrompt();
	}
class SWrapObjectDlgProc : public ParamMapUserDlgProc {
	public:
		SWrapObject *po;

		SWrapObjectDlgProc(SWrapObject *p) {po=p;}
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);
		void Update(TimeValue t);
		void DeleteThis() {delete this;}
	};

void SWrapObjectDlgProc::Update(TimeValue t)
{ float size;
	po->pblock->GetValue(PB_ICONSIZE,0,size,FOREVER);
	ICustButton *iBut = GetICustButton(GetDlgItem(po->hParams,IDC_AP_WRAPBUTTON));
	if (size<0.01f) iBut->Disable(); else iBut->Enable();
	ReleaseICustButton(iBut);
	po->ShowName();
}

BOOL SWrapObjectDlgProc::DlgProc(
		TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{int FToTick=(int)((float)TIME_TICKSPERSEC/(float)GetFrameRate());
	switch (msg) {
		case WM_INITDIALOG: {
			ICustButton *iBut = GetICustButton(GetDlgItem(hWnd,IDC_AP_WRAPBUTTON));
			iBut->SetType(CBT_CHECK);
			iBut->SetHighlightColor(GREEN_WASH);
			ReleaseICustButton(iBut);
			po->hParams=hWnd;
			Update(t);
			return FALSE;	// stop default keyboard focus - DB 2/27  
			}
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{    case IDC_AP_WRAPBUTTON:
				   { if (po->ip->GetCommandMode()->ID() == CID_STDPICK) 
					{ if (po->creating) 
						{  theCreateSWrapObjectMode.JumpStart(po->ip,po);
							po->ip->SetCommandMode(&theCreateSWrapObjectMode);
						} else {po->ip->SetStdCommandMode(CID_OBJMOVE);}
					} else 
						{ po->pickCB.po = po;						
						  po->ip->SetPickMode(&po->pickCB);
						}
					break;
				}

			}
			break;	
		}
	return TRUE;
	}

SWrapObject::SWrapObject()
{ TimeValue tpf=GetTicksPerFrame();
	MakeRefByID(FOREVER, 0, 
		CreateParameterBlock(SWrapdescVer0, PBLOCK_LENGTH, CURRENT_VERSION));
	assert(pblock);	

	cmValid.SetEmpty();
	srand(12345);
	custname=TSTR(_T(" "));
	custnode=NULL;
	cmesh=NULL;
	tm.IdentityMatrix();
	vnorms.ZeroCount();
	fnorms.ZeroCount();
	pblock->SetValue(PB_KIDEFAULT,0,0.0f);
	pblock->SetValue(PB_USESELVERTS,0,0);
	pblock->SetValue(PB_STANDOFF,0,1.0f);
}

SWrapObject::~SWrapObject()
{ pblock=NULL;
  DeleteAllRefsFromMe();
  if (cmesh) delete cmesh;
  vnorms.SetCount(0);vnorms.Shrink();
  fnorms.SetCount(0);fnorms.Shrink();
}

Modifier *SWrapObject::CreateWSMMod(INode *node)
	{
	return new SWrapMod(node,this);
	}

RefTargetHandle SWrapObject::Clone(RemapDir& remap) 
	{
	SWrapObject* newob = new SWrapObject();	
	newob->ReplaceReference(0,pblock->Clone(remap));
	if (custnode) newob->ReplaceReference(CUSTNODE,custnode);
	return newob;
	}

void SWrapObject::BeginEditParams(
		IObjParam *ip,ULONG flags,Animatable *prev)
	{
	this->ip = ip;
	if (flags&BEGIN_EDIT_CREATE) {
		creating = TRUE;
	} else { creating = FALSE; }

	if (pmapParam) {		
		// Left over
		pmapParam->SetParamBlock(pblock);
	} else {		
		hSot = ip->AddRollupPage( 
			hInstance, 
			MAKEINTRESOURCE(IDD_SW_DESC),
			DefaultSOTProc,
			GetString(IDS_AP_TOP), 
			(LPARAM)ip,APPENDROLL_CLOSED);

		// Gotta make a new one.
		pmapParam = CreateCPParamMap(
			descParam,PARAMDESC_LENGTH,
			pblock,
			ip,
			hInstance,
			MAKEINTRESOURCE(IDD_AP_SURFWRAP),
			GetString(IDS_AP_PARAMETERS),
			0);
		}
		if (pmapParam)
			pmapParam->SetUserDlgProc(new SWrapObjectDlgProc(this));
	}

void SWrapObject::EndEditParams(
		IObjParam *ip, ULONG flags,Animatable *next)
	{		
//	SimpleWSMObject::EndEditParams(ip,flags,next);
	this->ip = NULL;

	if (flags&END_EDIT_REMOVEUI ) {		
		DestroyCPParamMap(pmapParam);
		ip->DeleteRollupPage(hSot);
		pmapParam = NULL;		
		}	
	ip->ClearPickMode();
	ip= NULL;
	creating = FALSE;
	}

void SWrapObject::BuildMesh(TimeValue t)
{	ivalid = FOREVER;
	float width;
	pblock->GetValue(PB_ICONSIZE,t,width,ivalid);
	float hwidth;
	width  *= 0.5f;
	hwidth =width*0.5f;

	mesh.setNumVerts(10);
	mesh.setNumFaces(5);
	mesh.setVert(0, Point3(width,width, width));
	mesh.setVert(1, Point3(-width, width, width));
	mesh.setVert(2, Point3(-width, -width, width));
	mesh.setVert(3, Point3( width, -width,width));
	mesh.setVert(4, Point3( 0.0f, 0.0f,width));
	mesh.setVert(5, Point3( 0.0f, 0.0f,-width));
	mesh.setVert(6, Point3(hwidth, 0.0f,-hwidth));
	mesh.setVert(7, Point3(-hwidth, 0.0f,-hwidth));
	mesh.setVert(8, Point3(0.0f,hwidth,-hwidth));
	mesh.setVert(9, Point3(0.0f,-hwidth,-hwidth));

	mesh.faces[0].setVerts(3,0,1);
	mesh.faces[0].setEdgeVisFlags(1,1,0);
	mesh.faces[0].setSmGroup(0);

	mesh.faces[1].setEdgeVisFlags(1,1,0);
	mesh.faces[1].setSmGroup(0);
	mesh.faces[1].setVerts(1,2,3);

	mesh.faces[2].setEdgeVisFlags(1,1,1);
	mesh.faces[2].setSmGroup(0);
	mesh.faces[2].setVerts(5,6,7);

	mesh.faces[3].setEdgeVisFlags(1,1,1);
	mesh.faces[3].setSmGroup(0);
	mesh.faces[3].setVerts(5,8,9);

	mesh.faces[4].setEdgeVisFlags(0,1,0);
	mesh.faces[4].setSmGroup(0);
	mesh.faces[4].setVerts(3,4,5);

	mesh.InvalidateGeomCache();
}

void SWrapObject::InvalidateUI() 
	{
	if (pmapParam) pmapParam->Invalidate();
	}

ParamDimension *SWrapObject::GetParameterDim(int pbIndex) 
	{
	switch (pbIndex) {		
		case PB_ICONSIZE:
		case PB_STANDOFF:
		case PB_KIDEFAULT:	 return stdWorldDim;
		default: return defaultDim;
		}
	}

TSTR SWrapObject::GetParameterName(int pbIndex) 
	{
	switch (pbIndex) {				
		case PB_KIDEFAULT: 	return GetString(IDS_AP_KIDEFAULT);
		case PB_USESELVERTS: 	return GetString(IDS_AP_SELVERTS);
		case PB_ICONSIZE: 	return GetString(IDS_AP_ICONSIZE);
		case PB_STANDOFF: 	return GetString(IDS_AP_STANDOFF);
		default: 			return TSTR(_T(""));
		}
	}

//--- DeflectMod methods -----------------------------------------------

SWrapMod::SWrapMod(INode *node,SWrapObject *obj)
	{	
//	MakeRefByID(FOREVER,SIMPWSMMOD_OBREF,obj);
	MakeRefByID(FOREVER,SIMPWSMMOD_NODEREF,node);	
	pblock = NULL;
	obRef=NULL;
	}

Interval SWrapMod::GetValidity(TimeValue t) 
{ 	if (obRef && nodeRef)
	{	Interval valid = FOREVER;
		Matrix3 tm;
		float f;		
		SWrapObject *obj = (SWrapObject*)GetWSMObject(t);
		if (obj->custnode) 
		{ valid=obj->cmValid; 	}
		obj->pblock->GetValue(PB_KIDEFAULT,t,f,valid);
		obj->pblock->GetValue(PB_STANDOFF,t,f,valid);
		tm = nodeRef->GetObjectTM(t,&valid);
		return valid;
	} else {return FOREVER;	}
}

class SWrapDeformer : public Deformer {
	public:		
		Point3 Map(int i, Point3 p) {return p;}
	};
static SWrapDeformer SWrapdeformer;

Deformer& SWrapMod::GetDeformer(
		TimeValue t,ModContext &mc,Matrix3& mat,Matrix3& invmat)
	{
	return SWrapdeformer;
	}

RefTargetHandle SWrapMod::Clone(RemapDir& remap) 
	{
	SWrapMod *newob = new SWrapMod(nodeRef,(SWrapObject*)obRef);	
	newob->SimpleWSMModClone(this);
	return newob;
	}
 static TriObject *IsUseable(Object *pobj,TimeValue t)
{ 
  if (pobj->SuperClassID()==GEOMOBJECT_CLASS_ID)
  {	if (pobj->IsSubClassOf(triObjectClassID)) 
      return (TriObject*)pobj;
    else 
	{ if (pobj->CanConvertToType(triObjectClassID)) 
	  	return (TriObject*)pobj->ConvertToType(t,triObjectClassID);			
	}
  }
  return NULL;
}
 static BOOL IsShape(Object *pobj,TimeValue t,BezierShape *bshape)
{ 
  return FALSE;
}

 #define EPSILON	0.0001f

int RayIntersect(Ray& ray, float& at, Point3& norm,Mesh *amesh,Tab<VNormal> vnorms,Tab<Point3> fnorms)
{	Face *face = amesh->faces;	
	Point3 n, p, bry,bary;
	float d, rn, a;
	BOOL first = FALSE;

	for (int i=0; i<amesh->getNumFaces(); i++,face++) {
		n = fnorms[i];
		// See if the ray intersects the plane (backfaced)
		rn = DotProd(ray.dir,n);
		if (rn > -EPSILON) continue;
		// Use a point on the plane to find d
		d = DotProd(amesh->verts[face->v[0]],n);
		// Find the point on the ray that intersects the plane
		a = (d - DotProd(ray.p,n)) / rn;
		// Must be positive...
		if (a < 0.0f) continue;
		// Must be closer than the closest at so far
		if (first) {if (a > at) continue;}
		// The point on the ray and in the plane.
		p = ray.p + a*ray.dir;
		// Compute barycentric coords.
		bry = amesh->BaryCoords(i,p);
		// barycentric coordinates must sum to 1 and each component must
		// be in the range 0-1
		if (bry.x<0.0f || bry.x>1.0f || bry.y<0.0f || bry.y>1.0f || bry.z<0.0f || bry.z>1.0f) continue;
		if (fabs(bry.x + bry.y + bry.z - 1.0f) > EPSILON) continue;
		// Hit!
		first = TRUE;		
		at    = a;
//		bary.x  = bry.z;
//		bary.y  = bry.x;
//		bary.z  = bry.y;
		bary = bry; // DS 3/8/97
		// Use interpolated normal instead.
		if (!face->smGroup) {
			norm  = n;
		} else {
			norm = 
				vnorms[face->v[0]].GetNormal(face->smGroup) * bary.x +
				vnorms[face->v[1]].GetNormal(face->smGroup) * bary.y +
				vnorms[face->v[2]].GetNormal(face->smGroup) * bary.z;
			norm = Normalize(norm);
			}
		}

	return first;
	}

Point3 DoIntersect(Point3 vert,Ray ray,Mesh *mesh,float kdef,float standoff,int *kfound,Point3 v,Tab<VNormal> vnorms,Tab<Point3> fnorms) 
{ ray.p=vert;
  float at;Point3 norm;
  (*kfound)=RayIntersect(ray,at,norm,mesh,vnorms,fnorms);
  if (!(*kfound)) vert+=kdef*v;
  else 
  { Point3 intersect=ray.p+ray.dir*at;
    intersect=intersect;
    intersect=vert-intersect;
    vert=vert+v*(Length(intersect)-standoff);
  }
  return vert;
}

void GetVFLst(Mesh* dmesh,Tab<VNormal>* vnorms,Tab<Point3>* fnorms)	 
{ int nv=dmesh->getNumVerts();	
  int nf=dmesh->getNumFaces();	
  (*fnorms).Resize(nf);
  (*fnorms).SetCount(nf);
  (*vnorms).Resize(nv);
  (*vnorms).SetCount(nv);
  Face *face = dmesh->faces;
  for (int i=0; i<nv; i++) 
    (*vnorms)[i] = VNormal();
  Point3 v0, v1, v2;
  for (i=0; i<dmesh->getNumFaces(); i++,face++) 
  {	// Calculate the surface normal
	v0 = dmesh->verts[face->v[0]];
	v1 = dmesh->verts[face->v[1]];
	v2 = dmesh->verts[face->v[2]];
	(*fnorms)[i] = (v1-v0)^(v2-v1);
	for (int j=0; j<3; j++) 
	   (*vnorms)[face->v[j]].AddNormal((*fnorms)[i],face->smGroup);
    (*fnorms)[i] = Normalize((*fnorms)[i]);
  }
  for (i=0; i<nv; i++) 
	(*vnorms)[i].Normalize();
}
/*#define EDITABLE_SURF_CLASS_ID Class_ID(0x76a11646, 0x12a821fa)
#define FITPOINT_PLANE_CLASS_ID Class_ID(0x76a11646, 0xbadbeef)
#define EDITABLE_CVCURVE_CLASS_ID Class_ID(0x76a11646, 0x12a82144)
#define EDITABLE_FPCURVE_CLASS_ID Class_ID(0x76a11646, 0x12a82142)*/


void SWrapMod::ModifyObject(
		TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{	SWrapObject *obj = (SWrapObject *)GetWSMObject(t);
	INode *pnode;
	TriObject *towrapOb=NULL;Object *pobj=NULL;
	if (obj) pnode=obj->custnode;
	if (obj && nodeRef && pnode) 
	{	Interval valid = FOREVER;
		if (!obj->cmValid.InInterval(t))
		{   pobj = pnode->EvalWorldState(t).obj;
			obj->cmValid=pobj->ObjectValidity(t);
			Matrix3 tm=pnode->GetObjectTM(t,&(obj->cmValid));
			TriObject *wrapOb=IsUseable(pobj,t);
			if (wrapOb)
			{ if (obj->cmesh) delete obj->cmesh; 
			  obj->cmesh=new Mesh;
			   obj->cmesh->DeepCopy(&wrapOb->GetMesh(),
			     PART_GEOM|SELECT_CHANNEL|PART_SUBSEL_TYPE|PART_TOPO|TM_CHANNEL);
			   for (int ic=0;ic<obj->cmesh->getNumVerts();ic++)
			     obj->cmesh->verts[ic]=obj->cmesh->verts[ic]*tm;
			  GetVFLst(obj->cmesh,&obj->vnorms,&obj->fnorms);
			  if (wrapOb!=pobj) wrapOb->DeleteThis();
			}
 		}
		if (!obj->cmesh) return;
		if ((obj->cmesh->getNumVerts()==0)||(obj->cmesh->getNumFaces()==0)) 
			return;		 
//		Matrix3 invtm=Inverse(obj->tm);
		valid=obj->cmValid;
		Matrix3 ctm;
		ctm = nodeRef->GetNodeTM(t,&valid);
		Ray ray;
		Point3 v=-ctm.GetRow(2);
//		Matrix3 nooff=invtm;nooff.NoTrans();
		ray.dir=v;//*nooff;
		int selverts;
		float kdef,standoff;
		obj->pblock->GetValue(PB_USESELVERTS,t,selverts,valid);
		obj->pblock->GetValue(PB_KIDEFAULT,t,kdef,valid);
		obj->pblock->GetValue(PB_STANDOFF,t,standoff,valid);
		BezierShape stowrapOb;
		int found=0;
		Matrix3 towtm(1);
		if (os->GetTM()) 
			towtm=*(os->GetTM());
		Matrix3 invtowtm=Inverse(towtm);
		Point3 vert;
		Class_ID cid=os->obj->ClassID(),es=EDITABLE_SURF_CLASS_ID,efp=FITPOINT_PLANE_CLASS_ID,ecv=EDITABLE_CVCURVE_CLASS_ID,ecfp=EDITABLE_FPCURVE_CLASS_ID;
		if (((cid==EDITABLE_SURF_CLASS_ID)||(cid==FITPOINT_PLANE_CLASS_ID))||((cid==EDITABLE_CVCURVE_CLASS_ID)||(cid==EDITABLE_FPCURVE_CLASS_ID)))
		{ Object* nurbobj=os->obj;
		  int num=nurbobj->NumPoints();
		  for (int i=0;i<num;i++)
		  {	vert=DoIntersect(nurbobj->GetPoint(i)*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms); 
		    nurbobj->SetPoint(i,(vert*invtowtm));
		  }
		}
		else if (os->obj->IsSubClassOf(patchObjectClassID))
		{ PatchObject* patchob=(PatchObject *)os->obj;
		  PatchMesh *pm=&(patchob->patch);
		  int nv=pm->getNumVerts();
		  BitArray sel = pm->VertSel();
		  for (int i=0;i<nv;i++)
		  { if (!selverts||sel[i])
			{ vert=DoIntersect(pm->getVert(i).p*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms); 
		      vert=vert*invtowtm;
		      pm->setVert(i,vert);
			}
		  }
/*		  pm->buildLinkages();
		  pm->computeInteriors();
		  pm->InvalidateGeomCache();*/
		}
		else if (towrapOb=IsUseable(os->obj,t))
		{ float *vssel = NULL;
		  if (selverts) vssel = towrapOb->GetMesh().getVSelectionWeights();
		  for (int i=0;i<towrapOb->GetMesh().getNumVerts();i++)
		  { if ((!selverts)||(towrapOb->GetMesh().vertSel[i])||(vssel&&vssel[i]))
			{vert=DoIntersect(towrapOb->GetMesh().verts[i]*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms); 
		    towrapOb->GetMesh().verts[i]=vert*invtowtm;}
		  }
		  if (towrapOb!=os->obj) towrapOb->DeleteThis();
		}
		else if((os->obj->IsSubClassOf(splineShapeClassID))||(os->obj->CanConvertToType(splineShapeClassID))) 
		{ SplineShape *attSplShape = (SplineShape *)os->obj->ConvertToType(t,splineShapeClassID);
		if (attSplShape) 
		{ stowrapOb=attSplShape->shape;
		  for (int poly=0; poly<stowrapOb.splineCount; ++poly)
		  { Spline3D *spline = stowrapOb.GetSpline(poly);
			int verts = spline->Verts();
			int knots = spline->KnotCount();
			BitArray sel = stowrapOb.VertexTempSel(poly);
			Point3 cknot,cknot2;
			{ for(int k=0; k<knots; ++k) 
			  {	int vert = k * 3 + 1;
				if (!selverts||sel[vert])  
				{ cknot=DoIntersect(spline->GetKnotPoint(k)*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms);
				  attSplShape->shape.SetVert(poly,vert,cknot*invtowtm);
				  if (found)
				  { int knotType = spline->GetKnotType(k);
				    if(knotType & KTYPE_BEZIER) 
				    { cknot2= DoIntersect(spline->GetInVec(k)*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms);
					attSplShape->shape.SetVert(poly,vert-1,(found?cknot2:cknot)*invtowtm);
				  	  cknot2= DoIntersect(spline->GetOutVec(k)*towtm,ray,obj->cmesh,kdef,standoff,&found,v,obj->vnorms,obj->fnorms);
					  attSplShape->shape.SetVert(poly,vert+1,(found?cknot2:cknot)*invtowtm);
					}
				  }
				}
			  }
			}
		  }
		  if (attSplShape!=os->obj) attSplShape->DeleteThis();
		}
	  }
//	os->obj->PointsWereChanged();
	os->obj->UpdateValidity(GEOM_CHAN_NUM,valid);	
  }
} 

RefTargetHandle SWrapObject::GetReference(int i)
{	switch(i) {
		case PBLK: return(RefTargetHandle)pblock;
		case CUSTNODE: return (RefTargetHandle)custnode;
		default: return NULL;
		}
	}

void SWrapObject::SetReference(int i, RefTargetHandle rtarg) { 
	switch(i) {
		case PBLK: pblock=(IParamBlock*)rtarg; return;
		case CUSTNODE: custnode = (INode *)rtarg; return;
		}
	}

RefResult SWrapObject::NotifyRefChanged( 
		Interval changeInt,
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message )
	{				
	switch (message) {		
		case REFMSG_CHANGE:	
			{ if (hTarget==custnode) cmValid.SetEmpty();
			SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
			}
			break;
		case REFMSG_TARGET_DELETED:	
			{ if (hTarget==custnode) custnode=NULL;
			}
			break;
		case REFMSG_NODE_NAMECHANGE:
			{ if (hTarget==custnode) 
			  { custname = TSTR(custnode->GetName());
			    ShowName();
				}
			  break;
			}
		default: SimpleWSMObject::NotifyRefChanged(changeInt,hTarget,partID,message);
		}
	return REF_SUCCEED;
	}
#define SWRAP_CUSTNAME_CHUNK	0x0100

IOResult SWrapObject::Save(ISave *isave)
	{
	isave->BeginChunk(SWRAP_CUSTNAME_CHUNK);		
	isave->WriteWString(custname);
	isave->EndChunk();
	return IO_OK;
	}

IOResult SWrapObject::Load(ILoad *iload)
	{
	IOResult res = IO_OK;
	
	// Default names
	custname = TSTR(_T(" "));

	while (IO_OK==(res=iload->OpenChunk())) {
		switch (iload->CurChunkID()) {
			case SWRAP_CUSTNAME_CHUNK: {
				TCHAR *buf;
				res=iload->ReadWStringChunk(&buf);
				custname = TSTR(buf);
				break;
				}
			}
		
		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}

	return IO_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\asciiout.cpp ===
/**********************************************************************
 *<
	FILE: asciiout.cpp

	DESCRIPTION:  A utility that outputs an object in ASCII form

	CREATED BY: Rolf Berteig

	HISTORY: created December 26 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"
#include "polyshp.h"
#include "shape.h"

#define ASCII_OUT_CLASS_ID		0x8fbc04ea

class AsciiOut : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		ICustButton *iPick;
		BOOL objSpace;
		BOOL shapesAsBeziers;

		AsciiOut();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

		void SetObjectSpace(BOOL sw) { objSpace = sw; }
		void SetShapesAsBeziers(BOOL sw) { shapesAsBeziers = sw; }
		void OutputObject(INode *node,TCHAR *fname);
	};
static AsciiOut theAsciiOut;

class AsciiOutClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theAsciiOut;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_ASCIIOBJECTOUT);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(ASCII_OUT_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static AsciiOutClassDesc asciiOutDesc;
ClassDesc* GetAsciiOutDesc() {return &asciiOutDesc;}

class AsciiOutPickNodeCallback : public PickNodeCallback {
	public:		
		BOOL Filter(INode *node);
	};

BOOL AsciiOutPickNodeCallback::Filter(INode *node)
	{
	ObjectState os = node->EvalWorldState(theAsciiOut.ip->GetTime());
	if ((os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID &&
		os.obj->IsRenderable()) || os.obj->SuperClassID()==SHAPE_CLASS_ID) return TRUE;
	else return FALSE;
	}

static AsciiOutPickNodeCallback thePickFilt;

class AsciiOutPickModeCallback : public PickModeCallback {
	public:		
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		
		void EnterMode(IObjParam *ip) {theAsciiOut.iPick->SetCheck(TRUE);}
		void ExitMode(IObjParam *ip) {theAsciiOut.iPick->SetCheck(FALSE);}

		PickNodeCallback *GetFilter() {return &thePickFilt;}
		BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
	};

static AsciiOutPickModeCallback thePickMode;

BOOL AsciiOutPickModeCallback::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	return ip->PickNode(hWnd,m,&thePickFilt)?TRUE:FALSE;
	}

BOOL AsciiOutPickModeCallback::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		static TCHAR fname[256] = {'\0'};
		OPENFILENAME ofn;
		memset(&ofn,0,sizeof(ofn));
		FilterList fl;
		fl.Append( GetString(IDS_RB_ASCIIFILES));
		fl.Append( _T("*.asc"));		
		TSTR title = GetString(IDS_RB_SAVEOBJECT);

		ofn.lStructSize     = sizeof(OPENFILENAME);
	    ofn.hwndOwner       = ip->GetMAXHWnd();
	    ofn.lpstrFilter     = fl;
	    ofn.lpstrFile       = fname;
	    ofn.nMaxFile        = 256;    
	    ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
	    ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
	    ofn.lpstrDefExt     = _T("asc");
		ofn.lpstrTitle      = title;

tryAgain:
		if (GetSaveFileName(&ofn)) {
			if (DoesFileExist(fname)) {
				TSTR buf1;
				TSTR buf2 = GetString(IDS_RB_SAVEOBJECT);
				buf1.printf(GetString(IDS_RB_FILEEXISTS),fname);
				if (IDYES!=MessageBox(
					theAsciiOut.hPanel,
					buf1,buf2,MB_YESNO|MB_ICONQUESTION)) {
					goto tryAgain;
					}
				}
			theAsciiOut.OutputObject(node,fname);
			}
		}
	return TRUE;
	}


static BOOL CALLBACK AsciiOutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theAsciiOut.Init(hWnd);			
			break;
		
		case WM_DESTROY:
			theAsciiOut.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theAsciiOut.iu->CloseUtility();
					break;				
		
				case IDC_ASCIIOUT_PICK:
					theAsciiOut.ip->SetPickMode(&thePickMode); 
					break;

				case IDC_OBJECT_SPACE:
					theAsciiOut.SetObjectSpace(IsDlgButtonChecked(hWnd, IDC_OBJECT_SPACE));
					break;

				case IDC_SHAPES_AS_BEZIERS:
					theAsciiOut.SetShapesAsBeziers(IsDlgButtonChecked(hWnd, IDC_SHAPES_AS_BEZIERS));
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE; 
	}

AsciiOut::AsciiOut()
	{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;	
	iPick = NULL;
	objSpace = FALSE;
	shapesAsBeziers = FALSE;
	}

void AsciiOut::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_ASCIIOUT_PANEL),
		AsciiOutDlgProc,
		GetString(IDS_RB_ASCIIOBJECTOUT),
		0);
	}
	
void AsciiOut::EndEditParams(Interface *ip,IUtil *iu) 
	{
	ip->ClearPickMode();
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void AsciiOut::Init(HWND hWnd)
	{
	iPick = GetICustButton(GetDlgItem(hWnd,IDC_ASCIIOUT_PICK));
	iPick->SetType(CBT_CHECK);
	iPick->SetHighlightColor(GREEN_WASH);
	CheckDlgButton(hWnd, IDC_OBJECT_SPACE, objSpace);
	CheckDlgButton(hWnd, IDC_SHAPES_AS_BEZIERS, shapesAsBeziers);
	}

void AsciiOut::Destroy(HWND hWnd)
	{
	ReleaseICustButton(iPick);
	iPick = NULL;
	}

class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};

void AsciiOut::OutputObject(INode *node,TCHAR *fname)
	{
	ObjectState os = node->EvalWorldState(theAsciiOut.ip->GetTime());
	if(os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
		BOOL needDel;
		NullView nullView;
		Mesh *mesh = ((GeomObject*)os.obj)->GetRenderMesh(ip->GetTime(),node,nullView,needDel);
		if (!mesh) return;

		FILE *file = fopen(fname,_T("wt"));
		Matrix3 tm = node->GetObjTMAfterWSM(theAsciiOut.ip->GetTime());
		
		if (file) {
			fprintf(file,"\nNamed Object: \"%s\"\n",node->GetName());
			fprintf(file,"Tri-mesh, Vertices: %d     Faces: %d\n",
				mesh->getNumVerts(), mesh->getNumFaces());
			fprintf(file,"Vertex list:\n");
			for (int i=0; i<mesh->getNumVerts(); i++) {
				Point3 v = objSpace ? mesh->verts[i] : (tm * mesh->verts[i]);
				fprintf(file,"Vertex %d: X: %f     Y: %f     Z: %f\n",
					i, v.x, v.y, v.z);
				}

			fprintf(file,"Face list:\n");
			for (i=0; i<mesh->getNumFaces(); i++) {
				fprintf(file,"Face %d:    A:%d B:%d C:%d AB:%d BC:%d CA:%d\n",
					i, mesh->faces[i].v[0], mesh->faces[i].v[1], mesh->faces[i].v[2],
					mesh->faces[i].getEdgeVis(0) ? 1 : 0,
					mesh->faces[i].getEdgeVis(1) ? 1 : 0,
					mesh->faces[i].getEdgeVis(2) ? 1 : 0);
				fprintf(file,"Smoothing: ");			
				for (int j=0; j<32; j++) {
					if (mesh->faces[i].smGroup & (1<<j)) {
						if (mesh->faces[i].smGroup>>(j+1)) {
							fprintf(file,"%d, ",j+1);
						} else {
							fprintf(file,"%d ",j+1);
							}
						}
					}
				fprintf(file,"\n");
				}
			
			fclose(file);
			}	
		if (needDel) delete mesh;
		}
	else
	if(os.obj->SuperClassID()==SHAPE_CLASS_ID) {
		FILE *file = fopen(fname,_T("wt"));
		Matrix3 tm = node->GetObjTMAfterWSM(theAsciiOut.ip->GetTime());
		
		if (file) {
			if(shapesAsBeziers && ((ShapeObject *)os.obj)->CanMakeBezier()) {
				BezierShape shape;
				((ShapeObject *)os.obj)->MakeBezier(ip->GetTime(), shape);
				Spline3D *spline = shape.GetSpline(0);
				fprintf(file,"\nNamed Object: \"%s\"\n",node->GetName());

				for (int i=0; i<spline->KnotCount(); i++) {
					Point3 k = spline->GetKnotPoint(i);
					Point3 in = spline->GetInVec(i);
					Point3 out = spline->GetOutVec(i);
					if(!objSpace) {
						k = k * tm;
						in = in * tm;
						out = out * tm;
						}
					fprintf(file,"Knot %d: %f %f %f In: %f %f %f Out: %f %f %f\n", i,
						k.x, k.y, k.z, in.x, in.y, in.z, out.x, out.y, out.z);
					}
				}
			else {
				PolyShape shape;
				((ShapeObject *)os.obj)->MakePolyShape(ip->GetTime(), shape);
				fprintf(file,"\nNamed Object: \"%s\"\n",node->GetName());
				fprintf(file,"Shape, Lines: %d\n",shape.numLines);

				for (int poly=0; poly<shape.numLines; poly++) {
					PolyLine &line = shape.lines[poly];
					fprintf(file,"Line %d: %d vertices [%s]\n",poly, line.numPts, line.IsClosed() ? "CLOSED":"OPEN");
					for(int vert = 0; vert < line.numPts; ++vert) {
						PolyPt &p = line.pts[vert];
						Point3 v = objSpace ? p.p : (tm * p.p);
						fprintf(file,"Vertex %d: X: %f     Y: %f     Z: %f  ",
							vert, v.x, v.y, v.z);
						if(p.flags & POLYPT_KNOT)
							fprintf(file,"[KNOT]");
						if(p.flags & POLYPT_INTERPOLATED)
							fprintf(file,"[INTERP]");
						if(p.flags & POLYPT_SMOOTH)
							fprintf(file,"[SM]");
						if(p.flags & POLYPT_SEG_SELECTED)
							fprintf(file,"[SEL]");
						fprintf(file,"\n");
						}
					}
				}
			
			fclose(file);
			}	
		}
	else
		assert(0);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\celltex.cpp ===
/**********************************************************************
 *<
	FILE: CELLTEX.CPP

	DESCRIPTION: A Cellular texture

	CREATED BY: Rolf Berteig

	HISTORY: created 3/22/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "util.h"
#include "stdmat.h"
#include "iparamm2.h"
#include "texutil.h"

extern HINSTANCE hInstance;

#define CELLTEX_NAME		GetString(IDS_RB_CELLULAR)
#define CELLTEX_CLASSID	Class_ID(0xc90017a5,0x111940bb)

//class CellTexParamDlg;

#define NSUBTEX	3

class CellTex : public Texmap { 
	public:

		static ParamDlg* xyzGenDlg;	
		static ParamDlg* texoutDlg;

		IParamBlock2 *pblock;		// ref 0
		XYZGen *xyzGen;				// ref 1
		TextureOutput *texout;		// ref 2
		Texmap* subTex[NSUBTEX];	// ref 3-5

//		CellTexParamDlg *paramDlg;

		// Caches
		Interval ivalid;
		CRITICAL_SECTION csect;
		Color cellCol, divCol1, divCol2;
		float size, spread, low, high, mid, var, blend, varOff;
		float highMinuslow, midMinuslow, highMinusmid, iterations;
		float rough, smooth;
		int type, fract, useCellMap, useDiv1Map, useDiv2Map, adapt;

		CellTex();
		~CellTex() {
			DeleteCriticalSection(&csect);
			}

		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		//ULONG Requirements(int subMtlNum);
		ULONG LocalRequirements(int subMtlNum);
		void LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq);  
		void Update(TimeValue t, Interval& valid);
		void Init();
		void Reset();
		Interval Validity(TimeValue t) {Update(t,FOREVER); return ivalid;}		
		XYZGen* GetTheXYZGen() { return xyzGen; }

		// Evaluation
		AColor EvalColor(ShadeContext& sc);
		float EvalMono(ShadeContext& sc);
		AColor EvalFunction(ShadeContext& sc, float u, float v, float du, float dv);		
		Point3 EvalNormalPerturb(ShadeContext& sc);
		float CellFunc(Point3 pt,float dpsq,Point3 &np,BOOL noAdapt);

		// Methods to access texture maps of material
		int NumSubTexmaps() {return NSUBTEX;}
		Texmap* GetSubTexmap(int i) {return subTex[i];}
		void SetSubTexmap(int i, Texmap *m);
		TSTR GetSubTexmapSlotName(int i);

		Class_ID ClassID() {return CELLTEX_CLASSID;}
		SClass_ID SuperClassID() {return TEXMAP_CLASS_ID;}
		void GetClassName(TSTR& s) { s = GetString(IDS_RB_CELLULAR); } // mjm - 2.3.99
		void DeleteThis() {delete this;}	

		int NumSubs() {return 6;}
		Animatable* SubAnim(int i);
		TSTR SubAnimName(int i);
		int SubNumToRefNum(int subNum) {return subNum;}

 		int NumRefs() {return 6;}
		RefTargetHandle GetReference(int i);
		void SetReference(int i, RefTargetHandle rtarg);

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
		RefTargetHandle Clone(RemapDir &remap = NoRemap());
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message);

// JBW: direct ParamBlock access is added
		int	NumParamBlocks() { return 1; }					// return number of ParamBlocks in this instance
		IParamBlock2* GetParamBlock(int i) { return pblock; } // return i'th ParamBlock
		IParamBlock2* GetParamBlockByID(BlockID id) { return (pblock->ID() == id) ? pblock : NULL; } // return id'd ParamBlock
		BOOL SetDlgThing(ParamDlg* dlg);

	};
/*
class CellTexParamDlg : public ParamDlg, public ParamMapUserDlgProc {
	public:
		CellTex *map;
		IMtlParams *ip;
		IParamMap *pmap;
		ParamDlg *xyzGenDlg;
		ParamDlg *texoutDlg;
		TexDADMgr dadMgr;
		HWND hwmedit;

		CellTexParamDlg(CellTex *m,IMtlParams *i,HWND hMedit);
		Class_ID ClassID() {return CELLTEX_CLASSID;}
		ReferenceTarget* GetThing() {return map;}
		void SetThing(ReferenceTarget *m);
		void DeleteThis();
		void SetTime(TimeValue t);
		void ReloadDialog();
		void ActivateDlg(BOOL onOff) {}
		void UpdateSubTexNames();
		int FindSubTexFromHWND(HWND hw);
		void SetStates(HWND hWnd, BOOL isFractal);

		// From ParamMapUserDlgProc
		BOOL DlgProc(TimeValue t,IParamMap *map,HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam);		
	};
*/
class CellTexClassDesc:public ClassDesc2 {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading) {return new CellTex;}
	const TCHAR *	ClassName() { return GetString(IDS_RB_CELLULAR_CDESC); } // mjm - 2.3.99
	SClass_ID		SuperClassID() {return TEXMAP_CLASS_ID;}
	Class_ID 		ClassID() {return CELLTEX_CLASSID;}
	const TCHAR* 	Category() {return TEXMAP_CAT_3D;}
// JBW: new descriptor data accessors added.  Note that the 
//      internal name is hardwired since it must not be localized.
	const TCHAR*	InternalName() { return _T("cellularTex"); }	// returns fixed parsable name (scripter-visible name)
	HINSTANCE		HInstance() { return hInstance; }			// returns owning module handle
	};

static CellTexClassDesc cellTexCD;
ClassDesc* GetCellTexDesc() {return &cellTexCD;}
ParamDlg* CellTex::xyzGenDlg;	
ParamDlg* CellTex::texoutDlg;

#define MAX_ITERATIONS	20.0f


//--- Parameter Map/Parameter block IDs ------------------------------
/*
#define PB_CELLCOL		0
#define PB_DIVCOL1		1
#define PB_DIVCOL2		2
#define PB_VAR			3
#define PB_SIZE			4
#define PB_SPREAD		5
#define PB_LOW			6
#define PB_MID			7
#define PB_HIGH			8
#define PB_TYPE			9
#define PB_FRACT		10
#define PB_ITER			11
#define PB_USECELLMAP	12
#define PB_USEDIV1MAP	13
#define PB_USEDIV2MAP	14
#define PB_ROUGH		15
#define PB_SMOOTH		16
#define PB_ADAPT		17


static int typeIDs[] = {IDC_CELLTEX_CIRCULAR,IDC_CELLTEX_IRREGULAR};

static ParamUIDesc descParam[] = {
	// Cell color
	ParamUIDesc(PB_CELLCOL,TYPE_COLORSWATCH,IDC_CELLTEX_CELLCOLOR),

	// Div color 1
	ParamUIDesc(PB_DIVCOL1,TYPE_COLORSWATCH,IDC_CELLTEX_DIVCOL1),
	
	// Div color 2
	ParamUIDesc(PB_DIVCOL2,TYPE_COLORSWATCH,IDC_CELLTEX_DIVCOL2),

	// Variation
	ParamUIDesc(
		PB_VAR,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_VAR,IDC_CELLTEX_VARSPIN,
		0.0f,100.0f,
		0.1f),	

	// Size	
	ParamUIDesc(
		PB_SIZE,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_SIZE,IDC_CELLTEX_SIZESPIN,
		0.001f,999999999.0f,
		0.1f),	

	// Spread
	ParamUIDesc(
		PB_SPREAD,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_SPREAD,IDC_CELLTEX_SPREADSPIN,
		0.001f,999999999.0f,
		0.01f),	

	// Low thresh
	ParamUIDesc(
		PB_LOW,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_LOW,IDC_CELLTEX_LOWSPIN,
		0.0f,1.0f,
		0.01f),	

	// Mid thresh
	ParamUIDesc(
		PB_MID,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_MID,IDC_CELLTEX_MIDSPIN,
		0.0f,1.0f,
		0.01f),	

	// High thresh
	ParamUIDesc(
		PB_HIGH,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_HIGH,IDC_CELLTEX_HIGHSPIN,
		0.0f,1.0f,
		0.01f),	

	// Type
	ParamUIDesc(PB_TYPE,TYPE_RADIO,typeIDs,2),

	// Fractal
	ParamUIDesc(PB_FRACT,TYPE_SINGLECHEKBOX,IDC_CELLTEX_FRACTAL),

	// Iterations
	ParamUIDesc(
		PB_ITER,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_ITER,IDC_CELLTEX_ITERSPIN,
		1.0f,25.0f,
		0.01f),	

	// Use cell color map
	ParamUIDesc(PB_USECELLMAP,TYPE_SINGLECHEKBOX,IDC_CELLTEX_CELLCOLOR_USEMAP),

	// Use div1 color map
	ParamUIDesc(PB_USEDIV1MAP,TYPE_SINGLECHEKBOX,IDC_CELLTEX_DIVCOL1_USEMAP),

	// Use div2 color map
	ParamUIDesc(PB_USEDIV2MAP,TYPE_SINGLECHEKBOX,IDC_CELLTEX_DIVCOL2_USEMAP),

	// Rough
	ParamUIDesc(
		PB_ROUGH,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_ROUGH,IDC_CELLTEX_ROUGHSPIN,
		0.0f,1.0f,
		0.01f),	

	// Smooth
	ParamUIDesc(
		PB_SMOOTH,
		EDITTYPE_FLOAT,
		IDC_CELLTEX_BUMPSMOOTH,IDC_CELLTEX_BUMPSMOOTHSPIN,
		0.0f,1.0f,
		0.01f),	

	// adaptive
	ParamUIDesc(PB_ADAPT,TYPE_SINGLECHEKBOX,IDC_CELLTEX_ADAPTIVE),
	};
*/




enum { cellular_params };  // pblock ID
// grad_params param IDs


enum 
{ 
	cellular_celcolor, cellular_divcol1, cellular_divcol2,
	cellular_celmap, cellular_divmap1, cellular_divmap2,
	cellular_map1_on, cellular_map2_on, cellular_map3_on, 
	cellular_variation,cellular_size,cellular_spread,
	cellular_lowthresh,cellular_midthresh,cellular_highthresh,
	cellular_type, cellular_fractal,cellular_iteration,
	cellular_rough, cellular_smooth,cellular_adaptive,// main grad params 

	cellular_coords, cellular_output	  // access for UVW mapping
};

static ParamBlockDesc2 cellular_param_blk ( cellular_params, _T("parameters"),  0, &cellTexCD, P_AUTO_CONSTRUCT + P_AUTO_UI, 0, 
	//rollout
	IDD_CELLTEX_PARAMS, IDS_RB_CELLPARAMS, 0, 0, NULL, 
	// params
	cellular_celcolor,	 _T("cellColor"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_CELLCOLOR,	
		p_default,		Color(1.0,1.0,1.0), 
		p_ui,			TYPE_COLORSWATCH, IDC_CELLTEX_CELLCOLOR, 
		end,
	cellular_divcol1,	 _T("divColor1"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_DIVCOLOR1,	
		p_default,		Color(0.5,0.5,0.5), 
		p_ui,			TYPE_COLORSWATCH, IDC_CELLTEX_DIVCOL1, 
		end,
	cellular_divcol2,	 _T("divColor2"),	TYPE_RGBA,				P_ANIMATABLE,	IDS_RB_DIVCOLOR2,	
		p_default,		Color(0,0,0), 
		p_ui,			TYPE_COLORSWATCH, IDC_CELLTEX_DIVCOL2, 
		end,
	cellular_celmap,		_T("cellMap"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_RB_CELLMAP,
		p_refno,		3,
		p_subtexno,		0,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_CELLTEX_CELLCOLOR_MAP,
		end,
	cellular_divmap1,		_T("divMap1"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_RB_DIVMAP1,
		p_refno,		4,
		p_subtexno,		1,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_CELLTEX_DIVCOL1_MAP,
		end,
	cellular_divmap2,		_T("divMap2"),		TYPE_TEXMAP,			P_OWNERS_REF,	IDS_RB_DIVMAP2,
		p_refno,		5,
		p_subtexno,		2,		
		p_ui,			TYPE_TEXMAPBUTTON, IDC_CELLTEX_DIVCOL2_MAP,
		end,
	cellular_map1_on,	_T("map1Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP1_ON,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_CELLTEX_CELLCOLOR_USEMAP,
		end,
	cellular_map2_on,	_T("map2Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP2_ON,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_CELLTEX_DIVCOL1_USEMAP,
		end,
	cellular_map3_on,	_T("map3Enabled"), TYPE_BOOL,			0,				IDS_PW_MAP3_ON,
		p_default,		TRUE,
		p_ui,			TYPE_SINGLECHEKBOX, IDC_CELLTEX_DIVCOL2_USEMAP,
		end,

	cellular_variation,	_T("variation"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_VARIATION,
		p_default,		0.f,
		p_range,		0.0, 100.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_VAR, IDC_CELLTEX_VARSPIN, 0.1f, 
		end,
	cellular_size,	_T("size"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_SIZE,
		p_default,		5.f,
		p_range,		0.001f,999999999.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_SIZE, IDC_CELLTEX_SIZESPIN, 0.1f, 
		end,
	cellular_spread,	_T("spread"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_SPREAD,
		p_default,		0.5f,
		p_range,		0.001f,999999999.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_SPREAD,IDC_CELLTEX_SPREADSPIN, 0.01f, 
		end,

	cellular_lowthresh,	_T("lowThresh"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_LOW,
		p_default,		0.0f,
		p_range,		0.0f,1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_LOW,IDC_CELLTEX_LOWSPIN, 0.01f, 
		end,
	cellular_midthresh,	_T("midThresh"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_MID,
		p_default,		0.5f,
		p_range,		0.0f,1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_MID,IDC_CELLTEX_MIDSPIN, 0.01f, 
		end,
	cellular_highthresh,	_T("highThresh"),   TYPE_FLOAT,			P_ANIMATABLE,	IDS_RB_HIGH,
		p_default,		1.0f,
		p_range,		0.0f,1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_HIGH,IDC_CELLTEX_HIGHSPIN, 0.01f, 
		end,

	cellular_type, _T("type"), TYPE_INT,				0,				IDS_RB_TYPE,
		p_default,		0,
		p_range,		0,	2,
		p_ui,			TYPE_RADIO, 2, IDC_CELLTEX_CIRCULAR, IDC_CELLTEX_IRREGULAR,
		end,

	cellular_fractal, _T("fractal"), TYPE_BOOL,				0,		IDS_RB_FRACTAL,
		p_default,		0,
		p_ui,			TYPE_SINGLECHEKBOX,  IDC_CELLTEX_FRACTAL,
		p_enable_ctrls,	3, cellular_iteration,cellular_rough,cellular_adaptive,
		end,

	cellular_iteration,		_T("iteration"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_ITERATIONS,
		p_default,		3.f,
		p_range,		1.0, MAX_ITERATIONS,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_ITER,IDC_CELLTEX_ITERSPIN, 0.01f, 
		p_enabled,		FALSE,
		end,

	cellular_rough,		_T("roughness"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_ROUGHNESS,
		p_default,		0.f,
		p_range,		0.0, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_ROUGH,IDC_CELLTEX_ROUGHSPIN, 0.01f, 
		p_enabled,		FALSE,
		end,

	cellular_smooth,	_T("smooth"),	TYPE_FLOAT,	P_ANIMATABLE,	IDS_RB_BUMPSMOOTHING,
		p_default,		0.1f,
		p_range,		0.0, 1.0f,
		p_ui, 			TYPE_SPINNER, EDITTYPE_FLOAT, IDC_CELLTEX_BUMPSMOOTH,IDC_CELLTEX_BUMPSMOOTHSPIN, 0.01f, 
		end,

	cellular_adaptive, _T("adaptive"), TYPE_BOOL,				0,		IDS_PW_ADAPTIVE,
		p_default,		1,
		p_ui,			TYPE_SINGLECHEKBOX,  IDC_CELLTEX_ADAPTIVE,
		p_enabled,		FALSE,
		end,
	cellular_coords,		_T("coords"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_COORDS,
		p_refno,		1, 
		end,
	cellular_output,		_T("output"),	TYPE_REFTARG,		P_OWNERS_REF,	IDS_PW_OUTPUT,
		p_refno,		2, 
		end,


	end
);


#define PARAMDESC_LENGH 18

static ParamBlockDescID descVer0[] = {
	{ TYPE_POINT3, NULL, TRUE, cellular_celcolor }, // Cell color
	{ TYPE_POINT3, NULL, TRUE, cellular_divcol1 }, // Div col 1
	{ TYPE_POINT3, NULL, TRUE, cellular_divcol2 }, // Div col 2
	{ TYPE_FLOAT,  NULL, TRUE, cellular_variation },	// variation
	{ TYPE_FLOAT,  NULL, TRUE, cellular_size },	// size
	{ TYPE_FLOAT,  NULL, TRUE, cellular_spread },	// spread
	{ TYPE_FLOAT,  NULL, TRUE, cellular_lowthresh },	// low thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_midthresh },	// mid thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_highthresh },	// high thresh
	{ TYPE_INT,  NULL, FALSE, cellular_type },	// type
	{ TYPE_INT,  NULL, FALSE, cellular_fractal },	// fractal
	{ TYPE_FLOAT,  NULL, TRUE, cellular_iteration },// iterations	
	};

static ParamBlockDescID descVer1[] = {
	{ TYPE_POINT3, NULL, TRUE, cellular_celcolor }, // Cell color
	{ TYPE_POINT3, NULL, TRUE, cellular_divcol1 }, // Div col 1
	{ TYPE_POINT3, NULL, TRUE, cellular_divcol2 }, // Div col 2
	{ TYPE_FLOAT,  NULL, TRUE, cellular_variation },	// variation
	{ TYPE_FLOAT,  NULL, TRUE, cellular_size },	// size
	{ TYPE_FLOAT,  NULL, TRUE, cellular_spread },	// spread
	{ TYPE_FLOAT,  NULL, TRUE, cellular_lowthresh },	// low thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_midthresh },	// mid thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_highthresh },	// high thresh
	{ TYPE_INT,  NULL, FALSE, cellular_type },	// type
	{ TYPE_INT,  NULL, FALSE, cellular_fractal },	// fractal
	{ TYPE_FLOAT,  NULL, TRUE, cellular_iteration },// iterations
	{ TYPE_INT,  NULL, FALSE, cellular_map1_on },	// use cell col map
	{ TYPE_INT,  NULL, FALSE, cellular_map2_on },	// use div1 col map
	{ TYPE_INT,  NULL, FALSE, cellular_map3_on },	// use div2 col map
	};

static ParamBlockDescID descVer2[] = {
	{ TYPE_RGBA, NULL, TRUE, cellular_celcolor }, // Cell color
	{ TYPE_RGBA, NULL, TRUE, cellular_divcol1 }, // Div col 1
	{ TYPE_RGBA, NULL, TRUE, cellular_divcol2 }, // Div col 2
	{ TYPE_FLOAT,  NULL, TRUE, cellular_variation },	// variation
	{ TYPE_FLOAT,  NULL, TRUE, cellular_size },	// size
	{ TYPE_FLOAT,  NULL, TRUE, cellular_spread },	// spread
	{ TYPE_FLOAT,  NULL, TRUE, cellular_lowthresh },	// low thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_midthresh },	// mid thresh
	{ TYPE_FLOAT,  NULL, TRUE, cellular_highthresh },	// high thresh
	{ TYPE_INT,  NULL, FALSE, cellular_type },	// type
	{ TYPE_INT,  NULL, FALSE, cellular_fractal },	// fractal
	{ TYPE_FLOAT,  NULL, TRUE, cellular_iteration },// iterations
	{ TYPE_INT,  NULL, FALSE, cellular_map1_on },	// use cell col map
	{ TYPE_INT,  NULL, FALSE, cellular_map2_on },	// use div1 col map
	{ TYPE_INT,  NULL, FALSE, cellular_map3_on },	// use div2 col map
	{ TYPE_FLOAT,  NULL, TRUE, cellular_rough },// rough
	{ TYPE_FLOAT,  NULL, TRUE, cellular_smooth },// smooth
	{ TYPE_INT,  NULL, FALSE, cellular_adaptive },	// adaptive
	};

#define PBLOCK_LENGTH	18

static ParamVersionDesc versions[] = {
	ParamVersionDesc(descVer0,12,0),	
	ParamVersionDesc(descVer1,15,1),
	ParamVersionDesc(descVer2,18,2)
	};
#define NUM_OLDVERSIONS	3

//#define CURRENT_VERSION	2
//static ParamVersionDesc curVersion(descVer2,PBLOCK_LENGTH,CURRENT_VERSION);


/*
//--- CellTexParamDlg -------------------------------------------------------

CellTexParamDlg::CellTexParamDlg(CellTex *m,IMtlParams *i,HWND hMedit) 
	{
	dadMgr.Init(this);
	map = m;
	ip  = i;	
	hwmedit = hMedit;
	xyzGenDlg = map->xyzGen->CreateParamDlg(hwmedit, i);
	pmap = CreateMParamMap(
		descParam,PARAMDESC_LENGH,
		map->pblock,
		i,
		hInstance,
		MAKEINTRESOURCE(IDD_CELLTEX_PARAMS),
		GetString(IDS_RB_CELLPARAMS),
		0);	
	pmap->SetUserDlgProc(this);
	texoutDlg = map->texout->CreateParamDlg(hwmedit, i);
	}

void CellTexParamDlg::SetThing(ReferenceTarget *m)
	{
	assert(m->ClassID()==map->ClassID());
	map->paramDlg = NULL;
	map = (CellTex*)m;
	pmap->SetParamBlock(map->pblock);
	if (xyzGenDlg)
		xyzGenDlg->SetThing(map->xyzGen);
	if (texoutDlg)
		texoutDlg->SetThing(map->texout);
	map->paramDlg = this;
	ReloadDialog();
	}

void CellTexParamDlg::ReloadDialog() 
	{
	pmap->Invalidate();
	UpdateSubTexNames();	
	SetStates(pmap->GetHWnd(),map->fract);
	}

void CellTexParamDlg::SetTime(TimeValue t)
	{
	xyzGenDlg->SetTime(t);
	texoutDlg->SetTime(t);
	}

void CellTexParamDlg::DeleteThis()
	{
	static BOOL block = FALSE;
	if (block) return;
	map->paramDlg = NULL;
	block = TRUE;
	pmap->SetUserDlgProc(NULL);
	block = FALSE;
	DestroyMParamMap(pmap);
	xyzGenDlg->DeleteThis();
	texoutDlg->DeleteThis();
	delete this;
	}

int CellTexParamDlg::FindSubTexFromHWND(HWND hw)
	{
	if (hw==GetDlgItem(pmap->GetHWnd(),IDC_CELLTEX_CELLCOLOR_MAP)) return 0;
	if (hw==GetDlgItem(pmap->GetHWnd(),IDC_CELLTEX_DIVCOL1_MAP)) return 1;
	if (hw==GetDlgItem(pmap->GetHWnd(),IDC_CELLTEX_DIVCOL2_MAP)) return 2;
	return -1;
	}

void CellTexParamDlg::UpdateSubTexNames()
	{
	HWND hWnd = pmap->GetHWnd();
	ICustButton *but;

	but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_CELLCOLOR_MAP));
	if (map->subTex[0]) but->SetText(map->subTex[0]->GetFullName());
	else but->SetText(GetString(IDS_RB_NONE));
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_DIVCOL1_MAP));
	if (map->subTex[1]) but->SetText(map->subTex[1]->GetFullName());
	else but->SetText(GetString(IDS_RB_NONE));
	ReleaseICustButton(but);

	but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_DIVCOL2_MAP));
	if (map->subTex[2]) but->SetText(map->subTex[2]->GetFullName());
	else but->SetText(GetString(IDS_RB_NONE));
	ReleaseICustButton(but);

	}

void CellTexParamDlg::SetStates(HWND hWnd, BOOL isFractal)
	{
	ISpinnerControl *iIter  = GetISpinner(GetDlgItem(hWnd,IDC_CELLTEX_ITERSPIN));
	ISpinnerControl *iRough = GetISpinner(GetDlgItem(hWnd,IDC_CELLTEX_ROUGHSPIN));
	if (isFractal) {
		iIter->Enable();
		iRough->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ITERLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ROUGHLABEL),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ADAPTIVE),TRUE);
	} else {
		iIter->Disable();
		iRough->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ITERLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ROUGHLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_CELLTEX_ADAPTIVE),FALSE);
		}
	ReleaseISpinner(iIter);
	ReleaseISpinner(iRough);
	}

BOOL CellTexParamDlg::DlgProc(
		TimeValue t,IParamMap *map,
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {			
			ICustButton *but;
			but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_CELLCOLOR_MAP));
			but->SetDADMgr(&dadMgr);
			ReleaseICustButton(but);

			but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_DIVCOL1_MAP));
			but->SetDADMgr(&dadMgr);
			ReleaseICustButton(but);

			but = GetICustButton(GetDlgItem(hWnd,IDC_CELLTEX_DIVCOL2_MAP));
			but->SetDADMgr(&dadMgr);
			ReleaseICustButton(but);

			UpdateSubTexNames();
			SetStates(hWnd,IsDlgButtonChecked(hWnd,IDC_CELLTEX_FRACTAL));
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CELLTEX_FRACTAL:
					SetStates(hWnd,IsDlgButtonChecked(hWnd,IDC_CELLTEX_FRACTAL));
					return FALSE;

				case IDC_CELLTEX_CELLCOLOR_MAP:
					PostMessage(hwmedit,WM_TEXMAP_BUTTON,0 ,(LPARAM)this->map);
					break;
				case IDC_CELLTEX_DIVCOL1_MAP:
					PostMessage(hwmedit,WM_TEXMAP_BUTTON,1 ,(LPARAM)this->map);
					break;
				case IDC_CELLTEX_DIVCOL2_MAP:
					PostMessage(hwmedit,WM_TEXMAP_BUTTON,2 ,(LPARAM)this->map);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

*/
//--- CellTex Methods -----------------------------------------------

ParamDlg* CellTex::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
	{
//	paramDlg = new CellTexParamDlg(this,imp,hwMtlEdit);	
//	return paramDlg;
	// create the rollout dialogs
	xyzGenDlg = xyzGen->CreateParamDlg(hwMtlEdit, imp);	
	IAutoMParamDlg* masterDlg = cellTexCD.CreateParamDlgs(hwMtlEdit, imp, this);
	texoutDlg = texout->CreateParamDlg(hwMtlEdit, imp);
	// add the secondary dialogs to the master
	masterDlg->AddDlg(xyzGenDlg);
	masterDlg->AddDlg(texoutDlg);
//	celTex_param_blk.SetUserDlgProc(new NoiseDlgProc(this));
	return masterDlg;

	}

void CellTex::Update(TimeValue t, Interval& valid)
	{
	EnterCriticalSection(&csect);
	if (!ivalid.InInterval(t)) {
		ivalid = FOREVER;		
		xyzGen->Update(t,ivalid);
		texout->Update(t,ivalid);
/*	
		pblock->GetValue(PB_CELLCOL,t,cellCol,ivalid);
		pblock->GetValue(PB_DIVCOL1,t,divCol1,ivalid);
		pblock->GetValue(PB_DIVCOL2,t,divCol2,ivalid);
		pblock->GetValue(PB_VAR,t,var,ivalid);
		pblock->GetValue(PB_SIZE,t,size,ivalid);
		pblock->GetValue(PB_SPREAD,t,spread,ivalid);
		pblock->GetValue(PB_LOW,t,low,ivalid);
		pblock->GetValue(PB_MID,t,mid,ivalid);
		pblock->GetValue(PB_HIGH,t,high,ivalid);		
		pblock->GetValue(PB_TYPE,t,type,ivalid);
		pblock->GetValue(PB_FRACT,t,fract,ivalid);
		pblock->GetValue(PB_ITER,t,iterations,ivalid);		
		pblock->GetValue(PB_USECELLMAP,t,useCellMap,ivalid);
		pblock->GetValue(PB_USEDIV1MAP,t,useDiv1Map,ivalid);
		pblock->GetValue(PB_USEDIV2MAP,t,useDiv2Map,ivalid);		
		pblock->GetValue(PB_ROUGH,t,rough,ivalid);
		pblock->GetValue(PB_SMOOTH,t,smooth,ivalid);
		pblock->GetValue(PB_ADAPT,t,adapt,ivalid);
*/		

		pblock->GetValue(cellular_celcolor,t,cellCol,ivalid);
		pblock->GetValue(cellular_divcol1,t,divCol1,ivalid);
		pblock->GetValue(cellular_divcol2,t,divCol2,ivalid);
		pblock->GetValue(cellular_variation,t,var,ivalid);
		pblock->GetValue(cellular_size,t,size,ivalid);
		pblock->GetValue(cellular_spread,t,spread,ivalid);
		pblock->GetValue(cellular_lowthresh,t,low,ivalid);
		pblock->GetValue(cellular_midthresh,t,mid,ivalid);
		pblock->GetValue(cellular_highthresh,t,high,ivalid);		
		pblock->GetValue(cellular_type,t,type,ivalid);
		pblock->GetValue(cellular_fractal,t,fract,ivalid);
		pblock->GetValue(cellular_iteration,t,iterations,ivalid);		
		pblock->GetValue(cellular_map1_on,t,useCellMap,ivalid);
		pblock->GetValue(cellular_map2_on,t,useDiv1Map,ivalid);
		pblock->GetValue(cellular_map3_on,t,useDiv2Map,ivalid);		
		pblock->GetValue(cellular_rough,t,rough,ivalid);
		pblock->GetValue(cellular_smooth,t,smooth,ivalid);
		pblock->GetValue(cellular_adaptive,t,adapt,ivalid);
		
		
		smooth *= 0.7f;
		rough = 2.0f-rough;

		highMinuslow = high-low;		
		midMinuslow = mid - low;
		highMinusmid = high - mid;		
		if (type) {
			spread = spread/2.0f;
			}		
		var /= 50.0f;
		varOff = 1.0f-var * 0.5f;	

		for (int i=0; i<NSUBTEX; i++) {
			if (subTex[i]) 
				subTex[i]->Update(t,ivalid);
			}

		valid &= ivalid;	
		}
	LeaveCriticalSection(&csect);
	}

void CellTex::Init()
	{
	if (xyzGen) xyzGen->Reset();
	else ReplaceReference(1, GetNewDefaultXYZGen());

	if (texout) texout->Reset();
	else ReplaceReference(2, GetNewDefaultTextureOutput());
/*
	pblock->SetValue(PB_CELLCOL,0,Point3(1,1,1));
	pblock->SetValue(PB_DIVCOL1,0,Point3(.5f,.5f,.5f));
	pblock->SetValue(PB_DIVCOL2,0,Point3(0,0,0));
	pblock->SetValue(PB_SIZE,0,5.0f);
	pblock->SetValue(PB_SPREAD,0,0.5f);
	pblock->SetValue(PB_LOW,0,0.0f);
	pblock->SetValue(PB_MID,0,0.5f);
	pblock->SetValue(PB_HIGH,0,1.0f);
	pblock->SetValue(PB_FRACT,0,0);
	pblock->SetValue(PB_ITER,0,3.0f);
	pblock->SetValue(PB_USECELLMAP,0,1);
	pblock->SetValue(PB_USEDIV1MAP,0,1);
	pblock->SetValue(PB_USEDIV2MAP,0,1);
	pblock->SetValue(PB_SMOOTH,0,0.1f);	
	pblock->SetValue(PB_ADAPT,0,1);	
	if (paramDlg)  
		paramDlg->pmap->SetParamBlock(pblock);
*/
	fract = 0;
	ivalid.SetEmpty();
	}

void CellTex::Reset(){
	cellTexCD.Reset(this, TRUE);	// reset all pb2's
	DeleteReference(3);
	DeleteReference(4);
	DeleteReference(5);
	Init();
	}

CellTex::CellTex()
	{
//	paramDlg = NULL;
	pblock   = NULL;
	xyzGen   = NULL;
	texout   = NULL;
	subTex[0] = subTex[1] = subTex[2] = NULL;
	cellTexCD.MakeAutoParamBlocks(this);	// make and intialize paramblock2
	Init();
	InitializeCriticalSection(&csect);
	ivalid.SetEmpty();
	}


BOOL CellTex::SetDlgThing(ParamDlg* dlg)
{
	// JBW: set the appropriate 'thing' sub-object for each
	// secondary dialog
	if ((xyzGenDlg!= NULL) && (dlg == xyzGenDlg))
		xyzGenDlg->SetThing(xyzGen);
	else if ((texoutDlg!= NULL) && (dlg == texoutDlg))
		texoutDlg->SetThing(texout);
	else 
		return FALSE;
	return TRUE;
}


#define ITER	3.0f
static Point3 ptOffset(1000.0f,1000.0f,1000.0f);

AColor CellTex::EvalColor(ShadeContext& sc)
	{	
	// Get object point
	Point3 p,dp;
	if (gbufID) sc.SetGBufferID(gbufID);
	xyzGen->GetXYZ(sc,p,dp);
	p += ptOffset;
	p = p/size;
	
	// Eval maps
	Color cellC, div1C, div2C;
	if (useCellMap && subTex[0]) cellC = subTex[0]->EvalColor(sc);
	else cellC = cellCol;
	if (useDiv1Map && subTex[1]) div1C = subTex[1]->EvalColor(sc);
	else div1C = divCol1;
	if (useDiv2Map && subTex[2]) div2C = subTex[2]->EvalColor(sc);
	else div2C = divCol2;

	// Evaluate cell function
	float dist[2];
	int ids[2];
	float u;
	if (type) {
		if (fract) FractalCellFunction(p,iterations,rough,2,dist,ids);
		else CellFunction(p,2,dist,ids);
		u = 1.0f - (dist[1]-dist[0])/spread;		
	} else {
		if (fract) FractalCellFunction(p,iterations,rough,1,dist,ids);
		else CellFunction(p,1,dist,ids);
		u = dist[0]/spread;
		}

	// Vari cell color
	if (var>0.0f) {
		float vr = RandFromCellID(ids[0])*var + varOff;
		cellC.r = cellC.r*vr;
		cellC.g = cellC.g*vr;
		cellC.b = cellC.b*vr;
		cellC.ClampMinMax();		
		}

	if (u<low) return texout->Filter(RGBA(cellC));
	if (u>high) return texout->Filter(RGBA(div2C));
	if (u<mid) {
		u = (u-low)/(midMinuslow);
		return texout->Filter(RGBA(div1C*u + (1.0f-u)*cellC));
	} else {
		u = (u-mid)/(highMinusmid);
		return texout->Filter(RGBA(div2C*u + (1.0f-u)*div1C));
		}
	}

float CellTex::EvalMono(ShadeContext& sc)
	{
	return Intens(EvalColor(sc));
	}

#define SMOOTH	0.2f

float CellTex::CellFunc(Point3 pt,float dpsq,Point3 &np,BOOL noAdapt)
	{
	float dist[3];
	Point3 grad[3];
	float u, iter;
	
	if (fract) {
		if (adapt) {
			iter = iterations/dpsq;
			if (iter>MAX_ITERATIONS) iter = MAX_ITERATIONS; // RB 2/19/99: We run into some sort of floating point limitation (I think) when this gets over about 20 or so.
			if (iter<1.0f)  iter = 1.0f;
		} else {
			iter = iterations;
			}
		}

	if (type) {
		if (fract) FractalCellFunction(
			 pt/size,iter,rough,3,dist,NULL,grad,smooth);
		else CellFunction(pt/size,3,dist,NULL,grad,smooth);
		u  = (dist[1]-dist[0])/spread;
		np = (grad[1]-grad[0])/spread;
	} else {
		if (fract) FractalCellFunction(
			 pt/size,iter,rough,2,dist,NULL,grad,smooth);
		else CellFunction(pt/size,2,dist,NULL,grad,smooth);
		u  = dist[0]/spread;
		np = grad[0]/spread;
		}
	
#if 1
	if (u<low+SMOOTH) {
		if (u<low) {
			np = Point3(0,0,0);
		} else {
			float s = (u-low)/SMOOTH;
			np = np*s;
			}
		return 0.0f;
		}
	if (u>high) {
		if (u>high+SMOOTH) {
			np = Point3(0,0,0);
		} else {
			float s = 1.0f-(u-high)/SMOOTH;
			np = np*s;
			}
		return 1.0f;
		}
#else
	if (u<0.0f) {
		np = Point3(0,0,0);
		return 0.0f;
		}
	if (u>1.0f) {
		np = Point3(0,0,0);
		return 1.0f;
		}
#endif
	return u;
	}

Point3 CellTex::EvalNormalPerturb(ShadeContext& sc)
	{
	Point3 p,dp;
	xyzGen->GetXYZ(sc,p,dp);	
	p += ptOffset;
	Point3 np(0.0f,0.0f,0.0f);
	float dpsq = DotProd(dp,dp);		
	float d = CellFunc(p,dpsq,np,sc.InMtlEditor());

	Texmap* sub0 = (useCellMap && subTex[0])?subTex[0]:NULL; 
	Texmap* sub1 = (useDiv1Map && subTex[1])?subTex[1]:NULL; 
	Texmap* sub2 = (useDiv2Map && subTex[2])?subTex[2]:NULL; 
	if (d<low) {
		if (sub0) 
			np  = sub0->EvalNormalPerturb(sc);
		}
	else 
	if (d>high) {
		if (sub2) 
			np  = sub2->EvalNormalPerturb(sc);
		}
	else {
		Point3 M[3];
		xyzGen->GetBumpDP(sc,M);
		np = Point3( DotProd(np,M[0]),DotProd(np,M[1]),DotProd(np,M[2]));
		if (d<mid) {
			if (sub0||sub1) {
				float a,b;
				Point3 da,db;
				// d((1-k)*a + k*b ) = dk*(b-a) + k*(db-da) + da
				d = (d-low)/(midMinuslow);

				// div1C*u + (1.0f-u)*cellC) ;
				if (sub0) {
					a = sub0->EvalMono(sc);
					da = sub0->EvalNormalPerturb(sc);
					}
				else {
					 a = 1.0f;
					 da = Point3(0.0f,0.0f,0.0f);
					 }
				if (sub1) {
					b = sub1->EvalMono(sc);
					db = sub1->EvalNormalPerturb(sc);
					}
				else {
					 b = 1.0f;
					 db = Point3(0.0f,0.0f,0.0f);
					 }
				np = (b-a)*np + d*(db-da) + da;
				}
			} 
		else {
			if (sub1 || sub2) {
				float a,b;
				Point3 da,db;
				// div2C*u + (1.0f-u)*div1C);
				d = (d-mid)/(highMinusmid);
				if (sub1) {
					a = sub1->EvalMono(sc);
					da = sub1->EvalNormalPerturb(sc);
					}
				else {
					 a = 1.0f;
					 da = Point3(0.0f,0.0f,0.0f);
					 }
				if (sub2) {
					b = sub2->EvalMono(sc);
					db = sub2->EvalNormalPerturb(sc);
					}
				else {
					 b = 1.0f;
					 db = Point3(0.0f,0.0f,0.0f);
					 }
				np = (b-a)*np + d*(db-da) + da;
				}
			}
		}

//	float d = CellFunc(p,dpsq,np,sc.InMtlEditor());
//	Point3 tmp;
//	float div = type ? -0.1875f : 0.0375f;
//	Point3 DP[3];
//	xyzGen->GetBumpDP(sc,DP);
//	np.x = (CellFunc(p+DP[0],dpsq,tmp,sc.InMtlEditor()) - d)/div;
//	np.y = (CellFunc(p+DP[1],dpsq,tmp,sc.InMtlEditor()) - d)/div;
//	np.z = (CellFunc(p+DP[2],dpsq,tmp,sc.InMtlEditor()) - d)/div;

	if (type) np = np * -0.5f;	
	

	return texout->Filter(sc.VectorFromNoScale(np,REF_OBJECT));
	}

void CellTex::SetSubTexmap(int i, Texmap *m)
	{
	ReplaceReference(i+3,m);
	if (i==0)
		{
		cellular_param_blk.InvalidateUI(cellular_celmap);
		ivalid.SetEmpty();
		}
	else if (i==1)
		{
		cellular_param_blk.InvalidateUI(cellular_divmap1);
		ivalid.SetEmpty();
		}
	else if (i==2)
		{
		cellular_param_blk.InvalidateUI(cellular_divmap2);
		ivalid.SetEmpty();
		}

//	if (paramDlg) paramDlg->UpdateSubTexNames();
	}


TSTR CellTex::GetSubTexmapSlotName(int i)
	{
	switch (i) {
		case 0:  return GetString(IDS_RB_CELLCOLOR);
		case 1:  return GetString(IDS_RB_DIVCOLOR1);
		case 2:  return GetString(IDS_RB_DIVCOLOR2);
		default: return _T("");
		}
	}

Animatable* CellTex::SubAnim(int i)
	{
	return GetReference(i);
	}

TSTR CellTex::SubAnimName(int i)
	{
	switch (i) {
		default:
		case 0: return GetString(IDS_RB_PARAMETERS);
		case 1: return GetString(IDS_RB_COORDINATES);
		case 2: return GetString(IDS_RB_OUTPUT);
		case 3: return GetString(IDS_RB_CELLMAP);
		case 4: return GetString(IDS_RB_DIVMAP1);
		case 5: return GetString(IDS_RB_DIVMAP2);
		}
	}

RefTargetHandle CellTex::GetReference(int i)
	{
	switch (i) {
		case 0:  return pblock;
		case 1:  return xyzGen;
		case 2:  return texout;
		default: return subTex[i-3];
		}
	}

void CellTex::SetReference(int i, RefTargetHandle rtarg)
	{
	switch (i) {
		case 0:  pblock = (IParamBlock2*)rtarg; break;
		case 1:  xyzGen = (XYZGen *)rtarg; break;
		case 2:  texout = (TextureOutput *)rtarg; break;
		default: subTex[i-3] = (Texmap *)rtarg; break;
		}
	}

#define MTL_HDR_CHUNK 0x4000
IOResult CellTex::Save(ISave *isave) { 
	IOResult res;
	// Save common stuff
	isave->BeginChunk(MTL_HDR_CHUNK);
	res = MtlBase::Save(isave);
	isave->EndChunk();
	if (res!=IO_OK) return res;
	return IO_OK;
	}

IOResult CellTex::Load(ILoad *iload)
	{
	IOResult res;
	int id;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(id=iload->CurChunkID())  {
			case MTL_HDR_CHUNK:
				res = MtlBase::Load(iload);
				break;
			}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
		}

	ParamBlock2PLCB* plcb = new ParamBlock2PLCB(versions, NUM_OLDVERSIONS, &cellular_param_blk, this, 0);
	iload->RegisterPostLoadCallback(plcb);

/*
	iload->RegisterPostLoadCallback(
		new ParamBlockPLCB(
			versions, 
			NUM_OLDVERSIONS, 
			&curVersion, this, 0));
*/
	return IO_OK;
	}

RefTargetHandle CellTex::Clone(RemapDir &remap)
	{
	CellTex *map = new CellTex;
	*((MtlBase*)map) = *((MtlBase*)this);  // copy superclass stuff
	map->ReplaceReference(0,remap.CloneRef(pblock));	
	map->ReplaceReference(1,remap.CloneRef(xyzGen));
	map->ReplaceReference(2,remap.CloneRef(texout));
	for (int i=0; i<NSUBTEX; i++) {
		if (subTex[i]) map->ReplaceReference(3+i,remap.CloneRef(subTex[i]));
		}
	return map;
	}

/*
ULONG CellTex::Requirements(int subMtlNum) 
	{
	return MTLREQ_XYZ;
	}
	*/

ULONG CellTex::LocalRequirements(int subMtlNum) 
	{
	return xyzGen->Requirements(subMtlNum);
	}

void CellTex::LocalMappingsRequired(int subMtlNum, BitArray & mapreq, BitArray &bumpreq) {  
	xyzGen->MappingsRequired(subMtlNum,mapreq,bumpreq); 
	}

RefResult CellTex::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
		PartID& partID, 
		RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			ivalid.SetEmpty();
			if (hTarget == pblock)
				{
				ParamID changing_param = pblock->LastNotifyParamID();
				cellular_param_blk.InvalidateUI(changing_param);
				}
		
			break;
/*
		case REFMSG_GET_PARAM_DIM: {
			GetParamDim *gpd = (GetParamDim*)partID;
			switch (gpd->index) {
				case PB_CELLCOL:
				case PB_DIVCOL1:
				case PB_DIVCOL2:	gpd->dim = stdColor255Dim; break;				
				case PB_SIZE:		gpd->dim =  stdWorldDim; break;
				default:			gpd->dim = defaultDim; break;
				}
			return REF_STOP; 
			}

		case REFMSG_GET_PARAM_NAME: {
			GetParamName *gpn = (GetParamName*)partID;
			switch (gpn->index) {				
				case PB_CELLCOL:  gpn->name = GetString(IDS_RB_CELLCOLOR); break;
				case PB_DIVCOL1:  gpn->name = GetString(IDS_RB_DIVCOLOR1); break;
				case PB_DIVCOL2:  gpn->name = GetString(IDS_RB_DIVCOLOR2); break;
				case PB_VAR:      gpn->name = GetString(IDS_RB_VARIATION); break;
				case PB_SIZE:     gpn->name = GetString(IDS_RB_SIZE); break;
				case PB_SPREAD:   gpn->name = GetString(IDS_RB_SPREAD); break;
				case PB_LOW:      gpn->name = GetString(IDS_RB_LOW); break;
				case PB_MID:      gpn->name = GetString(IDS_RB_MID); break;
				case PB_HIGH:     gpn->name = GetString(IDS_RB_HIGH); break;
				case PB_TYPE:     gpn->name = GetString(IDS_RB_TYPE); break;
				case PB_FRACT:    gpn->name = GetString(IDS_RB_FRACTAL); break;
				case PB_ITER:     gpn->name = GetString(IDS_RB_ITERATIONS); break;
				case PB_ROUGH:    gpn->name = GetString(IDS_RB_ROUGHNESS); break;
				case PB_SMOOTH:   gpn->name = GetString(IDS_RB_BUMPSMOOTHING); break;
				default:          gpn->name = GetString(IDS_RB_PARAMETER);  break;
				}
			return REF_STOP; 
			}
*/
		}
	return REF_SUCCEED;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\SurfWrap\wrap.cpp ===
/**********************************************************************
 *<
	FILE: wrap.cpp

	DESCRIPTION: Wrap one surface over another common files

	CREATED BY: Audrey Peterson

	HISTORY: 1/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "wrap.h"


HINSTANCE hInstance;
static int controlsInit = FALSE;

//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------
float Check1to1(float x)
{ return(x>1.0f?1.0f:(x<-1.0f?-1.0f:x));}

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
BOOL CALLBACK DefaultSOTProc(
		HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
	{
	IObjParam *ip = (IObjParam*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			if (ip) ip->RollupMouseMessage(hWnd,msg,wParam,lParam);
			return FALSE;

		default:
			return FALSE;
		}
	return TRUE;
	}
__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_AP_SURFWRAPLIB); }

// This function returns the number of plug-in classes this DLL implements
__declspec( dllexport ) int 
LibNumberClasses() { return 2; }

// This function return the ith class descriptor. We have one.
__declspec( dllexport ) ClassDesc* 
LibClassDesc(int i) {
	switch(i){
	case 0:return GetSWrapDesc();
    case 1:return GetSWrapModDesc();
//    case 2:return GetMSWrapModDesc();
    default:return 0;}
 }
// This function returns a pre-defined constant indicating the version of 
// the system under which it was compiled.  It is used to allow the system
// to catch obsolete DLLs.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) 
	{	
	// Hang on to this DLL's instance handle.
	hInstance = hinstDLL;

  	if (!controlsInit) {
		controlsInit = TRUE;		

	// Initialize MAX's custom controls
	InitCustomControls(hInstance);
		
	// Initialize Win95 controls
	InitCommonControls();
	}
	
	return(TRUE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\linkinfo.cpp ===
/**********************************************************************
 *<
	FILE: linkinfo.cpp

	DESCRIPTION:  A utility for editing link info across objects

	CREATED BY: Rolf Berteig

	HISTORY: created 02/14/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"

#define LINKINFO_CLASS_ID		Class_ID(0x0017d5e1,0x7730aa61)
#define LINKINFO_CNAME			GetString(IDS_RB_LINKINFO)

class LinkInfoUtil : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;		
		HWND hWnd;

		LinkInfoUtil();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);
		
		void SetStates(HWND hWnd);
		void SetBit(int bit, BOOL onOff);
	};
static LinkInfoUtil theLinkInfoUtil;

class LinkInfoUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theLinkInfoUtil;}
	const TCHAR *	ClassName() {return LINKINFO_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return LINKINFO_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static LinkInfoUtilClassDesc linkInfoUtilDesc;
ClassDesc* GetLinkInfoUtilDesc() {return &linkInfoUtilDesc;}

//-----------------------------------------------------------------------

static int ctrlIDs[] = {
	IDC_INHERIT_XTRANS,IDC_INHERIT_YTRANS,IDC_INHERIT_ZTRANS,
	IDC_INHERIT_XROT,IDC_INHERIT_YROT,IDC_INHERIT_ZROT,
	IDC_INHERIT_XSCALE,IDC_INHERIT_YSCALE,IDC_INHERIT_ZSCALE
	};

static int GetCtrlBit(int id)
	{
	for (int i=0; i<9; i++) {
		if (ctrlIDs[i]==id) return i;
		}
	return -1;
	}

static BOOL CALLBACK LinkInfoUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theLinkInfoUtil.SetStates(hWnd);
			break;

		case WM_DESTROY:			
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_INHERIT_XTRANS:
				case IDC_INHERIT_YTRANS:
				case IDC_INHERIT_ZTRANS:
				case IDC_INHERIT_XROT:
				case IDC_INHERIT_YROT:
				case IDC_INHERIT_ZROT:
				case IDC_INHERIT_XSCALE:
				case IDC_INHERIT_YSCALE:
				case IDC_INHERIT_ZSCALE: {
					int bit = GetCtrlBit(LOWORD(wParam));
					assert(bit>=0);
					theLinkInfoUtil.SetBit(bit,
						IsDlgButtonChecked(hWnd,LOWORD(wParam)));
					break;
					}

				case IDOK:
					theLinkInfoUtil.iu->CloseUtility();
					break;							
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theLinkInfoUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	

//-----------------------------------------------------------------------

LinkInfoUtil::LinkInfoUtil()
	{
	iu   = NULL;
	ip   = NULL;
	hWnd = NULL;
	}

void LinkInfoUtil::BeginEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = iu;
	this->ip = ip;
	hWnd = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_PRSLINKINFO),
		LinkInfoUtilDlgProc,
		GetString(IDS_RB_LINKINFO),
		0);
	}

void LinkInfoUtil::EndEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hWnd);	
	}

void LinkInfoUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	SetStates(hWnd);
	}

void LinkInfoUtil::SetStates(HWND hWnd)
	{
	DWORD cf=0, valid=0xffffffff, init=0;

	if (!ip->GetSelNodeCount()) {
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XTRANS),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YTRANS),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZTRANS),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XROT),  FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YROT),  FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZROT),  FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XSCALE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YSCALE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZSCALE),FALSE);
		return;
	} else {
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XTRANS),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YTRANS),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZTRANS),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XROT),  TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YROT),  TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZROT),  TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_XSCALE),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_YSCALE),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_INHERIT_ZSCALE),TRUE);
		}

	for (DWORD i=0; i<(DWORD)ip->GetSelNodeCount(); i++) {
		DWORD flags = ip->GetSelNode(i)->GetTMController()->
			GetInheritanceFlags();
		for (DWORD j=0; j<9; j++) {
			if (init&(1<<j)) {
				if ((cf&(1<<j)) != (flags&(1<<j))) {
					valid &= ~(1<<j);
					}
			} else {
				cf   |= flags & (1<<j);
				init |= (1<<j);
				}
			}
		}

	for (i=0; i<9; i++) {
		if (valid & (1<<i)) {
			MakeButton2State(GetDlgItem(hWnd,ctrlIDs[i]));
			CheckDlgButton(hWnd,ctrlIDs[i],cf&(1<<i)?FALSE:TRUE);
		} else {
			MakeButton3State(GetDlgItem(hWnd,ctrlIDs[i]));
			CheckDlgButton(hWnd,ctrlIDs[i],BST_INDETERMINATE);
			}		 
		}
	}

void LinkInfoUtil::SetBit(int bit, BOOL onOff)
	{
	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		DWORD flags = ~ip->GetSelNode(i)->GetTMController()->
			GetInheritanceFlags();

		if (onOff) 
			 flags |= (1<<bit);
		else flags &= ~(1<<bit);

		ip->GetSelNode(i)->GetTMController()->
			SetInheritanceFlags(flags,TRUE);
		ip->GetSelNode(i)->GetTMController()->
			NotifyDependents(FOREVER,0,REFMSG_CHANGE);
		}
	SetStates(hWnd);
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\appdata.cpp ===
/**********************************************************************
 *<
	FILE: appdata.cpp

	DESCRIPTION:  A utility to test appdata

	CREATED BY: Rolf Berteig

	HISTORY: created 3/10/96

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"

#define APPDATA_TEST_CLASS_ID		0xf6277abd

class AppDataTest : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;		
		ISpinnerControl *spin;

		AppDataTest();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

		Animatable *PickAnim();
		void GetAppData();
		void PutAppData();
	};
static AppDataTest theAppDataTest;

class AppDataTestClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theAppDataTest;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_APPDATATEST);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(APPDATA_TEST_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static AppDataTestClassDesc appDataTestDesc;
ClassDesc* GetAppDataTestDesc() {return &appDataTestDesc;}


static BOOL CALLBACK AppDataTestDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theAppDataTest.Init(hWnd);			
			break;
		
		case WM_DESTROY:
			theAppDataTest.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theAppDataTest.iu->CloseUtility();
					break;

				case IDC_APPDATA_GET:
					theAppDataTest.GetAppData();
					break;

				case IDC_APPDATA_PUT:
					theAppDataTest.PutAppData();
					break;

				case IDC_APPDATA_EDIT:
					switch (HIWORD(wParam)) {
						case EN_SETFOCUS:
							DisableAccelerators();
							break;
						case EN_KILLFOCUS:
							EnableAccelerators();
							break;
						}
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theAppDataTest.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE; 
	}

AppDataTest::AppDataTest()
	{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;	
	spin = NULL;
	}

void AppDataTest::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_APPDATA_PANEL),
		AppDataTestDlgProc,
		GetString(IDS_RB_APPDATATEST),
		0);
	}
	
void AppDataTest::EndEditParams(Interface *ip,IUtil *iu) 
	{	
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void AppDataTest::Init(HWND hWnd)
	{
	spin = SetupIntSpinner(hWnd,IDC_APPDATA_SLOTSPIN,IDC_APPDATA_SLOT,0,99999999,0);
	}

void AppDataTest::Destroy(HWND hWnd)
	{
	ReleaseISpinner(spin);
	}

Animatable *AppDataTest::PickAnim()
	{
	TrackViewPick pick;
	if (ip->TrackViewPickDlg(hPanel,&pick)) {
		return pick.anim;
	} else {
		return NULL;
		}
	}

void AppDataTest::GetAppData()
	{
	Animatable *anim = PickAnim();
	if (!anim) return;

	// Grab the app data chunk from the anim
	AppDataChunk *ad = 
		anim->GetAppDataChunk(
			Class_ID(APPDATA_TEST_CLASS_ID,0), 
			UTILITY_CLASS_ID, 
			spin->GetIVal());
	if (ad) {
		// Fill the edit field with the text.
		SetDlgItemText(hPanel,IDC_APPDATA_EDIT,(TCHAR*)ad->data);
	} else {
		// Not found!
		MessageBox(hPanel,_T("No app data found"),_T("App Data Tester"),MB_OK);
		}
	}

void AppDataTest::PutAppData()
	{
	Animatable *anim = PickAnim();
	if (!anim) return;

	// Load the text out of the edit field into a buffer
	int len = GetWindowTextLength(GetDlgItem(hPanel,IDC_APPDATA_EDIT))+1;
	TCHAR *buf = (TCHAR*)malloc(len*sizeof(TCHAR));
	GetWindowText(
		GetDlgItem(hPanel,IDC_APPDATA_EDIT),
		buf, len);
	buf[len-1] = '\0';

	// Remove the chunk if it exists
	anim->RemoveAppDataChunk(
		Class_ID(APPDATA_TEST_CLASS_ID,0), 
		UTILITY_CLASS_ID, 
		spin->GetIVal());

	// Add a chunk
	anim->AddAppDataChunk(
		Class_ID(APPDATA_TEST_CLASS_ID,0), 
		UTILITY_CLASS_ID, 
		spin->GetIVal(),
		(DWORD)len, buf);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\collapse.cpp ===
/**********************************************************************
 *<
	FILE: collapse.cpp

	DESCRIPTION:  A collapse utility

	CREATED BY: Rolf Berteig

	HISTORY: created 11/20/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"
#include "mnmath.h"

#define COLLAPSE_CLASS_ID		Class_ID(0xb338aad8,0x13c75c33)
#define COLLAPSE_CNAME			GetString(IDS_RB_COLLAPSE)

class CollapseUtil : public UtilityObj, public MeshOpProgress {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		int collapseTo, outputType, boolType;
		BOOL dobool, canceled;
		int total;

		CollapseUtil();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void SetStates(HWND hWnd);

		void DoCollapse();

		// From MeshOpProgress
		void Init(int total);		
		BOOL Progress(int p);
	};
static CollapseUtil theCollapseUtil;

class CollapseUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theCollapseUtil;}
	const TCHAR *	ClassName() {return COLLAPSE_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return COLLAPSE_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static CollapseUtilClassDesc collapseUtilDesc;
ClassDesc* GetCollapseUtilDesc() {return &collapseUtilDesc;}


static BOOL CALLBACK CollapseUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theCollapseUtil.Init(hWnd);
			break;

		case WM_DESTROY:
			theCollapseUtil.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theCollapseUtil.iu->CloseUtility();
					break;
					
				case IDC_C_MULTIPLE:
				case IDC_C_SINGLE:
					theCollapseUtil.collapseTo = LOWORD(wParam);
					theCollapseUtil.SetStates(hWnd);
					break;

				case IDC_C_BOOL:
					theCollapseUtil.dobool = IsDlgButtonChecked(hWnd,IDC_C_BOOL);
					theCollapseUtil.SetStates(hWnd);
					break;

				case IDC_C_UNION:
				case IDC_C_SUBTRACTION:
				case IDC_C_INTERSECTION:
					theCollapseUtil.boolType = LOWORD(wParam);
					theCollapseUtil.SetStates(hWnd);
					break;

				case IDC_C_STACKRESULT:
				case IDC_C_MESH:
					theCollapseUtil.outputType = LOWORD(wParam);
					theCollapseUtil.SetStates(hWnd);					
					break;

				case IDC_C_COLLAPSE:
					theCollapseUtil.DoCollapse();
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theCollapseUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	


CollapseUtil::CollapseUtil()
	{	
	collapseTo = IDC_C_SINGLE;
	outputType = IDC_C_MESH;	
	dobool     = FALSE;
	boolType   = IDC_C_UNION;
	}

void CollapseUtil::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_COLLAPSE_PANEL),
		CollapseUtilDlgProc,
		GetString(IDS_RB_COLLAPSE),
		0);
	}
	
void CollapseUtil::EndEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void CollapseUtil::Init(HWND hWnd)
	{
	hPanel = hWnd;
	CheckDlgButton(hWnd,collapseTo,TRUE);
	CheckDlgButton(hWnd,outputType,TRUE);
	CheckDlgButton(hWnd,IDC_C_BOOL,dobool);
	CheckDlgButton(hWnd,boolType,TRUE);
	SelectionSetChanged(ip,iu);	
	}

void CollapseUtil::SetStates(HWND hWnd)
	{
	if (ip->GetSelNodeCount()) {
		EnableWindow(GetDlgItem(hPanel,IDC_C_COLLAPSE),TRUE);
	} else {
		EnableWindow(GetDlgItem(hPanel,IDC_C_COLLAPSE),FALSE);
		}

	if (theCollapseUtil.outputType==IDC_C_STACKRESULT) {
		EnableWindow(GetDlgItem(hWnd,IDC_C_BOOL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_MULTIPLE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_SINGLE),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_COLLPASETOLABEL),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_UNION),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_INTERSECTION),FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_SUBTRACTION),FALSE);
	} else {
		if (theCollapseUtil.collapseTo==IDC_C_SINGLE) {
			EnableWindow(GetDlgItem(hWnd,IDC_C_BOOL),TRUE);
			if (theCollapseUtil.dobool) {
				EnableWindow(GetDlgItem(hWnd,IDC_C_UNION),TRUE);
				EnableWindow(GetDlgItem(hWnd,IDC_C_INTERSECTION),TRUE);
				EnableWindow(GetDlgItem(hWnd,IDC_C_SUBTRACTION),TRUE);			
			} else {
				EnableWindow(GetDlgItem(hWnd,IDC_C_UNION),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_C_INTERSECTION),FALSE);
				EnableWindow(GetDlgItem(hWnd,IDC_C_SUBTRACTION),FALSE);
				}
		} else {
			EnableWindow(GetDlgItem(hWnd,IDC_C_BOOL),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_C_UNION),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_C_INTERSECTION),FALSE);
			EnableWindow(GetDlgItem(hWnd,IDC_C_SUBTRACTION),FALSE);			
			}		
		EnableWindow(GetDlgItem(hWnd,IDC_C_MULTIPLE),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_SINGLE),TRUE);
		EnableWindow(GetDlgItem(hWnd,IDC_C_COLLPASETOLABEL),TRUE);											
		}
	}

void CollapseUtil::Destroy(HWND hWnd)
	{		
	hPanel = NULL;
	}

void CollapseUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	SetStates(hPanel);
	if (ip->GetSelNodeCount()==1) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,ip->GetSelNode(0)->GetName());
	} else if (ip->GetSelNodeCount()) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_MULTISEL));
	} else {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_NONESEL));
		}	
	}

static ULONG _stdcall Function(void *foo) {return 0;}

void CollapseUtil::DoCollapse()
	{
	INode *node;
	TriObject *tobj = NULL;
	Tab<INode*> delNode;
	INodeTab flash;

	Matrix3 tm1, tm2;
	int type;	

	switch (boolType) {
		default:
		case IDC_C_UNION: type = MESHBOOL_UNION; break;
		case IDC_C_INTERSECTION: type = MESHBOOL_INTERSECTION; break;
		case IDC_C_SUBTRACTION: type = MESHBOOL_DIFFERENCE; break;
		}

	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		// Get a selected node
		node = ip->GetSelNode(i);
		flash.Append(1,&node,10);

		// Eval the node's object (exclude WSMs)
		Object *oldObj = node->GetObjectRef();
		
		// Check for NULL
		if (!oldObj) continue;

		// Skip bones
		if (oldObj->ClassID()==Class_ID(BONE_CLASS_ID,0)) continue;		

		// RB 6/14/99: Skip system nodes too
		Control *tmCont = node->GetTMController();
		if (tmCont && GetMasterController(tmCont)) continue;

		ObjectState os = oldObj->Eval(ip->GetTime());
		Object *obj = (Object*)os.obj->Clone();

		if (outputType==IDC_C_STACKRESULT) {
			// Make the result of the stack the new object
			oldObj->SetAFlag(A_LOCK_TARGET);
			node->SetObjectRef(obj);		
			oldObj->ClearAFlag(A_LOCK_TARGET);
			oldObj->MaybeAutoDelete();
		} else {
			if (collapseTo==IDC_C_SINGLE) {
				if (os.obj->CanConvertToType(triObjectClassID)) {
					// Convert to a TriObject
					TriObject *ntobj = (TriObject*)obj->ConvertToType(ip->GetTime(),triObjectClassID);
					
					if (!tobj) {
						// First one
						tobj = ntobj;
						oldObj->SetAFlag(A_LOCK_TARGET);
						node->SetObjectRef(tobj);		
						oldObj->ClearAFlag(A_LOCK_TARGET);
						tm1 = node->GetObjTMBeforeWSM(ip->GetTime());
					} else
					if (dobool) {
						Mesh mesh;
						tm2 = node->GetObjTMBeforeWSM(ip->GetTime());
						
						TSTR title(GetString(IDS_RB_BOOLEAN));
						title = title + TSTR(node->GetName());
						ip->ProgressStart(title, TRUE, Function, 0);

						// Steve Anderson, March 1998: switch to new Boolean.
						MNMesh op1 (tobj->GetMesh());
						MNMesh op2 (ntobj->GetMesh());
						op1.Transform (tm1);
						op2.Transform (tm2);
						op1.PrepForBoolean ();
						op2.PrepForBoolean ();
						MNMesh out;
						out.MakeBoolean (op1, op2, type, this);

// RB 2/19/99: This seems to fix the bug where operands get scattered around. Don't know why we'd want to just fix it in Viz.
//#ifdef DESIGN_VER
						out.Transform(Inverse(tm1));
//#endif
						mesh.FreeAll ();
						out.OutToTri (mesh);
						/*
						BOOL res = CalcBoolOp(
							mesh, 
							tobj->mesh, 
							ntobj->mesh, 
							type, this, &tm1, &tm2);
							*/
						
						ip->ProgressEnd();
						if (canceled) break;

						tobj->GetMesh() = mesh;
						delNode.Append(1,&node);
					} else {
						Mesh mesh;
						tm2 = node->GetObjTMBeforeWSM(ip->GetTime());
						CombineMeshes(
							mesh, tobj->GetMesh(), ntobj->GetMesh(),
							&tm1, &tm2);
						tobj->GetMesh() = mesh;
						delNode.Append(1,&node);
						}
					
					if (obj!=ntobj) obj->AutoDelete();
				} else {
					// Can't convert it.
					obj->AutoDelete();
					}
			} else {
				if (os.obj->CanConvertToType(triObjectClassID)) {
					// Convert it to a TriObject and make that the new object
					tobj = (TriObject*)obj->ConvertToType(ip->GetTime(),triObjectClassID);
					oldObj->SetAFlag(A_LOCK_TARGET);
					node->SetObjectRef(tobj);		
					oldObj->ClearAFlag(A_LOCK_TARGET);
					if (obj!=tobj) obj->AutoDelete();
					}
				}
			}
		}
	// Flash nodes
	ip->FlashNodes(&flash);

	// Now delete node's that were collpased
	for (i=0; i<delNode.Count(); i++) {
		ip->DeleteNode(delNode[i],FALSE);
		}

	ip->RedrawViews(ip->GetTime());
	GetSystemSetting(SYSSET_CLEAR_UNDO);
	}

void CollapseUtil::Init(int total)
	{
	this->total = total;
	canceled = FALSE;
	}

BOOL CollapseUtil::Progress(int p)
	{
	int pct = total?(p*100)/total:100;
	ip->ProgressUpdate(pct);
	if (ip->GetCancel()) {
		ip->SetCancel(FALSE);
		canceled = TRUE;
		return FALSE;
	} else {
		return TRUE;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\colclip.cpp ===
/**********************************************************************
 *<
	FILE: colclip.cpp

	DESCRIPTION:  A simple color swatch clipboard

	CREATED BY: Rolf Berteig

	HISTORY: created December 23 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"

#define COLOR_CLIP_CLASS_ID		0x8fbc04e9

#define NUM_COLORS			4
#define NUM_FLOAT_COLORS	12

static int csIDs[] = {
	IDC_COLOR_SWATCH1,IDC_COLOR_SWATCH2,IDC_COLOR_SWATCH3,
	IDC_COLOR_SWATCH4,IDC_COLOR_SWATCH5,IDC_COLOR_SWATCH6,
	IDC_COLOR_SWATCH7,IDC_COLOR_SWATCH8,IDC_COLOR_SWATCH9,
	IDC_COLOR_SWATCH10,IDC_COLOR_SWATCH11,IDC_COLOR_SWATCH12};

class ColorClip : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		Color colors[NUM_COLORS];
		IColorSwatch *cs[NUM_COLORS];

		ColorClip();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void CreateNewFloater();
	};
static ColorClip theColorClip;

class ColorClipClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theColorClip;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_COLORCLIPBOARD);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(COLOR_CLIP_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static ColorClipClassDesc colorClipDesc;
ClassDesc* GetColorClipDesc() {return &colorClipDesc;}


static BOOL CALLBACK ColorClipDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theColorClip.Init(hWnd);
			break;

		case WM_DESTROY:
			theColorClip.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theColorClip.iu->CloseUtility();
					break;
				
				case IDC_COLORCLIP_NEWFLOAT:
					theColorClip.CreateNewFloater();
					break;
				}
			break;

		case CC_COLOR_CHANGE:
			switch (LOWORD(wParam)) {
				case IDC_COLOR_SWATCH1:
					theColorClip.colors[0] = theColorClip.cs[0]->GetColor();
					break;	
				case IDC_COLOR_SWATCH2:
					theColorClip.colors[1] = theColorClip.cs[1]->GetColor();
					break;	
				case IDC_COLOR_SWATCH3:
					theColorClip.colors[2] = theColorClip.cs[2]->GetColor();
					break;
				case IDC_COLOR_SWATCH4:
					theColorClip.colors[3] = theColorClip.cs[3]->GetColor();
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theColorClip.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	

static TCHAR fname[256] = {'\0'};

void SetupTitle(HWND hWnd,TSTR &name)
	{
	TSTR fl, ext;
	SplitFilename(name,NULL,&fl,&ext);
	fl = TSTR(GetString(IDS_RB_COLORCLIPSHORT)) + 
		TSTR(_T(" - ")) + fl + ext;
	SetWindowText(hWnd,fl);
	}

static void LoadColorFile(HWND hWnd)
	{	
	OPENFILENAME ofn;
	memset(&ofn,0,sizeof(ofn));
	FilterList fl;
	fl.Append(GetString(IDS_RB_COLORCLIPFILES));
	fl.Append(_T("*.ccb"));
	TSTR title = GetString(IDS_RB_LOADCOLOR);
	ofn.lStructSize     = sizeof(OPENFILENAME);
	ofn.hwndOwner       = hWnd;
	ofn.lpstrFilter     = fl;
	ofn.lpstrFile       = fname;
	ofn.nMaxFile        = 256;    
	ofn.lpstrInitialDir = GetCOREInterface()->GetDir(APP_IMAGE_DIR);
	ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
	ofn.lpstrDefExt     = _T("ccb");
	ofn.lpstrTitle      = title;

	if (GetOpenFileName(&ofn)) {
		FILE *file = fopen(fname,_T("rt"));
		if (!file) {
			TSTR buf2 = GetString(IDS_RB_COLORCLIPBOARD);
			TSTR buf1;
			buf1.printf(GetString(IDS_RB_CANTOPENFILE),fname);			
			MessageBox(hWnd,buf1,buf2,MB_ICONEXCLAMATION);
			return;
			}
		
		for (int i=0; i<12; i++) {
			int r, g, b;
			if (EOF==fscanf(file,"%d %d %d",&r, &g, &b)) break;
			Color color(float(r)/255.0f,float(g)/255.0f,float(b)/255.0f);
			TSTR name;
			name.printf(GetString(IDS_RB_COLORNUM),i);
			IColorSwatch *cs = GetIColorSwatch(
				GetDlgItem(hWnd,csIDs[i]),color,name);			
			ReleaseIColorSwatch(cs);
			}		
		
		fclose(file);

		TSTR *fileName = (TSTR*)GetWindowLong(hWnd,GWL_USERDATA);
		delete fileName;
		fileName = new TSTR(fname);
		SetWindowLong(hWnd,GWL_USERDATA,(LONG)fileName);
		SetupTitle(hWnd,*fileName);
		}	
	}

static void SaveColorFile(HWND hWnd,TSTR &name)
	{
	FILE *file = fopen(fname,_T("wt"));
	if (!file) {
		TSTR buf2 = GetString(IDS_RB_COLORCLIPBOARD);
		TSTR buf1;
		buf1.printf(GetString(IDS_RB_CANTOPENFILE),fname);			
		MessageBox(hWnd,buf1,buf2,MB_ICONEXCLAMATION);
		return;
		}

	for (int i=0; i<12; i++) {
		int r, g, b;		
		IColorSwatch *cs = GetIColorSwatch(GetDlgItem(hWnd,csIDs[i]));
		COLORREF col = cs->GetColor();
		ReleaseIColorSwatch(cs);
		r = GetRValue(col); g = GetGValue(col); b = GetBValue(col);
		fprintf(file,"%d %d %d\n", r, g, b);
		}	

	SetupTitle(hWnd,name);
	fclose(file);
	}

static void SaveAsColorFile(HWND hWnd) 
	{
	TSTR *fileName = (TSTR*)GetWindowLong(hWnd,GWL_USERDATA);
	if (fileName) _tcscpy(fname,fileName->data());		
	
	OPENFILENAME ofn;
	memset(&ofn,0,sizeof(ofn));
	FilterList fl;
	fl.Append(GetString(IDS_RB_COLORCLIPFILES));
	fl.Append(_T("*.ccb"));
	TSTR title = GetString(IDS_RB_SAVECOLOR);
	ofn.lStructSize     = sizeof(OPENFILENAME);
	ofn.hwndOwner       = hWnd;
	ofn.lpstrFilter     = fl;
	ofn.lpstrFile       = fname;
	ofn.nMaxFile        = 256;    
	ofn.lpstrInitialDir = GetCOREInterface()->GetDir(APP_IMAGE_DIR);
	ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
	ofn.lpstrDefExt     = _T("ccb");
	ofn.lpstrTitle      = title;

tryAgain:
	if (GetSaveFileName(&ofn)) {
		if (DoesFileExist(fname)) {
			TSTR buf1;
			TSTR buf2 = GetString(IDS_RB_SAVECOLOR);
			buf1.printf(GetString(IDS_RB_FILEEXISTS),fname);
			if (IDYES!=MessageBox(
				hWnd,
				buf1,buf2,MB_YESNO|MB_ICONQUESTION)) {
				goto tryAgain;
				}
			}
		
		if (!fileName) fileName = new TSTR;
		*fileName = fname;
		SetWindowLong(hWnd,GWL_USERDATA,(LONG)fileName);

		SaveColorFile(hWnd,*fileName);		
		}	
	}

static BOOL CALLBACK ColorClipFloaterDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG: {
			CenterWindow(hWnd,GetParent(hWnd));
			Color color(0.5f,0.5f,0.5f);
			for (int i=0; i<NUM_FLOAT_COLORS; i++) {
				TSTR name;
				name.printf(GetString(IDS_RB_COLORNUM),i);
				IColorSwatch *cs = GetIColorSwatch(
					GetDlgItem(hWnd,csIDs[i]),color,name);
				ReleaseIColorSwatch(cs);
				}
			break;
			}
		
		case WM_DESTROY: {
			TSTR *fileName = (TSTR*)GetWindowLong(hWnd,GWL_USERDATA);
			delete fileName;
			break;
			}

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_COLOR_LOAD:
					LoadColorFile(hWnd);
					break;
				
				case IDC_COLOR_SAVE: {
					TSTR *fileName = (TSTR*)GetWindowLong(hWnd,GWL_USERDATA);
					if (fileName) SaveColorFile(hWnd,*fileName);
					else SaveAsColorFile(hWnd);						
					break;
					}

				case IDC_COLOR_SAVEAS:
					SaveAsColorFile(hWnd);
					break;

				case IDOK:
				case IDCANCEL:
					DestroyWindow(hWnd);
					break;
				}
			break;

		default:
			return FALSE;
		}

	return TRUE;
	}

ColorClip::ColorClip()
	{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
	srand(0);
	for (int i=0; i<NUM_COLORS; i++) {		
		cs[i] = NULL;
		colors[i].r = float(rand())/float(RAND_MAX);
		colors[i].g = float(rand())/float(RAND_MAX);
		colors[i].b = float(rand())/float(RAND_MAX);
		}
	}

void ColorClip::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_COLORCLIP_PANEL),
		ColorClipDlgProc,
		GetString(IDS_RB_COLORCLIPBOARD),
		0);
	}
	
void ColorClip::EndEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void ColorClip::Init(HWND hWnd)
	{
	for (int i=0; i<NUM_COLORS; i++) {
		TSTR name;
		name.printf(GetString(IDS_RB_COLORNUM),i);
		cs[i] = GetIColorSwatch(GetDlgItem(hWnd,csIDs[i]),colors[i],name);
		cs[i]->SetColor(colors[i]);
		}
	}

void ColorClip::Destroy(HWND hWnd)
	{
	for (int i=0; i<NUM_COLORS; i++) {
		ReleaseIColorSwatch(cs[i]);
		cs[i] = NULL;
		}
	}

void ColorClip::CreateNewFloater()
	{
	CreateDialog(
		hInstance,
		MAKEINTRESOURCE(IDD_COLORCLIP_FLOATER),
		ip->GetMAXHWnd(),
		ColorClipFloaterDlgProc);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ortkeys.cpp ===
/**********************************************************************
 *<
	FILE: ortkeys.cpp

	DESCRIPTION: A Track View Utility that creates key for out of range animation

	CREATED BY: Rolf Berteig

	HISTORY: created 12/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "tvutil.h"
#include "istdplug.h"

#define ORT_KEYS_NAME		GetString(IDS_RB_ORTKEYS)
#define ORT_KEYS_CLASS_ID	Class_ID(0x811ff4ba,0x20dd06ab)

class ORTKeysUtil : public TrackViewUtility {
	public:
		Interface *ip;
		ITVUtility *iu;
		HWND hWnd;
		ISpinnerControl *iBefore, *iAfter, *iSamp;
		TimeValue before, after;				
		int samples;		

		ORTKeysUtil();
		void DeleteThis() {} 
		void BeginEditParams(Interface *ip,ITVUtility *iu);
		void EndEditParams(Interface *ip,ITVUtility *iu);				

		void SetupWindow(HWND hWnd);
		void Destroy();
		void SpinnerChange(int id);		
		void Apply();
		void SampleORT(void *tab,Control *cont, TimeValue start, TimeValue end);
		void MakeORTKeys(void *tab,Control *cont, TimeValue start, TimeValue end);
	};

class ORTKeysClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new ORTKeysUtil;}
	const TCHAR *	ClassName() {return ORT_KEYS_NAME;}
	SClass_ID		SuperClassID() {return TRACKVIEW_UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return ORT_KEYS_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static ORTKeysClassDesc ortKeysDesc;
ClassDesc* GetORTKeysDesc() {return &ortKeysDesc;}

ORTKeysUtil::ORTKeysUtil()
	{
	ip = NULL;
	iu = NULL;
	hWnd = NULL;
	before = after = 1600;	
	samples = 10;
	}

static BOOL CALLBACK ORTKeysDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	ORTKeysUtil *util = (ORTKeysUtil*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			util = (ORTKeysUtil*)lParam;
			util->SetupWindow(hWnd);
			CenterWindow(hWnd,GetParent(hWnd));
			break;

		case CC_SPINNER_CHANGE:
			util->SpinnerChange(LOWORD(wParam));			
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {				
				case IDC_ORTKEYS_APPLY:
					util->Apply();
					break;
				}
			break;

		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			util->Destroy();			
			delete util;
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void ORTKeysUtil::SpinnerChange(int id) 
	{
	switch (id) {
		case IDC_ORTKEYS_BEFORESPIN:
			before = iBefore->GetIVal(); break;
		case IDC_ORTKEYS_AFTERSPIN:
			after = iAfter->GetIVal(); break;		
		case IDC_ORTKEYS_SAMPLESSPIN:
			samples = iSamp->GetIVal(); break;
		}
	}

void ORTKeysUtil::SetupWindow(HWND hWnd)
	{	
	this->hWnd = hWnd;
	
	iBefore = GetISpinner(GetDlgItem(hWnd,IDC_ORTKEYS_BEFORESPIN));
	iBefore->SetLimits(0, TIME_PosInfinity, FALSE);
	iBefore->SetScale(10.0f);
	iBefore->LinkToEdit(GetDlgItem(hWnd,IDC_ORTKEYS_BEFORE), EDITTYPE_TIME);
	iBefore->SetValue(before,FALSE);

	iAfter = GetISpinner(GetDlgItem(hWnd,IDC_ORTKEYS_AFTERSPIN));
	iAfter->SetLimits(0, TIME_PosInfinity, FALSE);
	iAfter->SetScale(10.0f);
	iAfter->LinkToEdit(GetDlgItem(hWnd,IDC_ORTKEYS_AFTER), EDITTYPE_TIME);
	iAfter->SetValue(before,FALSE);

	iSamp = GetISpinner(GetDlgItem(hWnd,IDC_ORTKEYS_SAMPLESSPIN));
	iSamp->SetLimits(1, 999999999, FALSE);
	iSamp->SetScale(0.1f);
	iSamp->LinkToEdit(GetDlgItem(hWnd,IDC_ORTKEYS_SAMPLES), EDITTYPE_INT);
	iSamp->SetValue(samples,FALSE);
	}

void ORTKeysUtil::Destroy()
	{
	ReleaseISpinner(iBefore);
	ReleaseISpinner(iAfter);	
	ReleaseISpinner(iSamp);
	iu->TVUtilClosing(this);
	}

void ORTKeysUtil::BeginEditParams(Interface *ip,ITVUtility *iu)
	{
	this->ip = ip;
	this->iu = iu;	
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_ORT_KEYS),
		iu->GetTrackViewHWnd(),
		ORTKeysDlgProc,
		(LONG)this);
	}

void ORTKeysUtil::EndEditParams(Interface *ip,ITVUtility *iu)
	{
	this->ip = NULL;
	this->iu = NULL;
	}

void ORTKeysUtil::SampleORT(
		void *tab,Control *cont, TimeValue start, TimeValue end)
	{
	Tab<float> *ftab = (Tab<float>*)tab;
	Tab<Point3> *pttab = (Tab<Point3>*)tab;
	Tab<ScaleValue> *stab = (Tab<ScaleValue>*)tab;
	Tab<Quat> *qtab = (Tab<Quat>*)tab;

	switch (cont->SuperClassID()) {
		case CTRL_FLOAT_CLASS_ID:			
			ftab->SetCount(samples);
			break;

		case CTRL_POSITION_CLASS_ID:
		case CTRL_POINT3_CLASS_ID:
			pttab->SetCount(samples);
			break;
		
		case CTRL_ROTATION_CLASS_ID:
			qtab->SetCount(samples);
			break;

		case CTRL_SCALE_CLASS_ID:
			stab->SetCount(samples);
			break;
		}

	// First fill a table full of values
	for (int i=0; i< samples; i++) {
		float u = float(i+1)/float(samples);
		TimeValue t = int(u*end) + int((1.0f-u)*start);

		switch (cont->SuperClassID()) {
			case CTRL_FLOAT_CLASS_ID:			
				cont->GetValue(t,&(*ftab)[i],FOREVER);
				break;

			case CTRL_POSITION_CLASS_ID:
			case CTRL_POINT3_CLASS_ID:
				cont->GetValue(t,&(*pttab)[i],FOREVER);				
				break;
			
			case CTRL_ROTATION_CLASS_ID:
				cont->GetValue(t,&(*qtab)[i],FOREVER);
				break;

			case CTRL_SCALE_CLASS_ID:
				cont->GetValue(t,&(*stab)[i],FOREVER);
				break;
			}
		}
	}

void ORTKeysUtil::MakeORTKeys(
		void *tab,Control *cont, TimeValue start, TimeValue end)
	{
	Tab<float> *ftab = (Tab<float>*)tab;
	Tab<Point3> *pttab = (Tab<Point3>*)tab;
	Tab<ScaleValue> *stab = (Tab<ScaleValue>*)tab;
	Tab<Quat> *qtab = (Tab<Quat>*)tab;

	// Temporarily suspend ORTs
	cont->EnableORTs(FALSE);

	// Now set the keys
	for (int i=0; i< samples; i++) {
		float u = float(i+1)/float(samples);
		TimeValue t = int(u*end) + int((1.0f-u)*start);

		switch (cont->SuperClassID()) {
			case CTRL_FLOAT_CLASS_ID:			
				cont->SetValue(t,&(*ftab)[i]);
				break;

			case CTRL_POSITION_CLASS_ID:
			case CTRL_POINT3_CLASS_ID:
				cont->SetValue(t,&(*pttab)[i]);
				break;
			
			case CTRL_ROTATION_CLASS_ID:
				cont->SetValue(t,&(*qtab)[i]);
				break;

			case CTRL_SCALE_CLASS_ID:
				cont->SetValue(t,&(*stab)[i]);
				break;
			}
		}

	// Turn ORTs back on.
	cont->EnableORTs(TRUE);
	}

void ORTKeysUtil::Apply()
	{
	Tab<float> ftabB, ftabA;
	Tab<Point3> pttabB, pttabA;
	Tab<ScaleValue> stabB, stabA;
	Tab<Quat> qtabB, qtabA;
	void *tabB, *tabA;

	BOOL fcurveMode = iu->GetMajorMode()==TVMODE_EDITFCURVE;

	theHold.Begin();

	// Turn animation on
	SuspendAnimate();
	AnimateOn();

	for (int i=0; i<iu->GetNumTracks(); i++) {
		if (!iu->IsSelected(i)) continue;

		// Get the control interface
		Control *cont = GetControlInterface(iu->GetAnim(i));
		if (!cont || !cont->IsLeaf() || !cont->IsKeyable()) continue;

		// Curve has to be selected when in fcurve mode.
		if (fcurveMode && !cont->IsCurveSelected()) continue;

		// Get the time range
		Interval range = cont->GetTimeRange(TIMERANGE_ALL);

		// Set the appropriate table pointers
		switch (cont->SuperClassID()) {
			case CTRL_FLOAT_CLASS_ID:			
				tabB = &ftabB; tabA = &ftabA;
				break;

			case CTRL_POSITION_CLASS_ID:
			case CTRL_POINT3_CLASS_ID:
				tabB = &pttabB; tabA = &pttabA;
				break;
			
			case CTRL_ROTATION_CLASS_ID:
				tabB = &qtabB; tabA = &qtabA;
				break;

			case CTRL_SCALE_CLASS_ID:
				tabB = &stabB; tabA = &stabA;
				break;

			default: return;
			}

		// Samples the leys
		if (cont->GetORT(ORT_BEFORE)!=ORT_CONSTANT && before) {			
			SampleORT(tabB, cont, range.Start(), range.Start()-before);
			}		
		if (cont->GetORT(ORT_AFTER)!=ORT_CONSTANT && after) {
			SampleORT(tabA, cont, range.End(), range.End()+after);
			}		

		// Make new keys
		if (cont->GetORT(ORT_BEFORE)!=ORT_CONSTANT && before) {			
			MakeORTKeys(tabB, cont, range.Start(), range.Start()-before);
			}		
		if (cont->GetORT(ORT_AFTER)!=ORT_CONSTANT && after) {
			MakeORTKeys(tabA, cont, range.End(), range.End()+after);
			}		
		}

	ResumeAnimate();

	theHold.Accept(GetString(IDS_RB_CREATEORTKEYS));
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\randkeys.cpp ===
/**********************************************************************
 *<
	FILE: randkeys.cpp

	DESCRIPTION: A Track View Utility that randomizes keys

	CREATED BY: Rolf Berteig

	HISTORY: created 12/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "tvutil.h"
#include "istdplug.h"

#define RAND_KEYS_NAME		GetString(IDS_RB_RANDKEYS)
#define RAND_KEYS_CLASS_ID	Class_ID(0x811ff4ba,0x20dd06ac)

class RandKeysUtil : public TrackViewUtility {
	public:
		Interface *ip;
		ITVUtility *iu;
		HWND hWnd;
		ISpinnerControl *iPosTime, *iNegTime, *iPosVal, *iNegVal;
		TimeValue posTime, negTime;
		float posVal, negVal;
		BOOL doTime, doVal;

		RandKeysUtil();
		void DeleteThis() {} 
		void BeginEditParams(Interface *ip,ITVUtility *iu);
		void EndEditParams(Interface *ip,ITVUtility *iu);
		void MajorModeChanged() {SetStates();}
		void TimeSelectionChanged() {SetStates();}

		void SetupWindow(HWND hWnd);
		void Destroy();
		void SpinnerChange(int id);
		void SetStates();
		void Apply();
	};

class RandKeysClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return new RandKeysUtil;}
	const TCHAR *	ClassName() {return RAND_KEYS_NAME;}
	SClass_ID		SuperClassID() {return TRACKVIEW_UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return RAND_KEYS_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static RandKeysClassDesc randKeysDesc;
ClassDesc* GetRandKeysDesc() {return &randKeysDesc;}

RandKeysUtil::RandKeysUtil()
	{
	ip = NULL;
	iu = NULL;
	hWnd = NULL;
	posTime = negTime = 160;
	posVal = negVal = 10.0f;
	doTime = TRUE;
	doVal = TRUE;
	}

static BOOL CALLBACK RandKeysDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	RandKeysUtil *util = (RandKeysUtil*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			util = (RandKeysUtil*)lParam;
			util->SetupWindow(hWnd);
			CenterWindow(hWnd,GetParent(hWnd));
			break;

		case CC_SPINNER_CHANGE:
			util->SpinnerChange(LOWORD(wParam));			
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {				
				case IDC_RANDKEYS_TIME:
					util->doTime = IsDlgButtonChecked(hWnd,LOWORD(wParam));
					util->SetStates();
					break;

				case IDC_RANDKEYS_VAL:
					util->doVal = IsDlgButtonChecked(hWnd,LOWORD(wParam));
					util->SetStates();
					break;

				case IDC_RANDKEYS_APPLY:
					util->Apply();
					break;
				}
			break;

		case WM_CLOSE:
			DestroyWindow(hWnd);
			break;

		case WM_DESTROY:
			util->Destroy();			
			delete util;
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void RandKeysUtil::SpinnerChange(int id) 
	{
	switch (id) {
		case IDC_RANDKEYS_POSTIMESPIN:
			posTime = iPosTime->GetIVal(); break;
		case IDC_RANDKEYS_NEGTIMESPIN:
			negTime = iNegTime->GetIVal(); break;
		case IDC_RANDKEYS_POSVALSPIN:
			posVal = iPosVal->GetFVal(); break;
		case IDC_RANDKEYS_NEGVALSPIN:
			negVal = iNegVal->GetFVal(); break;
		}
	}

void RandKeysUtil::SetStates()
	{
	if (doTime) {
		iPosTime->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_POSTIMELABEL),TRUE);
		iNegTime->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_NEGTIMELABEL),TRUE);
	} else {
		iPosTime->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_POSTIMELABEL),FALSE);
		iNegTime->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_NEGTIMELABEL),FALSE);
		}

	if (doVal) {
		iPosVal->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_POSVALLABEL),TRUE);
		iNegVal->Enable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_NEGVALLABEL),TRUE);
	} else {
		iPosVal->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_POSVALLABEL),FALSE);
		iNegVal->Disable();
		EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_NEGVALLABEL),FALSE);
		}

	switch (iu->GetMajorMode()) {
		case TVMODE_EDITKEYS:
		case TVMODE_EDITFCURVE:
			SetDlgItemText(hWnd,IDC_RANDKEYS_TEXT,
				GetString(IDS_RANDKEYS_KEYTEXT));
			EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_APPLY),TRUE);
			break;

		case TVMODE_EDITTIME: {
			Interval iv = iu->GetTimeSelection();
			TSTR buf, start, end;
			TimeToString(iv.Start(),start);
			TimeToString(iv.End(),end);
			buf.printf(GetString(IDS_RANDKEYS_TIMETEXT),start,end);
			SetDlgItemText(hWnd,IDC_RANDKEYS_TEXT,buf);
			EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_APPLY),TRUE);
			break;
			}

		case TVMODE_EDITRANGES:
		case TVMODE_POSRANGES:
			SetDlgItemText(hWnd,IDC_RANDKEYS_TEXT,_T(""));
			EnableWindow(GetDlgItem(hWnd,IDC_RANDKEYS_APPLY),FALSE);
			break;
		
		}
	}

void RandKeysUtil::SetupWindow(HWND hWnd)
	{	
	this->hWnd = hWnd;

	CheckDlgButton(hWnd,IDC_RANDKEYS_TIME,doTime);
	CheckDlgButton(hWnd,IDC_RANDKEYS_VAL,doVal);

	iPosTime = GetISpinner(GetDlgItem(hWnd,IDC_RANDKEYS_POSTIMESPIN));
	iPosTime->SetLimits(0, TIME_PosInfinity, FALSE);
	iPosTime->SetScale(10.0f);
	iPosTime->LinkToEdit(GetDlgItem(hWnd,IDC_RANDKEYS_POSTIME), EDITTYPE_TIME);
	iPosTime->SetValue(posTime,FALSE);

	iNegTime = GetISpinner(GetDlgItem(hWnd,IDC_RANDKEYS_NEGTIMESPIN));
	iNegTime->SetLimits(0, TIME_PosInfinity, FALSE);
	iNegTime->SetScale(10.0f);
	iNegTime->LinkToEdit(GetDlgItem(hWnd,IDC_RANDKEYS_NEGTIME), EDITTYPE_TIME);
	iNegTime->SetValue(negTime,FALSE);

	iPosVal = GetISpinner(GetDlgItem(hWnd,IDC_RANDKEYS_POSVALSPIN));
	iPosVal->SetLimits(0.0f, 999999999.9f, FALSE);
	iPosVal->SetScale(0.1f);
	iPosVal->LinkToEdit(GetDlgItem(hWnd,IDC_RANDKEYS_POSVAL), EDITTYPE_FLOAT);
	iPosVal->SetValue(posVal,FALSE);

	iNegVal = GetISpinner(GetDlgItem(hWnd,IDC_RANDKEYS_NEGVALSPIN));
	iNegVal->SetLimits(0.0f, 999999999.0f, FALSE);
	iNegVal->SetScale(0.1f);
	iNegVal->LinkToEdit(GetDlgItem(hWnd,IDC_RANDKEYS_NEGVAL), EDITTYPE_FLOAT);
	iNegVal->SetValue(negVal,FALSE);

	SetStates();
	}

void RandKeysUtil::Destroy()
	{
	ReleaseISpinner(iPosTime);
	ReleaseISpinner(iNegTime);
	ReleaseISpinner(iPosVal);
	ReleaseISpinner(iNegVal);
	iu->TVUtilClosing(this);
	}

void RandKeysUtil::BeginEditParams(Interface *ip,ITVUtility *iu)
	{
	this->ip = ip;
	this->iu = iu;	
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_RAND_KEYS),
		iu->GetTrackViewHWnd(),
		RandKeysDlgProc,
		(LONG)this);
	}

void RandKeysUtil::EndEditParams(Interface *ip,ITVUtility *iu)
	{
	this->ip = NULL;
	this->iu = NULL;
	}

static IKey *GetKeyPointer(SClass_ID sid, Class_ID cid)
	{
	static ITCBFloatKey  tcbfkey;
	static ITCBPoint3Key tcbpt3key;
	static ITCBRotKey    tcbrkey;
	static ITCBScaleKey  tcbskey;
	static IBezFloatKey  bezfkey;
	static IBezPoint3Key bezpt3key;
	static IBezQuatKey   bezrkey;
	static IBezScaleKey  bezskey;
	static ILinFloatKey  linfkey;
	static ILinPoint3Key linpt3key;
	static ILinRotKey    linrkey;
	static ILinScaleKey  linskey;

	switch (sid) {
		case CTRL_FLOAT_CLASS_ID:
			if (cid==Class_ID(HYBRIDINTERP_FLOAT_CLASS_ID,0)) return &bezfkey;
			if (cid==Class_ID(LININTERP_FLOAT_CLASS_ID,0)) return &linfkey;
			if (cid==Class_ID(TCBINTERP_FLOAT_CLASS_ID,0)) return &tcbfkey;
			break;

		case CTRL_POINT3_CLASS_ID:
			if (cid==Class_ID(HYBRIDINTERP_POINT3_CLASS_ID,0)) return &bezpt3key;
			if (cid==Class_ID(HYBRIDINTERP_COLOR_CLASS_ID,0)) return &bezpt3key;
			if (cid==Class_ID(TCBINTERP_POINT3_CLASS_ID,0)) return &tcbpt3key;
			break;

		case CTRL_POSITION_CLASS_ID:
			if (cid==Class_ID(LININTERP_POSITION_CLASS_ID,0)) return &linpt3key;
			if (cid==Class_ID(HYBRIDINTERP_POSITION_CLASS_ID,0)) return &bezpt3key;
			if (cid==Class_ID(TCBINTERP_POSITION_CLASS_ID,0)) return &tcbpt3key;
			break;

		case CTRL_ROTATION_CLASS_ID:
			if (cid==Class_ID(HYBRIDINTERP_ROTATION_CLASS_ID,0)) return &bezrkey;
			if (cid==Class_ID(LININTERP_ROTATION_CLASS_ID,0)) return &linrkey;
			if (cid==Class_ID(TCBINTERP_ROTATION_CLASS_ID,0)) return &tcbrkey;
			break;

		case CTRL_SCALE_CLASS_ID:
			if (cid==Class_ID(LININTERP_SCALE_CLASS_ID,0)) return &linskey;
			if (cid==Class_ID(HYBRIDINTERP_SCALE_CLASS_ID,0)) return &bezskey;
			if (cid==Class_ID(TCBINTERP_SCALE_CLASS_ID,0)) return &tcbskey;
			break;
		}
	return NULL;
	}

static float CompRand(float min, float max)
	{
	float u = float(rand())/float(RAND_MAX);
	return (1.0f-u)*min + u*max;
	}


void RandKeysUtil::Apply()
	{
	BOOL timeMode   = iu->GetMajorMode()==TVMODE_EDITTIME;
	BOOL fcurveMode = iu->GetMajorMode()==TVMODE_EDITFCURVE;
	Interval iv = iu->GetTimeSelection();
	if (!doTime && !doVal) return;

	theHold.Begin();

	// Turn animation on
	SuspendAnimate();
	AnimateOn();

	for (int i=0; i<iu->GetNumTracks(); i++) {
		if ((timeMode||fcurveMode) && !iu->IsSelected(i)) continue;
		
		// Get Interfaces
		Animatable *anim   = iu->GetAnim(i);
		Animatable *client = iu->GetClient(i);
		int subNum         = iu->GetSubNum(i);
		Control *cont      = GetControlInterface(anim);
		IKeyControl *ikc   = GetKeyControlInterface(anim);
		IKey *key          = GetKeyPointer(anim->SuperClassID(),anim->ClassID());				
		if (!ikc || !cont || !key) continue;						
		if (fcurveMode && !anim->IsCurveSelected()) continue;

		// Get the param dim
		float min = negVal, max = posVal;
		ParamDimension *dim = client->GetParamDimension(subNum);
		if (dim) {
			min = dim->UnConvert(min);
			max = dim->UnConvert(max);
			}

		for (int j=0; j<ikc->GetNumKeys(); j++) {
			// Get the key data
			ikc->GetKey(j,key);
			
			// Check if it's selected
			if (timeMode && !iv.InInterval(key->time)) continue;
			if (!timeMode && !(key->flags&IKEY_SELECTED)) continue;			

			// Randomize time
			if (doTime) {
				key->time = (int)CompRand(
					float(key->time-negTime),
					float(key->time+posTime));
				ikc->SetKey(j,key);
				}

			// Randomize value
			if (doVal) {
				Point3 pt, ang;
				float f;
				Quat q;
				ScaleValue s;				
				BOOL doX, doY, doZ;
				doX = doY = doZ = TRUE;
				if (!fcurveMode) {
					if (!(key->flags&IKEY_XSEL)) doX = FALSE;
					if (!(key->flags&IKEY_YSEL)) doY = FALSE;
					if (!(key->flags&IKEY_ZSEL)) doZ = FALSE;
					}

				switch (anim->SuperClassID()) {
					case CTRL_FLOAT_CLASS_ID:			
						cont->GetValue(key->time,&f,FOREVER);
						f = CompRand(f-min,f+max);
						cont->SetValue(key->time,&f);
						break;

					case CTRL_POSITION_CLASS_ID:
					case CTRL_POINT3_CLASS_ID:
						cont->GetValue(key->time,&pt,FOREVER);
						if (doX) pt.x = CompRand(pt.x-min,pt.x+max);
						if (doY) pt.y = CompRand(pt.y-min,pt.y+max);
						if (doZ) pt.z = CompRand(pt.z-min,pt.z+max);
						cont->SetValue(key->time,&pt);
						break;
					
					case CTRL_ROTATION_CLASS_ID:
						cont->GetValue(key->time,&q,FOREVER);
						QuatToEuler(q, ang);
						ang.x = CompRand(ang.x-min,ang.x+max);
						ang.y = CompRand(ang.y-min,ang.y+max);
						ang.z = CompRand(ang.z-min,ang.z+max);
						EulerToQuat(ang,q);
						cont->SetValue(key->time,&q);
						break;

					case CTRL_SCALE_CLASS_ID:
						cont->GetValue(key->time,&s,FOREVER);
						if (doX) s.s.x = CompRand(s.s.x-min,s.s.x+max);
						if (doY) s.s.y = CompRand(s.s.y-min,s.s.y+max);
						if (doZ) s.s.z = CompRand(s.s.z-min,s.s.z+max);
						cont->SetValue(key->time,&s);
						break;
					}
				}
			}

		if (doTime) ikc->SortKeys();
		}

	ResumeAnimate();

	theHold.Accept(GetString(IDS_RB_RANDOMIZEKEYS));
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by util.rc
//
#define IDC_RESCALE_SCENE               2
#define IDD_COLORCLIP_PANEL             101
#define IDD_COLORCLIP_FLOATER           102
#define IDD_ASCIIOUT_PANEL              103
#define IDD_UTILTEST_PANEL              104
#define IDD_APPDATA_PANEL               105
#define IDD_COLLAPSE_PANEL              106
#define IDD_RAND_KEYS                   107
#define IDD_ORT_KEYS                    108
#define IDD_SEL_KEYS                    109
#define IDD_FOLLOW_PANEL                110
#define IDD_REFERENCE_PANEL             111
#define IDD_PIPEMAKER_PANEL             112
#define IDR_PIPEMAKER_MENU              113
#define IDD_ABOUT_PIPEMAKER             114
#define IDR_MENU_POPUP                  115
#define IDD_PRSLINKINFO                 165
#define IDC_COLORCLIP_NEWFLOAT          1000
#define IDC_ASCIIOUT_PICK               1002
#define IDC_TESTER_MAKEOBJECT           1003
#define IDC_TESTER_MAKEGROUP            1004
#define IDC_APPDATA_EDIT                1004
#define IDC_TESTER_GROUPOBJS            1005
#define IDC_APPDATA_GET                 1005
#define IDC_TESTER_OPENGROUP            1006
#define IDC_APPDATA_PUT                 1006
#define IDC_TESTER_CLOSEGROUP           1007
#define IDC_TESTER_EXPLODEGROUP         1008
#define IDC_TESTER_UNGROUP              1009
#define IDC_TESTER_SAVETOFILE           1010
#define IDC_TESTER_LOADFROMFILE         1011
#define IDC_TESTER_SETENV               1012
#define IDC_TESTER_SETWAV               1013
#define IDS_TESTER_ANIMON               1014
#define IDS_TESTER_ANIMOFF              1015
#define IDC_C_COLLAPSE                  1015
#define IDC_INHERIT_XTRANS              1015
#define IDS_TESTER_RENDER               1016
#define IDC_C_BOOL                      1016
#define IDC_INHERIT_YTRANS              1016
#define IDC_INHERIT_ZTRANS              1017
#define IDC_C_MULTIPLE                  1018
#define IDC_INHERIT_XROT                1018
#define IDC_C_SINGLE                    1019
#define IDC_INHERIT_YROT                1019
#define IDC_C_STACKRESULT               1020
#define IDC_INHERIT_ZROT                1020
#define IDC_C_MESH                      1021
#define IDC_INHERIT_XSCALE              1021
#define IDC_INHERIT_YSCALE              1022
#define IDC_INHERIT_ZSCALE              1023
#define IDC_C_COLLPASETOLABEL           1025
#define IDC_C_UNION                     1026
#define IDC_C_INTERSECTION              1027
#define IDC_C_SUBTRACTION               1028
#define IDC_SEL_NAME                    1029
#define IDC_RANDKEYS_POSTIMELABEL       1030
#define IDC_RANDKEYS_POSTIME            1031
#define IDC_RANDKEYS_POSTIMESPIN        1032
#define IDC_RANDKEYS_TIME               1033
#define IDC_RANDKEYS_NEGTIME            1034
#define IDC_RANDKEYS_NEGTIMESPIN        1035
#define IDC_RANDKEYS_NEGTIMELABEL       1036
#define IDC_RANDKEYS_POSVAL             1037
#define IDC_RANDKEYS_POSVALSPIN         1038
#define IDC_COLOR_SWATCH1               1039
#define IDC_RANDKEYS_POSVALLABEL        1039
#define IDC_COLOR_SWATCH2               1040
#define IDC_RANDKEYS_VAL                1040
#define IDC_COLOR_SWATCH3               1041
#define IDC_RANDKEYS_NEGVAL             1041
#define IDC_COLOR_SWATCH4               1042
#define IDC_RANDKEYS_NEGVALSPIN         1042
#define IDC_COLOR_SWATCH5               1043
#define IDC_RANDKEYS_NEGVALLABEL        1043
#define IDC_COLOR_SWATCH6               1044
#define IDC_RANDKEYS_TEXT               1044
#define IDC_COLOR_SWATCH7               1045
#define IDC_RANDKEYS_APPLY              1045
#define IDC_COLOR_SWATCH8               1046
#define IDC_ORTKEYS_BEFORE              1046
#define IDC_COLOR_SWATCH9               1047
#define IDC_ORTKEYS_BEFORESPIN          1047
#define IDC_COLOR_SWATCH10              1048
#define IDC_ORTKEYS_AFTER               1048
#define IDC_COLOR_SWATCH11              1049
#define IDC_ORTKEYS_AFTERSPIN           1049
#define IDC_COLOR_SWATCH12              1050
#define IDC_ORTKEYS_SAMPLES             1050
#define IDC_ORTKEYS_SAMPLESSPIN         1051
#define IDC_ORTKEYS_APPLY               1052
#define IDC_SELKEYS_START               1053
#define IDC_SELKEYS_STARTSPIN           1054
#define IDC_SELKEYS_END                 1055
#define IDC_SELKEYS_ENDSPIN             1056
#define IDC_SELKEYS_CLEAR               1057
#define IDC_FOLLOW_APPLY                1058
#define IDC_REF_OBJECT                  1059
#define IDC_COLOR_LOAD                  1060
#define IDC_COLOR_SAVE                  1061
#define IDC_CELLTEX_CIRCULAR            1061
#define IDC_COLOR_SAVEAS                1062
#define IDD_CELLTEX_PARAMS              1062
#define IDC_CELLTEX_IRREGULAR           1062
#define IDC_CELLTEX_FRACTAL             1063
#define IDD_RESCALE_PANEL               1063
#define IDC_CELLTEX_CELLCOLOR_MAP       1064
#define IDD_RESCALE_DLG                 1064
#define IDC_CELLTEX_CELLCOLOR_USEMAP    1065
#define IDD_SHAPE_CHECK_PANEL           1065
#define IDC_CELLTEX_DIVCOL1_MAP         1066
#define IDC_CELLTEX_DIVCOL1_USEMAP      1067
#define IDC_CELLTEX_DIVCOL2_MAP         1068
#define IDC_CELLTEX_DIVCOL2_USEMAP      1069
#define IDC_CELLTEX_ADAPTIVE            1070
#define IDC_PIPE_NUMTOOLS               1074
#define IDC_PIPE_UP                     1076
#define IDC_PIPE_DOWN                   1077
#define IDC_PIPE_LEFT                   1078
#define IDC_PIPE_RIGHT                  1079
#define IDC_PIPE_FORWARD                1080
#define IDC_PIPE_BACK                   1081
#define IDC_PIPE_JOIN                   1082
#define IDC_PIPE_PROG                   1083
#define IDC_PIPE_AUTOZOOM               1084
#define IDC_RESCALE                     1085
#define IDC_RESC_SCENE                  1086
#define IDC_RESC_SEL                    1087
#define IDC_RESCALE_EDIT                1088
#define IDC_RESCALE_SPIN                1089
#define IDC_CELLTEX_ITERLABEL           1090
#define IDC_CELLTEX_ROUGHLABEL          1091
#define IDC_OBJECT_SPACE                1092
#define IDC_SHAPES_AS_BEZIERS           1093
#define IDC_SHAPECHECK_PICK             1093
#define IDC_CHECK_MESSAGE               1094
#define IDC_APPDATA_SLOTSPIN            1202
#define IDC_APPDATA_SLOT                1203
#define IDC_APPDATA_SLOTLABEL           1204
#define IDC_CELLTEX_CELLCOLOR           1256
#define IDC_CELLTEX_DIVCOL1             1257
#define IDC_CELLTEX_SIZE                1258
#define IDC_CELLTEX_SIZESPIN            1259
#define IDC_CELLTEX_SPREAD              1260
#define IDC_CELLTEX_SPREADSPIN          1261
#define IDC_CELLTEX_HIGH                1262
#define IDC_CELLTEX_HIGHSPIN            1263
#define IDC_CELLTEX_VAR                 1264
#define IDC_CELLTEX_VARSPIN             1265
#define IDC_CELLTEX_DIVCOL2             1266
#define IDC_CELLTEX_LOW                 1267
#define IDC_CELLTEX_LOWSPIN             1268
#define IDC_CELLTEX_MID                 1269
#define IDC_CELLTEX_MIDSPIN             1270
#define IDC_CELLTEX_ITER                1271
#define IDC_CELLTEX_ITERSPIN            1272
#define IDC_CELLTEX_BUMPSMOOTH          1273
#define IDC_CELLTEX_BUMPSMOOTHSPIN      1274
#define IDC_CELLTEX_ROUGH               1275
#define IDC_CELLTEX_ROUGHSPIN           1276
#define ID_TEST_ITEMONE                 20001
#define ID_TEST_ITEMTWO                 20002
#define ID_TEST_ITEMTHREE               20003
#define ID_FILE_RESET                   20004
#define ID_FILE_OPEN                    20005
#define ID_FILE_SAVE                    20006
#define ID_FILE_SAVEAS                  20007
#define ID_FILE_EXIT                    20008
#define ID_HELP_ABOUTPIPEMAKER          20009
#define ID_PIPEMAKER_PROPERTIES         20010
#define IDS_RB_ASCIIOBJECTOUT           30619
#define IDS_RB_ASCIIFILES               30620
#define IDS_RB_SAVEOBJECT               30621
#define IDS_RB_COLORCLIPBOARD           30622
#define IDS_RB_COLORNUM                 30623
#define IDS_RB_APPDATATEST              30624
#define IDS_RB_FILEEXISTS               30625
#define IDS_RB_COLLAPSE                 30626
#define IDS_RB_BOOLEAN                  30627
#define IDS_RB_MULTISEL                 30628
#define IDS_RB_NONESEL                  30629
#define IDS_RB_RANDKEYS                 30630
#define IDS_RANDKEYS_KEYTEXT            30631
#define IDS_RANDKEYS_TIMETEXT           30632
#define IDS_RB_RANDOMIZEKEYS            30633
#define IDS_RB_ORTKEYS                  30634
#define IDS_RB_CREATEORTKEYS            30635
#define IDS_RB_SELKEYS                  30636
#define IDS_RB_REFOBJ                   30637
#define IDS_RB_COLORCLIPFILES           30638
#define IDS_RB_LOADCOLOR                30639
#define IDS_RB_SAVECOLOR                30640
#define IDS_RB_CANTOPENFILE             30641
#define IDS_RB_COLORCLIPSHORT           30642
#define IDS_RB_LINKINFO                 30643
#define IDS_DS_RESCALE                  30644
#define IDS_RB_CELLULAR                 30645
#define IDS_RB_NONE                     30646
#define IDS_RB_CELLCOLOR                30647
#define IDS_RB_DIVCOLOR1                30648
#define IDS_RB_DIVCOLOR2                30649
#define IDS_RB_PARAMETERS               30650
#define IDS_RB_COORDINATES              30651
#define IDS_RB_OUTPUT                   30652
#define IDS_RB_VARIATION                30653
#define IDS_RB_SIZE                     30654
#define IDS_RB_SPREAD                   30655
#define IDS_RB_LOW                      30656
#define IDS_RB_MID                      30657
#define IDS_RB_HIGH                     30658
#define IDS_RB_TYPE                     30659
#define IDS_RB_FRACTAL                  30660
#define IDS_RB_ITERATIONS               30661
#define IDS_RB_ROUGHNESS                30662
#define IDS_RB_BUMPSMOOTHING            30663
#define IDS_RB_PARAMETER                30664
#define IDS_RB_DEFUTIL                  30665
#define IDS_RB_CELLPARAMS               30666
#define IDS_RB_SHAPE_CHECK              30667
#define IDS_NO_SHAPE_SELECTED           30668
#define IDS_SHAPE_OK                    30669
#define IDS_SHAPE_INTERSECTS            30670
#define IDS_RB_CELLMAP                  30671
#define IDS_RB_DIVMAP1                  30672
#define IDS_RB_DIVMAP2                  30673
#define IDS_PW_MAP1_ON                  30674
#define IDS_PW_MAP2_ON                  30675
#define IDS_PW_MAP3_ON                  30676
#define IDS_PW_ADAPTIVE                 30677
#define IDS_PW_OUTPUT                   30678
#define IDS_PW_COORDS                   30679
#define IDS_RB_CELLULAR_CDESC           30680
#define IDC_STATIC                      -1
#define IDC_PIPE_RANDOMIZE              65535

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         20011
#define _APS_NEXT_CONTROL_VALUE         1095
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\selkeys.cpp ===
/**********************************************************************																  /**********************************************************************
 *<
	FILE: selkeys.cpp

	DESCRIPTION: A Track View Utility that selects keys in the current time selection

	CREATED BY: Rolf Berteig

	HISTORY: created 12/18/96

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "tvutil.h"
#include "istdplug.h"

#define SEL_KEYS_NAME		GetString(IDS_RB_SELKEYS)
#define SEL_KEYS_CLASS_ID	Class_ID(0x18be63a6,0xcf32a8d3)

class SelKeysUtil : public TrackViewUtility {
	public:				
		Interface *ip;
		ITVUtility *iu;
		int clear;
		SelKeysUtil() {ip=NULL;iu=NULL;clear=TRUE;}
		void DeleteThis() {} 
		void BeginEditParams(Interface *ip,ITVUtility *iu);		

		void SetupWindow(HWND hWnd);
		void SelectKeys(HWND hWnd);
	};
SelKeysUtil theSelKeysUtil;

class SelKeysClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theSelKeysUtil;}
	const TCHAR *	ClassName() {return SEL_KEYS_NAME;}
	SClass_ID		SuperClassID() {return TRACKVIEW_UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return SEL_KEYS_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static SelKeysClassDesc selKeysDesc;
ClassDesc* GetSelKeysDesc() {return &selKeysDesc;}


void SelKeysUtil::SetupWindow(HWND hWnd)
	{
	Interval iv = iu->GetTimeSelection();
	ISpinnerControl *spin;
	spin = GetISpinner(GetDlgItem(hWnd,IDC_SELKEYS_STARTSPIN));
	spin->SetLimits(TIME_NegInfinity, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_SELKEYS_START), EDITTYPE_TIME);
	spin->SetValue(iv.Start(),FALSE);
	ReleaseISpinner(spin);

	spin = GetISpinner(GetDlgItem(hWnd,IDC_SELKEYS_ENDSPIN));
	spin->SetLimits(TIME_NegInfinity, TIME_PosInfinity, FALSE);
	spin->SetScale(10.0f);
	spin->LinkToEdit(GetDlgItem(hWnd,IDC_SELKEYS_END), EDITTYPE_TIME);
	spin->SetValue(iv.End(),FALSE);
	ReleaseISpinner(spin);

	CheckDlgButton(hWnd,IDC_SELKEYS_CLEAR,clear);
	}

class ClearWorkFlagEnumProc : public AnimEnum {		
	public:
		ClearWorkFlagEnumProc() : AnimEnum(SCOPE_ALL) {}
		int proc(Animatable *anim, Animatable *client, int subNum) {
			anim->ClearAFlag(A_WORK1);
			return ANIM_ENUM_PROCEED;
			}
	};

class SelKeysEnumProc : public AnimEnum {
	public:
		TimeValue start, end;
		BOOL clear;
		SelKeysEnumProc(TimeValue s, TimeValue e, BOOL c) : AnimEnum(SCOPE_ALL)
			{start=s; end=e; clear=c;}
		int proc(Animatable *anim, Animatable *client, int subNum) {
			if (anim->TestAFlag(A_WORK1)) return ANIM_ENUM_PROCEED;
			anim->SetAFlag(A_WORK1);
			if (clear) {
				TrackHitTab none;
				anim->SelectKeys(none, SELKEYS_CLEARKEYS);
			} else {			
				for (int j=0; j<anim->NumKeys(); j++) {				
					TimeValue t = anim->GetKeyTime(j);
					if (t>=start && t<=end) {
						anim->SelectKeyByIndex(j,TRUE);
						}
					}
				}
			return ANIM_ENUM_PROCEED;
			}
	};

void SelKeysUtil::SelectKeys(HWND hWnd)
	{
	clear = IsDlgButtonChecked(hWnd,IDC_SELKEYS_CLEAR);
	ISpinnerControl *spin;
	spin = GetISpinner(GetDlgItem(hWnd,IDC_SELKEYS_STARTSPIN));
	TimeValue start = spin->GetIVal();
	ReleaseISpinner(spin);
	spin = GetISpinner(GetDlgItem(hWnd,IDC_SELKEYS_ENDSPIN));
	TimeValue end = spin->GetIVal();
	ReleaseISpinner(spin);
	if (start>end) {
		TimeValue temp = end;
		end   = start;
		start = temp;
		}
	theHold.Begin();
	
	if (iu->SubTreeMode()) {
		ClearWorkFlagEnumProc proc;
		iu->GetTVRoot()->EnumAnimTree(&proc,NULL,0);
		}

	if (clear) {
		for (int i=0; i<iu->GetNumTracks(); i++) {			
			Animatable *anim = iu->GetAnim(i);
			if (iu->SubTreeMode()) {
				SelKeysEnumProc proc(start,end,TRUE);
				anim->EnumAnimTree(&proc,NULL,0);
			} else {
				if (clear) {
					TrackHitTab none;
					anim->SelectKeys(none, SELKEYS_CLEARKEYS);
					}				
				}				
			}

		if (iu->SubTreeMode()) {
			ClearWorkFlagEnumProc proc;
			iu->GetTVRoot()->EnumAnimTree(&proc,NULL,0);
			}
		}

	for (int i=0; i<iu->GetNumTracks(); i++) {
		if (iu->IsSelected(i)) {
			Animatable *anim = iu->GetAnim(i);
			if (iu->SubTreeMode()) {
				SelKeysEnumProc proc(start,end,FALSE);
				anim->EnumAnimTree(&proc,NULL,0);
			} else {							
				for (int j=0; j<anim->NumKeys(); j++) {				
					TimeValue t = anim->GetKeyTime(j);
					if (t>=start && t<=end) {
						anim->SelectKeyByIndex(j,TRUE);
						}					
					}
				}
			}
		}
	theHold.Accept(SEL_KEYS_NAME);
	}

static BOOL CALLBACK SelKeysDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			CenterWindow(hWnd,GetParent(hWnd));
			theSelKeysUtil.SetupWindow(hWnd);
			break;

		case WM_COMMAND:			
			switch (LOWORD(wParam)) {				
				case IDOK:
					theSelKeysUtil.SelectKeys(hWnd);
					EndDialog(hWnd,1);
					break;

				case IDCANCEL:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

void SelKeysUtil::BeginEditParams(Interface *ip,ITVUtility *iu)
	{
	this->ip = ip;
	this->iu = iu;
	DialogBox(
		hInstance,
		MAKEINTRESOURCE(IDD_SEL_KEYS),
		iu->GetTrackViewHWnd(),
		SelKeysDlgProc);
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\util.cpp ===
/**********************************************************************
 *<
	FILE: util.cpp

	DESCRIPTION:   Sample utilities

	CREATED BY: Rolf Berteig

	HISTORY: created 23 December 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "util.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);
		
		// initialize Chicago controls
		InitCommonControls();
		}
			
	return (TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_RB_DEFUTIL); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() {
#ifdef _DEBUG
	return 13;
#else
	return 10;
#endif
	}


__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetColorClipDesc();
		case 1: return GetAsciiOutDesc();
		case 2: return GetCollapseUtilDesc();
		case 3: return GetRandKeysDesc();
		case 4: return GetORTKeysDesc();
		case 5: return GetSelKeysDesc();
		case 6: return GetLinkInfoUtilDesc();
		case 7: return GetCellTexDesc();
		/*case 8: return GetPipeMakerDesc();*/ //RK: 07/02/99 Removing this from Shiva
		case 8: return GetRescaleDesc();
		case 9: return GetShapeCheckDesc();
#ifdef _DEBUG
		case 10: return GetUtilTestDesc();
		case 11: return GetAppDataTestDesc();
		case 12: return GetTestSoundObjDescriptor();
#endif
		default: return 0;
		}
			
	}

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
	{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\shapechk.cpp ===
/**********************************************************************
 *<
	FILE: shapechk.cpp

	DESCRIPTION:  A utility that checks Shape objects for validity

	CREATED BY: Tom Hudson

	HISTORY: created July 29, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"
#include "polyshp.h"
#include "shape.h"

#define SHAPE_CHECK_CLASS_ID		0x7cc401b4

class ShapeCheck;

class SCDisplayCallback : public ViewportDisplayCallback {
	public:
		ShapeCheck *sc;
		void SetSC(ShapeCheck *s) { sc = s; }
		void Display(TimeValue t, ViewExp *vpt, int flags);
		void GetViewportRect( TimeValue t, ViewExp *vpt, Rect *rect );
		BOOL Foreground() { return FALSE; } // return TRUE if the object changes a lot or FALSE if it doesn't change much		
	};

class CSIntersection : public IntersectionCallback3D {
	public:
		Point3Tab table;
		void Reset() { table.Delete(0, table.Count()); table.Shrink(); }
		BOOL Intersect(Point3 p, int piece); // Return FALSE to stop intersect tests
		void Display(GraphicsWindow *gw);
		void GetBBox(Box3 &box);
	};

BOOL CSIntersection::Intersect(Point3 p, int piece) {
	table.Append(1, &p);
	return TRUE;
	}

void CSIntersection::Display(GraphicsWindow *gw) {
	gw->setColor(LINE_COLOR, 1.0f, 0.0f, 0.0f);
	for(int i = 0; i < table.Count(); ++i)
		gw->marker(&table[i], BIG_BOX_MRKR);
	}

void CSIntersection::GetBBox(Box3 &box) {
	box.Init();
	for(int i = 0; i < table.Count(); ++i)
		box += table[i];
	}

class ShapeCheck : public UtilityObj, public TimeChangeCallback {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		ICustButton *iPick;
		SCDisplayCallback dcb;
		INode *theNode;
		CSIntersection csi;
		Interval objValid;

		ShapeCheck();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void SetNode(INode *node);
		BOOL CheckShape(TimeValue t);	// Returns TRUE if self-intersects
		// Time change callmack method
		void TimeChanged(TimeValue t);
	};

static ShapeCheck theShapeCheck;

class ShapeCheckClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theShapeCheck;}
	const TCHAR *	ClassName() {return GetString(IDS_RB_SHAPE_CHECK);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(SHAPE_CHECK_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static ShapeCheckClassDesc shapeCheckDesc;
ClassDesc* GetShapeCheckDesc() {return &shapeCheckDesc;}

void SCDisplayCallback::Display(TimeValue t, ViewExp *vpt, int flags) {
	if(!sc->theNode)
		return;
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(sc->theNode->GetObjectTM(t));	
	sc->csi.Display(gw);
	}

void SCDisplayCallback::GetViewportRect( TimeValue t, ViewExp *vpt, Rect *rect ) {
	if(!sc->theNode)
		return;
	Box3 box;
	Matrix3 identTM(1);
	sc->csi.GetBBox(box);
	// Put box in world space
	Matrix3 mat = sc->theNode->GetObjectTM(t);
	box = box * mat;
	// Get a screen bound box
	GraphicsWindow *gw = vpt->getGW();
	gw->setTransform(identTM);		
	DWORD cf;
	DWORD orCf = 0;
	DWORD andCf = 0xffff;
	IPoint3 pt;
	rect->SetEmpty();
	for ( int i = 0; i < 8; i++ ) {
		cf = gw->wTransPoint( &box[i], &pt );
		orCf |= cf;
		andCf &= cf;
		*rect += IPoint2(pt.x,pt.y);
		}
	// If out of view frustrum, bail out
	if(andCf) {
		rect->SetEmpty();
		return;
		}
	// Grow the box to allow for markers
	rect->left   -= 8; 
	rect->top    -= 8; 
	rect->right  += 8; 
	rect->bottom += 8; 
	}

class ShapeCheckPickNodeCallback : public PickNodeCallback {
	public:		
		BOOL Filter(INode *node);
	};

BOOL ShapeCheckPickNodeCallback::Filter(INode *node)
	{
	ObjectState os = node->EvalWorldState(theShapeCheck.ip->GetTime());
	if (os.obj->SuperClassID()==SHAPE_CLASS_ID) return TRUE;
	else return FALSE;
	}

static ShapeCheckPickNodeCallback thePickFilt;

class ShapeCheckPickModeCallback : public PickModeCallback {
	public:		
		BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
		BOOL Pick(IObjParam *ip,ViewExp *vpt);
		
		void EnterMode(IObjParam *ip) {theShapeCheck.iPick->SetCheck(TRUE);}
		void ExitMode(IObjParam *ip) {theShapeCheck.iPick->SetCheck(FALSE);}

		PickNodeCallback *GetFilter() {return &thePickFilt;}
		BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
	};

static ShapeCheckPickModeCallback thePickMode;

BOOL ShapeCheckPickModeCallback::HitTest(
		IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
	{
	return ip->PickNode(hWnd,m,&thePickFilt)?TRUE:FALSE;
	}

BOOL ShapeCheckPickModeCallback::Pick(IObjParam *ip,ViewExp *vpt)
	{
	INode *node = vpt->GetClosestHit();
	if (node) {
		theShapeCheck.SetNode(node);
		theShapeCheck.CheckShape(ip->GetTime());
		ip->ForceCompleteRedraw(FALSE);
		}
	return TRUE;
	}


static BOOL CALLBACK ShapeCheckDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theShapeCheck.Init(hWnd);			
			SetDlgItemText(hWnd, IDC_CHECK_MESSAGE, GetString(IDS_NO_SHAPE_SELECTED));
			break;
		
		case WM_DESTROY:
			theShapeCheck.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theShapeCheck.csi.Reset();
					theShapeCheck.theNode = NULL;
					theShapeCheck.ip->ForceCompleteRedraw(FALSE);
					theShapeCheck.iu->CloseUtility();
					break;				
		
				case IDC_SHAPECHECK_PICK:
					theShapeCheck.ip->SetPickMode(&thePickMode); 
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE; 
	}

ShapeCheck::ShapeCheck()
	{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;	
	iPick = NULL;
	theNode = NULL;
	objValid.SetEmpty();
	dcb.SetSC(this);
	}

void ShapeCheck::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SHAPE_CHECK_PANEL),
		ShapeCheckDlgProc,
		GetString(IDS_RB_SHAPE_CHECK),
		0);
	ip->RegisterViewportDisplayCallback(FALSE, &dcb);
	ip->RegisterTimeChangeCallback(this);
	}
	
void ShapeCheck::EndEditParams(Interface *ip,IUtil *iu) 
	{
	if(theNode) {
		SetNode(NULL);
		ip->ForceCompleteRedraw(FALSE);
		}
	ip->UnRegisterTimeChangeCallback(this);
	ip->UnRegisterViewportDisplayCallback(FALSE, &dcb);
	ip->ClearPickMode();
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void ShapeCheck::Init(HWND hWnd)
	{
	iPick = GetICustButton(GetDlgItem(hWnd,IDC_SHAPECHECK_PICK));
	iPick->SetType(CBT_CHECK);
	iPick->SetHighlightColor(GREEN_WASH);
	}

void ShapeCheck::Destroy(HWND hWnd)
	{
	ReleaseICustButton(iPick);
	iPick = NULL;
	}

void ShapeCheck::SetNode(INode *node) {
	theNode = node;
	csi.Reset();
	objValid.SetEmpty();
	}

class NullView: public View {
	public:
		Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
		NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
	};

BOOL ShapeCheck::CheckShape(TimeValue t)
	{
	BOOL intersects = FALSE;
	if(!theNode)
		return FALSE;
	if(objValid.InInterval(t))
		return FALSE;
	ObjectState os = theNode->EvalWorldState(t);
	if(os.obj->SuperClassID()==SHAPE_CLASS_ID) {
		Matrix3 tm = theNode->GetObjTMAfterWSM(t);
		
		PolyShape shape;
		((ShapeObject *)os.obj)->MakePolyShape(t, shape);
		objValid = os.Validity(t);
		BOOL si = FALSE;
		// Flush the intersection counter
		csi.Reset();
		// Check each polyline for self-intersection
		for(int i = 0; i < shape.numLines; ++i) {
			if(shape.lines[i].SelfIntersects(TRUE, &csi))
				si = TRUE;
			}
		// Now check them against each other
		for(i = 0; i < shape.numLines; ++i) {
			for(int j = i+1; j < shape.numLines; ++j) {
				if(i != j)
					if(shape.lines[i].HitsPolyLine(shape.lines[j],TRUE, &csi))
						si = TRUE;
				}
			}
		TSTR buf;
		if(si) {
			buf = GetString(IDS_SHAPE_INTERSECTS);
			ip->NotifyViewportDisplayCallbackChanged(FALSE,&dcb);
			intersects = TRUE;
			}
		else
			buf = GetString(IDS_SHAPE_OK);

		SetDlgItemText(hPanel, IDC_CHECK_MESSAGE, buf);
		}
	else
		assert(0);
	return intersects;
	}

void ShapeCheck::TimeChanged(TimeValue t) {
	if(theNode) {
		CheckShape(t);
		ip->ForceCompleteRedraw(FALSE);
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\rescale.cpp ===
/**********************************************************************
 *<
	FILE: rescale.cpp

	DESCRIPTION:  A rescale utility

	CREATED BY: Dan Silva

	HISTORY: created 4/28/97

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"

#define RESCALE_CLASS_ID		Class_ID(0xb1381a58,0x738933)
#define RESCALE_CNAME			GetString(IDS_DS_RESCALE)

class RescaleUtil : public UtilityObj, public MeshOpProgress {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		HWND hDlg;
		static float factor;
		static ISpinnerControl *fspin;
		static BOOL doSel;
		RescaleUtil();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);
		BOOL DlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void ReleaseControls();

		void DoRescale();

		// From MeshOpProgress
		void Init(int total);		
		BOOL Progress(int p);
	};

ISpinnerControl *RescaleUtil::fspin = NULL;
float RescaleUtil::factor = 1.0f;
BOOL RescaleUtil::doSel = FALSE;

static RescaleUtil theRescaleUtil;

class RescaleUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theRescaleUtil;}
	const TCHAR *	ClassName() {return RESCALE_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return RESCALE_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static RescaleUtilClassDesc rescaleUtilDesc;
ClassDesc* GetRescaleDesc() {return &rescaleUtilDesc;}


static BOOL CALLBACK RescaleUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theRescaleUtil.Init(hWnd);
			break;

		case WM_DESTROY:
			theRescaleUtil.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theRescaleUtil.iu->CloseUtility();
					break;
				case IDC_RESCALE:
					theRescaleUtil.DoRescale();
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MOUSEMOVE:
			theRescaleUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	


RescaleUtil::RescaleUtil()
	{	
	factor = 1.0f;
	}

void RescaleUtil::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_RESCALE_PANEL),
		RescaleUtilDlgProc,
		GetString(IDS_DS_RESCALE),
		0);
	}
	
void RescaleUtil::EndEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void RescaleUtil::Init(HWND hWnd)
	{
	hPanel = hWnd;
//	SelectionSetChanged(ip,iu);	
	}

void RescaleUtil::Destroy(HWND hWnd)
	{		
	hPanel = NULL;
	}

void RescaleUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{
	}

void RescaleUtil::ReleaseControls() {
	if (fspin) {
		ReleaseISpinner(fspin);
		fspin = NULL;
		}
	}

static BOOL doseltmp;

BOOL RescaleUtil::DlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	int id;
	switch (msg) {
		case WM_INITDIALOG:			
			fspin = SetupFloatSpinner(hWnd, IDC_RESCALE_SPIN, IDC_RESCALE_EDIT,0.00001f,100000.0f, factor);
			CenterWindow(hWnd, GetWindow(hWnd, GW_OWNER));        	
			CheckRadioButton( hWnd, IDC_RESC_SCENE,IDC_RESC_SEL, doSel+IDC_RESC_SCENE);
			doseltmp = doSel;
			break;

		case WM_DESTROY:
			ReleaseControls();
			break;

		case WM_COMMAND:			
			switch (id=LOWORD(wParam)) {				
				case IDC_RESC_SEL:
					doseltmp = 1;
					break;
				case IDC_RESC_SCENE:
					doseltmp = 0;
					break;
				case IDOK:
					doSel = doseltmp;
					factor = fspin->GetFVal();
					EndDialog(hWnd, TRUE);
					break;
	        	case IDCANCEL:
					EndDialog(hWnd, FALSE);
					break;
				}			
			break;

		default:
			return FALSE;
		}	
	return TRUE;
	}


static BOOL CALLBACK  RescaleDlgProc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) {
	RescaleUtil *resc;
	if (msg==WM_INITDIALOG) {
		resc = (RescaleUtil*)lParam;
		resc->hDlg = hwndDlg;
		SetWindowLong(hwndDlg, GWL_USERDATA,lParam);
		}
	else {
	    if ( (resc = (RescaleUtil *)GetWindowLong(hwndDlg, GWL_USERDATA) ) == NULL )
			return FALSE; 
		}
	int	res = resc->DlgProc(hwndDlg,msg,wParam,lParam);
	return res;
	}

class RescaleRestore: public RestoreObj {
	float fact;
	BOOL doSel;
	public:
		RescaleRestore::RescaleRestore(float f, BOOL sel) { fact = f; doSel = sel; } 
		void Restore(int isUndo) {
			Interface *ip = GetCOREInterface();
			ip->RescaleWorldUnits(1.0f/fact,doSel);
			ip->RedrawViews(ip->GetTime());
			}
		void Redo() {
			Interface *ip = GetCOREInterface();
			ip->RescaleWorldUnits(fact,doSel);
			ip->RedrawViews(ip->GetTime());
			}
		TSTR Description() { return TSTR("RescaleRestore"); }
	};


void RescaleUtil::DoRescale()
	{

	if (DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_RESCALE_DLG),
		hPanel,
		RescaleDlgProc,(LPARAM)this)) {
		ip->RescaleWorldUnits(factor,doSel);
		ip->RedrawViews(ip->GetTime());
		theHold.Begin();
		theHold.Put(new RescaleRestore(factor,doSel));
		theHold.Accept(GetString(IDS_DS_RESCALE));
		}

	}

void RescaleUtil::Init(int total)
	{
	}

BOOL RescaleUtil::Progress(int p)
	{
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\refobj.cpp ===
/**********************************************************************
 *<
	FILE: refobj.cpp

	DESCRIPTION: A utility that inserts a derived object 

	CREATED BY: Rolf Berteig

	HISTORY: created 1/27/97

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"

#define REFOBJ_CLASS_ID		Class_ID(0xbb300184,0xee6d2a10)
#define REFOBJ_CNAME		GetString(IDS_RB_REFOBJ)

class RefObjUtil : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;		
		
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}
		void SelectionSetChanged(Interface *ip,IUtil *iu);

		void Init(HWND hWnd);		

		void DoRefObj();
	};
static RefObjUtil theRefObjUtil;

class RefObjUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theRefObjUtil;}
	const TCHAR *	ClassName() {return REFOBJ_CNAME;}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return REFOBJ_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	};

static RefObjUtilClassDesc refObjUtilDesc;
ClassDesc* GetRefObjUtilDesc() {return &refObjUtilDesc;}


static BOOL CALLBACK RefObjUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theRefObjUtil.Init(hWnd);
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theRefObjUtil.iu->CloseUtility();
					break;

				case IDC_REF_OBJECT:
					theRefObjUtil.DoRefObj();
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theRefObjUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}	

void RefObjUtil::BeginEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_REFERENCE_PANEL),
		RefObjUtilDlgProc,
		GetString(IDS_RB_REFOBJ),
		0);
	}
	
void RefObjUtil::EndEditParams(Interface *ip,IUtil *iu) 
	{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void RefObjUtil::Init(HWND hWnd)
	{
	hPanel = hWnd;
	SelectionSetChanged(ip,iu);	
	}

void RefObjUtil::SelectionSetChanged(Interface *ip,IUtil *iu)
	{	
	if (ip->GetSelNodeCount()==1) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,ip->GetSelNode(0)->GetName());
	} else if (ip->GetSelNodeCount()) {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_MULTISEL));
	} else {
		SetDlgItemText(hPanel,IDC_SEL_NAME,GetString(IDS_RB_NONESEL));
		}
	if (ip->GetSelNodeCount()) {
		EnableWindow(GetDlgItem(hPanel,IDC_REF_OBJECT),TRUE);
	} else {
		EnableWindow(GetDlgItem(hPanel,IDC_REF_OBJECT),FALSE);
		}
	}

void RefObjUtil::DoRefObj()
	{
	theHold.Begin();
	INodeTab flash;
	for (int i=0; i<ip->GetSelNodeCount(); i++) {
		INode *node = ip->GetSelNode(i);
		flash.Append(1,&node,10);
		node->SetObjectRef(
			MakeObjectDerivedObject(node->GetObjectRef()));
		}
	theHold.Accept(GetString(IDS_RB_REFOBJ));
	// Flash nodes
	ip->FlashNodes(&flash);	
	ip->RedrawViews(ip->GetTime());
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\util.h ===
/**********************************************************************
 *<
	FILE: util.h

	DESCRIPTION:

	CREATED BY: Rolf Berteig

	HISTORY:

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __UTIL__H
#define __UTIL__H

#include "Max.h"
#include "resource.h"

TCHAR *GetString(int id);

extern ClassDesc* GetColorClipDesc();
extern ClassDesc* GetAsciiOutDesc();
extern ClassDesc* GetUtilTestDesc();
extern ClassDesc* GetAppDataTestDesc();
extern ClassDesc* GetTestSoundObjDescriptor();
extern ClassDesc* GetCollapseUtilDesc();
extern ClassDesc* GetRandKeysDesc();
extern ClassDesc* GetORTKeysDesc();
extern ClassDesc* GetSelKeysDesc();
extern ClassDesc* GetRefObjUtilDesc();
extern ClassDesc* GetLinkInfoUtilDesc();
extern ClassDesc* GetCellTexDesc();
/*extern ClassDesc* GetPipeMakerDesc();*/	//RK: 07/02/99 Removing this from Shiva
extern ClassDesc* GetRescaleDesc();
extern ClassDesc* GetShapeCheckDesc();

extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\ApplyVC.h ===
/**********************************************************************
 *<
	FILE:		    ApplyVC.h
	DESCRIPTION:	Vertex Color Utility
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, June 02, 1997

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/

#ifndef __APPLYVC__H
#define __APPLYVC__H

#include "Max.h"
#include "resource.h"
#include "utilapi.h"
#include "istdplug.h"
#include "EvalCol.h"

#define APPLYVC_UTIL_CLASS_ID	Class_ID(0x6e989195, 0x5dfb41b7)
#define APPLYVC_MOD_CLASS_ID	Class_ID(0x104170cc, 0x66373204)

class ModInfo {
public:
	Modifier*	mod;
	INodeTab	nodes;
};

typedef Tab<ModInfo*> ModInfoTab;

class ApplyVCUtil : public UtilityObj {
	public:
		IUtil	*iu;
		Interface	*ip;
		HWND	hPanel;
		int		lastLightModel;
		int		lastMix;
		int		lastShadow;
		int		lastUseMaps;

		ApplyVCUtil();
		~ApplyVCUtil();

		void	BeginEditParams(Interface *ip,IUtil *iu);
		void	EndEditParams(Interface *ip,IUtil *iu);
		void	DeleteThis() {}

		void	Init(HWND hWnd);
		void	Destroy(HWND hWnd);

		void	ApplySelected();
		BOOL	ApplyNode(INode* node, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps);
		Modifier*	GetModifier(INode* node, Class_ID modCID);
		void	UpdateAll();
		BOOL	UpdateAllEnum(INode* node, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps);

		void	CheckForAndMakeUnique(int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps);
		void	CheckAllNodesEnum(INode* node, ModInfoTab& modTab);
		BOOL	MakeUnique(ModInfo* mh, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps);

		void	SaveOptions();
		void	LoadOptions();
};

class ApplyVCMod : public Modifier {	
	public:
		static IObjParam*	ip;
		HWND			hPanel;
		ColorTab		mixedVertexColors;
		//VertexColorTab	vertexColors;
		FaceColorTab	faceColors;
		Interval		iValid;

		ApplyVCMod(BOOL create);
		void		InitControl(ModContext &mc,TriObject *obj,int type,TimeValue t);

		// From Animatable
		void		DeleteThis();
		void		GetClassName(TSTR& s);
		Class_ID	ClassID();
		void		BeginEditParams( IObjParam  *ip, ULONG flags,Animatable *prev);
		void		EndEditParams( IObjParam *ip,ULONG flags,Animatable *next);
		TCHAR*		GetObjectName();
		CreateMouseCallBack*	GetCreateMouseCallBack();
		BOOL		CanCopyAnim();
		BOOL		DependOnTopology(ModContext &mc);

		ChannelMask	ChannelsUsed();
		ChannelMask	ChannelsChanged();
		Class_ID	InputType();
		void		ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node);
		Interval	LocalValidity(TimeValue t);

		int			NumRefs();
		RefTargetHandle	GetReference(int i);
		void		SetReference(int i, RefTargetHandle rtarg);

		int			NumSubs();
		Animatable* SubAnim(int i);
		TSTR		SubAnimName(int i);

		RefTargetHandle	Clone(RemapDir& remap = NoRemap());
		RefResult	NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID, RefMessage message);

		IOResult	Load(ILoad *iload);
		IOResult	Save(ISave *isave);

		void		ResetColTab();
//		void		SetColors(VertexColorTab& colorTab);
		void		SetColors(FaceColorTab& colorTab);
		void		SetMixedColors(ColorTab& colorTab);
};

extern ClassDesc*	GetApplyVCUtilDesc();
extern ClassDesc*	GetApplyVCModDesc();
extern HINSTANCE	hInstance;
extern TCHAR*		GetString(int id);
extern TriObject*	GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt);

#endif // __APPLYVC__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\EvalCol.h ===
/**********************************************************************
 *<
	FILE:			EvalCpolor.cpp
	DESCRIPTION:	Vertex Color Renderer
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, December 12, 1996

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/
//
// Description:
// These functions calculates the diffuse or ambient color at each vertex
// or face of an INode.
//
// Exports:
// BOOL calcMixedVertexColors(INode*, TimeValue, int, ColorTab&, EvalColProgressCallback* callb = NULL);
//      This function calculates the interpolated diffuse or ambient 
//      color at each vertex of an INode.
//      Usage: Pass in a node pointer and the TimeValue to generate
//      a list of Colors corresponding to each vertex in the mesh
//      Use the int flag to specify if you want to have diffuse or 
//      ambient colors, or if you want to use the lights in the scene.
//      Note: 
//        You are responsible for deleting the Color objects in the table.
//      Additional note:
//        Since materials are assigned by face, this function renders each
//        face connected to the specific vertex (at the point of the vertex)
//        and then mixes the colors.
//
//***************************************************************************

#define LIGHT_AMBIENT		0x00
#define LIGHT_DIFFUSE		0x01
#define LIGHT_SCENELIGHT	0x02

typedef Tab<Color*> ColorTab;

class FaceColor {
public:
	Color colors[3];
	};

typedef Tab<FaceColor*> FaceColorTab;
typedef BOOL (*EVALCOL_PROGRESS)(float);

class EvalColProgressCallback {
public:
	virtual BOOL progress(float prog) = 0;
};

BOOL calcMixedVertexColors(INode* node, TimeValue t, int lightModel, BOOL castShadows, BOOL useMaps, ColorTab& vxColTab, EvalColProgressCallback* callb = NULL);
BOOL calcFaceColors(INode* node, TimeValue t, int lightModel, BOOL castShadows, BOOL useMaps, FaceColorTab& faceColTab, EvalColProgressCallback* callb = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\ApplyVC.cpp ===
/**********************************************************************
 *<
	FILE:			ApplyVC.cpp
	DESCRIPTION:	Vertex Color Utility + Modifier
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, June 02, 1997

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/

#include "ApplyVC.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}


__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses()
{
	return 2;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetApplyVCUtilDesc();
		case 1: return GetApplyVCModDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\AVCUtil.cpp ===
/**********************************************************************
 *<
	FILE:			AVCUtil.cpp
	DESCRIPTION:	Vertex Color Utility
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, June 02, 1997

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/

#include "ApplyVC.h"
#include "modstack.h"

static ApplyVCUtil theApplyVC;

#define NO_UPDATE -1

#define CFGFILE		_T("APPLYVC.CFG")
#define CFGVERSION	3

class ApplyVCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theApplyVC;}
	const TCHAR *	ClassName() {return GetString(IDS_AVCU_CNAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return APPLYVC_UTIL_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static ApplyVCClassDesc ApplyVCUtilDesc;
ClassDesc* GetApplyVCUtilDesc() {return &ApplyVCUtilDesc;}

static BOOL CALLBACK ApplyVCDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theApplyVC.Init(hWnd);
			break;

		case WM_DESTROY:
			theApplyVC.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSEBUTTON:
					theApplyVC.iu->CloseUtility();
					break;
				case IDC_VCUTIL_APPLY:
					theApplyVC.ApplySelected();
					break;
				case IDC_VCUTIL_UPDATEALL:
					theApplyVC.UpdateAll();
					break;
				case IDC_VCUTIL_SCENELIGHTS:
					EnableWindow(GetDlgItem(hWnd, IDC_CASTSHADOWS), TRUE);
					theApplyVC.lastLightModel = LOWORD(wParam);
					break;
				case IDC_VCUTIL_DIFFUSE:
					EnableWindow(GetDlgItem(hWnd, IDC_CASTSHADOWS), FALSE);
					theApplyVC.lastLightModel = LOWORD(wParam);
					break;
				case IDC_MIX:
					theApplyVC.lastMix = IsDlgButtonChecked(hWnd, IDC_MIX);
					break;
				case IDC_CASTSHADOWS:
					theApplyVC.lastShadow = IsDlgButtonChecked(hWnd, IDC_CASTSHADOWS);
					break;
				case IDC_USEMAPS:
					theApplyVC.lastUseMaps = IsDlgButtonChecked(hWnd, IDC_USEMAPS);
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theApplyVC.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}
	return TRUE;
}	

ApplyVCUtil::ApplyVCUtil()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
	lastLightModel = IDC_VCUTIL_SCENELIGHTS;
	lastMix = BST_UNCHECKED;
	lastShadow = BST_UNCHECKED;
	lastUseMaps = BST_CHECKED;
}

ApplyVCUtil::~ApplyVCUtil()
{
}

void ApplyVCUtil::SaveOptions()
	{
	TSTR f;

	f = ip->GetDir(APP_PLUGCFG_DIR);
	f += _T("\\");
	f += CFGFILE;

	FILE* out = fopen(f, "w");
	if (out) {
		fputc(CFGVERSION, out);
		fprintf(out, "%d\n", lastLightModel);
		fprintf(out, "%d\n", lastMix);
		fprintf(out, "%d\n", lastShadow);
		fprintf(out, "%d\n", lastUseMaps);
		fclose(out);
		}
	}

void ApplyVCUtil::LoadOptions()
	{
	TSTR f;

	f = ip->GetDir(APP_PLUGCFG_DIR);
	f += _T("\\");
	f += CFGFILE;

	FILE* in = fopen(f, "r");
	if (in) {
		int version;
		version = fgetc(in);	// Version
		fscanf(in, "%d\n", &lastLightModel);
		fscanf(in, "%d\n", &lastMix);
		fscanf(in, "%d\n", &lastShadow);
		fscanf(in, "%d\n", &lastUseMaps);
		fclose(in);
		}
	}

void ApplyVCUtil::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_VCUTIL_PANEL),
		ApplyVCDlgProc,
		GetString(IDS_AVCU_PANELTITLE),
		0);
	LoadOptions();
	CheckRadioButton(hPanel, IDC_VCUTIL_DIFFUSE, IDC_VCUTIL_SCENELIGHTS, lastLightModel);
	CheckDlgButton(hPanel, IDC_MIX, lastMix);
	CheckDlgButton(hPanel, IDC_CASTSHADOWS, lastShadow);
	CheckDlgButton(hPanel, IDC_USEMAPS, lastUseMaps);

	EnableWindow(GetDlgItem(hPanel, IDC_CASTSHADOWS), lastLightModel == IDC_VCUTIL_SCENELIGHTS);
}
	
void ApplyVCUtil::EndEditParams(Interface *ip,IUtil *iu) 
{
	SaveOptions();

	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void ApplyVCUtil::Init(HWND hWnd)
{
}

void ApplyVCUtil::Destroy(HWND hWnd)
{
}

//***************************************************************************
//
// Apply / Update selected
//
//***************************************************************************

void ApplyVCUtil::ApplySelected()
{
	int		lightModel = LIGHT_SCENELIGHT;
	BOOL	mixColors = FALSE;
	BOOL	castShadows = FALSE;
	BOOL	useMaps = FALSE;

	if (IsDlgButtonChecked(hPanel, IDC_VCUTIL_DIFFUSE))
		lightModel = LIGHT_DIFFUSE;

	if (IsDlgButtonChecked(hPanel, IDC_MIX))
		mixColors = TRUE;

	if (IsDlgButtonChecked(hPanel, IDC_CASTSHADOWS))
		castShadows = TRUE;

	if (IsDlgButtonChecked(hPanel, IDC_USEMAPS))
		useMaps = TRUE;

	for (int i=0; i<ip->GetSelNodeCount(); i++)
	{
		if (!ApplyNode(ip->GetSelNode(i), lightModel, mixColors, castShadows, useMaps)) {
			break;
		}
	}

	ip->RedrawViews(ip->GetTime());
}

class ProgCallback : public EvalColProgressCallback {
public:
	ProgCallback(ApplyVCUtil* util) { u = util; }
	BOOL progress(float prog) {
		static int p=-1;
		if (p!=int(prog*100.f)) {
			// Eliminate ugly flashing of progress bar by only
			// calling update if the value has changed.
			((ApplyVCUtil*)u)->ip->ProgressUpdate(int(prog*100.0f));
			p = int(prog*100.0f);
		}
		return ((ApplyVCUtil*)u)->ip->GetCancel();
	}

private:
	UtilityObj* u;
};

DWORD WINAPI dummy(LPVOID arg) {
	return(0);
}

BOOL ApplyVCUtil::ApplyNode(INode* node, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps)
{
	ProgCallback fn(this);

	if (!node)
		return TRUE;

	ObjectState os = node->EvalWorldState(ip->GetTime());
	if (!os.obj)
		return TRUE;

	if (!os.obj->CanConvertToType(triObjectClassID))
		return TRUE;

	FaceColorTab faceColors;
	ColorTab mixedVertexColors;

	if (lightModel != NO_UPDATE) {
		ip->ProgressStart(GetString(IDS_AVCU_PROGRESS), TRUE, dummy, NULL);

		if (bMix) {
			if (!calcMixedVertexColors(node, ip->GetTime(), lightModel, castShadows, useMaps, mixedVertexColors, &fn)) {
				ip->ProgressEnd();
				return FALSE;
			}
		}
		else {
			if (!calcFaceColors(node, ip->GetTime(), lightModel, castShadows, useMaps, faceColors, &fn)) {
				ip->ProgressEnd();
				return FALSE;
			}
		}

		ip->ProgressEnd();
	}


	ApplyVCMod* mod;
	
	if (!(mod = (ApplyVCMod*)GetModifier(node, APPLYVC_MOD_CLASS_ID))) {
		mod = (ApplyVCMod*)CreateInstance(OSM_CLASS_ID, APPLYVC_MOD_CLASS_ID);

		Object* obj = node->GetObjectRef();
		IDerivedObject* dobj = CreateDerivedObject(obj);
		dobj->AddModifier(mod);
		node->SetObjectRef(dobj);
	}

	if (lightModel != NO_UPDATE) {
		if (bMix) {
			mod->SetMixedColors(mixedVertexColors);
		}
		else {
			mod->SetColors(faceColors);
		}
	}

//	for (int i=0; i<vertexColors.Count(); i++) {
//		delete vertexColors[i];
//	}
	for (int i=0; i<faceColors.Count(); i++) {
		delete faceColors[i];
	}

	return TRUE;
}

//***************************************************************************
//
// Update all
//
//***************************************************************************

void ApplyVCUtil::UpdateAll()
{
	int		lightModel = LIGHT_SCENELIGHT;
	BOOL	mixColors = FALSE;
	BOOL	castShadows = FALSE;
	BOOL	useMaps = FALSE;

	if (IsDlgButtonChecked(hPanel, IDC_VCUTIL_DIFFUSE))
		lightModel = LIGHT_DIFFUSE;

	if (IsDlgButtonChecked(hPanel, IDC_MIX))
		mixColors = TRUE;

	if (IsDlgButtonChecked(hPanel, IDC_CASTSHADOWS))
		castShadows = TRUE;

	if (IsDlgButtonChecked(hPanel, IDC_USEMAPS))
		useMaps = TRUE;

	CheckForAndMakeUnique(lightModel, mixColors, castShadows, useMaps);
	
	for (int i=0; i<ip->GetRootNode()->NumberOfChildren(); i++)
	{
		if (!UpdateAllEnum(ip->GetRootNode()->GetChildNode(i), lightModel, mixColors, castShadows, useMaps)) {
			break;
		}
	}

	ip->RedrawViews(ip->GetTime());
}

BOOL ApplyVCUtil::UpdateAllEnum(INode* node, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps)
{
	for (int i=0; i<node->NumberOfChildren(); i++) {
		if (!UpdateAllEnum(node->GetChildNode(i), lightModel, bMix, castShadows, useMaps)) {
			return FALSE;
		}
	}

	if (GetModifier(node, APPLYVC_MOD_CLASS_ID)) {
		ApplyNode(node, lightModel, bMix, castShadows, useMaps);
	}

	return TRUE;
}

//***************************************************************************
//
// Analyze scene for instanced modifiers and instanced nodes sharing the
// modifier
//
//***************************************************************************

void ApplyVCUtil::CheckForAndMakeUnique(int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps)
{
	ModInfoTab	modTab;
	
	CheckAllNodesEnum(ip->GetRootNode(), modTab);

	for (int i=0; i<modTab.Count(); i++) {
		if (modTab[i]->nodes.Count() > 1) {
			MakeUnique(modTab[i], lightModel, bMix, castShadows, useMaps);
		}
		delete modTab[i];
	}
	modTab.ZeroCount();
	modTab.Shrink();
}

void ApplyVCUtil::CheckAllNodesEnum(INode* node, ModInfoTab& modTab)
{
	int i;
	BOOL found = FALSE;
	Modifier* mod = GetModifier(node, APPLYVC_MOD_CLASS_ID);
	if (mod) {
		for (i=0; i<modTab.Count(); i++) {
			if (modTab[i]->mod == mod) {
				modTab[i]->nodes.Append(1, &node, 5);
				found = TRUE;
			}
		}
		if (!found) {
			ModInfo* mh = new ModInfo;
			mh->mod = mod;
			mh->nodes.Append(1, &node, 5);
			modTab.Append(1, &mh, 5);
		}
	}
	int numChildren = node->NumberOfChildren();
	for (i=0; i<numChildren; i++) {
		CheckAllNodesEnum(node->GetChildNode(i), modTab);
	}
}

class DerivedObjTab : public Tab<IDerivedObject*> {
public:
	BOOL InList(IDerivedObject *dob) {
		for (int i=0; i<Count(); i++) {
			if ((*this)[i]==dob) return TRUE;
		}
		return FALSE;
	}
};

BOOL ApplyVCUtil::MakeUnique(ModInfo* mh, int lightModel, BOOL bMix, BOOL castShadows, BOOL useMaps)
{
	int i;
	
	if (!mh) {
		return FALSE;
	}

	// Step through all the nodes sharing this modifier	
	// and delete the modifier.
	// The modifier will be applied later when all the nodes
	// are finally updated.

	int nodeCount = mh->nodes.Count();
	for (i=0; i<nodeCount; i++) {
	    Object* obj = mh->nodes[i]->GetObjectRef();

	    if (!obj)
	        return FALSE;

	    while (obj && (obj->SuperClassID() == GEN_DERIVOB_CLASS_ID)) {
	        IDerivedObject* dobj = (IDerivedObject*)obj;
	        int m;
	        int numMods = dobj->NumModifiers();

			// This is really only needed for the first node
			// since they all share the same DerivedObject
	        for (m=0; m<numMods; m++) {
	            Modifier* mod = dobj->GetModifier(m);
	            if (mod) {
	                dobj->DeleteModifier(m);
	            }
	        }

			if (dobj->NumModifiers() == 0 && !dobj->TestAFlag(A_DERIVEDOBJ_DONTDELETE)) {
				obj = dobj->GetObjRef();
				obj->TransferReferences(dobj);
				dobj->SetAFlag(A_LOCK_TARGET);
				dobj->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				obj->NotifyDependents(FOREVER,0,REFMSG_SUBANIM_STRUCTURE_CHANGED);
				dobj->ClearAFlag(A_LOCK_TARGET);
				dobj->MaybeAutoDelete();
			}
			else {
				obj = dobj->GetObjRef();
			}
	    }

		ApplyNode(mh->nodes[i], NO_UPDATE, bMix, castShadows, useMaps);
	}

	return TRUE;
}


//***************************************************************************
//
// Utility methods
//
//***************************************************************************

// Traverse the pipeline for this node and return the first modifier with a
// specified ClassID

Modifier* ApplyVCUtil::GetModifier(INode* node, Class_ID modCID)
{
	Object* obj = node->GetObjectRef();

	if (!obj)
		return NULL;

	ObjectState os = node->EvalWorldState(0);
	if (os.obj && os.obj->SuperClassID() != GEOMOBJECT_CLASS_ID) {
		return NULL;
	}

	// For all derived objects (can be > 1)
	while (obj && (obj->SuperClassID() == GEN_DERIVOB_CLASS_ID)) {
		IDerivedObject* dobj = (IDerivedObject*)obj;
		int m;
		int numMods = dobj->NumModifiers();
		// Step through all modififers and verify the class id
		for (m=0; m<numMods; m++) {
			Modifier* mod = dobj->GetModifier(m);
			if (mod) {
				if (mod->ClassID() == modCID) {
					// Match! Return it
					return mod;
				}
			}
		}
		obj = dobj->GetObjRef();
	}

	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\utiltest.cpp ===
/**********************************************************************
 *<
	FILE: utiltest.cpp

	DESCRIPTION:  A test bed for APIs

	CREATED BY: Rolf Berteig

	HISTORY: created January 20 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/
#include "util.h"
#include "utilapi.h"
#include "istdplug.h"
#include "modstack.h"
#include "stdmat.h"
#include "bmmlib.h"

#define UTILTEST_CLASS_ID		0x99bb61a5

class UtilTest : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;		

		UtilTest();
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void MakeObject();
		void MakeGroup();
		void GroupObjs();
		void OpenGroup();
		void CloseGroup();
		void ExplodeGroup();
		void Ungroup();
		void SaveToFile();
		void LoadFromFile();
		void SetEnvironmentMap();
		void SetWAV();
		void SetAnimate(BOOL onOff);
		void RenderFrame();
	};
static UtilTest theUtilTest;

class UtilTestClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theUtilTest;}
	const TCHAR *	ClassName() {return _T("Utility Tester");}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return Class_ID(UTILTEST_CLASS_ID,0);}
	const TCHAR* 	Category() {return _T("");}
	};

static UtilTestClassDesc utilTestDesc;
ClassDesc* GetUtilTestDesc() {return &utilTestDesc;}


static BOOL CALLBACK UtilTestDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	switch (msg) {
		case WM_INITDIALOG:
			theUtilTest.Init(hWnd);			
			break;
		
		case WM_DESTROY:
			theUtilTest.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					theUtilTest.iu->CloseUtility();
					break;

				case IDC_TESTER_MAKEOBJECT:
					theUtilTest.MakeObject();
					break;

				case IDC_TESTER_MAKEGROUP:
					theUtilTest.MakeGroup();
					break;

				case IDC_TESTER_GROUPOBJS:
					theUtilTest.GroupObjs();
					break;

				case IDC_TESTER_OPENGROUP:
					theUtilTest.OpenGroup();
					break;

				case IDC_TESTER_CLOSEGROUP:
					theUtilTest.CloseGroup();
					break;

				case IDC_TESTER_EXPLODEGROUP:
					theUtilTest.ExplodeGroup();
					break;

				case IDC_TESTER_UNGROUP:
					theUtilTest.Ungroup();
					break;

				case IDC_TESTER_SAVETOFILE:
					theUtilTest.SaveToFile();
					break;

				case IDC_TESTER_LOADFROMFILE:
					theUtilTest.LoadFromFile();
					break;

				case IDC_TESTER_SETENV:
					theUtilTest.SetEnvironmentMap();
					break;

				case IDC_TESTER_SETWAV:
					theUtilTest.SetWAV();
					break;

				case IDS_TESTER_ANIMON:
					theUtilTest.SetAnimate(TRUE);
					break;

				case IDS_TESTER_ANIMOFF:
					theUtilTest.SetAnimate(FALSE);
					break;

				case IDS_TESTER_RENDER:
					theUtilTest.RenderFrame();
					break;
				}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theUtilTest.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
		}
	return TRUE; 
	}


UtilTest::UtilTest()
	{

	}

void UtilTest::BeginEditParams(Interface *ip,IUtil *iu)
	{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_UTILTEST_PANEL),
		UtilTestDlgProc,
		_T("Util Test"),
		0);
	}

void UtilTest::EndEditParams(Interface *ip,IUtil *iu)
	{	
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	}

void UtilTest::Init(HWND hWnd)
	{
	}

void UtilTest::Destroy(HWND hWnd)
	{
	}

void UtilTest::MakeObject()
	{
	// Create a new object through the CreateInstance() API
	Object *obj = (Object*)ip->CreateInstance(
		GEOMOBJECT_CLASS_ID,
		Class_ID(CYLINDER_CLASS_ID,0));
	assert(obj);

	// Get a hold of the parameter block
	IParamArray *iCylParams = obj->GetParamBlock();
	assert(iCylParams);

	// Set the value of radius, height and segs.
	int rad = obj->GetParamBlockIndex(CYLINDER_RADIUS);
	assert(rad>=0);
	iCylParams->SetValue(rad,TimeValue(0),30.0f);
	int height = obj->GetParamBlockIndex(CYLINDER_HEIGHT);
	assert(height>=0);
	iCylParams->SetValue(height,TimeValue(0),100.0f);
	int segs = obj->GetParamBlockIndex(CYLINDER_SEGMENTS);
	assert(segs>=0);
	iCylParams->SetValue(segs,TimeValue(0),10);

	// Create a derived object that references the cylinder
	IDerivedObject *dobj = CreateDerivedObject(obj);

	// Create a bend modifier
	Modifier *bend = (Modifier*)ip->CreateInstance(
		OSM_CLASS_ID,
		Class_ID(BENDOSM_CLASS_ID,0));

	// Set the bend angle
	IParamArray *iBendParams = bend->GetParamBlock();
	assert(iBendParams);
	int angle = bend->GetParamBlockIndex(BEND_ANGLE);
	iBendParams->SetValue(angle,TimeValue(0),90.0f);

	// Add the bend modifier to the derived object.
	dobj->AddModifier(bend);

	// Create a node in the scene that references the derived object
	INode *node = ip->CreateObjectNode(dobj);
	
	// Name the node and make the name unique.
	TSTR name(_T("MyNode"));
	ip->MakeNameUnique(name);
	node->SetName(name);

	// Get ready to add WSMs to this node
	node->CreateWSMDerivedObject();
	IDerivedObject *wsdobj = node->GetWSMDerivedObject();
	if (wsdobj) {
		WSMObject *swobj = (WSMObject*)ip->CreateInstance(
			WSM_OBJECT_CLASS_ID,
			Class_ID(SINEWAVE_OBJECT_CLASS_ID,0));
		int ix;
		IParamArray *iRipParams = swobj->GetParamBlock();
		
		ix = swobj->GetParamBlockIndex(RWAVE_AMPLITUDE);
		iRipParams->SetValue(ix,TimeValue(0),10.0f);

		ix = swobj->GetParamBlockIndex(RWAVE_AMPLITUDE2);
		iRipParams->SetValue(ix,TimeValue(0),10.0f);

		ix = swobj->GetParamBlockIndex(RWAVE_WAVELEN);
		iRipParams->SetValue(ix,TimeValue(0),40.0f);

		ix = swobj->GetParamBlockIndex(RWAVE_CIRCLES);
		iRipParams->SetValue(ix,TimeValue(0),10);

		ix = swobj->GetParamBlockIndex(RWAVE_DIVISIONS);
		iRipParams->SetValue(ix,TimeValue(0),4);

		ix = swobj->GetParamBlockIndex(RWAVE_SEGMENTS);
		iRipParams->SetValue(ix,TimeValue(0),16);

		INode *swnode = ip->CreateObjectNode(swobj);
		
		TSTR swname(_T("RippleNode"));
		ip->MakeNameUnique(swname);
		node->SetName(swname);

		// Create a Space Warp Modifier
		Modifier *swmod = swobj->CreateWSMMod(swnode);
		if (swmod) {
			wsdobj->AddModifier(swmod);
			}
		}
	
	// Redraw the views
	ip->RedrawViews(ip->GetTime());
	}

static INode *MakeGroupObj(Interface *ip,Point3 p)
	{
	Object *obj = (Object*)ip->CreateInstance(
		GEOMOBJECT_CLASS_ID,
		Class_ID(CYLINDER_CLASS_ID,0));
	IParamArray *iCylParams = obj->GetParamBlock();
	int rad = obj->GetParamBlockIndex(CYLINDER_RADIUS);	
	iCylParams->SetValue(rad,TimeValue(0),20.0f);
	int height = obj->GetParamBlockIndex(CYLINDER_HEIGHT);	
	iCylParams->SetValue(height,TimeValue(0),50.0f);
	INode *node = ip->CreateObjectNode(obj);
	Matrix3 tm(1);
	tm.SetTrans(p);
	node->SetNodeTM(0,tm);
	return node;
	}

void UtilTest::MakeGroup()
	{
	INode *node1, *node2, *node3, *node4, *gnode1, *gnode2;

	node1 = MakeGroupObj(ip,Point3(-50,0,0));
	node2 = MakeGroupObj(ip,Point3( 50,0,0));
	node3 = MakeGroupObj(ip,Point3(-50,100,0));
	node4 = MakeGroupObj(ip,Point3( 50,100,0));
	
	INodeTab tab1;
	tab1.Append(1,&node1);
	tab1.Append(1,&node2);
	
	INodeTab tab2;
	tab2.Append(1,&node3);
	tab2.Append(1,&node4);
	
	TSTR nam1("Group1");
	TSTR nam2("Group2");
	gnode1 = ip->GroupNodes(&tab1,&nam1,FALSE);
	gnode2 = ip->GroupNodes(&tab2,&nam2,FALSE);
	
	INodeTab tab3;
	tab3.Append(1,&gnode1);
	tab3.Append(1,&gnode2);
	TSTR nam3("Main Group");
	ip->GroupNodes(&tab3,&nam3,FALSE);

	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::GroupObjs()
	{
	ip->GroupNodes();
	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::OpenGroup()
	{
	ip->OpenGroup();
	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::CloseGroup()
	{
	ip->CloseGroup();
	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::ExplodeGroup()
	{
	ip->ExplodeNodes();
	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::Ungroup()
	{
	ip->UngroupNodes();
	ip->RedrawViews(ip->GetTime());
	}

void UtilTest::SaveToFile()
	{
	ip->SaveToFile(_T("c:\\devel\\3dswin\\src\\exe\\scenes\\savetest.max"));
	MessageBox(hPanel,_T("Save Completed."),_T("SaveToFile() Test"),MB_OK);
	}

void UtilTest::LoadFromFile()
	{
	ip->LoadFromFile(_T("c:\\devel\\3dswin\\src\\exe\\scenes\\savetest.max"));
	MessageBox(hPanel,_T("File Loaded."),_T("LoadFromFile() Test"),MB_OK);
	}

void UtilTest::SetEnvironmentMap()
	{
	// Make a bitmap texture map.
	BitmapTex *map = NewDefaultBitmapTex();
	
	// Get the UVGen
	StdUVGen *uvGen = map->GetUVGen();
	
	// Set up the coords. to be screen environment.
	uvGen->SetCoordMapping(UVMAP_SCREEN_ENV);

	// Set the bitmap file.
	map->SetMapName(_T("A_MAX.TGA"));

	// Make this the new environment map.
	ip->SetEnvironmentMap(map);
	}

void UtilTest::SetWAV()
	{
	// Get the current sound object.
	SoundObj *snd = ip->GetSoundObject();
	
	// See if we can get a wave interface
	IWaveSound *iWav = GetWaveSoundInterface(snd);
	if (iWav) {
		// Set the sound file
		if (!iWav->SetSoundFileName(_T("test.wav"))) {
			MessageBox(hPanel,
				_T("Unable to load TEST.WAV"),
				_T("Util Test"),MB_OK);
			return;
			}
		// Set the offset to 10 frames.
		iWav->SetStartTime(GetTicksPerFrame() * 10);
	} else {
		MessageBox(hPanel,
			_T("No IWaveSound interface"),
			_T("Util Test"),MB_OK);
		}
	}

void UtilTest::SetAnimate(BOOL onOff)
	{
	ip->SetAnimateButtonState(onOff);
	}

void UtilTest::RenderFrame()
	{
	int res;
	
	// Create a blank bitmap
	static Bitmap *bm = NULL;
	if (!bm) {
		BitmapInfo bi;		
		bi.SetWidth(320);
		bi.SetHeight(200);
		bi.SetType(BMM_TRUE_64);
		bi.SetFlags(MAP_HAS_ALPHA);
		bi.SetAspect(1.0f);
		bm = TheManager->Create(&bi);
		}

	// Get the active viewport to render
	ViewExp *view = ip->GetActiveViewport();
	
	// Display the bitmap
	bm->Display(_T("Test"));

	// Open up the renderer, render a frame and close it.
	res = ip->OpenCurRenderer(NULL,view);
	res = ip->CurRendererRenderFrame(
		ip->GetTime(),bm);
	ip->CloseCurRenderer();	

	// We're done with the viewport.
	ip->ReleaseViewport(view);
	}

//-----------------------------------------------------------

#define TEST_SOUNDOBJ_CLASS_ID	0x5eda4197

class TestSoundObj : public SoundObj {
	public:		
		BOOL Play(TimeValue tStart,TimeValue t0,TimeValue t1,TimeValue frameStep)
			{ return FALSE;}
		void Scrub(TimeValue t0,TimeValue t1) {}
		TimeValue Stop() {return 0;}
		TimeValue GetTime() {return 0;}
		BOOL Playing() {return FALSE;}
		void SaveSound(PAVIFILE pfile,TimeValue t0,TimeValue t1) {}
		void SetMute(BOOL mute) {}
		BOOL IsMute() {return FALSE;}

		void DeleteThis() {delete this;}
		Class_ID ClassID() {return Class_ID(TEST_SOUNDOBJ_CLASS_ID,0);}
		void GetClassName(TSTR& s) {s=_T("Test Sound Object");}

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message) {return REF_SUCCEED;}
	};

class TestSoundObjClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1;}
	void *			Create(BOOL loading) {return new TestSoundObj;}
	const TCHAR *	ClassName() { return _T("Test Sound Object"); }
	SClass_ID		SuperClassID() { return SClass_ID(SOUNDOBJ_CLASS_ID); }
	Class_ID 		ClassID() { return Class_ID(TEST_SOUNDOBJ_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static TestSoundObjClassDesc sndObjDesc;
ClassDesc *GetTestSoundObjDescriptor() {return &sndObjDesc;}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\EvalCol.cpp ===
/**********************************************************************
 *<
	FILE:			EvalCol.cpp
	DESCRIPTION:	Vertex Color Renderer
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, December 12, 1996

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/
//***************************************************************************
// December 12/13   1996	CCJ
// January  8		1997	CCJ  Bugfix
// June		1		1997	CCJ  Port to MAX 2.0
// June		6		1997	CCJ  Implemented full ShadeContext
// Dec		1		1998	CCJ  Shadow casting n' colors per face (unmixed vertex colors)
//
// Description:
// These functions calculates the diffuse, ambient or pre-lit color at each
// vertex or face of an INode.
//
// Exports:
// BOOL calcMixedVertexColors(INode*, TimeValue, int, ColorTab&);
//      This function calculates the interpolated diffuse or ambient 
//      color at each vetex of an INode.
//      Usage: Pass in a node pointer and the TimeValue to generate
//      a list of Colors corresponding to each vertex in the mesh
//      Use the int flag to specify if you want to have diffuse or 
//      ambient colors, or if you want to use the scene lights.
//      Note: 
//        You are responsible for deleting the Color objects in the table.
//      Additional note:
//        Since materials are assigned by face, this function renders each
//        face connected to the specific vertex (at the point of the vertex)
//        and mixes the colors afterwards. If this is not what you want
//        you can use the calcFaceColors() to calculate the color at the
//        centerpoint of each face.
//
//***************************************************************************

#include "max.h"
#include "bmmlib.h"
#include "evalcol.h"

// Enable this to print out debug information
// #define EVALCOL_DEBUG

class SContext;
class RefEnumProc;
class MeshInstance;

// Information about closest hit for shadow casting
struct HitInfo {
	MeshInstance*	instance;
	float			distance;	// Distance from light to shaded point
	Point3			hitPos;
	};

typedef float Plane[4];	// A plane definition.

Point3		interpVertexNormal(Mesh* mesh, Matrix3 tm, unsigned int vxNo, BitArray& faceList);
void		AddSceneLights(INode* node, SContext* sc, MtlBaseLib* mtls, int* numLights);
int			LoadMapFiles(INode* node, SContext* sc, MtlBaseLib& mtls, TimeValue t);
void		EnumRefs(ReferenceMaker *rm, RefEnumProc &proc);
TriObject*	GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt);

// Shadow raycasting
// These functions are essentially ripped out of context from the
// sample renderer. For full information please refer to
// maxsdk\samples\cjrender
BOOL		intersectMesh(Ray* ray, HitInfo& hitInfo);
BOOL		intersectTri(Ray* ray, Point3* tri, Point3& baryCoord, Point3& normal, Point3& hitPos);
void		CompPlaneEqn(Plane plane, const Point3& p0, const Point3& p1, const Point3& p2);
BOOL		rayBoundHit(Ray* ray, Box3 boundingBox);
BOOL		TMNegParity(Matrix3 &m);
Point3		CalcBaryCoords(Point3 p0, Point3 p1, Point3 p2, Point3 p);

#define BIGFLOAT (float(1.0e30))


//***************************************************************************
//* The is the map enumerator class used for collecting projector lights for
//* spotlights
//***************************************************************************

class GetMaps: public RefEnumProc {
	MtlBaseLib *mlib;
	public:
	void proc(ReferenceMaker *rm);
	GetMaps(MtlBaseLib *mbl);
};

//***************************************************************************
//* The is the Light descriptor object for default lights
//***************************************************************************
class DefObjLight : public ObjLightDesc 
{
	public:
		Color intensCol;   // intens*color 
		DefObjLight(DefaultLight *l);
		void DeleteThis() {delete this;}
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);
		int UpdateViewDepParams(const Matrix3& worldToCam);
		BOOL Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float &diffCoef);
};

class LightInfo {
public:
	LightInfo(INode* node, MtlBaseLib* mtls);
	LightInfo(DefaultLight* l);
	~LightInfo();

	ObjLightDesc* lightDesc;
	LightObject *light;
	BOOL		bIsObscured;
	float		distanceToShadedPoint;
};

typedef Tab<LightInfo*> LightTab;

//***************************************************************************
//* The MeshInstance list is a list of all meshes in world space
//***************************************************************************

class MeshInstance {
	public:

	MeshInstance(INode* node);
	~MeshInstance();

	INode*	node;
	Mesh*	mesh;	// A copy of the mesh

	BOOL	negParity;

	Point3	center;	// Bounding sphere
	float	radsq;

	Box3	boundingBox;
	};

MeshInstance::MeshInstance(INode* node)
	{
	mesh = NULL;
	int	v;

	this->node = node;

	BOOL	deleteIt;
	TriObject* tri = GetTriObjectFromNode(node, GetCOREInterface()->GetTime(), deleteIt);
	if (tri) {
		mesh = new Mesh;
		*mesh = *&tri->GetMesh();

		Point3 vx;
		Matrix3 objToWorld = node->GetObjTMAfterWSM(GetCOREInterface()->GetTime());

		negParity = TMNegParity(objToWorld);

		mesh->buildRenderNormals();

		// Transform the vertices
		for (v=0; v<mesh->numVerts; v++) {
			vx =  objToWorld * mesh->getVert(v);
			mesh->setVert(v, vx);
			}

		Matrix3 normalObjToWorld(1);
		// Calculate the inverse-transpose of objToWorld for transforming normals.
		for (int it=0; it<3; it++) {
			Point4 p = Inverse(objToWorld).GetColumn(it);
			normalObjToWorld.SetRow(it,Point3(p[0],p[1],p[2]));
			}

		// Transform the face normals
		for (int nf = 0; nf < mesh->numFaces; nf++) {
			Point3	fn = mesh->getFaceNormal(nf);
			Point3	nfn = VectorTransform(normalObjToWorld, fn);
			mesh->setFaceNormal(nf, nfn);
		}

		boundingBox = mesh->getBoundingBox();

		// Get the bounding sphere
		center = 0.5f*(boundingBox.pmin+boundingBox.pmax);
		radsq = 0.0f;
		Point3 d;
		float nr;
		for (v= 0; v<mesh->numVerts; v++) {
			d = mesh->verts[v] - center;
			nr = DotProd(d,d);
			if (nr>radsq) radsq = nr;
			}

		if (deleteIt) {
			delete tri;
			}
		}
	}

MeshInstance::~MeshInstance()
	{
	if (mesh) {
		mesh->DeleteThis();
		}
	}

typedef Tab<MeshInstance*> MeshInstanceTab;

void InitInstanceList(INode* node, MeshInstanceTab& ilist)
	{
	if (!node->IsRootNode()) {
		if (!node->IsHidden()) {
			ObjectState os = node->EvalWorldState(GetCOREInterface()->GetTime());
			if (os.obj && os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID) {
				MeshInstance* inst = new MeshInstance(node);
				ilist.Append(1, &inst, 50);
				}
			}
		}

	int numChildren = node->NumberOfChildren();
	for (int c=0; c<numChildren; c++) {
		InitInstanceList(node->GetChildNode(c), ilist);
		}
	}

void FreeInstanceList(MeshInstanceTab& ilist)
	{
	int numItems = ilist.Count();
	for (int i=0; i<numItems; i++) {
		delete ilist[i];
		}
	ilist.ZeroCount();
	ilist.Shrink();
	}

MeshInstance* GetNodeFromMeshInstance(INode* node, MeshInstanceTab& ilist)
	{
	int numItems = ilist.Count();
	for (int i=0; i<numItems; i++) {
		if (ilist[i]->node == node) {
			return ilist[i];
			}
		}
	return NULL;
	}

//***************************************************************************
//* RendContext is used to evaluate the lights
//***************************************************************************

 class RContext: public RendContext {
	public:
		Matrix3	WorldToCam() const { return Matrix3(1); }
		ShadowBuffer*	NewShadowBuffer() const;
		ShadowQuadTree*	NewShadowQuadTree() const;
		Color	GlobalLightLevel() const;
		int	Progress(int done, int total) {
			return 1;
		}
};

//***************************************************************************
// ShadeContext for evaluating materials
//***************************************************************************

class SContext : public ShadeContext {
public:
	SContext();
	~SContext();

	TimeValue CurTime();
	int NodeID();
	INode* Node();
	Point3 BarycentricCoords();
	int FaceNumber();
	Point3 Normal();
	float Curve();

	LightDesc*	Light(int lightNo);
	Point3	GNormal(void);
	Point3	ReflectVector(void);
	Point3	RefractVector(float ior);
	Point3	CamPos(void);
	Point3	V(void);
	Point3	P(void);
	Point3	DP(void);
	Point3	PObj(void);
	Point3	DPObj(void);
	Box3	ObjectBox(void);
	Point3	PObjRelBox(void);
	Point3	DPObjRelBox(void);
	void	ScreenUV(Point2 &uv,Point2 &duv);
	IPoint2	ScreenCoord(void);
	Point3	UVW(int chan);
	Point3	DUVW(int chan);
	void	DPdUVW(Point3 [], int chan);
	void	GetBGColor(Color &bgCol, Color &transp, int fogBG);
	Point3	PointTo(const Point3 &p, RefFrame ito);
	Point3	PointFrom(const Point3 &p, RefFrame ito);
	Point3	VectorTo(const Point3 &p, RefFrame ito);
	Point3	VectorFrom(const Point3 &p, RefFrame ito);
	int		InMtlEditor();
	void	SetView(Point3 v);

	int		ProjType();
	void	SetNodeAndTime(INode* n, TimeValue tm);
	void	SetMesh(Mesh* m);
	void	SetBaryCoord(Point3 bary);
	void	SetFaceNum(int f);
	void	SetMtlNum(int mNo);
	void	SetTargetPoint(Point3 tp);
	void	SetViewPoint(Point3 vp);
	void	SetViewDir(Point3 vd);
	void	CalcNormals();
	void	CalcBoundObj();
	void	ClearLights();
	void	AddLight(LightInfo* li);
	void	SetAmbientLight(Color c);
	void	UpdateLights();
	void	calc_size_ratio();
	float	RayDiam() {return 0.1f;}
	void	getTVerts(int chan);
	void	getObjVerts();

	void	CalcShadow(MeshInstanceTab& ilist);
	void	TurnOffObscuredLights(MeshInstance* mi);
	void	SetDiffuseOnly(bool d);

public:
	LightTab lightTab;
	LightTab allLights;
	Matrix3 tmAfterWSM;
	Point3 vxNormals[3];

private:
	INode* node;
	Mesh* mesh;
	Point3 baryCoord;
	int faceNum;
	Point3 targetPt;
	Point3 viewDir;
	Point3 viewPoint;
	TimeValue t;
	UVVert tv[MAX_MESHMAPS][3];
	Point3 bumpv[MAX_MESHMAPS][3];
	Box3 boundingObj;
	RContext rc;
	Point3	obpos[3];
	Point3	dobpos;
	float ratio;
	float curve;
	bool	bDiffuseOnly;
};

//***************************************************************************
//* Dummy Material : Simple Phong shader using Node color
//* This material is assigned to each node that does not have a material
//* previously assigned. The diffuse color is assigned based on the 
//* wireframe color.
//* This way we can assume that all nodes have a material assigned.
//***************************************************************************

#define DUMMTL_CLASS_ID	Class_ID(0x4efd2694, 0x37c809f4)

#define DUMSHINE	.20f
#define DUMSPEC		.20f

class DumMtl: public Mtl {
	Color diff, spec;
	float phongexp;
	public:
		DumMtl(Color c);
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
		Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		void SetAmbient(Color c, TimeValue t);
		void SetDiffuse(Color c, TimeValue t);
		void SetSpecular(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);
		Class_ID ClassID();
		void DeleteThis();
    	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
		void Shade(ShadeContext& sc);
};


// Return a pointer to a TriObject given an INode or return NULL
// if the node cannot be converted to a TriObject
TriObject* GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt)
{
	deleteIt = FALSE;
	Object *obj = node->EvalWorldState(t).obj;
	if (obj->CanConvertToType(Class_ID(TRIOBJ_CLASS_ID, 0))) { 
		TriObject *tri = (TriObject *) obj->ConvertToType(t, 
			Class_ID(TRIOBJ_CLASS_ID, 0));
		// Note that the TriObject should only be deleted
		// if the pointer to it is not equal to the object
		// pointer that called ConvertToType()
		if (obj != tri) deleteIt = TRUE;
		return tri;
	}
	else {
		return NULL;
	}
}

//***************************************************************************
// Calculate ambient or diffuse color at each vertex.
//***************************************************************************
BOOL calcFaceColors(INode* node, TimeValue t, int lightModel, BOOL castShadows, BOOL useMaps, FaceColorTab& faceColTab, EvalColProgressCallback* fn)
{
	ObjectState ostate;
	Mesh* mesh;
	SContext sc;
	DefaultLight dl1, dl2;
	MtlBaseLib mtls;
	Matrix3 tm;
	MeshInstanceTab	instanceList;

	sc.SetNodeAndTime(node, t);
	tm = sc.tmAfterWSM;

	InitInstanceList(GetCOREInterface()->GetRootNode(), instanceList);

	MeshInstance* mi = GetNodeFromMeshInstance(node, instanceList);
	if (!mi) {
		FreeInstanceList(instanceList);
		return TRUE;	// Returning FALSE would prevent us from processing the next node.
		}

	mesh = mi->mesh;
	if (!mesh) {
		FreeInstanceList(instanceList);
		return TRUE;	// Returning FALSE would prevent us from processing the next node.
		}

	// If the node doesn't have a material attached,
	// we create a dummy material.
	Mtl* mtl = node->GetMtl();
	if (!mtl) {
		mtl = new DumMtl(node->GetWireColor());
	}

	faceColTab.ZeroCount();
	faceColTab.Shrink();

	sc.SetMesh(mesh);
	sc.CalcBoundObj();
	sc.doMaps = useMaps;
	sc.SetDiffuseOnly(lightModel == LIGHT_DIFFUSE);

	// Add the material to the list
	mtls.AddMtl(mtl);

	// If we're using the real lights, we need to find them first
	if (lightModel == LIGHT_SCENELIGHT) {
		int numLights = 0;
		AddSceneLights(node, &sc, &mtls, &numLights);

		// Add default lights if there are no lights in the scene
		if (numLights == 0) {
			dl1.ls.intens = 1.0f;
			dl1.ls.color = Color(1.0f, 1.0f, 1.0f);
			dl1.ls.type = OMNI_LGT;
			dl1.tm = TransMatrix(1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			dl2.ls.intens = 1.0f;
			dl2.ls.color = Color(1.0f, 1.0f, 1.0f);
			dl2.ls.type = OMNI_LGT;
			dl2.tm = TransMatrix(-1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			sc.AddLight(new LightInfo(&dl1));
			sc.AddLight(new LightInfo(&dl2));
		}

		sc.SetAmbientLight(GetCOREInterface()->GetAmbient(t, FOREVER));
	}

	if (castShadows) {
		for (int i=0; i<sc.lightTab.Count(); i++) {
			sc.allLights.Append(1, &(sc.lightTab[i]), 5);
			}
		}

	sc.UpdateLights();
	// Update material
	mtl->Update(t, FOREVER);

	int numFaces = mesh->numFaces;

	for (unsigned int f = 0; f < (unsigned)numFaces; f++) {
		if (fn) {
			if (fn->progress(float(f)/float(numFaces))) {
				FreeInstanceList(instanceList);

				mtls.Empty();

				if (mtl->ClassID() == DUMMTL_CLASS_ID) {
					delete mtl;
				}

				return FALSE;
				}
			}

		FaceColor* faceCol = new FaceColor();

		for (int fv=0; fv<3; fv++) {
			sc.SetFaceNum(f);
			Face* face = &mesh->faces[f];
			sc.SetMtlNum(face->getMatID());
			sc.CalcNormals();

			Point3 vxNormal = sc.vxNormals[fv];

			Point3 viewDir = -vxNormal;
			Point3 viewPoint = mesh->verts[mesh->faces[f].v[fv]] + 5.0f*vxNormal;
			Point3 lightPos = viewPoint;
			Point3 viewTarget = mesh->verts[mesh->faces[f].v[fv]];

			// render vertex for this face.
			sc.SetViewPoint(viewPoint);
			sc.SetTargetPoint(viewTarget);
			sc.SetViewDir(viewDir);

			// Setup the barycentric coordinate
			if (fv == 0)
				sc.SetBaryCoord(Point3(1.0f, 0.0f, 0.0f));
			else if (fv == 1)
				sc.SetBaryCoord(Point3(0.0f, 1.0f, 0.0f));
			else if (fv == 2)
				sc.SetBaryCoord(Point3(0.0f, 0.0f, 1.0f));

			// Use diffuse color instead of ambient
			// The only difference is that we create a special light
			// located at the viewpoint and we set the ambient light to black.
			if (lightModel == LIGHT_DIFFUSE) {
				dl1.ls.intens = 1.0f;
				dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
				dl1.ls.type = OMNI_LGT;
				dl1.tm = TransMatrix(lightPos);

				sc.ClearLights();
				sc.AddLight(new LightInfo(&dl1));
				sc.UpdateLights();
			}
			else {
				if (castShadows) {
					sc.CalcShadow(instanceList);
					}
				}

			// Shade the vertex
			mtl->Shade(sc);

			faceCol->colors[fv].r = sc.out.c.r;
			faceCol->colors[fv].g = sc.out.c.g;
			faceCol->colors[fv].b = sc.out.c.b;

			faceCol->colors[fv].ClampMinMax();
			}

		// Append the Color to the table. If the array needs
		// to be realloc'ed, allocate extra space for 100 points.
		faceColTab.Append(1, &faceCol, 100);
		}

	if (castShadows) {
		sc.lightTab.ZeroCount();
		for (int i=0; i<sc.allLights.Count(); i++) {
			sc.lightTab.Append(1, &(sc.allLights[i]), 5);
			}
		}

	mtls.Empty();

	if (mtl->ClassID() == DUMMTL_CLASS_ID) {
		delete mtl;
	}

	FreeInstanceList(instanceList);

	return TRUE;
}



//***************************************************************************
// Calculate ambient or diffuse color at each vertex.
// Pass in TRUE as the "diffuse" parameter to calculate the diffuse color.
// If FALSE is passed in, ambient color is calculated.
//***************************************************************************
BOOL calcMixedVertexColors(INode* node, TimeValue t, int lightModel, BOOL castShadows, BOOL useMaps, ColorTab& vxColTab, EvalColProgressCallback* fn)
{
	ObjectState ostate;
	Mesh* mesh;
	SContext sc;
	DefaultLight dl1, dl2;
	MtlBaseLib mtls;
	Matrix3 tm;
	MeshInstanceTab	instanceList;

	sc.SetNodeAndTime(node, t);
	tm = sc.tmAfterWSM;

	InitInstanceList(GetCOREInterface()->GetRootNode(), instanceList);

	MeshInstance* mi = GetNodeFromMeshInstance(node, instanceList);
	if (!mi) {
		FreeInstanceList(instanceList);
		return TRUE;	// Returning FALSE would prevent us from processing the next node.
		}

	mesh = mi->mesh;
	if (!mesh) {
		FreeInstanceList(instanceList);
		return TRUE;	// Returning FALSE would prevent us from processing the next node.
		}

	// If the node doesn't have a material attached,
	// we create a dummy material.
	Mtl* mtl = node->GetMtl();
	if (!mtl) {
		mtl = new DumMtl(node->GetWireColor());
	}

	vxColTab.ZeroCount();
	vxColTab.Shrink();

	sc.SetMesh(mesh);
	sc.CalcBoundObj();
	sc.doMaps = useMaps;
	sc.SetDiffuseOnly(lightModel == LIGHT_DIFFUSE);

	// Add the material to the list
	mtls.AddMtl(mtl);

	// If we're using the real lights, we need to find them first
	if (lightModel == LIGHT_SCENELIGHT) {
		int numLights = 0;
		AddSceneLights(node, &sc, &mtls, &numLights);

		// Add default lights if there are no lights in the scene
		if (numLights == 0) {
			dl1.ls.intens = 1.0f;
			dl1.ls.color = Color(1.0f, 1.0f, 1.0f);
			dl1.ls.type = OMNI_LGT;
			dl1.tm = TransMatrix(1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			dl2.ls.intens = 1.0f;
			dl2.ls.color = Color(1.0f, 1.0f, 1.0f);
			dl2.ls.type = OMNI_LGT;
			dl2.tm = TransMatrix(-1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			sc.AddLight(new LightInfo(&dl1));
			sc.AddLight(new LightInfo(&dl2));
		}

		sc.SetAmbientLight(GetCOREInterface()->GetAmbient(t, FOREVER));
	}

	if (castShadows) {
		for (int i=0; i<sc.lightTab.Count(); i++) {
			sc.allLights.Append(1, &(sc.lightTab[i]), 5);
			}
		}

	sc.UpdateLights();
	// Update material
	mtl->Update(t, FOREVER);
	
	int numVerts = mesh->numVerts;
	for (unsigned int v = 0; v < (unsigned)numVerts; v++) {

		if (fn) {
			if (fn->progress(float(v)/float(numVerts))) {
				FreeInstanceList(instanceList);

				mtls.Empty();

				if (mtl->ClassID() == DUMMTL_CLASS_ID) {
					delete mtl;
				}

				return FALSE;
			}
		}

		// Create a new entry
		Color* vxCol = new Color;
		Point3 tmpCol(0.0f, 0.0f, 0.0f);

		int numShades = 0;
		BitArray faceList;
		faceList.SetSize(mesh->numFaces, 0);

		// Get vertex normal
		// We also pass in a BitArray that will be filled in with
		// to inform us to which faces this vertex belongs.
		// We could do this manually, but we need to do it to get
		// the vertex normal anyway so this is done to speed things
		// up a bit.
		Point3 vxNormal = interpVertexNormal(mesh, tm, v, faceList);
		Point3 viewDir = -vxNormal;
		Point3 viewPoint = mesh->verts[v] + 5.0f*vxNormal;
		Point3 lightPos = viewPoint;
		Point3 viewTarget = mesh->verts[v];

		// We now have a viewpoint and a view target.
		// Now we just have to shade this point on the mesh in order
		// to get it's color.
		// Note: 
		// Since materials are assigned on Face basis we need to render each
		// vertex as many times as it has connecting faces.
		// the colors collected are mixed to get the resulting
		// color at each vertex.
		
		for (int nf = 0; nf < faceList.GetSize(); nf++) {
			if (faceList[nf]) {
				// render vertex for this face.
				sc.SetViewPoint(viewPoint);
				sc.SetTargetPoint(viewTarget);
				sc.SetViewDir(viewDir);
				sc.SetFaceNum(nf);
				Face* f = &mesh->faces[nf];
				sc.SetMtlNum(f->getMatID());
				sc.CalcNormals();

				// Setup the barycentric coordinate
				if (mesh->faces[nf].v[0] == v)
					sc.SetBaryCoord(Point3(1.0f, 0.0f, 0.0f));
				else if (mesh->faces[nf].v[1] == v)
					sc.SetBaryCoord(Point3(0.0f, 1.0f, 0.0f));
				else if (mesh->faces[nf].v[2] == v)
					sc.SetBaryCoord(Point3(0.0f, 0.0f, 1.0f));

				// Use diffuse color instead of ambient
				// The only difference is that we create a special light
				// located at the viewpoint and we set the ambient light to black.
				if (lightModel == LIGHT_DIFFUSE) {
					dl1.ls.intens = 1.0f;
					dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
					dl1.ls.type = OMNI_LGT;
					dl1.tm = TransMatrix(lightPos);

					sc.ClearLights();
					sc.AddLight(new LightInfo(&dl1));
					sc.UpdateLights();
				}
				else {
					if (castShadows) {
						sc.CalcShadow(instanceList);
						}
					}

				// Shade the vertex
				mtl->Shade(sc);

				tmpCol.x += sc.out.c.r;
				tmpCol.y += sc.out.c.g;
				tmpCol.z += sc.out.c.b;
				numShades++;
			}
		}

		// The color mixes. We just add the colors together and 
		// then divide with as many colors as we added.
		if (numShades > 0) {
			tmpCol = tmpCol / (float)numShades;
		}

		
		vxCol->r = tmpCol.x;
		vxCol->g = tmpCol.y;
		vxCol->b = tmpCol.z;

		
		vxCol->ClampMinMax();

		
		// Append the Color to the table. If the array needs
		// to be realloc'ed, allocate extra space for 100 points.
		vxColTab.Append(1, &vxCol, 100);
	}

	if (castShadows) {
		sc.lightTab.ZeroCount();
		for (int i=0; i<sc.allLights.Count(); i++) {
			sc.lightTab.Append(1, &(sc.allLights[i]), 5);
			}
		}

	FreeInstanceList(instanceList);

	mtls.Empty();

	if (mtl->ClassID() == DUMMTL_CLASS_ID) {
		delete mtl;
	}

	return TRUE;
}


// Since vertices might have different normals depending on the face
// you are accessing it through, we get the normal for each face that
// connects to this vertex and interpolate these normals to get a single
// vertex normal fairly perpendicular to the mesh at the point of
// this vertex.
Point3 interpVertexNormal(Mesh* mesh, Matrix3 tm, unsigned int vxNo, BitArray& faceList)
{
	Point3 iNormal = Point3(0.0f, 0.0f, 0.0f);
	int numNormals = 0;

	for (int f = 0; f < mesh->numFaces; f++) {
		for (int fi = 0; fi < 3; fi++) {
			if (mesh->faces[f].v[fi] == vxNo) {
				Point3& fn = VectorTransform(tm, mesh->getFaceNormal(f));
				iNormal += fn;
				numNormals++;
				faceList.Set(f);
			}
		}
	}

	iNormal = iNormal / (float)numNormals;

	return Normalize(iNormal);
}


//***************************************************************************
// LightInfo encapsulates the light descriptor for standard and default lights
//***************************************************************************

LightInfo::LightInfo(INode* node, MtlBaseLib* mtls)
{
	ObjectState ostate = node->EvalWorldState(0);

	light = (LightObject*)ostate.obj;
	lightDesc = light->CreateLightDesc(node);
	bIsObscured = FALSE;

	// Process projector maps
	GetMaps getmaps(mtls);
	EnumRefs(light,getmaps);
}

LightInfo::LightInfo(DefaultLight* l)
{
	lightDesc = new DefObjLight(l);
	light = NULL;
}

LightInfo::~LightInfo()
{
	if (lightDesc) {
		delete lightDesc;
	}
}


//***************************************************************************
// Light Descriptor for the diffuse light we use
//***************************************************************************

DefObjLight::DefObjLight(DefaultLight *l) : ObjLightDesc(NULL)
{
	inode = NULL;
	ls = l->ls;
	lightToWorld = l->tm;
	worldToLight = Inverse(lightToWorld);
}


//***************************************************************************
// Update
//***************************************************************************

int DefObjLight::Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged)
{
	intensCol  = ls.intens*ls.color;
	return 1;
}


//***************************************************************************
// Update viewdependent parameters
//***************************************************************************

int DefObjLight::UpdateViewDepParams(const Matrix3& worldToCam)
{
	lightToCam = lightToWorld * worldToCam;
	camToLight = Inverse(lightToCam);
	lightPos   = lightToCam.GetRow(3);  // light pos in camera space
	return 1;
}


//***************************************************************************
// Illuminate method for default lights
// This is a special illumination method in order to evaluate diffuse color
// only, with no specular etc.
//***************************************************************************

BOOL DefObjLight::Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float &diffCoef)
{
	dir = FNormalize(lightPos-sc.P());
	color = intensCol;
	diffCoef = dot_nl = DotProd(normal,dir);
	return (dot_nl<=0.0f)?0:1;
}

static inline Point3 pabs(Point3 p) { return Point3(fabs(p.x),fabs(p.y),fabs(p.z)); }

// The ShadeContext used to shade a material a a specific point.
// This ShadeContext is setup to have full ambient light and no other
// lights until you call SetLight(). This will cause the ambient light to
// go black.
SContext::SContext()
{
	mode = SCMODE_NORMAL;
	doMaps = TRUE;
	filterMaps = TRUE;
	shadow = FALSE;
	backFace = FALSE;
	ambientLight = Color(1.0f, 1.0f, 1.0f);
	mtlNum = 0;

	nLights = 0;
}

SContext::~SContext()
{
	ClearLights();
}


// When the mesh and face number is specified we calculate 
// and store the vertex normals
void SContext::CalcNormals()
{
	RVertex* rv[3];
	Face* f = &mesh->faces[faceNum];
	DWORD smGroup = f->smGroup;
	int numNormals;

	// Get the vertex normals
	for (int i = 0; i < 3; i++) {
		rv[i] = mesh->getRVertPtr(f->getVert(i));

		// Is normal specified
		// SPCIFIED is not currently used, but may be used in future versions.
		if (rv[i]->rFlags & SPECIFIED_NORMAL) {
			vxNormals[i] = rv[i]->rn.getNormal();
		}
		// If normal is not specified it's only available if the face belongs
		// to a smoothing group
		else if ((numNormals = rv[i]->rFlags & NORCT_MASK) && smGroup) {
			// If there is only one vertex is found in the rn member.
			if (numNormals == 1) {
				vxNormals[i] = rv[i]->rn.getNormal();
			}
			else {
				// If two or more vertices are there you need to step through them
				// and find the vertex with the same smoothing group as the current face.
				// You will find multiple normals in the ern member.
				for (int j = 0; j < numNormals; j++) {
					if (rv[i]->ern[j].getSmGroup() & smGroup) {
						vxNormals[i] = rv[i]->ern[j].getNormal();
					}
				}
			}
		}
		else {
			vxNormals[i] = mesh->getFaceNormal(faceNum);
		}
	}
	vxNormals[0] = Normalize(VectorTransform(tmAfterWSM, vxNormals[0]));
	vxNormals[1] = Normalize(VectorTransform(tmAfterWSM, vxNormals[1]));
	vxNormals[2] = Normalize(VectorTransform(tmAfterWSM, vxNormals[2]));
}

void SContext::SetBaryCoord(Point3 bary)
{
	baryCoord = bary;
}

int SContext::ProjType()
	{
	return bDiffuseOnly ? PROJ_PARALLEL : PROJ_PERSPECTIVE;
	}

void SContext::SetNodeAndTime(INode* n, TimeValue tv)
{
	node = n;
	t = tv;
	tmAfterWSM = node->GetObjTMAfterWSM(t,NULL);
}

void SContext::SetFaceNum(int f)
{
	faceNum = f;
}

void SContext::SetMtlNum(int mNo)
{
	mtlNum = mNo;
}

void SContext::SetViewPoint(Point3 vp)
{
	viewPoint = vp;
}

void SContext::SetTargetPoint(Point3 tp)
{
	targetPt = tp;
}

void SContext::SetViewDir(Point3 vd)
{
	viewDir = vd;
}

void SContext::SetMesh(Mesh * m)
{
	mesh = m;
}

void SContext::AddLight(LightInfo* li)
{
	lightTab.Append(1, &li);
}

void SContext::ClearLights()
{
	for (int i=0; i<lightTab.Count(); i++) {
		delete lightTab[i];
	}
	lightTab.ZeroCount();
	lightTab.Shrink();
	allLights.ZeroCount();
	allLights.Shrink();

	nLights = 0;
}

void SContext::UpdateLights()
{
	for (int i=0; i<lightTab.Count(); i++) {
		((LightInfo*)lightTab[i])->lightDesc->Update(t, rc, NULL, FALSE, TRUE);
		((LightInfo*)lightTab[i])->lightDesc->UpdateViewDepParams(Matrix3(1));
	}

	nLights = lightTab.Count();
}

void SContext::SetAmbientLight(Color c)
{
	ambientLight = c;
}

void SContext::CalcBoundObj()
{
	if (!mesh)
		return;

	boundingObj.Init();

	// Include each vertex in the bounding box
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Face* f = &(mesh->faces[nf]);

		boundingObj += mesh->getVert(f->getVert(0));
		boundingObj += mesh->getVert(f->getVert(1));
		boundingObj += mesh->getVert(f->getVert(2));
	}
}

// Return current time
TimeValue SContext::CurTime()
{
	return t;
}

int SContext::NodeID()
{
	return -1;
}

INode* SContext::Node()
{
	return node;
}

Point3 SContext::BarycentricCoords()
{
	return baryCoord;
}

int SContext::FaceNumber()
{
	return faceNum;
}


// Interpolated normal
Point3 SContext::Normal()
{
	return Normalize(baryCoord.x*vxNormals[0] + baryCoord.y*vxNormals[1] + baryCoord.z*vxNormals[2]);
}

// Geometric normal (face normal)
Point3 SContext::GNormal(void)
{
	// The face normals are already in camera space
	return VectorTransform(tmAfterWSM, mesh->getFaceNormal(faceNum));
}

// Return a Light descriptor
LightDesc *SContext::Light(int lightNo)
{
	return ((LightInfo*)lightTab[lightNo])->lightDesc;
}

// Return reflection vector at this point.
// We do it like this to avoid specular color to show up.
Point3 SContext::ReflectVector(void)
	{
	Point3 nrm;
	if (bDiffuseOnly) {
		// If we aren't using scene lights, then we fake a light
		// just above the render point, therefore we need to remove
		// all specularity (otherwise it's all gonna be white)
		// We can do this by pointing the reflection vector away
		// from the viewpoint
		nrm = -Normal();
		}
	else {
		Point3 N = Normal();
		float VN = -DotProd(viewDir,N);
		nrm = Normalize(2.0f*VN*N + viewDir);
		}

	return nrm;
	}

// Foley & vanDam: Computer Graphics: Principles and Practice, 
//     2nd Ed. pp 756ff.
Point3 SContext::RefractVector(float ior)
{
	Point3 N = Normal();
	float VN,nur,k;
	VN = DotProd(-viewDir,N);
	if (backFace) nur = ior;
	else nur = (ior!=0.0f) ? 1.0f/ior: 1.0f;
	k = 1.0f-nur*nur*(1.0f-VN*VN);
	if (k<=0.0f) {
		// Total internal reflection: 
		return ReflectVector();
	}
	else {
		return (nur*VN-(float)sqrt(k))*N + nur*viewDir;
	}
}

Point3 SContext::CamPos(void)
{
	return viewPoint;
}

// Screen coordinate beeing rendered
IPoint2 SContext::ScreenCoord(void)
{
	return IPoint2(0,0);
}

// Background color
void SContext::GetBGColor(class Color &bgCol,class Color &transp,int fogBG)
{
	bgCol = Color(0.0f, 0.0f, 0.0f);
	transp = Color(0.0f, 0.0f, 0.0f);
}

// Transforms the specified point from internal camera space to the specified space.
Point3 SContext::PointTo(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return Inverse(tmAfterWSM) * p;
	}

	return p;
}

// Transforms the specified point from the specified coordinate system
// to internal camera space.
Point3 SContext::PointFrom(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return tmAfterWSM * p;
	}
	return p;
}

// Transform the vector from internal camera space to the specified space.
Point3 SContext::VectorTo(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return VectorTransform(Inverse(tmAfterWSM), p);
	}
	return p;
}

// Transform the vector from the specified space to internal camera space.
Point3 SContext::VectorFrom(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return VectorTransform(tmAfterWSM, p);
	}
	return p;
}

// This method returns the unit view vector, from the camera towards P,
// in camera space.
Point3 SContext::V(void)
{
	return viewDir;
}

// Returns the point to be shaded in camera space.
Point3 SContext::P(void)
{
	return targetPt;
}

// This returns the derivative of P, relative to the pixel.
// This gives the renderer or shader information about how fast the position
// is changing relative to the screen.
// TBD

#define DFACT .1f

Point3 SContext::DP(void)
{
	float d = (1.0f+DFACT)*(RayDiam())/(DFACT+(float)fabs(DotProd(Normal(),viewDir)));
	return Point3(d,d,d);
}

// Retrieves the point relative to the screen where the lower left
// corner is 0,0 and the upper right corner is 1,1.
void SContext::ScreenUV(class Point2 &uv,class Point2 &duv)
{
	Point2 p;

	uv.x = .5f;
	uv.y = .5f;
	duv.x = 1.0f;
	duv.y = 1.0f;
}

// Bounding box in object coords
Box3 SContext::ObjectBox(void)
{
	return boundingObj;
}

// Returns the point to be shaded relative to the object box where each
// component is in the range of -1 to +1.
Point3 SContext::PObjRelBox(void)
{
	Point3 q;
	Point3 p = PObj();
	Box3 b = ObjectBox(); 
	q.x = 2.0f*(p.x-b.pmin.x)/(b.pmax.x-b.pmin.x) - 1.0f;
	q.y = 2.0f*(p.y-b.pmin.y)/(b.pmax.y-b.pmin.y) - 1.0f;
	q.z = 2.0f*(p.z-b.pmin.z)/(b.pmax.z-b.pmin.z) - 1.0f;
	return q;
}

// Returns the derivative of PObjRelBox().
// This is the derivative of the point relative to the object box where
// each component is in the range of -1 to +1.
Point3 SContext::DPObjRelBox(void)
{
	Box3 b = ObjectBox(); 
	Point3 d = DPObj();
	d.x *= 2.0f/(b.pmax.x-b.pmin.x); 
	d.y *= 2.0f/(b.pmax.y-b.pmin.y); 
	d.z *= 2.0f/(b.pmax.z-b.pmin.z); 
	return d;
}

// Returns the point to be shaded in object coordinates.
Point3 SContext::PObj(void)
{
	return Inverse(tmAfterWSM) * P();
}

// Returns the derivative of PObj(), relative to the pixel.
// TBD
Point3 SContext::DPObj(void)
{
	Point3 d = DP();
	return VectorTransform(Inverse(tmAfterWSM),d);
}

// Returns the UVW coordinates for the point.
Point3 SContext::UVW(int chan)
{
	Point3 uvw = Point3(0.0f, 0.0f, 0.0f);
	UVVert tverts[3];

	if (mesh->mapSupport(chan)) {
		TVFace* tvf = &mesh->mapFaces(chan)[faceNum];
		tverts[0] = mesh->mapVerts(chan)[tvf->getTVert(0)];
		tverts[1] = mesh->mapVerts(chan)[tvf->getTVert(1)];
		tverts[2] = mesh->mapVerts(chan)[tvf->getTVert(2)];

		uvw = baryCoord.x*tverts[0] +
				baryCoord.y*tverts[1] +
				baryCoord.z*tverts[2];
	}

	return uvw;
}

static Point3 basic_tva[3] = { Point3(0.0,0.0,0.0),Point3(1.0,0.0,0.0),Point3(1.0,1.0,0.0)};
static Point3 basic_tvb[3] = { Point3(1.0,1.0,0.0),Point3(0.0,1.0,0.0),Point3(0.0,0.0,0.0)};
static int nextpt[3] = {1,2,0};
static int prevpt[3] = {2,0,1};

void MakeFaceUV(Face *f, UVVert *tv)
{
	int na,nhid,i;
	Point3 *basetv;
	/* make the invisible edge be 2->0 */
	nhid = 2;
	if (!(f->flags&EDGE_A))  nhid=0; 
	else if (!(f->flags&EDGE_B)) nhid = 1;
	else if (!(f->flags&EDGE_C)) nhid = 2;
	na = 2-nhid;
	basetv = (f->v[prevpt[nhid]]<f->v[nhid]) ? basic_tva : basic_tvb;
	for (i=0; i<3; i++) {
		tv[i] = basetv[na]; 
		na = nextpt[na];
	}
}

void SContext::getTVerts(int chan) 
{
	if (chan!=0&&(node->GetMtl()->Requirements(mtlNum)&MTLREQ_FACEMAP)) {
		MakeFaceUV(&mesh->faces[faceNum],tv[0]);
	}
	else {
		Mesh* m = mesh;
		if (!m->mapSupport(chan))
			return;

		UVVert* tverts = m->mapVerts(chan);
		TVFace* tvf = &m->mapFaces(chan)[faceNum];
		tv[chan][0] = tverts[tvf->t[0]];
		tv[chan][1] = tverts[tvf->t[1]];
		tv[chan][2] = tverts[tvf->t[2]];
	}
}

void SContext::getObjVerts()
{
	// TBD
}

// Returns the UVW derivatives for the point.
Point3 SContext::DUVW(int chan)
{
	getTVerts(chan);
	calc_size_ratio();
	return 0.5f*(pabs(tv[chan][1]-tv[chan][0])+pabs(tv[chan][2]-tv[chan][0]))*ratio;
}

// This returns the bump basis vectors for UVW in camera space.
void SContext::DPdUVW(Point3 dP[3], int chan)
{
	getTVerts(chan);
	calc_size_ratio();
	Point3 bv[3];
	getObjVerts();
	ComputeBumpVectors(tv[chan], obpos, bv);
	bumpv[chan][0] = Normalize(bv[0]);
	bumpv[chan][1] = Normalize(bv[1]);
	bumpv[chan][2] = Normalize(bv[2]);
	dP[0] = bumpv[chan][0];
	dP[1] = bumpv[chan][1];
	dP[2] = bumpv[chan][2];
}

//--------------------------------------------------------------------
// Computes the average curvature per unit surface distance in the face
//--------------------------------------------------------------------
float ComputeFaceCurvature(Point3 *n, Point3 *v, Point3 bc)
{
	Point3 nc = (n[0]+n[1]+n[2])/3.0f;
	Point3 dn0 = n[0]-nc;
	Point3 dn1 = n[1]-nc;
	Point3 dn2 = n[2]-nc;
	Point3 c = (v[0] + v[1] + v[2]) /3.0f;
	Point3 v0 = v[0]-c;
	Point3 v1 = v[1]-c;
	Point3 v2 = v[2]-c;
	float d0 = DotProd(dn0,v0)/LengthSquared(v0);
	float d1 = DotProd(dn1,v1)/LengthSquared(v1);
	float d2 = DotProd(dn2,v2)/LengthSquared(v2);
	float ad0 = (float)fabs(d0);
	float ad1 = (float)fabs(d1);
	float ad2 = (float)fabs(d2);
	return (ad0>ad1)? (ad0>ad2?d0:d2): ad1>ad2?d1:d2;
}

static inline float size_meas(Point3 a, Point3 b, Point3 c)
{
	double d  = fabs(b.x-a.x);
	d += fabs(b.y-a.y);
	d += fabs(b.z-a.z);
	d += fabs(c.x-a.x);
	d += fabs(c.y-a.y);
	d += fabs(c.z-a.z);
	return float(d/6.0);
}

// This is an estimate of how fast the normal is varying.
// For example if you are doing enviornment mapping this value may be used to
// determine how big an area of the environment to sample.
// If the normal is changing very fast a large area must be sampled otherwise
// you'll get aliasing.  This is an estimate of dN/dsx, dN/dsy put into a
// single value.
// Signed curvature:
float SContext::Curve() {
	Point3 tpos[3];
	Face &f = mesh->faces[faceNum];
	tpos[0] = mesh->verts[f.v[0]];
	tpos[1] = mesh->verts[f.v[1]];
	tpos[2] = mesh->verts[f.v[2]];
	float d = ComputeFaceCurvature(vxNormals,tpos,baryCoord);
	curve = d*RayDiam();
	return backFace?-curve:curve;
}

#define SZFACT 1.5f

// Approximate how big fragment is relative to whole face.
void SContext::calc_size_ratio()
{
	Point3 dp = DP();
	Point3 cv[3];
	cv[0] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[0]);
	cv[1] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[1]);
	cv[2] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[2]);
	float d = size_meas(cv[0], cv[1], cv[2]);
	ratio = SZFACT*(float)fabs(dp.x)/d;
}

int	SContext::InMtlEditor()
{
	return FALSE;
}

void SContext::SetView(Point3 v)
{
	viewPoint = v;
}

void SContext::SetDiffuseOnly(bool d)
	{
	bDiffuseOnly = d;
	}

/****************************************************************************
// Shadow buffer
 ***************************************************************************/

ShadowBuffer* RContext::NewShadowBuffer() const
{
	return NULL;
}

ShadowQuadTree* RContext::NewShadowQuadTree() const
{
	return NULL;
}

Color	RContext::GlobalLightLevel() const
{
	return Color(1,1,1); // TBD
}


/****************************************************************************
// Scan the scene for all lights and add them for the ShadeContext's lightTab
 ***************************************************************************/

void sceneLightEnum(INode* recvNode, INode* node, SContext* sc, MtlBaseLib* mtls, int* numLights)
{
	// For each child of this node, we recurse into ourselves 
	// until no more children are found.
	for (int c = 0; c < node->NumberOfChildren(); c++) {
		sceneLightEnum(recvNode, node->GetChildNode(c), sc, mtls, numLights);
	}

	// Get the ObjectState.
	// The ObjectState is the structure that flows up the pipeline.
	// It contains a matrix, a material index, some flags for channels,
	// and a pointer to the object in the pipeline.
	ObjectState ostate = node->EvalWorldState(0);
	if (ostate.obj==NULL) 
		return;

	// Examine the superclass ID in order to figure out what kind
	// of object we are dealing with.
	if (ostate.obj->SuperClassID() == LIGHT_CLASS_ID) {
		// Get the light object from the ObjectState
		LightObject *light = (LightObject*)ostate.obj;

		(*numLights)++;

		// Is this light turned on?
		if (light->GetUseLight()) {
			bool bUseLight = true;

			NameTab* nt = light->GetExclList();
			if (nt && nt->TestFlag(NT_AFFECT_ILLUM)) {
				if (light->Include()) {
					// Inclusion list
					if (nt->FindName(recvNode->GetName()) == -1) {
						bUseLight = false;
						}
					}
				else {
					if (nt->FindName(recvNode->GetName()) != -1) {
						bUseLight = false;
						}
					}
				}

			// Create a RenderLight and append it to our list of lights
			if (bUseLight) {
				LightInfo* li = new LightInfo(node, mtls);
				sc->lightTab.Append(1, &li);
				}
			}
		}
	}

void AddSceneLights(INode* node, SContext* sc, MtlBaseLib* mtls, int* numLights)
{
	INode* scene = GetCOREInterface()->GetRootNode();
	for (int i=0; i<scene->NumberOfChildren(); i++) {
		sceneLightEnum(node, scene->GetChildNode(i), sc, mtls, numLights);
	}
}


/****************************************************************************
// Material enumerator functions
// Before evaluating a material we need to load the maps used by the material
// and then tell the material to prepare for evaluation.
 ***************************************************************************/

class CheckFileNames: public NameEnumCallback {
	public:
		NameTab* missingMaps;
		BitmapInfo bi;
		CheckFileNames(NameTab* n);
		void RecordName(TCHAR *name);
};

//***************************************************************************
// Class to manage names of missing maps
//***************************************************************************

CheckFileNames::CheckFileNames(NameTab* n)
{
	missingMaps = n;
}

//***************************************************************************
// Add a name to the list if it's not already there
//***************************************************************************

void CheckFileNames::RecordName(TCHAR *name)
{ 
	if (name) {
		if (name[0]!=0) {
			if (missingMaps->FindName(name)<0) {
			    missingMaps->AddName(name);
			}
		}
	}
}

class MtlEnum {
	public:
		virtual int proc(MtlBase *m, int subMtlNum) = 0;
};

class MapLoadEnum:public MtlEnum {
	public:
		TimeValue t;

	   	MapLoadEnum(TimeValue time);
		virtual int proc(MtlBase *m, int subMtlNum);
};

//***************************************************************************
// Constructor of map loader
//***************************************************************************

MapLoadEnum::MapLoadEnum(TimeValue time)
{ 
	t = time; 
}

//***************************************************************************
// Map loader enum proc
//***************************************************************************

int MapLoadEnum::proc(MtlBase *m, int subMtlNum)
{
	Texmap *tm = (Texmap *)m;
	tm->LoadMapFiles(t);
	return 1;
}


int EnumMaps(MtlBase *mb, int subMtl,  MtlEnum &tenum)
{
	if (IsTex(mb)) {
		if (!tenum.proc(mb,subMtl)) {
			return 0;
		}
	}
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) {
			int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
			if (mb->SubTexmapOn(i)) {
				if (!EnumMaps(st,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) {
				int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
				if (!EnumMaps(sm,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	return 1;
}

void EnumRefs(ReferenceMaker *rm, RefEnumProc &proc)
{
	proc.proc(rm);
	for (int i=0; i<rm->NumRefs(); i++) {
		ReferenceMaker *srm = rm->GetReference(i);
		if (srm) {
			EnumRefs(srm,proc);		
		}
	}
}

//***************************************************************************
// Constructor of map enumerator
//***************************************************************************

GetMaps::GetMaps(MtlBaseLib *mbl)
{
	mlib = mbl;
}

//***************************************************************************
// Implementation of the map enumerator
//***************************************************************************

void GetMaps::proc(ReferenceMaker *rm)
{
	if (IsTex((MtlBase*)rm)) {
		mlib->AddMtl((MtlBase *)rm);
	}
}


int LoadMapFiles(INode* node, SContext* sc, MtlBaseLib& mtls, TimeValue t)
{
	NameTab mapFiles;
	CheckFileNames checkNames(&mapFiles);

	node->EnumAuxFiles(checkNames, FILE_ENUM_MISSING_ONLY | FILE_ENUM_1STSUB_MISSING);

	// Check the lights
	for (int i = 0; i < sc->lightTab.Count(); i++) {
		if (((LightInfo*)sc->lightTab[i])->light != NULL) {
			((LightInfo*)sc->lightTab[i])->light->EnumAuxFiles(checkNames, 
				FILE_ENUM_MISSING_ONLY | FILE_ENUM_1STSUB_MISSING);
		}
	}

	if (mapFiles.Count()) {
		// Error! Missing maps.
		// not sure how to handle this so we gladly continue.
			
		//if (MessageBox(hWnd, "There are missing maps.\nDo you want to render anyway?", "Warning!", MB_YESNO) != IDYES) {
		//	return 0;
		//}
	}

	// Load the maps
	MapLoadEnum mapload(t);
	for (i=0; i<mtls.Count(); i++) {
		EnumMaps(mtls[i],-1, mapload);
	}

	return 1;
}

//***************************************************************************
// This material is used when a node does not have a material assigned.
//***************************************************************************

DumMtl::DumMtl(Color c)
{ 
	diff = c; spec = Color(DUMSPEC,DUMSPEC,DUMSPEC); 
	phongexp = (float)pow(2.0, DUMSHINE*10.0);
}

void DumMtl::Update(TimeValue t, Interval& valid)
{
}

void DumMtl::Reset()
{
}

Interval DumMtl::Validity(TimeValue t)
{
	return FOREVER;
}

ParamDlg* DumMtl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
{
	return NULL;
}

Color DumMtl::GetAmbient(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetDiffuse(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetSpecular(int mtlNum, BOOL backFace)
{
	return spec;
}

float DumMtl::GetShininess(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetShinStr(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetXParency(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

void DumMtl::SetAmbient(Color c, TimeValue t)
{
}		

void DumMtl::SetDiffuse(Color c, TimeValue t)
{
}

void DumMtl::SetSpecular(Color c, TimeValue t)
{
}

void DumMtl::SetShininess(float v, TimeValue t)
{
}

Class_ID DumMtl::ClassID()
{
	return DUMMTL_CLASS_ID;
}

void DumMtl::DeleteThis()
{
	delete this;
}

RefResult DumMtl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message)
{
	return REF_SUCCEED;
}

//***************************************************************************
// Shade method for the dummy material
// If a node does not have a material assigned we create
// a dummy material that inherits the wireframe color of
// the node
//***************************************************************************

void DumMtl::Shade(ShadeContext& sc)
{
	Color lightCol;
	Color diffwk(0.0f,0.0f,0.0f);
	Color specwk(0.0f,0.0f,0.0f);
	Color ambwk(0.0f,0.0f,0.0f);
	Point3 N = sc.Normal();
	Point3	R = sc.ReflectVector();
	LightDesc *l;
	for (int i = 0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (!l->Illuminate(sc, N, lightCol, L, NL, diffCoef))
			continue;

		if (l->ambientOnly) {
			ambwk += lightCol;
			continue;
			}
		// diffuse
		if (l->affectDiffuse)
			diffwk += diffCoef*lightCol;
		// specular
		if (l->affectSpecular) {
			float c = DotProd(L,R);
			if (c>0.0f) {
				c = (float)pow((double)c, (double)phongexp); 
				specwk += c*lightCol*NL;   // multiply by NL to SOFTEN 
			}
		}
	}
	sc.out.t = Color(0.0f,0.0f,0.0f);
	sc.out.c = (.3f*sc.ambientLight + diffwk)*diff + specwk*spec+ambwk;		
}

void SContext::CalcShadow(MeshInstanceTab& ilist)
	{
	int i;
	for (i=0; i<allLights.Count(); i++) {
		allLights[i]->bIsObscured = FALSE;
		// Calculate the distance from the vertex to the light position
		allLights[i]->distanceToShadedPoint = Length(allLights[i]->lightDesc->LightPosition()-targetPt);
		}

	if (node->RcvShadows()) {
		for (i=0; i<ilist.Count(); i++) {
			TurnOffObscuredLights(ilist[i]);
			}
		}

	lightTab.ZeroCount();
	for (i=0; i<allLights.Count(); i++) {
		if (!allLights[i]->bIsObscured) {
			lightTab.Append(1, &(allLights[i]), 5);
			}
		}

	nLights = lightTab.Count();
	}

#define LSQ(v) (v.x*v.x + v.y*v.y + v.z*v.z)

void SContext::TurnOffObscuredLights(MeshInstance* inst)
	{
	Mesh*		mesh = inst->mesh;
	LightDesc*	ld;
	Ray			r;
	Point3		pos;
	HitInfo		hitInfo;

	if (inst->node == node)
		return;

	if (inst->node && !inst->node->CastShadows())
		return;

	hitInfo.instance = inst;

	int numLights = allLights.Count();
	for (int l=0; l<numLights; l++) {
		ld = ((LightInfo*)allLights[l])->lightDesc;

		if (allLights[l]->light) {	// CCJ 11/13/99 - This is NULL for default lights
			NameTab* nt = allLights[l]->light->GetExclList();
			if (nt && nt->TestFlag(NT_AFFECT_SHADOWCAST)) {
				if (allLights[l]->light->Include()) {
					// If it's not found in the inclusion list, it's out
					if (nt->FindName(node->GetName()) == -1) {
						allLights[l]->bIsObscured = FALSE;
						continue;
						}
					}
				else {
					// If it's found in the exclusion list, it's out
					if (nt->FindName(node->GetName()) != -1) {
						allLights[l]->bIsObscured = FALSE;
						continue;
						}
					}
				}
			}

		if (!allLights[l]->bIsObscured) {
			if (allLights[l]->light && allLights[l]->light->GetShadowMethod()!=LIGHTSHADOW_NONE) {

				pos = ld->LightPosition();
				r.p = pos;
				r.dir = targetPt-pos;
				Normalize(r.dir);

				// Bounding sphere test
				Point3 pc = inst->center - r.p;
				float v = DotProd(pc,r.dir);
				if ((inst->radsq - LSQ(pc) + v*v) >= 0.0f) {
					// Bounding box test
					if (rayBoundHit(&r, inst->boundingBox)) {
						if (intersectMesh(&r, hitInfo)) {
							if (Length(hitInfo.hitPos-r.p) < allLights[l]->distanceToShadedPoint) {
								allLights[l]->bIsObscured = TRUE;
								}
							}
						}
					}
				}
			}
		}
	}





//***************************************************************************
// Determine if the ray hits the bounding box of the node.
// This is done for trivial hit rejection.
//***************************************************************************

BOOL rayBoundHit(Ray* ray, Box3 boundingBox)
{
	float t, tmin, tmax;
	float dir, pos;

	tmax = BIGFLOAT;
	tmin = 0.0f;

	dir = ray->dir.x;
	pos = ray->p.x;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.x - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.x - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.x - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.x - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.x || pos > boundingBox.pmax.x)
		return FALSE;

	dir = ray->dir.y;
	pos = ray->p.y;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.y - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.y - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.y - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.y - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.y || pos > boundingBox.pmax.y)
		return FALSE;

	dir = ray->dir.z;
	pos = ray->p.z;

	if (dir < 0.0f) {
		t = (boundingBox.pmin.z - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmax.z - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (dir > 0.0f) {
		t = (boundingBox.pmax.z - pos) / dir;
		if (t < tmin)
			return FALSE;
		if (t <= tmax)
			tmax = t;
		t = (boundingBox.pmin.z - pos) / dir;
		if (t >= tmin) {
			if (t > tmax)
				return FALSE;
			tmin = t;
		}
	} else if (pos < boundingBox.pmin.z || pos > boundingBox.pmax.z)
		return FALSE;

	return TRUE;
}


//***************************************************************************
// Intersect a ray with a mesh
//***************************************************************************

// BOOL intersectMesh(Ray* ray, RenderNode* rn, int& faceNo, Point3& baryCoord, Point3& normal, Point3& hitPos)
BOOL intersectMesh(Ray* ray, HitInfo& hitInfo)
{
	Point3 tri[3];
	BOOL hit = FALSE;
	float dist = BIGFLOAT;
	Mesh* mesh = hitInfo.instance->mesh;

	// For each face in the mesh...
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Face* f = &(mesh->faces[nf]);

		/*
		// We have a pre-calculated bounding sphere for each face.
		// here we can do a trivial hit rejection to see if we can
		// discard the face.

		BoundingSphere* bs = hitInfo.instance->faceBoundSpheres[nf];
		Point3 pc = bs->bsCenter - ray->p;
		float v = DotProd(pc,ray->dir);
		if (bs->bsRadSq - LSQ(pc) + v*v < 0.0f) {
			// No point proceeding with this face...
			continue;
		}
		*/

		// Get the vertices
		if (!hitInfo.instance->negParity) {
			tri[0] = mesh->getVert(f->getVert(0));
			tri[1] = mesh->getVert(f->getVert(1));
			tri[2] = mesh->getVert(f->getVert(2));
		}
		else {
			// Scaling is negative, get the vertives
			// counter clockwise.
			tri[0] = mesh->getVert(f->getVert(2));
			tri[1] = mesh->getVert(f->getVert(1));
			tri[2] = mesh->getVert(f->getVert(0));
		}

		/* TBD: This slowed things down in some test scenes, but might work better
		// for real life scenes..
		// Do hit rejection on the triangle bouding box
		// to get a few extra triangles out of the way
		Box3 triBound;
		triBound.Init();

		triBound += tri[0];
		triBound += tri[1];
		triBound += tri[2];

		// If we don't hit the bounding box we don't need to hit test the
		// triangle
		if (!rayBoundHit(ray, triBound)) {
			continue;
		}
		*/

		// Intersect ray with triangle
		Point3 bc;
		Point3 n;
		Point3 hp;
		if (intersectTri(ray, tri, bc, n, hp)) {
			float dl = Length(hp);
			if (dl < dist) {
				hitInfo.hitPos = hp;
				dist = dl;
				hit = TRUE;
			}
		}
	}

	return hit;
}


//***************************************************************************
// Intersect a ray with a triangle.
//***************************************************************************

BOOL intersectTri(Ray* ray, Point3* tri, Point3& baryCoord,
				  Point3& normal, Point3& hitPos)
{
	Plane p;

	CompPlaneEqn(p, tri[0], tri[1], tri[2]);

	Point3 Pn = Point3(p[0], p[1], p[2]);
	Point3 Rd = ray->dir;
	Point3 R0 = ray->p;

	float Vd = Pn.x * Rd.x + Pn.y * Rd.y + Pn.z * Rd.z;
	if (Vd >= 0.0f)
		return FALSE;

	float V0 = -(Pn.x * R0.x + Pn.y * R0.y + Pn.z * R0.z + p[3]);
	float t = V0 / Vd;

	if (t < 0.0f)
		return FALSE;

	// Intersection with plane.
	Point3 Pi = Point3(R0.x+Rd.x*t, R0.y+Rd.y*t, R0.z+Rd.z*t);

	// Get the barycentric coordinates of the hitPoint.
	// If any of the components are > 1.0 the hit is outside the triangle
	baryCoord = CalcBaryCoords(tri[0], tri[1], tri[2], Pi);

	if (baryCoord.x >= 0.0f && baryCoord.x <= 1.0f) {
		if (baryCoord.y >= 0.0f && baryCoord.y <= 1.0f) {
			if (baryCoord.z >= 0.0f && baryCoord.z <= 1.0f) {
				normal = Point3(0.0f,0.0f,1.0f); // Not used!
				hitPos = Pi; // Intersection point (the point we render)
				return TRUE;
			}
		}
	}

	return FALSE;
}


//***************************************************************************
// Compute the plane equation for the three points making up the plane.
//***************************************************************************

void CompPlaneEqn(Plane plane, const Point3& p0,
				  const Point3& p1, const Point3& p2)
{
	Point3 e1 = p1-p0;
	Point3 e2 = p2-p0;
	Point3 p = CrossProd(e1,e2);
	p = Normalize(p);
	plane[0] = p.x;
	plane[1] = p.y;
	plane[2] = p.z;
	plane[3] = -DotProd(p0,p);
}

//***************************************************************************
// Determine is the node has negative scaling.
// This is used for mirrored objects for example. They have a negative scale
// so when calculating the normal we take the vertices counter clockwise.
// If we don't compensate for this the objects will be 'inverted'
//***************************************************************************

BOOL TMNegParity(Matrix3 &m)
{
    return (DotProd(CrossProd(m.GetRow(0),m.GetRow(1)),m.GetRow(2))<0.0)?1:0;
}


//***************************************************************************
// Calculate the determinant
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

static float det2x2( float a, float b, float c, float d )
{
    float ans;
    ans = a * d - b * c;
    return ans;
}

//***************************************************************************
// 
// float = det3x3(  a1, a2, a3, b1, b2, b3, c1, c2, c3 )
//   
// calculate the determinant of a 3x3 matrix
// in the form
//
//     | a1,  b1,  c1 |
//     | a2,  b2,  c2 |
//     | a3,  b3,  c3 |
//
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

static float det3x3( Point3 a,Point3 b,Point3 c )

{
   float a1, a2, a3, b1, b2, b3, c1, c2, c3;    
   float ans;
   
   a1 = a.x ; a2 = a.y ; a3 = a.z ;   
   b1 = b.x ; b2 = b.y ; b3 = b.z ;   
   c1 = c.x ; c2 = c.y ; c3 = c.z ;   

   ans = a1 * det2x2( b2, b3, c2, c3 )
       - b1 * det2x2( a2, a3, c2, c3 )
       + c1 * det2x2( a2, a3, b2, b3 );
   return ans;
}


//***************************************************************************
// Given three points in space forming a triangle (p0,p1,p2), 
// and a fourth point in the plane of that triangle, returns the
// barycentric coords of that point relative to the triangle.
// Thanks to Ruediger Hoefert, Absolute Software
//***************************************************************************

Point3 CalcBaryCoords(Point3 p0, Point3 p1, Point3 p2, Point3 p)
{ 
	Point3 tpos[3];
	Point3 cpos;
	Point3 bary;

	tpos[0] = p0;
	tpos[1] = p1;
	tpos[2] = p2;
	cpos = p;

 /*
 
 S.304 Curves+Surfaces for Computer aided design:

     u + v + w = 1

         area(p,b,c)    area(a,p,c)   area(a,b,p)
 u = -----------, v = -----------, w = -----------, 
    area(a,b,c)    area(a,b,c)   area(a,b,c)
 
   ax  bx  cx
   
 area(a,b,c) = 0.5 * ay  by  cy
   
   az  bz  cz
    
   
 */

	float area_abc, area_pbc, area_apc, area_abp; 
	
	area_abc= det3x3(tpos[0],tpos[1],tpos[2]);
	area_abc=1.0f/(area_abc == 0 ? 0.001f : area_abc);
	
	area_pbc =det3x3(cpos   ,tpos[1],tpos[2]); 
	area_apc =det3x3(tpos[0],cpos   ,tpos[2]);
	area_abp =det3x3(tpos[0],tpos[1],cpos   );
	
	bary.x = area_pbc *area_abc ;
	bary.y = area_apc *area_abc ;
	bary.z = area_abp *area_abc ;
	
	return bary;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\AVCMod.cpp ===
/**********************************************************************
 *<
	FILE:			AVCMod.cpp
	DESCRIPTION:	Vertex Color Modifier
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, June 02, 1997

	This modifier is the keeper of vertex colors generated by the
	"Apply Vertex Colors" Utility plug-in.

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/

#include "ApplyVC.h"

//--- ClassDescriptor and class vars ---------------------------------

IObjParam*			ApplyVCMod::ip =	NULL;

class AVCClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 0; }
	void *			Create(BOOL loading = FALSE) { return new ApplyVCMod(!loading);}
	const TCHAR *	ClassName() { return GetString(IDS_AVCM_CNAME); }
	SClass_ID		SuperClassID() { return OSM_CLASS_ID; }
	Class_ID		ClassID() { return APPLYVC_MOD_CLASS_ID; }
	const TCHAR* 	Category() { return _T("");}
};

static AVCClassDesc vcmodDesc;
extern ClassDesc* GetApplyVCModDesc() {return &vcmodDesc;}


//--- ApplyVCMod methods -------------------------------


ApplyVCMod::ApplyVCMod(BOOL create)
{	
	iValid.SetEmpty();
}

void ApplyVCMod::DeleteThis()
{
	delete this;
}

void ApplyVCMod::GetClassName(TSTR& s)
{
	s= GetString(IDS_AVCM_CNAME);
}

Class_ID ApplyVCMod::ClassID()
{
	return APPLYVC_MOD_CLASS_ID;
}

TCHAR* ApplyVCMod::GetObjectName()
{
	return GetString(IDS_AVCM_ONAME);
}

CreateMouseCallBack* ApplyVCMod::GetCreateMouseCallBack()
{
	return NULL;
}

// Prevent us from being copied in TrackView/ModifierStack.
BOOL ApplyVCMod::CanCopyAnim()
{
	return FALSE;
}

ChannelMask ApplyVCMod::ChannelsUsed()
{
	return VERTCOLOR_CHANNEL | TOPO_CHANNEL;
}

ChannelMask ApplyVCMod::ChannelsChanged()
{
	return VERTCOLOR_CHANNEL | TOPO_CHANNEL;
}

BOOL ApplyVCMod::DependOnTopology(ModContext &mc)
{
	return TRUE;
}

Class_ID ApplyVCMod::InputType()
{
	return triObjectClassID;
}

int ApplyVCMod::NumRefs()
{
	return 0;
}

int ApplyVCMod::NumSubs()
{
	return 0;
}

#define MIX_COLOR_CHUNK		0x110
#define VX_COLOR_CHUNK		0x120

IOResult ApplyVCMod::Load(ILoad *iload)
{
	IOResult res;
	ULONG nb;

	ResetColTab();

	Modifier::Load(iload);	
	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID())  {
			case MIX_COLOR_CHUNK: {
				Color* col = new Color();
				res=iload->Read(col,sizeof(Color),&nb);
				mixedVertexColors.Append(1, &col, 25);
				break;
			}

			case VX_COLOR_CHUNK: {
				FaceColor* faceCol = new FaceColor;
				for (int j=0; j<3; j++) {
					iload->Read(&faceCol->colors[j],sizeof(Color),&nb);
				}
				faceColors.Append(1, &faceCol, 25);
				break;
			}
			default:
				break; 
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}

IOResult ApplyVCMod::Save(ISave *isave)
{
	IOResult res;
	ULONG nb;
	int i, j;

	Modifier::Save(isave);

	for (i=0; i<mixedVertexColors.Count(); i++) {
		isave->BeginChunk(MIX_COLOR_CHUNK);
		res = isave->Write(mixedVertexColors[i], sizeof(Color), &nb);
		isave->EndChunk();
	}

	for (i=0; i<faceColors.Count(); i++) {
		isave->BeginChunk(VX_COLOR_CHUNK);
		for (j=0; j<3; j++) {
			res = isave->Write(faceColors[i]->colors[j], sizeof(Color), &nb);
		}
		isave->EndChunk();
	}

	return IO_OK;
}

static BOOL CALLBACK panelDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			GetCOREInterface()->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;
		default:
			return FALSE;
	}
	return TRUE;
}	

void ApplyVCMod::BeginEditParams(IObjParam *ip, ULONG flags,Animatable *prev)
{
	this->ip = ip;

	TimeValue t = ip->GetTime();
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_BEGIN_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_ON);
	SetAFlag(A_MOD_BEING_EDITED);

	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_VCMOD_PANEL),
		panelDlgProc,
		GetString(IDS_AVCM_PANELTITLE),
		0);

	iValid.SetEmpty();
}
		
void ApplyVCMod::EndEditParams( IObjParam *ip, ULONG flags,Animatable *next )
{	
	this->ip = NULL;

	TimeValue t = ip->GetTime();
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
	ClearAFlag(A_MOD_BEING_EDITED);
 	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_END_EDIT);
	NotifyDependents(Interval(t,t), PART_ALL, REFMSG_MOD_DISPLAY_OFF);
}

Interval ApplyVCMod::LocalValidity(TimeValue t)
{	
	return iValid;
}

RefTargetHandle ApplyVCMod::Clone(RemapDir& remap) 
{
	ApplyVCMod* newmod = new ApplyVCMod(FALSE);	

	for (int i=0; i<mixedVertexColors.Count(); i++) {
		Color* c = new Color(*mixedVertexColors[i]);
		newmod->mixedVertexColors.Append(1, &c, 25);
	}
	return newmod;
}


void ApplyVCMod::ModifyObject(TimeValue t, ModContext &mc, ObjectState *os, INode *node)
{
	static int calls = 0;
	iValid = FOREVER;
	Interval valid = LocalValidity(t);

	assert(os->obj->IsSubClassOf(triObjectClassID));
	TriObject *obj = (TriObject*)os->obj;
	Mesh &mesh = obj->GetMesh();	

	if (mixedVertexColors.Count() > 0) {
		mesh.setNumVertCol(mesh.numVerts);
		mesh.setNumVCFaces(mesh.numFaces);

		for (int i=0; i<mesh.numVerts; i++) {
			mesh.vertCol[i] = i<mixedVertexColors.Count() ?
				Point3(mixedVertexColors[i]->r, mixedVertexColors[i]->g, mixedVertexColors[i]->b) :
				Point3(1.0f, 1.0f, 1.0f);
			}

		for (i=0; i<mesh.numFaces; i++) {
			mesh.vcFace[i].t[0] = mesh.faces[i].v[0];
			mesh.vcFace[i].t[1] = mesh.faces[i].v[1];
			mesh.vcFace[i].t[2] = mesh.faces[i].v[2];
			}
		}
	else if (faceColors.Count() > 0) {
		int numVCVerts = mesh.numFaces*3;
		mesh.setNumVCFaces(mesh.numFaces);
		mesh.setNumVertCol(numVCVerts);

		int faceVert = 0;
		for (int i=0; i<mesh.numFaces; i++) {
			for (int j=0; j<3; j++) {
				mesh.vertCol[faceVert] = i<faceColors.Count() ? 
					Point3(faceColors[i]->colors[j].r, faceColors[i]->colors[j].g, faceColors[i]->colors[j].b) :
					Point3(1.0f, 1.0f, 1.0f);
				faceVert++;
				}
			}

		faceVert = 0;
		for (i=0; i<mesh.numFaces; i++) {
			mesh.vcFace[i].t[0] = faceVert++;
			mesh.vcFace[i].t[1] = faceVert++;
			mesh.vcFace[i].t[2] = faceVert++;
			}
		}

	NotifyDependents(Interval(t,t), PART_VERTCOLOR, REFMSG_CHANGE);
	NotifyDependents(Interval(t,t), PART_TOPO, REFMSG_CHANGE);
	obj->UpdateValidity(VERT_COLOR_CHAN_NUM, valid);
}


RefTargetHandle ApplyVCMod::GetReference(int i)
{
	return NULL;
}

void ApplyVCMod::SetReference(int i, RefTargetHandle rtarg)
{
}

Animatable* ApplyVCMod::SubAnim(int i)
{
	return NULL;
}

TSTR ApplyVCMod::SubAnimName(int i)
{
	return TSTR(_T(""));
}

RefResult ApplyVCMod::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
   		PartID& partID, 
   		RefMessage message) 
{
	return REF_SUCCEED;
}

void ApplyVCMod::ResetColTab()
{
	int i;
	// Reset table of mixed colors
	for (i=0; i<mixedVertexColors.Count(); i++) {
		delete mixedVertexColors[i];
	}
	mixedVertexColors.ZeroCount();
	mixedVertexColors.Shrink();

	// Reset table of vertex colors
	for (i=0; i<faceColors.Count(); i++) {
		delete faceColors[i];
	}
	faceColors.ZeroCount();
	faceColors.Shrink();

	iValid.SetEmpty();
}

// Public access function.
// Please note that multiple vertex colors are not implemetned yet.
// Please use SetMixedColors() for now.
void ApplyVCMod::SetColors(FaceColorTab& colorTab)
	{
	ResetColTab();

	for (int i=0; i<colorTab.Count(); i++) {
		FaceColor* faceCol = new FaceColor;

		for (int j=0; j<3; j++) {
			faceCol->colors[j] = colorTab[i]->colors[j];
		}
		faceColors.Append(1, &faceCol, 25);
	}

	NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
	}


// Public access function.
void ApplyVCMod::SetMixedColors(ColorTab& colorTab)
{
	ResetColTab();

	for (int i=0; i<colorTab.Count(); i++) {
		Color* col = new Color(*colorTab[i]);
		mixedVertexColors.Append(1, &col, 25);
	}

	NotifyDependents(FOREVER, PART_VERTCOLOR, REFMSG_CHANGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\ApplyVC\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ApplyVC.rc
//
#define IDS_AVCU_CNAME                  1
#define IDS_AVCU_PANELTITLE             2
#define IDS_AVCM_CNAME                  3
#define IDS_AVCM_ONAME                  4
#define IDS_AVCM_PANELTITLE             5
#define IDS_AVCU_PROGRESS               6
#define IDS_LIBDESCRIPTION              7
#define IDD_VCUTIL_PANEL                101
#define IDD_VCMOD_PANEL                 102
#define IDC_CLOSEBUTTON                 1000
#define IDC_VCUTIL_APPLY                1001
#define IDC_VCUTIL_AMBIENT              1002
#define IDC_VCUTIL_DIFFUSE              1003
#define IDC_VCUTIL_SCENELIGHTS          1004
#define IDC_VCUTIL_UPDATEALL            1005
#define IDC_MIX                         1006
#define IDC_CASTSHADOWS                 1007
#define IDC_USEMAPS                     1008

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\CCUtil\CCUtil.h ===
/**********************************************************************
 *<
	FILE: CCUtil.h

	DESCRIPTION:	Template Utility

	CREATED BY:

	HISTORY:

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __CCUTIL__H
#define __CCUTIL__H

#include "Max.h"
#include "resource.h"
#include "istdplug.h"
#include "icurvctl.h"

#include "utilapi.h"

extern TCHAR *GetString(int id);

extern HINSTANCE hInstance;

#endif // __CCUTIL__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\CCUtil\CCUtil.cpp ===
/**********************************************************************
 *<
	FILE: CCUtil.cpp

	DESCRIPTION:	Test Utility to show the use of CurveControl

	CREATED BY: Nikolai Sander, Kinetix Development

	HISTORY: Created 10/15/98

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "max.h"
#include "utilapi.h"
#include "icurvctl.h"
#include "resource.h"

#define CCUTIL_CLASS_ID	Class_ID(0x36d873ab, 0x6d2c806e)

static HIMAGELIST hTools = NULL;
static void LoadCurveControlResources();
//static void RegisterCurveCtlWindow();
LRESULT CALLBACK CurveCtlWindowProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

extern TCHAR *GetString(int id);

static char buf[11];

#define CURVECTLWINDOW				_T("CurveCtlWindow")

class DummyRefMaker : public ReferenceMaker
{
	void DeleteThis() {}
	virtual void* GetInterface(ULONG id);
	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, PartID& partID,RefMessage message){return REF_DONTCARE;}
};

class CCUtil : public UtilityObj, public ResourceMakerCallback {

	friend class CCUtilClassDesc;
	
public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		float xMin, xMax;
		float xZoom, yZoom;
		int xScroll, yScroll;
		
		//Constructor/Destructor
		CCUtil();
		~CCUtil();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		int  GetCurveNum();
		void ReadPtVals(Point2 &in, Point2 &out, Point2 &pos, int &flags, int &index);
		void ShowCurveControl();
		void ChangeCurveNumbers(BOOL inc);
		void SetColor(BOOL Active);
		void SetXRange();
		void SetZoom();
		void GetZoom();
		void SetScroll();
		void GetScroll();
		void SetDisplay();
		void GetCurveValues(BOOL Active);
		void SetAnimated();
		void SetFlags();
		void SetCommand();
		void GetPtInfo();
		void SetPt(BOOL insert);
		void DelPt();
		void GetPlacement();
		void SetPlacement();
		void SetSwatchColor(ICurve *pCurve,int index);

		
		BOOL SetCustomImageList(HIMAGELIST &hCTools,ICurveCtl *pCCtl);
		BOOL GetToolTip(int iButton, TSTR &ToolTip,ICurveCtl *pCCtl);
		void ResetCallback(int curvenum, ICurveCtl *pCCtl);
		void NewCurveCreatedCallback(int curvenum,ICurveCtl *pCCtl);
		

	private:
		ICurveCtl *mpCCtl;
		ISpinnerControl *iXMin;
		ISpinnerControl *iXMax;
		ISpinnerControl *iXZoom;
		ISpinnerControl *iYZoom;
		ISpinnerControl *iXScroll;
		ISpinnerControl *iYScroll;
		IColorSwatch    *iColor;
};


static CCUtil theCCUtil;

class CCUtilClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theCCUtil;}
	const TCHAR *	ClassName() {return GetString(IDS_CLASS_NAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return CCUTIL_CLASS_ID;}
	const TCHAR* 	Category() {return GetString(IDS_CATEGORY);}
	void			ResetClassParams (BOOL fileReset);
};

static CCUtilClassDesc CCUtilDesc;
ClassDesc* GetCCUtilDesc() {return &CCUtilDesc;}

//TODO: Should implement this method to reset the plugin params when Max is reset
void CCUtilClassDesc::ResetClassParams (BOOL fileReset) 
{
	if(theCCUtil.mpCCtl)
	{
		theCCUtil.mpCCtl->SetActive(FALSE);
		theCCUtil.mpCCtl->DeleteThis();
		theCCUtil.mpCCtl = NULL;
	}

}

static DummyRefMaker theDummyRefMaker;

void *DummyRefMaker::GetInterface(ULONG id)
{
	if(id == I_RESMAKER_INTERFACE)
		return (void *) (ResourceMakerCallback *) &theCCUtil;
	else
		return (void *) NULL;
}


static BOOL CALLBACK CCUtilDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	
	if(msg == WM_CC_CHANGE_CURVEPT)
	{
		ICurve *pCurve = (ICurve *) lParam;
		int index = LOWORD(wParam);
		theCCUtil.SetSwatchColor(pCurve,index);
	}

	if (((msg==CC_SPINNER_BUTTONUP) && HIWORD(wParam)) ||
		((msg==CC_SPINNER_CHANGE) ))// && (!HIWORD(wParam)))) 
	{
		ISpinnerControl *spin;
		spin = (ISpinnerControl *) lParam;
		
		switch (LOWORD(wParam)) 
		{
		case IDC_XMIN_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.xMin = spin->GetFVal();
				if(theCCUtil.xMin >= theCCUtil.xMax)
				{
					theCCUtil.xMin = theCCUtil.xMax-1.0f;
					spin->SetValue(theCCUtil.xMin,FALSE);
				}
				theCCUtil.SetXRange();
			}
			break;
		case IDC_XMAX_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.xMax = spin->GetFVal();
				if(theCCUtil.xMin >= theCCUtil.xMax)
				{
					theCCUtil.xMax = theCCUtil.xMin+1.0f;
					spin->SetValue(theCCUtil.xMax,FALSE);
				}
				theCCUtil.SetXRange();
			}
			break;
		case IDC_XZOOM_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.xZoom = spin->GetFVal();
				theCCUtil.SetZoom();
			}
			break;
		case IDC_YZOOM_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.yZoom = spin->GetFVal();
				theCCUtil.SetZoom();
			}

			break;
		case IDC_XSCROLL_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.xScroll = spin->GetIVal();
				theCCUtil.SetScroll();
			}
			break;
		case IDC_YSCROLL_SPIN:
			if ((msg == CC_SPINNER_CHANGE))// || (!HIWORD(wParam))) 
			{
				theCCUtil.yScroll = spin->GetIVal();
				theCCUtil.SetScroll();
			}

			break;
		}
	}		
	switch (msg) {
		case WM_INITDIALOG:
			theCCUtil.Init(hWnd);
			break;

		case WM_DESTROY:
			theCCUtil.Destroy(hWnd);
			break;

		case WM_COMMAND:
				switch (LOWORD(wParam)) 
				{
				case IDC_CC :
					theCCUtil.ShowCurveControl();
					break;
				case IDC_PLUS :
					theCCUtil.ChangeCurveNumbers(TRUE);
					break;
				case IDC_MINUS :
					theCCUtil.ChangeCurveNumbers(FALSE);
					break;
				case IDC_SETCOLOR :
					theCCUtil.SetColor(TRUE);
					break;
				case IDC_SETDCOLOR :
					theCCUtil.SetColor(FALSE);
					break;
				case IDC_GETZOOM :
					theCCUtil.GetZoom();
					break;
				case IDC_GETSCROLL :
					theCCUtil.GetScroll();
					break;
				case IDC_SETDISP :
					theCCUtil.SetDisplay();
					break;
				case IDC_GETVAL :
					theCCUtil.GetCurveValues(TRUE);
					break;
				case IDC_GETDISABLED:
					theCCUtil.GetCurveValues(FALSE);
					break;
				case IDC_SETANIMATED :
					theCCUtil.SetAnimated();
					break;
				case IDC_CMD_SET :
					theCCUtil.SetCommand();
					break;
				case IDC_PT_GET:
					theCCUtil.GetPtInfo();
					break;
				case IDC_PT_SET:
					theCCUtil.SetPt(FALSE);
					break;
				case IDC_PT_INSERT:
					theCCUtil.SetPt(TRUE);
					break;
				case IDC_PT_DELETE:
					theCCUtil.DelPt();
					break;
				case IDC_GET_PLACEMENT:
					theCCUtil.GetPlacement();
					break;
				case IDC_SET_PLACEMENT:
					theCCUtil.SetPlacement();
					break;
				case IDC_DRAWBG:
				case IDC_DRAWGRID:
				case IDC_DRAWUTOOLBAR:
				case IDC_SHOWRESET:
				case IDC_DRAWLTOOLBAR:
				case IDC_DRAWSCROLLBARS:
				case IDC_AUTOSCROLL:
				case IDC_DRAWRULER:
				case IDC_ASPOPUP:
				case IDC_CONSTRAIN_Y:	
				case IDC_HIDE_DISABLED_CURVES:
				case IDC_RCMENU_MOVE_XY:
				case IDC_RCMENU_MOVE_X:
				case IDC_RCMENU_MOVE_Y:
				case IDC_RCMENU_SCALE:
				case IDC_RCMENU_INSERT_CORNER:
				case IDC_RCMENU_INSERT_BEZIER:
				case IDC_RCMENU_DELETE:
					theCCUtil.SetFlags();
					break;
				case IDC_SC_CURVENUMBER:
				case IDC_SC_R:
				case IDC_SC_G:
				case IDC_SC_B:
				case IDC_DISPEDIT:
				case IDC_CMD_EDIT:
				case IDC_PT_INDEX:
				case IDC_PT_POS_X:
				case IDC_PT_POS_Y:
				case IDC_PT_IN_X:
				case IDC_PT_IN_Y:
				case IDC_PT_OUT_X:
				case IDC_PT_OUT_Y:
				case IDC_SIZE_X:
				case IDC_SIZE_Y:
				case IDC_POS_X:
				case IDC_POS_Y:
					if(HIWORD(wParam) == EN_SETFOCUS)
						DisableAccelerators();
					// Otherwise enable them again
					else if(HIWORD(wParam) == EN_KILLFOCUS) {
						EnableAccelerators();
					}
					break;					
				}
			break;


		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theCCUtil.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}
	return TRUE;
}



//--- CCUtil -------------------------------------------------------
CCUtil::CCUtil()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
	mpCCtl = NULL;
	iXMin = NULL;
	iXMax = NULL;
	xMin = 0;
	xMax = 1;
	xScroll = -24;
	yScroll = -40;
	xZoom = 492.727f;
	yZoom = 344.643f;
}

CCUtil::~CCUtil()
{

}

void CCUtil::BeginEditParams(Interface *ip,IUtil *iu) 
{
	//RegisterCurveCtlWindow();
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_PANEL),
		CCUtilDlgProc,
		GetString(IDS_PARAMS),
		0);
	
	iXMin = SetupIntSpinner (hPanel, IDC_XMIN_SPIN, IDC_XMIN, -10000, 10000, (int) xMin);
	iXMax = SetupIntSpinner (hPanel, IDC_XMAX_SPIN, IDC_XMAX, -10000, 10000, (int) xMax);

	iXZoom = SetupFloatSpinner(hPanel, IDC_XZOOM_SPIN, IDC_XZOOM, 0.00001f, 10000.0f, xZoom );
	iYZoom = SetupFloatSpinner(hPanel, IDC_YZOOM_SPIN, IDC_YZOOM, 0.00001f, 10000.0f, yZoom );
	iXScroll = SetupIntSpinner(hPanel, IDC_XSCROLL_SPIN, IDC_XSCROLL, -10000, 10000, xScroll );
	iYScroll = SetupIntSpinner(hPanel, IDC_YSCROLL_SPIN, IDC_YSCROLL, -10000, 10000, yScroll );
	iColor = GetIColorSwatch(GetDlgItem(hPanel, IDC_COLOR), 	RGB(255,255,255), _T("Curve Color"));
	

}
	
void CCUtil::EndEditParams(Interface *ip,IUtil *iu) 
{

	ReleaseISpinner (iXMin);
	ReleaseISpinner (iXMax);
	ReleaseISpinner (iXZoom);
	ReleaseISpinner (iYZoom);
	ReleaseISpinner (iXScroll);
	ReleaseISpinner (iYScroll);
	ReleaseIColorSwatch (iColor);

	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void CCUtil::Init(HWND hPanel)
{
	SetCheckBox(hPanel, IDC_DRAWBG,1);
	SetCheckBox(hPanel, IDC_DRAWGRID,1);
	SetCheckBox(hPanel, IDC_DRAWUTOOLBAR,1);
	SetCheckBox(hPanel, IDC_SHOWRESET,1);
	SetCheckBox(hPanel, IDC_DRAWLTOOLBAR,1);
	SetCheckBox(hPanel, IDC_DRAWSCROLLBARS,1);
	SetCheckBox(hPanel, IDC_AUTOSCROLL,1);
	SetCheckBox(hPanel, IDC_DRAWRULER,1);
	SetCheckBox(hPanel, IDC_ASPOPUP,1);
	SetCheckBox(hPanel, IDC_CONSTRAIN_Y,1);
	SetCheckBox(hPanel, IDC_HIDE_DISABLED_CURVES,1);
	
	SetCheckBox(hPanel, IDC_RCMENU_MOVE_XY,1);
	SetCheckBox(hPanel, IDC_RCMENU_MOVE_X,1);
	SetCheckBox(hPanel, IDC_RCMENU_MOVE_Y,1);
	SetCheckBox(hPanel, IDC_RCMENU_SCALE,1);
	SetCheckBox(hPanel, IDC_RCMENU_INSERT_CORNER,1);
	SetCheckBox(hPanel, IDC_RCMENU_INSERT_BEZIER,1);
	SetCheckBox(hPanel, IDC_RCMENU_DELETE,1);
	
}

void CCUtil::Destroy(HWND hWnd)
{

}

void CCUtil::ShowCurveControl()
{

	ICurve *pCurve = NULL;
	if(!mpCCtl)
	{
		mpCCtl = (ICurveCtl *) CreateInstance(REF_MAKER_CLASS_ID,CURVE_CONTROL_CLASS_ID);
		
		if(!mpCCtl)
			return;
	}

	mpCCtl->SetXRange(xMin,xMax);
	mpCCtl->SetYRange(0.0f,1.0f);

	mpCCtl->RegisterResourceMaker(&theDummyRefMaker);
	mpCCtl->SetNumCurves(4);
	
	LoadCurveControlResources();
	SetZoom();
	SetScroll();
	mpCCtl->SetTitle("Test Control Curve");
	
	BitArray ba;
	ba.SetSize(6);
	ba.Set(0);//ba.Set(0);ba.Set(0);ba.Set(3);
	mpCCtl->SetDisplayMode(ba);
	

	SetFlags();
	
	mpCCtl->SetCustomParentWnd(GetDlgItem(hPanel, IDC_CURVE));
	
	mpCCtl->SetMessageSink(hPanel);
	
	if(mpCCtl->IsActive())
		mpCCtl->SetActive(FALSE);
	else
		mpCCtl->SetActive(TRUE);
}



void CCUtil::ChangeCurveNumbers(BOOL inc)
{	
	int i = mpCCtl->GetNumCurves();
	
	if(inc)
	{
		mpCCtl->SetNumCurves(i+1);
	}
	else
		if(i > 0)
			mpCCtl->SetNumCurves(i-1);
}

void CCUtil::SetColor(BOOL Active)
{
	int r,g,b, style, width;

	GetDlgItemText(hPanel, IDC_SC_R, buf, 10); r = (int)atoi(buf);
	GetDlgItemText(hPanel, IDC_SC_G, buf, 10); g = (int)atoi(buf);
	GetDlgItemText(hPanel, IDC_SC_B, buf, 10); b = (int)atoi(buf);
	GetDlgItemText(hPanel, IDC_STYLE, buf, 10); style = (int)atoi(buf);
	GetDlgItemText(hPanel, IDC_WIDTH, buf, 10); width = (int)atoi(buf);


	ICurve *pCurve = mpCCtl->GetControlCurve(GetCurveNum());

	if(pCurve)
		if(Active)
			pCurve->SetPenProperty(RGB(r,g,b),width, style);
		else
			pCurve->SetDisabledPenProperty(RGB(r,g,b),width,style);

}

void CCUtil::SetXRange()
{
	mpCCtl->SetXRange(xMin, xMax);
}

void CCUtil::SetZoom()
{
	mpCCtl->SetZoomValues(xZoom,yZoom);
}

void CCUtil::GetZoom()
{
	mpCCtl->GetZoomValues(&xZoom,&yZoom);
	iXZoom->SetValue(xZoom,FALSE);
	iYZoom->SetValue(yZoom,FALSE);

}

void CCUtil::SetScroll()
{
	mpCCtl->SetScrollValues(xScroll,yScroll);
}

void CCUtil::GetScroll()
{
	mpCCtl->GetScrollValues(&xScroll,&yScroll);
	iXScroll->SetValue(xScroll,FALSE);
	iYScroll->SetValue(yScroll,FALSE);

}

void CCUtil::SetDisplay()
{

	long lDisp;

	GetDlgItemText(hPanel, IDC_DISPEDIT, buf, 10); lDisp = atol(buf);
	BitArray Disp(sizeof(long)*8);
	
	for(int i= 0 ; i < Disp.GetSize(); i++)
	{
		if( (lDisp>>i & 1)	)
			Disp.Set(i);
	}
	
	mpCCtl->SetDisplayMode(Disp);
}

int CCUtil::GetCurveNum()
{
	GetDlgItemText(hPanel, IDC_SC_CURVENUMBER, buf, 10); 
	return ((int)atoi(buf));
}


void CCUtil::GetCurveValues(BOOL Active)
{
	ICurve *pCurve = mpCCtl->GetControlCurve(GetCurveNum());

	if(pCurve)
	{
		int r,g,b;
		int width, style;
		COLORREF color;

		if(Active)
			pCurve->GetPenProperty(color,width,style);
		else
			pCurve->GetDisabledPenProperty(color,width,style);

		BOOL isAnimated = pCurve->GetCanBeAnimated();
		
		r = GetRValue(color);
		g = GetGValue(color);
		b = GetBValue(color);

		sprintf(buf,"%d",r);
		SetDlgItemText(hPanel, IDC_SC_R, buf); 
		sprintf(buf,"%d",g);
		SetDlgItemText(hPanel, IDC_SC_G, buf); 
		sprintf(buf,"%d",b);
		SetDlgItemText(hPanel, IDC_SC_B, buf); 
		
		SetCheckBox(hPanel, IDC_SETANIMATED, isAnimated);
	}

}

void CCUtil::SetAnimated()
{
	ICurve *pCurve = mpCCtl->GetControlCurve(GetCurveNum());

	if(pCurve)
		pCurve->SetCanBeAnimated(GetCheckBox(hPanel, IDC_SETANIMATED));

}

void CCUtil::SetFlags()
{
	DWORD flags = CC_NONE;
	
	flags |= GetCheckBox(hPanel, IDC_DRAWBG) ? CC_DRAWBG : 0;
	flags |= GetCheckBox(hPanel, IDC_DRAWGRID) ? CC_DRAWGRID : 0;
	flags |= GetCheckBox(hPanel, IDC_DRAWUTOOLBAR) ? CC_DRAWUTOOLBAR : 0;
	flags |= GetCheckBox(hPanel, IDC_DRAWLTOOLBAR) ? CC_DRAWLTOOLBAR : 0;
	flags |= GetCheckBox(hPanel, IDC_SHOWRESET) ? CC_SHOWRESET : 0;
	flags |= GetCheckBox(hPanel, IDC_DRAWSCROLLBARS) ? CC_DRAWSCROLLBARS : 0;
	flags |= GetCheckBox(hPanel, IDC_AUTOSCROLL) ? CC_AUTOSCROLL : 0;
	flags |= GetCheckBox(hPanel, IDC_DRAWRULER) ? CC_DRAWRULER : 0;
	flags |= GetCheckBox(hPanel, IDC_ASPOPUP) ? CC_ASPOPUP : 0;
	flags |= GetCheckBox(hPanel, IDC_CONSTRAIN_Y) ? CC_CONSTRAIN_Y : 0;
	flags |= GetCheckBox(hPanel, IDC_HIDE_DISABLED_CURVES) ? CC_HIDE_DISABLED_CURVES : 0;
	
	
	flags |= GetCheckBox(hPanel, IDC_RCMENU_MOVE_XY) ? CC_RCMENU_MOVE_XY : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_MOVE_X) ? CC_RCMENU_MOVE_X : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_MOVE_Y) ? CC_RCMENU_MOVE_Y : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_SCALE) ? CC_RCMENU_SCALE : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_INSERT_CORNER) ? CC_RCMENU_INSERT_CORNER : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_INSERT_BEZIER) ? CC_RCMENU_INSERT_BEZIER : 0;
	flags |= GetCheckBox(hPanel, IDC_RCMENU_DELETE) ? CC_RCMENU_DELETE : 0;

	if(mpCCtl) mpCCtl->SetCCFlags(flags);

}

void CCUtil::SetCommand()
{
	
	GetDlgItemText(hPanel, IDC_CMD_EDIT, buf, 10); 
	int id = (int)atoi(buf);
	if(mpCCtl) mpCCtl->SetCommandMode(id);
}

void CCUtil::GetPtInfo()
{
	ICurve *pCurve = mpCCtl->GetControlCurve(GetCurveNum());
	
	int idx=0;

	if(pCurve)
	{
		sprintf(buf,"%d",pCurve->GetNumPts());
		SetDlgItemText(hPanel, IDC_PT_NUM, buf); 
		
		GetDlgItemText(hPanel, IDC_PT_INDEX, buf, 10); 
		idx = (int)atoi(buf);

		if(idx >= 0 && idx < pCurve->GetNumPts())
		{
			CurvePoint pt = pCurve->GetPoint(ip->GetTime(),idx);
			sprintf(buf,"%.7f",pt.p.x);
			SetDlgItemText(hPanel, IDC_PT_POS_X, buf); 
			sprintf(buf,"%.7f",pt.p.y);
			SetDlgItemText(hPanel, IDC_PT_POS_Y, buf); 

			sprintf(buf,"%.7f",pt.in.x);
			SetDlgItemText(hPanel, IDC_PT_IN_X, buf); 
			sprintf(buf,"%.7f",pt.in.y);
			SetDlgItemText(hPanel, IDC_PT_IN_Y, buf); 

			sprintf(buf,"%.7f",pt.out.x);
			SetDlgItemText(hPanel, IDC_PT_OUT_X, buf); 
			sprintf(buf,"%.7f",pt.out.y);
			SetDlgItemText(hPanel, IDC_PT_OUT_Y, buf);
			
			SetCheckBox(hPanel, IDC_CORNER, pt.flags & CURVEP_CORNER );	
			SetCheckBox(hPanel, IDC_BEZIER, pt.flags & CURVEP_BEZIER );
			SetCheckBox(hPanel, IDC_LOCKED_X, pt.flags & CURVEP_LOCKED_X);
			SetCheckBox(hPanel, IDC_LOCKED_Y, pt.flags & CURVEP_LOCKED_Y);
			

		}
	}

}

void CCUtil::ReadPtVals(Point2 &in, Point2 &out, Point2 &pos, int &flags, int &index)
{

	GetDlgItemText(hPanel, IDC_PT_POS_X, buf, 10); 
	pos.x = (float)atof(buf);
	GetDlgItemText(hPanel, IDC_PT_POS_Y, buf, 10); 
	pos.y = (float)atof(buf);

	GetDlgItemText(hPanel, IDC_PT_IN_X, buf, 10); 
	in.x = (float)atof(buf);
	GetDlgItemText(hPanel, IDC_PT_IN_Y, buf, 10); 
	in.y = (float)atof(buf);

	GetDlgItemText(hPanel, IDC_PT_OUT_X, buf, 10); 
	out.x = (float)atof(buf);
	GetDlgItemText(hPanel, IDC_PT_OUT_Y, buf, 10); 
	out.y = (float)atof(buf);

	GetDlgItemText(hPanel, IDC_PT_INDEX, buf, 10); 
	index = (int)atof(buf);
			
	flags |= GetCheckBox(hPanel, IDC_CORNER) ? CURVEP_CORNER : 0;
	flags |= GetCheckBox(hPanel, IDC_BEZIER) ? CURVEP_BEZIER : 0;
	flags |= GetCheckBox(hPanel, IDC_LOCKED_X) ? CURVEP_LOCKED_X : 0;
	flags |= GetCheckBox(hPanel, IDC_LOCKED_Y) ? CURVEP_LOCKED_Y : 0;	
}

void CCUtil::SetPt(BOOL insert)
{
	Point2 in, out, pos;
	int idx, flags = 0;
	ReadPtVals(in,out,pos,flags,idx);
	ICurve *pCurve = NULL;
	
	if(mpCCtl)
		pCurve = mpCCtl->GetControlCurve(GetCurveNum());

	if(pCurve)
	{
		if(idx >= 0 && idx < pCurve->GetNumPts())
		{
			CurvePoint pt;

			pt.p = pos;
			pt.in = in;
			pt.out = out;
			pt.flags = flags;
			
			if(insert)
				pCurve->Insert(idx,pt);
			else
				pCurve->SetPoint(ip->GetTime(),idx,&pt);

			mpCCtl->Redraw();
		}
	}
}

void CCUtil::DelPt()
{
	ICurve *pCurve = NULL;

	if(mpCCtl)
		pCurve = mpCCtl->GetControlCurve(GetCurveNum());
	
	if(pCurve)
	{
		GetDlgItemText(hPanel, IDC_PT_INDEX, buf, 10); 
		int index = (int)atof(buf);
		if(index >= 0 && index < pCurve->GetNumPts() )
		{
			pCurve->Delete(index);
			mpCCtl->Redraw();
		}
	}
}

void CCUtil::GetPlacement()
{
	
	if(mpCCtl)
	{
		HWND hCurve = mpCCtl->GetHWND();
		if(hCurve)
		{
			RECT rect;
			GetWindowRect(hCurve,&rect);
		
			sprintf(buf,"%d",rect.top);
			SetDlgItemText(hPanel, IDC_POS_X, buf); 
	
			sprintf(buf,"%d",rect.left);
			SetDlgItemText(hPanel, IDC_POS_Y, buf); 

			sprintf(buf,"%d",rect.bottom-rect.top);
			SetDlgItemText(hPanel, IDC_SIZE_Y, buf); 

			sprintf(buf,"%d",rect.right-rect.left);
			SetDlgItemText(hPanel, IDC_SIZE_X, buf); 
			
		}
	}
}

void CCUtil::SetPlacement()
{
	if(mpCCtl && mpCCtl->GetCCFlags() & CC_ASPOPUP)
	{
		HWND hCurve = mpCCtl->GetHWND();
		if(hCurve)
		{
			int x,y,w,h;
			GetDlgItemText(hPanel,IDC_POS_X,buf,80);
			x = atoi(buf);
			GetDlgItemText(hPanel,IDC_POS_Y,buf,80);
			y = atoi(buf);
			GetDlgItemText(hPanel,IDC_SIZE_X,buf,80);
			w = atoi(buf);
			GetDlgItemText(hPanel,IDC_SIZE_Y,buf,80);
			h = atoi(buf);

			SetWindowPos(hCurve, HWND_TOP,x,y,w,h,SWP_SHOWWINDOW);
		}
	}
}
void CCUtil::SetSwatchColor(ICurve *pCurve,int index)
{
	Interval valid;
	if(mpCCtl && mpCCtl->GetNumCurves() >= 3 )
	{
		int col[3];
		CurvePoint cp = pCurve->GetPoint(ip->GetTime(), index);
		for(int i = 0 ; i < 3; i ++ )
		{
		col[i] = int (mpCCtl->GetControlCurve(i)->GetValue(ip->GetTime(),cp.p.x,valid,TRUE)*255);
		}
		iColor->SetColor(RGB(col[0],col[1],col[2]));
	}
}

//***************************************************************************
//**
//** ResourceMakerCallback implementation
//**
//***************************************************************************

BOOL CCUtil::SetCustomImageList(HIMAGELIST &hCTools,ICurveCtl *pCCtl)
{
	LoadCurveControlResources();
	hCTools = hTools;
	return TRUE;
}

BOOL CCUtil::GetToolTip(int iButton, TSTR &ToolTip,ICurveCtl *pCCtl)
{
	switch(iButton)
	{
		case 0:ToolTip = _T("Red Curve On/Off Toggle");break;
		case 1:ToolTip = _T("Green Curve On/Off Toggle");break;
		case 2:ToolTip = _T("Blue Curve On/Off Toggle");break;
		default:
			ToolTip = _T("Visibility On/Off Toggle");break;
	}
	return TRUE;
}

void CCUtil::ResetCallback(int curvenum,ICurveCtl *pCCtl)
{
	ICurve *pCurve = NULL;

	pCurve = mpCCtl->GetControlCurve(curvenum);
	if(pCurve)
	{
		pCurve->SetNumPts(2);
		NewCurveCreatedCallback(curvenum, pCCtl);
	}

}
void CCUtil::NewCurveCreatedCallback(int curvenum,ICurveCtl *pCCtl)
{
	float df = curvenum/10.0f;

	ICurve *pCurve = NULL;
	
	if(mpCCtl)
		pCurve = mpCCtl->GetControlCurve(curvenum);

	if(pCurve)
	{
		CurvePoint pt = pCurve->GetPoint(ip->GetTime(),0);
		pt.p.y = df;			
		pCurve->SetPoint(ip->GetTime(),0,&pt);
		
		pt = pCurve->GetPoint(ip->GetTime(),1);
		pt.p.y = 0.1f+df;			
		pCurve->SetPoint(ip->GetTime(),1,&pt);
		pCurve->SetLookupTableSize(100);

		switch(curvenum)
		{
		case 0:
			pCurve->SetPenProperty( RGB(255,0,0) );
			pCurve->SetDisabledPenProperty( RGB(255,180,180) );
			break;
		case 1:
			pCurve->SetPenProperty( RGB(0,128,0) );
			pCurve->SetDisabledPenProperty( RGB(190,200,190) );
			break;
		case 2:
			pCurve->SetPenProperty( RGB(0,0,255));
			pCurve->SetDisabledPenProperty( RGB(200,200,255));
			break;
		default:
			pCurve->SetPenProperty( RGB(0,0,0));
			pCurve->SetDisabledPenProperty( RGB(128,128,128));
		}
		
	}			
}

static void LoadCurveControlResources()
{

	HBITMAP hBitmap, hMask;

	hTools = ImageList_Create(16, 15, TRUE, 29, 0);
	hBitmap = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_DISPLAYRGB));
	hMask   = LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_MASK_DISPLAYRGB));
	ImageList_Add(hTools,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\CCUtil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CCUtil.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CATEGORY                    2
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDD_PANEL                       101
#define IDB_MASK_DISPLAYRGB             125
#define IDB_DISPLAYRGB                  127
#define IDC_CLOSEBUTTON                 1000
#define IDC_DOSTUFF                     1000
#define IDC_CC                          1001
#define IDC_MINUS                       1002
#define IDC_PLUS                        1003
#define IDC_SETCOLOR                    1004
#define IDC_SC_R                        1005
#define IDC_SC_G                        1006
#define IDC_SC_B                        1007
#define IDC_SC_CURVENUMBER              1008
#define IDC_SETDCOLOR                   1009
#define IDC_DISPEDIT                    1010
#define IDC_SETDISP                     1011
#define IDC_CMD_EDIT                    1012
#define IDC_GETZOOM                     1013
#define IDC_GETSCROLL                   1014
#define IDC_CMD_SET                     1015
#define IDC_SETANIMATED                 1016
#define IDC_GETVAL                      1017
#define IDC_GETDISABLED                 1018
#define IDC_DRAWBG                      1024
#define IDC_DRAWGRID                    1025
#define IDC_DRAWUTOOLBAR                1026
#define IDC_DRAWLTOOLBAR                1027
#define IDC_DRAWSCROLLBARS              1028
#define IDC_DRAWRULER                   1029
#define IDC_ASPOPUP                     1030
#define IDC_PT_IN_X                     1031
#define IDC_PT_IN_Y                     1032
#define IDC_PT_POS_X                    1033
#define IDC_PT_INDEX                    1034
#define IDC_PT_SET                      1035
#define IDC_AUTOSCROLL                  1036
#define IDC_PT_GET                      1037
#define IDC_PT_INSERT                   1038
#define IDC_PT_NUM                      1039
#define IDC_PT_POS_Y                    1040
#define IDC_PT_OUT_X                    1041
#define IDC_PT_OUT_Y                    1042
#define IDC_CURVE                       1043
#define IDC_CORNER                      1044
#define IDC_BEZIER                      1045
#define IDC_CONSTRAIN_Y                 1046
#define IDC_LOCKED_X                    1047
#define IDC_LOCKED_Y                    1048
#define IDC_PT_DELETE                   1049
#define IDC_SHOWRESET                   1050
#define IDC_RCMENU_MOVE_XY              1051
#define IDC_RCMENU_MOVE_X               1052
#define IDC_RCMENU_MOVE_Y               1053
#define IDC_RCMENU_SCALE                1054
#define IDC_RCMENU_INSERT_CORNER        1055
#define IDC_RCMENU_INSERT_BEZIER        1056
#define IDC_RCMENU_DELETE               1057
#define IDC_POS_X                       1058
#define IDC_POS_Y                       1059
#define IDC_GET_PLACEMENT               1060
#define IDC_SET_PLACEMENT               1061
#define IDC_HIDE_DISABLED_CURVES        1062
#define IDC_WIDTH                       1063
#define IDC_STYLE                       1064
#define IDC_SIZE_X                      1068
#define IDC_SIZE_Y                      1069
#define IDC_COLOR                       1456
#define IDC_EDIT                        1490
#define IDC_SPIN                        1496
#define IDC_XMIN                        3023
#define IDC_XZOOM                       3024
#define IDC_XSCROLL                     3025
#define IDC_XMAX                        3026
#define IDC_YZOOM                       3027
#define IDC_XMIN_SPIN                   3028
#define IDC_XMAX_SPIN                   3029
#define IDC_XZOOM_SPIN                  3030
#define IDC_YZOOM_SPIN                  3031
#define IDC_XSCROLL_SPIN                3032
#define IDC_YSCROLL                     3033
#define IDC_YSCROLL_SPIN                3034

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1064
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\CCUtil\DllEntry.cpp ===
/**********************************************************************
 *<
	FILE: DllEntry.cpp

	DESCRIPTION:Contains the Dll Entry stuff

	CREATED BY: 

	HISTORY: 

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "CCUtil.h"

extern ClassDesc* GetCCUtilDesc();

HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;				// Hang on to this DLL's instance handle.

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);	// Initialize MAX's custom controls
		InitCommonControls();			// Initialize Win95 controls
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetCCUtilDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\collector\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Collector.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDS_UV_NAME                     5
#define IDD_CL_PANEL                    105
#define IDC_CLOSEBUTTON                 1000
#define IDC_GO                          1001
#define IDC_PATH                        1005
#define IDC_BROWSE                      1006
#define IDC_PACKMAPS                    1007
#define IDC_PACKPLUGS                   1008
#define IDC_UPMAP                       1008
#define IDC_TYPE                        1009
#define IDC_PACKUP                      1010
#define IDC_PACKMAX                     1011
#define IDC_TYPE2                       1012
#define IDC_STATICPACK                  1013

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40031
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\collector\collector.h ===
/*----------------------------------------------------------------------*
 |
 |	FILE: Collector.h
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 *----------------------------------------------------------------------*/

#ifndef __COLLECTOR__H
#define __COLLECTOR__H

#include "Max.h"

#include "resource.h"
#include "utilapi.h"
#include "stdmat.h"
#include "bmmlib.h"

TCHAR *GetString(int id);

extern ClassDesc* GetCollectionDesc();

extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\collector\collector.cpp ===
/*----------------------------------------------------------------------*
 |
 |	FILE: Collector.cpp
 | 
 |	DESC: Resource Collection plugin
 |
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 |	HISTORY: 27.2.98
 |
 *----------------------------------------------------------------------*/


#include "collector.h"

#define CL_CLASSID	Class_ID(0x57ab2b60, 0x590572f5)
// two handy macros to set cursors for busy or normal operation
#define UI_MAKEBUSY			SetCursor(LoadCursor(NULL, IDC_WAIT));
#define UI_MAKEFREE			SetCursor(LoadCursor(NULL, IDC_ARROW));

HINSTANCE hInstance;
int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetCollectionDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

class Collection : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		
		char WZPath[255];
		BOOL WZisHere;

		Collection();
		~Collection();

		NameTab mapPaths;
		
		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

};

static Collection theCollection;


class CollectionClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theCollection;}
	const TCHAR *	ClassName() {return _T("Resource Collector");}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return CL_CLASSID;}
	const TCHAR* 	Category() {return _T("");}
};

static CollectionClassDesc CollectionDesc;
ClassDesc* GetCollectionDesc() {return &CollectionDesc;}


class CMtlEnum {
	public:

		virtual void  proc(MtlBase *m){
			Interface *ip = theCollection.ip;

			// Check for bitmaptex, and cast
			if(m->ClassID()==Class_ID(BMTEX_CLASS_ID,0)) {
				Texmap *bt = (Texmap*)m;
				BitmapTex *b = (BitmapTex*)bt;

				if(_stricmp(b->GetMapName(),"")!=0){
					
					// Use the very useful BMMGetFull.. to scan for existing files
					BitmapInfo bi(b->GetMapName());
					BMMGetFullFilename(&bi);

					char Bname[MAX_PATH];
					strcpy(Bname,bi.Name());

					// If our found file exists, add it to the list
					if(BMMIsFile(Bname)){
						char s[256];
						sprintf(s,"%s",Bname);

						// check for update, and do so if needed
						BOOL upd = GetCheckBox(theCollection.hPanel,IDC_UPMAP);
						if (upd) {
							TCHAR tfile[MAX_PATH];
							TCHAR textn[MAX_PATH];
							char to_path[255],fnl[MAX_PATH];
							GetWindowText(GetDlgItem(theCollection.hPanel,IDC_PATH),to_path,254);

							BMMSplitFilename(Bname, NULL, tfile, textn);
							BMMAppendSlash(to_path);
							sprintf(fnl,"%s%s%s",to_path,tfile,textn);

							b->SetMapName(fnl);
						}

						if(theCollection.mapPaths.FindName(Bname)==-1){
							theCollection.mapPaths.AddName(s);
						}
					}
				}
			}
		}
};


CMtlEnum CEnym;

// do the material enumeration
void CEnumMtlTree(MtlBase *mb, CMtlEnum &tenum) {
	tenum.proc(mb);
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) 
			CEnumMtlTree(st,tenum);
		}
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) 
				CEnumMtlTree(sm,tenum);
			}
		}
	}


// Enumerate the scene
void NodeEnum(INode *root)
{
	for (int k=0; k<root->NumberOfChildren(); k++)
	{
		INode *node = root->GetChildNode(k);
		MtlBase* mat = (MtlBase*)node->GetMtl();
		if (mat)
			CEnumMtlTree(mat,CEnym);
		if(node->NumberOfChildren()>0) NodeEnum(node);
	}
}



static BOOL CALLBACK CollectionDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	Interface *ip;
	ip = theCollection.ip;


	switch (msg) {
		case WM_INITDIALOG:
			theCollection.Init(hWnd);
			break;

		case WM_DESTROY:
			theCollection.Destroy(hWnd);
			break;

		case WM_COMMAND:

			switch(HIWORD(wParam)){
				case EN_SETFOCUS :
					DisableAccelerators();
					break;
				case EN_KILLFOCUS :
					EnableAccelerators();
					break;
			}

			switch (LOWORD(wParam)) {

			case IDC_BROWSE:
					TCHAR dir[256];
					TCHAR desc[256];
					_tcscpy(desc, _T("Target Directory"));
					ip->ChooseDirectory(hWnd, _T("Choose Output"), dir, desc);
					SetWindowText(GetDlgItem(hWnd,IDC_PATH),dir);
					break;

			case IDC_GO:
				{
				UI_MAKEBUSY
				theCollection.mapPaths.ZeroCount();

				// Collect bitmaps
				BOOL doMAPS = GetCheckBox(hWnd,IDC_PACKMAPS);

				if(doMAPS) 
				{
					INode *root = ip->GetRootNode();
					NodeEnum(root);
				}

				// Check and store MAX File
				BOOL doMAX = GetCheckBox(hWnd,IDC_PACKMAX);
				TCHAR winZipName[MAX_PATH];

				if(stricmp(ip->GetCurFilePath(),"")==0) 
				{
					MessageBox(NULL,"No valid MAX File Path","WARNING",MB_OK);

					// No file name. Assign a default.
					strcpy(winZipName,"UntitledScene.ZIP");
				}
				else
				{
					if (doMAX) theCollection.mapPaths.AddName(ip->GetCurFilePath()); 

					// Figure out a Winzip ZIP file name from the filepath
					TCHAR tfile[MAX_PATH];
						
					BMMSplitFilename(ip->GetCurFilePath(), NULL, tfile, NULL);
					sprintf(winZipName,"%s.ZIP",tfile);
				}
				


				// Do the copy/move options
				char to_path[255];
				char fnl[MAX_PATH];
				GetWindowText(GetDlgItem(hWnd,IDC_PATH),to_path,254);
				BOOL type;

				type = GetCheckBox(hWnd,IDC_TYPE);

				NameTab zipList; zipList.ZeroCount();

				for (int q=0; q<theCollection.mapPaths.Count(); q++)
				{
					TCHAR tfile[MAX_PATH];
					TCHAR textn[MAX_PATH];
					
					BMMSplitFilename(theCollection.mapPaths[q], NULL, tfile, textn);
					BMMAppendSlash(to_path);

					sprintf(fnl,"%s%s%s",to_path,tfile,textn);
					if(type)CopyFile(theCollection.mapPaths[q],fnl,FALSE);
					if(!type)MoveFile(theCollection.mapPaths[q],fnl);
					zipList.AddName(fnl);
				}

				BOOL zipup = GetCheckBox(hWnd,IDC_PACKUP);
				FILE *stream;

				// Create file list, and WINZIP the files together
				if(zipup&&theCollection.WZisHere)
				{
					char zpn[MAX_PATH];
					sprintf(zpn,"%sLIST$PCK.TXT",to_path);
					stream = fopen(zpn,"w+t");
					for (int u=0;u<zipList.Count();u++)
					{
					 fprintf(stream,"%s\n",zipList[u]);
					}
					fclose(stream);

					TCHAR tpath[MAX_PATH];
					TCHAR tfile[MAX_PATH];
					TCHAR textn[MAX_PATH];
					TCHAR exec[MAX_PATH];
					BMMSplitFilename(theCollection.WZPath, tpath, tfile, textn);

					// <winzip path> -a <zip filename> @LIST$PCK.TXT
					sprintf(exec,"%s%s -a \"%s\" @LIST$PCK.TXT",tpath,tfile,winZipName);

					_flushall();
					system(exec);

					DeleteFile(zpn);
				}

				UI_MAKEFREE
				ip->RedrawViews(ip->GetTime());
				} //mloop
				break;
			}
			break;

		default:
			return FALSE;
	}
	return TRUE;
}	

Collection::Collection()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

Collection::~Collection()
{
	
}

static BOOL CheckWinZip()
{
	HKEY	hKey;
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\classes\\WinZip", 0, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
		return FALSE;
	else
		return TRUE;
}
static void FindWinZipDir(TCHAR *Path)
{
	HKEY	hKey;
	long	kSize;
	RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\classes\\WinZip\\shell\\open\\command", 0, KEY_ALL_ACCESS, &hKey);
	RegQueryValue(hKey,NULL,Path,&kSize);
}

void Collection::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_CL_PANEL),
		CollectionDlgProc,
		"Parameters",
		0);

	mapPaths.ZeroCount();

	// Do a simple registry check for WinZip
	WZisHere = CheckWinZip();
	if(WZisHere) FindWinZipDir(WZPath);
		EnableWindow(GetDlgItem(hPanel,IDC_PACKUP),WZisHere);
		EnableWindow(GetDlgItem(hPanel,IDC_STATICPACK),WZisHere);
}
	
void Collection::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void Collection::Init(HWND hWnd)
{
	// Set our defaults
	SetCheckBox(hWnd,IDC_UPMAP,FALSE);
	SetCheckBox(hWnd,IDC_PACKMAX,FALSE);
	SetCheckBox(hWnd,IDC_PACKUP,FALSE);
	SetCheckBox(hWnd,IDC_TYPE2,FALSE);

	SetCheckBox(hWnd,IDC_PACKMAPS,TRUE);
	SetCheckBox(hWnd,IDC_TYPE,TRUE);

	SetWindowText(GetDlgItem(hWnd,IDC_PATH),ip->GetDir(APP_AUTOBACK_DIR));
}

void Collection::Destroy(HWND hWnd)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\comsrv\comsrv.cpp ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: comsrv.cpp
// ---------------------
// Author...: Gus J Grubba
// Date ....: October 1998
// Descr....: COM/DCOM Server Control Utility
//
// Shows how to control a "GUP" utility (which has no UI)
//            
//-----------------------------------------------------------------------------

#include "comsrv.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain ( HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved ) {

	static BOOL controlsInit = FALSE;

	switch (fdwReason) {

		case DLL_PROCESS_ATTACH:
			if (hInst)
				return(FALSE);
			hInst = hinstDLL;
			if (!controlsInit) {
				controlsInit = TRUE;
				InitCustomControls(hInst);
				InitCommonControls();
			}
			break;

		case DLL_PROCESS_DETACH:
			hInst  = NULL;
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;

	}
			
	return (TRUE);
}

//-----------------------------------------------------------------------------
//-- Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-- The Utility Object

static COMsrv comsrvManager;

//-----------------------------------------------------------------------------
//-- Interface Class Description

class COMsrvClassDesc : public ClassDesc {
	public:
		int 			IsPublic		( ) {return 1;}
		void*			Create			( BOOL loading = FALSE) {return &comsrvManager;}
		const TCHAR*	ClassName		( ) {return GetString(IDS_CLASS_DESC);}
		SClass_ID		SuperClassID	( ) {return UTILITY_CLASS_ID;}
		Class_ID		ClassID			( ) {return Class_ID(0x129AD7F2,10);}
		const TCHAR* 	Category		( ) {return _T("");}
};

static COMsrvClassDesc iflClassDesc;

//-----------------------------------------------------------------------------
// Max Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	  switch(i) {
		 case  0: return &iflClassDesc;	break;
		 default: return 0;				break;
	  }
}

DLLEXPORT ULONG LibVersion ( )  { 
	  return ( VERSION_3DSMAX ); 
}

//-----------------------------------------------------------------------------
// Dialogue Handler

BOOL CALLBACK iflDlgProc(	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {

	switch (msg) {
		
		case WM_INITDIALOG:
			comsrvManager.Init(hWnd);			
			break;
		
		case WM_DESTROY:
			comsrvManager.Destroy(hWnd);
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_REGISTER:
					comsrvManager.Register(hWnd);
					break;
				case IDOK:
					comsrvManager.iu->CloseUtility();
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			comsrvManager.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}

	return TRUE; 

}

//-----------------------------------------------------------------------------
// #> COMsrv::COMsrv()

COMsrv::COMsrv() {
	iu		= NULL;
	ip		= NULL;	
	comgup	= NULL;
	hPanel	= NULL;	
}

//-----------------------------------------------------------------------------
// #> COMsrv::BeginEditParams()

void COMsrv::BeginEditParams( Interface *ip, IUtil *iu ) {
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInst,
		MAKEINTRESOURCE(IDC_COMSRV_DLG),
		iflDlgProc,
		GetString(IDS_CLASS_DESC),
		0);
}
	
//-----------------------------------------------------------------------------
// #> COMsrv::EndEditParams()

void COMsrv::EndEditParams( Interface *ip,IUtil *iu ) {	
	this->iu	= NULL;
	this->ip	= NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel		= NULL;
}

//-----------------------------------------------------------------------------
// #> COMsrv::UpdateButton()

void COMsrv::UpdateButton( HWND hWnd ) {
	if (ISCOMREGISTERED)
		SetDlgItemText(hWnd,IDC_REGISTER,GetString(IDS_UNREGISTER));
	else
		SetDlgItemText(hWnd,IDC_REGISTER,GetString(IDS_REGISTER));
}

//-----------------------------------------------------------------------------
// #> COMsrv::Init()

void COMsrv::Init ( HWND hWnd ) {
	comgup = OpenGupPlugIn(Class_ID(470000002,0));
	if (!comgup) {
		TCHAR title[128];
		_tcscpy(title,GetString(IDS_DLG_TITLE));
		MessageBox(hWnd,GetString(IDS_CANT_FIND_GUP),title,MB_OK);
		return;
	}
	HWND hDlg = GetDlgItem(hWnd,IDC_REGISTER);
	EnableWindow(hDlg,TRUE);
	UpdateButton(hWnd);
}

//-----------------------------------------------------------------------------
// #> COMsrv::Destroy()

void COMsrv::Destroy ( HWND hWnd ) {
	if (comgup) {
		delete comgup;
		comgup = NULL;
	}
}

//-----------------------------------------------------------------------------
// #> COMsrv::Register()

void COMsrv::Register( HWND hWnd ) {
	HCURSOR oldcur = SetCursor(LoadCursor(NULL,IDC_WAIT));
	if (ISCOMREGISTERED)
		UNREGISTERCOM;
	else
		REGISTERCOM;
	UpdateButton(hWnd);
	SetCursor(oldcur);
}

//-- EOF: comsrv.cpp ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\comsrv\comsrv.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: comsrv.h
// -------------------
// Author...: Gus J Grubba
// Date ....: March 1997
// Descr....: IFL Manager Utility
//
// History .: Mar, 18 1997 - Started
//            
//-----------------------------------------------------------------------------

#ifndef __COMSRV__H
#define __COMSRV__H

#include <Max.h>
#include <utilapi.h>
#include <bmmlib.h>
#include <guplib.h>
#include "resource.h"

#define DLLEXPORT __declspec(dllexport)

#define ISCOMREGISTERED	comgup->Control(0)
#define REGISTERCOM		comgup->Control(1)
#define UNREGISTERCOM	comgup->Control(2)

//-----------------------------------------------------------------------------
//-- The Utility Class

class COMsrv : public UtilityObj {

	public:

		GUP*		comgup;

		IUtil*		iu;
		Interface*	ip;
		HWND		hPanel;		

				COMsrv();

		//--	Class Implementation
		
		void	BeginEditParams	( Interface *ip, IUtil *iu );
		void	EndEditParams	( Interface *ip, IUtil *iu );
		void	DeleteThis		( ) { ; }

		//--	Local Defined
		
		void	UpdateButton	( HWND hWnd );
		void	Init			( HWND hWnd );
		void	Destroy			( HWND hWnd );
		void	Register		( HWND hWnd );

};

#endif

//-- EOF: comsrv.h ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\iflmgr\iflmgr.h ===
//-----------------------------------------------------------------------------
// -------------------
// File ....: iflmgr.h
// -------------------
// Author...: Gus J Grubba
// Date ....: March 1997
// Descr....: IFL Manager Utility
//
// History .: Mar, 18 1997 - Started
//            
//-----------------------------------------------------------------------------

#ifndef __IFLMGR__H
#define __IFLMGR__H

#include <Max.h>
#include <utilapi.h>
#include <bmmlib.h>
#include "resource.h"

#define DLLEXPORT __declspec(dllexport)

//-----------------------------------------------------------------------------
//-- List of Files

typedef struct tagSortTable {
	TCHAR file[MAX_PATH];
} SortTable;

//-----------------------------------------------------------------------------
//-- The Utility Class

class IFLMgr : public UtilityObj {

		TCHAR			root[MAX_PATH];
		TCHAR			iflfile[MAX_PATH];
		TCHAR			workpath[MAX_PATH];
		
		Tab<SortTable>	table;

		void	ToggleControl	( HWND hWnd, int control, BOOL state );
		BOOL	EditIFL			( HWND hWnd, TCHAR *filename );
		void	ExtractRoot		( TCHAR *filename );
		int		BuildFileList	( HWND hWnd, const TCHAR *mask );
		void	InitSpinner		( HWND hWnd, int ed, int sp, int v, int min, int max );
		void	DestroySpinner	( HWND hWnd, int sp );
		int		GetSpinnerValue	( HWND hWnd, int sp );

	public:

		IUtil*		iu;
		Interface*	ip;
		HWND		hPanel;		

				IFLMgr();

		//--	Class Implementation
		
		void	BeginEditParams	( Interface *ip, IUtil *iu );
		void	EndEditParams	( Interface *ip, IUtil *iu );
		void	DeleteThis		( ) {}

		//--	Local Defined
		
		void	Init			( HWND hWnd );
		void	Destroy			( HWND hWnd );
		void	Create			( HWND hWnd );
		void	Select			( HWND hWnd );
		void	Edit			( HWND hWnd );

};

#endif

//-- EOF: iflmgr.h ------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\comsrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by comsrv.rc
//
#define IDS_CLASS_DESC                  1
#define IDS_ALL_FILES                   2
#define IDS_IFL_FILES                   3
#define IDS_EDIT_IFL                    4
#define IDS_IMAGE_FILES                 5
#define IDS_CREATE_TITLE                6
#define IDS_OVERWRITE_TXT               7
#define IDS_OVERWRITE_TIT               8
#define IDS_LIBDESCRIPTION              9
#define IDS_REGISTER                    10
#define IDS_UNREGISTER                  11
#define IDS_DLG_TITLE                   12
#define IDS_CANT_FIND_GUP               13
#define IDD_COLORCLIP_PANEL             101
#define IDD_COLORCLIP_FLOATER           102
#define IDD_ASCIIOUT_PANEL              103
#define IDD_UTILTEST_PANEL              104
#define IDD_APPDATA_PANEL               105
#define IDD_COLLAPSE_PANEL              106
#define IDD_RAND_KEYS                   107
#define IDD_ORT_KEYS                    108
#define IDD_SEL_KEYS                    109
#define IDD_FOLLOW_PANEL                110
#define IDD_REFERENCE_PANEL             111
#define IDD_PRSLINKINFO                 165
#define IDC_COLORCLIP_NEWFLOAT          1000
#define IDC_ASCIIOUT_PICK               1002
#define IDC_TESTER_MAKEOBJECT           1003
#define IDC_TESTER_MAKEGROUP            1004
#define IDC_APPDATA_EDIT                1004
#define IDC_COMSRV_DLG                  1004
#define IDC_TESTER_GROUPOBJS            1005
#define IDC_APPDATA_GET                 1005
#define IDC_TESTER_OPENGROUP            1006
#define IDC_APPDATA_PUT                 1006
#define IDC_TESTER_CLOSEGROUP           1007
#define IDC_TESTER_EXPLODEGROUP         1008
#define IDC_TESTER_UNGROUP              1009
#define IDC_TESTER_SAVETOFILE           1010
#define IDC_TESTER_LOADFROMFILE         1011
#define IDC_TESTER_SETENV               1012
#define IDC_TESTER_SETWAV               1013
#define IDS_TESTER_ANIMON               1014
#define IDS_TESTER_ANIMOFF              1015
#define IDC_C_COLLAPSE                  1015
#define IDC_INHERIT_XTRANS              1015
#define IDS_TESTER_RENDER               1016
#define IDC_C_BOOL                      1016
#define IDC_INHERIT_YTRANS              1016
#define IDC_INHERIT_ZTRANS              1017
#define IDC_C_MULTIPLE                  1018
#define IDC_INHERIT_XROT                1018
#define IDC_C_SINGLE                    1019
#define IDC_INHERIT_YROT                1019
#define IDC_C_STACKRESULT               1020
#define IDC_INHERIT_ZROT                1020
#define IDC_C_MESH                      1021
#define IDC_INHERIT_XSCALE              1021
#define IDC_INHERIT_YSCALE              1022
#define IDC_INHERIT_ZSCALE              1023
#define IDC_C_COLLPASETOLABEL           1025
#define IDC_C_UNION                     1026
#define IDC_C_INTERSECTION              1027
#define IDC_C_SUBTRACTION               1028
#define IDC_SEL_NAME                    1029
#define IDC_RANDKEYS_POSTIMELABEL       1030
#define IDC_RANDKEYS_POSTIME            1031
#define IDC_RANDKEYS_POSTIMESPIN        1032
#define IDC_RANDKEYS_TIME               1033
#define IDC_RANDKEYS_NEGTIME            1034
#define IDC_RANDKEYS_NEGTIMESPIN        1035
#define IDC_RANDKEYS_NEGTIMELABEL       1036
#define IDC_RANDKEYS_POSVAL             1037
#define IDC_RANDKEYS_POSVALSPIN         1038
#define IDC_COLOR_SWATCH1               1039
#define IDC_RANDKEYS_POSVALLABEL        1039
#define IDC_COLOR_SWATCH2               1040
#define IDC_RANDKEYS_VAL                1040
#define IDC_COLOR_SWATCH3               1041
#define IDC_RANDKEYS_NEGVAL             1041
#define IDC_COLOR_SWATCH4               1042
#define IDC_RANDKEYS_NEGVALSPIN         1042
#define IDC_COLOR_SWATCH5               1043
#define IDC_RANDKEYS_NEGVALLABEL        1043
#define IDC_COLOR_SWATCH6               1044
#define IDC_RANDKEYS_TEXT               1044
#define IDC_COLOR_SWATCH7               1045
#define IDC_RANDKEYS_APPLY              1045
#define IDC_COLOR_SWATCH8               1046
#define IDC_ORTKEYS_BEFORE              1046
#define IDC_COLOR_SWATCH9               1047
#define IDC_ORTKEYS_BEFORESPIN          1047
#define IDC_COLOR_SWATCH10              1048
#define IDC_ORTKEYS_AFTER               1048
#define IDC_COLOR_SWATCH11              1049
#define IDC_ORTKEYS_AFTERSPIN           1049
#define IDC_COLOR_SWATCH12              1050
#define IDC_ORTKEYS_SAMPLES             1050
#define IDC_ORTKEYS_SAMPLESSPIN         1051
#define IDC_ORTKEYS_APPLY               1052
#define IDC_SELKEYS_START               1053
#define IDC_SELKEYS_STARTSPIN           1054
#define IDC_SELKEYS_END                 1055
#define IDC_SELKEYS_ENDSPIN             1056
#define IDC_SELKEYS_CLEAR               1057
#define IDC_FOLLOW_APPLY                1058
#define IDC_REF_OBJECT                  1059
#define IDC_COLOR_LOAD                  1060
#define IDC_COLOR_SAVE                  1061
#define IDC_SELECT                      1061
#define IDC_COLOR_SAVEAS                1062
#define IDC_CREATE                      1062
#define IDC_EDIT                        1063
#define IDC_FRAME                       1065
#define IDC_REGISTER                    1066
#define IDC_APPDATA_SLOTSPIN            1202
#define IDC_START_SP                    1202
#define IDC_APPDATA_SLOT                1203
#define IDC_START_ED                    1203
#define IDC_APPDATA_SLOTLABEL           1204
#define IDC_NTH_ED                      1204
#define IDC_NTH_SP                      1205
#define IDC_END_ED                      1208
#define IDC_END_SP                      1209
#define IDC_MULT_ED                     1210
#define IDC_MULT_SP                     1211
#define IDS_RB_ASCIIOBJECTOUT           30619
#define IDS_RB_ASCIIFILES               30620
#define IDS_RB_SAVEOBJECT               30621
#define IDS_RB_COLORCLIPBOARD           30622
#define IDS_RB_COLORNUM                 30623
#define IDS_RB_APPDATATEST              30624
#define IDS_RB_FILEEXISTS               30625
#define IDS_RB_COLLAPSE                 30626
#define IDS_RB_BOOLEAN                  30627
#define IDS_RB_MULTISEL                 30628
#define IDS_RB_NONESEL                  30629
#define IDS_RB_RANDKEYS                 30630
#define IDS_RANDKEYS_KEYTEXT            30631
#define IDS_RANDKEYS_TIMETEXT           30632
#define IDS_RB_RANDOMIZEKEYS            30633
#define IDS_RB_ORTKEYS                  30634
#define IDS_RB_CREATEORTKEYS            30635
#define IDS_RB_SELKEYS                  30636
#define IDS_RB_REFOBJ                   30637
#define IDS_RB_COLORCLIPFILES           30638
#define IDS_RB_LOADCOLOR                30639
#define IDS_RB_SAVECOLOR                30640
#define IDS_RB_CANTOPENFILE             30641
#define IDS_RB_COLORCLIPSHORT           30642
#define IDS_RB_LINKINFO                 30643
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1067
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\iflmgr\iflmgr.cpp ===
//-----------------------------------------------------------------------------
// ---------------------
// File ....: iflmgr.cpp
// ---------------------
// Author...: Gus J Grubba
// Date ....: March 1997
// Descr....: IFL Manager Utility
//
// History .: Mar, 18 1997 - Started
//            
//-----------------------------------------------------------------------------

#include "iflmgr.h"

//-- Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

#define NUMCONTROLS 9

static int ControlArray[] = {
	IDC_START_ED,
	IDC_START_SP,
	IDC_END_ED,
	IDC_END_SP,
	IDC_NTH_ED,
	IDC_NTH_SP,
	IDC_MULT_ED,
	IDC_MULT_SP,
	IDC_CREATE
};

//-----------------------------------------------------------------------------
// *> Sort IFL list

static BOOL backward = FALSE;

static int CompTable( const void *elem1, const void *elem2 ) {
	TCHAR *a = (TCHAR *)elem1;
	TCHAR *b = (TCHAR *)elem2;
	//if (backward)
	//	return(_tcscmp(b,a));
	//else
		return(_tcscmp(a,b));
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//-- DLL Declaration

BOOL WINAPI DllMain ( HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved ) {

	static BOOL controlsInit = FALSE;

	switch (fdwReason) {

		case DLL_PROCESS_ATTACH:
			if (hInst)
				return(FALSE);
			hInst = hinstDLL;
			if (!controlsInit) {
				controlsInit = TRUE;
				InitCustomControls(hInst);
				InitCommonControls();
			}
			break;

		case DLL_PROCESS_DETACH:
			hInst  = NULL;
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;

	}
			
	return (TRUE);

}

//-----------------------------------------------------------------------------
//-- Helper

TCHAR *GetString(int id) {
	static TCHAR buf[256];
	if (hInst)
		return LoadString(hInst, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

//-----------------------------------------------------------------------------
//-- The Utility Object

static IFLMgr iflManager;

//-----------------------------------------------------------------------------
//-- Interface Class Description

class IFLMgrClassDesc : public ClassDesc {
	public:
		int 			IsPublic		( ) {return 1;}
		void*			Create			( BOOL loading = FALSE) {return &iflManager;}
		const TCHAR*	ClassName		( ) {return GetString(IDS_CLASS_DESC);}
		SClass_ID		SuperClassID	( ) {return UTILITY_CLASS_ID;}
		Class_ID		ClassID			( ) {return Class_ID(0x129AD7F1,0);}
		const TCHAR* 	Category		( ) {return _T("");}
};

static IFLMgrClassDesc iflClassDesc;

//-----------------------------------------------------------------------------
// Max Interface

DLLEXPORT const TCHAR * LibDescription ( )  { 
	return GetString(IDS_LIBDESCRIPTION); 
}

DLLEXPORT int LibNumberClasses ( ) { 
	return 1; 
}

DLLEXPORT ClassDesc *LibClassDesc(int i) {
	  switch(i) {
		 case  0: return &iflClassDesc;	break;
		 default: return 0;				break;
	  }
}

DLLEXPORT ULONG LibVersion ( )  { 
	  return ( VERSION_3DSMAX ); 
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

//-----------------------------------------------------------------------------
// Dialogue Handler

BOOL CALLBACK iflDlgProc(	HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam ) {

	switch (msg) {
		
		case WM_INITDIALOG:
			iflManager.Init(hWnd);			
			break;
		
		case WM_DESTROY:
			iflManager.Destroy(hWnd);
			break;
		
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CREATE:
					iflManager.Create(hWnd);
					break;
				case IDC_EDIT:
					iflManager.Edit(hWnd);
					break;
				case IDC_SELECT:
					iflManager.Select(hWnd);
					break;
				case IDOK:
					iflManager.iu->CloseUtility();
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			iflManager.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}

	return TRUE; 

}

//-----------------------------------------------------------------------------
// #> IFLMgr::IFLMgr()

IFLMgr::IFLMgr() {
	iu			= NULL;
	ip			= NULL;	
	hPanel		= NULL;	
	workpath[0] = 0;
}

//-----------------------------------------------------------------------------
// #> IFLMgr::BeginEditParams()

void IFLMgr::BeginEditParams( Interface *ip, IUtil *iu ) {
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInst,
		MAKEINTRESOURCE(IDC_IFLMGR_DLG),
		iflDlgProc,
		GetString(IDS_CLASS_DESC),
		0);
}
	
//-----------------------------------------------------------------------------
// #> IFLMgr::EndEditParams()

void IFLMgr::EndEditParams( Interface *ip,IUtil *iu ) {	
	this->iu	= NULL;
	this->ip	= NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel		= NULL;
}

//-----------------------------------------------------------------------------
// #> IFLMgr::Init()

void IFLMgr::Init ( HWND hWnd ) {
	for (int i = 0; i < NUMCONTROLS; i++) 
		ToggleControl(hWnd,ControlArray[i],FALSE);
}

//-----------------------------------------------------------------------------
// #> IFLMgr::Destroy()

void IFLMgr::Destroy ( HWND hWnd ) {
	DestroySpinner(hWnd,IDC_START_SP);
	DestroySpinner(hWnd,IDC_END_SP);
	DestroySpinner(hWnd,IDC_NTH_SP);
	DestroySpinner(hWnd,IDC_MULT_SP);
}

//-----------------------------------------------------------------------------
// #> IFLMgr::Create()

void IFLMgr::Create ( HWND hWnd ) {

	if (table.Count() < 2)
		return;

	FilterList filterList;
	filterList.Append( GetString(IDS_IFL_FILES));
	filterList.Append( _T("*.ifl"));
	filterList.Append( _T(""));
	filterList.Append( _T(""));

	OPENFILENAME ofn;
	memset(&ofn, 0, sizeof(OPENFILENAME));

	TCHAR filename[MAX_PATH];
	filename[0] = 0;
	ofn.lpstrFile		= filename;
	ofn.nMaxFile		= MAX_PATH;

	ofn.lpstrFilter		= filterList;
	ofn.lpstrTitle		= GetString(IDS_CREATE_TITLE);
	ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
	ofn.lStructSize		= sizeof(OPENFILENAME);
	ofn.hwndOwner		= hWnd;

	if (workpath[0])
		ofn.lpstrInitialDir	= workpath;
	else
		ofn.lpstrInitialDir	= ip->GetMapDir(0);

	while (1) {
		
		if (GetSaveFileName(&ofn)) {

			//-- Make sure there is an extension ----------

			int l = _tcslen(ofn.lpstrFile);
			if (!l)
				return;
			if (l==ofn.nFileExtension || !ofn.nFileExtension) 
			_tcscat(ofn.lpstrFile,_T(".ifl"));  
			
			//-- Check for file overwrite -----------------

			if (BMMIsFile(ofn.lpstrFile)) {
				TCHAR text[MAX_PATH];
				wsprintf(text,GetString(IDS_OVERWRITE_TXT),ofn.lpstrFile);
				TSTR tit = GetString(IDS_OVERWRITE_TIT);
				if (MessageBox(hWnd,text,tit,MB_APPLMODAL | MB_ICONQUESTION | MB_YESNO) != IDYES)
					continue;
			}
			
			//-- Create IFL file --------------------------

			FILE *f = _tfopen(ofn.lpstrFile,"wt");
			if (f) {

				//-- Get Arguments ------------------------

				int start	= max(GetSpinnerValue(hWnd,IDC_START_SP),0);
				int end		= min(GetSpinnerValue(hWnd,IDC_END_SP),table.Count()-1);
				int nth		= GetSpinnerValue(hWnd,IDC_NTH_SP);
				int mult	= GetSpinnerValue(hWnd,IDC_MULT_SP);

				if (start > end) {
					int t = start;
					start = end;
					end = t;
					backward = TRUE;
				} else
					backward = FALSE;

				table.Sort(CompTable);

				//-- Append list of image files -----------

				if (backward) {
					for (int i = end; i >= start; i -= nth ) {
						if (mult > 1)
							fprintf(f,"%s %d\n",table[i].file,mult);
						else
							fprintf(f,"%s\n",table[i].file);
					}
				} else {
					for (int i = start; i <= end; i += nth ) {
						if (mult > 1)
							fprintf(f,"%s %d\n",table[i].file,mult);
						else
							fprintf(f,"%s\n",table[i].file);
					}
				}

				fclose(f);
				BMMSplitFilename(ofn.lpstrFile,workpath,NULL,NULL);

			}

			//-- Kaput ------------------------------------
			
			//iflManager.iu->CloseUtility();

		}

		break;
	
	}

}

//-----------------------------------------------------------------------------
// #> IFLMgr::Select()

void IFLMgr::Select ( HWND hWnd ) {

#if 0

	FilterList filterList;
	filterList.Append( GetString(IDS_ALL_FILES));
	filterList.Append( _T("*.*"));
	filterList.Append( _T(""));
	filterList.Append( _T(""));

	OPENFILENAME ofn;
	memset(&ofn, 0, sizeof(OPENFILENAME));
	TCHAR filename[MAX_PATH];
	filename[0] = 0;

	ofn.lpstrFilter		= filterList;
	ofn.lpstrTitle		= GetString(IDS_IMAGE_FILES);
	ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST;
	ofn.lStructSize		= sizeof(OPENFILENAME);
	ofn.hwndOwner		= hWnd;
	ofn.lpstrFile		= filename;
	ofn.nMaxFile		= MAX_PATH;

	if (workpath[0])
		ofn.lpstrInitialDir	= workpath;
	else
		ofn.lpstrInitialDir	= ip->GetMapDir(0);

	if (GetOpenFileName(&ofn)) {
		
		if (!BuildFileList(hWnd,ofn.lpstrFile)) 
			return;
		
		TCHAR title[MAX_PATH];
		wsprintf(title,_T(" %s "),root);
		SetDlgItemText(hWnd,IDC_FRAME,title);

		for (int i = 0; i < NUMCONTROLS; i++) 
			ToggleControl(hWnd,ControlArray[i],TRUE);
		
		int c = table.Count();
		InitSpinner(hWnd,IDC_START_ED,	IDC_START_SP,	0,0,c-1);
		InitSpinner(hWnd,IDC_END_ED,	IDC_END_SP,		c-1,0,c-1);
		InitSpinner(hWnd,IDC_NTH_ED,	IDC_NTH_SP,		1,1,c-1);
		InitSpinner(hWnd,IDC_MULT_ED,	IDC_MULT_SP,	1,1,9999);

		BMMSplitFilename(ofn.lpstrFile,workpath,NULL,NULL);
		
	}

#endif

	BitmapInfo fbi;
	TCHAR path[MAX_PATH];

	if (workpath[0])
		strcpy(path,workpath);
	else
		strcpy(path,ip->GetMapDir(0));

	BMMAppendSlash(path);
	fbi.SetName(path);
	
	if (TheManager->SelectFileInput(&fbi,hWnd)) {

		//-- Check for Valid File

		int idx = TheManager->ioList.FindDeviceFromFilename(fbi.Name());
		if (idx == -1) {
			TCHAR text[MAX_PATH];
			wsprintf(text,GetString(IDS_BAD_FILETYPE),fbi.Name());
			TSTR tit = GetString(IDS_CLASS_DESC);
			MessageBox(hWnd,text,tit,MB_APPLMODAL | MB_ICONSTOP | MB_OK);
			return;
		}

		if (TheManager->ioList[idx].TestCapabilities(BMMIO_MULTIFRAME) ||
			TheManager->ioList[idx].TestCapabilities(BMMIO_IFL)) {
			TCHAR text[MAX_PATH];
			wsprintf(text,GetString(IDS_BAD_FILETYPE),fbi.Name());
			TSTR tit = GetString(IDS_CLASS_DESC);
			MessageBox(hWnd,text,tit,MB_APPLMODAL | MB_ICONSTOP | MB_OK);
			return;
		}

		if (!BuildFileList(hWnd,fbi.Name()) || table.Count() == 1) {
			if (table.Count())
				table.Delete(0,table.Count());
			TSTR text	= GetString(IDS_NOLISTCREATED);
			TSTR tit	= GetString(IDS_CLASS_DESC);
			MessageBox(hWnd,text,tit,MB_APPLMODAL | MB_ICONSTOP | MB_OK);
			return;
		}

		TCHAR title[MAX_PATH];
		wsprintf(title,_T(" %s "),root);
		SetDlgItemText(hWnd,IDC_FRAME,title);

		for (int i = 0; i < NUMCONTROLS; i++) 
			ToggleControl(hWnd,ControlArray[i],TRUE);
		
		int c = table.Count();
		InitSpinner(hWnd,IDC_START_ED,	IDC_START_SP,	0,0,c-1);
		InitSpinner(hWnd,IDC_END_ED,	IDC_END_SP,		c-1,0,c-1);
		InitSpinner(hWnd,IDC_NTH_ED,	IDC_NTH_SP,		1,1,c-1);
		InitSpinner(hWnd,IDC_MULT_ED,	IDC_MULT_SP,	1,1,9999);

		BMMSplitFilename(fbi.Name(),workpath,NULL,NULL);
		return;
	}

}

//-----------------------------------------------------------------------------
// #> IFLMgr::Edit()

void IFLMgr::Edit ( HWND hWnd ) {

	FilterList filterList;
	filterList.Append( GetString(IDS_IFL_FILES));
	filterList.Append( _T("*.ifl"));
	filterList.Append( GetString(IDS_ALL_FILES));
	filterList.Append( _T("*.*"));
	filterList.Append( _T(""));
	filterList.Append( _T(""));

	OPENFILENAME ofn;
	memset(&ofn, 0, sizeof(OPENFILENAME));
	TCHAR filename[MAX_PATH];
	filename[0] = 0;

	ofn.lpstrFilter		= filterList;
	ofn.lpstrTitle		= GetString(IDS_EDIT_IFL);
	ofn.Flags			= OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;
	ofn.lStructSize		= sizeof(OPENFILENAME);
	ofn.hwndOwner		= hWnd;
	ofn.lpstrFile		= filename;
	ofn.nMaxFile		= MAX_PATH;

	if (workpath[0])
		ofn.lpstrInitialDir	= workpath;
	else
		ofn.lpstrInitialDir	= ip->GetMapDir(0);

	if (GetOpenFileName(&ofn)) {
		EditIFL( hWnd, ofn.lpstrFile );
		BMMSplitFilename(ofn.lpstrFile,workpath,NULL,NULL);
	}

}

//-----------------------------------------------------------------------------
// #> IFLMgr::ToggleControl()

void IFLMgr::ToggleControl( HWND hWnd, int control, BOOL state ) {
	HWND hDlg = GetDlgItem(hWnd,control);
	EnableWindow(hDlg,state);
}
	
//-----------------------------------------------------------------------------
// #> IFLMgr::EditIFL()

BOOL IFLMgr::EditIFL( HWND hWnd, TCHAR *filename ) {

	//-- Define Command Line ------------------------------

	// Use default editor
	if ((unsigned int)ShellExecute(NULL, "open", filename, NULL, NULL, SW_SHOWNORMAL) > 32) {
		return TRUE; 
		}

	// Default to notepad if no default viewer.
	TCHAR cmd[512];
	wsprintf(cmd,_T("notepad.exe \"%s\""),filename);

	//-- Startup Info Structure ---------------------------

	PROCESS_INFORMATION process;
	STARTUPINFO	si;
	BOOL res = FALSE;

	memset(&si,0,sizeof(STARTUPINFO));
	
	si.cb  			= sizeof(STARTUPINFO);
	si.dwFlags		= STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	si.wShowWindow	= SW_SHOWDEFAULT;
	si.hStdError	= NULL;

	//-- Start the Thing ----------------------------------

	res = CreateProcess(
		  (LPCTSTR)	NULL,						  //-- Pointer	to	name of executable module 
		  (LPTSTR)	cmd,  						  //-- Pointer	to	command line string
		  (LPSECURITY_ATTRIBUTES)	NULL,		  //-- Pointer	to	process security attributes 
		  (LPSECURITY_ATTRIBUTES)	NULL,		  //-- Pointer	to	thread security attributes	
		  FALSE,								  //-- Handle inheritance flag 
		  (DWORD)0,								  //-- Creation flags 
		  (LPVOID)NULL,							  //-- Pointer	to	new environment block 
		  (LPCTSTR)NULL,						  //-- Pointer	to	current directory	name 
		  (LPSTARTUPINFO)&si,					  //-- Pointer	to	STARTUPINFO	
		  (LPPROCESS_INFORMATION)&process		  //-- Pointer	to	PROCESS_INFORMATION	
	);		 
	
	if	(!res)
		return (FALSE);
	
	CloseHandle(process.hThread);
	return (TRUE);

}

//-----------------------------------------------------------------------------
// *> IsNumeric()

static BOOL IsNumeric( TCHAR *filename ) {
	TCHAR *p = filename;
	 while (*(p++)) {
		if (*p >= _T('0') && *p <= _T('9'))
			return TRUE;
		}
	return FALSE;
}

//-----------------------------------------------------------------------------
// #> IFLMgr::BuildFileList()

int	IFLMgr::BuildFileList(HWND hWnd, const TCHAR *masktext ) {

	TCHAR mask[MAX_PATH];
	strcpy(mask,masktext);

	if (table.Count())
		table.Delete(0,table.Count());

	//-- Check for Wild Cards

	TCHAR tpath[MAX_PATH],tfile[MAX_PATH],ext[_MAX_EXT];
	BMMSplitFilename(mask,tpath,tfile,ext);
	BMMAppendSlash(tpath);

	int i = 0;
	while (tfile[i++]) {
		if (tfile[i] <= _T('9') && tfile[i] >= _T('0'))
			tfile[i] = _T('?');
	}
	wsprintf(mask,_T("%s%s%s"),tpath,tfile,ext);
	
	if (!_tcsstr(mask,_T("*")) && !_tcsstr(mask,_T("?")))
		return 0;

	//-- Look for matches --------------------------------

	HANDLE findhandle;
	WIN32_FIND_DATA file;
	findhandle = FindFirstFile(mask,&file);
	FindClose(findhandle);

	if (findhandle == INVALID_HANDLE_VALUE)
		return 0;

	//-- Load and sort list of files ----------------------

	findhandle = FindFirstFile(mask,&file);
	do {
		if (!IsNumeric(file.cFileName))
			continue;
		table.Append(1,(SortTable *)(void *)&file.cFileName);
	} while (FindNextFile(findhandle,&file));

	if (table.Count() < 2)
		return 0;

	//-- Build Filename -----------------------------------

	ExtractRoot(table[0].file);
	wsprintf(iflfile,_T("%s%s.ifl"),tpath,root);

	return (table.Count());
	
}

//-----------------------------------------------------------------------------
// #> IFLMgr::ExtractRoot()

void IFLMgr::ExtractRoot( TCHAR *filename ) {
	TCHAR dr[_MAX_DRIVE],di[_MAX_DIR],fn[_MAX_FNAME],ex[_MAX_EXT];
	_splitpath(filename,dr,di,fn,ex);
	int i = 0;
	while (fn[i++]) {
		if (fn[i] >= _T('0') && fn[i] <= _T('9')) {
			fn[i]=0;
			break;
		}
	}
	_makepath(root,dr,di,fn,NULL);
	_tcslwr(root);
}

//-----------------------------------------------------------------------------
// #> IFLMgr::InitSpinner()

void IFLMgr::InitSpinner( HWND hWnd, int ed, int sp, int v, int minv, int maxv ) {
	ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,sp));
	if (blendspin) {
		blendspin->LinkToEdit(GetDlgItem(hWnd,ed),EDITTYPE_INT);
		blendspin->SetLimits(minv,maxv,FALSE);
		blendspin->SetValue(v,FALSE);
	}
}

//-----------------------------------------------------------------------------
// #> IFLMgr::DestroySpinner()

void IFLMgr::DestroySpinner( HWND hWnd, int sp ) {
	ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,sp));
	if (blendspin)
		ReleaseISpinner(blendspin);
}

//-----------------------------------------------------------------------------
// #> IFLMgr::GetSpinnerValue()

int IFLMgr::GetSpinnerValue( HWND hWnd, int sp ) {
	ISpinnerControl	*blendspin = GetISpinner(GetDlgItem(hWnd,sp));
	if (blendspin)
		return (blendspin->GetIVal());
	else
		return 0;
}

//-- EOF: iflmgr.cpp ----------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\iflmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by iflmgr.rc
//
#define IDS_CLASS_DESC                  1
#define IDS_ALL_FILES                   2
#define IDS_IFL_FILES                   3
#define IDS_EDIT_IFL                    4
#define IDS_IMAGE_FILES                 5
#define IDS_CREATE_TITLE                6
#define IDS_OVERWRITE_TXT               7
#define IDS_OVERWRITE_TIT               8
#define IDS_LIBDESCRIPTION              9
#define IDS_NO_SEQUENCE                 10
#define IDS_BAD_FILETYPE                11
#define IDS_NOLISTCREATED               12
#define IDC_IFLMGR_DLG                  1004
#define IDC_SELECT                      1061
#define IDC_CREATE                      1062
#define IDC_EDIT                        1063
#define IDC_FRAME                       1065
#define IDC_START_SP                    1202
#define IDC_START_ED                    1203
#define IDC_NTH_ED                      1204
#define IDC_NTH_SP                      1205
#define IDC_END_ED                      1208
#define IDC_END_SP                      1209
#define IDC_MULT_ED                     1210
#define IDC_MULT_SP                     1211
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1066
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\MapPath\mappath.cpp ===
/**********************************************************************
 *<
	FILE..........: MapPath.cpp

	DESCRIPTION...: Bitmap Path Editor

	CREATED BY....: Christer Janson - Kinetix

	HISTORY.......: Created Thursday, October 16, 1997

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "MapPath.h"

HINSTANCE		hInstance;
int				controlsInit = FALSE;
static TCHAR*	useFolder;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}


__declspec( dllexport ) const TCHAR* LibDescription()
{
	return _T("Map path editor utility (Kinetix)");
}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetRefCheckDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

static RefCheck theRefCheck;

class RefCheckClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theRefCheck;}
	const TCHAR *	ClassName() {return _T("MapPath Editor");}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return REFCHECK_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static RefCheckClassDesc RefCheckDesc;
ClassDesc* GetRefCheckDesc() {return &RefCheckDesc;}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}


static BOOL CALLBACK RefCheckDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theRefCheck.Init(hWnd);
			break;

		case WM_DESTROY:
			theRefCheck.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSEBUTTON:
					theRefCheck.iu->CloseUtility();
					break;
				case IDC_CHECKDEP:
					theRefCheck.DoDialog();
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theRefCheck.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}
	return TRUE;
}	

RefCheck::RefCheck()
{
	iu		= NULL;
	ip		= NULL;	
	hPanel	= NULL;
	hDialog	= NULL;
	//pDib	= NULL;
}

RefCheck::~RefCheck()
{
	if (hDialog) {
		DestroyWindow(hDialog);
	}
}

// The dialogprocedure for the modeless dialogbox
BOOL CALLBACK dlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	RefCheck* util = (RefCheck*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			{
				RECT rect;
				util = (RefCheck*)lParam;
				util->hDialog = hWnd;
				SetWindowLong(hWnd,GWL_USERDATA,lParam);
				CenterWindow(hWnd, util->ip->GetMAXHWnd());
				util->CheckDependencies();
				util->EnableEntry(hWnd, FALSE, 0);

				GetWindowRect(hWnd, &rect);
				util->SetMinDialogSize((rect.right - rect.left)*2/3, rect.bottom - rect.top);
			}
			break;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDCANCEL:
				case IDOK:
					//DestroyWindow(hWnd);
					EndDialog(hWnd, 1);
					break;
				case IDC_SETPATH:
					theRefCheck.Update();
					break;
				case IDC_STRIP_SELECTED:
					theRefCheck.StripSelected();
					break;
				case IDC_STRIP_ALL:
					theRefCheck.StripAll();
					break;
				case IDC_INFO:
					theRefCheck.ShowInfo();
					break;
				case IDC_COPYMAPS:
					theRefCheck.CopyMaps();
					break;
				case IDC_MISSING:
					theRefCheck.SelectMissing();
					break;
				case IDC_ACTUALPATH:
					theRefCheck.SetActualPath();
					break;
				case IDC_DEPLIST:
					if (HIWORD(wParam) == LBN_DBLCLK) {
						theRefCheck.ShowInfo();
					}
					else if (HIWORD(wParam) == LBN_SELCHANGE) {
						theRefCheck.DoSelection();
					}
					break;
				case IDC_BROWSE:
					theRefCheck.BrowseDirectory();
					break;
				case IDC_PATHEDIT:
					// If we get a setfocus message, disable accelerators
					if(HIWORD(wParam) == EN_SETFOCUS)
						DisableAccelerators();
					// Otherwise enable them again
					else if(HIWORD(wParam) == EN_KILLFOCUS) {
						EnableAccelerators();
					}
					break;
			}
			break;
		case WM_CLOSE:
			//DestroyWindow(hWnd);
			EndDialog(hWnd, 1);
			break;
		case WM_DESTROY:
			util->hDialog = NULL;
			break;
		case WM_WINDOWPOSCHANGING:
			{
				if(IsIconic(hWnd)) {
					return FALSE;
				}

				// prevent the window from stretching horizontally
				WINDOWPOS *wp = (WINDOWPOS*)lParam;
				if (wp->cx < util->GetMinDialogWidth()) {
					wp->cx = util->GetMinDialogWidth();
				}
				if (wp->cy < util->GetMinDialogHeight()) {
					wp->cy = util->GetMinDialogHeight();
				}

				break;
			}
		case WM_SIZE:
			util->ResizeWindow(LOWORD(lParam), HIWORD(lParam));
			break;
		default:
			return FALSE;
	}
	return TRUE;
}

void RefCheck::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;

	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_PANEL),
		RefCheckDlgProc,
		GetString(IDS_PANELTITLE),
		0);
}
	
void RefCheck::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void RefCheck::Init(HWND hWnd)
{
	CheckDlgButton(hWnd, IDC_INCLUDE_MEDIT, BST_CHECKED);
}

void RefCheck::Destroy(HWND hWnd)
{
}

void RefCheck::DoDialog()
{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_MAINDIALOG),
		ip->GetMAXHWnd(),
		dlgProc,
		(LPARAM)this);
}

// My own version of ScreenToClient (taking Rect instead of Point)
void ScreenToClient(HWND hWnd, RECT* rect)
{
	POINT pt;
	pt.x = rect->left;
	pt.y = rect->top;
	ScreenToClient(hWnd, &pt);
	rect->left = pt.x;
	rect->top = pt.y;
	pt.x = rect->right;
	pt.y = rect->bottom;
	ScreenToClient(hWnd, &pt);
	rect->right = pt.x;
	rect->bottom = pt.y;
}

// Resize the window
void RefCheck::ResizeWindow(int x, int y)
{
	HWND	pCtrl;
	RECT	lbRect;
	RECT	prevCtrlRect;
	int		offset;
	BOOL	bRepaint = FALSE;

	// Move the OK button
	pCtrl = GetDlgItem(hDialog, IDCANCEL);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.right - lbRect.left;
	lbRect.left = x-offset - 10;
	lbRect.right = lbRect.left + offset;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Move the Info button
	pCtrl = GetDlgItem(hDialog, IDC_INFO);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.bottom - lbRect.top;
	lbRect.top = prevCtrlRect.top+28;
	lbRect.bottom = lbRect.top + offset;
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Move the CopyMaps button
	pCtrl = GetDlgItem(hDialog, IDC_COPYMAPS);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.bottom - lbRect.top;
	lbRect.top = prevCtrlRect.top+41;
	lbRect.bottom = lbRect.top + offset;
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Path editbox
	pCtrl = GetDlgItem(hDialog, IDC_PATHEDIT);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.bottom - lbRect.top;
	lbRect.top = y - offset - 6;
	lbRect.bottom = lbRect.top + offset;
	lbRect.right = prevCtrlRect.left - 35;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Browse button
	pCtrl = GetDlgItem(hDialog, IDC_BROWSE);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.bottom - lbRect.top;
	lbRect.top = prevCtrlRect.top;
	lbRect.bottom = lbRect.top + offset;
	lbRect.left = prevCtrlRect.right + 3;
	lbRect.right = prevCtrlRect.right + 30;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);


	// Path title text
	pCtrl = GetDlgItem(hDialog, IDC_PATHTITLE);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	offset = lbRect.bottom - lbRect.top;
	lbRect.top = prevCtrlRect.top+4;
	lbRect.bottom = lbRect.top + offset;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);

	// Resize the listbox
	pCtrl = GetDlgItem(hDialog, IDC_DEPLIST);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.bottom = prevCtrlRect.top - 3;
	lbRect.right = prevCtrlRect.right+30;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);

	// Load the Close btn rect
	GetWindowRect(GetDlgItem(hDialog, IDCANCEL), &prevCtrlRect);
	ScreenToClient(hDialog, &prevCtrlRect);

	// SetMap button
	pCtrl = GetDlgItem(hDialog, IDC_SETPATH);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	// Load the edit box rect
	GetWindowRect(GetDlgItem(hDialog, IDC_PATHEDIT), &prevCtrlRect);
	ScreenToClient(hDialog, &prevCtrlRect);
	lbRect.top = prevCtrlRect.top;
	lbRect.bottom = prevCtrlRect.bottom;
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Strip all button
	pCtrl = GetDlgItem(hDialog, IDC_STRIP_ALL);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	offset = lbRect.bottom - lbRect.top;
	lbRect.bottom = prevCtrlRect.top - 4;
	lbRect.top = lbRect.bottom - offset;	
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Strip selected button
	pCtrl = GetDlgItem(hDialog, IDC_STRIP_SELECTED);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	offset = lbRect.bottom - lbRect.top;
	lbRect.bottom = prevCtrlRect.top - 4;
	lbRect.top = lbRect.bottom - offset;	
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Set Actual Path
	pCtrl = GetDlgItem(hDialog, IDC_ACTUALPATH);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	offset = lbRect.bottom - lbRect.top;
	lbRect.bottom = prevCtrlRect.top - 4;
	lbRect.top = lbRect.bottom - offset;	
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);
	prevCtrlRect = lbRect;

	// Missing Maps
	pCtrl = GetDlgItem(hDialog, IDC_MISSING);
	GetWindowRect(pCtrl, &lbRect);
	ScreenToClient(hDialog, &lbRect);
	lbRect.right = prevCtrlRect.right;
	lbRect.left = prevCtrlRect.left;
	offset = lbRect.bottom - lbRect.top;
	lbRect.bottom = prevCtrlRect.top - 4;
	lbRect.top = lbRect.bottom - offset;	
	MoveWindow(pCtrl, lbRect.left, lbRect.top, lbRect.right-lbRect.left, lbRect.bottom-lbRect.top, bRepaint);


	InvalidateRect(hDialog, NULL, TRUE);
}

class SceneAPIFindSceneProc : public DependentEnumProc {
	public:
		SceneAPIFindSceneProc(ReferenceMaker** anim) {
			scene = anim;
			*scene = NULL;
		}
		int proc(ReferenceMaker *ref) {
			switch (ref->SuperClassID()) {
				case REF_MAKER_CLASS_ID:
					if (ref->ClassID() == Class_ID(THE_SCENE_CLASS_ID, 0)) {
						*scene = ref;
					}
					break;
			}
			return 0;
		}
	private:
		ReferenceMaker** scene;
};

class TexMapEnum : public AnimEnum {
	public:	
		TexMapEnum(HWND dlg, Animatable* medit) : AnimEnum(SCOPE_ALL)
		{
			hDialog = dlg;
			mtledit = medit;
		}
		int proc(Animatable *anim, Animatable *client, int subNum)
		{
			if (anim == mtledit) {
				return ANIM_ENUM_STOP;
			}
			else {
				if (anim->SuperClassID() == TEXMAP_CLASS_ID) {
					if (anim->ClassID() == Class_ID(BMTEX_CLASS_ID, 0)) {
						BitmapTex* bmt = (BitmapTex*)anim;
						AddTexmap(bmt);
					}
				}
				return ANIM_ENUM_PROCEED;
			}
		}

		BOOL AddTexmap(BitmapTex* bmt)
		{
			int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
			for (int i=0; i < numItems; i++) {
				DWORD ptr = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
				if (ptr == (DWORD)bmt) {
					return FALSE;
				}
			}

			int idx = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_ADDSTRING, 0, (LPARAM)bmt->GetMapName());
			SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_SETITEMDATA, idx, (LPARAM)bmt);

			return TRUE;
		}
	private:
	HWND hDialog;
	Animatable* mtledit;
};


void RefCheck::CheckDependencies()
{
	ReferenceMaker* scene;

	scene = NULL;
	SceneAPIFindSceneProc dep(&scene);
	ip->GetRootNode()->EnumDependents(&dep);

	int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
	int numSel = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);
	int* selArray = new int[numSel];
	SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELITEMS, numSel, (LPARAM)selArray);

	SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_RESETCONTENT, 0, 0);

	Animatable* pMEdit = NULL;
	if (!GetIncludeMedit()) {
		// Yikes!
		pMEdit = scene->SubAnim(7);
	}

	TexMapEnum texmapEnum(hDialog, pMEdit);
	scene->EnumAnimTree(&texmapEnum,NULL,0);

	if (GetIncludeMatLib()) {
		MtlBaseLib matlib = ip->GetMaterialLibrary();
		matlib.EnumAnimTree(&texmapEnum,NULL,0);
	}

	if (numItems == SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0)) {
		for (int i=0; i<numSel; i++) {
			SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_SETSEL, TRUE, selArray[i]);
		}
	}
	delete [] selArray;

	numSel = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);
	if (numSel) {
		EnableEntry(hDialog, TRUE, numSel);
	}
	else {
		EnableEntry(hDialog, FALSE, numSel);
	}
}



void RefCheck::Update()
{
	BitmapTex*	bmTex = NULL;
	TCHAR		newPath[MAX_PATH];

	int numSel		= SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);
	int numEntries	= SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);

	SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_GETTEXT, MAX_PATH, (LPARAM)newPath);

	if (_tcslen(newPath) == 0) {
		return;
	}

	if (numSel == 1) {
		int idx = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCURSEL, 0, 0);
		if (idx != -1) {
			bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, idx, 0);

			if (bmTex) {
				SetPath(newPath, bmTex);
				bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)"");
			}
		}
	}
	else {
		for (int idx=0; idx < numEntries; idx++) {
			if (SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSEL, idx, 0) > 0) {
				bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, idx, 0);
				if (bmTex) {
					SetPath(newPath, bmTex);
					bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
					SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)"");
				}
			}
		}
	}

	CheckDependencies();
}

void RefCheck::StripSelected()
{
	TSTR szTitle = GetString(IDS_STRIPTITLE);
	if (MessageBox(hDialog, GetString(IDS_STRIPWARNING), szTitle, MB_OKCANCEL | MB_ICONWARNING) != IDOK) {
		return;
	}

	int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
	for (int i=0; i < numItems; i++) {
		if (SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSEL, i, 0) > 0) {
			BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
			if (bmTex) {
				TCHAR* texName = bmTex->GetMapName();
				if (texName && _tcscmp(texName, _T(""))) {
					TCHAR	newName[MAX_PATH];
					TCHAR	drive[_MAX_DRIVE];
					TCHAR	dir[_MAX_DIR];
					TCHAR	fname[_MAX_FNAME];
					TCHAR	ext[_MAX_EXT];
					_splitpath(texName, drive, dir, fname, ext);
					_tcscpy(newName, fname);
					_tcscat(newName, ext);
					bmTex->SetMapName(newName);
					bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
				}
			}
		}
	}

	CheckDependencies();
}

void RefCheck::StripAll()
{
	TSTR szTitle = GetString(IDS_STRIPTITLE);
	if (MessageBox(hDialog, GetString(IDS_STRIPWARNING), szTitle, MB_OKCANCEL | MB_ICONWARNING) != IDOK) {
		return;
	}

	int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
	for (int i=0; i < numItems; i++) {
		BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
		if (bmTex) {
			TCHAR* texName = bmTex->GetMapName();
			if (texName && _tcscmp(texName, _T(""))) {
				TCHAR	newName[MAX_PATH];
				TCHAR	drive[_MAX_DRIVE];
				TCHAR	dir[_MAX_DIR];
				TCHAR	fname[_MAX_FNAME];
				TCHAR	ext[_MAX_EXT];
				_splitpath(texName, drive, dir, fname, ext);
				_tcscpy(newName, fname);
				_tcscat(newName, ext);
				bmTex->SetMapName(newName);
				bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		}
	}

	CheckDependencies();
}

void RefCheck::DoSelection()
{
	TCHAR	bmName[MAX_PATH];

	int numSel		= SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);
	int numEntries	= SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);

	if (numSel == 0) {
		EnableEntry(hDialog, FALSE, 0);
		SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)"");
	}
	else if (numSel == 1) {
		EnableEntry(hDialog, TRUE, 1);
		int idx = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCURSEL, 0, 0);
		if (idx != -1) {
			SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETTEXT, idx, (LPARAM)bmName);
			StripMapName(bmName);
			SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)bmName);
			BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, idx, 0);
			if (bmTex) {
				SendMessage(GetDlgItem(hDialog, IDC_MAPNAME), WM_SETTEXT, 0, (LPARAM)(char*)bmTex->GetName());
			}
		}
	}
	else {
		EnableEntry(hDialog, TRUE, numSel);
		SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)"");
	}
}

void RefCheck::SetPath(TCHAR* path, BitmapTex* map)
{
	TCHAR*	texName = map->GetMapName();

	if (_tcscmp(texName, _T("")) == 0) {
		return;
		}

	TCHAR	newName[MAX_PATH];
	TCHAR	drive[_MAX_DRIVE];
	TCHAR	dir[_MAX_DIR];
	TCHAR	fname[_MAX_FNAME];
	TCHAR	ext[_MAX_EXT];
	_splitpath(texName, drive, dir, fname, ext);

	_tcscpy(newName, path);
	if (path[_tcslen(path)-1] != _T('\\')) {
		_tcscat(newName, _T("\\"));
	}
	_tcscat(newName, fname);
	_tcscat(newName, ext);

	map->SetMapName(newName);
}

void RefCheck::StripMapName(TCHAR* path)
{
	TCHAR	drive[_MAX_DRIVE];
	TCHAR	dir[_MAX_DIR];
	TCHAR	fname[_MAX_FNAME];
	TCHAR	ext[_MAX_EXT];
	_splitpath(path, drive, dir, fname, ext);

	_tcscpy(path, drive);
	_tcscat(path, dir);
}

void RefCheck::EnableEntry(HWND hWnd, BOOL bEnable, int numSel)
{
	EnableWindow(GetDlgItem(hWnd, IDC_PATHEDIT), bEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_BROWSE), bEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_STRIP_SELECTED), bEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_SETPATH), bEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_COPYMAPS), bEnable);
	EnableWindow(GetDlgItem(hWnd, IDC_ACTUALPATH), bEnable);

	// Only enable this is one single entry is selected
	if (bEnable && numSel ==1) {
		EnableWindow(GetDlgItem(hWnd, IDC_INFO), TRUE);
	}
	else {
		EnableWindow(GetDlgItem(hWnd, IDC_INFO), FALSE);
	}

	EnableWindow(GetDlgItem(hWnd, IDC_MISSING), TRUE);
}

void RefCheck::BrowseDirectory()
{
	TCHAR newPath[MAX_PATH];

	if (ChooseDir("Select New Path", newPath)) {
		SendMessage(GetDlgItem(hDialog, IDC_PATHEDIT), WM_SETTEXT, 0, (LPARAM)newPath);
	}
}

// CCJ 10/15/99 
// Switched from custom path selection dialog to the standard one.
/*
static unsigned int	CALLBACK FileOpenHookProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM	lParam) 
{
	static int fakeDblClk;

	switch (message) 
	{
		case WM_INITDIALOG: 
			useFolder[0] = _T('\0');
			fakeDblClk = 0;
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			return	1;
		  
		case WM_COMMAND:
			switch (LOWORD(wParam)) 
			{
				case IDC_MY_OK:
					GetDlgItemText(hWnd, 1088, useFolder, MAX_PATH);

					EndDialog(hWnd, TRUE);
					break;

				case IDCANCEL:
					break;
			}
			break;
	}
	return 0;
}
*/

BOOL RefCheck::ChooseDir(TCHAR *title, TCHAR *dir)
{
	TCHAR	folderName[MAX_PATH];

	_tcscpy(folderName, dir);

	ip->ChooseDirectory(ip->GetMAXHWnd(), title, folderName, NULL);
	if (_tcscmp(folderName, _T("")) == 0) {
		// Cancel
		return FALSE;
		}

	_tcscpy(dir, folderName);

	return TRUE;

// CCJ 10/15/99 
/*
	TCHAR			fileName[MAX_PATH];
	TCHAR			folderName[MAX_PATH];
	TCHAR			folderName2[MAX_PATH];
	OPENFILENAME	ofn;	
	BOOL			done = FALSE;

	do {
		_tcscpy(fileName, dir);
		ofn.lStructSize       = sizeof(OPENFILENAME);
		ofn.hwndOwner         = hDialog;
		ofn.lpstrTitle        = title;
		ofn.lpstrFilter       = _T("All\0*.*\0");
		ofn.lpstrCustomFilter = NULL;
		ofn.nMaxCustFilter    = 0;
		ofn.nFilterIndex      = 1;
		ofn.lpstrFile         = fileName;
		ofn.nMaxFile          = sizeof(fileName);
		ofn.lpstrFileTitle    = NULL;
		ofn.nMaxFileTitle     = 0;
		ofn.lpstrInitialDir   = dir;
		ofn.nFileOffset       = 0;
		ofn.nFileExtension    = 0;
		ofn.lpstrDefExt       = NULL;
		ofn.nFilterIndex      = 0;
		ofn.hInstance         = hInstance;	
		ofn.lpTemplateName	  =	MAKEINTRESOURCE(IDD_CHOOSE_DIR);
		ofn.lpfnHook		  =	(LPOFNHOOKPROC)FileOpenHookProc;
		ofn.lCustData		  =	0;
		ofn.Flags			  =	OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_NOVALIDATE |
									OFN_ENABLETEMPLATE | OFN_ENABLEHOOK |OFN_LONGNAMES;

		_tcscpy(folderName, dir);
		useFolder = folderName;
		useFolder2 = folderName2;
		
		if(!GetOpenFileName(&ofn)) 
		{
			return FALSE;
		}
	
		if(!SetCurrentDirectory(folderName)) 
		{
			TSTR errmsg = GetString(IDS_ERROR);
			MessageBox(hDialog, GetString(IDS_NODIR), errmsg, MB_OK);
		}
		else {
			done = TRUE;
		}
 	} while (!done);

	_tcscpy(dir, folderName);

	return TRUE;
*/

}

void RefCheck::SelectMissing()
{
	int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
	int numSel = 0;

	// Clear selection
	SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_SELITEMRANGE, FALSE, MAKELPARAM(0, numItems-1));

	SetCursor(LoadCursor(NULL,IDC_WAIT));

	for (int i=0; i < numItems; i++) {
		BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
		if (bmTex) {
			TCHAR* texName = bmTex->GetMapName();
			if (texName && _tcscmp(texName, _T(""))) {
				TCHAR	newName[MAX_PATH];
				if (!FindMap(texName, newName)) {
					SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_SETSEL, TRUE, i);
					numSel++;
				}
			}
		}
	}
	SetCursor(LoadCursor(NULL,IDC_ARROW));

	EnableEntry(hDialog, numSel > 0, numSel);
}

BOOL RefCheck::FindMap(TCHAR* mapName, TCHAR* newName)
{
	TCHAR	tmpPath[MAX_PATH];
	BOOL	bFound = FALSE;

	// Copy the map name to the new target name even if the map is not found.
	_tcscpy(newName, mapName);

	// Try full path
	if (!_access(mapName, 0)) {
		bFound = TRUE;
		_tcscpy(newName, mapName);
	}
	else {
		// Try MAX File directory

		TCHAR	drive[_MAX_DRIVE];
		TCHAR	dir[_MAX_DIR];
		TCHAR	fname[_MAX_FNAME];
		TCHAR	ext[_MAX_EXT];

		_splitpath(ip->GetCurFilePath(), drive, dir, fname, ext);
		_tcscpy(tmpPath, drive);
		_tcscat(tmpPath, dir);
		if (tmpPath[_tcslen(tmpPath)-1] != _T('\\')) {
			_tcscat(tmpPath, _T("\\"));
		}
		_splitpath(mapName, drive, dir, fname, ext);
		_tcscat(tmpPath, fname);
		_tcscat(tmpPath, ext);
		if (!_access(tmpPath, 0)) {
			bFound = TRUE;
			_tcscpy(newName, tmpPath);
		}
		else {
			// Try each of the map paths
			for (int d = 0; d < TheManager->GetMapDirCount(); d++) {
				_tcscpy(tmpPath, TheManager->GetMapDir(d));
				if (tmpPath[_tcslen(tmpPath)-1] != _T('\\')) {
					_tcscat(tmpPath, _T("\\"));
				}
				_tcscat(tmpPath, fname);
				_tcscat(tmpPath, ext);
				if (!_access(tmpPath, 0)) {
					_tcscpy(newName, tmpPath);
					bFound = TRUE;
					break;
				}
			}
		}
	}

	return bFound;
}

void RefCheck::SetActualPath()
{
	int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
	int numSelItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);

	SetCursor(LoadCursor(NULL,IDC_WAIT));

	int nFoundMapCount = 0;
	int nMissingMapCount = 0;
	for (int i=0; i < numItems; i++) {
		if (SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSEL, i, 0) > 0) {
			BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
			if (bmTex) {
				TCHAR* texName = bmTex->GetMapName();
				if (texName && _tcscmp(texName, _T(""))) {
					TCHAR	newName[MAX_PATH];
					if (FindMap(texName, newName)) {
						bmTex->SetMapName(newName);
						bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
						nFoundMapCount++;
					}
					else {
						nMissingMapCount++;
					}
				}
			}
		}
	}
	CheckDependencies();
	SetCursor(LoadCursor(NULL,IDC_ARROW));

	TSTR msg;
	msg.printf(GetString(IDS_FOUNDLOG), nFoundMapCount, nMissingMapCount);
	MessageBox(hDialog, msg, GetString(IDS_MESSAGE), MB_OK);
}

class CopyWarning {
public:
	TSTR	filename;
	int		retval;
};

BOOL CALLBACK CopyWarningDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	CopyWarning* obj = (CopyWarning*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			obj = (CopyWarning*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));

			SendMessage(GetDlgItem(hWnd, IDC_FILENAME), WM_SETTEXT, 0, (LPARAM)(TCHAR*)obj->filename);
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_YES:
					obj->retval = COPYWARN_YES;
					EndDialog(hWnd, 1);
					break;
				case IDC_YESTOALL:
					obj->retval = COPYWARN_YESTOALL;
					EndDialog(hWnd, 1);
					break;
				case IDCANCEL:
					obj->retval = COPYWARN_NO;
					EndDialog(hWnd, 1);
					break;
				case IDC_NOTOALL:
					obj->retval = COPYWARN_NOTOALL;
					EndDialog(hWnd, 1);
					break;
			}
			return 1;
		case WM_CLOSE:
			EndDialog(hWnd, 0);			
			break;
	}
	return 0;
}

int RefCheck::CopyWarningPrompt(HWND hParent, TCHAR* filename)
{
	CopyWarning copyWarn;

	copyWarn.filename = filename;

	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_COPYWARNING),
		hParent,
		(DLGPROC)CopyWarningDlgProc,
		(LPARAM)&copyWarn);

	return copyWarn.retval;
}


BOOL CALLBACK CopyDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	RefCheck* util = (RefCheck*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			util = (RefCheck*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);

			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			EnableWindow(util->hDialog, FALSE);

			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDCANCEL:
					util->SetCopyQuitFlag(TRUE);
					DestroyWindow(hWnd);
					break;
			}
			return 1;
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;
		case WM_DESTROY:
			EnableWindow(util->hDialog, TRUE);
			break;

	}
	return 0;
}


void RefCheck::CopyMaps()
{
	TCHAR	newPath[MAX_PATH];
	int		copyCount = 0;
	HWND	hCopyDlg;
	TSTR	copyLog;

	SetCopyQuitFlag(FALSE);

	if (ChooseDir("Select New Path", newPath)) {

		hCopyDlg = CreateDialogParam(
			hInstance,
			MAKEINTRESOURCE(IDD_COPYDLG),
			hDialog,
			CopyDlgProc,
			(LPARAM)this);

		if (hCopyDlg) {

			TCHAR	tmpPath[MAX_PATH];
			TCHAR	texName[MAX_PATH];

			if (newPath[_tcslen(newPath)-1] != _T('\\')) {
				_tcscat(newPath, _T("\\"));
			}

			int numItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETCOUNT, 0, 0);
			int numSelItems = SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELCOUNT, 0, 0);

			SendMessage(GetDlgItem(hCopyDlg, IDC_COPYPROGRESS), PBM_SETRANGE, 0, MAKELPARAM(0, numSelItems-1));

			int		progress	= 0;
			int		copyStat	= COPYWARN_NO;
			BOOL	bOverwrite	= FALSE;
			BOOL	fileExists	= FALSE;

			for (int i=0; i < numItems; i++) {
				if (SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSEL, i, 0) > 0) {
					BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, i, 0);
					if (bmTex) {
						TCHAR* tmpName = bmTex->GetMapName();
						if (tmpName && _tcscmp(texName, _T(""))) {
							TCHAR	drive[_MAX_DRIVE];
							TCHAR	dir[_MAX_DIR];
							TCHAR	fname[_MAX_FNAME];
							TCHAR	ext[_MAX_EXT];
							
							FindMap(tmpName, texName);

							_splitpath(texName, drive, dir, fname, ext);
							_tcscpy(tmpPath, newPath);
							_tcscat(tmpPath, fname);
							_tcscat(tmpPath, ext);

							//bmTex->SetMapName(newName);
							//bmTex->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
							progress++;

							SendMessage(GetDlgItem(hCopyDlg, IDC_CURRENTFILE), WM_SETTEXT, 0, (LPARAM)texName);

							if (GetCopyQuitFlag()) {
								break;
							}

							fileExists = !_access(tmpPath, 0);

							if (copyStat == COPYWARN_NOTOALL) {
								//
							}
							else if (copyStat == COPYWARN_YESTOALL) {
								//
							}
							else if (fileExists) {
								copyStat = CopyWarningPrompt(hCopyDlg, tmpPath);
							}

							if (copyStat == COPYWARN_NO || copyStat == COPYWARN_NOTOALL) {
								bOverwrite = FALSE;
							}
							else {
								bOverwrite = TRUE;
							}

							if (fileExists && bOverwrite == FALSE) {
								copyLog = GetString(IDS_COPYSKIP);
							}
							else if (!CopyFile(texName, tmpPath, !bOverwrite)) {
								copyLog = GetString(IDS_COPYFAIL);
								/*
								TSTR szTitle = GetString(IDS_COPYTITLE);
								if (MessageBox(hDialog, GetString(IDS_COPYERROR), szTitle, MB_OKCANCEL | MB_ICONWARNING) != IDOK) {
									break;
								}
								*/
							}
							else {
								copyLog = GetString(IDS_COPYOK);
								copyCount++;
							}
							copyLog += texName;
							SendMessage(GetDlgItem(hCopyDlg, IDC_COPYLOG), LB_ADDSTRING, 0, (LPARAM)(char*)copyLog);

						}
					}
					SendMessage(GetDlgItem(hCopyDlg, IDC_COPYPROGRESS), PBM_SETPOS, progress, 0);
				}
			}
			if (GetCopyQuitFlag()) {
				copyLog.printf(GetString(IDS_COPYABORTED), copyCount);
			}
			else {
				copyLog.printf(GetString(IDS_COPYCOUNT), copyCount);
			}
			SendMessage(GetDlgItem(hCopyDlg, IDC_CURRENTFILE), WM_SETTEXT, 0, (LPARAM)(char*)copyLog);
			SendMessage(GetDlgItem(hCopyDlg, IDCANCEL), WM_SETTEXT, 0, (LPARAM)GetString(IDS_CLOSE));
		}
	}
}

BOOL CALLBACK InfoDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
{
	RefCheck* util = (RefCheck*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (message) {
		case WM_INITDIALOG:
			util = (RefCheck*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			CenterWindow(hWnd,GetParent(hWnd));
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			util->HandleInfoDlg(hWnd);
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:				  
				case IDCANCEL:
					EndDialog(hWnd,1);
					break;
				case IDC_VIEW: {
						BitmapTex* i = util->GetInfoTex();
						if (i) {
							Bitmap* b = i->GetBitmap(util->ip->GetTime());
							if (b) {
								b->Display(i->GetName());
							}
						}
					}
					break;
			}
			return 1;
	}
	return 0;
}

void RefCheck::ShowInfo()
{
	DialogBoxParam(
		hInstance,
		MAKEINTRESOURCE(IDD_INFODLG),
		hDialog,
		(DLGPROC)InfoDlgProc,
		(LPARAM)this);

	/*
	if (pDib) {
		LocalFree(pDib);
		pDib = NULL;
	}
	*/
}

class FindNodesProc : public DependentEnumProc {
	public:
		FindNodesProc(INodeTab* tab) {
			nodetab = tab;
		}
		int proc(ReferenceMaker *ref) {
			switch (ref->SuperClassID()) {
				case BASENODE_CLASS_ID:
					INode* n = (INode*)ref;
					nodetab->Append(1, &n, 5);
					break;
			}
			return 0;
		}
	private:
		INodeTab* nodetab;
};

void RefCheck::HandleInfoDlg(HWND dlg)
{
	int idx;

	SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETSELITEMS, 1, (LPARAM)&idx);
	BitmapTex* bmTex = (BitmapTex*)SendMessage(GetDlgItem(hDialog, IDC_DEPLIST), LB_GETITEMDATA, idx, 0);
	if (bmTex) {
		SetInfoTex(bmTex);
		INodeTab nodeTab;
		FindNodesProc dep(&nodeTab);
		bmTex->EnumDependents(&dep);
		for (int i=0; i<nodeTab.Count(); i++) {
			SendMessage(GetDlgItem(dlg, IDC_NODELIST), LB_ADDSTRING, 0, (LPARAM)nodeTab[i]->GetName());
		}

		/*
		Bitmap* b = bmTex->GetBitmap(ip->GetTime());

		if (b) {
			ICustImage* iImage;
			pDib = b->ToDib();
			iImage = GetICustImage(GetDlgItem(dlg, IDC_IMAGE));
			// ...
			ReleaseICustImage(iImage);
		}
		*/
	}
}

BOOL RefCheck::GetIncludeMatLib()
{
	return IsDlgButtonChecked(hPanel, IDC_USE_MATLIB) == BST_CHECKED;
}

BOOL RefCheck::GetIncludeMedit()
{
	return IsDlgButtonChecked(hPanel, IDC_INCLUDE_MEDIT) == BST_CHECKED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\MapPath\mappath.h ===
/**********************************************************************
 *<
	FILE: RefCheck.h

	DESCRIPTION:	Template Utility

	CREATED BY:

	HISTORY:

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __REFCHECK__H
#define __REFCHECK__H

#include "Max.h"
#include "resource.h"
#include "utilapi.h"
#include "istdplug.h"
#include "stdmat.h"
#include "bmmlib.h"
#include <io.h>

#define REFCHECK_CLASS_ID	Class_ID(0xa7d423ed, 0x64de98f9)

extern ClassDesc*	GetRefCheckDesc();
extern HINSTANCE	hInstance;
extern TCHAR*		GetString(int id);

#define COPYWARN_YES		0x00
#define COPYWARN_YESTOALL	0x01
#define COPYWARN_NO			0x02
#define COPYWARN_NOTOALL	0x03

class RefCheck : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		HWND hDialog;

		RefCheck();
		~RefCheck();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

		// Main dialog resize functions
		void ResizeWindow(int x, int y);
		void SetMinDialogSize(int w, int h)	{ minDlgWidth = w; minDlgHeight = h; }
		int	 GetMinDialogWidth()			{ return minDlgWidth; }
		int  GetMinDialogHeight()			{ return minDlgHeight; }

		void CheckDependencies();
		void Update();
		void StripSelected();
		void StripAll();
		void DoDialog();
		void DoSelection();
		void SetPath(TCHAR* path, BitmapTex* map);
		void StripMapName(TCHAR* path);
		void BrowseDirectory();
		BOOL ChooseDir(TCHAR *title, TCHAR *dir);
		void EnableEntry(HWND hWnd, BOOL bEnable, int numSel);
		void ShowInfo();
		void HandleInfoDlg(HWND dlg);

		BOOL GetIncludeMatLib();
		BOOL GetIncludeMedit();

		int  CopyWarningPrompt(HWND hParent, TCHAR* filename);
		void CopyMaps();
		void SetActualPath();
		void SelectMissing();

		BOOL FindMap(TCHAR* mapName, TCHAR* newName);

		BOOL GetCopyQuitFlag()	{ return bCopyQuitFlag; }
		void SetCopyQuitFlag(BOOL bStatus)	{ bCopyQuitFlag = bStatus; }
		void SetInfoTex(BitmapTex* b) { infoTex = b; }
		BitmapTex* GetInfoTex() { return infoTex; }

	private:
		BOOL		bCopyQuitFlag;
		BitmapTex*	infoTex;
		int			minDlgWidth;
		int			minDlgHeight;
		//PBITMAPINFO	pDib;
};

#endif // __REFCHECK__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\crt_crv.cpp ===
/**********************************************************************
 *<
    FILE: crt_crv.cpp

    DESCRIPTION:  Test Utility for the API

    CREATED BY: Charlie Thaeler

    HISTORY: created 18 Feb, 1998

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"


int
APITestUtil::MakeTestCVCurve(NURBSSet &nset, Matrix3 mat)
{
	NURBSCVCurve *c = new NURBSCVCurve();
	c->SetName(GetString(IDS_CV_CURVE));
	c->SetNumCVs(4);

	c->SetOrder(4);
	c->SetNumKnots(8);
	for (int k = 0; k < 4; k++) {
		c->SetKnot(k, 0.0);
		c->SetKnot(k+4, 1.0);
	}

	NURBSControlVertex cv;
	cv.SetSelected(TRUE); // make all the CVs selected
	cv.SetPosition(0, mat * Point3(0, 150, 50));
	c->SetCV(0, cv);
	cv.SetPosition(0, mat * Point3(-100, 150, 50));
	c->SetCV(1, cv);
	cv.SetPosition(0, mat * Point3(-100, 250, 50));
	c->SetCV(2, cv);
	cv.SetPosition(0, mat * Point3(0, 250, 50));
	c->SetCV(3, cv);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestPointCurve(NURBSSet &nset, Matrix3 mat)
{
	NURBSPointCurve *c = new NURBSPointCurve();
	c->SetName(GetString(IDS_POINT_CURVE));
	c->SetNumPts(4);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, mat * Point3(0, 150, 0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, mat * Point3(-100, 150, 0));
	c->SetPoint(1, pt);
	pt.SetPosition(0, mat * Point3(-100, 250, 0));
	c->SetPoint(2, pt);
	pt.SetPosition(0, mat * Point3(0, 250, 0));
	c->SetPoint(3, pt);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestBlendCurve(NURBSSet &nset, int p1, int p2)
{
	NURBSBlendCurve *c = new NURBSBlendCurve();
	c->SetName(GetString(IDS_BLEND_CURVE));
	c->SetNSet(&nset);

	c->SetParent(0, p1);
	c->SetParent(1, p2);
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestOffsetCurve(NURBSSet &nset, int p)
{
	NURBSOffsetCurve *c = new NURBSOffsetCurve();
	c->SetName(GetString(IDS_OFFSET_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
	c->SetDistance(0, 50.0);
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestXFormCurve(NURBSSet &nset, int p)
{
	NURBSXFormCurve *c = new NURBSXFormCurve();
	c->SetName(GetString(IDS_XFORM_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.SetTrans(Point3(10, 10, 100));
	c->SetXForm(0, mat);
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestMirrorCurve(NURBSSet &nset, int p)
{
	NURBSMirrorCurve *c = new NURBSMirrorCurve();
	c->SetName(GetString(IDS_MIRROR_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
	Matrix3 mat;
	mat.IdentityMatrix();
	c->SetXForm(0, mat);
	c->SetAxis(kMirrorX);
	c->SetDistance(0, 25.0);
	return nset.AppendObject(c);
}


int
APITestUtil::MakeTestFilletCurve(NURBSSet &nset)
{
	NURBSPointCurve *ec0 = new NURBSPointCurve();
	ec0->SetName(GetString(IDS_F_EDGE_CRV1));
	ec0->SetNumPts(2);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(0, 0, 0));
	ec0->SetPoint(0, pt);
	pt.SetPosition(0, Point3(100, -100, 0));
	ec0->SetPoint(1, pt);
	int f1 = nset.AppendObject(ec0);

	NURBSPointCurve *ec1 = new NURBSPointCurve();
	ec1->SetName(GetString(IDS_F_EDGE_CRV2));
	ec1->SetNumPts(2);

	pt.SetPosition(0, Point3(100, 0, 0));
	ec1->SetPoint(0, pt);
	pt.SetPosition(0, Point3(100, -100, 0));
	ec1->SetPoint(1, pt);
	int f2 = nset.AppendObject(ec1);

	NURBSFilletCurve *fc = new NURBSFilletCurve();
	fc->SetName(GetString(IDS_FILLET_CURVE));
	fc->SetParent(0, f1);
	fc->SetParent(1, f2);
	fc->SetRadius(0, 20.0);
	fc->SetEnd(0, TRUE);
	fc->SetEnd(1, TRUE);

	return nset.AppendObject(fc);
}



int
APITestUtil::MakeTestChamferCurve(NURBSSet &nset)
{
	NURBSPointCurve *ec0 = new NURBSPointCurve();
	ec0->SetName(GetString(IDS_C_EDGE_CRV1));
	ec0->SetNumPts(2);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(0, 0, 50));
	ec0->SetPoint(0, pt);
	pt.SetPosition(0, Point3(90, -80, 50));
	ec0->SetPoint(1, pt);
	int f1 = nset.AppendObject(ec0);

	NURBSPointCurve *ec1 = new NURBSPointCurve();
	ec1->SetName(GetString(IDS_C_EDGE_CRV2));
	ec1->SetNumPts(2);

	pt.SetPosition(0, Point3(100, 0, 50));
	ec1->SetPoint(0, pt);
	pt.SetPosition(0, Point3(90, -80, 50));
	ec1->SetPoint(1, pt);
	int f2 = nset.AppendObject(ec1);

	NURBSChamferCurve *fc = new NURBSChamferCurve();
	fc->SetName(GetString(IDS_CHAMFER_CURVE));
	fc->SetParent(0, f1);
	fc->SetParent(1, f2);
	fc->SetLength(0, 0, 20.0);
	fc->SetLength(0, 1, 30.0);
	fc->SetEnd(0, TRUE);
	fc->SetEnd(1, TRUE);

	return nset.AppendObject(fc);
}

int
APITestUtil::MakeTestIsoCurveU(NURBSSet &nset, int p)
{
	NURBSIsoCurve *c = new NURBSIsoCurve();
	c->SetName(GetString(IDS_U_ISO_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
	c->SetParam(0, 0.5);
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestIsoCurveV(NURBSSet &nset, int p)
{
	NURBSIsoCurve *c = new NURBSIsoCurve();
	c->SetName(GetString(IDS_V_ISO_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
    c->SetDirection(FALSE);
	c->SetParam(0, 0.5);
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestSurfaceEdgeCurve(NURBSSet &nset, int p)
{
	NURBSSurfaceEdgeCurve *c = new NURBSSurfaceEdgeCurve();
	c->SetName(GetString(IDS_SURFACE_EDGE_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p);
	c->SetSeed(Point2(0.0f, 1.0f));
	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestProjectVectorCurve(NURBSSet &nset, int p1, int p2)
{
	NURBSProjectVectorCurve *c = new NURBSProjectVectorCurve();
	c->SetName(GetString(IDS_PROJ_VECT_CURVE));
	c->SetNSet(&nset);

	c->SetParent(0, p1);
	c->SetParent(1, p2);

	c->SetPVec(0, Point3(0, 0, 1));

	c->SetSeed(Point2(0.8, 0.8));

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestProjectNormalCurve(NURBSSet &nset, int p1, int p2)
{
	NURBSProjectNormalCurve *c = new NURBSProjectNormalCurve();
	c->SetName(GetString(IDS_PROJ_NORM_CURVE));
	c->SetNSet(&nset);

	c->SetParent(0, p1);
	c->SetParent(1, p2);

	c->SetSeed(Point2(0.2, 0.2));
	c->SetTrim(TRUE);

	return nset.AppendObject(c);
}
int
APITestUtil::MakeTestSurfSurfIntersectionCurve(NURBSSet &nset, int p1, int p2)
{
	NURBSSurfSurfIntersectionCurve *c = new NURBSSurfSurfIntersectionCurve();
	c->SetName(GetString(IDS_SURF_SURF_CURVE));
	c->SetNSet(&nset);

	c->SetParent(0, p1);
	c->SetParent(1, p2);

	c->SetSeed(Point2(0.8, 0.8));

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestCurveOnSurface(NURBSSet &nset, int p1)
{
	NURBSCurveOnSurface *c = new NURBSCurveOnSurface();
	c->SetName(GetString(IDS_CV_COS_CURVE));
	c->SetParent(p1);
	c->SetNumCVs(4);

	c->SetOrder(4);
	c->SetNumKnots(8);
	for (int k = 0; k < 4; k++) {
		c->SetKnot(k, 0.0);
		c->SetKnot(k+4, 1.0);
	}

	NURBSControlVertex cv;
	cv.SetSelected(TRUE);
	cv.SetPosition(0, Point3(0.0, 0.0, 0.0));
	c->SetCV(0, cv);
	cv.SetPosition(0, Point3(0.5, 0.25, 0.0));
	c->SetCV(1, cv);
	cv.SetPosition(0, Point3(0.25, 0.75, 0.0));
	c->SetCV(2, cv);
	cv.SetPosition(0, Point3(1.0, 1.0, 0.0));
	c->SetCV(3, cv);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestPointCurveOnSurface(NURBSSet &nset, int p1)
{
	NURBSPointCurveOnSurface *c = new NURBSPointCurveOnSurface();
	c->SetName(GetString(IDS_POINT_COS_CURVE));
	c->SetParent(p1);
	c->SetNumPts(4);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(0.0, 0.0, 0.0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(0.5, 0.25, 0.0));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(0.25, 0.75, 0.0));
	c->SetPoint(2, pt);
	pt.SetPosition(0, Point3(1.0, 1.0, 0.0));
	c->SetPoint(3, pt);

	c->SetTrim(TRUE);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestSurfaceNormalCurve(NURBSSet &nset, int p1)
{
	NURBSSurfaceNormalCurve *c = new NURBSSurfaceNormalCurve();
	c->SetName(GetString(IDS_SURF_NORM_CURVE));
	c->SetParent(p1);
	c->SetDistance(0, 25.0f);

	return nset.AppendObject(c);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\crt_srf.cpp ===
/**********************************************************************
 *<
    FILE: crt_srf.cpp

    DESCRIPTION:  Test Utility for the API

    CREATED BY: Charlie Thaeler

    HISTORY: created 18 Feb, 1998

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"



int
APITestUtil::MakeTestCVSurface(NURBSSet &nset, Matrix3 mat, BOOL rigid)
{
	NURBSCVSurface *s = new NURBSCVSurface();
	s->SetRigid(rigid);
	s->SetName(GetString(IDS_CV_SURFACE));
	s->SetNumCVs(4, 4);

	s->SetUOrder(4);
	s->SetVOrder(4);
	s->SetNumUKnots(8);
	s->SetNumVKnots(8);
	for (int k = 0; k < 4; k++) {
		s->SetUKnot(k, 0.0);
		s->SetVKnot(k, 0.0);
		s->SetUKnot(k+4, 1.0);
		s->SetVKnot(k+4, 1.0);
	}

	NURBSControlVertex cv;
	for (int u = 0; u < 4; u++) {
		float up = 100.0f * ((float)u/3.0f);
		for (int v = 0; v < 4; v++) {
			float vp = 100.0f * ((float)v/3.0f);
			cv.SetPosition(0, mat * Point3(-150.0f + up, -100.0f + vp, 0.0f));
			char name[20];
			sprintf(name, "%s[%d,%d]", GetString(IDS_CV), u, v);
			cv.SetName(name);
			s->SetCV(u, v, cv);
		}
	}
	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestPointSurface(NURBSSet &nset, Matrix3 mat)
{
	NURBSPointSurface *s = new NURBSPointSurface();
	s->SetName(GetString(IDS_POINT_SURFACE));
	s->SetNumPts(2, 2);
	NURBSIndependentPoint pt;
	pt.SetPosition(0, mat * Point3(20, 0, 0));
	char name[32];
	sprintf(name, "%d [%d,%d]", GetString(IDS_POINT), 0, 0);
	pt.SetName(name);
	s->SetPoint(0, 0, pt);
	pt.SetPosition(0, mat * Point3(20, 0, 100));
	sprintf(name, "%d [%d,%d]", GetString(IDS_POINT), 0, 1);
	pt.SetName(name);
	s->SetPoint(0, 1, pt);
	pt.SetPosition(0, mat * Point3(120, 0, 0));
	sprintf(name, "%d [%d,%d]", GetString(IDS_POINT), 1, 0);
	pt.SetName(name);
	s->SetPoint(1, 0, pt);
	pt.SetPosition(0, mat * Point3(120, 0, 100));
	sprintf(name, "%d [%d,%d]", GetString(IDS_POINT), 1, 1);
	pt.SetName(name);
	s->SetPoint(1, 1, pt);

	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestBlendSurface(NURBSSet &nset, int p1, int p2)
{
	NURBSBlendSurface *s = new NURBSBlendSurface();
	s->SetName(GetString(IDS_BLEND_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(0, p1);
	s->SetParent(1, p2);

	s->SetEdge(0, 1); // make it the High U edge

	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestOffsetSurface(NURBSSet &nset, int p)
{
	NURBSOffsetSurface *s = new NURBSOffsetSurface();
	s->SetName(GetString(IDS_OFFSET_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(p);
	s->SetDistance(0, 20.0);
	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestXFormSurface(NURBSSet &nset, int p)
{
	NURBSXFormSurface *s = new NURBSXFormSurface();
	s->SetName(GetString(IDS_XFORM_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(p);
	Matrix3 mat;
	mat.IdentityMatrix();
	mat.SetTrans(Point3(-150, 150, 0));
	s->SetXForm(0, mat);
	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestMirrorSurface(NURBSSet &nset, int p)
{
	NURBSMirrorSurface *s = new NURBSMirrorSurface();
	s->SetName(GetString(IDS_MIRROR_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(p);
	Matrix3 mat;
	mat.IdentityMatrix();
	s->SetXForm(0, mat);
	s->SetAxis(kMirrorZ);
	s->SetDistance(0, 100.0);
	s->FlipNormals(TRUE);
	return nset.AppendObject(s);
}


int
APITestUtil::MakeTestRuledSurface(NURBSSet &nset, int p1, int p2)
{
	NURBSRuledSurface *s = new NURBSRuledSurface();
	s->SetName(GetString(IDS_RULED_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(0, p1);
	s->SetParent(1, p2);
	s->SetFlip(0, FALSE);
	s->SetFlip(1, FALSE);
	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestULoftSurface(NURBSSet &nset, int p1, int p2, int p3)
{
	NURBSULoftSurface *s = new NURBSULoftSurface();
	s->SetName(GetString(IDS_ULOFT_SURFACE));
	s->SetNSet(&nset);

	s->AppendCurve(p1, FALSE);
	s->AppendCurve(p2, FALSE);
	s->AppendCurve(p3, FALSE);
	s->FlipNormals(TRUE);
	return nset.AppendObject(s);
}


int
APITestUtil::MakeTestExtrudeSurface(NURBSSet &nset, int p1)
{
	NURBSExtrudeSurface *s = new NURBSExtrudeSurface();
	s->SetName(GetString(IDS_EXTRUDE_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(p1);
	s->SetDistance(0, 50);
	s->FlipNormals(TRUE);

	return nset.AppendObject(s);
}


static int
MakeCurveToLathe(NURBSSet &nset)
{
	NURBSPointCurve *c = new NURBSPointCurve();
	c->SetName(GetString(IDS_POINT_CURVE));
	c->SetNumPts(3);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(200, 200, 0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(250, 200, 100));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(200, 200, 150));
	c->SetPoint(2, pt);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestLatheSurface(NURBSSet &nset)
{
	int p = MakeCurveToLathe(nset);

	NURBSLatheSurface *s = new NURBSLatheSurface();
	s->SetName(GetString(IDS_LATHE_SURFACE));
	s->SetNSet(&nset);

	s->SetParent(p);
	Matrix3 mat = TransMatrix(Point3(200, 200, 0));
	s->SetAxis(0, mat);

	s->FlipNormals(TRUE);

	return nset.AppendObject(s);
}



static int
P1Curve(NURBSSet &nset, Matrix3 mat)
{
	NURBSPointCurve *c = new NURBSPointCurve();
	c->SetName(GetString(IDS_POINT_CURVE));
	c->SetNumPts(4);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, mat * Point3(1, 1, 0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, mat * Point3(-1, 1, 0));
	c->SetPoint(1, pt);
	pt.SetPosition(0, mat * Point3(-1, -1, 0));
	c->SetPoint(2, pt);
	pt.SetPosition(0, mat * Point3(1, -1, 0));
	c->SetPoint(3, pt);

	return nset.AppendObject(c);
}
static int
P2Curve(NURBSSet &nset, Matrix3 mat)
{
	NURBSPointCurve *c = new NURBSPointCurve();
	c->SetName(GetString(IDS_POINT_CURVE));
	c->SetNumPts(3);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, mat * Point3(0, 0, 0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, mat * Point3(0, 0, 20));
	c->SetPoint(1, pt);
	pt.SetPosition(0, mat * Point3(0, 0, 40));
	c->SetPoint(2, pt);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestUVLoftSurface(NURBSSet &nset)
{
	Matrix3 scale = ScaleMatrix(Point3(50, 50, 50));
	Matrix3 rotate = RotateZMatrix(PI/2.0f);
	int cu0 = P1Curve(nset, scale * TransMatrix(Point3(0, 0, 0)));
	int cu1 = P1Curve(nset, scale * TransMatrix(Point3(0, 0, 20)));
	int cu2 = P1Curve(nset, scale * TransMatrix(Point3(0, 0, 40)));

	int cv0 = P2Curve(nset, TransMatrix(Point3(50, 50, 0)));
	int cv1 = P2Curve(nset, TransMatrix(Point3(-50, 50, 0)));
	int cv2 = P2Curve(nset, TransMatrix(Point3(-50, -50, 0)));
	int cv3 = P2Curve(nset, TransMatrix(Point3(50, -50, 0)));

	NURBSUVLoftSurface *s = new NURBSUVLoftSurface();
	s->SetName(GetString(IDS_UVLOFT_SURFACE));
	s->SetNSet(&nset);
	s->AppendUCurve(cu0);
	s->AppendUCurve(cu1);
	s->AppendUCurve(cu2);

	s->AppendVCurve(cv0);
	s->AppendVCurve(cv1);
	s->AppendVCurve(cv2);
	s->AppendVCurve(cv3);

	return nset.AppendObject(s);
}

int
APITestUtil::MakeTest1RailSweepSurface(NURBSSet &nset)
{
	int rail = P1Curve(nset, ScaleMatrix(Point3(50, 50, 50)));
	int cross = P1Curve(nset, ScaleMatrix(Point3(5, 5, 5)) *
							RotateYMatrix(PI/2.0f) *
							TransMatrix(Point3(50, 50, 0)));
	NURBS1RailSweepSurface *s = new NURBS1RailSweepSurface();
	s->SetName(GetString(IDS_1RAIL_SURFACE));
	s->SetNSet(&nset);

	s->SetParentRail(rail);
	s->AppendCurve(cross, FALSE);
	s->SetParallel(FALSE);
	s->FlipNormals(TRUE);

	return nset.AppendObject(s);
}

int
APITestUtil::MakeTest2RailSweepSurface(NURBSSet &nset)
{
	int rail1 = P1Curve(nset, ScaleMatrix(Point3(70, 70, 70)));
	int rail2 = P1Curve(nset, ScaleMatrix(Point3(90, 90, 90)));
	int cross = P1Curve(nset, ScaleMatrix(Point3(5, 5, 5)) *
							RotateYMatrix(PI/2.0f) *
							TransMatrix(Point3(70, 70, 0)));
	NURBS2RailSweepSurface *s = new NURBS2RailSweepSurface();
	s->SetName(GetString(IDS_2RAIL_SURFACE));
	s->SetNSet(&nset);

	s->SetRailParent(0, rail1);
	s->SetRailParent(1, rail2);
	s->AppendCurve(cross, FALSE);

	return nset.AppendObject(s);
}

static int
COS1(NURBSSet &nset, int p1)
{
	NURBSPointCurveOnSurface *c = new NURBSPointCurveOnSurface();
	c->SetName(GetString(IDS_POINT_COS_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p1);
	c->SetNumPts(3);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(0.1, 0.1, 0.0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(0.25, 0.75, 0.0));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(0.9, 0.9, 0.0));
	c->SetPoint(2, pt);

	return nset.AppendObject(c);
}

static int
COS2(NURBSSet &nset, int p1)
{
	NURBSPointCurveOnSurface *c = new NURBSPointCurveOnSurface();
	c->SetName(GetString(IDS_POINT_COS_CURVE));
	c->SetNSet(&nset);

	c->SetParent(p1);
	c->SetNumPts(3);

	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(0.1, 0.1, 0.0));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(0.75, 0.25, 0.0));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(0.9, 0.9, 0.0));
	c->SetPoint(2, pt);

	return nset.AppendObject(c);
}

int
APITestUtil::MakeTestMultiCurveTrimSurface(NURBSSet &nset)
{
	int srf = MakeTestCVSurface(nset, TransMatrix(Point3(100, 100, 150)));
	int cos1 = COS1(nset, srf);
	int cos2 = COS2(nset, srf);

	NURBSMultiCurveTrimSurface *s = new NURBSMultiCurveTrimSurface();
	s->SetName(GetString(IDS_MULTI_TRIM_SURFACE));
	s->SetNSet(&nset);

	s->SetSurfaceParent(srf);
	s->AppendCurve(cos1);
	s->AppendCurve(cos2);

    // Tell the surface to flip the orientation of the trim.
	s->SetFlipTrim(TRUE);

	return nset.AppendObject(s);
}

int
APITestUtil::MakeTestCapSurface(NURBSSet &nset)
{
	// NOT YET IMPLEMENTED
	return 0;
}

int
APITestUtil::MakeTestNBlendSurface(NURBSSet &nset)
{
	// NOT YET IMPLEMENTED
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\crt_pnt.cpp ===
/**********************************************************************
 *<
    FILE: crt_pnt.cpp

    DESCRIPTION:  Test Utility for the API

    CREATED BY: Charlie Thaeler

    HISTORY: created 18 Feb, 1998

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"





int
APITestUtil::MakeTestPoint(NURBSSet &nset)
{
	NURBSIndependentPoint *p = new NURBSIndependentPoint();
	p->SetName(GetString(IDS_POINT));
	p->SetPosition(0, Point3(75, -75, 0));

	return nset.AppendObject(p);
}

int
APITestUtil::MakeTestPointCPoint(NURBSSet &nset, int p1)
{
	NURBSPointConstPoint *p = new NURBSPointConstPoint();
	p->SetName(GetString(IDS_POINT_CONST_POINT));
	p->SetParent(p1);
	p->SetPointType(kNConstOffset);
	p->SetOffset(0, Point3(20, -20, 20));

	return nset.AppendObject(p);
}


int
APITestUtil::MakeTestCurveCPoint(NURBSSet &nset, int p1)
{
	NURBSCurveConstPoint *p = new NURBSCurveConstPoint();
	p->SetName(GetString(IDS_CURVE_CONST_POINT));
	p->SetParent(p1);
	p->SetUParam(0, 0.5);
	p->SetPointType(kNConstNormal);
	p->SetNormal(0, 15.0f);

	return nset.AppendObject(p);
}


int
APITestUtil::MakeTestSurfCPoint(NURBSSet &nset, int p1)
{
	NURBSSurfConstPoint *p = new NURBSSurfConstPoint();
	p->SetName(GetString(IDS_SURF_CONST_POINT));
	p->SetParent(p1);
	p->SetUParam(0, 0.5);
	p->SetVParam(0, 0.6);
	p->SetPointType(kNConstTangent);
	p->SetUTangent(0, 15.0f);
	p->SetVTangent(0, 25.0f);

	return nset.AppendObject(p);
}

int
APITestUtil::MakeTestCurveCurve(NURBSSet &nset, int p1, int p2, BOOL trim)
{
	NURBSCurveCurveIntersectionPoint *p = new NURBSCurveCurveIntersectionPoint();
	p->SetName(GetString(IDS_CURVE_CURVE_POINT));
	p->SetNSet(&nset);

	p->SetParent(0, p1);
	p->SetParent(1, p2);
    p->SetCurveParam(0, 0.0);
    p->SetCurveParam(1, 0.0);
    p->SetTrimCurve(1, trim);

	return nset.AppendObject(p);
}

int
APITestUtil::MakeTestCurveSurface(NURBSSet &nset, int p1, int p2)
{
	NURBSCurveSurfaceIntersectionPoint *p = new NURBSCurveSurfaceIntersectionPoint();
	p->SetName(GetString(IDS_CURV_SURF_INT_POINT));
	p->SetNSet(&nset);

	p->SetParent(0, p1);
	p->SetParent(1, p2);

	p->SetSeed(0.5);

	return nset.AppendObject(p);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\MapPath\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MapPath.rc
//
#define IDS_STRIPWARNING                1
#define IDS_STRIPTITLE                  2
#define IDS_COPYTITLE                   3
#define IDS_COPYERROR                   4
#define IDS_COPYCOUNT                   5
#define IDS_CLOSE                       6
#define IDS_COPYFAIL                    7
#define IDS_COPYOK                      8
#define IDS_COPYABORTED                 9
#define IDS_FOUNDLOG                    10
#define IDS_MESSAGE                     11
#define IDS_PANELTITLE                  12
#define IDS_OVERWRITEPROMPT             13
#define IDS_ERROR                       14
#define IDS_NODIR                       15
#define IDS_COPYSKIP                    16
#define IDD_PANEL                       101
#define IDD_DEPDLG                      102
#define IDD_MAINDIALOG                  102
#define IDD_INFODLG                     103
#define IDD_COPYDLG                     104
#define IDD_COPYWARNING                 105
#define IDD_CHOOSE_DIR                  317
#define IDC_CLOSEBUTTON                 1000
#define IDC_CHECKDEP                    1001
#define IDC_DEPLIST                     1003
#define IDC_PATHEDIT                    1004
#define IDC_DESC_EDIT                   1004
#define IDC_UPDATE                      1005
#define IDC_SETPATH                     1005
#define IDC_TITLE                       1006
#define IDC_STRIP_SELECTED              1007
#define IDC_MAPNAME                     1008
#define IDC_BROWSE                      1010
#define IDC_COPYMAPS                    1012
#define IDC_INFO                        1014
#define IDC_NODELIST                    1016
#define IDC_COPYPROGRESS                1018
#define IDC_CURRENTFILE                 1019
#define IDC_COPYLOG                     1020
#define IDC_ACTUALPATH                  1021
#define IDC_MISSING                     1022
#define IDC_VIEW                        1024
#define IDC_PATHTITLE                   1025
#define IDC_YES                         1027
#define IDC_YESTOALL                    1028
#define IDC_NOTOALL                     1030
#define IDC_FILENAME                    1031
#define IDC_USE_MATLIB                  1032
#define IDC_STRIP_ALL2                  1033
#define IDC_STRIP_ALL                   1033
#define IDC_INCLUDE_MEDIT               1034
#define IDC_MY_OK                       1286

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1035
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\nutil.h ===
/**********************************************************************
 *<
	FILE: nutil.h

	DESCRIPTION: header file for the Test harness utility plugin for the
	             NURBS API

	CREATED BY: Charlie Thaeler

	HISTORY: created 8/13/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/


#ifndef _NUTIL_H
#define _NUTIL_H

#include "max.h"
#include "iparamm.h"
#include "utilapi.h"
#include "surf_api.h"
#include "resource.h"

extern HINSTANCE hInstance;
extern TCHAR *GetString(int id);

#define API_TEST_UTIL_CLASS_ID Class_ID(0x3a521292, 0x740775fa)
#define SURF_APPROX_UTIL_CLASS_ID Class_ID(0x6216493, 0x131c3958)


enum SurfApproxType {
	kCurveView = 0,
	kCurveRend,
	kSurfView,
	kSurfRend,
	kSurfDisp
};


class SurfApproxUtil : public UtilityObj {
private:
	IUtil* mpIu;
public:
	IObjParam* mpIp;
	SurfApproxType mSettingType;
	TessApprox *mpSurfView;
	TessApprox *mpSurfRend;
	TessApprox *mpDispRend;
	TessApprox *mpCurveView;
	TessApprox *mpCurveRend;
	BOOL mClearSurfaces;

	NURBSDisplay mDisplay;

	SurfApproxUtil(void);
	~SurfApproxUtil(void);
	friend BOOL CALLBACK SurfApproxDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	void BeginEditParams(Interface *ip,IUtil *iu);
	void EndEditParams(Interface *ip,IUtil *iu);
	void SetSurfApprox();
	void SetSurfDisplay();
	void SetupDisplayUI(HWND hwnd);
	void DeleteThis() {}
	void ResetTess();
	void ResetDisplay();

	TessApprox *GetTess(SurfApproxType type);
	void SetTess(TessApprox &tess, SurfApproxType type);
	void ClearTess(SurfApproxType type);

    TessApprox* GetPreset(int preset);
    void SetPreset(int preset, TessApprox& tess);
};

class APITestUtil : public UtilityObj {
private:
	IUtil* mpIu;
	IObjParam* mpIp;
public:
	char mFilename[256];
	BOOL mToFile;
	BOOL mRelational;
	BOOL mAsCurve;
	FILE *mFP;

	APITestUtil() { mRelational = TRUE; mAsCurve = FALSE; mToFile = FALSE; mFP = NULL; sprintf(mFilename, "testdump.txt"); }

	friend BOOL CALLBACK APITestDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

	void BeginEditParams(Interface *ip,IUtil *iu);
	void EndEditParams(Interface *ip,IUtil *iu);

	void CombinedTests();
	void PointTests();
	void CurveTests();
	void SurfaceTests();
	void COSTests();

	void DumpPrint(const TCHAR *format, ...);
	void DumpMatrix3(int indent, Matrix3& mat);
	void PrintPoint(int indent, Point3 pt);
	void DumpObject(int indent, NURBSObject* nobj, TimeValue t);
	void DumpSelected();
	void DeleteThis() {}

	int MakeTestPoint(NURBSSet &nset);
	int MakeTestPointCPoint(NURBSSet &nset, int p1);
	int MakeTestCurveCPoint(NURBSSet &nset, int p1);
	int MakeTestSurfCPoint(NURBSSet &nset, int p1);
	int MakeTestCurveCurve(NURBSSet &nset, int p1, int p2, BOOL trim);
	int MakeTestCurveSurface(NURBSSet &nset, int p1, int p2);


	int MakeTestCVCurve(NURBSSet &nset, Matrix3 mat);
	int MakeTestPointCurve(NURBSSet &nset, Matrix3 mat);
	int MakeTestBlendCurve(NURBSSet &nset, int p1, int p2);
	int MakeTestOffsetCurve(NURBSSet &nset, int p);
	int MakeTestXFormCurve(NURBSSet &nset, int p);
	int MakeTestMirrorCurve(NURBSSet &nset, int p);
	int MakeTestFilletCurve(NURBSSet &nset);
	int MakeTestChamferCurve(NURBSSet &nset);
	int MakeTestIsoCurveU(NURBSSet &nset, int p);
	int MakeTestIsoCurveV(NURBSSet &nset, int p);
	int MakeTestSurfaceEdgeCurve(NURBSSet &nset, int p);
	int MakeTestProjectVectorCurve(NURBSSet &nset, int p1, int p2);
	int MakeTestProjectNormalCurve(NURBSSet &nset, int p1, int p2);
	int MakeTestSurfSurfIntersectionCurve(NURBSSet &nset, int p1, int p2);
	int MakeTestCurveOnSurface(NURBSSet &nset, int p);
	int MakeTestPointCurveOnSurface(NURBSSet &nset, int p);
	int MakeTestSurfaceNormalCurve(NURBSSet &nset, int p);


	int MakeTestCVSurface(NURBSSet &nset, Matrix3 mat, BOOL rigid=FALSE);
	int MakeTestPointSurface(NURBSSet &nset, Matrix3 mat);
	int MakeTestBlendSurface(NURBSSet &nset, int p1, int p2);
	int MakeTestOffsetSurface(NURBSSet &nset, int p);
	int MakeTestXFormSurface(NURBSSet &nset, int p);
	int MakeTestMirrorSurface(NURBSSet &nset, int p);
	int MakeTestRuledSurface(NURBSSet &nset, int p1, int p2);
	int MakeTestULoftSurface(NURBSSet &nset, int p1, int p2, int p3);
	int MakeTestExtrudeSurface(NURBSSet &nset, int p1);
	int MakeTestLatheSurface(NURBSSet &nset);
	int MakeTestUVLoftSurface(NURBSSet &nset);
	int MakeTestNBlendSurface(NURBSSet &nset);
	int MakeTest1RailSweepSurface(NURBSSet &nset);
	int MakeTest2RailSweepSurface(NURBSSet &nset);
	int MakeTestCapSurface(NURBSSet &nset);
	int MakeTestMultiCurveTrimSurface(NURBSSet &nset);

};




class SurfApproxUtilDesc : public ClassDesc
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new SurfApproxUtil();}
	const TCHAR *	ClassName();
	SClass_ID		SuperClassID() { return UTILITY_CLASS_ID; }
	Class_ID		ClassID() { return SURF_APPROX_UTIL_CLASS_ID; }
	const TCHAR* 	Category();
};
extern ClassDesc* GetSurfApproxUtilDesc();

class APITestUtilDesc : public ClassDesc
{
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) {return new APITestUtil();}
	const TCHAR *	ClassName();
	SClass_ID		SuperClassID() { return UTILITY_CLASS_ID; }
	Class_ID		ClassID() { return API_TEST_UTIL_CLASS_ID; }
	const TCHAR* 	Category();
};
extern ClassDesc* GetAPITestUtilDesc();




#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\nutil.cpp ===
/**********************************************************************
 *<
	FILE: NURBS.cpp

	DESCRIPTION: A Test harness utility plugin for the NURBS API

	CREATED BY: Charlie Thaeler

	HISTORY: created 8/13/97

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "nutil.h"


HINSTANCE hInstance;

// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

TCHAR *GetString(int id)
{
    static TCHAR buf[256];
    
    if (hInstance)
        return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
    return NULL;
}


int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, ULONG fdwReason, LPVOID lpvReserved) 
{
    hInstance = hinstDLL;
    static call=0;
    
    if ( !controlsInit ) {
        controlsInit = TRUE;
        
        // jaguar controls
        InitCustomControls(hInstance);
        
        // initialize Chicago controls
        InitCommonControls();
    }
    
    switch(fdwReason) {
    case DLL_PROCESS_ATTACH:
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_THREAD_DETACH:
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return(TRUE);
}


//------------------------------------------------------
// This is the interface to Max:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_LIB_DESCRIPTION); }

/// MUST CHANGE THIS NUMBER WHEN NEW CLASS ARE ADD
__declspec( dllexport ) int LibNumberClasses()
{
#ifdef _DEBUG
    return 2;
#else
    return 1;
#endif
}





__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) 
{
    switch(i) {
    case 0: return GetSurfApproxUtilDesc();	// Batch Surface Approximation changer
#ifdef _DEBUG
	case 1: return GetAPITestUtilDesc();	// API Test Class
#endif
    default: return 0;
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\srf_dump.cpp ===
/**********************************************************************
 *<
    FILE: srf_dump.cpp

    DESCRIPTION:  Test Utility for the API

    CREATED BY: Charlie Thaeler

    HISTORY: created 18 Feb, 1998

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"




void
APITestUtil::DumpMatrix3(int indent, Matrix3& mat)
{
	char indStr[80];

	for (int i = 0; i <= indent; i++)
		indStr[i] = ' ';
	indStr[indent+1] = '\0';

	for (i = 0; i < 4; i++) {
		Point3 p = mat.GetRow(i);
		DumpPrint("%s   %10.4f %10.4f %10.4f\n", indStr, p.x, p.y, p.z);
	}
}

static TCHAR ybuf[256];
static TCHAR nbuf[256];
BOOL y_n_init = FALSE;
static TCHAR *
YorN(BOOL yorn)
{
    if (hInstance && !y_n_init) {
        LoadString(hInstance, IDS_YES, ybuf, sizeof(ybuf));
        LoadString(hInstance, IDS_NO, nbuf, sizeof(nbuf));
	}
	if (yorn)
		return ybuf;
	return nbuf;
}


void
APITestUtil::PrintPoint(int indent, Point3 pt)
{
	char indStr[80];

	for (int i = 0; i <= indent; i++)
		indStr[i] = ' ';
	indStr[indent+1] = '\0';
	DumpPrint("%s   %s %g", indStr, GetString(IDS_X), pt.x);
	DumpPrint("   %s %g", GetString(IDS_Y), pt.y);
	DumpPrint("  %s %g\n", GetString(IDS_Z), pt.z);
}

void
APITestUtil::DumpObject(int indent, NURBSObject* nobj, TimeValue t)
{
	char indStr[80];

	for (int i = 0; i <= indent; i++)
		indStr[i] = ' ';
	indStr[indent+1] = '\0';

	// now common object stuff
	DumpPrint("%s%s \"%s\" ", indStr, GetString(IDS_NAME), nobj->GetName());
	DumpPrint(" %s  %lx ", GetString(IDS_ID), nobj->GetId());
	DumpPrint(" %s  ", GetString(IDS_TYPE));

	switch (nobj->GetType()) {
	case kNPoint:
		DumpPrint("%s", GetString(IDS_POINT));
		break;
	case kNPointCPoint:
		DumpPrint("%s", GetString(IDS_POINT_CONST_POINT));
		break;
	case kNCurveCPoint:
		DumpPrint("%s", GetString(IDS_CURVE_CONST_POINT));
		break;
	case kNCurveCurveIntersectionPoint:
		DumpPrint("%s", GetString(IDS_CURVE_CURVE_POINT));
		break;
	case kNSurfaceCPoint:
		DumpPrint("%s", GetString(IDS_SURF_CONST_POINT));
		break;
	case kNCurveSurfaceIntersectionPoint:
		DumpPrint("%s", GetString(IDS_CURV_SURF_INT_POINT));
		break;
	case kNTexturePoint:
		DumpPrint("%s", GetString(IDS_TEXTURE_POINT));
		break;

	case kNCV:
		DumpPrint("%s", GetString(IDS_CV));
		break;

	case kNCVCurve:
		DumpPrint("%s", GetString(IDS_CV_CURVE));
		break;
	case kNPointCurve:
		DumpPrint("%s", GetString(IDS_POINT_CURVE));
		break;
	case kNBlendCurve:
		DumpPrint("%s", GetString(IDS_BLEND_CURVE));
		break;
	case kNOffsetCurve:
		DumpPrint("%s", GetString(IDS_OFFSET_CURVE));
		break;
	case kNXFormCurve:
		DumpPrint("%s", GetString(IDS_XFORM_CURVE));
		break;
	case kNMirrorCurve:
		DumpPrint("%s", GetString(IDS_MIRROR_CURVE));
		break;
	case kNFilletCurve:
		DumpPrint("%s", GetString(IDS_FILLET_CURVE));
		break;
	case kNChamferCurve:
		DumpPrint("%s", GetString(IDS_CHAMFER_CURVE));
		break;
	case kNIsoCurve:
		DumpPrint("%s", GetString(IDS_ISO_CURVE));
		break;
	case kNProjectVectorCurve:
		DumpPrint("%s", GetString(IDS_PROJ_VECT_CURVE));
		break;
	case kNProjectNormalCurve:
		DumpPrint("%s", GetString(IDS_PROJ_NORM_CURVE));
		break;
	case kNSurfSurfIntersectionCurve:
		DumpPrint("%s", GetString(IDS_SURF_SURF_CURVE));
		break;
	case kNCurveOnSurface:
		DumpPrint("%s", GetString(IDS_COS_CURVE));
		break;
	case kNPointCurveOnSurface:
		DumpPrint("%s", GetString(IDS_POINT_COS_CURVE));
		break;
	case kNSurfaceNormalCurve:
		DumpPrint("%s", GetString(IDS_SURF_NORM_CURVE));
		break;



	case kNCVSurface:
		DumpPrint("%s", GetString(IDS_CV_SURFACE));
		break;
	case kNPointSurface:
		DumpPrint("%s", GetString(IDS_POINT_SURFACE));
		break;
	case kNBlendSurface:
		DumpPrint("%s", GetString(IDS_BLEND_SURFACE));
		break;
	case kNOffsetSurface:
		DumpPrint("%s", GetString(IDS_OFFSET_SURFACE));
		break;
	case kNXFormSurface:
		DumpPrint("%s", GetString(IDS_XFORM_SURFACE));
		break;
	case kNMirrorSurface:
		DumpPrint("%s", GetString(IDS_MIRROR_SURFACE));
		break;
	case kNRuledSurface:
		DumpPrint("%s", GetString(IDS_RULED_SURFACE));
		break;
	case kNULoftSurface:
		DumpPrint("%s", GetString(IDS_ULOFT_SURFACE));
		break;
	case kNUVLoftSurface:
		DumpPrint("%s", GetString(IDS_UVLOFT_SURFACE));
		break;
	case kNExtrudeSurface:
		DumpPrint("%s", GetString(IDS_EXTRUDE_SURFACE));
		break;
	case kNLatheSurface:
		DumpPrint("%s", GetString(IDS_LATHE_SURFACE));
		break;
	case kNNBlendSurface:
		DumpPrint("%s", GetString(IDS_NBLEND_SURFACE));
		break;
	case kN1RailSweepSurface:
		DumpPrint("%s", GetString(IDS_1RAIL_SURFACE));
		break;
	case kN2RailSweepSurface:
		DumpPrint("%s", GetString(IDS_2RAIL_SURFACE));
		break;
	case kNCapSurface:
		DumpPrint("%s", GetString(IDS_CAP_SURFACE));
		break;
	case kNMultiCurveTrimSurface:
		DumpPrint("%s", GetString(IDS_MULTI_TRIM_SURFACE));
		break;
	case kNFilletSurface:
		DumpPrint("%s", GetString(IDS_FILLET_SURFACE));
		break;
	}

	if (nobj->IsSelected())
		DumpPrint("  %s\n", GetString(IDS_SELECTED));
	else
		DumpPrint("  %s\n", GetString(IDS_NOT_SELECTED));


	// dump CV data since it doesn't otherwise exist in the database
	if (indent > 0 && nobj->GetType() != kNCV)
		return;

	// now stuff common amongst groups of types
	switch (nobj->GetKind()) {
	case kNURBSPoint:
		{
		NURBSPoint* pNPnt = (NURBSPoint*)nobj;
		double x, y, z;
		pNPnt->GetPosition(t, x, y, z);
		PrintPoint(indent, Point3(x, y, z));
		break; }

	case kNURBSTexturePoint:
		{
		NURBSTexturePoint* pNPnt = (NURBSTexturePoint*)nobj;
		double x, y;
		pNPnt->GetPosition(t, x, y);
		PrintPoint(indent, Point3(x, y, 0.0));
		break; }

	case kNURBSCurve:
		{
		NURBSCurve* pNCrv = (NURBSCurve*)nobj;

		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_MAT_ID),
			pNCrv->MatID());
		// Timming data.
        int numTrimPts = pNCrv->NumTrimPoints();
        DumpPrint("%s %d\n", GetString(IDS_NUM_TRIM_POINTS), numTrimPts);
        for(int i = 0; i < numTrimPts; i++) {
            NURBSTrimPoint trimPt = pNCrv->GetTrimPoint(t, i);
			DumpPrint("%s %g ", GetString(IDS_PARAMETER),
								trimPt.GetParameter());
            switch(trimPt.GetDirection()) {
            case kNone:
                DumpPrint(GetString(IDS_DIRECTION_NONE));
                break;
            case kPositive:
                 DumpPrint(GetString(IDS_DIRECTION_POS));
                break;
            case kNegative:
                DumpPrint(GetString(IDS_DIRECTION_NEG));
                break;
            }
        }
		break; }

	case kNURBSSurface:
		{
		NURBSSurface* pNSrf = (NURBSSurface*)nobj;
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_RENDERABLE),
			YorN(pNSrf->Renderable()));
		DumpPrint("%s   %s %s\n", indStr, GetString(IDS_FLIP_NORMALS),
			YorN(pNSrf->FlipNormals()));
		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_MAT_ID),
			pNSrf->MatID());
		DumpPrint("%s   %s %s\n", indStr, GetString(IDS_CLOSED_U),
			YorN(pNSrf->IsClosedInU()));
		DumpPrint("%s   %s %s\n", indStr, GetString(IDS_CLOSED_V),
			YorN(pNSrf->IsClosedInV()));
		for (int i = 0; i < pNSrf->NumChannels(); i++) {
            int channel = pNSrf->GetChannelFromIndex(i);
            if (pNSrf->GenerateUVs(channel)) {
                DumpPrint("%s   %s %d\n", indStr,
                          GetString(IDS_UV_CHANNEL), channel);
                DumpPrint("%s     %s:      %s\n", indStr,
                          GetString(IDS_GENUV), YorN(pNSrf->GenerateUVs(channel)));
                for (int tex = 0; tex < 4; tex++) {
                    Point2 tuv = pNSrf->GetTextureUVs(t, tex, channel);
                    DumpPrint("%s       %s %d = U: %g  V: %g\n", indStr,
                              GetString(IDS_TEXUV), tex, tuv.x, tuv.y);
                }
                float ut, vt, uo, vo, a;
                pNSrf->GetTileOffset(t, ut, vt, uo, vo, a, channel);
                DumpPrint("%s     %s %g", indStr, GetString(IDS_UOFFSET), uo);
                DumpPrint("  %s %g\n", GetString(IDS_VOFFSET), vo);
                DumpPrint("%s     %s   %g", indStr, GetString(IDS_UTILE), ut);
                DumpPrint("  %s   %g\n", GetString(IDS_VTILE), vt);
                DumpPrint("%s     %s   %g\n", indStr, GetString(IDS_ANGLE), a);
                
                NURBSTextureSurface *pTexSurf = &pNSrf->GetTextureSurface(channel);
				switch (pTexSurf->MapperType()) {
				case kNMapDefault:
                    DumpPrint("  %s\n", GetString(IDS_CLP));
					break;
				case kNMapUserDefined: {
                    DumpPrint("\n");
                    int numU = pTexSurf->GetNumUPoints(),
                        numV = pTexSurf->GetNumVPoints();
                    DumpPrint("%s  %s", indStr, GetString(IDS_TEXTURE_POINT));
                    DumpPrint(" %s  %d", GetString(IDS_U), numU);
                    DumpPrint(" %s  %d\n", GetString(IDS_V), numV);
                    for (int u = 0; u < numU; u++)
                        for (int v = 0; v < numV; v++)
                            DumpObject(indent+4, pTexSurf->GetPoint(u, v), t);
						break; }
				case kNMapSufaceMapper:
                    DumpPrint("  %s\n", GetString(IDS_SURFACE_MAPPER));
					DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pTexSurf->GetParentId());
					break;
                }
            }
		}

		int numTrimLoops = pNSrf->NumTrimLoops(t);
		if (numTrimLoops > 0) {
			for (int loop = 0; loop < numTrimLoops; loop++) {
				int numCrvs = pNSrf->NumCurvesInLoop(t, loop);
				for (int crv = 0; crv < numCrvs; crv++) {
					int degree, numCVs, numKnots;
					NURBSCVTab cvs;
					NURBSKnotTab knots;
					if (pNSrf->Get2dTrimCurveData(t, loop, crv, degree,
										numCVs, cvs, numKnots, knots)) {
						DumpPrint("      TRIM LOOP %d CURVE %d degree %d\n", loop, crv, degree);
						for (int cv = 0; cv < numCVs; cv++) {
							double x, y, z;
							cvs[cv].GetPosition(t, x, y, z);
							DumpPrint("        %s[%d]: %f %f %f\n", GetString(IDS_CV), cv, x, y, z);
						}
					}
				}
			}
		}

		break; }
	}



	// now object type specific stuff
	switch (nobj->GetType()) {
	case kNPoint: {
		NURBSIndependentPoint* pNPnt = (NURBSIndependentPoint*)nobj;
		double x, y, z;
		pNPnt->GetPosition(t, x, y, z);
		PrintPoint(indent, Point3(x, y, z));
		break; }
	case kNTexturePoint: {
		NURBSTexturePoint* pNPnt = (NURBSTexturePoint*)nobj;
		double x, y;
		pNPnt->GetPosition(t, x, y);
		PrintPoint(indent, Point3(x, y, 0.0));
		break; }
	case kNPointCPoint: {
		NURBSPointConstPoint* pNPnt = (NURBSPointConstPoint*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId());
		switch(pNPnt->GetPointType()) {
		case kNConstOnObject:
			DumpPrint("%s   %s\n", indStr, GetString(IDS_ON_OBJECT));
			break;
		case kNConstOffset: {
			DumpPrint("%s   %s", indStr, GetString(IDS_OFFSET));
			Point3 p = pNPnt->GetOffset(t);
			PrintPoint(0, p);
			break; }
		}
		break; }
	case kNCurveCPoint: {
		NURBSCurveConstPoint* pNPnt = (NURBSCurveConstPoint*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId());
		DumpPrint("%s   %s %g\n", indStr, GetString(IDS_UPARAM), pNPnt->GetUParam(t));
		switch(pNPnt->GetPointType()) {
		case kNConstOnObject:
			DumpPrint("%s   %s\n", indStr, GetString(IDS_ON_OBJECT));
			break;
		case kNConstOffset: {
			DumpPrint("%s   %s", indStr, GetString(IDS_OFFSET));
			Point3 p = pNPnt->GetOffset(t);
			PrintPoint(0, p);
			break; }
		case kNConstNormal: {
			DumpPrint("%s   %s %g\n", indStr, GetString(IDS_NORMAL), pNPnt->GetNormal(t));
			break; }
		case kNConstTangent: {
			DumpPrint("%s   %s %g\n", indStr, GetString(IDS_UTANGENT), pNPnt->GetUTangent(t));
			break; }
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM), YorN(pNPnt->GetTrimCurve()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNPnt->GetFlipTrim()));
		}
		break; }
	case kNSurfaceCPoint: {
		NURBSSurfConstPoint* pNPnt = (NURBSSurfConstPoint*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId());
		DumpPrint("%s   %s %g", indStr, GetString(IDS_UPARAM), pNPnt->GetUParam(t));
		DumpPrint("  %s %g\n", GetString(IDS_VPARAM), pNPnt->GetVParam(t));
		switch(pNPnt->GetPointType()) {
		case kNConstOnObject:
			DumpPrint("%s   %s\n", indStr, GetString(IDS_ON_OBJECT));
			break;
		case kNConstOffset: {
			DumpPrint("%s   %s", indStr, GetString(IDS_OFFSET));
			Point3 p = pNPnt->GetOffset(t);
			PrintPoint(0, p);
			break; }
		case kNConstNormal: {
			DumpPrint("%s   %s %g\n", indStr, GetString(IDS_NORMAL), pNPnt->GetNormal(t));
			break; }
		case kNConstTangent: {
			DumpPrint("%s   %s %g\n", indStr, GetString(IDS_UTANGENT), pNPnt->GetUTangent(t));
			DumpPrint("%s   %s %g\n", indStr, GetString(IDS_VTANGENT), pNPnt->GetVTangent(t));
			break; }
		}
		break; }
	case kNCurveCurveIntersectionPoint: {
		NURBSCurveCurveIntersectionPoint* pNPnt = (NURBSCurveCurveIntersectionPoint*)nobj;
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId(i));
			DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM), YorN(pNPnt->GetTrimCurve(i)));
			DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNPnt->GetFlipTrim(i)));
		}
		break; }
	case kNCurveSurfaceIntersectionPoint: {
		NURBSCurveSurfaceIntersectionPoint* pNPnt = (NURBSCurveSurfaceIntersectionPoint*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNPnt->GetParentId(1));
		DumpPrint("%s  %s (%g %g)\n", indStr, GetString(IDS_SEED), pNPnt->GetSeed());
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM), YorN(pNPnt->GetTrimCurve()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNPnt->GetFlipTrim()));
		break; }




	case kNCV: {
		NURBSControlVertex* pNCV = (NURBSControlVertex*)nobj;
		double x, y, z, w;
		pNCV->GetPosition(t, x, y, z);
		w = pNCV->GetWeight(t);
		PrintPoint(indent, Point3(x, y, z));
		break; }




	case kNCVCurve: {
		NURBSCVCurve *pNCurve = (NURBSCVCurve*)nobj;
		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_ORDER), pNCurve->GetOrder());
		int numK = pNCurve->GetNumKnots();
		DumpPrint("%s  %s %d\n%s    ", indStr, GetString(IDS_KNOTS), numK, indStr);
		for (int k = 0; k < numK; k++)
			DumpPrint("%g ", pNCurve->GetKnot(k));
		DumpPrint("\n");
		int numCV = pNCurve->GetNumCVs();
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNCurve->GetTransformMatrix(t));
		DumpPrint("%s  %s %d\n", indStr, GetString(IDS_CVS), numCV);
		for (int cv = 0; cv < numCV; cv++)
			DumpObject(indent+4, pNCurve->GetCV(cv), t);
		break; }
	case kNPointCurve: {
		NURBSPointCurve *pNCurve = (NURBSPointCurve*)nobj;
		int num = pNCurve->GetNumPts();
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNCurve->GetTransformMatrix(t));
		DumpPrint("%s  %s %d\n", indStr, GetString(IDS_POINTS), num);
		for (int p = 0; p < num; p++)
			DumpObject(indent+4, pNCurve->GetPoint(p), t);
		break; }
	case kNOffsetCurve: {
		NURBSOffsetCurve *pNCurve = (NURBSOffsetCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s  %s %g\n", indStr, GetString(IDS_DISTANCE), pNCurve->GetDistance(t));
		break; }
	case kNXFormCurve: {
		NURBSXFormCurve *pNCurve = (NURBSXFormCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s  %s\n", indStr, GetString(IDS_TRANSFORM));
		DumpMatrix3(indent+4, pNCurve->GetXForm(t));
		break; }
	case kNMirrorCurve: {
		NURBSMirrorCurve *pNCurve = (NURBSMirrorCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s  %s %g\n", indStr, GetString(IDS_DISTANCE), pNCurve->GetDistance(t));
		DumpPrint("%s  %s", indStr, GetString(IDS_AXIS));
		switch (pNCurve->GetAxis()) {
		case kMirrorX:
			DumpPrint("%s\n", GetString(IDS_MIRRORX));
			break;
		case kMirrorY:
			DumpPrint("%s\n", GetString(IDS_MIRRORY));
			break;
		case kMirrorZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORZ));
			break;
		case kMirrorXY:
			DumpPrint("%s\n", GetString(IDS_MIRRORXY));
			break;
		case kMirrorXZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORXZ));
			break;
		case kMirrorYZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORYZ));
			break;
		}
		DumpPrint("%s  %s\n", indStr, GetString(IDS_TRANSFORM));
		DumpMatrix3(indent+4, pNCurve->GetXForm(t));
		break; }
	case kNBlendCurve: {
		NURBSBlendCurve *pNCurve = (NURBSBlendCurve*)nobj;
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(i));
			DumpPrint("%s  %s %d  %g\n", indStr, GetString(IDS_TENSION), i, pNCurve->GetTension(t, i));
			DumpPrint("%s  %s %d", indStr, GetString(IDS_END), i);
			if (pNCurve->GetEnd(i))
				DumpPrint(" %s\n", GetString(IDS_HIGHU));
			else
				DumpPrint(" %s\n", GetString(IDS_LOWU));
		}
		break; }
	case kNFilletCurve: {
		NURBSFilletCurve *pNCurve = (NURBSFilletCurve*)nobj;
		DumpPrint("%s  Radius: %g\n", indStr, pNCurve->GetRadius(t));
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(i));
			DumpPrint("%s  %s %d", indStr, GetString(IDS_END), i);
			if (pNCurve->GetEnd(i))
				DumpPrint(" %s\n", GetString(IDS_HIGHU));
			else
				DumpPrint(" %s\n", GetString(IDS_LOWU));
			DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM), YorN(pNCurve->GetTrimCurve(i)));
		}
		break; }
	case kNChamferCurve: {
		NURBSChamferCurve *pNCurve = (NURBSChamferCurve*)nobj;
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(i));
			DumpPrint("%s  Length(%d): %g\n", indStr, i, pNCurve->GetLength(t, i));
			DumpPrint("%s  %s %d", indStr, GetString(IDS_END), i);
			if (pNCurve->GetEnd(i))
				DumpPrint(" %s\n", GetString(IDS_HIGHU));
			else
				DumpPrint(" %s\n", GetString(IDS_LOWU));
			DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM), YorN(pNCurve->GetTrimCurve(i)));
		}
		break; }
	case kNIsoCurve: {
		NURBSIsoCurve *pNCurve = (NURBSIsoCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s  %s", indStr, GetString(IDS_DIRECTION));
		if (pNCurve->GetDirection())
			DumpPrint(" %s %g\n", GetString(IDS_U), pNCurve->GetParam(t));
		else
			DumpPrint(" %s %g\n", GetString(IDS_V), pNCurve->GetParam(t));
		Point2 seed = pNCurve->GetSeed();
		DumpPrint("%s  %s (%g %g)\n", indStr, GetString(IDS_SEED), seed.x, seed.y);
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim()));
		break; }
	case kNProjectVectorCurve: {
		NURBSProjectVectorCurve* pNCurve = (NURBSProjectVectorCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(1));
		Point3 p = pNCurve->GetPVec(t);
		DumpPrint("%s  EVec ", indStr);
		PrintPoint(0, p);
		Point2 seed = pNCurve->GetSeed();
		DumpPrint("%s  %s (%g %g)\n", indStr, GetString(IDS_SEED), seed.x, seed.y);
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim()));
		break; }
	case kNProjectNormalCurve: {
		NURBSProjectNormalCurve* pNCurve = (NURBSProjectNormalCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(1));
		Point2 seed = pNCurve->GetSeed();
		DumpPrint("%s  %s (%g %g)\n", indStr, GetString(IDS_SEED), seed.x, seed.y);
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim()));
		break; }
	case kNSurfSurfIntersectionCurve: {
		NURBSSurfSurfIntersectionCurve* pNCurve = (NURBSSurfSurfIntersectionCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId(1));
		Point2 seed = pNCurve->GetSeed();
		DumpPrint("%s  %s (%g %g)\n", indStr, GetString(IDS_SEED), seed.x, seed.y);
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim(0)));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim(0)));
		DumpPrint("%s   %s 1 %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim(1)));
		DumpPrint("%s   %s 2 %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim(1)));
		break; }
	case kNCurveOnSurface: {
		NURBSCurveOnSurface* pNCurve = (NURBSCurveOnSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim()));
		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_ORDER), pNCurve->GetOrder());
		int numK = pNCurve->GetNumKnots();
		DumpPrint("%s  %s %d\n%s    ", indStr, GetString(IDS_KNOTS), numK, indStr);
		for (int k = 0; k < numK; k++)
			DumpPrint("%g ", pNCurve->GetKnot(k));
		DumpPrint("\n");
		int numCV = pNCurve->GetNumCVs();
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNCurve->GetTransformMatrix(t));
		DumpPrint("%s  %s %d\n", indStr, GetString(IDS_CVS), numCV);
		for (int cv = 0; cv < numCV; cv++)
			DumpObject(indent+4, pNCurve->GetCV(cv), t);
		break; }
	case kNPointCurveOnSurface: {
		NURBSPointCurveOnSurface* pNCurve = (NURBSPointCurveOnSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_TRIM_SURFACE), YorN(pNCurve->GetTrim()));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_FLIP_TRIM), YorN(pNCurve->GetFlipTrim()));
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNCurve->GetTransformMatrix(t));
		int numPnts = pNCurve->GetNumPts();
		DumpPrint("%s  %s %d\n", indStr, GetString(IDS_POINT), numPnts);
		for (int i = 0; i < numPnts; i++)
			DumpObject(indent+4, pNCurve->GetPoint(i), t);
		break; }
	case kNSurfaceNormalCurve: {
		NURBSSurfaceNormalCurve* pNCurve = (NURBSSurfaceNormalCurve*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNCurve->GetParentId());
		DumpPrint("%s  %s %g\n", indStr, GetString(IDS_DISTANCE), pNCurve->GetDistance(t));
		break; }




	case kNCVSurface: {
		NURBSCVSurface *pNSurface = (NURBSCVSurface*)nobj;
		if (pNSurface->IsRigid())
			DebugPrint("%s   %s\n", indStr, GetString(IDS_RIGID));
		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_UORDER), pNSurface->GetUOrder());
		DumpPrint("%s   %s %d\n", indStr, GetString(IDS_VORDER), pNSurface->GetVOrder());
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNSurface->GetTransformMatrix(t));
		int numK = pNSurface->GetNumUKnots();
		DumpPrint("%s  %s %d\n%s    ", indStr, GetString(IDS_UKNOTS),
						numK, indStr);
		for (int k = 0; k < numK; k++)
			DumpPrint("%g ", pNSurface->GetUKnot(k));
		DumpPrint("\n");
		numK = pNSurface->GetNumVKnots();
		DumpPrint("%s  %s %d\n%s    ", indStr, GetString(IDS_VKNOTS),
						numK, indStr);
		for (k = 0; k < numK; k++)
			DumpPrint("%g ", pNSurface->GetVKnot(k));
		DumpPrint("\n");
		int numU = pNSurface->GetNumUCVs(),
			numV = pNSurface->GetNumVCVs();
		DumpPrint("%s  %s", indStr, GetString(IDS_CVS));
		DumpPrint(" %s  %d", GetString(IDS_U), numU);
		DumpPrint(" %s  %d\n", GetString(IDS_V), numV);
		for (int u = 0; u < numU; u++)
			for (int v = 0; v < numV; v++)
				DumpObject(indent+4, pNSurface->GetCV(u, v), t);
		break; }
	case kNPointSurface: {
		NURBSPointSurface *pNSurface = (NURBSPointSurface*)nobj;
		DumpPrint("%s  %s\n", indStr, GetString(IDS_XFORM_MAT));
		DumpMatrix3(indent+4, pNSurface->GetTransformMatrix(t));
		int numU = pNSurface->GetNumUPts(),
			numV = pNSurface->GetNumVPts();
		DumpPrint("%s  %s", indStr, GetString(IDS_POINTS));
		DumpPrint(" %s  %d", GetString(IDS_U), numU);
		DumpPrint(" %s  %d\n", GetString(IDS_V), numV);
		for (int u = 0; u < numU; u++)
			for (int v = 0; v < numV; v++)
				DumpObject(indent+4, pNSurface->GetPoint(u, v), t);
		break; }
	case kNBlendSurface: {
		NURBSBlendSurface *pNSurface = (NURBSBlendSurface*)nobj;
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
			DumpPrint("%s  %s %d   %g\n", indStr, GetString(IDS_TENSION), i, pNSurface->GetTension(t, i));
			DumpPrint("%s  %s %d  ", indStr, GetString(IDS_EDGE), i);
			switch (pNSurface->GetEdge(i)) {
			case 0:
				DumpPrint("%s\n", GetString(IDS_LOWU));
				break;
			case 1:
				DumpPrint("%s\n", GetString(IDS_HIGHU));
				break;
			case 2:
				DumpPrint("%s\n", GetString(IDS_LOWV));
				break;
			case 3:
				DumpPrint("%s\n", GetString(IDS_HIGHV));
				break;
			}
			DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_FLIP), i, YorN(pNSurface->GetFlip(i)));
		}
		break; }
	case kNOffsetSurface: {
		NURBSOffsetSurface *pNSurface = (NURBSOffsetSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  %s %g\n", indStr, GetString(IDS_DISTANCE), pNSurface->GetDistance(t));
		break; }
	case kNRuledSurface: {
		NURBSRuledSurface *pNSurface = (NURBSRuledSurface*)nobj;
		for (int i = 0; i < 2; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
			DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_FLIP), i, YorN(pNSurface->GetFlip(i)));
		}
		break; }
	case kNULoftSurface: {
		NURBSULoftSurface *pNSurface = (NURBSULoftSurface*)nobj;
		int numC = pNSurface->GetNumCurves();
		for (int i = 0; i < numC; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
			DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_FLIP), i, YorN(pNSurface->GetFlip(i)));
		}
		break; }
	case kNUVLoftSurface: {
		NURBSUVLoftSurface* pNSurface = (NURBSUVLoftSurface*)nobj;
		int numUC = pNSurface->GetNumUCurves();
		for (int i = 0; i < numUC; i++)
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetUParentId(i));
		int numVC = pNSurface->GetNumVCurves();
		for (i = 0; i < numVC; i++)
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetVParentId(i));
		break; }
	case kNXFormSurface: {
		NURBSXFormSurface *pNSurface = (NURBSXFormSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  %s\n", indStr, GetString(IDS_TRANSFORM));
		DumpMatrix3(indent+4, pNSurface->GetXForm(t));
		break; }
	case kNMirrorSurface: {
		NURBSMirrorSurface *pNSurface = (NURBSMirrorSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  Distance: %g\n", indStr, pNSurface->GetDistance(t));
		DumpPrint("%s  %s", indStr, GetString(IDS_AXIS));
		switch (pNSurface->GetAxis()) {
		case kMirrorX:
			DumpPrint("%s\n", GetString(IDS_MIRRORX));
			break;
		case kMirrorY:
			DumpPrint("%s\n", GetString(IDS_MIRRORY));
			break;
		case kMirrorZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORZ));
			break;
		case kMirrorXY:
			DumpPrint("%s\n", GetString(IDS_MIRRORXY));
			break;
		case kMirrorXZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORXZ));
			break;
		case kMirrorYZ:
			DumpPrint("%s\n", GetString(IDS_MIRRORYZ));
			break;
		}
		DumpPrint("%s  %s\n", indStr, GetString(IDS_TRANSFORM));
		DumpMatrix3(indent+4, pNSurface->GetXForm(t));
		break; }
	case kNExtrudeSurface: {
		NURBSExtrudeSurface *pNSurface = (NURBSExtrudeSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  Distance: %g\n", indStr, pNSurface->GetDistance(t));
		DumpMatrix3(indent+4, pNSurface->GetAxis(t));
		break; }
	case kNLatheSurface: {
		NURBSLatheSurface *pNSurface = (NURBSLatheSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  %s %g\n", indStr, GetString(IDS_DEGREES), pNSurface->GetRotation(t));
		DumpPrint("%s  %s\n", indStr, GetString(IDS_AXIS));
		DumpMatrix3(indent+4, pNSurface->GetAxis(t));
		break; }
	case kN1RailSweepSurface: {
		NURBS1RailSweepSurface* pNSurface = (NURBS1RailSweepSurface*)nobj;
		int numC = pNSurface->GetNumCurves();
		for (int i = 0; i < numC; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
			DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_FLIP), i, YorN(pNSurface->GetFlip(i)));
		}
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_RAIL_ID), pNSurface->GetParentRailId());
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_PARALLEL), i, YorN(pNSurface->GetParallel()));
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_SNAPCS), i, YorN(pNSurface->GetSnapCS()));
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_ROADLIKE), i, YorN(pNSurface->GetRoadlike()));
		DumpMatrix3(indent+4, pNSurface->GetAxis(t));
		break; }
	case kN2RailSweepSurface: {
		NURBS2RailSweepSurface* pNSurface = (NURBS2RailSweepSurface*)nobj;
		int numC = pNSurface->GetNumCurves();
		for (int i = 0; i < numC; i++) {
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
			DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_FLIP), i, YorN(pNSurface->GetFlip(i)));
		}
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_RAIL_ID), pNSurface->GetRailParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_RAIL_ID), pNSurface->GetRailParentId(1));
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_PARALLEL), i, YorN(pNSurface->GetParallel()));
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_SCALE), i, YorN(pNSurface->GetScale()));
		DumpPrint("%s  %s %d  %s\n", indStr, GetString(IDS_SNAPCS), i, YorN(pNSurface->GetSnapCS()));
		break; }
	case kNNBlendSurface: {
		NURBSNBlendSurface* pNSurface = (NURBSNBlendSurface*)nobj;
		for (int i = 0; i < 4; i++) {
			NURBSId nid = pNSurface->GetParentId(i);
			if (nid == 0) continue;
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), nid);
			DumpPrint("%s  %s %d ", indStr, GetString(IDS_EDGE), i);
			switch (pNSurface->GetEdge(i)) {
			case 0:
				DumpPrint("%s\n", GetString(IDS_LOWU));
				break;
			case 1:
				DumpPrint("%s\n", GetString(IDS_HIGHU));
				break;
			case 2:
				DumpPrint("%s\n", GetString(IDS_LOWV));
				break;
			case 3:
				DumpPrint("%s\n", GetString(IDS_HIGHV));
				break;
			}
		}
		break; }
	case kNCapSurface: {
		NURBSCapSurface* pNSurface = (NURBSCapSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId());
		DumpPrint("%s  %s  ", indStr, GetString(IDS_EDGE));
		switch (pNSurface->GetEdge()) {
		case 0:
			DumpPrint("%s\n", GetString(IDS_LOWU));
			break;
		case 1:
			DumpPrint("%s\n", GetString(IDS_HIGHU));
			break;
		case 2:
			DumpPrint("%s\n", GetString(IDS_LOWV));
			break;
		case 3:
			DumpPrint("%s\n", GetString(IDS_HIGHV));
			break;
		}
		break; }
	case kNMultiCurveTrimSurface: {
		NURBSMultiCurveTrimSurface* pNSurface = (NURBSMultiCurveTrimSurface*)nobj;
		DumpPrint("%s  Surf %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetSurfaceParentId());
		int numC = pNSurface->GetNumCurves();
		for (int i = 0; i < numC; i++)
			DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(i));
		break; }
	case kNFilletSurface: {
		NURBSFilletSurface* pNSurface = (NURBSFilletSurface*)nobj;
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(0));
		DumpPrint("%s  %s %lx\n", indStr, GetString(IDS_PARENT_ID), pNSurface->GetParentId(1));
		DumpPrint("%s  %s %d %g\n", indStr, GetString(IDS_RADIUS), 0, pNSurface->GetRadius(t, 0));
		DumpPrint("%s  %s %d %g\n", indStr, GetString(IDS_RADIUS), 1, pNSurface->GetRadius(t, 1));
		DumpPrint("%s   %s  %s\n", indStr, GetString(IDS_CUBIC), YorN(pNSurface->IsCubic()));
		break; }
	}

	DumpPrint("\n\n");
}


void
APITestUtil::DumpPrint(const TCHAR *format, ...)
{
	TCHAR buf[512];
	va_list args;
	va_start(args,format);
	_vsntprintf(buf,512,format,args);
	va_end(args);
	if (mToFile && mFP) {
		fprintf(mFP, buf);
		return;
	}

	DebugPrint(buf);
}

void
APITestUtil::DumpSelected()
{
	if (mToFile && strlen(mFilename) > 0) {
		// try to open the file
		mFP = fopen(mFilename, "w");
	}
	for (int i=0; i < mpIp->GetSelNodeCount(); i++) {
		// Get a selected node
		INode* node = mpIp->GetSelNode(i);
		Object* obj = node->GetObjectRef();

		NURBSSet getSet;
		BOOL getres = GetNURBSSet(obj, mpIp->GetTime(), getSet, mRelational);
		int numObj = getSet.GetNumObjects();
		for (i = 0; i < numObj; i++)
			DumpObject(0, getSet.GetNURBSObject(i), mpIp->GetTime());

		getSet.DeleteObjects();
	}

	if (mFP) {
		fclose(mFP);
		mFP = NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nutil.rc
//
#define IDS_LIB_DESCRIPTION             1
#define IDS_SURF_APPROX                 2
#define IDS_API_TEST                    3
#define IDS_POINT                       4
#define IDS_POINT_CONST_POINT           5
#define IDS_CURVE_CONST_POINT           6
#define IDS_SURF_CONST_POINT            7
#define IDS_CURVE_CURVE_POINT           8
#define IDS_CV_CURVE                    9
#define IDS_POINT_CURVE                 10
#define IDS_BLEND_CURVE                 11
#define IDS_OFFSET_CURVE                12
#define IDS_XFORM_CURVE                 13
#define IDS_MIRROR_CURVE                14
#define IDS_FILLET_CURVE                15
#define IDS_CHAMFER_CURVE               16
#define IDS_U_ISO_CURVE                 17
#define IDS_V_ISO_CURVE                 18
#define IDS_CV_SURFACE                  19
#define IDS_CV                          20
#define IDS_POINT_SURFACE               21
#define IDS_BLEND_SURFACE               22
#define IDS_OFFSET_SURFACE              23
#define IDS_XFORM_SURFACE               24
#define IDS_MIRROR_SURFACE              25
#define IDS_RULED_SURFACE               26
#define IDS_ULOFT_SURFACE               27
#define IDS_EXTRUDE_SURFACE             28
#define IDS_LATHE_SURFACE               29
#define IDS_F_EDGE_CRV1                 30
#define IDS_F_EDGE_CRV2                 31
#define IDS_C_EDGE_CRV1                 32
#define IDS_C_EDGE_CRV2                 33
#define IDS_ADDED_POINT_SURF            34
#define IDS_ADDED_ISO_CURVE             35
#define IDS_J_PT_CRV1                   36
#define IDS_J_PT_CRV2                   37
#define IDS_J_PT_SRF1                   38
#define IDS_J_PT_SRF2                   39
#define IDS_BREAK_CURVE                 40
#define IDS_BREAK_SURFACE               41
#define IDS_NAME                        42
#define IDS_ID                          43
#define IDS_ISO_CURVE                   44
#define IDS_X                           45
#define IDS_Y                           46
#define IDS_Z                           47
#define IDS_NUM_TRIM_POINTS             48
#define IDS_PARAMETER                   49
#define IDS_DIRECTION_NONE              50
#define IDS_DIRECTION_POS               51
#define IDS_DIRECTION_NEG               52
#define IDS_RENDERABLE                  53
#define IDS_FLIP_NORMALS                54
#define IDS_MAT_ID                      55
#define IDS_CLOSED_U                    56
#define IDS_CLOSED_V                    57
#define IDS_UV_CHANNEL                  58
#define IDS_GENUV                       59
#define IDS_TEXUV                       60
#define IDS_U                           61
#define IDS_V                           62
#define IDS_UTILE                       63
#define IDS_VTILE                       64
#define IDS_UOFFSET                     65
#define IDS_VOFFSET                     66
#define IDS_YES                         67
#define IDS_NO                          68
#define IDS_TYPE                        69
#define IDS_ON_OBJECT                   70
#define IDS_OFFSET                      71
#define IDS_NORMAL                      72
#define IDS_UTANGENT                    73
#define IDS_VTANGENT                    74
#define IDS_UPARAM                      76
#define IDS_VPARAM                      77
#define IDS_XFORM_MAT                   78
#define IDS_POINTS                      79
#define IDS_ORDER                       80
#define IDS_KNOTS                       81
#define IDS_CVS                         82
#define IDS_PARENT_ID                   83
#define IDS_TRANSFORM                   84
#define IDS_DIRECTION                   85
#define IDS_DISTANCE                    86
#define IDS_TENSION                     87
#define IDS_EDGE                        88
#define IDS_FLIP                        89
#define IDS_LOWU                        90
#define IDS_HIGHU                       91
#define IDS_LOWV                        92
#define IDS_HIGHV                       93
#define IDS_UORDER                      94
#define IDS_VORDER                      95
#define IDS_UKNOTS                      96
#define IDS_VKNOTS                      97
#define IDS_END                         98
#define IDS_TRIM                        99
#define IDS_MIRRORX                     100
#define IDS_MIRRORY                     101
#define IDS_MIRRORZ                     102
#define IDS_MIRRORXY                    103
#define IDS_MIRRORXZ                    104
#define IDS_MIRRORYZ                    105
#define IDS_AXIS                        106
#define IDS_DEGREES                     107
#define IDS_NURBS                       108
#define IDS_SELECTED                    109
#define IDS_NOT_SELECTED                110
#define IDS_TEST_OBJECT                 111
#define IDS_PNT_TEST_OBJECT             112
#define IDS_CRV_TEST_OBJECT             113
#define IDS_SRF_TEST_OBJECT             114
#define IDS_COS_TEST_OBJECT             115
#define IDD_SURF_APPROX                 184
#define IDS_ADV_SURF_APPROX_WARNING_TITLE 322
#define IDS_ADV_SURF_APPROX_WARNING     323
#define IDS_SURF_DISPLAY                324
#define IDS_CURV_SURF_INT_POINT         325
#define IDS_PROJ_VECT_CURVE             326
#define IDS_PROJ_NORM_CURVE             327
#define IDS_SURF_SURF_CURVE             328
#define IDS_COS_CURVE                   329
#define IDS_SURF_NORM_CURVE             330
#define IDS_UVLOFT_SURFACE              331
#define IDS_NBLEND_SURFACE              332
#define IDS_1RAIL_SURFACE               333
#define IDS_2RAIL_SURFACE               334
#define IDS_MULTI_TRIM_SURFACE          335
#define IDS_CAP_SURFACE                 336
#define IDS_PARALLEL                    337
#define IDS_SCALE                       338
#define IDS_RAIL_ID                     339
#define IDS_SEED                        340
#define IDS_TRIM_SURFACE                341
#define IDS_FLIP_TRIM                   342
#define IDS_CLP                         343
#define IDS_POINT_COS_CURVE             344
#define IDS_CV_COS_CURVE                345
#define IDS_RIGID                       346
#define IDS_ANGLE                       347
#define IDS_FILLET_SURFACE              348
#define IDS_CUBIC                       349
#define IDS_RADIUS                      350
#define IDS_SURFACE_EDGE_CURVE          351
#define IDS_SNAPCS                      352
#define IDS_ROADLIKE                    353
#define IDS_TEXTURE_POINT               354
#define IDS_SURFACE_MAPPER              355
#define IDD_SURF_APPROX_ADV             413
#define IDC_RESET                       1000
#define IDC_TESS_REGULAR                1003
#define IDC_SURF_DISPLAY                1004
#define IDC_DEGRADE                     1005
#define IDC_FILE                        1006
#define IDC_FILENAME                    1007
#define IDC_RELATIONAL                  1008
#define IDC_CLEAR_SURF                  1009
#define IDC_AS_CURVE                    1010
#define IDC_CLEAR_ALL_SURFS             1011
#define IDD_NURBS_API_TEST              1069
#define IDD_SURF_DISPLAY                1070
#define IDC_TRIM                        1073
#define IDC_DISP_SURFACE                1091
#define IDC_TESS_U_SPINNER              1092
#define IDC_ISO_U_SPINNER               1093
#define IDC_DISP_CURVE                  1094
#define IDC_TESS_U                      1097
#define IDC_ISO_U                       1098
#define IDC_TESS_V_SPINNER              1102
#define IDC_ISO_V_SPINNER               1103
#define IDC_TESS_V                      1107
#define IDC_ISO_V                       1108
#define IDC_TESS_DIST_SPINNER           1112
#define IDC_MERGE_SPINNER               1113
#define IDC_TESS_DIST                   1116
#define IDC_MERGE                       1117
#define IDC_TESS_ANG_SPINNER            1120
#define IDC_TESS_ANG                    1125
#define IDC_TESS_EDGE_SPINNER           1130
#define IDC_TESS_MIN_REC_SPINNER        1131
#define IDC_TESS_MAX_REC_SPINNER        1132
#define IDC_TESS_MAX_TRIS_SPINNER       1133
#define IDC_TESS_EDGE                   1134
#define IDC_TESS_MIN_REC                1135
#define IDD_SURF_APPROX_NEW             1135
#define IDC_TESS_MAX_REC                1136
#define IDD_SURF_APPROX_PARAMS          1136
#define IDD_DISP_SURF_APPROX_PARAMS     1137
#define IDC_TESS_MAX_TRIS               1137
#define IDD_CRUVE_SURF_APPROX_PARAMS    1138
#define IDC_TESS_VIEW                   1141
#define IDC_TESS_RENDERER               1142
#define IDC_TESS_PARAM                  1143
#define IDC_TESS_SPATIAL                1144
#define IDC_TESS_CURV                   1145
#define IDC_TESS_VIEW_DEP               1146
#define IDC_TESS_LDA                    1147
#define IDC_CV_IMAGE                    1160
#define IDC_DISP_DEP                    1160
#define IDC_DISP_TRIM                   1161
#define IDC_ISO_ONLY                    1224
#define IDC_MESH_ONLY                   1225
#define IDC_ISO_AND_MESH                1226
#define IDC_RUN_TEST                    1267
#define IDC_POINT_TEST                  1268
#define IDC_SURF_APPROX                 1269
#define IDC_CURVE_TEST                  1269
#define IDC_DUMP                        1270
#define IDC_SURF_TEST                   1271
#define IDC_SURF_TRIM_TEST              1272
#define IDC_CURVE_TRIM_TEST             1273
#define IDC_COS_TEST                    1274
#define IDC_DISPLATTICE                 1286
#define IDC_GRID                        1288
#define IDC_TREE                        1289
#define IDC_ADVANCED                    1328
#define IDC_SURFACE                     1364
#define IDC_DISPLACEMENT                1365
#define IDC_LOCK                        1365
#define IDC_CURVE                       1366
#define IDC_MERGE_TXT                   1366
#define IDC_MESH                        1368
#define IDC_TESS_V_TXT                  1372
#define IDC_DELAUNAY                    1416
#define IDC_PRESET3                     1425
#define IDC_SAVE_PRESET3                1426
#define IDC_PRESET2                     1427
#define IDC_SAVE_PRESET2                1428
#define IDC_PRESET1                     1429
#define IDC_SAVE_PRESET1                1430

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\srf_aprx.cpp ===
/**********************************************************************
 *<
    FILE: srf_aprx.cpp

    DESCRIPTION:  Surf Approx Setting Utility for NURBS

    CREATED BY: Charlie Thaeler

    HISTORY: created 13 August, 1997

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"


#define MAX_F 1000.0f
#define MAX_POS	((float)1e30)


static SurfApproxUtilDesc sSurfApproxUtilDesc;

ClassDesc*
GetSurfApproxUtilDesc()
{
	return &sSurfApproxUtilDesc;
}



const TCHAR *
SurfApproxUtilDesc::ClassName()
{
	return GetString(IDS_SURF_APPROX);
}

const TCHAR *
SurfApproxUtilDesc::Category()
{
	return GetString(IDS_NURBS);
}




SurfApproxUtil::SurfApproxUtil(void)
{
	mpSurfView = NULL;
	mpSurfRend = NULL;
	mpDispRend = NULL;
	mpCurveView = NULL;
	mpCurveRend = NULL;
	mClearSurfaces = TRUE;

	ResetTess();
	ResetDisplay();
}

SurfApproxUtil::~SurfApproxUtil(void)
{
	if (mpCurveView)
		delete mpCurveView;
	mpCurveView = NULL;

	if (mpCurveRend)
		delete mpCurveRend;
	mpCurveRend = NULL;

	if (mpSurfView)
		delete mpSurfView;
	mpSurfView = NULL;

	if (mpSurfRend)
		delete mpSurfRend;
	mpSurfRend = NULL;

	if (mpDispRend)
		delete mpDispRend;
	mpDispRend = NULL;
}


void
SurfApproxUtil::SetSurfApprox()
{
	for (int i=0; i < mpIp->GetSelNodeCount(); i++) {
		// Get a selected node
		INode* node = mpIp->GetSelNode(i);
		Object* obj = node->GetObjectRef();
		SetSurfaceApprox(obj, TRUE, mpSurfView, mClearSurfaces);
		SetSurfaceApprox(obj, FALSE, mpSurfRend, mClearSurfaces);
		SetCurveApprox(obj, TRUE, mpCurveView, mClearSurfaces);
		SetCurveApprox(obj, FALSE, mpCurveRend, mClearSurfaces);
		SetDispApprox(obj, mpDispRend, mClearSurfaces);
	}
	mpIp->RedrawViews(mpIp->GetTime());
}

void
SurfApproxUtil::SetSurfDisplay()
{
	NURBSResult retval = kNOk;
	for (int i=0; i < mpIp->GetSelNodeCount(); i++) {
		// Get a selected node
		INode* node = mpIp->GetSelNode(i);
		Object* obj = node->GetObjectRef();
		retval = SetSurfaceDisplaySettings(obj, mDisplay);
	}
	mpIp->RedrawViews(mpIp->GetTime());
}

void
SurfApproxUtil::ResetTess()
{
	mClearSurfaces = TRUE;

	mSettingType = kSurfView;

	if (mpSurfRend == NULL)
		mpSurfRend = new TessApprox;
    *mpSurfRend = *GetTessPreset((int) kSurfRend, 1);

    // Default for viewport tessellation
	if (mpSurfView == NULL)
		mpSurfView = new TessApprox;
    *mpSurfView = *GetTessPreset((int) kSurfView, 1);

	if (mpDispRend)
		delete mpDispRend;
	mpDispRend = NULL;

	if (mpCurveView)
		delete mpCurveView;
	mpCurveView = NULL;

	if (mpCurveRend)
		delete mpCurveRend;
	mpCurveRend = NULL;
}


void
SurfApproxUtil::ResetDisplay()
{
	mDisplay.mDisplayCurves = TRUE;
	mDisplay.mDisplaySurfaces = TRUE;
	mDisplay.mDisplayLattices = FALSE;
	mDisplay.mDisplaySurfCVLattices = TRUE;
	mDisplay.mDisplayCurveCVLattices = TRUE;
	mDisplay.mDisplayDependents = TRUE;
	mDisplay.mDisplayTrimming = TRUE;
	mDisplay.mDegradeOnMove = TRUE;
}


static HWND hApprox = NULL;
static HWND hDisplay = NULL;
BOOL CALLBACK SurfApproxDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK SurfDisplayDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

void
SurfApproxUtil::BeginEditParams(Interface *ip,IUtil *iu)
{
	this->mpIu = iu;
	this->mpIp = (IObjParam*)ip;
	hApprox = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SURF_APPROX),
		SurfApproxDlgProc,
		GetString(IDS_SURF_APPROX),
		(LPARAM)this);
	hDisplay = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SURF_DISPLAY),
		SurfDisplayDlgProc,
		GetString(IDS_SURF_DISPLAY),
		(LPARAM)this);
}


void
SurfApproxUtil::EndEditParams(Interface *ip,IUtil *iu)
{
	this->mpIu = NULL;
	this->mpIp = NULL;
	ip->DeleteRollupPage(hApprox);
	hApprox = NULL;
	ip->DeleteRollupPage(hDisplay);
	hDisplay = NULL;
}





// Display toggles
void
SurfApproxUtil::SetupDisplayUI(HWND hDlg)
{
	CheckDlgButton( hDlg, IDC_DISPLATTICE, mDisplay.mDisplayLattices);
	CheckDlgButton( hDlg, IDC_DISP_CURVE, mDisplay.mDisplayCurves);
	CheckDlgButton( hDlg, IDC_DISP_SURFACE, mDisplay.mDisplaySurfaces);
	CheckDlgButton( hDlg, IDC_DISP_DEP, mDisplay.mDisplayDependents);
	CheckDlgButton( hDlg, IDC_DISP_TRIM, mDisplay.mDisplayTrimming);
	CheckDlgButton( hDlg, IDC_DEGRADE, mDisplay.mDegradeOnMove);
}

static BOOL CALLBACK
SurfDisplayDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	SurfApproxUtil *pUtil = (SurfApproxUtil*) GetWindowLong(hWnd, GWL_USERDATA);
    switch (msg) {
    case WM_INITDIALOG: {
        pUtil = (SurfApproxUtil*) lParam;
        SetWindowLong(hWnd, GWL_USERDATA, lParam);
		pUtil->SetupDisplayUI(hWnd);
		break; }

    case WM_COMMAND:
		switch ( LOWORD(wParam) ) {
		case IDC_SURF_DISPLAY:
			pUtil->SetSurfDisplay();
			break;
		case IDC_RESET:
			pUtil->ResetDisplay();
			pUtil->SetupDisplayUI(hWnd);
			break;
		case IDC_DISPLATTICE:
			pUtil->mDisplay.mDisplayLattices = IsDlgButtonChecked(hWnd, IDC_DISPLATTICE);
			break;
		case IDC_DISP_CURVE:
			pUtil->mDisplay.mDisplayCurves = IsDlgButtonChecked(hWnd, IDC_DISP_CURVE);
			break;
		case IDC_DISP_SURFACE:
			pUtil->mDisplay.mDisplaySurfaces = IsDlgButtonChecked(hWnd, IDC_DISP_SURFACE);
			break;
		case IDC_DISP_DEP:
			pUtil->mDisplay.mDisplayDependents = IsDlgButtonChecked(hWnd, IDC_DISP_DEP);
			break;
		case IDC_DISP_TRIM:
			pUtil->mDisplay.mDisplayTrimming = IsDlgButtonChecked(hWnd, IDC_DISP_TRIM);
			break;
		case IDC_DEGRADE:
			pUtil->mDisplay.mDegradeOnMove = IsDlgButtonChecked(hWnd, IDC_DEGRADE);
			break;
		}
		break;
	}
    return FALSE;
}







// Approximation
class AdvParams {
public:
	TessSubdivStyle mStyle;
	int mMin, mMax;
	int mTris;
};

static AdvParams sParams;



static ISpinnerControl* psMergeSpin = NULL;
static ISpinnerControl* psUSpin = NULL;
static ISpinnerControl* psVSpin = NULL;
static ISpinnerControl* psEdgeSpin = NULL;
static ISpinnerControl* psDistSpin = NULL;
static ISpinnerControl* psAngSpin = NULL;
static ISpinnerControl* psIsoUSpin = NULL;
static ISpinnerControl* psIsoVSpin = NULL;


BOOL CALLBACK ApproxParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
BOOL CALLBACK AdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );



static void
SetupUI(HWND hDlg, SurfApproxUtil *pUtil)
{
	// clear out the settings of the radio groups so they
	// will work properly
	CheckDlgButton( hDlg, IDC_ISO_ONLY, FALSE);
	CheckDlgButton( hDlg, IDC_ISO_AND_MESH, FALSE);
	CheckDlgButton( hDlg, IDC_MESH_ONLY, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_VIEW, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_RENDERER, FALSE);

	// turn on the isoline controls
	if (pUtil->mpSurfView->vpt_cfg == MESH_ONLY) {
		psIsoUSpin->Disable();
		psIsoVSpin->Disable();
	} else {
		psIsoUSpin->Enable();
		psIsoVSpin->Enable();
		psIsoUSpin->SetValue(pUtil->mpSurfView->u_iso, FALSE);
		psIsoVSpin->SetValue(pUtil->mpSurfView->v_iso, FALSE);
	}

	switch (pUtil->mpSurfView->vpt_cfg) {
	case ISO_ONLY:
		CheckDlgButton( hDlg, IDC_ISO_ONLY, TRUE);
		break;
	case ISO_AND_MESH:
		CheckDlgButton( hDlg, IDC_ISO_AND_MESH, TRUE);
		break;
	case MESH_ONLY:
		CheckDlgButton( hDlg, IDC_MESH_ONLY, TRUE);
		break;
	}


	// start off showing everything
	EnableWindow(GetDlgItem(hDlg, IDC_DISPLACEMENT), TRUE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), TRUE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), TRUE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), TRUE);
	EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_TXT), TRUE);
    psMergeSpin->Enable(TRUE);
	EnableWindow(GetDlgItem(hDlg, IDC_MERGE_TXT), TRUE);

	// clear out the settings of the radio groups so they
	// will work properly
	CheckDlgButton( hDlg, IDC_TESS_VIEW, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_RENDERER, FALSE);
	CheckDlgButton( hDlg, IDC_MESH, FALSE);
	CheckDlgButton( hDlg, IDC_TRIM, FALSE);
	CheckDlgButton( hDlg, IDC_DISPLACEMENT, FALSE);

	CheckDlgButton( hDlg, IDC_TESS_REGULAR, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_PARAM, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_SPATIAL, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_CURV, FALSE);
	CheckDlgButton( hDlg, IDC_TESS_LDA, FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET1), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET2), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET3), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRESET1), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRESET2), TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRESET3), TRUE);

	switch (pUtil->mSettingType) {
	case kSurfView:
		EnableWindow(GetDlgItem(hDlg, IDC_DISPLACEMENT), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), FALSE);

		CheckDlgButton( hDlg, IDC_TESS_VIEW, TRUE);
		CheckDlgButton( hDlg, IDC_MESH, TRUE);
		break;

	case kSurfRend:
		CheckDlgButton( hDlg, IDC_TESS_RENDERER, TRUE);
		CheckDlgButton( hDlg, IDC_MESH, TRUE);
		break;

	case kSurfDisp:
        psMergeSpin->Enable(FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_MERGE_TXT), FALSE);

		CheckDlgButton( hDlg, IDC_TESS_RENDERER, TRUE);
		CheckDlgButton( hDlg, IDC_DISPLACEMENT, TRUE);
		break;

	case kCurveView:
		EnableWindow(GetDlgItem(hDlg, IDC_DISPLACEMENT), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_VIEW_DEP), FALSE);

		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_TXT), FALSE);

        psMergeSpin->Enable(FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_MERGE_TXT), FALSE);

		CheckDlgButton( hDlg, IDC_TESS_VIEW, TRUE);
		CheckDlgButton( hDlg, IDC_TRIM, TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET1), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET3), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET1), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET3), FALSE);
		break;

	case kCurveRend:
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_SPINNER), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_TESS_V_TXT), FALSE);

        psMergeSpin->Enable(FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_MERGE_TXT), FALSE);

		CheckDlgButton( hDlg, IDC_TESS_RENDERER, TRUE);
		CheckDlgButton( hDlg, IDC_TRIM, TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET1), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_SAVE_PRESET3), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET1), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET2), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRESET3), FALSE);
		break;
	}


	TessApprox *pTess = pUtil->GetTess(pUtil->mSettingType);

	TessApprox tess;
	tess.type = TESS_CURVE;

	if (pTess)
		tess = *pTess;
	// start by enabling and setting the values of all the spinners
	psUSpin->Enable();
	psVSpin->Enable();
	psEdgeSpin->Enable();
	psDistSpin->Enable();
	psAngSpin->Enable();

	psVSpin->SetValue(tess.v, FALSE);
	psUSpin->SetValue(tess.u, FALSE);
	psEdgeSpin->SetValue(tess.edge, FALSE);
	psDistSpin->SetValue(tess.dist, FALSE);
	psAngSpin->SetValue(tess.ang, FALSE);


	switch (tess.type) {
	case TESS_SET:
	case TESS_ISO:
		assert(0);
		break;

	case TESS_REGULAR:
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();

		CheckDlgButton( hDlg, IDC_TESS_REGULAR, TRUE);
		break;

	case TESS_PARAM:
		psEdgeSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();

		CheckDlgButton( hDlg, IDC_TESS_PARAM, TRUE);
		break;

	case TESS_SPATIAL:
		psUSpin->Disable();
		psVSpin->Disable();
		psDistSpin->Disable();
		psAngSpin->Disable();

		CheckDlgButton( hDlg, IDC_TESS_SPATIAL, TRUE);
		break;

	case TESS_CURVE:
		psUSpin->Disable();
		psVSpin->Disable();
		psEdgeSpin->Disable();

		CheckDlgButton( hDlg, IDC_TESS_CURV, TRUE);
		break;

	case TESS_LDA:
		psUSpin->Disable();
		psVSpin->Disable();

		CheckDlgButton( hDlg, IDC_TESS_LDA, TRUE);
		break;
	}

	CheckDlgButton( hDlg, IDC_TESS_VIEW_DEP, tess.view);

}

TessApprox*
SurfApproxUtil::GetPreset(int preset)
{
    return GetTessPreset((int) mSettingType, preset);
}


void
SurfApproxUtil::SetPreset(int preset, TessApprox& tess)
{
    SetTessPreset((int) mSettingType, preset, tess);
}



BOOL CALLBACK
SurfApproxDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	SurfApproxUtil *pUtil = (SurfApproxUtil*) GetWindowLong(hWnd, GWL_USERDATA);

	TessApprox tess, *pTess;
	tess.type = TESS_CURVE;
	if (pUtil) {
		TessApprox *pTess = pUtil->GetTess(pUtil->mSettingType);
		if (pTess)
			tess = *pTess;
	}

    switch (msg) {
    case WM_INITDIALOG: {
        pUtil = (SurfApproxUtil*) lParam;
        SetWindowLong(hWnd, GWL_USERDATA, lParam);
		TessApprox vTess;
		vTess = *pUtil->mpSurfView;
		psIsoUSpin = SetupIntSpinner( hWnd, IDC_ISO_U_SPINNER, IDC_ISO_U, 0, 100, vTess.u_iso);
		psIsoVSpin = SetupIntSpinner( hWnd, IDC_ISO_V_SPINNER, IDC_ISO_V, 0, 100, vTess.v_iso);
		CheckDlgButton( hWnd, IDC_CLEAR_SURF, pUtil->mClearSurfaces);

		// the values will be reset by SetupUI()
		psUSpin = SetupIntSpinner( hWnd, IDC_TESS_U_SPINNER, IDC_TESS_U, 1, 100, vTess.u);
		psVSpin = SetupIntSpinner( hWnd, IDC_TESS_V_SPINNER, IDC_TESS_V, 1, 100, vTess.v);

		psEdgeSpin = SetupFloatSpinner( hWnd, IDC_TESS_EDGE_SPINNER, IDC_TESS_EDGE, 0.0f, MAX_F, vTess.edge);
		psDistSpin = SetupFloatSpinner( hWnd, IDC_TESS_DIST_SPINNER, IDC_TESS_DIST, 0.0f, MAX_F, vTess.dist);
		psAngSpin =  SetupFloatSpinner( hWnd, IDC_TESS_ANG_SPINNER,  IDC_TESS_ANG, 0.0f, 180.0f, vTess.ang);
		psMergeSpin = SetupFloatSpinner( hWnd, IDC_MERGE_SPINNER, IDC_MERGE, 0.0f, MAX_POS, vTess.merge);
		// since angle is more confined (0->180) don't autoscale it.
		psEdgeSpin->SetAutoScale(TRUE);
		psDistSpin->SetAutoScale(TRUE);
		psMergeSpin->SetAutoScale(TRUE);
		SetupUI(hWnd, pUtil);
        break; }


    case WM_DESTROY:
		if( psIsoUSpin ) {
			ReleaseISpinner(psIsoUSpin);
			psIsoUSpin = NULL;
		}
		if( psIsoVSpin ) {
			ReleaseISpinner(psIsoVSpin);
			psIsoVSpin = NULL;
		}
		if( psMergeSpin ) {
			ReleaseISpinner(psMergeSpin);
			psMergeSpin = NULL;
		}
		if( psUSpin ) {
			ReleaseISpinner(psUSpin);
			psUSpin = NULL;
		}
		if( psVSpin ) {
			ReleaseISpinner(psVSpin);
			psVSpin = NULL;
		}
		if( psEdgeSpin ) {
			ReleaseISpinner(psEdgeSpin);
			psEdgeSpin = NULL;
		}
		if( psDistSpin ) {
			ReleaseISpinner(psDistSpin);
			psDistSpin = NULL;
		}
		if( psAngSpin ) {
			ReleaseISpinner(psAngSpin);
			psAngSpin = NULL;
		}
        break;



    case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_ISO_U_SPINNER:
			pUtil->mpSurfView->u_iso = psIsoUSpin->GetIVal();
			SetupUI(hWnd, pUtil);
			break;
		case IDC_ISO_V_SPINNER:
			pUtil->mpSurfView->v_iso = psIsoVSpin->GetIVal();
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_U_SPINNER:
			tess.u = psUSpin->GetIVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		case IDC_TESS_V_SPINNER:
			tess.v = psVSpin->GetIVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		case IDC_TESS_EDGE_SPINNER:
			tess.edge = psEdgeSpin->GetFVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		case IDC_TESS_DIST_SPINNER:
			tess.dist = psDistSpin->GetFVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		case IDC_TESS_ANG_SPINNER:
			tess.ang = psAngSpin->GetFVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		case IDC_MERGE_SPINNER:
			tess.merge = psMergeSpin->GetFVal();
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;
		}
        break;


    case WM_COMMAND:
		switch ( LOWORD(wParam) ) {
		case IDC_SURF_APPROX:
			pUtil->SetSurfApprox();
			break;
		case IDC_RESET:
			pUtil->ResetTess();
			SetupUI(hWnd, pUtil);
			break;

		case IDC_CLEAR_SURF:
			pUtil->mClearSurfaces = IsDlgButtonChecked(hWnd, IDC_CLEAR_SURF);
			break;

		case IDC_ISO_ONLY:
			pUtil->mpSurfView->vpt_cfg = ISO_ONLY;
			SetupUI(hWnd, pUtil);
			break;

		case IDC_ISO_AND_MESH:
			pUtil->mpSurfView->vpt_cfg = ISO_AND_MESH;
			SetupUI(hWnd, pUtil);
			break;

		case IDC_MESH_ONLY:
			pUtil->mpSurfView->vpt_cfg = MESH_ONLY;
			SetupUI(hWnd, pUtil);
			break;


		case IDC_TESS_VIEW:
			if (IsDlgButtonChecked(hWnd, IDC_MESH))
				pUtil->mSettingType = kSurfView;
			else
				pUtil->mSettingType = kCurveView;
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_RENDERER:
			if (IsDlgButtonChecked(hWnd, IDC_MESH)) {
				pUtil->mSettingType = kSurfRend;
			} else if (IsDlgButtonChecked(hWnd, IDC_TRIM)) {
				pUtil->mSettingType = kCurveRend;
			} else {
				pUtil->mSettingType = kSurfDisp;
			}
			SetupUI(hWnd, pUtil);
			break;
		case IDC_MESH:
			if (IsDlgButtonChecked(hWnd, IDC_TESS_VIEW))
				pUtil->mSettingType = kSurfView;
			else
				pUtil->mSettingType = kSurfRend;
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TRIM:
			if (IsDlgButtonChecked(hWnd, IDC_TESS_VIEW))
				pUtil->mSettingType = kCurveView;
			else
				pUtil->mSettingType = kCurveRend;
			SetupUI(hWnd, pUtil);
			break;
		case IDC_DISPLACEMENT:
			pUtil->mSettingType = kSurfDisp;
			SetupUI(hWnd, pUtil);
			break;

		case IDC_TESS_REGULAR:
			tess.type = TESS_REGULAR;
			pUtil->SetTess(tess, pUtil->mSettingType);
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_PARAM:
			tess.type = TESS_PARAM;
			pUtil->SetTess(tess, pUtil->mSettingType);
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_SPATIAL:
			tess.type = TESS_SPATIAL;
			pUtil->SetTess(tess, pUtil->mSettingType);
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_CURV:
			tess.type = TESS_CURVE;
			pUtil->SetTess(tess, pUtil->mSettingType);
			SetupUI(hWnd, pUtil);
			break;
		case IDC_TESS_LDA:
			tess.type = TESS_LDA;
			pUtil->SetTess(tess, pUtil->mSettingType);
			SetupUI(hWnd, pUtil);
			break;

		case IDC_TESS_VIEW_DEP:
			tess.view = IsDlgButtonChecked(hWnd, IDC_TESS_VIEW_DEP);
			pUtil->SetTess(tess, pUtil->mSettingType);
			break;

        case IDC_PRESET1:
            pTess = pUtil->GetPreset(0);
            if (pTess) {
                tess = *pTess;
                pUtil->SetTess(tess, pUtil->mSettingType);
                SetupUI(hWnd, pUtil);
            }
            break;

        case IDC_PRESET2:
            pTess = pUtil->GetPreset(1);
            if (pTess) {
                tess = *pTess;
                pUtil->SetTess(tess, pUtil->mSettingType);
                SetupUI(hWnd, pUtil);
            }
            break;

        case IDC_PRESET3:
            pTess = pUtil->GetPreset(2);
            if (pTess) {
                tess = *pTess;
                pUtil->SetTess(tess, pUtil->mSettingType);
                SetupUI(hWnd, pUtil);
            }
            break;

        case IDC_SAVE_PRESET1:
			pUtil->SetPreset(0, tess);
            break;

        case IDC_SAVE_PRESET2:
			pUtil->SetPreset(1, tess);
            break;

        case IDC_SAVE_PRESET3:
			pUtil->SetPreset(2, tess);
            break;

		case IDC_ADVANCED: {
			sParams.mStyle = tess.subdiv;
			sParams.mMin = tess.minSub;
			sParams.mMax = tess.maxSub;
			sParams.mTris = tess.maxTris;
			int retval = DialogBox( hInstance,
						MAKEINTRESOURCE(IDD_SURF_APPROX_ADV),
						hWnd, AdvParametersDialogProc);
			if (retval == 1) {
				BOOL confirm = FALSE;
				if ((sParams.mStyle == SUBDIV_DELAUNAY && sParams.mTris > 200000) ||
					(sParams.mStyle != SUBDIV_DELAUNAY && sParams.mMax > 5)) {
					// warning!
					TSTR title = GetString(IDS_ADV_SURF_APPROX_WARNING_TITLE),
						warning = GetString(IDS_ADV_SURF_APPROX_WARNING);
					if (MessageBox(hWnd, warning, title,
						MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 ) == IDYES)
						confirm = TRUE;
 
				} else
					confirm = TRUE;
				if (confirm) {
					tess.subdiv = sParams.mStyle;
					tess.minSub = sParams.mMin;
					tess.maxSub = sParams.mMax;
					tess.maxTris = sParams.mTris;
					pUtil->SetTess(tess, pUtil->mSettingType);
				}
			}
			break; }
		}
        break;
    }
    return FALSE;
}








static ISpinnerControl* psMinSpin = NULL;
static ISpinnerControl* psMaxSpin = NULL;
static ISpinnerControl* psMaxTrisSpin = NULL;
// this max matches the MI max.
#define MAX_SUBDIV 7


static BOOL initing = FALSE; // this is a hack but CenterWindow causes bad commands

BOOL CALLBACK
AdvParametersDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg) {
    case WM_INITDIALOG: {
		initing = TRUE;
        CenterWindow(hDlg, GetCOREInterface()->GetMAXHWnd());
		initing = FALSE;
		psMinSpin = SetupIntSpinner( hDlg, IDC_TESS_MIN_REC_SPINNER, IDC_TESS_MIN_REC, 0, sParams.mMax, sParams.mMin);
		psMaxSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_REC_SPINNER, IDC_TESS_MAX_REC, sParams.mMin, MAX_SUBDIV, sParams.mMax);
		psMaxTrisSpin = SetupIntSpinner( hDlg, IDC_TESS_MAX_TRIS_SPINNER, IDC_TESS_MAX_TRIS, 0, 2000000, sParams.mTris);
		switch (sParams.mStyle) {
		case SUBDIV_GRID:
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case SUBDIV_TREE:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case SUBDIV_DELAUNAY:
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			break;
		}
		break; }

    case WM_COMMAND:
		if (initing) return FALSE;
		switch ( LOWORD(wParam) ) {
		case IDOK:
			EndDialog(hDlg, 1);
			break;
		case IDCANCEL:
			EndDialog(hDlg, 0);
			break;
		case IDC_GRID:
			sParams.mStyle = SUBDIV_GRID;
			CheckDlgButton( hDlg, IDC_GRID, TRUE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case IDC_TREE:
			sParams.mStyle = SUBDIV_TREE;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, TRUE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, FALSE);
			break;
		case IDC_DELAUNAY:
			sParams.mStyle = SUBDIV_DELAUNAY;
			CheckDlgButton( hDlg, IDC_GRID, FALSE);
			CheckDlgButton( hDlg, IDC_TREE, FALSE);
			CheckDlgButton( hDlg, IDC_DELAUNAY, TRUE);
			break;
		}
		break;

    case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_TESS_MIN_REC_SPINNER:
			sParams.mMin = psMinSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_REC_SPINNER:
			sParams.mMax = psMaxSpin->GetIVal();
			psMinSpin->SetLimits(0, sParams.mMax, FALSE);
			psMaxSpin->SetLimits(sParams.mMin, MAX_SUBDIV, FALSE);
			break;
		case IDC_TESS_MAX_TRIS_SPINNER:
			sParams.mTris = psMaxTrisSpin->GetIVal();
			break;
		}
		break;

	case WM_DESTROY:
		if( psMinSpin ) {
			ReleaseISpinner(psMinSpin);
			psMinSpin = NULL;
		}
		if( psMaxSpin ) {
			ReleaseISpinner(psMaxSpin);
			psMaxSpin = NULL;
		}
		if( psMaxTrisSpin ) {
			ReleaseISpinner(psMaxTrisSpin);
			psMaxTrisSpin = NULL;
		}
		break;
	}

	return FALSE;
}





TessApprox *
SurfApproxUtil::GetTess(SurfApproxType type)
{
	switch(type) {
	case kCurveRend:
		if (mpCurveRend)
			return mpCurveRend;
		break;
	case kCurveView:
		if (mpCurveView)
			return mpCurveView;
		break;

	case kSurfView:
		if (mpSurfView)
			return mpSurfView;
		break;
	case kSurfDisp:
		if (mpDispRend)
			return mpDispRend;
		break;
	case kSurfRend:
		if (mpSurfRend)
			return mpSurfRend;
		break;
	default:
		assert(0);
	}

	return NULL;
}


void
SurfApproxUtil::SetTess(TessApprox &tess, SurfApproxType type)
{
	switch(type) {
	case kCurveView:
		if (mpCurveView == NULL) {
			mpCurveView = new TessApprox();
			mpCurveView->type = TESS_CURVE;
		}
		*mpCurveView = tess;
		break;
	case kCurveRend:
		if (mpCurveRend == NULL) {
			mpCurveRend = new TessApprox();
			mpCurveRend->type = TESS_CURVE;
		}
		*mpCurveRend = tess;
		break;
	case kSurfView:
		if (mpSurfView == NULL) {
			mpSurfView = new TessApprox();
			mpSurfView->type = TESS_CURVE;
		}
		*mpSurfView = tess;
		break;
	case kSurfRend:
		if (mpSurfRend == NULL) {
			mpSurfRend = new TessApprox();
			mpSurfRend->type = TESS_CURVE;
		}
		*mpSurfRend = tess;
		break;
	case kSurfDisp:
		if (mpDispRend == NULL) {
			mpDispRend = new TessApprox();
			mpDispRend->type = TESS_CURVE;
		}
		*mpDispRend = tess;
		break;
	default:
		assert(0);
	}
}


void
SurfApproxUtil::ClearTess(SurfApproxType type)
{
	switch(type) {
	case kCurveView:
		if (mpCurveView) {
			delete mpCurveView;
			mpCurveView = NULL;
		}
		break;
	case kCurveRend:
		if (mpCurveRend) {
			delete mpCurveRend;
			mpCurveRend = NULL;
		}
		break;

	case kSurfView:
		if (mpSurfView) {
			// don't really clear this one just reset it.
			mpSurfView->u       = 2;
			mpSurfView->v       = 2;
			mpSurfView->u_iso   = 2;
			mpSurfView->v_iso   = 3;
			mpSurfView->view    = FALSE;
			mpSurfView->ang     = 20.0f;
			mpSurfView->dist    = 10.0f;
			mpSurfView->edge    = 10.0f;
			mpSurfView->type    = TESS_CURVE;
			mpSurfView->merge   = 0.0f;
			mpSurfView->minSub  = 0;
			mpSurfView->maxSub  = 5;
			mpSurfView->subdiv = SUBDIV_TREE;
			mpSurfView->merge = 0.0f;
		}
		break;
	case kSurfRend:
		if (mpSurfRend) {
			delete mpSurfRend;
			mpSurfRend = NULL;
		}
		break;
	case kSurfDisp:
		if (mpDispRend) {
			delete mpDispRend;
			mpDispRend = NULL;
		}
		break;
	default:
		assert(0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\PropertyTest\PropertyTest.cpp ===
/**********************************************************************
 *<
	FILE:			PropertyTest.cpp

	DESCRIPTION:	PropertySet Test Utility

	CREATED BY:		Christer Janson

	HISTORY:		Created Tuesday, September 22, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

/**********************************************************************

This Utility demonstrates how to access the property sets stored in 
the MAX Scene. There are three property sets, the SummaryInformation,
the DocumentSummaryInformation and the UserDefinedProperties.
SummaryInformation and DocumentSummaryInformation are standard property
sets with a fixed set of properties, and the UserDefinedProperty set
contains (surprise) user defined properties.
One benefit with these property sets is that anyone outside of MAX
can parse them as they are stored in the MAX file in a standard way.

This Utility, however, demonstrates the property API inside of MAX and
will only work on the currently loaded scene.

Summary Information
===================
These are the relevant entries in the SummaryInformation
property set:

Property Name	PropertyID Str.	Prop. ID	VT Type
==============	===============	==========	======================
Title			PID_TITLE		0x00000002	VT_LPSTR 
Subject			PID_SUBJECT		0x00000003	VT_LPSTR
Author			PID_AUTHOR		0x00000004	VT_LPSTR
Keywords		PID_KEYWORDS	0x00000005	VT_LPSTR
Comments		PID_COMMENTS	0x00000006	VT_LPSTR
Thumbnail		PID_THUMBNAIL	0x00000011	VT_CF		*)

*) The thumbnail is generated on save and then thrown away.
It is part of the property set in the MAX file, but it is not
in the scene while MAX is running.

Document Summary Information
============================
These are the relevant entries in the DocumentSummaryInformation
property set:

Property Name	PropertyID Str.	Prop. ID	VT Type
==============	===============	==========	======================
Category		PID_CATEGORY	0x00000002	VT_LPSTR
HeadingPairs	PID_HEADINGPAIR	0x0000000C	VT_VARIANT | VT_VECTOR
TitlesofParts	PID_DOCPARTS	0x0000000D	VT_LPSTR | VT_VECTOR
Manager			PID_MANAGER		0x0000000E	VT_LPSTR
Company			PID_COMPANY		0x0000000F	VT_LPSTR

User Defined Properties
=======================
These are all custom properties.
The internal structure supports any property type, but the
user interface in the MAX property editor supports only
Text, Number, BOOL and Date.
You can use this API to manage other types in the user defined
property set.

***********************************************************************/

#include "PropertyTest.h"

HINSTANCE hInstance;

#define PROPERTYTEST_CLASS_ID	Class_ID(0xb3f3a6cc,0x9a708091)

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			hInstance = hinstDLL;
			InitCustomControls(hInstance);
			InitCommonControls();
			break;
		case DLL_PROCESS_DETACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
	}

	return (TRUE);
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESC);
}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetPropertyTestDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

static PropertyTest thePropertyTest;

class PropertyTestClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &thePropertyTest;}
	const TCHAR *	ClassName() {return GetString(IDS_CLASSNAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return PROPERTYTEST_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static PropertyTestClassDesc PropertyTestDesc;
ClassDesc* GetPropertyTestDesc() {return &PropertyTestDesc;}


static BOOL CALLBACK PropertyTestDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			thePropertyTest.Init(hWnd);
			break;

		case WM_DESTROY:
			thePropertyTest.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSEBUTTON:
					thePropertyTest.iu->CloseUtility();
					break;
				case IDC_SHOWPROP:
					thePropertyTest.ShowProperties();
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			thePropertyTest.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}
	return TRUE;
}	

PropertyTest::PropertyTest()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

PropertyTest::~PropertyTest()
{
}

void PropertyTest::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_PANEL),
		PropertyTestDlgProc,
		GetString(IDS_PARAMETERS),
		0);
}
	
void PropertyTest::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void PropertyTest::Init(HWND hWnd)
{
}

void PropertyTest::Destroy(HWND hWnd)
{
}

BOOL CALLBACK staticPropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);
void VariantToString(PROPVARIANT* pProp, char* szString, int bufSize);
void TypeNameFromVariant(PROPVARIANT* pProp, char* szString, int bufSize);

void PropertyTest::ShowProperties()
{
	DialogBox(hInstance,
			  MAKEINTRESOURCE(IDD_PROPERTYDIALOG),
			  ip->GetMAXHWnd(),
			  (DLGPROC)staticPropDlgProc);
	}

BOOL CALLBACK staticPropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{
	return thePropertyTest.PropDlgProc(hWnd,message,wParam,lParam);
	}


BOOL PropertyTest::PropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam)
	{

	switch (message) {
		case WM_INITDIALOG:
			{
			SetCursor(LoadCursor(NULL,IDC_ARROW));
			CenterWindow(hWnd, GetParent(hWnd));

			// Arrange the columns in the list view
			LV_COLUMN column;
			column.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
			column.fmt = LVCFMT_LEFT;
			column.pszText = GetString(IDS_NAME);
			column.cx = 80;
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 0, &column);
			column.pszText = GetString(IDS_VALUE);
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 1, &column);
			column.pszText = GetString(IDS_TYPE);
			ListView_InsertColumn(GetDlgItem(hWnd, IDC_CUSTOM), 2, &column);

			GetProperties(hWnd);
			}
			return 1;
		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
				case IDCANCEL:
					EndDialog(hWnd, 0);
					break;
				}
			return 1;
		}
	return 0;
	}
	
void PropertyTest::GetProperties(HWND hDlg)
	{
	HWND hContents = GetDlgItem(hDlg, IDC_CONTENTS);
	HWND hCustom = GetDlgItem(hDlg, IDC_CUSTOM);

	PROPSPEC	PropSpec;
	int			idx;

	PropSpec.ulKind = PRSPEC_PROPID;

	/////////////////////////////////////////////////////////////////////////
	//
	// The General Page
	//
	//
	PropSpec.propid = PIDSI_TITLE;
	idx = ip->FindProperty(PROPSET_SUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_SUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_TITLE), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PIDSI_SUBJECT;
	idx = ip->FindProperty(PROPSET_SUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_SUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_SUBJECT), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PIDSI_AUTHOR;
	idx = ip->FindProperty(PROPSET_SUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_SUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_AUTHOR), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PID_MANAGER;
	idx = ip->FindProperty(PROPSET_DOCSUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_DOCSUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_MANAGER), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PID_COMPANY;
	idx = ip->FindProperty(PROPSET_DOCSUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_DOCSUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_COMPANY), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PID_CATEGORY;
	idx = ip->FindProperty(PROPSET_DOCSUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_DOCSUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_CATEGORY), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	PropSpec.propid = PIDSI_KEYWORDS;
	idx = ip->FindProperty(PROPSET_SUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_SUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_KEYWORDS), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}


	PropSpec.propid = PIDSI_COMMENTS;
	idx = ip->FindProperty(PROPSET_SUMMARYINFO, &PropSpec);
	if (idx != -1) {
		const PROPVARIANT* prop = ip->GetPropertyVariant(PROPSET_SUMMARYINFO, idx);
		if (prop && prop->vt == VT_LPSTR) {
			SendMessage(GetDlgItem(hDlg, IDC_COMMENTS), WM_SETTEXT, 0, (LPARAM)prop->pszVal);
			}
		}

	/////////////////////////////////////////////////////////////////////////
	//
	// The Contents Page
	//
	//

	const PROPVARIANT*	pPropHeading;
	const PROPVARIANT*	pPropDocPart;

	PropSpec.propid = PID_HEADINGPAIR;

	// First, get the PID_HEADINGPAIR property.
	// This property contains an array of the headings (titles) of the contents list.
	// For each heading, there is also a number, representing the number of docparts
	// for that heading. The docparts is an array of strings.
	if ((idx = ip->FindProperty(PROPSET_DOCSUMMARYINFO, &PropSpec)) != -1) {
		if ((pPropHeading = ip->GetPropertyVariant(PROPSET_DOCSUMMARYINFO, idx)) != NULL) {

			// Get the docparts.
			PropSpec.propid = PID_DOCPARTS;
			if ((idx = ip->FindProperty(PROPSET_DOCSUMMARYINFO, &PropSpec)) != -1) {
				if ((pPropDocPart = ip->GetPropertyVariant(PROPSET_DOCSUMMARYINFO, idx)) != NULL) {

					const CAPROPVARIANT*	pHeading = &pPropHeading->capropvar;
					const CALPSTR*	pDocPart = &pPropDocPart->calpstr;
					int nDocPart = 0;
					for (UINT i=0; i<pHeading->cElems; i+=2) {

						// For each heading:
						// Add the heading...

						SendMessage(hContents, LB_ADDSTRING, 0, (LPARAM)pHeading->pElems[i].pszVal);
						for (int j=0; j<pHeading->pElems[i+1].lVal; j++) {

							// ...and then all the docparts for this heading
							// The docparts are tab indented to make it look better.
							CStr tBuf;
							tBuf.printf("\t%s", pDocPart->pElems[nDocPart]);
							SendMessage(hContents, LB_ADDSTRING, 0, (LPARAM)(char*)tBuf);
							nDocPart++;
							}
						}
					}
				}
			}
		}

	/////////////////////////////////////////////////////////////////////////
	//
	// The Custom Page
	//
	//

	TCHAR	szBuf[80];
	int		bufSize = 80;
	int		numProps;

	ListView_DeleteAllItems(hCustom);

	numProps = ip->GetNumProperties(PROPSET_USERDEFINED);

	for (int i=0; i<numProps; i++) {
		const PROPSPEC* pPropSpec = ip->GetPropertySpec(PROPSET_USERDEFINED, i);
		const PROPVARIANT* pPropVar = ip->GetPropertyVariant(PROPSET_USERDEFINED, i);

		if (pPropSpec->ulKind == PRSPEC_PROPID) {
			_stprintf(szBuf, "%ld", pPropSpec->propid);
			}
		else {
			_tcscpy(szBuf, TSTR(pPropSpec->lpwstr));
			}

		LV_ITEM item;
		item.mask = LVIF_TEXT;
		item.iItem = i;
		item.iSubItem = 0;
		item.pszText = szBuf;
		item.cchTextMax = _tcslen(szBuf);
		ListView_InsertItem(hCustom, &item);

		VariantToString(pPropVar, szBuf, 80);
		item.iSubItem = 1;
		item.pszText = szBuf;
		item.cchTextMax = _tcslen(szBuf);
		ListView_SetItem(hCustom, &item);

		TypeNameFromVariant(pPropVar, szBuf, 80);
		item.iSubItem = 2;
		item.pszText = szBuf;
		item.cchTextMax = _tcslen(szBuf);
		ListView_SetItem(hCustom, &item);
		}
	}

// Get the type of a PROPVARIANT into readable format
//

void PropertyTest::TypeNameFromVariant(const PROPVARIANT* pProp, TCHAR* szString, int bufSize)
	{
	switch (pProp->vt) {
		case VT_LPWSTR:
		case VT_LPSTR:
			_tcscpy(szString, GetString(IDS_PROPTEXT));
			break;
		case VT_I4:
		case VT_R4:
		case VT_R8:
			_tcscpy(szString, GetString(IDS_PROPNUMBER));
			break;
		case VT_BOOL:
			_tcscpy(szString, GetString(IDS_PROPYESNO));
			break;
		case VT_FILETIME:
			_tcscpy(szString, GetString(IDS_PROPDATE));
			break;
		default:
			_tcscpy(szString, "");
			break;
		}
	}

// Convert (well, copy) a PROPVARIANT into a string
//
void PropertyTest::VariantToString(const PROPVARIANT* pProp, TCHAR* szString, int bufSize)
	{
	switch (pProp->vt) {
		case VT_LPWSTR:
			_tcscpy(szString, TSTR(pProp->pwszVal));
			break;
		case VT_LPSTR:
			_tcscpy(szString, TSTR(pProp->pszVal));
			break;
		case VT_I4:
			_stprintf(szString, "%ld", pProp->lVal);
			break;
		case VT_R4:
			_stprintf(szString, "%f", pProp->fltVal);
			break;
		case VT_R8:
			_stprintf(szString, "%lf", pProp->dblVal);
			break;
		case VT_BOOL:
			_stprintf(szString, "%s", pProp->boolVal ? GetString(IDS_PROPYES) : GetString(IDS_PROPNO));
			break;
		case VT_FILETIME:
			SYSTEMTIME sysTime;
			FileTimeToSystemTime(&pProp->filetime, &sysTime);
			GetDateFormat(LOCALE_SYSTEM_DEFAULT,
						  DATE_SHORTDATE,
						  &sysTime,
						  NULL,
						  szString,
						  bufSize);
			break;
		default:
			_tcscpy(szString, "");	
			break;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\PropertyTest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PropertyTest.rc
//
#define IDS_NAME                        1
#define IDS_VALUE                       2
#define IDS_TYPE                        3
#define IDS_LIBDESC                     4
#define IDS_CLASSNAME                   5
#define IDS_PARAMETERS                  6
#define IDS_AUTHOR                      7
#define IDS_PROPTEXT                    7
#define IDS_PROPNUMBER                  8
#define IDS_PROPYESNO                   9
#define IDS_PROPDATE                    10
#define IDS_PROPYES                     11
#define IDS_PROPNO                      12
#define IDD_PANEL                       101
#define IDD_PROPERTYDIALOG              102
#define IDC_CLOSEBUTTON                 1000
#define IDC_SHOWPROP                    1001
#define IDC_CONTENTS                    1002
#define IDC_CUSTOM                      1004
#define IDC_TITLE                       1014
#define IDC_SUBJECT                     1015
#define IDC_AUTHOR                      1016
#define IDC_MANAGER                     1017
#define IDC_COMPANY                     1018
#define IDC_CATEGORY                    1019
#define IDC_KEYWORDS                    1020
#define IDC_COMMENTS                    1021

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\scenemgr\cjapiext.cpp ===
//***************************************************************************
//* SceneAPI - Implementation of Scene Extension API for 3D Studio MAX 2.0
//* 
//* By Christer Janson
//* Kinetix Development
//*
//* November  2, 1996	CCJ Initial coding
//* January   8, 1997	CCJ Added material editor slot access
//* March    15, 1997	CCJ Added scene materials access
//* November 10, 1997	CCJ Ported to MAX Release 2.0
//*
//* This class implements a couple of missing API calls.
//* 


#include "max.h"
#include "cjapiext.h"


class SceneAPIFindSceneProc : public DependentEnumProc {
	public:
		SceneAPIFindSceneProc(ReferenceMaker** anim) {
			scene = anim;
			*scene = NULL;
		}
		int proc(ReferenceMaker *ref) {
			switch (ref->SuperClassID()) {
				case REF_MAKER_CLASS_ID:
					if (ref->ClassID() == Class_ID(THE_SCENE_CLASS_ID, 0)) {
						*scene = ref;
					}
					break;
			}
			return 0;
		}
	private:
		ReferenceMaker** scene;
};


SceneAPI::SceneAPI(Interface* i)
{
	ip = i;

	FindScene();
}

void SceneAPI::FindScene()
{
	scene = NULL;
	SceneAPIFindSceneProc dep(&scene);
	ip->GetRootNode()->EnumDependents(&dep);
}

//////////
// public:
//

MtlBase* SceneAPI::GetMtlSlot(int i)
{
	if (!scene)
		return NULL;

	ReferenceTarget* mtlEdit;
	mtlEdit = scene->GetReference(0);

	if (i >= mtlEdit->NumSubs())
		return NULL;

	MtlBase* mtl = (MtlBase*)mtlEdit->SubAnim(i);

	return mtl;
}

MtlBaseLib* SceneAPI::GetSceneMtls()
{
	if (!scene)
		return NULL;

	return (MtlBaseLib*)scene->GetReference(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\Nurbs\srf_test.cpp ===
/**********************************************************************
 *<
    FILE: sdk_test.cpp

    DESCRIPTION:  Test Utility for the API

    CREATED BY: Charlie Thaeler

    HISTORY: created 24 July, 1997

 *> Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "nutil.h"

static HWND hPanel;

static APITestUtilDesc sAPITestUtilDesc;

ClassDesc*
GetAPITestUtilDesc()
{
	return &sAPITestUtilDesc;
}

const TCHAR *
APITestUtilDesc::ClassName()
{
	return GetString(IDS_API_TEST);
}

const TCHAR *
APITestUtilDesc::Category()
{
	return GetString(IDS_NURBS);
}












static int
AddTestPointSurface(NURBSSet &nset)
{
	NURBSPointSurface *s = new NURBSPointSurface();
	s->SetName(GetString(IDS_ADDED_POINT_SURF));
	s->SetNumPts(2, 2);
	NURBSIndependentPoint pt;
	pt.SetPosition(0, Point3(20, 0, -100));
	s->SetPoint(0, 0, pt);
	pt.SetPosition(0, Point3(20, 0, -200));
	s->SetPoint(0, 1, pt);
	pt.SetPosition(0, Point3(120, 0, -100));
	s->SetPoint(1, 0, pt);
	pt.SetPosition(0, Point3(120, 0, -200));
	s->SetPoint(1, 1, pt);

	s->FlipNormals(TRUE);

	return nset.AppendObject(s);
}


static int
AddTestIsoCurve(NURBSSet &nset, NURBSId id)
{
	NURBSIsoCurve *c = new NURBSIsoCurve();
	c->SetName(GetString(IDS_ADDED_ISO_CURVE));
	c->SetNSet(&nset);

	c->SetParentId(id);
	c->SetParam(0, 0.6);
	c->SetDirection(FALSE); // not U
	return nset.AppendObject(c);
}


static void
AddObjectsForJoinTests(NURBSSet &nset, int &c1, int &c2, int &s1, int &s2)
{
	NURBSIndependentPoint pt;

	NURBSPointCurve *c = new NURBSPointCurve();
	c->SetName(GetString(IDS_J_PT_CRV1));
	c->SetNumPts(3);
	pt.SetPosition(0, Point3(100, 0, -100));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(200, 0, -100));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(200, 100, -100));
	c->SetPoint(2, pt);
	c1 = nset.AppendObject(c);

	c = new NURBSPointCurve();
	c->SetName(GetString(IDS_J_PT_CRV2));
	c->SetNumPts(3);
	pt.SetPosition(0, Point3(210, 110, -100));
	c->SetPoint(0, pt);
	pt.SetPosition(0, Point3(300, 200, -100));
	c->SetPoint(1, pt);
	pt.SetPosition(0, Point3(300, 100, -100));
	c->SetPoint(2, pt);
	c2 = nset.AppendObject(c);

	NURBSPointSurface *s = new NURBSPointSurface();
	s->SetName(GetString(IDS_J_PT_SRF1));
	s->SetNumPts(2, 2);
	pt.SetPosition(0, Point3(200, 0, -100));
	s->SetPoint(0, 0, pt);
	pt.SetPosition(0, Point3(200, 100, -100));
	s->SetPoint(0, 1, pt);
	pt.SetPosition(0, Point3(300, 0, -100));
	s->SetPoint(1, 0, pt);
	pt.SetPosition(0, Point3(300, 100, -100));
	s->SetPoint(1, 1, pt);
	s1 = nset.AppendObject(s);

	s = new NURBSPointSurface();
	s->SetName(GetString(IDS_J_PT_SRF2));
	s->SetNumPts(2, 2);
	pt.SetPosition(0, Point3(310, 0, -100));
	s->SetPoint(0, 0, pt);
	pt.SetPosition(0, Point3(310, 100, -100));
	s->SetPoint(0, 1, pt);
	pt.SetPosition(0, Point3(400, 0, -100));
	s->SetPoint(1, 0, pt);
	pt.SetPosition(0, Point3(400, 100, -100));
	s->SetPoint(1, 1, pt);
	s2 = nset.AppendObject(s);
}

static void
AddObjectsForBreakTests(NURBSSet &nset, int &c1, int &s1)
{
	NURBSCVCurve *c = new NURBSCVCurve();
	c->SetName(GetString(IDS_BREAK_CURVE));
	c->SetNumCVs(4);

	c->SetOrder(4);
	c->SetNumKnots(8);
	for (int k = 0; k < 4; k++) {
		c->SetKnot(k, 0.0);
		c->SetKnot(k+4, 1.0);
	}

	NURBSControlVertex cv;
	cv.SetPosition(0, Point3(200, 0, 50));
	c->SetCV(0, cv);
	cv.SetPosition(0, Point3(300, 0, 50));
	c->SetCV(1, cv);
	cv.SetPosition(0, Point3(300, -100, 50));
	c->SetCV(2, cv);
	cv.SetPosition(0, Point3(200, -100, 50));
	c->SetCV(3, cv);

	c1 = nset.AppendObject(c);
	NURBSCVSurface *s = new NURBSCVSurface();
	s->SetName(GetString(IDS_BREAK_SURFACE));
	s->SetNumCVs(4, 4);

	s->SetUOrder(4);
	s->SetVOrder(4);
	s->SetNumUKnots(8);
	s->SetNumVKnots(8);
	for (k = 0; k < 4; k++) {
		s->SetUKnot(k, 0.0);
		s->SetVKnot(k, 0.0);
		s->SetUKnot(k+4, 1.0);
		s->SetVKnot(k+4, 1.0);
	}

	for (int u = 0; u < 4; u++) {
		float up = 100.0f * ((float)u/3.0f);
		for (int v = 0; v < 4; v++) {
			float vp = 100.0f * ((float)v/3.0f);
			cv.SetPosition(0, Point3(-150.0f + up, -100.0f + vp, -200.0f));
			s->SetCV(u, v, cv);
		}
	}
	s1 = nset.AppendObject(s);
}


void
APITestUtil::CombinedTests()
{
	// now let's build a test object
	NURBSSet nset;
	Matrix3 mat;
	mat.IdentityMatrix();


	// build an independent point
	int indPnt = MakeTestPoint(nset);

	// now a constrained point
	int ptPnt = MakeTestPointCPoint(nset, indPnt);



	// build a cv curve
	int cvCrv = MakeTestCVCurve(nset, mat);

	// and a constrained point on that curve
	int crvPnt = MakeTestCurveCPoint(nset, cvCrv);

	// now a point curve
	int ptCrv = MakeTestPointCurve(nset, mat);

	// Blend the two curves
	int blendCrv = MakeTestBlendCurve(nset, cvCrv, ptCrv);

	// make an offset of the CV curve
	int offCrv = MakeTestOffsetCurve(nset, cvCrv);

	// make a Transform curve of the point curve
	int xformCrv = MakeTestXFormCurve(nset, ptCrv);

	// make a mirror of the blend
	int mirCrv = MakeTestMirrorCurve(nset, blendCrv);

	// make a fillet curve (It makes it's own point curves to fillet)
	int fltCrv = MakeTestFilletCurve(nset);

	// make a chamfer curve (It makes it's own point curves to fillet)
	int chmCrv = MakeTestChamferCurve(nset);




	// build a cv surface
	int cvSurf = MakeTestCVSurface(nset, mat);


	// and a constrained point on that surface
	int srfPnt = MakeTestSurfCPoint(nset, cvSurf);

	// Curve Surface intersection point.
	int cvCrv2 = MakeTestCVCurve(nset, RotateXMatrix(PI/2.0f) * TransMatrix(Point3(0, 0, -175)));
	int srfIntPoint = MakeTestCurveSurface(nset, cvSurf, cvCrv2);

	// Now an Iso Curve on the CV surface
	int isoCrv1 = MakeTestIsoCurveU(nset, cvSurf);

	// Now an Iso Curve on the CV surface
	int isoCrv2 = MakeTestIsoCurveV(nset, cvSurf);

	// Now a Surface Edge Curve on the CV surface
	int surfEdgeCrv = MakeTestSurfaceEdgeCurve(nset, cvSurf);

	// build a CV Curve on Surface
	int cvCOS = MakeTestCurveOnSurface(nset, cvSurf);

	// build a Point Curve on Surface
	int pntCOS = MakeTestPointCurveOnSurface(nset, cvSurf);

	// build a Surface Normal Offset Curve
	int cnoCrf = MakeTestSurfaceNormalCurve(nset, cvCOS);

    // Make a curve-curve intersection point
    int curveCurve = MakeTestCurveCurve(nset, isoCrv1, isoCrv2, TRUE);

	// build a point surface
	int ptSurf = MakeTestPointSurface(nset, mat);

	// Blend the two surfaces
	int blendSurf = MakeTestBlendSurface(nset, cvSurf, ptSurf);

	// Offset of the blend
	int offSurf = MakeTestOffsetSurface(nset, blendSurf);

	// Transform of the Offset
	int xformSurf = MakeTestXFormSurface(nset, offSurf);

	// Mirror of the transform surface
	int mirSurf = MakeTestMirrorSurface(nset, xformSurf);

	// Make a Ruled surface between two curves
	int rulSurf = MakeTestRuledSurface(nset, cvCrv, ptCrv);

	// Make a ULoft surface
	int uLoftSurf = MakeTestULoftSurface(nset, ptCrv, offCrv, xformCrv);

	// Make a Extrude surface
	int extSurf = MakeTestExtrudeSurface(nset, xformCrv);

	// Make a lathe
	int lthSurf = MakeTestLatheSurface(nset);

	// these will build their own curves to work with
	// UV Loft
	int uvLoftSurf = MakeTestUVLoftSurface(nset);


	// 1 Rail Sweep
	int oneRailSurf = MakeTest1RailSweepSurface(nset);

	// 2 Rail Sweep
	int twoRailSurf = MakeTest2RailSweepSurface(nset);

	// MultiCurveTrim Surface
	int multiTrimSurf = MakeTestMultiCurveTrimSurface(nset);


	// Now make the curves and surfaces that we'll use later for the join tests
	int jc1, jc2, js1, js2;
	AddObjectsForJoinTests(nset, jc1, jc2, js1, js2);

	int bc, bs;
	AddObjectsForBreakTests(nset, bc, bs);


	Object *obj = CreateNURBSObject(mpIp, &nset, mat);
	INode *node = mpIp->CreateObjectNode(obj);
	node->SetName(GetString(IDS_TEST_OBJECT));




	NURBSSet addNset;
	// build a point surface
	int addptSurf = AddTestPointSurface(addNset);

	// add an iso curve to the previously created CV Surface
	NURBSId id = nset.GetNURBSObject(cvSurf)->GetId();
	int addIsoCrv = AddTestIsoCurve(addNset, id);

	AddNURBSObjects(obj, mpIp, &addNset);




	// now test some changing functionality
	// Let's change the name of the CVSurface
	NURBSObject* nObj = nset.GetNURBSObject(cvSurf);
	nObj->SetName(_T("New CVSurf Name"));  // testing only, no need to localize

	// now let's change the position of one of the points in the point curve
	NURBSPointCurve* ptCrvObj = (NURBSPointCurve*)nset.GetNURBSObject(ptCrv);
	ptCrvObj->GetPoint(0)->SetPosition(0, Point3(10, 160, 0)); // moved from 0,150,0

	// now let's change the position and weight of one of the CVs
	// in the CV Surface
	NURBSCVSurface* cvSurfObj = (NURBSCVSurface*)nset.GetNURBSObject(cvSurf);
	cvSurfObj->GetCV(0, 0)->SetPosition(0, Point3(-150.0, -100.0, 20.0)); // moved from 0,0,0
	cvSurfObj->GetCV(0, 0)->SetWeight(0, 2.0); // from 1.0


	// now let's do a transform of a curve.
	NURBSIdTab xfmTab;
	NURBSId nid = nset.GetNURBSObject(jc1)->GetId();
	xfmTab.Append(1, &nid);
	Matrix3 xfmMat;
	xfmMat = TransMatrix(Point3(10, 10, -10));
	SetXFormPacket xPack(xfmMat);
	NURBSResult res = Transform(obj, xfmTab, xPack, xfmMat, 0);




	// Now let's Join two curves
	NURBSId jc1id = nset.GetNURBSObject(jc1)->GetId(),
			jc2id = nset.GetNURBSObject(jc2)->GetId();
	JoinCurves(obj, jc1id, jc2id, FALSE, TRUE, 20.0, 1.0f, 1.0f, 0);

	// Now let's Join two surfaces
	NURBSId js1id = nset.GetNURBSObject(js1)->GetId(),
			js2id = nset.GetNURBSObject(js2)->GetId();
	JoinSurfaces(obj, js1id, js2id, 1, 0, 20.0, 1.0f, 1.0f, 0);

	// Break a Curve
	NURBSId bcid = nset.GetNURBSObject(bc)->GetId();
	BreakCurve(obj, bcid, .5, 0);

	// Break a Surface
	NURBSId bsid = nset.GetNURBSObject(bs)->GetId();
	BreakSurface(obj, bsid, TRUE, .5, 0);

	mpIp->RedrawViews(mpIp->GetTime());
	nset.DeleteObjects();
	addNset.DeleteObjects();


	// now do a detach
	NURBSSet detset;
	Matrix3 detmat;
	detmat.IdentityMatrix();
	// build a cv curve
	int detcvCrv = MakeTestCVCurve(detset, detmat);

	// now a point curve
	int detptCrv = MakeTestPointCurve(detset, detmat);

	// Blend the two curves
	int detblendCrv = MakeTestBlendCurve(detset, detcvCrv, detptCrv);

	Object *detobj = CreateNURBSObject(mpIp, &detset, detmat);
	INode *detnode = mpIp->CreateObjectNode(detobj);
	detnode->SetName("Detach From");

	BOOL copy = TRUE;
	BOOL relational = TRUE;
	NURBSIdList detlist;
	NURBSId oid = detset.GetNURBSObject(detblendCrv)->GetId();
	detlist.Append(1, &oid);
	DetachObjects(GetCOREInterface()->GetTime(), detnode, detobj,
					detlist, "Detach Test", copy, relational);
	mpIp->RedrawViews(mpIp->GetTime());

}

void
APITestUtil::PointTests()
{
	// now let's build a test object
	NURBSSet nset;
	Matrix3 mat;
	mat.IdentityMatrix();


	// 6 types of points...

	// 1: build an independent point
	int indPnt = MakeTestPoint(nset);


	// 2: now a constrained point
	int ptPnt = MakeTestPointCPoint(nset, indPnt);



	// build a cv curve
	int cvCrv = MakeTestCVCurve(nset, mat);

	// 3: a constrained point on that curve
	int crvPnt = MakeTestCurveCPoint(nset, cvCrv);



	// build a cv surface
	int cvSurf = MakeTestCVSurface(nset, mat);

	// 4: a constrained point on that surface
	int srfPnt = MakeTestSurfCPoint(nset, cvSurf);

	// 5: Curve Curve intersection point
	int cvCrv1 = MakeTestCVCurve(nset, TransMatrix(Point3(65, 0, 0)) * RotateZMatrix(0.5));
	int intPoint = MakeTestCurveCurve(nset, cvCrv, cvCrv1, FALSE);

	// 6: Curve Surface intersection point.
	int cvCrv2 = MakeTestCVCurve(nset, RotateXMatrix(PI/2.0f) * TransMatrix(Point3(0, 0, -175)));
	int srfIntPoint = MakeTestCurveSurface(nset, cvSurf, cvCrv2);


	Object *obj = CreateNURBSObject(mpIp, &nset, mat);
	INode *node = mpIp->CreateObjectNode(obj);
	node->SetName(GetString(IDS_PNT_TEST_OBJECT));
	mpIp->RedrawViews(mpIp->GetTime());
}


void
APITestUtil::CurveTests()
{
	// now let's build a test object
	NURBSSet nset;
	Matrix3 mat;
	mat.IdentityMatrix();

	// build a cv curve
	int cvCrv = MakeTestCVCurve(nset, mat);

	// now a point curve
	int ptCrv = MakeTestPointCurve(nset, mat);

	// Blend the two curves
	int blendCrv = MakeTestBlendCurve(nset, cvCrv, ptCrv);

	// make an offset of the CV curve
	int offCrv = MakeTestOffsetCurve(nset, cvCrv);

	// make a Transform curve of the point curve
	int xformCrv = MakeTestXFormCurve(nset, ptCrv);

	// make a mirror of the blend
	int mirCrv = MakeTestMirrorCurve(nset, blendCrv);

	// make a fillet curve (It makes it's own point curves to fillet)
	int fltCrv = MakeTestFilletCurve(nset);

	// make a chamfer curve (It makes it's own point curves to fillet)
	int chmCrv = MakeTestChamferCurve(nset);

	Object *obj = CreateNURBSObject(mpIp, &nset, mat);
	INode *node = mpIp->CreateObjectNode(obj);
	node->SetName(GetString(IDS_CRV_TEST_OBJECT));
	mpIp->RedrawViews(mpIp->GetTime());
}

void
APITestUtil::SurfaceTests()
{
	// now let's build a test object
	NURBSSet nset;
	Matrix3 mat;
	mat.IdentityMatrix();

	// we'll need these curves later for contruction of some surfaces
	// build a cv curve
	int cvCrv = MakeTestCVCurve(nset, mat);

	// now a point curve
	int ptCrv = MakeTestPointCurve(nset, mat);

	// make a Transform curve of the point curve
	int xformCrv = MakeTestXFormCurve(nset, ptCrv);

	// make an offset of the CV curve
	int offCrv = MakeTestOffsetCurve(nset, cvCrv);



	// build a cv surface
	int cvSurf = MakeTestCVSurface(nset, mat, TRUE);


	// build a point surface
	int ptSurf = MakeTestPointSurface(nset, mat);

	// Blend the two surfaces
	int blendSurf = MakeTestBlendSurface(nset, cvSurf, ptSurf);

	// Offset of the blend
	int offSurf = MakeTestOffsetSurface(nset, blendSurf);

	// Transform of the Offset
	int xformSurf = MakeTestXFormSurface(nset, offSurf);

	// Mirror of the transform surface
	int mirSurf = MakeTestMirrorSurface(nset, xformSurf);

	// Make a Ruled surface between two curves
	int rulSurf = MakeTestRuledSurface(nset, cvCrv, ptCrv);

	// Make a ULoft surface
	int uLoftSurf = MakeTestULoftSurface(nset, ptCrv, offCrv, xformCrv);

	// Make a Extrude surface
	int extSurf = MakeTestExtrudeSurface(nset, xformCrv);

	// Make a lathe
	int lthSurf = MakeTestLatheSurface(nset);

	// these will build their own curve to work with
	// UV Loft
	int uvLoftSurf = MakeTestUVLoftSurface(nset);


	// 1 Rail Sweep
	int oneRailSurf = MakeTest1RailSweepSurface(nset);

	// 2 Rail Sweep
	int twoRailSurf = MakeTest2RailSweepSurface(nset);

	// MultiCurveTrim Surface
	int multiTrimSurf = MakeTestMultiCurveTrimSurface(nset);

	// N Blend

	// Cap Surface

	Object *obj = CreateNURBSObject(mpIp, &nset, mat);
	INode *node = mpIp->CreateObjectNode(obj);
	node->SetName(GetString(IDS_SRF_TEST_OBJECT));
	mpIp->RedrawViews(mpIp->GetTime());
}

void
APITestUtil::COSTests()
{
	// now let's build a test object
	NURBSSet nset;
	Matrix3 mat;
	mat.IdentityMatrix();

	// build a cv surface
	int cvSurf = MakeTestCVSurface(nset, mat);

	// Now an Iso Curve on the CV surface
	int isoCrv1 = MakeTestIsoCurveU(nset, cvSurf);

	// Now an Iso Curve on the CV surface
	int isoCrv2 = MakeTestIsoCurveV(nset, cvSurf);

	// build a CV Curve on Surface
	int cvCOS = MakeTestCurveOnSurface(nset, cvSurf);

	// build a Point Curve on Surface
	int pntCOS = MakeTestPointCurveOnSurface(nset, cvSurf);

	// build a Surface Normal Offset Curve
	int cnoCrf = MakeTestSurfaceNormalCurve(nset, cvCOS);

	// build a surface surface intersection curve
	int cvSurf1 = MakeTestCVSurface(nset, TransMatrix(Point3(0.0, 0.0, -30.0)) * RotateYMatrix(0.5));
	int intCrv = MakeTestSurfSurfIntersectionCurve(nset, cvSurf, cvSurf1);

	// Vector Projection Curve
	int cvCrv1 = MakeTestCVCurve(nset, TransMatrix(Point3(-100, -200, 40)));
	int vecCrv = MakeTestProjectVectorCurve(nset, cvSurf, cvCrv1);

	// Normal Normal Curve
	int cvCrv2 = MakeTestCVCurve(nset, TransMatrix(Point3(0, -250, 10)));
	int nrmCrv = MakeTestProjectNormalCurve(nset, cvSurf1, cvCrv2);


	Object *obj = CreateNURBSObject(mpIp, &nset, mat);
	INode *node = mpIp->CreateObjectNode(obj);
	node->SetName(GetString(IDS_COS_TEST_OBJECT));
	mpIp->RedrawViews(mpIp->GetTime());
}





static BOOL CALLBACK
APITestDlgProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	APITestUtil *pUtil = (APITestUtil*) GetWindowLong(hWnd, GWL_USERDATA);
	switch (msg) {
	case WM_INITDIALOG:
        pUtil = (APITestUtil*) lParam;
        SetWindowLong(hWnd, GWL_USERDATA, lParam);
		CheckDlgButton(hWnd, IDC_RELATIONAL, pUtil->mRelational);
		CheckDlgButton(hWnd, IDC_AS_CURVE, pUtil->mAsCurve);
		CheckDlgButton(hWnd, IDC_FILE, pUtil->mToFile);
		SetDlgItemText(hWnd, IDC_FILENAME, pUtil->mFilename); 
		break;
	case WM_COMMAND:
		switch (LOWORD(wParam)) {
		case IDC_RUN_TEST:
			pUtil->CombinedTests();
			break;

		case IDC_POINT_TEST:
			pUtil->PointTests();
			break;
		case IDC_CURVE_TEST:
			pUtil->CurveTests();
			break;
		case IDC_SURF_TEST:
			pUtil->SurfaceTests();
			break;
		case IDC_COS_TEST:
			pUtil->COSTests();
			break;

		case IDC_DUMP:
			pUtil->DumpSelected();
			break;

		case IDC_AS_CURVE:
			pUtil->mAsCurve = IsDlgButtonChecked(hWnd, IDC_AS_CURVE);
			break;

		case IDC_RELATIONAL:
			pUtil->mRelational = IsDlgButtonChecked(hWnd, IDC_RELATIONAL);
			break;
		case IDC_FILE:
			pUtil->mToFile = IsDlgButtonChecked(hWnd, IDC_FILE);
			break;
		case IDC_FILENAME:
			switch(HIWORD(wParam)) {
			case EN_SETFOCUS:
				DisableAccelerators();					
				break;
			case EN_KILLFOCUS:
				EnableAccelerators();
				break;
			}
			GetDlgItemText(hWnd, IDC_FILENAME, pUtil->mFilename, 255); 
			break;
		}
		break;
	case WM_DESTROY:
		break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_MOUSEMOVE:
		pUtil->mpIp->RollupMouseMessage(hWnd,msg,wParam,lParam); 
		break;

	default:
		return FALSE;
	}
	return TRUE;
}

void
APITestUtil::BeginEditParams(Interface *ip,IUtil *iu)
{
	this->mpIu = iu;
	this->mpIp = (IObjParam*)ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_NURBS_API_TEST),
		APITestDlgProc,
		GetString(IDS_API_TEST),
		(LPARAM)this);
}


void
APITestUtil::EndEditParams(Interface *ip,IUtil *iu)
{
	this->mpIu = NULL;
	this->mpIp = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\PropertyTest\PropertyTest.h ===
/**********************************************************************
 *<
	FILE: PropertyTest.h

	DESCRIPTION:	Template Utility

	CREATED BY:

	HISTORY:

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __PROPERTYTEST__H
#define __PROPERTYTEST__H

#include "Max.h"
#include "resource.h"
#include "utilapi.h"
#include "istdplug.h"

extern ClassDesc* GetPropertyTestDesc();

extern HINSTANCE hInstance;


class PropertyTest : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;

		PropertyTest();
		~PropertyTest();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);

		void ShowProperties();
		void GetProperties(HWND hDlg);

		void VariantToString(const PROPVARIANT* pProp, TCHAR* szString, int bufSize);
		void TypeNameFromVariant(const PROPVARIANT* pProp, TCHAR* szString, int bufSize);

		BOOL PropDlgProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam);

};

// SummaryInfo properties
/* These are defined in objidl.h
#define PIDSI_TITLE				0x00000002
#define PIDSI_SUBJECT			0x00000003
#define PIDSI_AUTHOR			0x00000004
#define PIDSI_KEYWORDS			0x00000005
#define PIDSI_COMMENTS			0x00000006
*/

// Document SummaryInfo properties
#define PID_MANAGER				0x0000000E
#define PID_COMPANY				0x0000000F
#define PID_CATEGORY			0x00000002
#define PID_HEADINGPAIR			0x0000000C
#define PID_DOCPARTS			0x0000000D

#endif // __PROPERTYTEST__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\scenemgr\cjapiext.h ===
//***************************************************************************
//* SceneAPI - Implementation of Scene Extension API for 3D Studio MAX 1.2
//* 
//* By Christer Janson
//* Kinetix Development
//*
//* November 2, 1996	CCJ Initial coding
//* January  8, 1997	CCJ Added material editor slot access
//* March   15, 1997	CCJ Added scene materials access
//* November 10, 1997	CCJ Ported to MAX Release 2.0
//*
//* This class implements a couple of missing API calls.
//* 
//* WARNING:
//* These functions depend on the internal structure of 3D Studio MAX 2.0.
//* Do not attempt to use it with other versions.
//*

#ifndef __CJAPIEXT__H
#define __CJAPIEXT__H


class SceneAPI {
public:
	SceneAPI(Interface* i);

	MtlBase* GetMtlSlot(int i);
	MtlBaseLib* GetSceneMtls();

private:
	void FindScene();

	Interface* ip;
	ReferenceMaker* scene;
};

#endif	// __CJAPIEXT__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\scenemgr\scenemgr.cpp ===
/*----------------------------------------------------------------------*
 |
 |	FILE: SManager.cpp
 | 
 |	DESC: Scene Manager plugin
 |		  Uses Christer's SceneAPI (CJAPIEXT)
 |
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 |	HISTORY: 27.2.98
 |
 *----------------------------------------------------------------------*/


#include "scenemgr.h"

#define SMANAGER_CLASS_ID	Class_ID(0xb21d7f80, 0x5fc6636a)

HINSTANCE hInstance;
int controlsInit = FALSE;

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetSManagerDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

class SManager : public UtilityObj {
	public:

		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		
		//Constructor/Destructor
		SManager();
		~SManager();
		
		HWND hMapper;
		int m1,m2,m3,m4,m5;
		float totalRAM; 
		NameTab biDB; NameTab mtDB; NameTab txDB;


		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void Output(const TCHAR *format, ...);
		void SetStatus(const TCHAR *format, ...);

		void RefreshScanner(HWND hWnd);

		void DoObjects();
		int facecount,vertcount;
		void TraverseNode(INode* node, TimeValue t);
		void CountFaces(Interface* ip);
		
		void DoUVW();
		int UV1count,UV2count;
		void TraverseNodeUVW(INode* node, TimeValue t);
		void CountUVW(Interface* ip);

		void DoMaps();
		void DoDups();
		void DoLights();


};



static SManager MM;


class SManagerClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &MM;}
	const TCHAR *	ClassName() {return GetString(IDS_CLASS_NAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return SMANAGER_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
	void ResetClassParams (BOOL fileReset);
};

static SManagerClassDesc SManagerDesc;
ClassDesc* GetSManagerDesc() {return &SManagerDesc;}

//TODO: Should implement this method to reset the plugin params when Max is reset
void SManagerClassDesc::ResetClassParams (BOOL fileReset) 
{

}



void SManager::Output(const TCHAR *format, ...){
	TCHAR buf[512];
	va_list args;
	va_start(args,format);
	_vsntprintf(buf,512,format,args);
	va_end(args);

	SendMessage(GetDlgItem(hMapper,IDC_OUT),LB_ADDSTRING,0,(LPARAM)buf);
}

void SManager::SetStatus(const TCHAR *format, ...){
	TCHAR buf[512];
	va_list args;
	va_start(args,format);
	_vsntprintf(buf,512,format,args);
	va_end(args);

	SetWindowText(GetDlgItem(hMapper,IDC_STATUS),buf);
	InvalidateRect(GetDlgItem(hMapper,IDC_STATUS),NULL,TRUE);
}



void SManager::RefreshScanner(HWND hWnd){
				HMENU hMenu = GetMenu(hWnd);
				if(m1==0){
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_1,MF_UNCHECKED );
				}
				else {
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_1,MF_CHECKED );
				}

				if(m2==0){
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_2,MF_UNCHECKED );
				}
				else {
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_2,MF_CHECKED );
				}
				if(m3==0){
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_3,MF_UNCHECKED );
				}
				else {
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_3,MF_CHECKED );
				}
				if(m4==0){
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_4,MF_UNCHECKED );
				}
				else {
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_4,MF_CHECKED );
				}
				if(m5==0){
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_5,MF_UNCHECKED );
				}
				else {
					CheckMenuItem(GetSubMenu(hMenu, 1),ID_5,MF_CHECKED );
				}


}

static BOOL CALLBACK MMDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{

	switch(msg){

		case WM_INITDIALOG:
			MM.RefreshScanner(hWnd);
		break;

		case WM_DESTROY:
			MM.biDB.SetSize(0); MM.mtDB.SetSize(0); MM.txDB.SetSize(0);
			// kill variables
			MM.totalRAM=0; MM.vertcount=0; MM.facecount=0;
			MM.UV1count=MM.UV2count=0; 
		break;


		case WM_COMMAND:
		switch (LOWORD(wParam)) {

			case IDC_SAVE:{
				OPENFILENAME ofn;
				TCHAR filename[255] = _T("");

				memset(&ofn, 0, sizeof(OPENFILENAME));
				ofn.lStructSize = sizeof(OPENFILENAME);
				ofn.hwndOwner = hWnd;
				ofn.hInstance = hInstance;
				ofn.lpstrFile = filename;
				ofn.nMaxFile = sizeof(filename) / sizeof(TCHAR);
				ofn.lpstrFilter = _T("Text File\0*.txt\0");
				ofn.nFilterIndex = 1;
				ofn.lpstrTitle   = _T("Choose Output");
				ofn.lpstrFileTitle = NULL;
				ofn.nMaxFileTitle = 0;
				ofn.lpstrInitialDir = MM.ip->GetDir(APP_SCENE_DIR);
				ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

				if (GetSaveFileName(&ofn))
				{
					if(_tcsicmp(filename + _tcslen(filename) - 4, ".txt")) 
						strcat(filename,".txt");

					FILE *stream;
					stream = fopen(filename,"wt");
					HWND outHwnd = GetDlgItem(hWnd,IDC_OUT);
					if (stream)
					{
						for(int x=0; x<(SendMessage(outHwnd,LB_GETCOUNT,0,0));x++)
						{
							char q[255];
							SendMessage(outHwnd,LB_GETTEXT,x,(WPARAM)q);
							fprintf(stream,"%s\n",q);
						}
						fclose(stream);
					}
				}
			break;}

			case IDC_CLOSE:
				MM.hMapper=NULL;
				EndDialog(hWnd,1);
			break;
			case IDC_CLEAR:
				SendMessage(GetDlgItem(hWnd,IDC_OUT),LB_RESETCONTENT,0,0);
				InvalidateRect(GetDlgItem(hWnd,IDC_OUT),NULL,TRUE); 

			break;
			case IDC_GENERATE:
					
					// kill variables
					MM.totalRAM=0; MM.vertcount=0; MM.facecount=0;
					MM.UV1count=MM.UV2count=0; 
					MM.biDB.SetSize(0); MM.mtDB.SetSize(0); MM.txDB.SetSize(0);

					MM.SetStatus("");
					MM.Output("--- START OF REPORT ---");
					MM.Output("");
					MM.Output("");
					if(MM.m1==1) MM.DoObjects();
					if(MM.m2==1) MM.DoUVW();
					if(MM.m3==1) MM.DoMaps();
					if(MM.m4==1) MM.DoDups();
					if(MM.m5==1) MM.DoLights();
					MM.Output("");
					MM.Output("Total Memory Usage: %.2fMB",(float)MM.totalRAM/1024.0f);
					MM.Output("");MM.Output("--- END OF REPORT ---");MM.Output("");MM.Output("");
					MM.SetStatus("");
				break;

			case ID_ALL:
				MM.m1=MM.m2=MM.m3=MM.m4=MM.m5=1;MM.RefreshScanner(hWnd);
			break;
			case ID_NONE:
				MM.m1=MM.m2=MM.m3=MM.m4=MM.m5=0;MM.RefreshScanner(hWnd);
			break;

			case ID_1:{
				if(MM.m1==1){MM.m1=0;}
				else {MM.m1=1;}MM.RefreshScanner(hWnd);
			break;}
			case ID_2:{
				if(MM.m2==1){MM.m2=0;}
				else {MM.m2=1;}MM.RefreshScanner(hWnd);
			break;}
			case ID_3:{
				if(MM.m3==1){MM.m3=0;}
				else {MM.m3=1;}MM.RefreshScanner(hWnd);
			break;}
			case ID_4:{
				if(MM.m4==1){MM.m4=0;}
				else {MM.m4=1;}MM.RefreshScanner(hWnd);
			break;}
			case ID_5:{
				if(MM.m5==1){MM.m5=0;}
				else {MM.m5=1;}MM.RefreshScanner(hWnd);
			break;}

		}
		break;

		case WM_SIZE:{
				MoveWindow(GetDlgItem(hWnd,IDC_OUT),
					0,
					0, 
					LOWORD(lParam),
					HIWORD(lParam)-22,TRUE);
				Rect rw;
				GetWindowRect(GetDlgItem(hWnd,IDC_OUT),&rw);
				MoveWindow(GetDlgItem(hWnd,IDC_STATUS),
					0,
					rw.h()+1, 
					LOWORD(lParam),
					20,TRUE);
			break;}

		case WM_CLOSE:
			MM.hMapper=NULL;
			EndDialog(hWnd,1);
			break;
	}

	
	return FALSE;
	}


static BOOL CALLBACK SManagerDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			MM.Init(hWnd);
			break;

		case WM_DESTROY:
			MM.Destroy(hWnd);
			break;

		case WM_ENABLE:
			if(MM.hMapper!=NULL) EnableWindow(MM.hMapper,(BOOL) wParam);
			break;

		case WM_COMMAND:
		switch (LOWORD(wParam)) {



			case IDC_LAUNCH:
				if(MM.hMapper==NULL) MM.hMapper = 
					CreateDialog(
					hInstance,
					MAKEINTRESOURCE(IDD_SM_FLOATER),
					GetCOREInterface()->GetMAXHWnd(),
					MMDlgProc);
				break;
		}
			break;

		default:
			return FALSE;
	}
	return TRUE;
}



//--- SManager -------------------------------------------------------
SManager::SManager()
{
	iu = NULL;
	hPanel = NULL;
	m1=m2=m3=m4=m5=1;
	totalRAM=0;
}

SManager::~SManager()
{

}

void SManager::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_SM_PANEL),
		SManagerDlgProc,
		GetString(IDS_PARAMS),
		0);
}
	
void SManager::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void SManager::Init(HWND hWnd)
{
}

void SManager::Destroy(HWND hWnd)
{

}


//****************************************************************
// GENERATORS
//****************************************************************

class NullView : public View {

public:

Point2 ViewToScreen(Point3 p)

{ return Point2(p.x,p.y); }

NullView() {

worldToView.IdentityMatrix();
screenW=640.0f; screenH = 480.0f;
}

};

//****************************************************************
// GEOMETRY SCAN
//****************************************************************

class BeginEnum : public RefEnumProc {
	TimeValue t;
	public:
		BeginEnum(TimeValue time) { t = time; }
		void proc(ReferenceMaker *m) { 
				m->RenderBegin(t);  
			}
	};

class EndEnum : public RefEnumProc {
	TimeValue t;
	public:
		EndEnum(TimeValue time) { t = time; }
		void proc(ReferenceMaker *m) { 
				m->RenderEnd(t);  
			}
	};


void EnumRefs(RefEnumProc& renum,INode *inode) {
	EnumRefHierarchy(inode,renum);
	}


// Traverse the node counting polygons.  
void SManager::TraverseNode(INode* node, TimeValue t)
{
	BOOL deleteMesh;
	NullView nw;
	MM.SetStatus("Examining Object : %s",node->GetName());

	//node->RenderBegin(t);
	BeginEnum beginEnum(ip->GetTime());
	EnumRefs(beginEnum,node);

    const ObjectState& os = node->EvalWorldState(t);
    Object* ob = os.obj;
    if (ob!=NULL) {

        if (ob->SuperClassID() == GEOMOBJECT_CLASS_ID) {
            GeomObject* geo = (GeomObject *)ob;
            if(geo->CanConvertToType(triObjectClassID)) {

				MM.Output("%s :",node->GetName());
		               
				Mesh* mesh = geo->GetRenderMesh(t, node, nw, deleteMesh);

                facecount += mesh->getNumFaces();
				float fclc = (mesh->getNumFaces()*34.0f)/1024.0f;
                vertcount += mesh->getNumVerts();
				float vclc = (mesh->getNumVerts()*28.0f)/1024.0f;
				
				MM.Output("    * Face Count: %i -> %.1f kB",
					mesh->getNumFaces(),
					fclc);
				MM.Output("    * Vertex Count: %i -> %.1f kB",
					mesh->getNumVerts(),
					vclc);

                	if (deleteMesh) {
						delete mesh;
					}

            }
        }
    }
	//node->RenderEnd(t);
	EndEnum endEnum(ip->GetTime());
	EnumRefs(endEnum,node);


    int i, numChildren = node->NumberOfChildren();
    for(i=0; i<numChildren; i++)
        TraverseNode(node->GetChildNode(i), t);
}

// Traverse all the nodes in the scene graph.
void SManager::CountFaces(Interface* ip)
{
    TraverseNode(ip->GetRootNode(), ip->GetTime());
}

void SManager::DoObjects(){
	MM.Output("*** Beginning Object Pass  ------------------------------------------------------------------------");
	MM.Output("***");
	MM.SetStatus("Beginning Object Pass");
	CountFaces(ip);
	float fll = (facecount*34.0f)/1024.0f;
	float vll = (vertcount*28.0f)/1024.0f;
	float sll = ((facecount*34.0f)+(vertcount*28.0f))/1024.0f;
	MM.Output("");
	MM.Output("Total Scene Faces: %i -> %.1f kB",facecount,fll);
	MM.Output("Total Scene Vertices: %i -> %.1f kB",vertcount,vll);
	MM.Output("Total Geometry RAM: %.2f kB   |   %.2f MB",sll,sll/1024.0f);
	MM.Output("");

	totalRAM+=sll;

}

//****************************************************************
// UVW MAPPING SCAN
//****************************************************************

// Traverse the node counting UVW.  
void SManager::TraverseNodeUVW(INode* node, TimeValue t)
{
	BOOL deleteMesh;
	NullView nw;
	
	MM.SetStatus("Examining Object UVWs : %s",node->GetName());

	//node->RenderBegin(t);
	BeginEnum beginEnum(ip->GetTime());
	EnumRefs(beginEnum,node);


    const ObjectState& os = node->EvalWorldState(t);
    Object* ob = os.obj;
    if (ob!=NULL) {

		
        if (ob->SuperClassID() == GEOMOBJECT_CLASS_ID) {
            GeomObject* geo = (GeomObject *)ob;
            if(geo->CanConvertToType(triObjectClassID)) {
        
				Mesh* mesh = geo->GetRenderMesh(t, node, nw, deleteMesh);


				// are there any mapping coords to speak of?
				if(mesh->getNumVertCol()>0||
					mesh->getNumTVerts()>0) MM.Output("%s :",node->GetName());


                UV2count += mesh->getNumVertCol();
				float fclc = (mesh->getNumVertCol()*12.0f)/1024.0f;
                UV1count += mesh->getNumTVerts();
				float vclc = (mesh->getNumTVerts()*12.0f)/1024.0f;
				
				if(mesh->getNumTVerts()>0) {MM.Output("    * UV Channel 1: %i -> %.1f kB",
					mesh->getNumTVerts(),
					vclc);}
				if(mesh->getNumVertCol()>0) {MM.Output("    * UV Channel 2: %i -> %.1f kB",
					mesh->getNumVertCol(),
					fclc);}

                	if (deleteMesh) {
						delete mesh;
					}

            }
        }
    }
	//node->RenderEnd(t);
	EndEnum endEnum(ip->GetTime());
	EnumRefs(endEnum,node);


    int i, numChildren = node->NumberOfChildren();
    for(i=0; i<numChildren; i++)
        TraverseNodeUVW(node->GetChildNode(i), t);
}

// Traverse all the nodes in the scene graph.
void SManager::CountUVW(Interface* ip)
{
    TraverseNodeUVW(ip->GetRootNode(), ip->GetTime());
}

void SManager::DoUVW(){
	MM.Output("*** Beginning UVW Mapping Pass  -------------------------------------------------------------------");
	MM.Output("***");
	MM.SetStatus("Beginning UVW Mapping Pass");
	CountUVW(ip);
	float fll = (UV1count*12.0f)/1024.0f;
	float vll = (UV2count*12.0f)/1024.0f;
	float sll = ((UV1count*12.0f)+(UV2count*12.0f))/1024.0f;
	MM.Output("");
	MM.Output("Total UV Channel 1: %i -> %.1f kB",UV1count,fll);
	MM.Output("Total UV Channel 2: %i -> %.1f kB",UV2count,vll);
	MM.Output("Total Mapping RAM: %.2f kB   |   %.2f MB",sll,sll/1024.0f);
	MM.Output("");

	totalRAM+=sll;

}

int bmp_bpp(BitmapInfo bi){

	//calculate bits/pixel
	int bpp;
	if(bi.Type()==BMM_LINE_ART)		bpp=1;
	if(bi.Type()==BMM_GRAY_8)		bpp=8;
	if(bi.Type()==BMM_GRAY_16)		bpp=16;
	if(bi.Type()==BMM_TRUE_16)		bpp=16;
	if(bi.Type()==BMM_TRUE_32)		bpp=32;
	if(bi.Type()==BMM_TRUE_64)		bpp=64;
	if(bi.Type()==BMM_TRUE_24)		bpp=24;
	if(bi.Type()==BMM_TRUE_48)		bpp=48;
	if(bi.Type()==BMM_BMP_4)		bpp=4;
	if(bi.Type()==BMM_PALETTED)		bpp=8;
	return bpp;
}
//****************************************************************
// BITMAP SCAN
//****************************************************************
class MtlEnum {
	public:
	char mname[255];

		virtual void  proc(MtlBase *m){

			if(m->ClassID()==Class_ID(BMTEX_CLASS_ID,0)) {
				Texmap *bt = (Texmap*)m;
				BitmapTex *b = (BitmapTex*)bt;

				if(_stricmp(b->GetMapName(),"")!=0){
					
					Bitmap *bmp = b->GetBitmap(MM.ip->GetTime());

					if(BMMIsFile(b->GetMapName())){
					BitmapInfo bi = bmp->Storage()->bi;
					
					if(MM.biDB.FindName(b->GetMapName())==-1){
						
						float mem = (float)((bmp->Width()*bmp->Height()*bmp_bpp(bi))/1024)/8;

						MM.Output("[%s / %s] : %s",mname,b->GetName(),b->GetMapName());
						MM.Output("    * RAM Statistics:  W:%i, H:%i, BPP:%i  ->  %.1f kB",
							bmp->Width(),bmp->Height(),bmp_bpp(bi),
							mem);

						int FT = b->GetFilterType();
						if (FT==FILTER_PYR) (float)mem*=1.33f;
						if (FT==FILTER_SAT) (float)mem*=4.0f;
						MM.Output("    * Total After Filtering:  %.1f MB",mem/1024.0f);
						MM.Output("");

						MM.totalRAM+=(int)(mem);

						MM.biDB.AddName (b->GetMapName());
						MM.txDB.AddName (b->GetName());
						MM.mtDB.AddName (mname);
					}

					}else{
						char p[255],f[255],e[255];
						BMMSplitFilename(b->GetMapName(), p, f, e);
						MM.Output("[%s / %s] : %s",mname,b->GetName(),b->GetMapName());
 						MM.Output("    * Map file '%s%s' could not be found!",f,e);
						MM.Output("");
						
					}

				}
				else{
					MM.Output("Map Found: [Undefined/Unallocated]");
				}
			}
		}
	};


MtlEnum Enym;


// do the material enumeration
void EnumMtlTree(MtlBase *mb, MtlEnum &tenum) {
	tenum.proc(mb);
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) 
			EnumMtlTree(st,tenum);
		}
	if (IsMtl(mb)) {
		strcpy(tenum.mname,mb->GetName());
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) 
				EnumMtlTree(sm,tenum);
			}
		}
	}



void SManager::DoMaps(){
	MM.Output("*** Beginning Bitmap Materials Pass  --------------------------------------------------------------");
	MM.Output("***");
	MM.SetStatus("Beginning Bitmap Materials Pass");

	// Use the SceneAPI to check the material editor for anything..
	SceneAPI sceneapi(ip);
	
	MtlBaseLib* mlib;
	mlib = sceneapi.GetSceneMtls();

	if (mlib) {
		int numMtls = mlib->Count();
		for (int i=0; i<numMtls; i++) {
			MtlBase* mat = (*mlib)[i];
			EnumMtlTree(mat,Enym);				
		}
	}
	MM.Output("");
	MM.Output("*** Checking for duplicate map names...");
	MM.SetStatus("Checking for duplicate map names");

	char p[255],f[255],e[255];
	char p2[255],f2[255],e2[255];
	for(int y=0;y<biDB.Count();y++){
		BMMSplitFilename(biDB[y], p, f, e);

		for(int d=0;d<biDB.Count();d++){
			BMMSplitFilename(biDB[d], p2, f2, e2);
			if(_stricmp(f,f2)==0&&_stricmp(e,e2)==0&&_stricmp(p,p2)!=0){
				MM.Output("    * Duplicated map in [%s / %s] : %s%s%s",MM.mtDB[d],MM.txDB[d],p2,f2,e2);
			}
		}

	}
	MM.Output("");

}


// Enumerate the scene for lights
void LiteEnum(INode *root)
{
	for (int k=0; k<root->NumberOfChildren(); k++)
	{
		INode *node = root->GetChildNode(k);
		Object* ob = node->GetObjectRef();
		if(ob!=NULL&&ob->SuperClassID()==LIGHT_CLASS_ID)
		{
			LightObject *ltmp = (LightObject*) ob;
			int mSz = ltmp->GetMapSize(MM.ip->GetTime());
			if((mSz!=0)&&(ltmp->GetShadow())&&(ltmp->GetShadowMethod()==LIGHTSHADOW_MAPPED)){
				float msRAM = ((mSz*mSz)*4.0f)/1024.0f;
				MM.Output("%s -> Shadow Map size: %i --> %0.1f kB",node->GetName(),mSz,msRAM);
				MM.totalRAM+=(int)(msRAM);
			}
		}
		if(node->NumberOfChildren()>0) LiteEnum(node);
	}
}

void SManager::DoDups(){
	MM.Output("*** Beginning Lighting Pass  ----------------------------------------------------------------------");
	MM.Output("");
	INode *root = ip->GetRootNode();
	LiteEnum(root);
	MM.Output("");
}

void SManager::DoLights(){
	MM.Output("*** Beginning Render RAM Pass  --------------------------------------------------------------------");
	MM.Output("");
	int rWidth = ip->GetRendWidth();
	int rHeight = ip->GetRendHeight();
	float RAMrw = ((rWidth*rHeight)*8.0f)/1024.0f;

	MM.Output("Render Bitmap output: %ix%i --> %.1f kB / %.1f MB",rWidth,rHeight,RAMrw,RAMrw/1024.0f);

	MM.totalRAM+=(int)(RAMrw);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\scenemgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SceneMgr.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDC_GENERATE                    2
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDS_UV_NAME                     5
#define IDD_SM_PANEL                    101
#define IDD_SM_FLOATER                  102
#define IDR_MENU1                       103
#define IDI_ICON1                       104
#define IDC_LAUNCH                      1001
#define IDC_OUT                         1002
#define IDC_STATUS                      1015
#define IDC_SAVE                        40004
#define IDC_CLEAR                       40005
#define ID_1                            40006
#define ID_2                            40007
#define ID_3                            40008
#define ID_4                            40009
#define ID_5                            40010
#define IDC_FIND                        40012
#define IDC_CLOSE                       40013
#define ID_6                            40016
#define ID_S1                           40018
#define ID_S2                           40019
#define ID_S3                           40020
#define ID_S4                           40021
#define ID_S5                           40022
#define ID_S6                           40023
#define ID_S7                           40024
#define ID_S8                           40025
#define ID_ALL                          40026
#define ID_NONE                         40027
#define ID_SALL                         40028
#define ID_SNONE                        40029

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40031
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UMaxFind\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UMaxFind.rc
//
#define IDS_LIBDESC                     1
#define IDS_CLASSNAME                   2
#define IDS_TITLE                       3
#define IDS_ERROR                       4
#define IDS_NOEXE                       5
#define IDS_VIZ_CLASSNAME               6
#define IDS_VIZ_TITLE                   7
#define IDD_PANEL                       101
#define IDD_VIZ_PANEL                   102
#define IDC_CLOSEBUTTON                 1000
#define IDC_START                       1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UMaxFind\UMaxFind.h ===
/**********************************************************************
 *<
	FILE:			UMaxFind.h

	DESCRIPTION:	Utility to startup external MAXFinder executable.

	CREATED BY:		Christer Janson

	HISTORY:		Created Monday, October 05, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#ifndef __UMAXFIND__H
#define __UMAXFIND__H

#include "Max.h"
#include "resource.h"
#include "utilapi.h"
#include "istdplug.h"

extern ClassDesc* GetUMaxFindDesc();

extern HINSTANCE hInstance;

#endif // __UMAXFIND__H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\scenemgr\scenemgr.h ===
/*----------------------------------------------------------------------*
 |
 |	FILE: scenemgr.h
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 *----------------------------------------------------------------------*/

#ifndef __SCENEMGR__H
#define __SCENEMGR__H

#include "Max.h"

#include "resource.h"
#include "utilapi.h"
#include "stdmat.h"
#include "bmmlib.h"
#include "cjapiext.h"

TCHAR *GetString(int id);

extern ClassDesc* GetSManagerDesc();

extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UMaxFind\UMaxFind.cpp ===
/**********************************************************************
 *<
	FILE:			UMaxFind.cpp

	DESCRIPTION:	Utility to startup external MAXFinder executable.

	CREATED BY:		Christer Janson

	HISTORY:		Created Monday, October 05, 1998

 *>	Copyright (c) 1998, All Rights Reserved.
 **********************************************************************/

#include "UMaxFind.h"
#include "buildver.h"

HINSTANCE hInstance;

#define UMAXFIND_CLASS_ID	Class_ID(0x72bb49f5, 0xa7a1cb4f)

BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			hInstance = hinstDLL;
			InitCustomControls(hInstance);
			InitCommonControls();
			break;
		case DLL_PROCESS_DETACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
	}

	return (TRUE);
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESC);
}

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}


__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetUMaxFindDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}

class UMaxFind : public UtilityObj {
	public:
		IUtil *iu;
		Interface *ip;
		HWND hPanel;

		UMaxFind();
		~UMaxFind();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void StartFileFinder();
};

static UMaxFind theUMaxFind;

class UMaxFindClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theUMaxFind;}
	const TCHAR *	ClassName() {return GetString(IDS_CLASSNAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return UMAXFIND_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static UMaxFindClassDesc UMaxFindDesc;
ClassDesc* GetUMaxFindDesc() {return &UMaxFindDesc;}


static BOOL CALLBACK UMaxFindDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theUMaxFind.Init(hWnd);
			break;

		case WM_DESTROY:
			theUMaxFind.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDC_CLOSEBUTTON:
					theUMaxFind.iu->CloseUtility();
					break;
				case IDC_START:
					theUMaxFind.StartFileFinder();
					break;
			}
			break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_MOUSEMOVE:
			theUMaxFind.ip->RollupMouseMessage(hWnd,msg,wParam,lParam); 
			break;

		default:
			return FALSE;
	}
	return TRUE;
}	

UMaxFind::UMaxFind()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

UMaxFind::~UMaxFind()
{
}

void UMaxFind::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
#ifndef DESIGN_VER
		MAKEINTRESOURCE(IDD_PANEL),
#else
		MAKEINTRESOURCE(IDD_VIZ_PANEL),
#endif
		UMaxFindDlgProc,
#ifndef DESIGN_VER
		GetString(IDS_TITLE),
#else
		GetString(IDS_VIZ_TITLE),
#endif
		0);
}
	
void UMaxFind::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void UMaxFind::Init(HWND hWnd)
{
}

void UMaxFind::Destroy(HWND hWnd)
{
}

void UMaxFind::StartFileFinder()
{
	TCHAR				szExeFile[_MAX_PATH];
	TSTR				szPath;
	PROCESS_INFORMATION	process;
	STARTUPINFO			si;
	BOOL				res;

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	si.wShowWindow = SW_SHOWDEFAULT;
	si.hStdError = NULL;


	GetModuleFileName(NULL, szExeFile, _MAX_PATH);
	SplitFilename(TSTR(szExeFile), &szPath, NULL, NULL);
#ifndef DESIGN_VER
	szPath = szPath+_T("\\MaxFind.Exe");	
#else
	szPath = szPath+_T("\\VIZFind.Exe");	
#endif

	res = CreateProcess(NULL, szPath, NULL, NULL, FALSE, 0, NULL, NULL, &si, &process);
	if (!res) {
		// Error
		TSTR msg = GetString(IDS_ERROR);
		MessageBox(hPanel, GetString(IDS_NOEXE), msg, MB_OK | MB_ICONEXCLAMATION);
		return;
		}

	CloseHandle(process.hThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UVremove\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UVRemove.rc
//
#define IDS_LIBDESCRIPTION              1
#define IDS_CLASS_NAME                  3
#define IDS_PARAMS                      4
#define IDS_UV_NAME                     5
#define IDD_UV_PANEL                    104
#define IDC_R1                          1001
#define IDC_R2                          1002
#define IDC_BLANK                       1003
#define IDC_SEL                         1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40031
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UVremove\uvremove.cpp ===
/*----------------------------------------------------------------------*
 |
 |	FILE: UVStrip.cpp
 | 
 |	DESC: UVW Coord remover plugin
 |
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 |	HISTORY: 27.2.98
 |
 *----------------------------------------------------------------------*/

#include "uvremove.h"

#define UV_CLASS_ID	Class_ID(0x653e99d6, 0x68e7731e)

HINSTANCE hInstance;
int controlsInit = FALSE;


BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if (!controlsInit) {
		controlsInit = TRUE;
		InitCustomControls(hInstance);
		InitCommonControls();
	}
			
	return (TRUE);
}

__declspec( dllexport ) const TCHAR* LibDescription()
{
	return GetString(IDS_LIBDESCRIPTION);
}

//TODO: Must change this number when adding a new class
__declspec( dllexport ) int LibNumberClasses()
{
	return 1;
}

__declspec( dllexport ) ClassDesc* LibClassDesc(int i)
{
	switch(i) {
		case 0: return GetUVStripDesc();
		default: return 0;
	}
}

__declspec( dllexport ) ULONG LibVersion()
{
	return VERSION_3DSMAX;
}

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}

class UVStrip : public UtilityObj {
	public:

		IUtil *iu;
		Interface *ip;
		HWND hPanel;
		
		//Constructor/Destructor
		UVStrip();
		~UVStrip();

		void BeginEditParams(Interface *ip,IUtil *iu);
		void EndEditParams(Interface *ip,IUtil *iu);
		void DeleteThis() {}

		void Init(HWND hWnd);
		void Destroy(HWND hWnd);
		void SelectionSetChanged(Interface *ip,IUtil *iu);
};



static UVStrip theUVStrip;

class UVStripClassDesc:public ClassDesc {
	public:
	int 			IsPublic() {return 1;}
	void *			Create(BOOL loading = FALSE) {return &theUVStrip;}
	const TCHAR *	ClassName() {return GetString(IDS_UV_NAME);}
	SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
	Class_ID		ClassID() {return UV_CLASS_ID;}
	const TCHAR* 	Category() {return _T("");}
};

static UVStripClassDesc UVStripDesc;
ClassDesc* GetUVStripDesc() {return &UVStripDesc;}


static BOOL CALLBACK UVStripDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	switch (msg) {
		case WM_INITDIALOG:
			theUVStrip.Init(hWnd);
			char s[50]; sprintf(s,"%i Object(s) Selected",theUVStrip.ip->GetSelNodeCount());
			SetWindowText(GetDlgItem(hWnd,IDC_SEL),s);
			break;

		case WM_DESTROY:
			theUVStrip.Destroy(hWnd);
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
			
			case IDC_R1:{
				int cn = theUVStrip.ip->GetSelNodeCount();
				Interval valid=FOREVER;
				if(cn>0){
					for(int x=0;x<cn;x++){
				      ObjectState os = theUVStrip.ip->GetSelNode(x)->EvalWorldState(theUVStrip.ip->GetTime());
					  if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID && os.obj->IsRenderable() && os.obj->IsDeformable()) {
						  TriObject *T1 = (TriObject *)os.obj;
						  T1->GetMesh().setNumTVerts(0);
						  T1->GetMesh().setNumTVFaces(0);
						  //T1->UpdateValidity(TEXMAP_CHAN_NUM,valid);
						  //T1->mesh.InvalidateGeomCache();
						  //T1->mesh.InvalidateTopologyCache();
					  }
					  theUVStrip.ip->ForceCompleteRedraw();
					}
				}
				break;}

			case IDC_R2:{
				int cn = theUVStrip.ip->GetSelNodeCount();
				if(cn>0){
					for(int x=0;x<cn;x++){
						INode *tmp=theUVStrip.ip->GetSelNode(x);
						tmp->SetMtl(NULL);
						if(GetCheckBox(hWnd, IDC_BLANK)) tmp->SetWireColor(RGB(160,160,160));
					}
					theUVStrip.ip->ForceCompleteRedraw();
				}
				break;}

			}
			break;

		default:
			return FALSE;
	}
	return TRUE;
}



//--- UVStrip -------------------------------------------------------
UVStrip::UVStrip()
{
	iu = NULL;
	ip = NULL;	
	hPanel = NULL;
}

UVStrip::~UVStrip()
{

}


void UVStrip::SelectionSetChanged(Interface *ip,IUtil *iu)
{
	char s[50]; sprintf(s,"%i Object(s) Selected",ip->GetSelNodeCount());
	SetWindowText(GetDlgItem(hPanel,IDC_SEL),s);
}

void UVStrip::BeginEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = iu;
	this->ip = ip;
	hPanel = ip->AddRollupPage(
		hInstance,
		MAKEINTRESOURCE(IDD_UV_PANEL),
		UVStripDlgProc,
		GetString(IDS_PARAMS),
		0);
}
	
void UVStrip::EndEditParams(Interface *ip,IUtil *iu) 
{
	this->iu = NULL;
	this->ip = NULL;
	ip->DeleteRollupPage(hPanel);
	hPanel = NULL;
}

void UVStrip::Init(HWND hWnd)
{

}

void UVStrip::Destroy(HWND hWnd)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ViewFile\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by viewfile.rc
//
#define IDS_DB_VIEW_FILE                1
#define IDS_DB_NO_VIEW                  2
#define IDS_DB_VIEW_ERROR               3

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Utility\UVremove\uvremove.h ===
/*----------------------------------------------------------------------*
 |
 |	FILE: uvremove.h
 |	AUTH: Harry Denholm, Kinetix
 |		  Copyright (c) 1998, All Rights Reserved.
 |
 *----------------------------------------------------------------------*/

#ifndef __UVREMOVE__H
#define __UVREMOVE__H

#include "Max.h"

#include "resource.h"
#include "utilapi.h"

TCHAR *GetString(int id);

extern ClassDesc* GetUVStripDesc();

extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\acob.cpp ===
mesh.setNumVerts(62);
    mesh.setNumFaces(109);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669281));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.000610,0.150846,-0.003418));
    mesh.setVert(11, size * Point3(0.058156,0.150846,-0.003418));
    mesh.setVert(12, size * Point3(0.050283,0.150846,0.025965));
    mesh.setVert(13, size * Point3(0.028773,0.150846,0.047475));
    mesh.setVert(14, size * Point3(-0.000610,0.150846,0.055348));
    mesh.setVert(15, size * Point3(-0.029993,0.150846,0.047475));
    mesh.setVert(16, size * Point3(-0.051502,0.150846,0.025965));
    mesh.setVert(17, size * Point3(-0.059376,0.150846,-0.003418));
    mesh.setVert(18, size * Point3(-0.051503,0.150846,-0.032801));
    mesh.setVert(19, size * Point3(-0.029993,0.150846,-0.054310));
    mesh.setVert(20, size * Point3(-0.000610,0.150846,-0.062183));
    mesh.setVert(21, size * Point3(0.028773,0.150846,-0.054310));
    mesh.setVert(22, size * Point3(0.050283,0.150846,-0.032801));
    mesh.setVert(23, size * Point3(0.380659,-0.101110,-0.003418));
    mesh.setVert(24, size * Point3(0.329579,-0.101110,0.187217));
    mesh.setVert(25, size * Point3(0.190025,-0.101110,0.326771));
    mesh.setVert(26, size * Point3(-0.000610,-0.101110,0.377851));
    mesh.setVert(27, size * Point3(-0.191244,-0.101110,0.326771));
    mesh.setVert(28, size * Point3(-0.330799,-0.101110,0.187217));
    mesh.setVert(29, size * Point3(-0.381879,-0.101110,-0.003418));
    mesh.setVert(30, size * Point3(-0.330799,-0.101110,-0.194052));
    mesh.setVert(31, size * Point3(-0.191245,-0.101110,-0.333606));
    mesh.setVert(32, size * Point3(-0.000610,-0.101110,-0.384687));
    mesh.setVert(33, size * Point3(0.190024,-0.101110,-0.333607));
    mesh.setVert(34, size * Point3(0.329579,-0.101110,-0.194053));
    mesh.setVert(35, size * Point3(-0.000610,-0.101110,-0.003418));
    mesh.setVert(36, size * Point3(-0.005238,0.234135,-0.003681));
    mesh.setVert(37, size * Point3(0.112614,0.234135,-0.003681));
    mesh.setVert(38, size * Point3(0.096824,0.234135,0.055245));
    mesh.setVert(39, size * Point3(0.053688,0.234135,0.098381));
    mesh.setVert(40, size * Point3(-0.005238,0.234135,0.114171));
    mesh.setVert(41, size * Point3(-0.064163,0.234135,0.098381));
    mesh.setVert(42, size * Point3(-0.107300,0.234135,0.055245));
    mesh.setVert(43, size * Point3(-0.123089,0.234135,-0.003681));
    mesh.setVert(44, size * Point3(-0.107300,0.234135,-0.062606));
    mesh.setVert(45, size * Point3(-0.064163,0.234135,-0.105743));
    mesh.setVert(46, size * Point3(-0.005238,0.234135,-0.121532));
    mesh.setVert(47, size * Point3(0.053688,0.234135,-0.105743));
    mesh.setVert(48, size * Point3(0.096824,0.234135,-0.062606));
    mesh.setVert(49, size * Point3(0.112614,0.151639,-0.003681));
    mesh.setVert(50, size * Point3(0.096824,0.151639,0.055245));
    mesh.setVert(51, size * Point3(0.053688,0.151639,0.098381));
    mesh.setVert(52, size * Point3(-0.005238,0.151639,0.114171));
    mesh.setVert(53, size * Point3(-0.064163,0.151639,0.098381));
    mesh.setVert(54, size * Point3(-0.107300,0.151639,0.055245));
    mesh.setVert(55, size * Point3(-0.123089,0.151639,-0.003681));
    mesh.setVert(56, size * Point3(-0.107300,0.151639,-0.062606));
    mesh.setVert(57, size * Point3(-0.064163,0.151639,-0.105743));
    mesh.setVert(58, size * Point3(-0.005238,0.151639,-0.121532));
    mesh.setVert(59, size * Point3(0.053688,0.151639,-0.105743));
    mesh.setVert(60, size * Point3(0.096824,0.151639,-0.062606));
    mesh.setVert(61, size * Point3(-0.005238,0.151639,-0.003681));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(12,10,11);
    mesh.faces[13].setEdgeVisFlags(0,0,1);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(13,10,12);
    mesh.faces[14].setEdgeVisFlags(0,0,1);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(14,10,13);
    mesh.faces[15].setEdgeVisFlags(0,0,1);
    mesh.faces[15].setSmGroup(1);
    mesh.faces[16].setVerts(15,10,14);
    mesh.faces[16].setEdgeVisFlags(0,0,1);
    mesh.faces[16].setSmGroup(1);
    mesh.faces[17].setVerts(16,10,15);
    mesh.faces[17].setEdgeVisFlags(0,0,1);
    mesh.faces[17].setSmGroup(1);
    mesh.faces[18].setVerts(17,10,16);
    mesh.faces[18].setEdgeVisFlags(0,0,1);
    mesh.faces[18].setSmGroup(1);
    mesh.faces[19].setVerts(18,10,17);
    mesh.faces[19].setEdgeVisFlags(0,0,1);
    mesh.faces[19].setSmGroup(1);
    mesh.faces[20].setVerts(19,10,18);
    mesh.faces[20].setEdgeVisFlags(0,0,1);
    mesh.faces[20].setSmGroup(1);
    mesh.faces[21].setVerts(20,10,19);
    mesh.faces[21].setEdgeVisFlags(0,0,1);
    mesh.faces[21].setSmGroup(1);
    mesh.faces[22].setVerts(21,10,20);
    mesh.faces[22].setEdgeVisFlags(0,0,1);
    mesh.faces[22].setSmGroup(1);
    mesh.faces[23].setVerts(22,10,21);
    mesh.faces[23].setEdgeVisFlags(0,0,1);
    mesh.faces[23].setSmGroup(1);
    mesh.faces[24].setVerts(11,10,22);
    mesh.faces[24].setEdgeVisFlags(0,0,1);
    mesh.faces[24].setSmGroup(1);
    mesh.faces[25].setVerts(24,11,23);
    mesh.faces[25].setEdgeVisFlags(0,1,1);
    mesh.faces[25].setSmGroup(8);
    mesh.faces[26].setVerts(12,11,24);
    mesh.faces[26].setEdgeVisFlags(1,0,1);
    mesh.faces[26].setSmGroup(8);
    mesh.faces[27].setVerts(25,12,24);
    mesh.faces[27].setEdgeVisFlags(0,1,1);
    mesh.faces[27].setSmGroup(8);
    mesh.faces[28].setVerts(13,12,25);
    mesh.faces[28].setEdgeVisFlags(1,0,1);
    mesh.faces[28].setSmGroup(8);
    mesh.faces[29].setVerts(26,13,25);
    mesh.faces[29].setEdgeVisFlags(0,1,1);
    mesh.faces[29].setSmGroup(8);
    mesh.faces[30].setVerts(14,13,26);
    mesh.faces[30].setEdgeVisFlags(1,0,1);
    mesh.faces[30].setSmGroup(8);
    mesh.faces[31].setVerts(27,14,26);
    mesh.faces[31].setEdgeVisFlags(0,1,1);
    mesh.faces[31].setSmGroup(8);
    mesh.faces[32].setVerts(15,14,27);
    mesh.faces[32].setEdgeVisFlags(1,0,1);
    mesh.faces[32].setSmGroup(8);
    mesh.faces[33].setVerts(28,15,27);
    mesh.faces[33].setEdgeVisFlags(0,1,1);
    mesh.faces[33].setSmGroup(8);
    mesh.faces[34].setVerts(16,15,28);
    mesh.faces[34].setEdgeVisFlags(1,0,1);
    mesh.faces[34].setSmGroup(8);
    mesh.faces[35].setVerts(29,16,28);
    mesh.faces[35].setEdgeVisFlags(0,1,1);
    mesh.faces[35].setSmGroup(8);
    mesh.faces[36].setVerts(17,16,29);
    mesh.faces[36].setEdgeVisFlags(1,0,1);
    mesh.faces[36].setSmGroup(8);
    mesh.faces[37].setVerts(30,17,29);
    mesh.faces[37].setEdgeVisFlags(0,1,1);
    mesh.faces[37].setSmGroup(8);
    mesh.faces[38].setVerts(18,17,30);
    mesh.faces[38].setEdgeVisFlags(1,0,1);
    mesh.faces[38].setSmGroup(8);
    mesh.faces[39].setVerts(31,18,30);
    mesh.faces[39].setEdgeVisFlags(0,1,1);
    mesh.faces[39].setSmGroup(8);
    mesh.faces[40].setVerts(19,18,31);
    mesh.faces[40].setEdgeVisFlags(1,0,1);
    mesh.faces[40].setSmGroup(8);
    mesh.faces[41].setVerts(32,19,31);
    mesh.faces[41].setEdgeVisFlags(0,1,1);
    mesh.faces[41].setSmGroup(8);
    mesh.faces[42].setVerts(20,19,32);
    mesh.faces[42].setEdgeVisFlags(1,0,1);
    mesh.faces[42].setSmGroup(8);
    mesh.faces[43].setVerts(33,20,32);
    mesh.faces[43].setEdgeVisFlags(0,1,1);
    mesh.faces[43].setSmGroup(8);
    mesh.faces[44].setVerts(21,20,33);
    mesh.faces[44].setEdgeVisFlags(1,0,1);
    mesh.faces[44].setSmGroup(8);
    mesh.faces[45].setVerts(34,21,33);
    mesh.faces[45].setEdgeVisFlags(0,1,1);
    mesh.faces[45].setSmGroup(8);
    mesh.faces[46].setVerts(22,21,34);
    mesh.faces[46].setEdgeVisFlags(1,0,1);
    mesh.faces[46].setSmGroup(8);
    mesh.faces[47].setVerts(23,22,34);
    mesh.faces[47].setEdgeVisFlags(0,1,1);
    mesh.faces[47].setSmGroup(8);
    mesh.faces[48].setVerts(11,22,23);
    mesh.faces[48].setEdgeVisFlags(1,0,1);
    mesh.faces[48].setSmGroup(8);
    mesh.faces[49].setVerts(23,35,24);
    mesh.faces[49].setEdgeVisFlags(0,0,1);
    mesh.faces[49].setSmGroup(1);
    mesh.faces[50].setVerts(24,35,25);
    mesh.faces[50].setEdgeVisFlags(0,0,1);
    mesh.faces[50].setSmGroup(1);
    mesh.faces[51].setVerts(25,35,26);
    mesh.faces[51].setEdgeVisFlags(0,0,1);
    mesh.faces[51].setSmGroup(1);
    mesh.faces[52].setVerts(26,35,27);
    mesh.faces[52].setEdgeVisFlags(0,0,1);
    mesh.faces[52].setSmGroup(1);
    mesh.faces[53].setVerts(27,35,28);
    mesh.faces[53].setEdgeVisFlags(0,0,1);
    mesh.faces[53].setSmGroup(1);
    mesh.faces[54].setVerts(28,35,29);
    mesh.faces[54].setEdgeVisFlags(0,0,1);
    mesh.faces[54].setSmGroup(1);
    mesh.faces[55].setVerts(29,35,30);
    mesh.faces[55].setEdgeVisFlags(0,0,1);
    mesh.faces[55].setSmGroup(1);
    mesh.faces[56].setVerts(30,35,31);
    mesh.faces[56].setEdgeVisFlags(0,0,1);
    mesh.faces[56].setSmGroup(1);
    mesh.faces[57].setVerts(31,35,32);
    mesh.faces[57].setEdgeVisFlags(0,0,1);
    mesh.faces[57].setSmGroup(1);
    mesh.faces[58].setVerts(32,35,33);
    mesh.faces[58].setEdgeVisFlags(0,0,1);
    mesh.faces[58].setSmGroup(1);
    mesh.faces[59].setVerts(33,35,34);
    mesh.faces[59].setEdgeVisFlags(0,0,1);
    mesh.faces[59].setSmGroup(1);
    mesh.faces[60].setVerts(34,35,23);
    mesh.faces[60].setEdgeVisFlags(0,0,1);
    mesh.faces[60].setSmGroup(1);
    mesh.faces[61].setVerts(36,38,37);
    mesh.faces[61].setEdgeVisFlags(0,1,0);
    mesh.faces[61].setSmGroup(1);
    mesh.faces[62].setVerts(36,39,38);
    mesh.faces[62].setEdgeVisFlags(0,1,0);
    mesh.faces[62].setSmGroup(1);
    mesh.faces[63].setVerts(36,40,39);
    mesh.faces[63].setEdgeVisFlags(0,1,0);
    mesh.faces[63].setSmGroup(1);
    mesh.faces[64].setVerts(36,41,40);
    mesh.faces[64].setEdgeVisFlags(0,1,0);
    mesh.faces[64].setSmGroup(1);
    mesh.faces[65].setVerts(36,42,41);
    mesh.faces[65].setEdgeVisFlags(0,1,0);
    mesh.faces[65].setSmGroup(1);
    mesh.faces[66].setVerts(36,43,42);
    mesh.faces[66].setEdgeVisFlags(0,1,0);
    mesh.faces[66].setSmGroup(1);
    mesh.faces[67].setVerts(36,44,43);
    mesh.faces[67].setEdgeVisFlags(0,1,0);
    mesh.faces[67].setSmGroup(1);
    mesh.faces[68].setVerts(36,45,44);
    mesh.faces[68].setEdgeVisFlags(0,1,0);
    mesh.faces[68].setSmGroup(1);
    mesh.faces[69].setVerts(36,46,45);
    mesh.faces[69].setEdgeVisFlags(0,1,0);
    mesh.faces[69].setSmGroup(1);
    mesh.faces[70].setVerts(36,47,46);
    mesh.faces[70].setEdgeVisFlags(0,1,0);
    mesh.faces[70].setSmGroup(1);
    mesh.faces[71].setVerts(36,48,47);
    mesh.faces[71].setEdgeVisFlags(0,1,0);
    mesh.faces[71].setSmGroup(1);
    mesh.faces[72].setVerts(36,37,48);
    mesh.faces[72].setEdgeVisFlags(0,1,0);
    mesh.faces[72].setSmGroup(1);
    mesh.faces[73].setVerts(37,50,49);
    mesh.faces[73].setEdgeVisFlags(0,1,1);
    mesh.faces[73].setSmGroup(8);
    mesh.faces[74].setVerts(37,38,50);
    mesh.faces[74].setEdgeVisFlags(1,1,0);
    mesh.faces[74].setSmGroup(8);
    mesh.faces[75].setVerts(38,51,50);
    mesh.faces[75].setEdgeVisFlags(0,1,1);
    mesh.faces[75].setSmGroup(8);
    mesh.faces[76].setVerts(38,39,51);
    mesh.faces[76].setEdgeVisFlags(1,1,0);
    mesh.faces[76].setSmGroup(8);
    mesh.faces[77].setVerts(39,52,51);
    mesh.faces[77].setEdgeVisFlags(0,1,1);
    mesh.faces[77].setSmGroup(8);
    mesh.faces[78].setVerts(39,40,52);
    mesh.faces[78].setEdgeVisFlags(1,1,0);
    mesh.faces[78].setSmGroup(8);
    mesh.faces[79].setVerts(40,53,52);
    mesh.faces[79].setEdgeVisFlags(0,1,1);
    mesh.faces[79].setSmGroup(8);
    mesh.faces[80].setVerts(40,41,53);
    mesh.faces[80].setEdgeVisFlags(1,1,0);
    mesh.faces[80].setSmGroup(8);
    mesh.faces[81].setVerts(41,54,53);
    mesh.faces[81].setEdgeVisFlags(0,1,1);
    mesh.faces[81].setSmGroup(8);
    mesh.faces[82].setVerts(41,42,54);
    mesh.faces[82].setEdgeVisFlags(1,1,0);
    mesh.faces[82].setSmGroup(8);
    mesh.faces[83].setVerts(42,55,54);
    mesh.faces[83].setEdgeVisFlags(0,1,1);
    mesh.faces[83].setSmGroup(8);
    mesh.faces[84].setVerts(42,43,55);
    mesh.faces[84].setEdgeVisFlags(1,1,0);
    mesh.faces[84].setSmGroup(8);
    mesh.faces[85].setVerts(43,56,55);
    mesh.faces[85].setEdgeVisFlags(0,1,1);
    mesh.faces[85].setSmGroup(8);
    mesh.faces[86].setVerts(43,44,56);
    mesh.faces[86].setEdgeVisFlags(1,1,0);
    mesh.faces[86].setSmGroup(8);
    mesh.faces[87].setVerts(44,57,56);
    mesh.faces[87].setEdgeVisFlags(0,1,1);
    mesh.faces[87].setSmGroup(8);
    mesh.faces[88].setVerts(44,45,57);
    mesh.faces[88].setEdgeVisFlags(1,1,0);
    mesh.faces[88].setSmGroup(8);
    mesh.faces[89].setVerts(45,58,57);
    mesh.faces[89].setEdgeVisFlags(0,1,1);
    mesh.faces[89].setSmGroup(8);
    mesh.faces[90].setVerts(45,46,58);
    mesh.faces[90].setEdgeVisFlags(1,1,0);
    mesh.faces[90].setSmGroup(8);
    mesh.faces[91].setVerts(46,59,58);
    mesh.faces[91].setEdgeVisFlags(0,1,1);
    mesh.faces[91].setSmGroup(8);
    mesh.faces[92].setVerts(46,47,59);
    mesh.faces[92].setEdgeVisFlags(1,1,0);
    mesh.faces[92].setSmGroup(8);
    mesh.faces[93].setVerts(47,60,59);
    mesh.faces[93].setEdgeVisFlags(0,1,1);
    mesh.faces[93].setSmGroup(8);
    mesh.faces[94].setVerts(47,48,60);
    mesh.faces[94].setEdgeVisFlags(1,1,0);
    mesh.faces[94].setSmGroup(8);
    mesh.faces[95].setVerts(48,49,60);
    mesh.faces[95].setEdgeVisFlags(0,1,1);
    mesh.faces[95].setSmGroup(8);
    mesh.faces[96].setVerts(48,37,49);
    mesh.faces[96].setEdgeVisFlags(1,1,0);
    mesh.faces[96].setSmGroup(8);
    mesh.faces[97].setVerts(61,49,50);
    mesh.faces[97].setEdgeVisFlags(0,1,0);
    mesh.faces[97].setSmGroup(1);
    mesh.faces[98].setVerts(61,50,51);
    mesh.faces[98].setEdgeVisFlags(0,1,0);
    mesh.faces[98].setSmGroup(1);
    mesh.faces[99].setVerts(61,51,52);
    mesh.faces[99].setEdgeVisFlags(0,1,0);
    mesh.faces[99].setSmGroup(1);
    mesh.faces[100].setVerts(61,52,53);
    mesh.faces[100].setEdgeVisFlags(0,1,0);
    mesh.faces[100].setSmGroup(1);
    mesh.faces[101].setVerts(61,53,54);
    mesh.faces[101].setEdgeVisFlags(0,1,0);
    mesh.faces[101].setSmGroup(1);
    mesh.faces[102].setVerts(61,54,55);
    mesh.faces[102].setEdgeVisFlags(0,1,0);
    mesh.faces[102].setSmGroup(1);
    mesh.faces[103].setVerts(61,55,56);
    mesh.faces[103].setEdgeVisFlags(0,1,0);
    mesh.faces[103].setSmGroup(1);
    mesh.faces[104].setVerts(61,56,57);
    mesh.faces[104].setEdgeVisFlags(0,1,0);
    mesh.faces[104].setSmGroup(1);
    mesh.faces[105].setVerts(61,57,58);
    mesh.faces[105].setEdgeVisFlags(0,1,0);
    mesh.faces[105].setSmGroup(1);
    mesh.faces[106].setVerts(61,58,59);
    mesh.faces[106].setEdgeVisFlags(0,1,0);
    mesh.faces[106].setSmGroup(1);
    mesh.faces[107].setVerts(61,59,60);
    mesh.faces[107].setEdgeVisFlags(0,1,0);
    mesh.faces[107].setSmGroup(1);
    mesh.faces[108].setVerts(61,60,49);
    mesh.faces[108].setEdgeVisFlags(0,1,0);
    mesh.faces[108].setSmGroup(1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\ViewFile\viewfile.cpp ===
//-----------------------------------------------------------------------------
// -----------------------
// File	....:	ViewFile.cpp
// -----------------------
// Author...:	Gus J	Grubba
// Date	....:	September 1995
// O.S.	....:	Windows NT 3.51
//
// History	.:	Nov, 02 1995 -	Created
//
// This	is	the "View File" option in MAX's File menu.
//
//-----------------------------------------------------------------------------

#include <Max.h>
#include "bmmlib.h"
#include "resource.h"

#define	 VWFEXPORT __declspec( dllexport	)
#include "ViewFile.h"

//--	Globals ------------------------------------------------------------------

HINSTANCE hInst = NULL;

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//--	DLL Declaration

BOOL	WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)	{
	switch (fdwReason) {
		 case	DLL_PROCESS_ATTACH:
				if	(hInst)
					return(FALSE);
				hInst	= hDLLInst;
				break;
		 case	DLL_PROCESS_DETACH:
				hInst	 =	NULL;
				break;
		 case	DLL_THREAD_ATTACH:
				break;
		 case	DLL_THREAD_DETACH:
				break;
	}
	return TRUE;
}

//-----------------------------------------------------------------------------
// Interface

VWFEXPORT void *ViewFileCreate	( ) {	
	return new ViewFile;
}	 

VWFEXPORT void  ViewFileDestroy	( ViewFile *v ) {	
	if	(v)
		delete v;
}	 

//-----------------------------------------------------------------------------
// #> ViewFile::ViewFile()
//

ViewFile::ViewFile() {
	hWnd		 =	NULL;
}

//-----------------------------------------------------------------------------
// #> ViewFile::~ViewFile()
//

ViewFile::~ViewFile() {


}

//-----------------------------------------------------------------------------
// #> ViewFile::View()
//

void	ViewFile::View( HWND	hWnd ) {
	
	int idx;
	DWORD caps;
	BitmapInfo bi;
	Bitmap *map = NULL;
	TCHAR buf[256];

	LoadString(hInst, IDS_DB_VIEW_FILE, buf, sizeof(buf));
	
	if (!TheManager->SelectFileInputEx(&bi, hWnd, buf, TRUE))
	   return;

	if	(bi.Name()[0])
		idx = TheManager->ioList.ResolveDevice(&bi);
	else
		idx = TheManager->ioList.FindDevice(bi.Device());

	if (idx == -1)
		goto error;

	caps = TheManager->ioList.GetDeviceCapabilities(bi.Device());
	TCHAR title[MAX_PATH];

	if	(caps & BMMIO_EXTENSION)
		_tcscpy(title,bi.Filename());
	else
		_tcscpy(title,bi.Device());

	if	(caps & BMMIO_OWN_VIEWER) {
		BitmapIO	*IO =	TheManager->ioList.CreateDevInstance(bi.Device());
		if(IO) {
			BOOL succeeded = IO->ShowImage(hWnd,&bi);
			delete IO;
			if(!succeeded)
				goto normal_view;
		}
	} else {
		normal_view:
		SetCursor(LoadCursor(NULL,IDC_WAIT));
		map = TheManager->Load(&bi);
		if	(map)	{
			map->Display(title, BMM_CN, TRUE, FALSE);
		} else {
			error:
			TCHAR text[128];
			TCHAR tmp[128];
			LoadString(hInst, IDS_DB_NO_VIEW, tmp, sizeof(tmp));
			wsprintf(text,tmp,bi.Name());
			LoadString(hInst, IDS_DB_VIEW_ERROR, tmp, sizeof(tmp));
			MessageBox(hWnd,text,tmp,MB_OK);
		}
		SetCursor(LoadCursor(NULL,IDC_ARROW));
	}
	
}

//--	EOF: ViewFile.cpp	--------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\anchor.h ===
/**********************************************************************
 *<
    FILE: anchor.h
 
    DESCRIPTION:  Defines a VRML 2.0 Anchor helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 17 Sept. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __Anchor__H__
 
#define __Anchor__H__
 
#define Anchor_CLASS_ID1 0x7ef53442
#define Anchor_CLASS_ID2 0xF002Bd37

#define AnchorClassID Class_ID(Anchor_CLASS_ID1, Anchor_CLASS_ID2)

extern ClassDesc* GetAnchorDesc();

class AnchorCreateCallBack;

class AnchorObject: public HelperObject {			   
    friend class AnchorCreateCallBack;
    friend class AnchorObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;

    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    CommandMode *previousMode;

    static ICustButton *AnchorPickButton;
    static ICustButton *ParentPickButton;

    IParamBlock *pblock;
    static IParamMap *pmapParam;

    INode* triggerObject;
    INode* cameraObject;
    TSTR description, URL, parameter;
    BOOL isJump;

    AnchorObject();
    ~AnchorObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
           void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_ANCHOR)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_ANCHOR)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
           void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(Anchor_CLASS_ID1,
                                         Anchor_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_ANCHOR_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 3;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

    IOResult Load(ILoad *iload) ;
    IOResult Save(ISave *iload) ;

};				

#define PB_AN_SIZE          0
#define PB_AN_TYPE          1
#define PB_AN_LENGTH        2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\anchor.cpp ===
/**********************************************************************
 *<
    FILE: anchor.cpp

    DESCRIPTION:  A VRML Anchor helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 17 Sept, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "anchor.h"
#include "bookmark.h"

//------------------------------------------------------

class AnchorClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new AnchorObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_ANCHOR_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(Anchor_CLASS_ID1,
                                                    Anchor_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static AnchorClassDesc AnchorDesc;

ClassDesc* GetAnchorDesc() { return &AnchorDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ICustButton *AnchorObject::ParentPickButton = NULL;

HWND AnchorObject::hRollup = NULL;
int AnchorObject::dlgPrevSel = -1;

class TriggerPick : public PickModeCallback {
    AnchorObject *parent;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetAnchor(AnchorObject *l) { parent = l; }
};

//static TriggerPick theParentPick;
static  TriggerPick     thePick;
static  BOOL            pickMode    = FALSE;
static  CommandMode*    lastMode    = NULL;

static void
SetPickMode(AnchorObject* o) {
    if (pickMode || !o) {
        pickMode = FALSE;
        GetCOREInterface()->PushCommandMode(lastMode);
        lastMode = NULL;
        GetCOREInterface()->ClearPickMode();
    } else {
        pickMode = TRUE;
        lastMode = GetCOREInterface()->GetCommandMode();
        thePick.SetAnchor(o);
        GetCOREInterface()->SetPickMode(&thePick);
    }
}

BOOL
TriggerPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(Anchor_CLASS_ID1, Anchor_CLASS_ID2)))
        return FALSE;
    return TRUE;
}

void
TriggerPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(_T(GetString(IDS_PICK_TRIGGER)));
}

void
TriggerPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
TriggerPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        RefResult ret = parent->ReplaceReference(1, node);

        SetPickMode(NULL);
        //parent->iObjParams->SetCommandMode(parent->previousMode);
        //parent->previousMode = NULL;
        parent->ParentPickButton->SetCheck(FALSE);
        HWND hw = parent->hRollup;
        Static_SetText(GetDlgItem(hw,IDC_TRIGGER_OBJ),
                       parent->triggerObject->GetName());
        return FALSE;
    }
    return FALSE;
}


HCURSOR
TriggerPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

static void
GetCameras(INode *inode, Tab<INode*> *list)
{
    const ObjectState& os = inode->EvalWorldState(0);
    Object* ob = os.obj;
    if (ob != NULL) {
        if (ob->SuperClassID() == CAMERA_CLASS_ID) {
            list->Append(1, &inode);
        }
    }
    int count = inode->NumberOfChildren();
    for (int i = 0; i < count; i++)
        GetCameras(inode->GetChildNode( i), list);
}

BOOL CALLBACK
AnchorDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam,
               AnchorObject* th)
{
    TCHAR text[MAX_PATH];
    int c, camIndex, i, type;
    HWND cb;
    Tab<INode*> cameras;

    switch ( message ) {
    case WM_INITDIALOG:

        th->ParentPickButton = GetICustButton(GetDlgItem(hDlg,
                                                  IDC_PICK_PARENT));
        th->ParentPickButton->SetType(CBT_CHECK);
        th->ParentPickButton->SetButtonDownNotify(TRUE);
        th->ParentPickButton->SetHighlightColor(GREEN_WASH);
        th->ParentPickButton->SetCheck(FALSE);

        th->dlgPrevSel = -1;
        th->hRollup = hDlg;
        if (th->triggerObject)
            Static_SetText(GetDlgItem(hDlg,IDC_TRIGGER_OBJ),
                           th->triggerObject->GetName());
        th->pblock->GetValue(PB_AN_TYPE, th->iObjParams->GetTime(),
                             type, FOREVER);
        th->isJump = type == 0;
        EnableWindow(GetDlgItem(hDlg, IDC_ANCHOR_URL), th->isJump);
        EnableWindow(GetDlgItem(hDlg, IDC_PARAMETER), th->isJump);
        EnableWindow(GetDlgItem(hDlg, IDC_BOOKMARKS), th->isJump);
        EnableWindow(GetDlgItem(hDlg, IDC_CAMERA), !th->isJump);
        GetCameras(th->iObjParams->GetRootNode(), &cameras);
        c = cameras.Count();
        cb = GetDlgItem(hDlg, IDC_CAMERA);
        camIndex = -1;
        for (i = 0; i < c; i++) {
            // add the name to the list
            TSTR name = cameras[i]->GetName();
            int ind = ComboBox_AddString(cb, name.data());
            ComboBox_SetItemData(cb, ind, cameras[i]);
            if (cameras[i] == th->cameraObject)
                camIndex = i;
            
        }
        if (camIndex != -1)
            ComboBox_SelectString(cb, 0, cameras[camIndex]->GetName());

        Edit_SetText(GetDlgItem(hDlg, IDC_DESC), th->description.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_ANCHOR_URL), th->URL.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_PARAMETER), th->parameter.data());

        if (pickMode) SetPickMode(th);

        return TRUE;			

    case WM_DESTROY:

        if (pickMode) SetPickMode(th);
        //th->iObjParams->ClearPickMode();
        //th->previousMode = NULL;
        ReleaseICustButton( th->ParentPickButton );
        return FALSE;

    case WM_MOUSEACTIVATE:
        return FALSE;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        return FALSE;

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_BOOKMARKS: {
            // do bookmarks
            TSTR url, cam, desc;
            if (GetBookmarkURL(th->iObjParams, &url, &cam, &desc)) {
                // get the new URL information;
                Edit_SetText(GetDlgItem(hDlg,IDC_ANCHOR_URL), url.data());
                Edit_SetText(GetDlgItem(hDlg,IDC_DESC), desc.data());
            } }
            break;
        case IDC_CAMERA:
            if (HIWORD(wParam) == CBN_SELCHANGE) {
                cb = GetDlgItem(hDlg, IDC_CAMERA);
                int sel = ComboBox_GetCurSel(cb);
                INode *rtarg;
                rtarg = (INode*) ComboBox_GetItemData(cb, sel);
                th->ReplaceReference(2, rtarg);
            }
            break;
        case IDC_HYPERLINK:
            th->isJump = IsDlgButtonChecked(hDlg, IDC_HYPERLINK);
            EnableWindow(GetDlgItem(hDlg, IDC_ANCHOR_URL), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_PARAMETER), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_BOOKMARKS), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_CAMERA), !th->isJump);
            break;
        case IDC_SET_CAMERA:
            th->isJump = !IsDlgButtonChecked(hDlg, IDC_SET_CAMERA);
            EnableWindow(GetDlgItem(hDlg, IDC_ANCHOR_URL), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_PARAMETER), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_BOOKMARKS), th->isJump);
            EnableWindow(GetDlgItem(hDlg, IDC_CAMERA), !th->isJump);
            break;
        case IDC_PICK_PARENT: // Pick an object from the scene
            // Set the pickmode...
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                SetPickMode(th);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    theParentPick.SetAnchor(th);
                    th->iObjParams->SetPickMode(&theParentPick);
                }
                */
                break;
            }
            return TRUE;
        case IDC_ANCHOR_URL:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_ANCHOR_URL),
                             text, MAX_PATH);
                th->URL = text;
            }
            break;
        case IDC_DESC:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_DESC),
                             text, MAX_PATH);
                th->description = text;
            }
            break;
        case IDC_PARAMETER:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_PARAMETER),
                             text, MAX_PATH);
                th->parameter = text;
            }
            break;
    default:
        return FALSE;
        }
    }
    return FALSE;
}

static int buttonIds[] = {IDC_HYPERLINK, IDC_SET_CAMERA};

static ParamUIDesc descParam[] = {
  // Size
  ParamUIDesc(
              PB_AN_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_SIZE_EDIT, IDC_SIZE_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Type
  ParamUIDesc(PB_AN_TYPE, TYPE_RADIO, buttonIds, 2),
};

#define PARAMDESC_LENGTH 2

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
};


//static ParamVersionDesc versions[] = {
//  ParamVersionDesc(descVer0,5,0),
//};

//#define NUM_OLD_VERSIONS 1

#define CURRENT_VERSION	0
// Current version
static ParamVersionDesc curVersion(descVer0, PB_AN_LENGTH, CURRENT_VERSION);

class AnchorParamDlgProc : public ParamMapUserDlgProc {
public:
  AnchorObject *ob;

  AnchorParamDlgProc(AnchorObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL AnchorParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return AnchorDlgProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *AnchorObject::pmapParam = NULL;

void
AnchorObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                   Animatable *prev )
{
    iObjParams = ip;
    if (pmapParam) {
        // Left over from last TouchSensor created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_ANCHOR),
                                     _T("Anchor"),
                                     0);
    }
    
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new AnchorParamDlgProc(this));
    }
}
		
void
AnchorObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

AnchorObject::AnchorObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_AN_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_AN_TYPE, 0, 0);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    previousMode = NULL;
    triggerObject = NULL;
    cameraObject = NULL;
    isJump = TRUE;
}

AnchorObject::~AnchorObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *AnchorObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
AnchorObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
    switch (message) {
    case REFMSG_TARGET_DELETED:
        if (hTarget == triggerObject)
            triggerObject = NULL;
        if (hTarget == cameraObject)
            cameraObject = NULL;
        break;
    }
    return REF_SUCCEED;
}

RefTargetHandle
AnchorObject::GetReference(int ind)
{
    if (ind == 0)
        return pblock;
    if (ind == 1)
        return triggerObject;
    if (ind == 2)
        return cameraObject;
    return NULL;
}

void
AnchorObject::SetReference(int ind, RefTargetHandle rtarg)
{
    if (ind == 0) {
        pblock = (IParamBlock*) rtarg;
        return;
    }
    if (ind == 1) {
        triggerObject = (INode*) rtarg;
        return;
    }
    if (ind == 2) {
        cameraObject = (INode*) rtarg;
        return;
    }
    return;
}

ObjectState
AnchorObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
AnchorObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
AnchorObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
AnchorObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    BuildMesh(t);
    box = mesh.getBoundingBox();

}

void
AnchorObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
AnchorObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_AN_SIZE, t, size, FOREVER);
#include "anchorob.cpp"
}

int
AnchorObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_AN_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.4f, 0.0f, 0.6f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
AnchorObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class AnchorCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    AnchorObject *anchorObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(AnchorObject *obj) {anchorObject = obj;}

};

			
int
AnchorCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            anchorObject->pblock->SetValue(PB_AN_SIZE,
                                               anchorObject->
                                               iObjParams->GetTime(), radius);
            anchorObject->pmapParam->Invalidate();
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(anchorObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static AnchorCreateCallBack AnchorCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
AnchorObject::GetCreateMouseCallBack() 
{
    AnchorCreateCB.SetObj(this);
    return(&AnchorCreateCB);
}

#define DESC_CHUNK		0xad30
#define URL_CHUNK		0xad31
#define PARAM_CHUNK		0xad32

IOResult 
AnchorObject::Save(ISave *isave)
{
    isave->BeginChunk(DESC_CHUNK);
    isave->WriteCString(description.data());
    isave->EndChunk();

    isave->BeginChunk(URL_CHUNK);
    isave->WriteCString(URL.data());
    isave->EndChunk();

    isave->BeginChunk(PARAM_CHUNK);
    isave->WriteCString(parameter.data());
    isave->EndChunk();

    return IO_OK;
}

IOResult
AnchorObject::Load(ILoad *iload)
{
    TCHAR* txt;

    while (iload->OpenChunk() == IO_OK) {
        switch(iload->CurChunkID()) {
        case DESC_CHUNK:
            iload->ReadCStringChunk(&txt);
            description = txt;
            break;
            
        case URL_CHUNK:
            iload->ReadCStringChunk(&txt);
            URL = txt;
            break;
            
        case PARAM_CHUNK:
            iload->ReadCStringChunk(&txt);
            parameter = txt;
            break;
            
        default:
            break;
        }
        iload->CloseChunk();
    }
    return IO_OK;
}

            
RefTargetHandle
AnchorObject::Clone(RemapDir& remap)
{
    AnchorObject* ts = new AnchorObject();
    ts->ReplaceReference(0, pblock->Clone(remap));
    ts->ReplaceReference(1, triggerObject);
    ts->ReplaceReference(2, cameraObject);
    ts->description = description;
    ts->URL = URL;
    ts->parameter = parameter;
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\appd.h ===
// Appdata functions

// Our APP data chunk IDs
#define NORMALS_ID            0
#define INDENT_ID             1
#define FIELDS_ID             2
#define OUTPUT_LANG_ID        3
#define USE_PREFIX_ID         4
#define URL_PREFIX_ID         5
#define CAMERA_ID             6
#define MAX_POLYS_ID          7
#define MAX_SELECTED_ID       8
#define UPDIR_ID              9
#define DIGITS_ID            10
#define COORD_INTERP_ID      11
#define TFORM_SAMPLE_ID      12
#define COORD_SAMPLE_ID      13
#define TFORM_SAMPLE_RATE_ID 14
#define COORD_SAMPLE_RATE_ID 15
#define NAV_INFO_ID          16
#define TITLE_ID             17
#define INFO_ID              18
#define EXPORT_HIDDEN_ID     19
#define PRIMITIVES_ID        20
#define BACKGROUND_ID        21
#define FOG_ID               22
#define TOUCH_ID             23
#define ANCHOR_ID               24
#define POLYGON_TYPE_ID		    25
#define ENABLE_PROGRESS_BAR_ID  26
#define EXPORT_PRE_LIGHT_ID     27
#define FLIP_BOOK_ID            28
#define FLIPBOOK_SAMPLE_ID      29
#define FLIPBOOK_SAMPLE_RATE_ID 30
#define CPV_SOURCE_ID           31

extern void WriteAppData(Interface* ip, int id, TCHAR* val);
extern void GetAppData(Interface * ip, int id, TCHAR* def,
                       TCHAR* val, int len);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\anchorob.cpp ===
mesh.setNumVerts(86);
    mesh.setNumFaces(133);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669280));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.067799,0.004578,0.179988));
    mesh.setVert(11, size * Point3(-0.067799,0.004578,0.158638));
    mesh.setVert(12, size * Point3(-0.067799,0.023067,0.190663));
    mesh.setVert(13, size * Point3(-0.067799,-0.013912,0.190663));
    mesh.setVert(14, size * Point3(0.060300,0.004578,0.158638));
    mesh.setVert(15, size * Point3(0.060300,0.023067,0.190663));
    mesh.setVert(16, size * Point3(0.060300,-0.013912,0.190663));
    mesh.setVert(17, size * Point3(0.060300,0.004578,0.179988));
    mesh.setVert(18, size * Point3(0.071282,0.004578,0.159154));
    mesh.setVert(19, size * Point3(0.092632,0.004578,0.159154));
    mesh.setVert(20, size * Point3(0.060607,0.023067,0.159154));
    mesh.setVert(21, size * Point3(0.060607,-0.013912,0.159154));
    mesh.setVert(22, size * Point3(0.092632,0.004578,0.287253));
    mesh.setVert(23, size * Point3(0.060607,0.023067,0.287253));
    mesh.setVert(24, size * Point3(0.060607,-0.013912,0.287253));
    mesh.setVert(25, size * Point3(0.071282,0.004578,0.287253));
    mesh.setVert(26, size * Point3(-0.089926,0.004578,0.159154));
    mesh.setVert(27, size * Point3(-0.068576,0.004578,0.159154));
    mesh.setVert(28, size * Point3(-0.100601,0.023067,0.159154));
    mesh.setVert(29, size * Point3(-0.100601,-0.013912,0.159154));
    mesh.setVert(30, size * Point3(-0.068576,0.004578,0.287253));
    mesh.setVert(31, size * Point3(-0.100601,0.023067,0.287253));
    mesh.setVert(32, size * Point3(-0.100601,-0.013912,0.287253));
    mesh.setVert(33, size * Point3(-0.089926,0.004578,0.287253));
    mesh.setVert(34, size * Point3(-0.067799,0.004578,0.276507));
    mesh.setVert(35, size * Point3(-0.067799,0.004578,0.255158));
    mesh.setVert(36, size * Point3(-0.067799,0.023067,0.287182));
    mesh.setVert(37, size * Point3(-0.067799,-0.013912,0.287182));
    mesh.setVert(38, size * Point3(0.060300,0.004578,0.255158));
    mesh.setVert(39, size * Point3(0.060300,0.023067,0.287182));
    mesh.setVert(40, size * Point3(0.060300,-0.013912,0.287182));
    mesh.setVert(41, size * Point3(0.060300,0.004578,0.276507));
    mesh.setVert(42, size * Point3(-0.139594,0.000763,-0.317768));
    mesh.setVert(43, size * Point3(-0.162003,-0.024752,-0.363064));
    mesh.setVert(44, size * Point3(-0.162006,0.026279,-0.362958));
    mesh.setVert(45, size * Point3(0.131235,0.000763,-0.317768));
    mesh.setVert(46, size * Point3(0.151744,-0.024752,-0.362591));
    mesh.setVert(47, size * Point3(0.151751,0.026279,-0.362768));
    mesh.setVert(48, size * Point3(0.291033,0.002180,-0.141779));
    mesh.setVert(49, size * Point3(0.266898,0.002180,-0.124880));
    mesh.setVert(50, size * Point3(0.303100,-0.023335,-0.150228));
    mesh.setVert(51, size * Point3(0.303100,0.027696,-0.150228));
    mesh.setVert(52, size * Point3(-0.298223,0.002180,-0.141779));
    mesh.setVert(53, size * Point3(-0.274089,0.002180,-0.124880));
    mesh.setVert(54, size * Point3(-0.310290,-0.023335,-0.150228));
    mesh.setVert(55, size * Point3(-0.310290,0.027696,-0.150228));
    mesh.setVert(56, size * Point3(0.332890,0.001836,-0.068190));
    mesh.setVert(57, size * Point3(0.269500,0.002000,-0.114236));
    mesh.setVert(58, size * Point3(0.311302,0.002000,-0.143506));
    mesh.setVert(59, size * Point3(0.222103,0.137307,-0.226411));
    mesh.setVert(60, size * Point3(0.186662,0.101105,-0.232541));
    mesh.setVert(61, size * Point3(0.228464,0.101105,-0.261811));
    mesh.setVert(62, size * Point3(0.212410,0.113172,-0.240254));
    mesh.setVert(63, size * Point3(0.222190,-0.133634,-0.226286));
    mesh.setVert(64, size * Point3(0.186750,-0.097432,-0.232415));
    mesh.setVert(65, size * Point3(0.228552,-0.097432,-0.261686));
    mesh.setVert(66, size * Point3(0.212497,-0.109499,-0.240129));
    mesh.setVert(67, size * Point3(-0.340770,0.001836,-0.068190));
    mesh.setVert(68, size * Point3(-0.277380,0.002000,-0.114236));
    mesh.setVert(69, size * Point3(-0.319182,0.002000,-0.143506));
    mesh.setVert(70, size * Point3(-0.229983,0.137307,-0.226411));
    mesh.setVert(71, size * Point3(-0.194542,0.101105,-0.232541));
    mesh.setVert(72, size * Point3(-0.236344,0.101105,-0.261811));
    mesh.setVert(73, size * Point3(-0.220290,0.113172,-0.240254));
    mesh.setVert(74, size * Point3(-0.230070,-0.133634,-0.226286));
    mesh.setVert(75, size * Point3(-0.194630,-0.097432,-0.232415));
    mesh.setVert(76, size * Point3(-0.236432,-0.097432,-0.261686));
    mesh.setVert(77, size * Point3(-0.220377,-0.109499,-0.240129));
    mesh.setVert(78, size * Point3(-0.008097,0.004578,-0.314628));
    mesh.setVert(79, size * Point3(0.021366,0.004578,-0.314628));
    mesh.setVert(80, size * Point3(-0.022829,0.030093,-0.314628));
    mesh.setVert(81, size * Point3(-0.022829,-0.020938,-0.314628));
    mesh.setVert(82, size * Point3(0.021366,0.004578,0.156776));
    mesh.setVert(83, size * Point3(-0.022829,0.030093,0.156776));
    mesh.setVert(84, size * Point3(-0.022829,-0.020938,0.156776));
    mesh.setVert(85, size * Point3(-0.008097,0.004578,0.156776));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,12,11);
    mesh.faces[13].setEdgeVisFlags(0,1,0);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(10,13,12);
    mesh.faces[14].setEdgeVisFlags(0,1,0);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(10,11,13);
    mesh.faces[15].setEdgeVisFlags(0,1,0);
    mesh.faces[15].setSmGroup(1);
    mesh.faces[16].setVerts(11,15,14);
    mesh.faces[16].setEdgeVisFlags(0,1,1);
    mesh.faces[16].setSmGroup(8);
    mesh.faces[17].setVerts(11,12,15);
    mesh.faces[17].setEdgeVisFlags(1,1,0);
    mesh.faces[17].setSmGroup(8);
    mesh.faces[18].setVerts(12,16,15);
    mesh.faces[18].setEdgeVisFlags(0,1,1);
    mesh.faces[18].setSmGroup(8);
    mesh.faces[19].setVerts(12,13,16);
    mesh.faces[19].setEdgeVisFlags(1,1,0);
    mesh.faces[19].setSmGroup(8);
    mesh.faces[20].setVerts(13,14,16);
    mesh.faces[20].setEdgeVisFlags(0,1,1);
    mesh.faces[20].setSmGroup(8);
    mesh.faces[21].setVerts(13,11,14);
    mesh.faces[21].setEdgeVisFlags(1,1,0);
    mesh.faces[21].setSmGroup(8);
    mesh.faces[22].setVerts(17,14,15);
    mesh.faces[22].setEdgeVisFlags(0,1,0);
    mesh.faces[22].setSmGroup(1);
    mesh.faces[23].setVerts(17,15,16);
    mesh.faces[23].setEdgeVisFlags(0,1,0);
    mesh.faces[23].setSmGroup(1);
    mesh.faces[24].setVerts(17,16,14);
    mesh.faces[24].setEdgeVisFlags(0,1,0);
    mesh.faces[24].setSmGroup(1);
    mesh.faces[25].setVerts(18,20,19);
    mesh.faces[25].setEdgeVisFlags(0,1,0);
    mesh.faces[25].setSmGroup(1);
    mesh.faces[26].setVerts(18,21,20);
    mesh.faces[26].setEdgeVisFlags(0,1,0);
    mesh.faces[26].setSmGroup(1);
    mesh.faces[27].setVerts(18,19,21);
    mesh.faces[27].setEdgeVisFlags(0,1,0);
    mesh.faces[27].setSmGroup(1);
    mesh.faces[28].setVerts(19,23,22);
    mesh.faces[28].setEdgeVisFlags(0,1,1);
    mesh.faces[28].setSmGroup(8);
    mesh.faces[29].setVerts(19,20,23);
    mesh.faces[29].setEdgeVisFlags(1,1,0);
    mesh.faces[29].setSmGroup(8);
    mesh.faces[30].setVerts(20,24,23);
    mesh.faces[30].setEdgeVisFlags(0,1,1);
    mesh.faces[30].setSmGroup(8);
    mesh.faces[31].setVerts(20,21,24);
    mesh.faces[31].setEdgeVisFlags(1,1,0);
    mesh.faces[31].setSmGroup(8);
    mesh.faces[32].setVerts(21,22,24);
    mesh.faces[32].setEdgeVisFlags(0,1,1);
    mesh.faces[32].setSmGroup(8);
    mesh.faces[33].setVerts(21,19,22);
    mesh.faces[33].setEdgeVisFlags(1,1,0);
    mesh.faces[33].setSmGroup(8);
    mesh.faces[34].setVerts(25,22,23);
    mesh.faces[34].setEdgeVisFlags(0,1,0);
    mesh.faces[34].setSmGroup(1);
    mesh.faces[35].setVerts(25,23,24);
    mesh.faces[35].setEdgeVisFlags(0,1,0);
    mesh.faces[35].setSmGroup(1);
    mesh.faces[36].setVerts(25,24,22);
    mesh.faces[36].setEdgeVisFlags(0,1,0);
    mesh.faces[36].setSmGroup(1);
    mesh.faces[37].setVerts(26,28,27);
    mesh.faces[37].setEdgeVisFlags(0,1,0);
    mesh.faces[37].setSmGroup(1);
    mesh.faces[38].setVerts(26,29,28);
    mesh.faces[38].setEdgeVisFlags(0,1,0);
    mesh.faces[38].setSmGroup(1);
    mesh.faces[39].setVerts(26,27,29);
    mesh.faces[39].setEdgeVisFlags(0,1,0);
    mesh.faces[39].setSmGroup(1);
    mesh.faces[40].setVerts(27,31,30);
    mesh.faces[40].setEdgeVisFlags(0,1,1);
    mesh.faces[40].setSmGroup(8);
    mesh.faces[41].setVerts(27,28,31);
    mesh.faces[41].setEdgeVisFlags(1,1,0);
    mesh.faces[41].setSmGroup(8);
    mesh.faces[42].setVerts(28,32,31);
    mesh.faces[42].setEdgeVisFlags(0,1,1);
    mesh.faces[42].setSmGroup(8);
    mesh.faces[43].setVerts(28,29,32);
    mesh.faces[43].setEdgeVisFlags(1,1,0);
    mesh.faces[43].setSmGroup(8);
    mesh.faces[44].setVerts(29,30,32);
    mesh.faces[44].setEdgeVisFlags(0,1,1);
    mesh.faces[44].setSmGroup(8);
    mesh.faces[45].setVerts(29,27,30);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(8);
    mesh.faces[46].setVerts(33,30,31);
    mesh.faces[46].setEdgeVisFlags(0,1,0);
    mesh.faces[46].setSmGroup(1);
    mesh.faces[47].setVerts(33,31,32);
    mesh.faces[47].setEdgeVisFlags(0,1,0);
    mesh.faces[47].setSmGroup(1);
    mesh.faces[48].setVerts(33,32,30);
    mesh.faces[48].setEdgeVisFlags(0,1,0);
    mesh.faces[48].setSmGroup(1);
    mesh.faces[49].setVerts(34,36,35);
    mesh.faces[49].setEdgeVisFlags(0,1,0);
    mesh.faces[49].setSmGroup(1);
    mesh.faces[50].setVerts(34,37,36);
    mesh.faces[50].setEdgeVisFlags(0,1,0);
    mesh.faces[50].setSmGroup(1);
    mesh.faces[51].setVerts(34,35,37);
    mesh.faces[51].setEdgeVisFlags(0,1,0);
    mesh.faces[51].setSmGroup(1);
    mesh.faces[52].setVerts(35,39,38);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(8);
    mesh.faces[53].setVerts(35,36,39);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(8);
    mesh.faces[54].setVerts(36,40,39);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(8);
    mesh.faces[55].setVerts(36,37,40);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(8);
    mesh.faces[56].setVerts(37,38,40);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(8);
    mesh.faces[57].setVerts(37,35,38);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(8);
    mesh.faces[58].setVerts(41,38,39);
    mesh.faces[58].setEdgeVisFlags(0,1,0);
    mesh.faces[58].setSmGroup(1);
    mesh.faces[59].setVerts(41,39,40);
    mesh.faces[59].setEdgeVisFlags(0,1,0);
    mesh.faces[59].setSmGroup(1);
    mesh.faces[60].setVerts(41,40,38);
    mesh.faces[60].setEdgeVisFlags(0,1,0);
    mesh.faces[60].setSmGroup(1);
    mesh.faces[61].setVerts(42,46,45);
    mesh.faces[61].setEdgeVisFlags(0,1,1);
    mesh.faces[61].setSmGroup(8);
    mesh.faces[62].setVerts(42,43,46);
    mesh.faces[62].setEdgeVisFlags(1,1,0);
    mesh.faces[62].setSmGroup(8);
    mesh.faces[63].setVerts(43,47,46);
    mesh.faces[63].setEdgeVisFlags(0,1,1);
    mesh.faces[63].setSmGroup(8);
    mesh.faces[64].setVerts(43,44,47);
    mesh.faces[64].setEdgeVisFlags(1,1,0);
    mesh.faces[64].setSmGroup(8);
    mesh.faces[65].setVerts(44,45,47);
    mesh.faces[65].setEdgeVisFlags(0,1,1);
    mesh.faces[65].setSmGroup(8);
    mesh.faces[66].setVerts(44,42,45);
    mesh.faces[66].setEdgeVisFlags(1,1,0);
    mesh.faces[66].setSmGroup(8);
    mesh.faces[67].setVerts(50,48,49);
    mesh.faces[67].setEdgeVisFlags(0,0,1);
    mesh.faces[67].setSmGroup(1);
    mesh.faces[68].setVerts(51,48,50);
    mesh.faces[68].setEdgeVisFlags(0,0,1);
    mesh.faces[68].setSmGroup(1);
    mesh.faces[69].setVerts(49,48,51);
    mesh.faces[69].setEdgeVisFlags(0,0,1);
    mesh.faces[69].setSmGroup(1);
    mesh.faces[70].setVerts(46,49,45);
    mesh.faces[70].setEdgeVisFlags(0,1,1);
    mesh.faces[70].setSmGroup(8);
    mesh.faces[71].setVerts(50,49,46);
    mesh.faces[71].setEdgeVisFlags(1,0,1);
    mesh.faces[71].setSmGroup(8);
    mesh.faces[72].setVerts(47,50,46);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(8);
    mesh.faces[73].setVerts(51,50,47);
    mesh.faces[73].setEdgeVisFlags(1,0,1);
    mesh.faces[73].setSmGroup(8);
    mesh.faces[74].setVerts(45,51,47);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(8);
    mesh.faces[75].setVerts(49,51,45);
    mesh.faces[75].setEdgeVisFlags(1,0,1);
    mesh.faces[75].setSmGroup(8);
    mesh.faces[76].setVerts(52,54,53);
    mesh.faces[76].setEdgeVisFlags(0,1,0);
    mesh.faces[76].setSmGroup(1);
    mesh.faces[77].setVerts(52,55,54);
    mesh.faces[77].setEdgeVisFlags(0,1,0);
    mesh.faces[77].setSmGroup(1);
    mesh.faces[78].setVerts(52,53,55);
    mesh.faces[78].setEdgeVisFlags(0,1,0);
    mesh.faces[78].setSmGroup(1);
    mesh.faces[79].setVerts(53,43,42);
    mesh.faces[79].setEdgeVisFlags(0,1,1);
    mesh.faces[79].setSmGroup(8);
    mesh.faces[80].setVerts(53,54,43);
    mesh.faces[80].setEdgeVisFlags(1,1,0);
    mesh.faces[80].setSmGroup(8);
    mesh.faces[81].setVerts(54,44,43);
    mesh.faces[81].setEdgeVisFlags(0,1,1);
    mesh.faces[81].setSmGroup(8);
    mesh.faces[82].setVerts(54,55,44);
    mesh.faces[82].setEdgeVisFlags(1,1,0);
    mesh.faces[82].setSmGroup(8);
    mesh.faces[83].setVerts(55,42,44);
    mesh.faces[83].setEdgeVisFlags(0,1,1);
    mesh.faces[83].setSmGroup(8);
    mesh.faces[84].setVerts(55,53,42);
    mesh.faces[84].setEdgeVisFlags(1,1,0);
    mesh.faces[84].setSmGroup(8);
    mesh.faces[85].setVerts(60,56,59);
    mesh.faces[85].setEdgeVisFlags(0,1,1);
    mesh.faces[85].setSmGroup(8);
    mesh.faces[86].setVerts(57,56,60);
    mesh.faces[86].setEdgeVisFlags(1,0,1);
    mesh.faces[86].setSmGroup(8);
    mesh.faces[87].setVerts(61,57,60);
    mesh.faces[87].setEdgeVisFlags(0,1,1);
    mesh.faces[87].setSmGroup(8);
    mesh.faces[88].setVerts(58,57,61);
    mesh.faces[88].setEdgeVisFlags(1,0,1);
    mesh.faces[88].setSmGroup(8);
    mesh.faces[89].setVerts(59,58,61);
    mesh.faces[89].setEdgeVisFlags(0,1,1);
    mesh.faces[89].setSmGroup(8);
    mesh.faces[90].setVerts(56,58,59);
    mesh.faces[90].setEdgeVisFlags(1,0,1);
    mesh.faces[90].setSmGroup(8);
    mesh.faces[91].setVerts(59,62,60);
    mesh.faces[91].setEdgeVisFlags(0,0,1);
    mesh.faces[91].setSmGroup(1);
    mesh.faces[92].setVerts(60,62,61);
    mesh.faces[92].setEdgeVisFlags(0,0,1);
    mesh.faces[92].setSmGroup(1);
    mesh.faces[93].setVerts(61,62,59);
    mesh.faces[93].setEdgeVisFlags(0,0,1);
    mesh.faces[93].setSmGroup(1);
    mesh.faces[94].setVerts(56,64,63);
    mesh.faces[94].setEdgeVisFlags(0,1,1);
    mesh.faces[94].setSmGroup(8);
    mesh.faces[95].setVerts(56,57,64);
    mesh.faces[95].setEdgeVisFlags(1,1,0);
    mesh.faces[95].setSmGroup(8);
    mesh.faces[96].setVerts(57,65,64);
    mesh.faces[96].setEdgeVisFlags(0,1,1);
    mesh.faces[96].setSmGroup(8);
    mesh.faces[97].setVerts(57,58,65);
    mesh.faces[97].setEdgeVisFlags(1,1,0);
    mesh.faces[97].setSmGroup(8);
    mesh.faces[98].setVerts(58,63,65);
    mesh.faces[98].setEdgeVisFlags(0,1,1);
    mesh.faces[98].setSmGroup(8);
    mesh.faces[99].setVerts(58,56,63);
    mesh.faces[99].setEdgeVisFlags(1,1,0);
    mesh.faces[99].setSmGroup(8);
    mesh.faces[100].setVerts(66,63,64);
    mesh.faces[100].setEdgeVisFlags(0,1,0);
    mesh.faces[100].setSmGroup(1);
    mesh.faces[101].setVerts(66,64,65);
    mesh.faces[101].setEdgeVisFlags(0,1,0);
    mesh.faces[101].setSmGroup(1);
    mesh.faces[102].setVerts(66,65,63);
    mesh.faces[102].setEdgeVisFlags(0,1,0);
    mesh.faces[102].setSmGroup(1);
    mesh.faces[103].setVerts(67,71,70);
    mesh.faces[103].setEdgeVisFlags(0,1,1);
    mesh.faces[103].setSmGroup(8);
    mesh.faces[104].setVerts(67,68,71);
    mesh.faces[104].setEdgeVisFlags(1,1,0);
    mesh.faces[104].setSmGroup(8);
    mesh.faces[105].setVerts(68,72,71);
    mesh.faces[105].setEdgeVisFlags(0,1,1);
    mesh.faces[105].setSmGroup(8);
    mesh.faces[106].setVerts(68,69,72);
    mesh.faces[106].setEdgeVisFlags(1,1,0);
    mesh.faces[106].setSmGroup(8);
    mesh.faces[107].setVerts(69,70,72);
    mesh.faces[107].setEdgeVisFlags(0,1,1);
    mesh.faces[107].setSmGroup(8);
    mesh.faces[108].setVerts(69,67,70);
    mesh.faces[108].setEdgeVisFlags(1,1,0);
    mesh.faces[108].setSmGroup(8);
    mesh.faces[109].setVerts(73,70,71);
    mesh.faces[109].setEdgeVisFlags(0,1,0);
    mesh.faces[109].setSmGroup(1);
    mesh.faces[110].setVerts(73,71,72);
    mesh.faces[110].setEdgeVisFlags(0,1,0);
    mesh.faces[110].setSmGroup(1);
    mesh.faces[111].setVerts(73,72,70);
    mesh.faces[111].setEdgeVisFlags(0,1,0);
    mesh.faces[111].setSmGroup(1);
    mesh.faces[112].setVerts(75,67,74);
    mesh.faces[112].setEdgeVisFlags(0,1,1);
    mesh.faces[112].setSmGroup(8);
    mesh.faces[113].setVerts(68,67,75);
    mesh.faces[113].setEdgeVisFlags(1,0,1);
    mesh.faces[113].setSmGroup(8);
    mesh.faces[114].setVerts(76,68,75);
    mesh.faces[114].setEdgeVisFlags(0,1,1);
    mesh.faces[114].setSmGroup(8);
    mesh.faces[115].setVerts(69,68,76);
    mesh.faces[115].setEdgeVisFlags(1,0,1);
    mesh.faces[115].setSmGroup(8);
    mesh.faces[116].setVerts(74,69,76);
    mesh.faces[116].setEdgeVisFlags(0,1,1);
    mesh.faces[116].setSmGroup(8);
    mesh.faces[117].setVerts(67,69,74);
    mesh.faces[117].setEdgeVisFlags(1,0,1);
    mesh.faces[117].setSmGroup(8);
    mesh.faces[118].setVerts(74,77,75);
    mesh.faces[118].setEdgeVisFlags(0,0,1);
    mesh.faces[118].setSmGroup(1);
    mesh.faces[119].setVerts(75,77,76);
    mesh.faces[119].setEdgeVisFlags(0,0,1);
    mesh.faces[119].setSmGroup(1);
    mesh.faces[120].setVerts(76,77,74);
    mesh.faces[120].setEdgeVisFlags(0,0,1);
    mesh.faces[120].setSmGroup(1);
    mesh.faces[121].setVerts(78,80,79);
    mesh.faces[121].setEdgeVisFlags(0,1,0);
    mesh.faces[121].setSmGroup(1);
    mesh.faces[122].setVerts(78,81,80);
    mesh.faces[122].setEdgeVisFlags(0,1,0);
    mesh.faces[122].setSmGroup(1);
    mesh.faces[123].setVerts(78,79,81);
    mesh.faces[123].setEdgeVisFlags(0,1,0);
    mesh.faces[123].setSmGroup(1);
    mesh.faces[124].setVerts(79,83,82);
    mesh.faces[124].setEdgeVisFlags(0,1,1);
    mesh.faces[124].setSmGroup(8);
    mesh.faces[125].setVerts(79,80,83);
    mesh.faces[125].setEdgeVisFlags(1,1,0);
    mesh.faces[125].setSmGroup(8);
    mesh.faces[126].setVerts(80,84,83);
    mesh.faces[126].setEdgeVisFlags(0,1,1);
    mesh.faces[126].setSmGroup(8);
    mesh.faces[127].setVerts(80,81,84);
    mesh.faces[127].setEdgeVisFlags(1,1,0);
    mesh.faces[127].setSmGroup(8);
    mesh.faces[128].setVerts(81,82,84);
    mesh.faces[128].setEdgeVisFlags(0,1,1);
    mesh.faces[128].setSmGroup(8);
    mesh.faces[129].setVerts(81,79,82);
    mesh.faces[129].setEdgeVisFlags(1,1,0);
    mesh.faces[129].setSmGroup(8);
    mesh.faces[130].setVerts(85,82,83);
    mesh.faces[130].setEdgeVisFlags(0,1,0);
    mesh.faces[130].setSmGroup(1);
    mesh.faces[131].setVerts(85,83,84);
    mesh.faces[131].setEdgeVisFlags(0,1,0);
    mesh.faces[131].setSmGroup(1);
    mesh.faces[132].setVerts(85,84,82);
    mesh.faces[132].setEdgeVisFlags(0,1,0);
    mesh.faces[132].setSmGroup(1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\audio.cpp ===
/**********************************************************************
 *<
    FILE: audio.cpp

    DESCRIPTION:  A VRML 2.0 AutoClip helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 29 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "audio.h"

//------------------------------------------------------

class AudioClipClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new AudioClipObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_AUDIO_CLIP_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(AudioClip_CLASS_ID1,
                                                    AudioClip_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static AudioClipClassDesc AudioClipDesc;

ClassDesc* GetAudioClipDesc() { return &AudioClipDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

BOOL CALLBACK
AudioClipDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam,
                  AudioClipObject *th)
{
    TCHAR text[MAX_PATH];

    switch ( message ) {
    case WM_INITDIALOG: {
        Edit_SetText(GetDlgItem(hDlg, IDC_URL), th->url.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_DESC), th->desc.data());
        return FALSE;
    }
    
    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_URL:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_URL), text, MAX_PATH);
                th->url = text;
                break;
            }
            break;
        case IDC_DESC:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_DESC), text, MAX_PATH);
                th->desc = text;
                break;
            }
            break;
        }
        break;
    default:
        return FALSE;
    }

    return FALSE;
}

static ParamUIDesc descParam[] = {
  // Loop
  ParamUIDesc(PB_AC_LOOP,
              TYPE_SINGLECHEKBOX, IDC_LOOP),

  // Loop
  ParamUIDesc(PB_AC_START,
              TYPE_SINGLECHEKBOX, IDC_START_ON_LOAD),

  // Pitch
  ParamUIDesc(
              PB_AC_PITCH,
              EDITTYPE_FLOAT,
              IDC_PITCH_EDIT, IDC_PITCH_SPIN,
              0.0f, 1.0f,
              0.1f),	

  // Pitch
  ParamUIDesc(
              PB_AC_SIZE,
              EDITTYPE_FLOAT,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 10000.0f,
              0.1f),	

};
  

#define PARAMDESC_LENGTH 4

static ParamBlockDescID descVer0[] = {
  { TYPE_INT, NULL, FALSE,   0 },
  { TYPE_FLOAT, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_INT, NULL, FALSE,   3 },
};

#define CURRENT_VERSION	0

class AudioClipParamDlgProc : public ParamMapUserDlgProc {
public:
  AudioClipObject *ob;

  AudioClipParamDlgProc(AudioClipObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL AudioClipParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return AudioClipDlgProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *AudioClipObject::pmapParam = NULL;

void
AudioClipObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        
        // Left over from last AudioClip created		
        pmapParam->SetParamBlock(pblock);

    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_AUDIO_CLIP),
                                     _T("Audio Clip"),
                                     0);
    }
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new AudioClipParamDlgProc(this));
    }
    
}

void
AudioClipObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags & END_EDIT_REMOVEUI ) {
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

AudioClipObject::AudioClipObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_AC_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_AC_LOOP, 0, FALSE);
    pb->SetValue(PB_AC_PITCH , 0, 1.0f);
    pb->SetValue(PB_AC_START , 0, FALSE);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);

    written = 0;
}

AudioClipObject::~AudioClipObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *AudioClipObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
AudioClipObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
//     int i;
//     switch (message) {
//     }
     return REF_SUCCEED;
}

RefTargetHandle
AudioClipObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    return NULL;
}

void
AudioClipObject::SetReference(int ind, RefTargetHandle rtarg)
{
    pblock = (IParamBlock*) rtarg;
}

ObjectState
AudioClipObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
AudioClipObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
AudioClipObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
AudioClipObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
AudioClipObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
AudioClipObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_AC_SIZE, t, size, FOREVER);
#include "acob.cpp"    
}

int
AudioClipObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_AC_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 1.0f, 0.0f, 1.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
AudioClipObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class AudioClipCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    AudioClipObject *audioClipObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(AudioClipObject *obj) {audioClipObject = obj;}

};

			
int
AudioClipCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            audioClipObject->pblock->SetValue(PB_AC_SIZE,
                                               audioClipObject->
                                               iObjParams->GetTime(), radius);
            audioClipObject->pmapParam->Invalidate();										
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(audioClipObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static AudioClipCreateCallBack AudioClipCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
AudioClipObject::GetCreateMouseCallBack() 
{
    AudioClipCreateCB.SetObj(this);
    return(&AudioClipCreateCB);
}

#define DESC_CHUNK		0xad30
#define URL_CHUNK		0xad31
#define TOP_CHUNK		0xad05

IOResult 
AudioClipObject::Save(ISave *isave)
{
    isave->BeginChunk(DESC_CHUNK);
    isave->WriteCString(desc.data());
    isave->EndChunk();

    isave->BeginChunk(URL_CHUNK);
    isave->WriteCString(url.data());
    isave->EndChunk();

    return IO_OK;
}

IOResult
AudioClipObject::Load(ILoad *iload)
{
    TCHAR* txt;

    while (iload->OpenChunk() == IO_OK) {
        switch(iload->CurChunkID()) {
        case DESC_CHUNK:
            iload->ReadCStringChunk(&txt);
            desc = txt;
            break;
            
        case URL_CHUNK:
            iload->ReadCStringChunk(&txt);
            url = txt;
            break;
            
        default:
            break;
        }
        iload->CloseChunk();
    }
    return IO_OK;
}

            
RefTargetHandle
AudioClipObject::Clone(RemapDir& remap)
{
    AudioClipObject* ac = new AudioClipObject();
    ac->ReplaceReference(0, pblock->Clone(remap));
    ac->desc = desc;
    ac->url = url;
    return ac;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\audio.h ===
/**********************************************************************
 *<
    FILE: audio.g
 
    DESCRIPTION:  Defines an AuioClip VRML 2.0 helper object
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 29 Aug. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __AudioClip__H__
 
#define __AudioClip__H__
 
#define AudioClip_CLASS_ID1 0xA73D3442
#define AudioClip_CLASS_ID2 0xFB15DBAD

#define AudioClipClassID Class_ID(AudioClip_CLASS_ID1, AudioClip_CLASS_ID2)

extern ClassDesc* GetAudioClipDesc();

class AudioClipObject: public HelperObject {			   
    friend class AudioClipCreateCallBack;
    friend class AudioClipObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
  public:


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    static IObjParam *iObjParams;
    TSTR desc, url;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    HWND imageDlg;
    IParamBlock *pblock;
    static IParamMap *pmapParam;

    BOOL written;

    AudioClipObject();
    ~AudioClipObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_AUDIO_CLIP)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_AUDIO_CLIP)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(AudioClip_CLASS_ID1,
                                         AudioClip_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_AUDIO_CLIP_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

    // IO
    IOResult Save(ISave *isave);
    IOResult Load(ILoad *iload);
};				

#define PB_AC_LOOP      0
#define PB_AC_PITCH     1
#define PB_AC_SIZE      2
#define PB_AC_START     3
#define PB_AC_LENGTH    4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\backgrnd.h ===
/**********************************************************************
 *<
    FILE: backgrnd.h
 
    DESCRIPTION:  Defines a VRML 2.0 Background helper object
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 29 Aug. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __Background__H__
 
#define __Background__H__
 
#define Background_CLASS_ID1 0xAC5D3442
#define Background_CLASS_ID2 0xFBBDBAD

#define BackgroundClassID Class_ID(Background_CLASS_ID1, Background_CLASS_ID2)

extern ClassDesc* GetBackgroundDesc();

class BackgroundCreateCallBack;

class BackgroundObject: public HelperObject {			   
    friend class BackgroundCreateCallBack;
    friend class BackgroundObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(BackgroundObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    HWND imageDlg;
    IParamBlock *pblock;
    static IParamMap *skyParam;
    static IParamMap *groundParam;
    TSTR back, bottom, front, left, right, top;

    BackgroundObject();
    ~BackgroundObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_BACKGROUND)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_BACKGROUND)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(Background_CLASS_ID1,
                                         Background_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_BACKGROUND_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

    // IO
    IOResult Save(ISave *isave);
    IOResult Load(ILoad *iload);
};				

#define PB_SKY_NUM_COLORS      0
#define PB_SKY_COLOR1          1
#define PB_SKY_COLOR2          2
#define PB_SKY_COLOR2_ANGLE    3
#define PB_SKY_COLOR3          4
#define PB_SKY_COLOR3_ANGLE    5
#define PB_GROUND_NUM_COLORS   6
#define PB_GROUND_COLOR1       7
#define PB_GROUND_COLOR2       8
#define PB_GROUND_COLOR2_ANGLE 9
#define PB_GROUND_COLOR3       10
#define PB_GROUND_COLOR3_ANGLE 11
#define PB_BG_SIZE             12
#define PB_BG_LENGTH           13

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bboard.h ===
/**********************************************************************
 *<
    FILE: bboard.h
 
    DESCRIPTION:  Defines a Billboard VRML 2.0 helper object
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 29 Feb. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __Billboard__H__
 
#define __Billboard__H__
 
#define Billboard_CLASS_ID1 0xABBD3442
#define Billboard_CLASS_ID2 0xFBBDBAD

#define BillboardClassID Class_ID(Billboard_CLASS_ID1, Billboard_CLASS_ID2)

extern ClassDesc* GetBillboardDesc();

class BillboardCreateCallBack;

class BillboardObject: public HelperObject {			   
    friend class BillboardCreateCallBack;
    friend class BillboardObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(BillboardObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    IParamBlock *pblock;
    static IParamMap *pmapParam;

    BillboardObject();
    ~BillboardObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_BILLBOARD)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_BILLBOARD)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(Billboard_CLASS_ID1,
                                         Billboard_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_BILLBOARD_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

};				

#define PB_BB_SIZE    0
#define PB_BB_SCREEN_ALIGN 1
#define PB_BB_LENGTH  2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\backgrnd.cpp ===
/**********************************************************************
 *<
    FILE: backgrnd.cpp

    DESCRIPTION:  A VRML Background helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 26 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "backgrnd.h"

//------------------------------------------------------

class BackgroundClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new BackgroundObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_BACKGROUND_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(Background_CLASS_ID1,
                                                    Background_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static BackgroundClassDesc BackgroundDesc;

ClassDesc* GetBackgroundDesc() { return &BackgroundDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

HWND BackgroundObject::hRollup = NULL;
int BackgroundObject::dlgPrevSel = -1;

BOOL CALLBACK
BackgroundImageDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    TCHAR text[MAX_PATH];
    BackgroundObject *th =
        (BackgroundObject *)GetWindowLong( hDlg, GWL_USERDATA );	

    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG: {
        th = (BackgroundObject *)lParam;
        SetWindowLong( hDlg, GWL_USERDATA, (LONG)th );
        Edit_SetText(GetDlgItem(hDlg, IDC_BACK), th->back.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_BOTTOM), th->bottom.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_FRONT), th->front.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_LEFT), th->left.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_RIGHT), th->right.data());
        Edit_SetText(GetDlgItem(hDlg, IDC_TOP), th->top.data());
        return TRUE;
    }
    
    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_BACK:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_BACK), text, MAX_PATH);
                th->back = text;
            }
            break;
        case IDC_BOTTOM:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_BOTTOM), text, MAX_PATH);
                th->bottom = text;
            }
            break;
        case IDC_FRONT:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_FRONT), text, MAX_PATH);
                th->front = text;
            }
            break;
        case IDC_LEFT:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_LEFT), text, MAX_PATH);
                th->left = text;
            }
            break;
        case IDC_RIGHT:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_RIGHT), text, MAX_PATH);
                th->right = text;
            }
            break;
        case IDC_TOP:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                Edit_GetText(GetDlgItem(hDlg, IDC_TOP), text, MAX_PATH);
                th->top = text;
            }
            break;
        }
        return TRUE;
    default:
        return FALSE;
    }

    return FALSE;
}

static int buttonIds[] = {IDC_1_COLOR, IDC_2_COLOR, IDC_3_COLOR};

static ParamUIDesc descSkyParam[] = {
  // Number of colors
  ParamUIDesc(PB_SKY_NUM_COLORS,
              TYPE_RADIO, buttonIds, 3),

  // Color 1
  ParamUIDesc(PB_SKY_COLOR1,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_1),


  // Color 2
  ParamUIDesc(PB_SKY_COLOR2,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_2),

  // Color 2 angle
  ParamUIDesc(
              PB_SKY_COLOR2_ANGLE,
              EDITTYPE_FLOAT,
              IDC_COLOR_2_ANGLE_EDIT, IDC_COLOR_2_ANGLE_SPIN,
              0.0f, 180.0f,
              1.0f, stdAngleDim),	

  // Color 3
  ParamUIDesc(PB_SKY_COLOR3,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_3),

  // Color 3 angle
  ParamUIDesc(
              PB_SKY_COLOR3_ANGLE,
              EDITTYPE_FLOAT,
              IDC_COLOR_3_ANGLE_EDIT, IDC_COLOR_3_ANGLE_SPIN,
              0.0f, 180.0f,
              1.0f, stdAngleDim),	

  // Size
  ParamUIDesc(
              PB_BG_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

};
  
#define PARAMDESC_SKY_LENGTH 7

static ParamUIDesc descGroundParam[] = {
  // Number of colors
  ParamUIDesc(PB_GROUND_NUM_COLORS,
              TYPE_RADIO, buttonIds, 3),

  // Color 1
  ParamUIDesc(PB_GROUND_COLOR1,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_1),


  // Color 2
  ParamUIDesc(PB_GROUND_COLOR2,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_2),

  // Color 2 angle
  ParamUIDesc(
              PB_GROUND_COLOR2_ANGLE,
              EDITTYPE_FLOAT,
              IDC_COLOR_2_ANGLE_EDIT, IDC_COLOR_2_ANGLE_SPIN,
              0.0f, 180.0f,
              1.0f, stdAngleDim),	

  // Color 3
  ParamUIDesc(PB_GROUND_COLOR3,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH_3),

  // Color 3 angle
  ParamUIDesc(
              PB_GROUND_COLOR3_ANGLE,
              EDITTYPE_FLOAT,
              IDC_COLOR_3_ANGLE_EDIT, IDC_COLOR_3_ANGLE_SPIN,
              0.0f, 180.0f,
              1.0f, stdAngleDim),	

};
  

#define PARAMDESC_GROUND_LENGTH 6

static ParamBlockDescID descVer0[] = {
  { TYPE_INT, NULL, FALSE,   0 },
  { TYPE_RGBA, NULL, FALSE, 1 },
  { TYPE_RGBA, NULL, FALSE, 2 },
  { TYPE_FLOAT, NULL, FALSE, 3 },
  { TYPE_RGBA, NULL, FALSE, 4 },
  { TYPE_FLOAT, NULL, FALSE, 5 },
  { TYPE_INT, NULL, FALSE,   6 },
  { TYPE_RGBA, NULL, FALSE, 7 },
  { TYPE_RGBA, NULL, FALSE, 8 },
  { TYPE_FLOAT, NULL, FALSE, 9 },
  { TYPE_RGBA, NULL, FALSE, 10 },
  { TYPE_FLOAT, NULL, FALSE, 11 },
  { TYPE_FLOAT, NULL, FALSE, 12 },
};

// Current version
static ParamVersionDesc curVersion(descVer0, PB_BG_LENGTH, 0);
#define CURRENT_VERSION	0

IParamMap *BackgroundObject::skyParam = NULL;
IParamMap *BackgroundObject::groundParam = NULL;

static HWND imgDlg;

void
BackgroundObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                Animatable *prev )
{
    iObjParams = ip;
    
    if (skyParam) {
        
        // Left over from last Background created		
        skyParam->SetParamBlock(pblock);
        groundParam->SetParamBlock(pblock);

    } else {
        
        // Gotta make a new one.
        skyParam = CreateCPParamMap(descSkyParam,PARAMDESC_SKY_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_BACKGROUND_COLORS),
                                     _T("Sky Colors"),
                                     0);
        groundParam = CreateCPParamMap(descGroundParam,PARAMDESC_GROUND_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_BACKGROUND_COLORS1),
                                     _T("Ground Colors"),
                                     APPENDROLL_CLOSED);
     // imageDlg = ip->AddRollupPage(hInstance,
        imgDlg = GetCOREInterface()->AddRollupPage(hInstance,
                                     MAKEINTRESOURCE(IDD_BACKGROUND_IMAGES),
                                     BackgroundImageDlgProc,
                                     _T("Images"),
                                     (LPARAM) this,
                                     APPENDROLL_CLOSED);
    }
    
}

void
BackgroundObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {
        if (skyParam) DestroyCPParamMap(skyParam);
        skyParam  = NULL;
        if (groundParam) DestroyCPParamMap(groundParam);
        groundParam  = NULL;
     // if (imageDlg) ip->DeleteRollupPage(imageDlg);
        if (imgDlg) GetCOREInterface()->DeleteRollupPage(imgDlg);
        imgDlg = NULL;
    }	
}

BackgroundObject::BackgroundObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_BG_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_SKY_NUM_COLORS, 0, 0);
    pb->SetValue(PB_SKY_COLOR1 , 0, Point3(0.0f, 0.0f, 1.0f));
    pb->SetValue(PB_SKY_COLOR2 , 0, Point3(1.0f, 0.0f, 0.0f));
    pb->SetValue(PB_SKY_COLOR3 , 0, Point3(0.0f, 1.0f, 0.0f));
    pb->SetValue(PB_SKY_COLOR2_ANGLE, 0, float(PI/4.0));
    pb->SetValue(PB_SKY_COLOR3_ANGLE, 0, float(PI/2.0));
    pb->SetValue(PB_GROUND_NUM_COLORS, 0, 0);
    pb->SetValue(PB_GROUND_COLOR1 , 0, Point3(0.7f, 0.4f, 0.3f));
    pb->SetValue(PB_GROUND_COLOR2 , 0, Point3(1.0f, 0.0f, 0.0f));
    pb->SetValue(PB_GROUND_COLOR3 , 0, Point3(0.0f, 1.0f, 0.0f));
    pb->SetValue(PB_GROUND_COLOR2_ANGLE, 0, float(PI/4.0));
    pb->SetValue(PB_GROUND_COLOR3_ANGLE, 0, float(PI/2.0));
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
}

BackgroundObject::~BackgroundObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *BackgroundObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
BackgroundObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
//     int i;
//     switch (message) {
//     }
     return REF_SUCCEED;
}

RefTargetHandle
BackgroundObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    return NULL;
}

void
BackgroundObject::SetReference(int ind, RefTargetHandle rtarg)
{
    pblock = (IParamBlock*) rtarg;
}

ObjectState
BackgroundObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
BackgroundObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
BackgroundObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
BackgroundObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
BackgroundObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
BackgroundObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_BG_SIZE, t, size, FOREVER);
#include "bgob.cpp"
}

int
BackgroundObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_BG_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 0.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
BackgroundObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class BackgroundCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    BackgroundObject *backgroundObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(BackgroundObject *obj) {backgroundObject = obj;}

};

			
int
BackgroundCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            backgroundObject->pblock->SetValue(PB_BG_SIZE,
                                               backgroundObject->
                                               iObjParams->GetTime(), radius);
            backgroundObject->skyParam->Invalidate();
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(backgroundObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static BackgroundCreateCallBack BackgroundCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
BackgroundObject::GetCreateMouseCallBack() 
{
    BackgroundCreateCB.SetObj(this);
    return(&BackgroundCreateCB);
}

#define BACK_CHUNK		0xad00
#define BOTTOM_CHUNK		0xad01
#define FRONT_CHUNK		0xad02
#define LEFT_CHUNK		0xad03
#define RIGHT_CHUNK		0xad04
#define TOP_CHUNK		0xad05

IOResult 
BackgroundObject::Save(ISave *isave)
{
    isave->BeginChunk(BACK_CHUNK);
    isave->WriteCString(back.data());
    isave->EndChunk();

    isave->BeginChunk(BOTTOM_CHUNK);
    isave->WriteCString(bottom.data());
    isave->EndChunk();

    isave->BeginChunk(FRONT_CHUNK);
    isave->WriteCString(front.data());
    isave->EndChunk();

    isave->BeginChunk(LEFT_CHUNK);
    isave->WriteCString(left.data());
    isave->EndChunk();

    isave->BeginChunk(RIGHT_CHUNK);
    isave->WriteCString(right.data());
    isave->EndChunk();

    isave->BeginChunk(TOP_CHUNK);
    isave->WriteCString(top.data());
    isave->EndChunk();

    return IO_OK;
}

IOResult
BackgroundObject::Load(ILoad *iload)
{
    TCHAR* txt;

    while (iload->OpenChunk() == IO_OK) {
        switch(iload->CurChunkID()) {
        case BACK_CHUNK:
            iload->ReadCStringChunk(&txt);
            back = txt;
            break;
            
        case BOTTOM_CHUNK:
            iload->ReadCStringChunk(&txt);
            bottom = txt;
            break;
            
        case FRONT_CHUNK:
            iload->ReadCStringChunk(&txt);
            front = txt;
            break;
            
        case LEFT_CHUNK:
            iload->ReadCStringChunk(&txt);
            left = txt;
            break;
            
        case RIGHT_CHUNK:
            iload->ReadCStringChunk(&txt);
            right = txt;
            break;
            
        case TOP_CHUNK:
            iload->ReadCStringChunk(&txt);
            top = txt;
            break;
        default:
            break;
        }
        iload->CloseChunk();
    }
    return IO_OK;
}

            
RefTargetHandle
BackgroundObject::Clone(RemapDir& remap)
{
    BackgroundObject* bg = new BackgroundObject();
    bg->ReplaceReference(0, pblock->Clone(remap));
    bg->back = back;
    bg->bottom = bottom;
    bg->front = front;
    bg->left = left;
    bg->right = right;
    bg->top = top;
    return bg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bboard.cpp ===
/**********************************************************************
 *<
    FILE: bboard.cpp

    DESCRIPTION:  A VRML Billboard VRML 2.0 helper object
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 18 Sept, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "bboard.h"

//------------------------------------------------------

class BillboardClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new BillboardObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_BILLBOARD_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(Billboard_CLASS_ID1,
                                                    Billboard_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static BillboardClassDesc BillboardDesc;

ClassDesc* GetBillboardDesc() { return &BillboardDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

HWND BillboardObject::hRollup = NULL;
int BillboardObject::dlgPrevSel = -1;

static ParamUIDesc descParam[] = {
  // Size
  ParamUIDesc(
              PB_BB_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Loop
  ParamUIDesc(PB_BB_SCREEN_ALIGN, TYPE_SINGLECHEKBOX, IDC_ALIGN),
};

  

#define PARAMDESC_LENGTH 2

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
};

#define NUM_OLD_VERSIONS 0

// Current version
#define CURRENT_VERSION	0

IParamMap *BillboardObject::pmapParam = NULL;

void
BillboardObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        
        // Left over from last Billboard created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_BBOARD),
                                     _T("Billboard"),
                                     0);
    }
    
}

void
BillboardObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

BillboardObject::BillboardObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_BB_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_BB_SCREEN_ALIGN, 0, FALSE);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    
}

BillboardObject::~BillboardObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *BillboardObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
BillboardObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
     return REF_SUCCEED;
}

RefTargetHandle
BillboardObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    return NULL;
}

void
BillboardObject::SetReference(int ind, RefTargetHandle rtarg)
{
    pblock = (IParamBlock*) rtarg;
}

ObjectState
BillboardObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
BillboardObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
BillboardObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
BillboardObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    BuildMesh(t);
    box = mesh.getBoundingBox();

}

void
BillboardObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
BillboardObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_BB_SIZE, t, size, FOREVER);
#include "bbob.cpp"
}

int
BillboardObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_BB_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.5f, 0.5f, 1.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
BillboardObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class BillboardCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    BillboardObject *billboardObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(BillboardObject *obj) {billboardObject = obj;}

};

			
int
BillboardCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            billboardObject->pblock->SetValue(PB_BB_SIZE,
                                               billboardObject->
                                               iObjParams->GetTime(), radius);
            billboardObject->pmapParam->Invalidate();
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(billboardObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static BillboardCreateCallBack BillboardCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
BillboardObject::GetCreateMouseCallBack() 
{
    BillboardCreateCB.SetObj(this);
    return(&BillboardCreateCB);
}

RefTargetHandle
BillboardObject::Clone(RemapDir& remap)
{
    BillboardObject* ni = new BillboardObject();
    ni->ReplaceReference(0, pblock->Clone(remap));
    return ni;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bbob.cpp ===
mesh.setNumVerts(34);
    mesh.setNumFaces(49);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669280));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.387674,0.040373,-0.120724));
    mesh.setVert(11, size * Point3(0.377855,0.040373,-0.120724));
    mesh.setVert(12, size * Point3(-0.387674,-0.050282,-0.120724));
    mesh.setVert(13, size * Point3(0.377855,-0.050282,-0.120724));
    mesh.setVert(14, size * Point3(-0.387674,0.040373,0.241895));
    mesh.setVert(15, size * Point3(0.377855,0.040373,0.241895));
    mesh.setVert(16, size * Point3(-0.387674,-0.050282,0.241895));
    mesh.setVert(17, size * Point3(0.377855,-0.050282,0.241895));
    mesh.setVert(18, size * Point3(0.254279,0.010810,-0.332996));
    mesh.setVert(19, size * Point3(0.301419,0.010810,-0.332996));
    mesh.setVert(20, size * Point3(0.254279,-0.018653,-0.332996));
    mesh.setVert(21, size * Point3(0.301419,-0.018653,-0.332996));
    mesh.setVert(22, size * Point3(0.254279,0.010810,-0.120864));
    mesh.setVert(23, size * Point3(0.301419,0.010810,-0.120864));
    mesh.setVert(24, size * Point3(0.254279,-0.018653,-0.120864));
    mesh.setVert(25, size * Point3(0.301419,-0.018653,-0.120864));
    mesh.setVert(26, size * Point3(-0.310152,0.010810,-0.332996));
    mesh.setVert(27, size * Point3(-0.263012,0.010810,-0.332996));
    mesh.setVert(28, size * Point3(-0.310152,-0.018653,-0.332996));
    mesh.setVert(29, size * Point3(-0.263012,-0.018653,-0.332996));
    mesh.setVert(30, size * Point3(-0.310152,0.010810,-0.120864));
    mesh.setVert(31, size * Point3(-0.263012,0.010810,-0.120864));
    mesh.setVert(32, size * Point3(-0.310152,-0.018653,-0.120864));
    mesh.setVert(33, size * Point3(-0.263012,-0.018653,-0.120864));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(12,10,13);
    mesh.faces[13].setEdgeVisFlags(1,0,1);
    mesh.faces[13].setSmGroup(2);
    mesh.faces[14].setVerts(11,13,10);
    mesh.faces[14].setEdgeVisFlags(1,0,1);
    mesh.faces[14].setSmGroup(2);
    mesh.faces[15].setVerts(15,14,17);
    mesh.faces[15].setEdgeVisFlags(1,0,1);
    mesh.faces[15].setSmGroup(4);
    mesh.faces[16].setVerts(16,17,14);
    mesh.faces[16].setEdgeVisFlags(1,0,1);
    mesh.faces[16].setSmGroup(4);
    mesh.faces[17].setVerts(11,10,15);
    mesh.faces[17].setEdgeVisFlags(1,0,1);
    mesh.faces[17].setSmGroup(20);
    mesh.faces[18].setVerts(14,15,10);
    mesh.faces[18].setEdgeVisFlags(1,0,1);
    mesh.faces[18].setSmGroup(20);
    mesh.faces[19].setVerts(13,11,17);
    mesh.faces[19].setEdgeVisFlags(1,0,1);
    mesh.faces[19].setSmGroup(10);
    mesh.faces[20].setVerts(15,17,11);
    mesh.faces[20].setEdgeVisFlags(1,0,1);
    mesh.faces[20].setSmGroup(10);
    mesh.faces[21].setVerts(12,13,16);
    mesh.faces[21].setEdgeVisFlags(1,0,1);
    mesh.faces[21].setSmGroup(20);
    mesh.faces[22].setVerts(17,16,13);
    mesh.faces[22].setEdgeVisFlags(1,0,1);
    mesh.faces[22].setSmGroup(20);
    mesh.faces[23].setVerts(10,12,14);
    mesh.faces[23].setEdgeVisFlags(1,0,1);
    mesh.faces[23].setSmGroup(40);
    mesh.faces[24].setVerts(16,14,12);
    mesh.faces[24].setEdgeVisFlags(1,0,1);
    mesh.faces[24].setSmGroup(40);
    mesh.faces[25].setVerts(20,18,21);
    mesh.faces[25].setEdgeVisFlags(1,0,1);
    mesh.faces[25].setSmGroup(2);
    mesh.faces[26].setVerts(19,21,18);
    mesh.faces[26].setEdgeVisFlags(1,0,1);
    mesh.faces[26].setSmGroup(2);
    mesh.faces[27].setVerts(23,22,25);
    mesh.faces[27].setEdgeVisFlags(1,0,1);
    mesh.faces[27].setSmGroup(4);
    mesh.faces[28].setVerts(24,25,22);
    mesh.faces[28].setEdgeVisFlags(1,0,1);
    mesh.faces[28].setSmGroup(4);
    mesh.faces[29].setVerts(19,18,23);
    mesh.faces[29].setEdgeVisFlags(1,0,1);
    mesh.faces[29].setSmGroup(20);
    mesh.faces[30].setVerts(22,23,18);
    mesh.faces[30].setEdgeVisFlags(1,0,1);
    mesh.faces[30].setSmGroup(20);
    mesh.faces[31].setVerts(21,19,25);
    mesh.faces[31].setEdgeVisFlags(1,0,1);
    mesh.faces[31].setSmGroup(10);
    mesh.faces[32].setVerts(23,25,19);
    mesh.faces[32].setEdgeVisFlags(1,0,1);
    mesh.faces[32].setSmGroup(10);
    mesh.faces[33].setVerts(20,21,24);
    mesh.faces[33].setEdgeVisFlags(1,0,1);
    mesh.faces[33].setSmGroup(20);
    mesh.faces[34].setVerts(25,24,21);
    mesh.faces[34].setEdgeVisFlags(1,0,1);
    mesh.faces[34].setSmGroup(20);
    mesh.faces[35].setVerts(18,20,22);
    mesh.faces[35].setEdgeVisFlags(1,0,1);
    mesh.faces[35].setSmGroup(40);
    mesh.faces[36].setVerts(24,22,20);
    mesh.faces[36].setEdgeVisFlags(1,0,1);
    mesh.faces[36].setSmGroup(40);
    mesh.faces[37].setVerts(28,26,29);
    mesh.faces[37].setEdgeVisFlags(1,0,1);
    mesh.faces[37].setSmGroup(2);
    mesh.faces[38].setVerts(27,29,26);
    mesh.faces[38].setEdgeVisFlags(1,0,1);
    mesh.faces[38].setSmGroup(2);
    mesh.faces[39].setVerts(31,30,33);
    mesh.faces[39].setEdgeVisFlags(1,0,1);
    mesh.faces[39].setSmGroup(4);
    mesh.faces[40].setVerts(32,33,30);
    mesh.faces[40].setEdgeVisFlags(1,0,1);
    mesh.faces[40].setSmGroup(4);
    mesh.faces[41].setVerts(27,26,31);
    mesh.faces[41].setEdgeVisFlags(1,0,1);
    mesh.faces[41].setSmGroup(20);
    mesh.faces[42].setVerts(30,31,26);
    mesh.faces[42].setEdgeVisFlags(1,0,1);
    mesh.faces[42].setSmGroup(20);
    mesh.faces[43].setVerts(29,27,33);
    mesh.faces[43].setEdgeVisFlags(1,0,1);
    mesh.faces[43].setSmGroup(10);
    mesh.faces[44].setVerts(31,33,27);
    mesh.faces[44].setEdgeVisFlags(1,0,1);
    mesh.faces[44].setSmGroup(10);
    mesh.faces[45].setVerts(28,29,32);
    mesh.faces[45].setEdgeVisFlags(1,0,1);
    mesh.faces[45].setSmGroup(20);
    mesh.faces[46].setVerts(33,32,29);
    mesh.faces[46].setEdgeVisFlags(1,0,1);
    mesh.faces[46].setSmGroup(20);
    mesh.faces[47].setVerts(26,28,30);
    mesh.faces[47].setEdgeVisFlags(1,0,1);
    mesh.faces[47].setSmGroup(40);
    mesh.faces[48].setVerts(32,30,28);
    mesh.faces[48].setEdgeVisFlags(1,0,1);
    mesh.faces[48].setSmGroup(40);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bgob.cpp ===
mesh.setNumVerts(88);
    mesh.setNumFaces(99);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669281));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(0.219425,0.109512,0.259798));
    mesh.setVert(11, size * Point3(0.219425,0.145574,0.322260));
    mesh.setVert(12, size * Point3(0.165331,0.145574,0.291029));
    mesh.setVert(13, size * Point3(0.165331,0.145574,0.228567));
    mesh.setVert(14, size * Point3(0.219425,0.145574,0.197336));
    mesh.setVert(15, size * Point3(0.273518,0.145574,0.228567));
    mesh.setVert(16, size * Point3(0.273518,0.145574,0.291029));
    mesh.setVert(17, size * Point3(0.219425,0.217699,0.322260));
    mesh.setVert(18, size * Point3(0.165331,0.217699,0.291029));
    mesh.setVert(19, size * Point3(0.165331,0.217699,0.228567));
    mesh.setVert(20, size * Point3(0.219425,0.217699,0.197336));
    mesh.setVert(21, size * Point3(0.273518,0.217699,0.228567));
    mesh.setVert(22, size * Point3(0.273518,0.217699,0.291029));
    mesh.setVert(23, size * Point3(0.219425,0.253761,0.259798));
    mesh.setVert(24, size * Point3(-0.426216,0.228993,-0.136859));
    mesh.setVert(25, size * Point3(-0.360085,0.208861,-0.112403));
    mesh.setVert(26, size * Point3(-0.313941,0.194487,-0.094083));
    mesh.setVert(27, size * Point3(-0.282842,0.183430,-0.079436));
    mesh.setVert(28, size * Point3(-0.261848,0.173626,-0.066000));
    mesh.setVert(29, size * Point3(-0.246017,0.163282,-0.051311));
    mesh.setVert(30, size * Point3(-0.230409,0.150869,-0.032907));
    mesh.setVert(31, size * Point3(-0.210081,0.135242,-0.008324));
    mesh.setVert(32, size * Point3(-0.186682,0.117680,0.021616));
    mesh.setVert(33, size * Point3(-0.165152,0.100277,0.054450));
    mesh.setVert(34, size * Point3(-0.145491,0.083548,0.090180));
    mesh.setVert(35, size * Point3(-0.127700,0.068052,0.128803));
    mesh.setVert(36, size * Point3(-0.111778,0.054392,0.170321));
    mesh.setVert(37, size * Point3(-0.097725,0.043219,0.214734));
    mesh.setVert(38, size * Point3(-0.085541,0.035229,0.262040));
    mesh.setVert(39, size * Point3(-0.037441,0.037013,0.249104));
    mesh.setVert(40, size * Point3(0.017968,0.035493,0.259980));
    mesh.setVert(41, size * Point3(0.112763,0.110618,0.034503));
    mesh.setVert(42, size * Point3(0.125697,0.124146,0.010268));
    mesh.setVert(43, size * Point3(0.140124,0.137626,-0.012188));
    mesh.setVert(44, size * Point3(0.156042,0.150841,-0.032864));
    mesh.setVert(45, size * Point3(0.173454,0.163593,-0.051761));
    mesh.setVert(46, size * Point3(0.192358,0.175700,-0.068879));
    mesh.setVert(47, size * Point3(0.212754,0.186997,-0.084218));
    mesh.setVert(48, size * Point3(0.234642,0.197337,-0.097777));
    mesh.setVert(49, size * Point3(0.258023,0.206589,-0.109557));
    mesh.setVert(50, size * Point3(0.282897,0.214639,-0.119558));
    mesh.setVert(51, size * Point3(0.309262,0.221393,-0.127779));
    mesh.setVert(52, size * Point3(0.337120,0.226770,-0.134221));
    mesh.setVert(53, size * Point3(0.366471,0.230708,-0.138884));
    mesh.setVert(54, size * Point3(0.397314,0.233163,-0.141768));
    mesh.setVert(55, size * Point3(0.429649,0.234108,-0.142872));
    mesh.setVert(56, size * Point3(-0.426216,-0.180601,-0.136859));
    mesh.setVert(57, size * Point3(-0.360085,-0.162176,-0.112403));
    mesh.setVert(58, size * Point3(-0.313941,-0.149020,-0.094083));
    mesh.setVert(59, size * Point3(-0.282842,-0.138900,-0.079436));
    mesh.setVert(60, size * Point3(-0.261848,-0.129927,-0.066000));
    mesh.setVert(61, size * Point3(-0.246017,-0.120459,-0.051311));
    mesh.setVert(62, size * Point3(-0.230409,-0.109099,-0.032907));
    mesh.setVert(63, size * Point3(-0.210081,-0.094796,-0.008324));
    mesh.setVert(64, size * Point3(-0.186682,-0.078723,0.021616));
    mesh.setVert(65, size * Point3(-0.165152,-0.062795,0.054450));
    mesh.setVert(66, size * Point3(-0.145491,-0.047484,0.090180));
    mesh.setVert(67, size * Point3(-0.127700,-0.033301,0.128803));
    mesh.setVert(68, size * Point3(-0.111778,-0.020799,0.170321));
    mesh.setVert(69, size * Point3(-0.097725,-0.010573,0.214733));
    mesh.setVert(70, size * Point3(-0.085541,-0.003260,0.262040));
    mesh.setVert(71, size * Point3(-0.037441,-0.004893,0.249104));
    mesh.setVert(72, size * Point3(0.017968,-0.003501,0.259980));
    mesh.setVert(73, size * Point3(0.112763,-0.072259,0.034503));
    mesh.setVert(74, size * Point3(0.125697,-0.084641,0.010268));
    mesh.setVert(75, size * Point3(0.140124,-0.096978,-0.012188));
    mesh.setVert(76, size * Point3(0.156042,-0.109073,-0.032864));
    mesh.setVert(77, size * Point3(0.173454,-0.120744,-0.051761));
    mesh.setVert(78, size * Point3(0.192358,-0.131825,-0.068879));
    mesh.setVert(79, size * Point3(0.212754,-0.142165,-0.084218));
    mesh.setVert(80, size * Point3(0.234642,-0.151628,-0.097777));
    mesh.setVert(81, size * Point3(0.258023,-0.160096,-0.109557));
    mesh.setVert(82, size * Point3(0.282897,-0.167464,-0.119558));
    mesh.setVert(83, size * Point3(0.309262,-0.173645,-0.127779));
    mesh.setVert(84, size * Point3(0.337120,-0.178566,-0.134221));
    mesh.setVert(85, size * Point3(0.366471,-0.182171,-0.138884));
    mesh.setVert(86, size * Point3(0.397314,-0.184418,-0.141768));
    mesh.setVert(87, size * Point3(0.429649,-0.185283,-0.142872));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,11,12);
    mesh.faces[13].setEdgeVisFlags(1,1,1);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(10,12,13);
    mesh.faces[14].setEdgeVisFlags(1,1,1);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(10,13,14);
    mesh.faces[15].setEdgeVisFlags(1,1,1);
    mesh.faces[15].setSmGroup(1);
    mesh.faces[16].setVerts(10,14,15);
    mesh.faces[16].setEdgeVisFlags(1,1,1);
    mesh.faces[16].setSmGroup(1);
    mesh.faces[17].setVerts(10,15,16);
    mesh.faces[17].setEdgeVisFlags(1,1,1);
    mesh.faces[17].setSmGroup(1);
    mesh.faces[18].setVerts(10,16,11);
    mesh.faces[18].setEdgeVisFlags(1,1,1);
    mesh.faces[18].setSmGroup(1);
    mesh.faces[19].setVerts(11,17,18);
    mesh.faces[19].setEdgeVisFlags(1,1,0);
    mesh.faces[19].setSmGroup(1);
    mesh.faces[20].setVerts(11,18,12);
    mesh.faces[20].setEdgeVisFlags(0,1,1);
    mesh.faces[20].setSmGroup(1);
    mesh.faces[21].setVerts(12,18,19);
    mesh.faces[21].setEdgeVisFlags(1,1,0);
    mesh.faces[21].setSmGroup(1);
    mesh.faces[22].setVerts(12,19,13);
    mesh.faces[22].setEdgeVisFlags(0,1,1);
    mesh.faces[22].setSmGroup(1);
    mesh.faces[23].setVerts(13,19,20);
    mesh.faces[23].setEdgeVisFlags(1,1,0);
    mesh.faces[23].setSmGroup(1);
    mesh.faces[24].setVerts(13,20,14);
    mesh.faces[24].setEdgeVisFlags(0,1,1);
    mesh.faces[24].setSmGroup(1);
    mesh.faces[25].setVerts(14,20,21);
    mesh.faces[25].setEdgeVisFlags(1,1,0);
    mesh.faces[25].setSmGroup(1);
    mesh.faces[26].setVerts(14,21,15);
    mesh.faces[26].setEdgeVisFlags(0,1,1);
    mesh.faces[26].setSmGroup(1);
    mesh.faces[27].setVerts(15,21,22);
    mesh.faces[27].setEdgeVisFlags(1,1,0);
    mesh.faces[27].setSmGroup(1);
    mesh.faces[28].setVerts(15,22,16);
    mesh.faces[28].setEdgeVisFlags(0,1,1);
    mesh.faces[28].setSmGroup(1);
    mesh.faces[29].setVerts(16,22,17);
    mesh.faces[29].setEdgeVisFlags(1,1,0);
    mesh.faces[29].setSmGroup(1);
    mesh.faces[30].setVerts(16,17,11);
    mesh.faces[30].setEdgeVisFlags(0,1,1);
    mesh.faces[30].setSmGroup(1);
    mesh.faces[31].setVerts(23,18,17);
    mesh.faces[31].setEdgeVisFlags(1,1,1);
    mesh.faces[31].setSmGroup(1);
    mesh.faces[32].setVerts(23,19,18);
    mesh.faces[32].setEdgeVisFlags(1,1,1);
    mesh.faces[32].setSmGroup(1);
    mesh.faces[33].setVerts(23,20,19);
    mesh.faces[33].setEdgeVisFlags(1,1,1);
    mesh.faces[33].setSmGroup(1);
    mesh.faces[34].setVerts(23,21,20);
    mesh.faces[34].setEdgeVisFlags(1,1,1);
    mesh.faces[34].setSmGroup(1);
    mesh.faces[35].setVerts(23,22,21);
    mesh.faces[35].setEdgeVisFlags(1,1,1);
    mesh.faces[35].setSmGroup(1);
    mesh.faces[36].setVerts(23,17,22);
    mesh.faces[36].setEdgeVisFlags(1,1,1);
    mesh.faces[36].setSmGroup(1);
    mesh.faces[37].setVerts(24,25,57);
    mesh.faces[37].setEdgeVisFlags(1,1,0);
    mesh.faces[37].setSmGroup(1);
    mesh.faces[38].setVerts(24,57,56);
    mesh.faces[38].setEdgeVisFlags(0,1,1);
    mesh.faces[38].setSmGroup(1);
    mesh.faces[39].setVerts(25,26,58);
    mesh.faces[39].setEdgeVisFlags(1,1,0);
    mesh.faces[39].setSmGroup(3);
    mesh.faces[40].setVerts(25,58,57);
    mesh.faces[40].setEdgeVisFlags(0,1,1);
    mesh.faces[40].setSmGroup(3);
    mesh.faces[41].setVerts(26,27,59);
    mesh.faces[41].setEdgeVisFlags(1,1,0);
    mesh.faces[41].setSmGroup(2);
    mesh.faces[42].setVerts(26,59,58);
    mesh.faces[42].setEdgeVisFlags(0,1,1);
    mesh.faces[42].setSmGroup(2);
    mesh.faces[43].setVerts(27,28,60);
    mesh.faces[43].setEdgeVisFlags(1,1,0);
    mesh.faces[43].setSmGroup(2);
    mesh.faces[44].setVerts(27,60,59);
    mesh.faces[44].setEdgeVisFlags(0,1,1);
    mesh.faces[44].setSmGroup(2);
    mesh.faces[45].setVerts(28,29,61);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(2);
    mesh.faces[46].setVerts(28,61,60);
    mesh.faces[46].setEdgeVisFlags(0,1,1);
    mesh.faces[46].setSmGroup(2);
    mesh.faces[47].setVerts(29,30,62);
    mesh.faces[47].setEdgeVisFlags(1,1,0);
    mesh.faces[47].setSmGroup(2);
    mesh.faces[48].setVerts(29,62,61);
    mesh.faces[48].setEdgeVisFlags(0,1,1);
    mesh.faces[48].setSmGroup(2);
    mesh.faces[49].setVerts(30,31,63);
    mesh.faces[49].setEdgeVisFlags(1,1,0);
    mesh.faces[49].setSmGroup(2);
    mesh.faces[50].setVerts(30,63,62);
    mesh.faces[50].setEdgeVisFlags(0,1,1);
    mesh.faces[50].setSmGroup(2);
    mesh.faces[51].setVerts(31,32,64);
    mesh.faces[51].setEdgeVisFlags(1,1,0);
    mesh.faces[51].setSmGroup(2);
    mesh.faces[52].setVerts(31,64,63);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(2);
    mesh.faces[53].setVerts(32,33,65);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(2);
    mesh.faces[54].setVerts(32,65,64);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(2);
    mesh.faces[55].setVerts(33,34,66);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(2);
    mesh.faces[56].setVerts(33,66,65);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(2);
    mesh.faces[57].setVerts(34,35,67);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(2);
    mesh.faces[58].setVerts(34,67,66);
    mesh.faces[58].setEdgeVisFlags(0,1,1);
    mesh.faces[58].setSmGroup(2);
    mesh.faces[59].setVerts(35,36,68);
    mesh.faces[59].setEdgeVisFlags(1,1,0);
    mesh.faces[59].setSmGroup(2);
    mesh.faces[60].setVerts(35,68,67);
    mesh.faces[60].setEdgeVisFlags(0,1,1);
    mesh.faces[60].setSmGroup(2);
    mesh.faces[61].setVerts(36,37,69);
    mesh.faces[61].setEdgeVisFlags(1,1,0);
    mesh.faces[61].setSmGroup(2);
    mesh.faces[62].setVerts(36,69,68);
    mesh.faces[62].setEdgeVisFlags(0,1,1);
    mesh.faces[62].setSmGroup(2);
    mesh.faces[63].setVerts(37,38,70);
    mesh.faces[63].setEdgeVisFlags(1,1,0);
    mesh.faces[63].setSmGroup(2);
    mesh.faces[64].setVerts(37,70,69);
    mesh.faces[64].setEdgeVisFlags(0,1,1);
    mesh.faces[64].setSmGroup(2);
    mesh.faces[65].setVerts(38,39,71);
    mesh.faces[65].setEdgeVisFlags(1,1,0);
    mesh.faces[65].setSmGroup(4);
    mesh.faces[66].setVerts(38,71,70);
    mesh.faces[66].setEdgeVisFlags(0,1,1);
    mesh.faces[66].setSmGroup(4);
    mesh.faces[67].setVerts(39,40,72);
    mesh.faces[67].setEdgeVisFlags(1,1,0);
    mesh.faces[67].setSmGroup(2);
    mesh.faces[68].setVerts(39,72,71);
    mesh.faces[68].setEdgeVisFlags(0,1,1);
    mesh.faces[68].setSmGroup(2);
    mesh.faces[69].setVerts(40,41,73);
    mesh.faces[69].setEdgeVisFlags(1,1,0);
    mesh.faces[69].setSmGroup(4);
    mesh.faces[70].setVerts(40,73,72);
    mesh.faces[70].setEdgeVisFlags(0,1,1);
    mesh.faces[70].setSmGroup(4);
    mesh.faces[71].setVerts(41,42,74);
    mesh.faces[71].setEdgeVisFlags(1,1,0);
    mesh.faces[71].setSmGroup(2);
    mesh.faces[72].setVerts(41,74,73);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(2);
    mesh.faces[73].setVerts(42,43,75);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(2);
    mesh.faces[74].setVerts(42,75,74);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(2);
    mesh.faces[75].setVerts(43,44,76);
    mesh.faces[75].setEdgeVisFlags(1,1,0);
    mesh.faces[75].setSmGroup(2);
    mesh.faces[76].setVerts(43,76,75);
    mesh.faces[76].setEdgeVisFlags(0,1,1);
    mesh.faces[76].setSmGroup(2);
    mesh.faces[77].setVerts(44,45,77);
    mesh.faces[77].setEdgeVisFlags(1,1,0);
    mesh.faces[77].setSmGroup(2);
    mesh.faces[78].setVerts(44,77,76);
    mesh.faces[78].setEdgeVisFlags(0,1,1);
    mesh.faces[78].setSmGroup(2);
    mesh.faces[79].setVerts(45,46,78);
    mesh.faces[79].setEdgeVisFlags(1,1,0);
    mesh.faces[79].setSmGroup(2);
    mesh.faces[80].setVerts(45,78,77);
    mesh.faces[80].setEdgeVisFlags(0,1,1);
    mesh.faces[80].setSmGroup(2);
    mesh.faces[81].setVerts(46,47,79);
    mesh.faces[81].setEdgeVisFlags(1,1,0);
    mesh.faces[81].setSmGroup(2);
    mesh.faces[82].setVerts(46,79,78);
    mesh.faces[82].setEdgeVisFlags(0,1,1);
    mesh.faces[82].setSmGroup(2);
    mesh.faces[83].setVerts(47,48,80);
    mesh.faces[83].setEdgeVisFlags(1,1,0);
    mesh.faces[83].setSmGroup(2);
    mesh.faces[84].setVerts(47,80,79);
    mesh.faces[84].setEdgeVisFlags(0,1,1);
    mesh.faces[84].setSmGroup(2);
    mesh.faces[85].setVerts(48,49,81);
    mesh.faces[85].setEdgeVisFlags(1,1,0);
    mesh.faces[85].setSmGroup(2);
    mesh.faces[86].setVerts(48,81,80);
    mesh.faces[86].setEdgeVisFlags(0,1,1);
    mesh.faces[86].setSmGroup(2);
    mesh.faces[87].setVerts(49,50,82);
    mesh.faces[87].setEdgeVisFlags(1,1,0);
    mesh.faces[87].setSmGroup(2);
    mesh.faces[88].setVerts(49,82,81);
    mesh.faces[88].setEdgeVisFlags(0,1,1);
    mesh.faces[88].setSmGroup(2);
    mesh.faces[89].setVerts(50,51,83);
    mesh.faces[89].setEdgeVisFlags(1,1,0);
    mesh.faces[89].setSmGroup(2);
    mesh.faces[90].setVerts(50,83,82);
    mesh.faces[90].setEdgeVisFlags(0,1,1);
    mesh.faces[90].setSmGroup(2);
    mesh.faces[91].setVerts(51,52,84);
    mesh.faces[91].setEdgeVisFlags(1,1,0);
    mesh.faces[91].setSmGroup(2);
    mesh.faces[92].setVerts(51,84,83);
    mesh.faces[92].setEdgeVisFlags(0,1,1);
    mesh.faces[92].setSmGroup(2);
    mesh.faces[93].setVerts(52,53,85);
    mesh.faces[93].setEdgeVisFlags(1,1,0);
    mesh.faces[93].setSmGroup(2);
    mesh.faces[94].setVerts(52,85,84);
    mesh.faces[94].setEdgeVisFlags(0,1,1);
    mesh.faces[94].setSmGroup(2);
    mesh.faces[95].setVerts(53,54,86);
    mesh.faces[95].setEdgeVisFlags(1,1,0);
    mesh.faces[95].setSmGroup(2);
    mesh.faces[96].setVerts(53,86,85);
    mesh.faces[96].setEdgeVisFlags(0,1,1);
    mesh.faces[96].setSmGroup(2);
    mesh.faces[97].setVerts(54,55,87);
    mesh.faces[97].setEdgeVisFlags(1,1,0);
    mesh.faces[97].setSmGroup(3);
    mesh.faces[98].setVerts(54,87,86);
    mesh.faces[98].setEdgeVisFlags(0,1,1);
    mesh.faces[98].setSmGroup(3);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bookmark.h ===
/**********************************************************************
 *<
    FILE: bookmark.h
 
    DESCRIPTION:  Access to the URL bookmark
 
    CREATED BY: Charles Thaeler
  
    HISTORY: created 26 Mar. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __BOOKMARK__H__
 
#define __BOOKMARK__H__

#define VRMBLIO_INI_FILE _T("vrblio.ini")
#define BOOKMARK_SECTION _T("Bookmarks")

TCHAR * ExportIniFilename(Interface* ip);

extern void SplitURL(TSTR in, TSTR *url, TSTR *camera);
extern int GetBookmarkURL(Interface *ip, TSTR *u, TSTR *c, TSTR *d);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\bookmark.cpp ===
/**********************************************************************
 *<
    FILE: bookmark.cpp

    DESCRIPTION:  A Dialog box to get a URL
 
    CREATED BY: Charles Thaeler
 
    HISTORY: created 26 Mar. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"
#include "bookmark.h"

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

class Bookmark  {
public:
	TSTR url;
	TSTR desc;
};

static Tab<Bookmark*> bookmarks;

static TSTR url;
static TSTR desc;
static BOOL initBookmarks = TRUE;

void
SplitURL(TSTR in, TSTR *url, TSTR *camera)
{
	if (camera) {
		TSTR temp = in;
		int i = temp.last('#');
		if (i >= 0) {
			*camera = temp.Substr(i+1, temp.Length() - i - 1);
			*url = temp.Substr(0, i);
		} else {
			*camera = ""; // no camera
			*url = in;
		}
	} else
		*url = in;
}

static void
LoadBookmarks(Interface *ip, TCHAR *filename, HWND hlist)
{
#define MAX_STR 1024
	if (filename) {
		FILE *fp = fopen(filename, "r");
		if (fp == NULL) {
			// Warning box?
			return;
		}
		int inchar;
		while ((inchar = getc(fp)) != EOF) {
			// loop till we find an A HREF="
			if ((inchar == 'A') &&
				(((inchar = getc(fp)) != EOF && inchar == ' ') &&
				((inchar = getc(fp)) != EOF && inchar == 'H') &&
				((inchar = getc(fp)) != EOF && inchar == 'R') &&
				((inchar = getc(fp)) != EOF && inchar == 'E') &&
				((inchar = getc(fp)) != EOF && inchar == 'F') &&
				((inchar = getc(fp)) != EOF && inchar == '=') &&
				((inchar = getc(fp)) != EOF && inchar == '"'))) {
				char url[MAX_STR];
				char desc[MAX_STR];
				int count = 0;
				url[0] = desc[0] = '\0';

				while ((inchar = getc(fp)) != EOF) {
					// loop till we find the closing " or are too big
					if (inchar == '"' || count >= (MAX_STR -2)) {
						url[count] = '\0';
						if (inchar == '"')
							break;
					} else
						url[count++] = inchar;
				}
				count = 0;
				if (inchar != EOF) {
					// loop till we find a >
					while ((inchar = getc(fp)) != EOF && inchar != '>') ;
					if (inchar != EOF) {
						// Everything till the next < is a description
						while ((inchar = getc(fp)) != EOF) {
							// loop till we find the closing " or are too big
							if (inchar == '<' || count >= (MAX_STR -2)) {
								desc[count] = '\0';
								if (inchar == '<')
									break;
							} else
								desc[count++] = inchar;
						}
					}
				}
				// OK I think we have have a valid URL and Description so we need
				// to add it to the bookmarks
				Bookmark *bm = new Bookmark();
				bm->url = url;
				bm->desc = desc;
				int pos = bookmarks.Append(1, &bm);
				if (hlist) {
					LV_ITEM item;
					item.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
					item.iItem = pos;
					item.iSubItem = 0;
					item.state = 0;
					item.stateMask = 0;
					item.lParam = (LPARAM)bookmarks[pos];
					item.pszText = bm->url.data();
					item.cchTextMax = strlen(item.pszText)+1;
					ListView_InsertItem(hlist, &item);
					ListView_SetItemText(hlist, pos, 1, bm->desc.data());
					ListView_EnsureVisible(hlist, pos, FALSE);
				}
			}
		}
	} else {
		// I wonder how big it should be?
#define BM_SIZE 32768
		//Load from the ini file.
		TCHAR bm[BM_SIZE], *pbm;

		int rc = GetPrivateProfileSection(BOOKMARK_SECTION, bm, BM_SIZE,
                                                  ExportIniFilename(ip));
		// Clean out the old list if it exists
		for (int i = bookmarks.Count()-1; i >= 0; i--) {
			delete bookmarks[i];
			bookmarks.Delete(i, 1);
		}
		if (rc > 0 && rc != (BM_SIZE - 2)) {
			pbm = bm;
			while(*pbm) {
				Bookmark *nbm = new Bookmark();
				TCHAR *p = pbm;
				while(p) {
					if (*p == '=') {
						*p = '\0';
						break;
					}
					p++;
				}
				// the first string is a key -- url
				nbm->url = pbm;
				pbm += _tcslen(pbm) + 1; // Step beyond the null

				// the next string is a value -- description
				nbm->desc = pbm;
				pbm += _tcslen(pbm) + 1; // Step beyond the null
				bookmarks.Append(1, &nbm);
			}
		}
	}
}

static void
SaveBookmarks(Interface *ip)
{
	//Load from the ini file.
	// First Nuke the old ones
	WritePrivateProfileSection(BOOKMARK_SECTION, "\0\0",
                                   ExportIniFilename(ip));
	for (int i = 0; i < bookmarks.Count(); i++)
		WritePrivateProfileString(BOOKMARK_SECTION,
			bookmarks[i]->url, bookmarks[i]->desc,
                                          ExportIniFilename(ip));
}

static BOOL CALLBACK
URLBookmarkDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    if (msg == WM_INITDIALOG)
        SetWindowLong(hDlg, GWL_USERDATA, lParam);

	Interface *ip = (Interface *)GetWindowLong( hDlg, GWL_USERDATA );

	HWND hlist = GetDlgItem(hDlg,IDC_URL_LIST);

    switch (msg) {
    case WM_INITDIALOG: {
		int rc;
		LV_COLUMN col;

		col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
		col.fmt = LVCFMT_LEFT;
		col.cx = 260;  // allow for the URL, the remainder is the description
		col.pszText = _T(GetString(IDS_PRS_URL));
		rc = ListView_InsertColumn(hlist, 0, &col);

		col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
		col.fmt = LVCFMT_LEFT;
		col.cx = 260;
		col.pszText = _T(GetString(IDS_PRS_DESCRIPTION));
		rc = ListView_InsertColumn(hlist, 1, &col);

		for (int i = 0; i < bookmarks.Count(); i++) {
            LV_ITEM item;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            item.iItem = i;
            item.iSubItem = 0;
            item.state = 0;
            item.stateMask = 0;
			item.lParam = (LPARAM)bookmarks[i];
            item.pszText = bookmarks[i]->url.data();
            item.cchTextMax = strlen(item.pszText)+1;
            rc = ListView_InsertItem(hlist, &item);
            ListView_SetItemText(hlist, i, 1, bookmarks[i]->desc.data());
		}

		SendMessage(GetDlgItem(hDlg,IDC_URL), WM_SETTEXT, 0, (LPARAM)url.data());
		EnableWindow(GetDlgItem(hDlg,IDC_URL),TRUE);

		SendMessage(GetDlgItem(hDlg,IDC_DESC), WM_SETTEXT, 0, (LPARAM)desc.data());
		EnableWindow(GetDlgItem(hDlg,IDC_DESC),TRUE);

		int numsel = ListView_GetSelectedCount(hlist);
		EnableWindow(GetDlgItem(hDlg,IDC_DELETE), numsel > 0);

        CenterWindow(hDlg, GetParent(hDlg));
		}
        return TRUE;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
		case IDC_IMPORT: {
			OPENFILENAME ofn;
			char filename[MAX_PATH];
			char *filterStr = _T("Bookmarks\0*.htm;*.html\0\0");
			filename[0] = '\0';
			ofn.lStructSize = sizeof(OPENFILENAME); 
			ofn.hInstance = hInstance;
			ofn.hwndOwner = hDlg;
			ofn.lpstrFilter = filterStr;
			ofn.lpstrCustomFilter = NULL;
			ofn.nFilterIndex = 0;
			ofn.lpstrFile = filename;
			ofn.nMaxFile = MAX_PATH;
			ofn.lpstrFileTitle = NULL;
			ofn.nMaxFileTitle = 0;
			ofn.lpstrInitialDir = NULL; 
			ofn.lpstrTitle = NULL; 
			ofn.Flags = OFN_FILEMUSTEXIST | OFN_LONGNAMES | OFN_PATHMUSTEXIST; 
			ofn.lpstrDefExt = _T("htm"); 

			if (GetOpenFileName(&ofn))
				LoadBookmarks(ip, ofn.lpstrFile, hlist);
			return TRUE;
			}
		case IDC_ADD: {
			Bookmark *bm = new Bookmark();

			int len = SendDlgItemMessage(hDlg, IDC_URL, WM_GETTEXTLENGTH, 0, 0);
			TSTR temp;
			temp.Resize(len+1);
			SendDlgItemMessage(hDlg, IDC_URL, WM_GETTEXT, len+1, (LPARAM)temp.data());
			bm->url = temp;

			len = SendDlgItemMessage(hDlg, IDC_DESC, WM_GETTEXTLENGTH, 0, 0);
			temp.Resize(len+1);
			SendDlgItemMessage(hDlg, IDC_DESC, WM_GETTEXT, len+1, (LPARAM)temp.data());
			bm->desc = temp;

			int pos = bookmarks.Append(1, &bm);

            LV_ITEM item;
            item.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            item.iItem = pos;
            item.iSubItem = 0;
            item.state = 0;
            item.stateMask = 0;
			item.lParam = (LPARAM)bookmarks[pos];
            item.pszText = bm->url.data();
            item.cchTextMax = strlen(item.pszText)+1;
            ListView_InsertItem(hlist, &item);
            ListView_SetItemText(hlist, pos, 1, bm->desc.data());
			ListView_EnsureVisible(hlist, pos, FALSE);
			}
			return TRUE;
		case IDC_DELETE: {
			int numsel = ListView_GetSelectedCount(hlist);
			if (numsel > 0) {
				// need to find and delete them, traverse backwards since the list shrinks
				for (int i = ListView_GetItemCount(hlist) - 1; i >= 0; i--) {
					LV_ITEM item;
					item.mask = LVIF_STATE | LVIF_PARAM;
					item.iSubItem = 0;
					item.state = 0;
					item.stateMask = LVIS_SELECTED;
					item.iItem = i;
					ListView_GetItem(hlist, &item);
					if (item.state & LVIS_SELECTED) {
						ListView_DeleteItem(hlist, i);
						// Now find the bookmark and delete it
						for (int j = 0; j < bookmarks.Count(); j++) {
							if (bookmarks[j] ==(Bookmark*)item.lParam) {
								bookmarks.Delete(j, 1);
								break;
							}
						}
					}
				}
				EnableWindow(GetDlgItem(hDlg,IDC_DELETE), FALSE);
			}
			}
			return TRUE;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return TRUE;
        case IDOK: {
			int len = SendDlgItemMessage(hDlg, IDC_URL, WM_GETTEXTLENGTH, 0, 0);
			TSTR temp;
			temp.Resize(len+1);
			SendDlgItemMessage(hDlg, IDC_URL, WM_GETTEXT, len+1, (LPARAM)temp.data());
			url = temp;

			len = SendDlgItemMessage(hDlg, IDC_DESC, WM_GETTEXTLENGTH, 0, 0);
			temp.Resize(len+1);
			SendDlgItemMessage(hDlg, IDC_DESC, WM_GETTEXT, len+1, (LPARAM)temp.data());
			desc = temp;
			EndDialog(hDlg, TRUE);
			}
            return TRUE;
		}
		break;

	case WM_NOTIFY:
        switch(LOWORD(wParam)) {
        case IDC_URL_LIST:
            NMHDR *pnmh = (LPNMHDR) lParam;
			int code = pnmh->code;
            switch(code) {
			case NM_CLICK:
            case NM_SETFOCUS:
				int numsel = ListView_GetSelectedCount(hlist);
				EnableWindow(GetDlgItem(hDlg,IDC_DELETE), numsel > 0);
				for (int i = 0; i < ListView_GetItemCount(hlist); i++) {
					LV_ITEM item;
					item.mask = LVIF_STATE | LVIF_PARAM;
					item.iSubItem = 0;
					item.state = 0;
					item.stateMask = LVIS_FOCUSED;
					item.iItem = i;
					ListView_GetItem(hlist, &item);
					if (item.state & LVIS_FOCUSED) {
						SendMessage(GetDlgItem(hDlg,IDC_URL), WM_SETTEXT, 0,
							(LPARAM)((Bookmark*)item.lParam)->url.data());
						SendMessage(GetDlgItem(hDlg,IDC_DESC), WM_SETTEXT, 0,
							(LPARAM)((Bookmark*)item.lParam)->desc.data());
					}
				}
				return TRUE;
			} // pnmh->code switch
			break;
		}
		break;

    } // msg switch
    return FALSE;
}

int
GetBookmarkURL(Interface *ip, TSTR *u, TSTR *c, TSTR *d)
{
	LoadBookmarks(ip, NULL, NULL);

	if (c && c->Length() > 0)
		url = *u + _T("#") + *c;
	else
		url = *u;

	if (d)
		desc = *d;
	else
		desc = _T("");

	if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_URL_BOOKMARKS), 
            GetActiveWindow(), URLBookmarkDlgProc, (LPARAM) ip)) {
		SplitURL(url, u, c);
		if (d)
			*d = desc;
		SaveBookmarks(ip);
		return TRUE;
	}

	return FALSE;
}

TCHAR *
ExportIniFilename(Interface* ip)
{
    static TCHAR ini_file[MAX_PATH];
    TCHAR *maxDir = ip->GetDir(APP_PLUGCFG_DIR);
    _tcscpy(ini_file, maxDir);
    _tcscat(ini_file, "\\");
    _tcscat(ini_file, VRMBLIO_INI_FILE);
    return ini_file;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\clockob.cpp ===
mesh.setNumVerts(96);
    mesh.setNumFaces(157);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669280));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(0.196466,0.017025,0.283948));
    mesh.setVert(11, size * Point3(0.178641,0.091048,0.253076));
    mesh.setVert(12, size * Point3(0.228762,0.063178,0.224139));
    mesh.setVert(13, size * Point3(0.241141,0.000553,0.216992));
    mesh.setVert(14, size * Point3(0.206456,-0.049669,0.237017));
    mesh.setVert(15, size * Point3(0.150827,-0.049668,0.269135));
    mesh.setVert(16, size * Point3(0.116142,0.000553,0.289160));
    mesh.setVert(17, size * Point3(0.128521,0.063178,0.282013));
    mesh.setVert(18, size * Point3(0.149125,0.111705,0.201953));
    mesh.setVert(19, size * Point3(0.213232,0.076057,0.164941));
    mesh.setVert(20, size * Point3(0.229065,-0.004044,0.155800));
    mesh.setVert(21, size * Point3(0.184702,-0.068279,0.181413));
    mesh.setVert(22, size * Point3(0.113549,-0.068279,0.222493));
    mesh.setVert(23, size * Point3(0.069186,-0.004044,0.248106));
    mesh.setVert(24, size * Point3(0.085019,0.076057,0.238965));
    mesh.setVert(25, size * Point3(0.149125,0.017025,0.201953));
    mesh.setVert(26, size * Point3(-0.228638,0.017025,0.283948));
    mesh.setVert(27, size * Point3(-0.210814,0.091048,0.253076));
    mesh.setVert(28, size * Point3(-0.260935,0.063178,0.224139));
    mesh.setVert(29, size * Point3(-0.273313,0.000553,0.216992));
    mesh.setVert(30, size * Point3(-0.238629,-0.049668,0.237017));
    mesh.setVert(31, size * Point3(-0.182999,-0.049668,0.269135));
    mesh.setVert(32, size * Point3(-0.148315,0.000553,0.289160));
    mesh.setVert(33, size * Point3(-0.160694,0.063178,0.282013));
    mesh.setVert(34, size * Point3(-0.181298,0.111705,0.201953));
    mesh.setVert(35, size * Point3(-0.245405,0.076057,0.164941));
    mesh.setVert(36, size * Point3(-0.261238,-0.004044,0.155800));
    mesh.setVert(37, size * Point3(-0.216875,-0.068279,0.181413));
    mesh.setVert(38, size * Point3(-0.145722,-0.068279,0.222493));
    mesh.setVert(39, size * Point3(-0.101359,-0.004044,0.248106));
    mesh.setVert(40, size * Point3(-0.117192,0.076057,0.238965));
    mesh.setVert(41, size * Point3(-0.181298,0.017025,0.201953));
    mesh.setVert(42, size * Point3(-0.022487,0.019048,-0.083443));
    mesh.setVert(43, size * Point3(-0.007580,0.019048,-0.087998));
    mesh.setVert(44, size * Point3(-0.029940,0.032547,-0.081166));
    mesh.setVert(45, size * Point3(-0.029940,0.005549,-0.081166));
    mesh.setVert(46, size * Point3(0.063230,0.019048,0.143735));
    mesh.setVert(47, size * Point3(0.040870,0.032547,0.150568));
    mesh.setVert(48, size * Point3(0.040870,0.005549,0.150568));
    mesh.setVert(49, size * Point3(0.048323,0.019048,0.148290));
    mesh.setVert(50, size * Point3(-0.022487,0.019048,-0.083443));
    mesh.setVert(51, size * Point3(-0.021945,0.019048,-0.067865));
    mesh.setVert(52, size * Point3(-0.022758,0.032547,-0.091232));
    mesh.setVert(53, size * Point3(-0.022758,0.005549,-0.091232));
    mesh.setVert(54, size * Point3(-0.154035,0.019048,-0.063273));
    mesh.setVert(55, size * Point3(-0.154848,0.032547,-0.086640));
    mesh.setVert(56, size * Point3(-0.154848,0.005549,-0.086640));
    mesh.setVert(57, size * Point3(-0.154577,0.019048,-0.078851));
    mesh.setVert(58, size * Point3(-0.014940,0.070643,-0.079889));
    mesh.setVert(59, size * Point3(0.275213,0.070643,-0.079889));
    mesh.setVert(60, size * Point3(0.219798,0.070643,0.090659));
    mesh.setVert(61, size * Point3(0.074722,0.070643,0.196063));
    mesh.setVert(62, size * Point3(-0.104603,0.070643,0.196063));
    mesh.setVert(63, size * Point3(-0.249679,0.070643,0.090659));
    mesh.setVert(64, size * Point3(-0.305093,0.070643,-0.079889));
    mesh.setVert(65, size * Point3(-0.249679,0.070643,-0.250437));
    mesh.setVert(66, size * Point3(-0.104603,0.070643,-0.355841));
    mesh.setVert(67, size * Point3(0.074722,0.070643,-0.355841));
    mesh.setVert(68, size * Point3(0.219798,0.070643,-0.250437));
    mesh.setVert(69, size * Point3(0.275213,-0.054125,-0.079889));
    mesh.setVert(70, size * Point3(0.219798,-0.054125,0.090659));
    mesh.setVert(71, size * Point3(0.074722,-0.054125,0.196063));
    mesh.setVert(72, size * Point3(-0.104603,-0.054125,0.196063));
    mesh.setVert(73, size * Point3(-0.249679,-0.054125,0.090659));
    mesh.setVert(74, size * Point3(-0.305093,-0.054125,-0.079889));
    mesh.setVert(75, size * Point3(-0.249679,-0.054125,-0.250437));
    mesh.setVert(76, size * Point3(-0.104603,-0.054125,-0.355841));
    mesh.setVert(77, size * Point3(0.074722,-0.054125,-0.355841));
    mesh.setVert(78, size * Point3(0.219798,-0.054125,-0.250437));
    mesh.setVert(79, size * Point3(-0.014940,-0.054125,-0.079889));
    mesh.setVert(80, size * Point3(0.118728,0.010873,-0.458903));
    mesh.setVert(81, size * Point3(0.103821,0.010873,-0.463458));
    mesh.setVert(82, size * Point3(0.126182,0.024372,-0.456625));
    mesh.setVert(83, size * Point3(0.126182,-0.002626,-0.456625));
    mesh.setVert(84, size * Point3(0.071635,0.010873,-0.358124));
    mesh.setVert(85, size * Point3(0.093996,0.024372,-0.351292));
    mesh.setVert(86, size * Point3(0.093996,-0.002626,-0.351292));
    mesh.setVert(87, size * Point3(0.086542,0.010873,-0.353569));
    mesh.setVert(88, size * Point3(-0.145611,0.010873,-0.458903));
    mesh.setVert(89, size * Point3(-0.130703,0.010873,-0.463458));
    mesh.setVert(90, size * Point3(-0.153064,0.024372,-0.456625));
    mesh.setVert(91, size * Point3(-0.153064,-0.002626,-0.456625));
    mesh.setVert(92, size * Point3(-0.098517,0.010873,-0.358124));
    mesh.setVert(93, size * Point3(-0.120878,0.024372,-0.351292));
    mesh.setVert(94, size * Point3(-0.120878,-0.002626,-0.351292));
    mesh.setVert(95, size * Point3(-0.113424,0.010873,-0.353569));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(11,10,12);
    mesh.faces[13].setEdgeVisFlags(1,1,1);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(12,10,13);
    mesh.faces[14].setEdgeVisFlags(1,1,1);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(13,10,14);
    mesh.faces[15].setEdgeVisFlags(1,1,1);
    mesh.faces[15].setSmGroup(1);
    mesh.faces[16].setVerts(14,10,15);
    mesh.faces[16].setEdgeVisFlags(1,1,1);
    mesh.faces[16].setSmGroup(1);
    mesh.faces[17].setVerts(15,10,16);
    mesh.faces[17].setEdgeVisFlags(1,1,1);
    mesh.faces[17].setSmGroup(1);
    mesh.faces[18].setVerts(16,10,17);
    mesh.faces[18].setEdgeVisFlags(1,1,1);
    mesh.faces[18].setSmGroup(1);
    mesh.faces[19].setVerts(17,10,11);
    mesh.faces[19].setEdgeVisFlags(1,1,1);
    mesh.faces[19].setSmGroup(1);
    mesh.faces[20].setVerts(18,11,19);
    mesh.faces[20].setEdgeVisFlags(1,0,1);
    mesh.faces[20].setSmGroup(1);
    mesh.faces[21].setVerts(19,11,12);
    mesh.faces[21].setEdgeVisFlags(0,1,1);
    mesh.faces[21].setSmGroup(1);
    mesh.faces[22].setVerts(19,12,20);
    mesh.faces[22].setEdgeVisFlags(1,0,1);
    mesh.faces[22].setSmGroup(1);
    mesh.faces[23].setVerts(20,12,13);
    mesh.faces[23].setEdgeVisFlags(0,1,1);
    mesh.faces[23].setSmGroup(1);
    mesh.faces[24].setVerts(20,13,21);
    mesh.faces[24].setEdgeVisFlags(1,0,1);
    mesh.faces[24].setSmGroup(1);
    mesh.faces[25].setVerts(21,13,14);
    mesh.faces[25].setEdgeVisFlags(0,1,1);
    mesh.faces[25].setSmGroup(1);
    mesh.faces[26].setVerts(21,14,22);
    mesh.faces[26].setEdgeVisFlags(1,0,1);
    mesh.faces[26].setSmGroup(1);
    mesh.faces[27].setVerts(22,14,15);
    mesh.faces[27].setEdgeVisFlags(0,1,1);
    mesh.faces[27].setSmGroup(1);
    mesh.faces[28].setVerts(22,15,23);
    mesh.faces[28].setEdgeVisFlags(1,0,1);
    mesh.faces[28].setSmGroup(1);
    mesh.faces[29].setVerts(23,15,16);
    mesh.faces[29].setEdgeVisFlags(0,1,1);
    mesh.faces[29].setSmGroup(1);
    mesh.faces[30].setVerts(23,16,24);
    mesh.faces[30].setEdgeVisFlags(1,0,1);
    mesh.faces[30].setSmGroup(1);
    mesh.faces[31].setVerts(24,16,17);
    mesh.faces[31].setEdgeVisFlags(0,1,1);
    mesh.faces[31].setSmGroup(1);
    mesh.faces[32].setVerts(24,17,18);
    mesh.faces[32].setEdgeVisFlags(1,0,1);
    mesh.faces[32].setSmGroup(1);
    mesh.faces[33].setVerts(18,17,11);
    mesh.faces[33].setEdgeVisFlags(0,1,1);
    mesh.faces[33].setSmGroup(1);
    mesh.faces[34].setVerts(19,25,18);
    mesh.faces[34].setEdgeVisFlags(1,1,1);
    mesh.faces[34].setSmGroup(2);
    mesh.faces[35].setVerts(20,25,19);
    mesh.faces[35].setEdgeVisFlags(1,1,1);
    mesh.faces[35].setSmGroup(2);
    mesh.faces[36].setVerts(21,25,20);
    mesh.faces[36].setEdgeVisFlags(1,1,1);
    mesh.faces[36].setSmGroup(2);
    mesh.faces[37].setVerts(22,25,21);
    mesh.faces[37].setEdgeVisFlags(1,1,1);
    mesh.faces[37].setSmGroup(2);
    mesh.faces[38].setVerts(23,25,22);
    mesh.faces[38].setEdgeVisFlags(1,1,1);
    mesh.faces[38].setSmGroup(2);
    mesh.faces[39].setVerts(24,25,23);
    mesh.faces[39].setEdgeVisFlags(1,1,1);
    mesh.faces[39].setSmGroup(2);
    mesh.faces[40].setVerts(18,25,24);
    mesh.faces[40].setEdgeVisFlags(1,1,1);
    mesh.faces[40].setSmGroup(2);
    mesh.faces[41].setVerts(26,27,28);
    mesh.faces[41].setEdgeVisFlags(1,1,1);
    mesh.faces[41].setSmGroup(1);
    mesh.faces[42].setVerts(26,28,29);
    mesh.faces[42].setEdgeVisFlags(1,1,1);
    mesh.faces[42].setSmGroup(1);
    mesh.faces[43].setVerts(26,29,30);
    mesh.faces[43].setEdgeVisFlags(1,1,1);
    mesh.faces[43].setSmGroup(1);
    mesh.faces[44].setVerts(26,30,31);
    mesh.faces[44].setEdgeVisFlags(1,1,1);
    mesh.faces[44].setSmGroup(1);
    mesh.faces[45].setVerts(26,31,32);
    mesh.faces[45].setEdgeVisFlags(1,1,1);
    mesh.faces[45].setSmGroup(1);
    mesh.faces[46].setVerts(26,32,33);
    mesh.faces[46].setEdgeVisFlags(1,1,1);
    mesh.faces[46].setSmGroup(1);
    mesh.faces[47].setVerts(26,33,27);
    mesh.faces[47].setEdgeVisFlags(1,1,1);
    mesh.faces[47].setSmGroup(1);
    mesh.faces[48].setVerts(27,34,35);
    mesh.faces[48].setEdgeVisFlags(1,1,0);
    mesh.faces[48].setSmGroup(1);
    mesh.faces[49].setVerts(27,35,28);
    mesh.faces[49].setEdgeVisFlags(0,1,1);
    mesh.faces[49].setSmGroup(1);
    mesh.faces[50].setVerts(28,35,36);
    mesh.faces[50].setEdgeVisFlags(1,1,0);
    mesh.faces[50].setSmGroup(1);
    mesh.faces[51].setVerts(28,36,29);
    mesh.faces[51].setEdgeVisFlags(0,1,1);
    mesh.faces[51].setSmGroup(1);
    mesh.faces[52].setVerts(29,36,37);
    mesh.faces[52].setEdgeVisFlags(1,1,0);
    mesh.faces[52].setSmGroup(1);
    mesh.faces[53].setVerts(29,37,30);
    mesh.faces[53].setEdgeVisFlags(0,1,1);
    mesh.faces[53].setSmGroup(1);
    mesh.faces[54].setVerts(30,37,38);
    mesh.faces[54].setEdgeVisFlags(1,1,0);
    mesh.faces[54].setSmGroup(1);
    mesh.faces[55].setVerts(30,38,31);
    mesh.faces[55].setEdgeVisFlags(0,1,1);
    mesh.faces[55].setSmGroup(1);
    mesh.faces[56].setVerts(31,38,39);
    mesh.faces[56].setEdgeVisFlags(1,1,0);
    mesh.faces[56].setSmGroup(1);
    mesh.faces[57].setVerts(31,39,32);
    mesh.faces[57].setEdgeVisFlags(0,1,1);
    mesh.faces[57].setSmGroup(1);
    mesh.faces[58].setVerts(32,39,40);
    mesh.faces[58].setEdgeVisFlags(1,1,0);
    mesh.faces[58].setSmGroup(1);
    mesh.faces[59].setVerts(32,40,33);
    mesh.faces[59].setEdgeVisFlags(0,1,1);
    mesh.faces[59].setSmGroup(1);
    mesh.faces[60].setVerts(33,40,34);
    mesh.faces[60].setEdgeVisFlags(1,1,0);
    mesh.faces[60].setSmGroup(1);
    mesh.faces[61].setVerts(33,34,27);
    mesh.faces[61].setEdgeVisFlags(0,1,1);
    mesh.faces[61].setSmGroup(1);
    mesh.faces[62].setVerts(41,35,34);
    mesh.faces[62].setEdgeVisFlags(1,1,1);
    mesh.faces[62].setSmGroup(2);
    mesh.faces[63].setVerts(41,36,35);
    mesh.faces[63].setEdgeVisFlags(1,1,1);
    mesh.faces[63].setSmGroup(2);
    mesh.faces[64].setVerts(41,37,36);
    mesh.faces[64].setEdgeVisFlags(1,1,1);
    mesh.faces[64].setSmGroup(2);
    mesh.faces[65].setVerts(41,38,37);
    mesh.faces[65].setEdgeVisFlags(1,1,1);
    mesh.faces[65].setSmGroup(2);
    mesh.faces[66].setVerts(41,39,38);
    mesh.faces[66].setEdgeVisFlags(1,1,1);
    mesh.faces[66].setSmGroup(2);
    mesh.faces[67].setVerts(41,40,39);
    mesh.faces[67].setEdgeVisFlags(1,1,1);
    mesh.faces[67].setSmGroup(2);
    mesh.faces[68].setVerts(41,34,40);
    mesh.faces[68].setEdgeVisFlags(1,1,1);
    mesh.faces[68].setSmGroup(2);
    mesh.faces[69].setVerts(42,44,43);
    mesh.faces[69].setEdgeVisFlags(0,1,0);
    mesh.faces[69].setSmGroup(1);
    mesh.faces[70].setVerts(42,45,44);
    mesh.faces[70].setEdgeVisFlags(0,1,0);
    mesh.faces[70].setSmGroup(1);
    mesh.faces[71].setVerts(42,43,45);
    mesh.faces[71].setEdgeVisFlags(0,1,0);
    mesh.faces[71].setSmGroup(1);
    mesh.faces[72].setVerts(43,47,46);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(8);
    mesh.faces[73].setVerts(43,44,47);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(8);
    mesh.faces[74].setVerts(44,48,47);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(8);
    mesh.faces[75].setVerts(44,45,48);
    mesh.faces[75].setEdgeVisFlags(1,1,0);
    mesh.faces[75].setSmGroup(8);
    mesh.faces[76].setVerts(45,46,48);
    mesh.faces[76].setEdgeVisFlags(0,1,1);
    mesh.faces[76].setSmGroup(8);
    mesh.faces[77].setVerts(45,43,46);
    mesh.faces[77].setEdgeVisFlags(1,1,0);
    mesh.faces[77].setSmGroup(8);
    mesh.faces[78].setVerts(49,46,47);
    mesh.faces[78].setEdgeVisFlags(0,1,0);
    mesh.faces[78].setSmGroup(1);
    mesh.faces[79].setVerts(49,47,48);
    mesh.faces[79].setEdgeVisFlags(0,1,0);
    mesh.faces[79].setSmGroup(1);
    mesh.faces[80].setVerts(49,48,46);
    mesh.faces[80].setEdgeVisFlags(0,1,0);
    mesh.faces[80].setSmGroup(1);
    mesh.faces[81].setVerts(50,52,51);
    mesh.faces[81].setEdgeVisFlags(0,1,0);
    mesh.faces[81].setSmGroup(1);
    mesh.faces[82].setVerts(50,53,52);
    mesh.faces[82].setEdgeVisFlags(0,1,0);
    mesh.faces[82].setSmGroup(1);
    mesh.faces[83].setVerts(50,51,53);
    mesh.faces[83].setEdgeVisFlags(0,1,0);
    mesh.faces[83].setSmGroup(1);
    mesh.faces[84].setVerts(51,55,54);
    mesh.faces[84].setEdgeVisFlags(0,1,1);
    mesh.faces[84].setSmGroup(8);
    mesh.faces[85].setVerts(51,52,55);
    mesh.faces[85].setEdgeVisFlags(1,1,0);
    mesh.faces[85].setSmGroup(8);
    mesh.faces[86].setVerts(52,56,55);
    mesh.faces[86].setEdgeVisFlags(0,1,1);
    mesh.faces[86].setSmGroup(8);
    mesh.faces[87].setVerts(52,53,56);
    mesh.faces[87].setEdgeVisFlags(1,1,0);
    mesh.faces[87].setSmGroup(8);
    mesh.faces[88].setVerts(53,54,56);
    mesh.faces[88].setEdgeVisFlags(0,1,1);
    mesh.faces[88].setSmGroup(8);
    mesh.faces[89].setVerts(53,51,54);
    mesh.faces[89].setEdgeVisFlags(1,1,0);
    mesh.faces[89].setSmGroup(8);
    mesh.faces[90].setVerts(57,54,55);
    mesh.faces[90].setEdgeVisFlags(0,1,0);
    mesh.faces[90].setSmGroup(1);
    mesh.faces[91].setVerts(57,55,56);
    mesh.faces[91].setEdgeVisFlags(0,1,0);
    mesh.faces[91].setSmGroup(1);
    mesh.faces[92].setVerts(57,56,54);
    mesh.faces[92].setEdgeVisFlags(0,1,0);
    mesh.faces[92].setSmGroup(1);
    mesh.faces[93].setVerts(58,60,59);
    mesh.faces[93].setEdgeVisFlags(0,1,0);
    mesh.faces[93].setSmGroup(1);
    mesh.faces[94].setVerts(58,61,60);
    mesh.faces[94].setEdgeVisFlags(0,1,0);
    mesh.faces[94].setSmGroup(1);
    mesh.faces[95].setVerts(58,62,61);
    mesh.faces[95].setEdgeVisFlags(0,1,0);
    mesh.faces[95].setSmGroup(1);
    mesh.faces[96].setVerts(58,63,62);
    mesh.faces[96].setEdgeVisFlags(0,1,0);
    mesh.faces[96].setSmGroup(1);
    mesh.faces[97].setVerts(58,64,63);
    mesh.faces[97].setEdgeVisFlags(0,1,0);
    mesh.faces[97].setSmGroup(1);
    mesh.faces[98].setVerts(58,65,64);
    mesh.faces[98].setEdgeVisFlags(0,1,0);
    mesh.faces[98].setSmGroup(1);
    mesh.faces[99].setVerts(58,66,65);
    mesh.faces[99].setEdgeVisFlags(0,1,0);
    mesh.faces[99].setSmGroup(1);
    mesh.faces[100].setVerts(58,67,66);
    mesh.faces[100].setEdgeVisFlags(0,1,0);
    mesh.faces[100].setSmGroup(1);
    mesh.faces[101].setVerts(58,68,67);
    mesh.faces[101].setEdgeVisFlags(0,1,0);
    mesh.faces[101].setSmGroup(1);
    mesh.faces[102].setVerts(58,59,68);
    mesh.faces[102].setEdgeVisFlags(0,1,0);
    mesh.faces[102].setSmGroup(1);
    mesh.faces[103].setVerts(59,70,69);
    mesh.faces[103].setEdgeVisFlags(0,1,1);
    mesh.faces[103].setSmGroup(8);
    mesh.faces[104].setVerts(59,60,70);
    mesh.faces[104].setEdgeVisFlags(1,1,0);
    mesh.faces[104].setSmGroup(8);
    mesh.faces[105].setVerts(60,71,70);
    mesh.faces[105].setEdgeVisFlags(0,1,1);
    mesh.faces[105].setSmGroup(8);
    mesh.faces[106].setVerts(60,61,71);
    mesh.faces[106].setEdgeVisFlags(1,1,0);
    mesh.faces[106].setSmGroup(8);
    mesh.faces[107].setVerts(61,72,71);
    mesh.faces[107].setEdgeVisFlags(0,1,1);
    mesh.faces[107].setSmGroup(8);
    mesh.faces[108].setVerts(61,62,72);
    mesh.faces[108].setEdgeVisFlags(1,1,0);
    mesh.faces[108].setSmGroup(8);
    mesh.faces[109].setVerts(62,73,72);
    mesh.faces[109].setEdgeVisFlags(0,1,1);
    mesh.faces[109].setSmGroup(8);
    mesh.faces[110].setVerts(62,63,73);
    mesh.faces[110].setEdgeVisFlags(1,1,0);
    mesh.faces[110].setSmGroup(8);
    mesh.faces[111].setVerts(63,74,73);
    mesh.faces[111].setEdgeVisFlags(0,1,1);
    mesh.faces[111].setSmGroup(8);
    mesh.faces[112].setVerts(63,64,74);
    mesh.faces[112].setEdgeVisFlags(1,1,0);
    mesh.faces[112].setSmGroup(8);
    mesh.faces[113].setVerts(64,75,74);
    mesh.faces[113].setEdgeVisFlags(0,1,1);
    mesh.faces[113].setSmGroup(8);
    mesh.faces[114].setVerts(64,65,75);
    mesh.faces[114].setEdgeVisFlags(1,1,0);
    mesh.faces[114].setSmGroup(8);
    mesh.faces[115].setVerts(65,76,75);
    mesh.faces[115].setEdgeVisFlags(0,1,1);
    mesh.faces[115].setSmGroup(8);
    mesh.faces[116].setVerts(65,66,76);
    mesh.faces[116].setEdgeVisFlags(1,1,0);
    mesh.faces[116].setSmGroup(8);
    mesh.faces[117].setVerts(66,77,76);
    mesh.faces[117].setEdgeVisFlags(0,1,1);
    mesh.faces[117].setSmGroup(8);
    mesh.faces[118].setVerts(66,67,77);
    mesh.faces[118].setEdgeVisFlags(1,1,0);
    mesh.faces[118].setSmGroup(8);
    mesh.faces[119].setVerts(67,78,77);
    mesh.faces[119].setEdgeVisFlags(0,1,1);
    mesh.faces[119].setSmGroup(8);
    mesh.faces[120].setVerts(67,68,78);
    mesh.faces[120].setEdgeVisFlags(1,1,0);
    mesh.faces[120].setSmGroup(8);
    mesh.faces[121].setVerts(68,69,78);
    mesh.faces[121].setEdgeVisFlags(0,1,1);
    mesh.faces[121].setSmGroup(8);
    mesh.faces[122].setVerts(68,59,69);
    mesh.faces[122].setEdgeVisFlags(1,1,0);
    mesh.faces[122].setSmGroup(8);
    mesh.faces[123].setVerts(79,69,70);
    mesh.faces[123].setEdgeVisFlags(0,1,0);
    mesh.faces[123].setSmGroup(1);
    mesh.faces[124].setVerts(79,70,71);
    mesh.faces[124].setEdgeVisFlags(0,1,0);
    mesh.faces[124].setSmGroup(1);
    mesh.faces[125].setVerts(79,71,72);
    mesh.faces[125].setEdgeVisFlags(0,1,0);
    mesh.faces[125].setSmGroup(1);
    mesh.faces[126].setVerts(79,72,73);
    mesh.faces[126].setEdgeVisFlags(0,1,0);
    mesh.faces[126].setSmGroup(1);
    mesh.faces[127].setVerts(79,73,74);
    mesh.faces[127].setEdgeVisFlags(0,1,0);
    mesh.faces[127].setSmGroup(1);
    mesh.faces[128].setVerts(79,74,75);
    mesh.faces[128].setEdgeVisFlags(0,1,0);
    mesh.faces[128].setSmGroup(1);
    mesh.faces[129].setVerts(79,75,76);
    mesh.faces[129].setEdgeVisFlags(0,1,0);
    mesh.faces[129].setSmGroup(1);
    mesh.faces[130].setVerts(79,76,77);
    mesh.faces[130].setEdgeVisFlags(0,1,0);
    mesh.faces[130].setSmGroup(1);
    mesh.faces[131].setVerts(79,77,78);
    mesh.faces[131].setEdgeVisFlags(0,1,0);
    mesh.faces[131].setSmGroup(1);
    mesh.faces[132].setVerts(79,78,69);
    mesh.faces[132].setEdgeVisFlags(0,1,0);
    mesh.faces[132].setSmGroup(1);
    mesh.faces[133].setVerts(82,80,81);
    mesh.faces[133].setEdgeVisFlags(0,0,1);
    mesh.faces[133].setSmGroup(1);
    mesh.faces[134].setVerts(83,80,82);
    mesh.faces[134].setEdgeVisFlags(0,0,1);
    mesh.faces[134].setSmGroup(1);
    mesh.faces[135].setVerts(81,80,83);
    mesh.faces[135].setEdgeVisFlags(0,0,1);
    mesh.faces[135].setSmGroup(1);
    mesh.faces[136].setVerts(85,81,84);
    mesh.faces[136].setEdgeVisFlags(0,1,1);
    mesh.faces[136].setSmGroup(8);
    mesh.faces[137].setVerts(82,81,85);
    mesh.faces[137].setEdgeVisFlags(1,0,1);
    mesh.faces[137].setSmGroup(8);
    mesh.faces[138].setVerts(86,82,85);
    mesh.faces[138].setEdgeVisFlags(0,1,1);
    mesh.faces[138].setSmGroup(8);
    mesh.faces[139].setVerts(83,82,86);
    mesh.faces[139].setEdgeVisFlags(1,0,1);
    mesh.faces[139].setSmGroup(8);
    mesh.faces[140].setVerts(84,83,86);
    mesh.faces[140].setEdgeVisFlags(0,1,1);
    mesh.faces[140].setSmGroup(8);
    mesh.faces[141].setVerts(81,83,84);
    mesh.faces[141].setEdgeVisFlags(1,0,1);
    mesh.faces[141].setSmGroup(8);
    mesh.faces[142].setVerts(84,87,85);
    mesh.faces[142].setEdgeVisFlags(0,0,1);
    mesh.faces[142].setSmGroup(1);
    mesh.faces[143].setVerts(85,87,86);
    mesh.faces[143].setEdgeVisFlags(0,0,1);
    mesh.faces[143].setSmGroup(1);
    mesh.faces[144].setVerts(86,87,84);
    mesh.faces[144].setEdgeVisFlags(0,0,1);
    mesh.faces[144].setSmGroup(1);
    mesh.faces[145].setVerts(88,90,89);
    mesh.faces[145].setEdgeVisFlags(0,1,0);
    mesh.faces[145].setSmGroup(1);
    mesh.faces[146].setVerts(88,91,90);
    mesh.faces[146].setEdgeVisFlags(0,1,0);
    mesh.faces[146].setSmGroup(1);
    mesh.faces[147].setVerts(88,89,91);
    mesh.faces[147].setEdgeVisFlags(0,1,0);
    mesh.faces[147].setSmGroup(1);
    mesh.faces[148].setVerts(89,93,92);
    mesh.faces[148].setEdgeVisFlags(0,1,1);
    mesh.faces[148].setSmGroup(8);
    mesh.faces[149].setVerts(89,90,93);
    mesh.faces[149].setEdgeVisFlags(1,1,0);
    mesh.faces[149].setSmGroup(8);
    mesh.faces[150].setVerts(90,94,93);
    mesh.faces[150].setEdgeVisFlags(0,1,1);
    mesh.faces[150].setSmGroup(8);
    mesh.faces[151].setVerts(90,91,94);
    mesh.faces[151].setEdgeVisFlags(1,1,0);
    mesh.faces[151].setSmGroup(8);
    mesh.faces[152].setVerts(91,92,94);
    mesh.faces[152].setEdgeVisFlags(0,1,1);
    mesh.faces[152].setSmGroup(8);
    mesh.faces[153].setVerts(91,89,92);
    mesh.faces[153].setEdgeVisFlags(1,1,0);
    mesh.faces[153].setSmGroup(8);
    mesh.faces[154].setVerts(95,92,93);
    mesh.faces[154].setEdgeVisFlags(0,1,0);
    mesh.faces[154].setSmGroup(1);
    mesh.faces[155].setVerts(95,93,94);
    mesh.faces[155].setEdgeVisFlags(0,1,0);
    mesh.faces[155].setSmGroup(1);
    mesh.faces[156].setVerts(95,94,92);
    mesh.faces[156].setEdgeVisFlags(0,1,0);
    mesh.faces[156].setSmGroup(1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\EvalCol.h ===
/**********************************************************************
 *<
	FILE:			EvalCpolor.cpp
	DESCRIPTION:	Vertex Color Renderer
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, December 12, 1996

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/
//
// Description:
// These functions calculates the diffuse or ambient color at each vertex
// or face of an INode.
//
// Exports:
// BOOL calcMixedVertexColors(INode*, TimeValue, int, ColorTab&, EvalColProgressCallback* callb = NULL);
//      This function calculates the interpolated diffuse or ambient 
//      color at each vertex of an INode.
//      Usage: Pass in a node pointer and the TimeValue to generate
//      a list of Colors corresponding to each vertex in the mesh
//      Use the int flag to specify if you want to have diffuse or 
//      ambient colors, or if you want to use the lights in the scene.
//      Note: 
//        You are responsible for deleting the Color objects in the table.
//      Additional note:
//        Since materials are assigned by face, this function renders each
//        face connected to the specific vertex (at the point of the vertex)
//        and then mixes the colors.
//
//***************************************************************************

#define LIGHT_AMBIENT		0x00
#define LIGHT_DIFFUSE		0x01
#define LIGHT_SCENELIGHT	0x02

typedef Tab<Color*> ColorTab;

class SingleVertexColor {
public:
	~SingleVertexColor();
	ColorTab vertexColors;
};

typedef Tab<SingleVertexColor*> VertexColorTab;
typedef BOOL (*EVALCOL_PROGRESS)(float);

class EvalColProgressCallback {
public:
	virtual BOOL progress(float prog) = 0;
};

BOOL calcMixedVertexColors(INode* node, TimeValue t, int lightModel, ColorTab& vxColTab, EvalColProgressCallback* callb = NULL);
BOOL calcVertexColors(INode* node, TimeValue t, int lightModel, VertexColorTab& vxColTab, EvalColProgressCallback* callb = NULL);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\EvalCol.cpp ===
/**********************************************************************
 *<
	FILE:			EvalCol.cpp
	DESCRIPTION:	Vertex Color Renderer
	CREATED BY:		Christer Janson
	HISTORY:		Created Monday, December 12, 1996

 *>	Copyright (c) 1997 Kinetix, All Rights Reserved.
 **********************************************************************/
//***************************************************************************
// December 12/13   1996	CCJ
// January  8		1997	CCJ  Bugfix
// June		1		1997	CCJ  Port to MAX 2.0
// June		6		1997	CCJ  Implemented full ShadeContext
//
// Description:
// These functions calculates the diffuse, ambient or pre-lit color at each
// vertex or face of an INode.
//
// Exports:
// BOOL calcMixedVertexColors(INode*, TimeValue, int, ColorTab&);
//      This function calculates the interpolated diffuse or ambient 
//      color at each vetex of an INode.
//      Usage: Pass in a node pointer and the TimeValue to generate
//      a list of Colors corresponding to each vertex in the mesh
//      Use the int flag to specify if you want to have diffuse or 
//      ambient colors, or if you want to use the scene lights.
//      Note: 
//        You are responsible for deleting the Color objects in the table.
//      Additional note:
//        Since materials are assigned by face, this function renders each
//        face connected to the specific vertex (at the point of the vertex)
//        and mixes the colors afterwards. If this is not what you want
//        you can use the calcFaceColors() to calculate the color at the
//        centerpoint of each face.
//
//***************************************************************************

#include "max.h"
#include "bmmlib.h"
#include "evalcol.h"

// Enable this to print out debug information
// #define EVALCOL_DEBUG

class SContext;
class RefEnumProc;

Point3 interpVertexNormal(Mesh* mesh, Matrix3 tm, unsigned int vxNo, BitArray& faceList);
void AddSceneLights(SContext* sc, MtlBaseLib* mtls);
int LoadMapFiles(INode* node, SContext* sc, MtlBaseLib& mtls, TimeValue t);
void EnumRefs(ReferenceMaker *rm, RefEnumProc &proc);

SingleVertexColor::~SingleVertexColor()
{
	for (int i=0; i<vertexColors.Count(); i++) {
		delete vertexColors[i];
	}
}

//***************************************************************************
//* The is the map enumerator class used for collecting projector lights for
//* spotlights
//***************************************************************************

class GetMaps: public RefEnumProc {
	MtlBaseLib *mlib;
	public:
	void proc(ReferenceMaker *rm);
	GetMaps(MtlBaseLib *mbl);
};

//***************************************************************************
//* The is the Light descriptor object for default lights
//***************************************************************************
class DefObjLight : public ObjLightDesc 
{
	public:
		Color intensCol;   // intens*color 
		DefObjLight(DefaultLight *l);
		void DeleteThis() {delete this;}
		int Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged);
		int UpdateViewDepParams(const Matrix3& worldToCam);
		BOOL Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float &diffCoef);
};

class LightInfo {
public:
	LightInfo(INode* node, MtlBaseLib* mtls);
	LightInfo(DefaultLight* l);
	~LightInfo();

	ObjLightDesc* lightDesc;
	LightObject *light;
};

typedef Tab<LightInfo*> LightTab;

//***************************************************************************
//* RendContext is used to evaluate the lights
//***************************************************************************

 class RContext: public RendContext {
	public:
		Matrix3	WorldToCam() const { return Matrix3(1); }
		ShadowBuffer*	NewShadowBuffer() const;
		ShadowQuadTree*	NewShadowQuadTree() const;
		Color	GlobalLightLevel() const;
		int	Progress(int done, int total) {
			return 1;
		}
};

//***************************************************************************
// ShadeContext for evaluating materials
//***************************************************************************

class SContext : public ShadeContext {
public:
	SContext();
	~SContext();

	TimeValue CurTime();
	int NodeID();
	INode* Node();
	Point3 BarycentricCoords();
	int FaceNumber();
	Point3 Normal();
	float Curve();

	LightDesc*	Light(int lightNo);
	Point3	GNormal(void);
	Point3	ReflectVector(void);
	Point3	RefractVector(float ior);
	Point3	CamPos(void);
	Point3	V(void);
	Point3	P(void);
	Point3	DP(void);
	Point3	PObj(void);
	Point3	DPObj(void);
	Box3	ObjectBox(void);
	Point3	PObjRelBox(void);
	Point3	DPObjRelBox(void);
	void	ScreenUV(Point2 &uv,Point2 &duv);
	IPoint2	ScreenCoord(void);
	Point3	UVW(int chan);
	Point3	DUVW(int chan);
	void	DPdUVW(Point3 [], int chan);
	void	GetBGColor(Color &bgCol, Color &transp, int fogBG);
	Point3	PointTo(const Point3 &p, RefFrame ito);
	Point3	PointFrom(const Point3 &p, RefFrame ito);
	Point3	VectorTo(const Point3 &p, RefFrame ito);
	Point3	VectorFrom(const Point3 &p, RefFrame ito);
	int		InMtlEditor();
	void	SetView(Point3 v);

	int		ProjType();
	void	SetNodeAndTime(INode* n, TimeValue tm);
	void	SetMesh(Mesh* m);
	void	SetBaryCoord(Point3 bary);
	void	SetFaceNum(int f);
	void	SetMtlNum(int mNo);
	void	SetTargetPoint(Point3 tp);
	void	SetViewPoint(Point3 vp);
	void	SetViewDir(Point3 vd);
	void	CalcNormals();
	void	CalcBoundObj();
	void	ClearLights();
	void	AddLight(LightInfo* li);
	void	SetAmbientLight(Color c);
	void	UpdateLights();
	void	calc_size_ratio();
	float	RayDiam() {return 0.1f;}
	void	getTVerts(int chan);
	void	getObjVerts();

public:
	LightTab lightTab;
Matrix3 tmAfterWSM;
	 
private:
	INode* node;
	Mesh* mesh;
	Point3 baryCoord;
	int faceNum;
	Point3 targetPt;
	Point3 viewDir;
	Point3 viewPoint;
	TimeValue t;
	Point3 vxNormals[3];
	UVVert tv[2][3];
	Point3 bumpv[2][3];
	Box3 boundingObj;
	RContext rc;
	Point3	obpos[3];
	Point3	dobpos;
	float ratio;
	float curve;
};

//***************************************************************************
//* Dummy Material : Simple Phong shader using Node color
//* This material is assigned to each node that does not have a material
//* previously assigned. The diffuse color is assigned based on the 
//* wireframe color.
//* This way we can assume that all nodes have a material assigned.
//***************************************************************************

#define DUMMTL_CLASS_ID	Class_ID(0x4efd2694, 0x37c809f4)

#define DUMSHINE .25f
#define DUMSPEC .50f

class DumMtl: public Mtl {
	Color diff, spec;
	float phongexp;
	public:
		DumMtl(Color c);
		void Update(TimeValue t, Interval& valid);
		void Reset();
		Interval Validity(TimeValue t);
		ParamDlg* CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp);
		Color GetAmbient(int mtlNum=0, BOOL backFace=FALSE);
		Color GetDiffuse(int mtlNum=0, BOOL backFace=FALSE);
		Color GetSpecular(int mtlNum=0, BOOL backFace=FALSE);
		float GetShininess(int mtlNum=0, BOOL backFace=FALSE);
		float GetShinStr(int mtlNum=0, BOOL backFace=FALSE);
		float GetXParency(int mtlNum=0, BOOL backFace=FALSE);
		void SetAmbient(Color c, TimeValue t);
		void SetDiffuse(Color c, TimeValue t);
		void SetSpecular(Color c, TimeValue t);
		void SetShininess(float v, TimeValue t);
		Class_ID ClassID();
		void DeleteThis();
    	RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message);
		void Shade(ShadeContext& sc);
};


// Return a pointer to a TriObject given an INode or return NULL
// if the node cannot be converted to a TriObject
TriObject* GetTriObjectFromNode(INode *node, TimeValue t, int &deleteIt)
{
	deleteIt = FALSE;
	Object *obj = node->EvalWorldState(t).obj;
	if (obj->CanConvertToType(Class_ID(TRIOBJ_CLASS_ID, 0))) { 
		TriObject *tri = (TriObject *) obj->ConvertToType(t, 
			Class_ID(TRIOBJ_CLASS_ID, 0));
		// Note that the TriObject should only be deleted
		// if the pointer to it is not equal to the object
		// pointer that called ConvertToType()
		if (obj != tri) deleteIt = TRUE;
		return tri;
	}
	else {
		return NULL;
	}
}

//***************************************************************************
// Calculate ambient or diffuse color at each vertex.
//***************************************************************************
BOOL calcVertexColors(INode* node, TimeValue t, int lightModel, VertexColorTab& vxColTab, EvalColProgressCallback* fn)
{
	ObjectState ostate;
	BOOL deleteTri;
	Mesh* mesh;
	SContext sc;
	DefaultLight dl1, dl2;
	MtlBaseLib mtls;
	Matrix3 tm;

	sc.SetNodeAndTime(node, t);
	tm = sc.tmAfterWSM;

	TriObject* tri = GetTriObjectFromNode(node, t, deleteTri);

	// We will only work on GeomObjects
	if (!tri) {
		return FALSE;
	}

	// Get the mesh from the object
	mesh = &tri->GetMesh();
	if (!mesh) {
		return FALSE;
	}

	// If the node doesn't have a material attached,
	// we create a dummy material.
	Mtl* mtl = node->GetMtl();
	if (!mtl) {
		mtl = new DumMtl(node->GetWireColor());
	}

	mesh->buildRenderNormals();

	vxColTab.ZeroCount();
	vxColTab.Shrink();

	sc.SetMesh(mesh);
	sc.CalcBoundObj();

	// Add the material to the list
	mtls.AddMtl(mtl);

	// Setup ambient light
	if (lightModel == LIGHT_AMBIENT) {
		sc.SetAmbientLight(Color(1.0f, 1.0f, 1.0f));
	}
	else {
		sc.SetAmbientLight(Color(0.0f, 0.0f, 0.0f));
	}

	// If we're using the real lights, we need to find them first
	if (lightModel == LIGHT_SCENELIGHT) {
		AddSceneLights(&sc, &mtls);

		// Add default lights if there are no lights in the scene
		if (sc.lightTab.Count() == 0) {
			dl1.ls.intens = 1.0f;
			dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
			dl1.ls.type = OMNI_LGT;
			dl1.tm = TransMatrix(1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			dl2.ls.intens = 1.0f;
			dl2.ls.color = Color(0.8f, 0.8f, 0.8f);
			dl2.ls.type = OMNI_LGT;
			dl2.tm = TransMatrix(-1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			sc.AddLight(new LightInfo(&dl1));
			sc.AddLight(new LightInfo(&dl2));
		}

		sc.SetAmbientLight(GetCOREInterface()->GetAmbient(t, FOREVER));
	}

	sc.UpdateLights();
	// Update material
	mtl->Update(t, FOREVER);
	
	int numVerts = mesh->numVerts;
	for (unsigned int v = 0; v < (unsigned)numVerts; v++) {

		if (fn) {
			if (fn->progress(float(v)/float(numVerts))) {
				if (deleteTri) {
					delete tri;
				}

				mtls.Empty();

				if (mtl->ClassID() == DUMMTL_CLASS_ID) {
					delete mtl;
				}

				// What to return here is up for discussion.
				// 1) We are aborting so FALSE might be in order.
				// 2) We have calculated some colors. Let's use what we've got so far.
				return TRUE;
			}
		}

		BitArray faceList;
		faceList.SetSize(mesh->numFaces, 0);

		// Get vertex normal
		// We also pass in a BitArray that will be filled in with
		// to inform us to which faces this vertex belongs.
		// We could do this manually, but we need to do it to get
		// the vertex normal anyway so this is done to speed things
		// up a bit.
		Point3 vxNormal = interpVertexNormal(mesh, tm, v, faceList);
		Point3 viewDir = -vxNormal;
		Point3 viewPoint = tm*mesh->verts[v] + 5.0f*vxNormal;
		Point3 lightPos = viewPoint;
		Point3 viewTarget = tm*mesh->verts[v];

		// We now have a viewpoint and a view target.
		// Now we just have to shade this point on the mesh in order
		// to get it's color.
		// Note: 
		// Since materials are assigned on Face basis we need to render each
		// vertex as many times as it has connecting faces.

		SingleVertexColor* svc = new SingleVertexColor();
		
		for (int nf = 0; nf < faceList.GetSize(); nf++) {
			if (faceList[nf]) {
				// render vertex for this face.
				sc.SetViewPoint(viewPoint);
				sc.SetTargetPoint(viewTarget);
				sc.SetViewDir(viewDir);
				sc.SetFaceNum(nf);
				Face* f = &mesh->faces[nf];
				sc.SetMtlNum(f->getMatID());
				sc.CalcNormals();

				// Setup the barycentric coordinate
				if (mesh->faces[nf].v[0] == v)
					sc.SetBaryCoord(Point3(1.0f, 0.0f, 0.0f));
				else if (mesh->faces[nf].v[1] == v)
					sc.SetBaryCoord(Point3(0.0f, 1.0f, 0.0f));
				else if (mesh->faces[nf].v[2] == v)
					sc.SetBaryCoord(Point3(0.0f, 0.0f, 1.0f));

				// Use diffuse color instead of ambient
				// The only difference is that we create a special light
				// located at the viewpoint and we set the ambient light to black.
				if (lightModel == LIGHT_DIFFUSE) {
					dl1.ls.intens = 1.0f;
					dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
					dl1.ls.type = OMNI_LGT;
					dl1.tm = TransMatrix(lightPos);

					sc.ClearLights();
					sc.AddLight(new LightInfo(&dl1));
					sc.UpdateLights();
				}

				// Shade the vertex
				mtl->Shade(sc);

				Color* tmpCol = new Color();

				tmpCol->r += sc.out.c.r;
				tmpCol->g += sc.out.c.g;
				tmpCol->b += sc.out.c.b;

				tmpCol->ClampMinMax();

				svc->vertexColors.Append(1, &tmpCol, 2);
			}
		}

		// Append the Color to the table. If the array needs
		// to be realloc'ed, allocate extra space for 100 points.
		vxColTab.Append(1, &svc, 100);
	}

	// Some objects gives us a temporary mesh that we need to delete afterwards.
	if (deleteTri) {
		delete tri;
	}

	mtls.Empty();

	if (mtl->ClassID() == DUMMTL_CLASS_ID) {
		delete mtl;
	}

	return TRUE;
}



//***************************************************************************
// Calculate ambient or diffuse color at each vertex.
// Pass in TRUE as the "diffuse" parameter to calculate the diffuse color.
// If FALSE is passed in, ambient color is calculated.
//***************************************************************************
BOOL calcMixedVertexColors(INode* node, TimeValue t, int lightModel, ColorTab& vxColTab, EvalColProgressCallback* fn)
{
	ObjectState ostate;
	BOOL deleteTri;
	Mesh* mesh;
	SContext sc;
	DefaultLight dl1, dl2;
	MtlBaseLib mtls;
	Matrix3 tm;

	sc.SetNodeAndTime(node, t);
	tm = sc.tmAfterWSM;

	TriObject* tri = GetTriObjectFromNode(node, t, deleteTri);

	// We will only work on GeomObjects
	if (!tri) {
		return FALSE;
	}

	// Get the mesh from the object
	mesh = &tri->GetMesh();
	if (!mesh) {
		return FALSE;
	}

	// If the node doesn't have a material attached,
	// we create a dummy material.
	Mtl* mtl = node->GetMtl();
	if (!mtl) {
		mtl = new DumMtl(node->GetWireColor());
	}

	mesh->buildRenderNormals();

	vxColTab.ZeroCount();
	vxColTab.Shrink();

	sc.SetMesh(mesh);
	sc.CalcBoundObj();

	// Add the material to the list
	mtls.AddMtl(mtl);

	// Setup ambient light
	if (lightModel == LIGHT_AMBIENT) {
		sc.SetAmbientLight(Color(1.0f, 1.0f, 1.0f));
	}
	else {
		sc.SetAmbientLight(Color(0.0f, 0.0f, 0.0f));
	}

	// If we're using the real lights, we need to find them first
	if (lightModel == LIGHT_SCENELIGHT) {
		AddSceneLights(&sc, &mtls);

		// Add default lights if there are no lights in the scene
		if (sc.lightTab.Count() == 0) {
			dl1.ls.intens = 1.0f;
			dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
			dl1.ls.type = OMNI_LGT;
			dl1.tm = TransMatrix(1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			dl2.ls.intens = 1.0f;
			dl2.ls.color = Color(0.8f, 0.8f, 0.8f);
			dl2.ls.type = OMNI_LGT;
			dl2.tm = TransMatrix(-1000.0f * Point3(-900.0f, -1000.0f, 1500.0f));

			sc.AddLight(new LightInfo(&dl1));
			sc.AddLight(new LightInfo(&dl2));
		}

		sc.SetAmbientLight(GetCOREInterface()->GetAmbient(t, FOREVER));
	}

	sc.UpdateLights();
	// Update material
	mtl->Update(t, FOREVER);
	
	int numVerts = mesh->numVerts;
	for (unsigned int v = 0; v < (unsigned)numVerts; v++) {

		if (fn) {
			if (fn->progress(float(v)/float(numVerts))) {
				if (deleteTri) {
					delete tri;
				}

				mtls.Empty();

				if (mtl->ClassID() == DUMMTL_CLASS_ID) {
					delete mtl;
				}

				// What to return here is up for discussion.
				// 1) We are aborting so FALSE might be in order.
				// 2) We have calculated some colors. Let's use what we've got so far.
				return TRUE;
			}
		}

		// Create a new entry
		Color* vxCol = new Color;
		Point3 tmpCol(0.0f, 0.0f, 0.0f);

		int numShades = 0;
		BitArray faceList;
		faceList.SetSize(mesh->numFaces, 0);

		// Get vertex normal
		// We also pass in a BitArray that will be filled in with
		// to inform us to which faces this vertex belongs.
		// We could do this manually, but we need to do it to get
		// the vertex normal anyway so this is done to speed things
		// up a bit.
		Point3 vxNormal = interpVertexNormal(mesh, tm, v, faceList);
		Point3 viewDir = -vxNormal;
		Point3 viewPoint = tm*mesh->verts[v] + 5.0f*vxNormal;
		Point3 lightPos = viewPoint;
		Point3 viewTarget = tm*mesh->verts[v];

		// We now have a viewpoint and a view target.
		// Now we just have to shade this point on the mesh in order
		// to get it's color.
		// Note: 
		// Since materials are assigned on Face basis we need to render each
		// vertex as many times as it has connecting faces.
		// the colors collected are mixed to get the resulting
		// color at each vertex.
		
		for (int nf = 0; nf < faceList.GetSize(); nf++) {
			if (faceList[nf]) {
				// render vertex for this face.
				sc.SetViewPoint(viewPoint);
				sc.SetTargetPoint(viewTarget);
				sc.SetViewDir(viewDir);
				sc.SetFaceNum(nf);
				Face* f = &mesh->faces[nf];
				sc.SetMtlNum(f->getMatID());
				sc.CalcNormals();

				// Setup the barycentric coordinate
				if (mesh->faces[nf].v[0] == v)
					sc.SetBaryCoord(Point3(1.0f, 0.0f, 0.0f));
				else if (mesh->faces[nf].v[1] == v)
					sc.SetBaryCoord(Point3(0.0f, 1.0f, 0.0f));
				else if (mesh->faces[nf].v[2] == v)
					sc.SetBaryCoord(Point3(0.0f, 0.0f, 1.0f));

				// Use diffuse color instead of ambient
				// The only difference is that we create a special light
				// located at the viewpoint and we set the ambient light to black.
				if (lightModel == LIGHT_DIFFUSE) {
					dl1.ls.intens = 1.0f;
					dl1.ls.color = Color(0.8f, 0.8f, 0.8f);
					dl1.ls.type = OMNI_LGT;
					dl1.tm = TransMatrix(lightPos);

					sc.ClearLights();
					sc.AddLight(new LightInfo(&dl1));
					sc.UpdateLights();
				}


				// Shade the vertex
				mtl->Shade(sc);

				tmpCol.x += sc.out.c.r;
				tmpCol.y += sc.out.c.g;
				tmpCol.z += sc.out.c.b;
				numShades++;
			}
		}

		// The color mixes. We just add the colors together and 
		// then divide with as many colors as we added.
		if (numShades > 0) {
			tmpCol = tmpCol / (float)numShades;
		}

		
		vxCol->r = tmpCol.x;
		vxCol->g = tmpCol.y;
		vxCol->b = tmpCol.z;

		
		vxCol->ClampMinMax();

		
		// Append the Color to the table. If the array needs
		// to be realloc'ed, allocate extra space for 100 points.
		vxColTab.Append(1, &vxCol, 100);
	}

	// Some objects gives us a temporary mesh that we need to delete afterwards.
	if (deleteTri) {
		delete tri;
	}


	mtls.Empty();

	if (mtl->ClassID() == DUMMTL_CLASS_ID) {
		delete mtl;
	}

	return TRUE;
}


// Since vertices might have different normals depending on the face
// you are accessing it through, we get the normal for each face that
// connects to this vertex and interpolate these normals to get a single
// vertex normal fairly perpendicular to the mesh at the point of
// this vertex.
Point3 interpVertexNormal(Mesh* mesh, Matrix3 tm, unsigned int vxNo, BitArray& faceList)
{
	Point3 iNormal = Point3(0.0f, 0.0f, 0.0f);
	int numNormals = 0;

	for (int f = 0; f < mesh->numFaces; f++) {
		for (int fi = 0; fi < 3; fi++) {
			if (mesh->faces[f].v[fi] == vxNo) {
				Point3& fn = VectorTransform(tm, mesh->getFaceNormal(f));
				iNormal += fn;
				numNormals++;
				faceList.Set(f);
			}
		}
	}

	iNormal = iNormal / (float)numNormals;

	return Normalize(iNormal);
}


//***************************************************************************
// LightInfo encapsulates the light descriptor for standard and default lights
//***************************************************************************

LightInfo::LightInfo(INode* node, MtlBaseLib* mtls)
{
	ObjectState ostate = node->EvalWorldState(0);

	light = (LightObject*)ostate.obj;
	lightDesc = light->CreateLightDesc(node);

	// Process projector maps
	GetMaps getmaps(mtls);
	EnumRefs(light,getmaps);
}

LightInfo::LightInfo(DefaultLight* l)
{
	lightDesc = new DefObjLight(l);
	light = NULL;
}

LightInfo::~LightInfo()
{
	if (lightDesc) {
		delete lightDesc;
	}
}


//***************************************************************************
// Light Descriptor for the diffuse light we use
//***************************************************************************

DefObjLight::DefObjLight(DefaultLight *l) : ObjLightDesc(NULL)
{
	inode = NULL;
	ls = l->ls;
	lightToWorld = l->tm;
	worldToLight = Inverse(lightToWorld);
}


//***************************************************************************
// Update
//***************************************************************************

int DefObjLight::Update(TimeValue t, const RendContext& rc, RenderGlobalContext *rgc, BOOL shadows, BOOL shadowGeomChanged)
{
	intensCol  = ls.intens*ls.color;
	return 1;
}


//***************************************************************************
// Update viewdependent parameters
//***************************************************************************

int DefObjLight::UpdateViewDepParams(const Matrix3& worldToCam)
{
	lightToCam = lightToWorld * worldToCam;
	camToLight = Inverse(lightToCam);
	lightPos   = lightToCam.GetRow(3);  // light pos in camera space
	return 1;
}


//***************************************************************************
// Illuminate method for default lights
// This is a special illumination method in order to evaluate diffuse color
// only, with no specular etc.
//***************************************************************************

BOOL DefObjLight::Illuminate(ShadeContext& sc, Point3& normal, Color& color, Point3 &dir, float &dot_nl, float &diffCoef)
{
	dir = Normalize(lightPos-sc.P());
	diffCoef = dot_nl = DotProd(normal, dir);
	color = intensCol;

	return (dot_nl <= 0.0f) ? 0 : 1;
}

static inline Point3 pabs(Point3 p) { return Point3(fabs(p.x),fabs(p.y),fabs(p.z)); }

// The ShadeContext used to shade a material a a specific point.
// This ShadeContext is setup to have full ambient light and no other
// lights until you call SetLight(). This will cause the ambient light to
// go black.
SContext::SContext()
{
	mode = SCMODE_NORMAL;
	doMaps = TRUE;
	filterMaps = FALSE;
	shadow = FALSE;
	backFace = FALSE;
	ambientLight = Color(1.0f, 1.0f, 1.0f);
	mtlNum = 0;

	nLights = 0;
}

SContext::~SContext()
{
	ClearLights();
}


// When the mesh and face number is specified we calculate 
// and store the vertex normals
void SContext::CalcNormals()
{
	RVertex* rv[3];
	Face* f = &mesh->faces[faceNum];
	DWORD smGroup = f->smGroup;
	int numNormals;

	// Get the vertex normals
	for (int i = 0; i < 3; i++) {
		rv[i] = mesh->getRVertPtr(f->getVert(i));

		// Is normal specified
		// SPCIFIED is not currently used, but may be used in future versions.
		if (rv[i]->rFlags & SPECIFIED_NORMAL) {
			vxNormals[i] = rv[i]->rn.getNormal();
		}
		// If normal is not specified it's only available if the face belongs
		// to a smoothing group
		else if ((numNormals = rv[i]->rFlags & NORCT_MASK) && smGroup) {
			// If there is only one vertex is found in the rn member.
			if (numNormals == 1) {
				vxNormals[i] = rv[i]->rn.getNormal();
			}
			else {
				// If two or more vertices are there you need to step through them
				// and find the vertex with the same smoothing group as the current face.
				// You will find multiple normals in the ern member.
				for (int j = 0; j < numNormals; j++) {
					if (rv[i]->ern[j].getSmGroup() & smGroup) {
						vxNormals[i] = rv[i]->ern[j].getNormal();
					}
				}
			}
		}
		else {
			vxNormals[i] = mesh->getFaceNormal(faceNum);
		}
	}
	vxNormals[0] = Normalize(VectorTransform(tmAfterWSM, vxNormals[0]));
	vxNormals[1] = Normalize(VectorTransform(tmAfterWSM, vxNormals[1]));
	vxNormals[2] = Normalize(VectorTransform(tmAfterWSM, vxNormals[2]));
}

void SContext::SetBaryCoord(Point3 bary)
{
	baryCoord = bary;
}

int SContext::ProjType()
{
	return PROJ_PARALLEL;
}

void SContext::SetNodeAndTime(INode* n, TimeValue tv)
{
	node = n;
	t = tv;
	tmAfterWSM = node->GetObjTMAfterWSM(t,NULL);
}

void SContext::SetFaceNum(int f)
{
	faceNum = f;
}

void SContext::SetMtlNum(int mNo)
{
	mtlNum = mNo;
}

void SContext::SetViewPoint(Point3 vp)
{
	viewPoint = vp;
}

void SContext::SetTargetPoint(Point3 tp)
{
	targetPt = tp;
}

void SContext::SetViewDir(Point3 vd)
{
	viewDir = vd;
}

void SContext::SetMesh(Mesh * m)
{
	mesh = m;
}

void SContext::AddLight(LightInfo* li)
{
	lightTab.Append(1, &li);
}

void SContext::ClearLights()
{
	for (int i=0; i<lightTab.Count(); i++) {
		delete lightTab[i];
	}
	lightTab.ZeroCount();
	lightTab.Shrink();
	nLights = 0;
}

void SContext::UpdateLights()
{
	for (int i=0; i<lightTab.Count(); i++) {
		((LightInfo*)lightTab[i])->lightDesc->Update(t, rc, NULL, FALSE, TRUE);
		((LightInfo*)lightTab[i])->lightDesc->UpdateViewDepParams(Matrix3(1));
	}

	nLights = lightTab.Count();
}

void SContext::SetAmbientLight(Color c)
{
	ambientLight = c;
}

void SContext::CalcBoundObj()
{
	if (!mesh)
		return;

	boundingObj.Init();

	// Include each vertex in the bounding box
	for (int nf = 0; nf < mesh->numFaces; nf++) {
		Face* f = &(mesh->faces[nf]);

		boundingObj += mesh->getVert(f->getVert(0));
		boundingObj += mesh->getVert(f->getVert(1));
		boundingObj += mesh->getVert(f->getVert(2));
	}
}

// Return current time
TimeValue SContext::CurTime()
{
	return t;
}

int SContext::NodeID()
{
	return -1;
}

INode* SContext::Node()
{
	return node;
}

Point3 SContext::BarycentricCoords()
{
	return baryCoord;
}

int SContext::FaceNumber()
{
	return faceNum;
}


// Interpolated normal
Point3 SContext::Normal()
{
	return Normalize(baryCoord.x*vxNormals[0] + baryCoord.y*vxNormals[1] + baryCoord.z*vxNormals[2]);
}

// Geometric normal (face normal)
Point3 SContext::GNormal(void)
{
	// The face normals are already in camera space
	return VectorTransform(tmAfterWSM, mesh->getFaceNormal(faceNum));
}

// Return a Light descriptor
LightDesc *SContext::Light(int lightNo)
{
	return ((LightInfo*)lightTab[lightNo])->lightDesc;
}

// Return reflection vector at this point.
// We do it like this to avoid specular color to show up.
Point3 SContext::ReflectVector(void)
{
	return -Normal();
}

// Foley & vanDam: Computer Graphics: Principles and Practice, 
//     2nd Ed. pp 756ff.
Point3 SContext::RefractVector(float ior)
{
	Point3 N = Normal();
	float VN,nur,k;
	VN = DotProd(-viewDir,N);
	if (backFace) nur = ior;
	else nur = (ior!=0.0f) ? 1.0f/ior: 1.0f;
	k = 1.0f-nur*nur*(1.0f-VN*VN);
	if (k<=0.0f) {
		// Total internal reflection: 
		return ReflectVector();
	}
	else {
		return (nur*VN-(float)sqrt(k))*N + nur*viewDir;
	}
}

Point3 SContext::CamPos(void)
{
	return viewPoint;
}

// Screen coordinate beeing rendered
IPoint2 SContext::ScreenCoord(void)
{
	return IPoint2(0,0);
}

// Background color
void SContext::GetBGColor(class Color &bgCol,class Color &transp,int fogBG)
{
	bgCol = Color(0.0f, 0.0f, 0.0f);
	transp = Color(0.0f, 0.0f, 0.0f);
}

// Transforms the specified point from internal camera space to the specified space.
Point3 SContext::PointTo(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return Inverse(tmAfterWSM) * p;
	}

	return p;
}

// Transforms the specified point from the specified coordinate system
// to internal camera space.
Point3 SContext::PointFrom(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return tmAfterWSM * p;
	}
	return p;
}

// Transform the vector from internal camera space to the specified space.
Point3 SContext::VectorTo(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return VectorTransform(Inverse(tmAfterWSM), p);
	}
	return p;
}

// Transform the vector from the specified space to internal camera space.
Point3 SContext::VectorFrom(const class Point3 &p, RefFrame ito)
{
	if (ito==REF_OBJECT) {
		return VectorTransform(tmAfterWSM, p);
	}
	return p;
}

// This method returns the unit view vector, from the camera towards P,
// in camera space.
Point3 SContext::V(void)
{
	return viewDir;
}

// Returns the point to be shaded in camera space.
Point3 SContext::P(void)
{
	return targetPt;
}

// This returns the derivative of P, relative to the pixel.
// This gives the renderer or shader information about how fast the position
// is changing relative to the screen.
// TBD

#define DFACT .1f

Point3 SContext::DP(void)
{
	float d = (1.0f+DFACT)*(RayDiam())/(DFACT+(float)fabs(DotProd(Normal(),viewDir)));
	return Point3(d,d,d);
}

// Retrieves the point relative to the screen where the lower left
// corner is 0,0 and the upper right corner is 1,1.
void SContext::ScreenUV(class Point2 &uv,class Point2 &duv)
{
	Point2 p;

	uv.x = .5f;
	uv.y = .5f;
	duv.x = 1.0f;
	duv.y = 1.0f;
}

// Bounding box in object coords
Box3 SContext::ObjectBox(void)
{
	return boundingObj;
}

// Returns the point to be shaded relative to the object box where each
// component is in the range of -1 to +1.
Point3 SContext::PObjRelBox(void)
{
	Point3 q;
	Point3 p = PObj();
	Box3 b = ObjectBox(); 
	q.x = 2.0f*(p.x-b.pmin.x)/(b.pmax.x-b.pmin.x) - 1.0f;
	q.y = 2.0f*(p.y-b.pmin.y)/(b.pmax.y-b.pmin.y) - 1.0f;
	q.z = 2.0f*(p.z-b.pmin.z)/(b.pmax.z-b.pmin.z) - 1.0f;
	return q;
}

// Returns the derivative of PObjRelBox().
// This is the derivative of the point relative to the object box where
// each component is in the range of -1 to +1.
Point3 SContext::DPObjRelBox(void)
{
	Box3 b = ObjectBox(); 
	Point3 d = DPObj();
	d.x *= 2.0f/(b.pmax.x-b.pmin.x); 
	d.y *= 2.0f/(b.pmax.y-b.pmin.y); 
	d.z *= 2.0f/(b.pmax.z-b.pmin.z); 
	return d;
}

// Returns the point to be shaded in object coordinates.
Point3 SContext::PObj(void)
{
	return Inverse(tmAfterWSM) * P();
}

// Returns the derivative of PObj(), relative to the pixel.
// TBD
Point3 SContext::DPObj(void)
{
	Point3 d = DP();
	return VectorTransform(Inverse(tmAfterWSM),d);
}

// Returns the UVW coordinates for the point.
Point3 SContext::UVW(int)
{
	Point3 uvw = Point3(0.0f, 0.0f, 0.0f);
	UVVert tverts[3];

	if (mesh->numTVerts > 0) {
		TVFace* tvf = &mesh->tvFace[faceNum];
		tverts[0] = mesh->tVerts[tvf->getTVert(0)];
		tverts[1] = mesh->tVerts[tvf->getTVert(1)];
		tverts[2] = mesh->tVerts[tvf->getTVert(2)];

		uvw = baryCoord.x*tverts[0] +
				baryCoord.y*tverts[1] +
				baryCoord.z*tverts[2];
	}

	return uvw;
}

static Point3 basic_tva[3] = { Point3(0.0,0.0,0.0),Point3(1.0,0.0,0.0),Point3(1.0,1.0,0.0)};
static Point3 basic_tvb[3] = { Point3(1.0,1.0,0.0),Point3(0.0,1.0,0.0),Point3(0.0,0.0,0.0)};
static int nextpt[3] = {1,2,0};
static int prevpt[3] = {2,0,1};

void MakeFaceUV(Face *f, UVVert *tv)
{
	int na,nhid,i;
	Point3 *basetv;
	/* make the invisible edge be 2->0 */
	nhid = 2;
	if (!(f->flags&EDGE_A))  nhid=0; 
	else if (!(f->flags&EDGE_B)) nhid = 1;
	else if (!(f->flags&EDGE_C)) nhid = 2;
	na = 2-nhid;
	basetv = (f->v[prevpt[nhid]]<f->v[nhid]) ? basic_tva : basic_tvb;
	for (i=0; i<3; i++) {
		tv[i] = basetv[na]; 
		na = nextpt[na];
	}
}

void SContext::getTVerts(int chan) 
{
	if (chan==0&&(node->GetMtl()->Requirements(mtlNum)&MTLREQ_FACEMAP)) {
		MakeFaceUV(&mesh->faces[faceNum],tv[0]);
	}
	else {
		Mesh* m = mesh;
		if(chan==0) {
			UVVert* tverts;
			TVFace* tvf;
			tverts = m->tVerts;
			tvf = m->tvFace;
			if (tverts==0||tvf==0) 
				return;
			tvf = &tvf[faceNum];
			tv[0][0] = tverts[tvf->t[0]];
			tv[0][1] = tverts[tvf->t[1]];
			tv[0][2] = tverts[tvf->t[2]];
		}
		else {
	  		VertColor *vc;
	  		TVFace* tvf;
	  		vc = m->vertCol;
	  		tvf = m->vcFace;
	  		if (vc==0||tvf==0) 
	  			return;
	  		tvf = &tvf[faceNum];
	  		tv[1][0] = vc[tvf->t[0]];
	  		tv[1][1] = vc[tvf->t[1]];
	  		tv[1][2] = vc[tvf->t[2]];
	  	}
	}
}

void SContext::getObjVerts()
{
	// TBD
}

// Returns the UVW derivatives for the point.
Point3 SContext::DUVW(int chan)
{
	getTVerts(chan);
	calc_size_ratio();
	return 0.5f*(pabs(tv[chan][1]-tv[chan][0])+pabs(tv[chan][2]-tv[chan][0]))*ratio;
}

// This returns the bump basis vectors for UVW in camera space.
void SContext::DPdUVW(Point3 dP[3], int chan)
{
	getTVerts(chan);
	calc_size_ratio();
	Point3 bv[3];
	getObjVerts();
	ComputeBumpVectors(tv[chan], obpos, bv);
	bumpv[chan][0] = Normalize(bv[0]);
	bumpv[chan][1] = Normalize(bv[1]);
	bumpv[chan][2] = Normalize(bv[2]);
	dP[0] = bumpv[chan][0];
	dP[1] = bumpv[chan][1];
	dP[2] = bumpv[chan][2];
}

//--------------------------------------------------------------------
// Computes the average curvature per unit surface distance in the face
//--------------------------------------------------------------------
float ComputeFaceCurvature(Point3 *n, Point3 *v, Point3 bc)
{
	Point3 nc = (n[0]+n[1]+n[2])/3.0f;
	Point3 dn0 = n[0]-nc;
	Point3 dn1 = n[1]-nc;
	Point3 dn2 = n[2]-nc;
	Point3 c = (v[0] + v[1] + v[2]) /3.0f;
	Point3 v0 = v[0]-c;
	Point3 v1 = v[1]-c;
	Point3 v2 = v[2]-c;
	float d0 = DotProd(dn0,v0)/LengthSquared(v0);
	float d1 = DotProd(dn1,v1)/LengthSquared(v1);
	float d2 = DotProd(dn2,v2)/LengthSquared(v2);
	float ad0 = (float)fabs(d0);
	float ad1 = (float)fabs(d1);
	float ad2 = (float)fabs(d2);
	return (ad0>ad1)? (ad0>ad2?d0:d2): ad1>ad2?d1:d2;
}

static inline float size_meas(Point3 a, Point3 b, Point3 c)
{
	double d  = fabs(b.x-a.x);
	d += fabs(b.y-a.y);
	d += fabs(b.z-a.z);
	d += fabs(c.x-a.x);
	d += fabs(c.y-a.y);
	d += fabs(c.z-a.z);
	return float(d/6.0);
}

// This is an estimate of how fast the normal is varying.
// For example if you are doing enviornment mapping this value may be used to
// determine how big an area of the environment to sample.
// If the normal is changing very fast a large area must be sampled otherwise
// you'll get aliasing.  This is an estimate of dN/dsx, dN/dsy put into a
// single value.
// Signed curvature:
float SContext::Curve() {
	Point3 tpos[3];
	Face &f = mesh->faces[faceNum];
	tpos[0] = mesh->verts[f.v[0]];
	tpos[1] = mesh->verts[f.v[1]];
	tpos[2] = mesh->verts[f.v[2]];
	float d = ComputeFaceCurvature(vxNormals,tpos,baryCoord);
	curve = d*RayDiam();
	return backFace?-curve:curve;
}

#define SZFACT 1.5f

// Approximate how big fragment is relative to whole face.
void SContext::calc_size_ratio()
{
	Point3 dp = DP();
	Point3 cv[3];
	cv[0] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[0]);
	cv[1] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[1]);
	cv[2] = *mesh->getVertPtr((&mesh->faces[faceNum])->v[2]);
	float d = size_meas(cv[0], cv[1], cv[2]);
	ratio = SZFACT*(float)fabs(dp.x)/d;
}

int	SContext::InMtlEditor()
{
	return FALSE;
}

void SContext::SetView(Point3 v)
{
	viewPoint = v;
}

/****************************************************************************
// Shadow buffer
 ***************************************************************************/

ShadowBuffer* RContext::NewShadowBuffer() const
{
	return NULL;
}

ShadowQuadTree* RContext::NewShadowQuadTree() const
{
	return NULL;
}

Color	RContext::GlobalLightLevel() const
{
	return Color(1,1,1); // TBD
}


/****************************************************************************
// Scan the scene for all lights and add them for the ShadeContext's lightTab
 ***************************************************************************/

void sceneLightEnum(INode* node, SContext* sc, MtlBaseLib* mtls)
{
	// For each child of this node, we recurse into ourselves 
	// until no more children are found.
	for (int c = 0; c < node->NumberOfChildren(); c++) {
		sceneLightEnum(node->GetChildNode(c), sc, mtls);
	}

	// Get the ObjectState.
	// The ObjectState is the structure that flows up the pipeline.
	// It contains a matrix, a material index, some flags for channels,
	// and a pointer to the object in the pipeline.
	ObjectState ostate = node->EvalWorldState(0);
	if (ostate.obj==NULL) 
		return;

	// Examine the superclass ID in order to figure out what kind
	// of object we are dealing with.
	if (ostate.obj->SuperClassID() == LIGHT_CLASS_ID) {
		// Get the light object from the ObjectState
		LightObject *light = (LightObject*)ostate.obj;

		// Is this light turned on?
		if (light->GetUseLight()) {
			// Create a RenderLight and append it to our list of lights
            // to fix compiler error
            LightInfo* li = new LightInfo(node, mtls);
            sc->lightTab.Append(1, &(li));
			//sc->lightTab.Append(1, &(new LightInfo(node, mtls)));
		}
	}
}

void AddSceneLights(SContext* sc, MtlBaseLib* mtls)
{
	INode* scene = GetCOREInterface()->GetRootNode();
	for (int i=0; i<scene->NumberOfChildren(); i++) {
		sceneLightEnum(scene->GetChildNode(i), sc, mtls);
	}
}

/****************************************************************************
// Material enumerator functions
// Before evaluating a material we need to load the maps used by the material
// and then tell the material to prepare for evaluation.
 ***************************************************************************/

class CheckFileNames: public NameEnumCallback {
	public:
		NameTab* missingMaps;
		BitmapInfo bi;
		CheckFileNames(NameTab* n);
		void RecordName(TCHAR *name);
};

//***************************************************************************
// Class to manage names of missing maps
//***************************************************************************

CheckFileNames::CheckFileNames(NameTab* n)
{
	missingMaps = n;
}

//***************************************************************************
// Add a name to the list if it's not already there
//***************************************************************************

void CheckFileNames::RecordName(TCHAR *name)
{ 
	if (name) {
		if (name[0]!=0) {
			if (missingMaps->FindName(name)<0) {
			    missingMaps->AddName(name);
			}
		}
	}
}

class MtlEnum {
	public:
		virtual int proc(MtlBase *m, int subMtlNum) = 0;
};

class MapLoadEnum:public MtlEnum {
	public:
		TimeValue t;

	   	MapLoadEnum(TimeValue time);
		virtual int proc(MtlBase *m, int subMtlNum);
};

//***************************************************************************
// Constructor of map loader
//***************************************************************************

MapLoadEnum::MapLoadEnum(TimeValue time)
{ 
	t = time; 
}

//***************************************************************************
// Map loader enum proc
//***************************************************************************

int MapLoadEnum::proc(MtlBase *m, int subMtlNum)
{
	Texmap *tm = (Texmap *)m;
	tm->LoadMapFiles(t);
	return 1;
}


int EnumMaps(MtlBase *mb, int subMtl,  MtlEnum &tenum)
{
	if (IsTex(mb)) {
		if (!tenum.proc(mb,subMtl)) {
			return 0;
		}
	}
	for (int i=0; i<mb->NumSubTexmaps(); i++) {
		Texmap *st = mb->GetSubTexmap(i); 
		if (st) {
			int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
			if (mb->SubTexmapOn(i)) {
				if (!EnumMaps(st,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	if (IsMtl(mb)) {
		Mtl *m = (Mtl *)mb;
		for (i=0; i<m->NumSubMtls(); i++) {
			Mtl *sm = m->GetSubMtl(i);
			if (sm) {
				int subm = (mb->IsMultiMtl()&&subMtl<0)?i:subMtl;
				if (!EnumMaps(sm,subm,tenum)) {
					return 0;
				}
			}
		}
	}
	return 1;
}

void EnumRefs(ReferenceMaker *rm, RefEnumProc &proc)
{
	proc.proc(rm);
	for (int i=0; i<rm->NumRefs(); i++) {
		ReferenceMaker *srm = rm->GetReference(i);
		if (srm) {
			EnumRefs(srm,proc);		
		}
	}
}

//***************************************************************************
// Constructor of map enumerator
//***************************************************************************

GetMaps::GetMaps(MtlBaseLib *mbl)
{
	mlib = mbl;
}

//***************************************************************************
// Implementation of the map enumerator
//***************************************************************************

void GetMaps::proc(ReferenceMaker *rm)
{
	if (IsTex((MtlBase*)rm)) {
		mlib->AddMtl((MtlBase *)rm);
	}
}


int LoadMapFiles(INode* node, SContext* sc, MtlBaseLib& mtls, TimeValue t)
{
	NameTab mapFiles;
	CheckFileNames checkNames(&mapFiles);

	node->EnumAuxFiles(checkNames, FILE_ENUM_MISSING_ONLY | FILE_ENUM_1STSUB_MISSING);

	// Check the lights
	for (int i = 0; i < sc->lightTab.Count(); i++) {
		if (((LightInfo*)sc->lightTab[i])->light != NULL) {
			((LightInfo*)sc->lightTab[i])->light->EnumAuxFiles(checkNames, 
				FILE_ENUM_MISSING_ONLY | FILE_ENUM_1STSUB_MISSING);
		}
	}

	if (mapFiles.Count()) {
		// Error! Missing maps.
		// not sure how to handle this so we gladly continue.
			
		//if (MessageBox(hWnd, "There are missing maps.\nDo you want to render anyway?", "Warning!", MB_YESNO) != IDYES) {
		//	return 0;
		//}
	}

	// Load the maps
	MapLoadEnum mapload(t);
	for (i=0; i<mtls.Count(); i++) {
		EnumMaps(mtls[i],-1, mapload);
	}

	return 1;
}

//***************************************************************************
// This material is used when a node does not have a material assigned.
//***************************************************************************

DumMtl::DumMtl(Color c)
{ 
	diff = c; spec = Color(DUMSPEC,DUMSPEC,DUMSPEC); 
	phongexp = (float)pow(2.0, DUMSHINE*10.0);
}

void DumMtl::Update(TimeValue t, Interval& valid)
{
}

void DumMtl::Reset()
{
}

Interval DumMtl::Validity(TimeValue t)
{
	return FOREVER;
}

ParamDlg* DumMtl::CreateParamDlg(HWND hwMtlEdit, IMtlParams *imp)
{
	return NULL;
}

Color DumMtl::GetAmbient(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetDiffuse(int mtlNum, BOOL backFace)
{
	return diff;
}

Color DumMtl::GetSpecular(int mtlNum, BOOL backFace)
{
	return spec;
}

float DumMtl::GetShininess(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetShinStr(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

float DumMtl::GetXParency(int mtlNum, BOOL backFace)
{
	return 0.0f;
}

void DumMtl::SetAmbient(Color c, TimeValue t)
{
}		

void DumMtl::SetDiffuse(Color c, TimeValue t)
{
}

void DumMtl::SetSpecular(Color c, TimeValue t)
{
}

void DumMtl::SetShininess(float v, TimeValue t)
{
}

Class_ID DumMtl::ClassID()
{
	return DUMMTL_CLASS_ID;
}

void DumMtl::DeleteThis()
{
	delete this;
}

RefResult DumMtl::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	    	PartID& partID,  RefMessage message)
{
	return REF_SUCCEED;
}

//***************************************************************************
// Shade method for the dummy material
// If a node does not have a material assigned we create
// a dummy material that inherits the wireframe color of
// the node
//***************************************************************************

void DumMtl::Shade(ShadeContext& sc)
{
	Color lightCol;
	Color diffwk(0.0f,0.0f,0.0f);
	Color specwk(0.0f,0.0f,0.0f);
	Point3 N = sc.Normal();
	Point3	R = sc.ReflectVector();
	LightDesc *l;
	for (int i = 0; i<sc.nLights; i++) {
		l = sc.Light(i);
		register float NL, diffCoef;
		Point3 L;
		if (!l->Illuminate(sc, N, lightCol, L, NL, diffCoef))
			continue;

		// diffuse
		if (l->affectDiffuse)
			diffwk += diffCoef*lightCol;
		// specular
		if (l->affectSpecular) {
			float c = DotProd(L,R);
			if (c>0.0f) {
				c = (float)pow((double)c, (double)phongexp); 
				specwk += c*lightCol*NL;   // multiply by NL to SOFTEN 
			}
		}
	}
	sc.out.t = Color(0.0f,0.0f,0.0f);
	sc.out.c = (.3f*sc.ambientLight + diffwk)*diff + specwk*spec;		
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\fog.h ===
/**********************************************************************
 *<
    FILE: fog.h
 
    DESCRIPTION:  VRML 2.0 Fog helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 28 Aug. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __Fog__H__
 
#define __Fog__H__
 
#define Fog_CLASS_ID1 0xACAD3442
#define Fog_CLASS_ID2 0xF42DBAD

#define FogClassID Class_ID(Fog_CLASS_ID1, Fog_CLASS_ID2)

extern ClassDesc* GetFogDesc();

class FogCreateCallBack;

class FogObject: public HelperObject {			   
    friend class FogCreateCallBack;
    friend class FogObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(FogObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    IParamBlock *pblock;
    static IParamMap *pmapParam;

    FogObject();
    ~FogObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_FOG)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_FOG)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(Fog_CLASS_ID1,
                                         Fog_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_FOG_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

};				

#define PB_TYPE       0
#define PB_COLOR      1
#define PB_VIS_RANGE  2
#define PB_FOG_SIZE   3
#define PB_FOG_LENGTH 4

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\cppout.cpp ===
/**********************************************************************
 *<
	FILE: cooout.cpp

	DESCRIPTION:  A utility that outputs an object in C++ code

	CREATED BY: Scott Morrison

	HISTORY: created Spetember 9 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"
#ifdef _DEBUG

extern TCHAR *GetString(int id);

#define CPP_OUT_CLASS_ID		0x8f7ce9ea

class CppOut : public UtilityObj {
public:
    IUtil *iu;
    Interface *ip;
    HWND hPanel;
    ICustButton *iPick;

    CppOut();
    void BeginEditParams(Interface *ip,IUtil *iu);
    void EndEditParams(Interface *ip,IUtil *iu);
    void DeleteThis() {}

    void Init(HWND hWnd);
    void Destroy(HWND hWnd);

    void OutputObject(INode *node,TCHAR *fname);
};
static CppOut theCppOut;

class CppOutClassDesc:public ClassDesc {
public:
    int 			IsPublic() {return 1;}
    void *			Create(BOOL loading = FALSE) {return &theCppOut;}
    const TCHAR *	ClassName() {return GetString(IDS_RB_CPPOBJECTOUT);}
    SClass_ID		SuperClassID() {return UTILITY_CLASS_ID;}
    Class_ID		ClassID() {return Class_ID(CPP_OUT_CLASS_ID,0);}
    const TCHAR* 	Category() {return _T("");}
};

static CppOutClassDesc cppOutDesc;
ClassDesc* GetCppOutDesc() {return &cppOutDesc;}

class CppOutPickNodeCallback : public PickNodeCallback {
public:		
    BOOL Filter(INode *node);
};

BOOL 
CppOutPickNodeCallback::Filter(INode *node)
{
    ObjectState os = node->EvalWorldState(theCppOut.ip->GetTime());
    if (os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID &&
        os.obj->IsRenderable()) return TRUE;
    else return FALSE;
}

static CppOutPickNodeCallback thePickFilt;

class CppOutPickModeCallback : public PickModeCallback {
public:		
    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);
		
    void EnterMode(IObjParam *ip) {theCppOut.iPick->SetCheck(TRUE);}
    void ExitMode(IObjParam *ip) {theCppOut.iPick->SetCheck(FALSE);}

    PickNodeCallback *GetFilter() {return &thePickFilt;}
    BOOL RightClick(IObjParam *ip,ViewExp *vpt) {return TRUE;}
};

static CppOutPickModeCallback thePickMode;

BOOL CppOutPickModeCallback::HitTest(
    IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{
    return ip->PickNode(hWnd,m,&thePickFilt)?TRUE:FALSE;
}

BOOL 
CppOutPickModeCallback::Pick(IObjParam *ip,ViewExp *vpt)
{
    INode *node = vpt->GetClosestHit();
    if (node) {
        static TCHAR fname[256] = {'\0'};
        OPENFILENAME ofn;
        memset(&ofn,0,sizeof(ofn));
        FilterList fl;
        fl.Append( GetString(IDS_RB_CPPFILES));
        fl.Append( _T("*.cpp"));		
        TSTR title = GetString(IDS_RB_SAVEOBJECT);

        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = theCppOut.hPanel;
        ofn.lpstrFilter     = fl;
        ofn.lpstrFile       = fname;
        ofn.nMaxFile        = 256;    
        ofn.lpstrInitialDir = ip->GetDir(APP_EXPORT_DIR);
        ofn.Flags           = OFN_HIDEREADONLY|OFN_FILEMUSTEXIST|OFN_PATHMUSTEXIST;
        ofn.lpstrDefExt     = _T("asc");
        ofn.lpstrTitle      = title;

      tryAgain:
        if (GetSaveFileName(&ofn)) {
            if (DoesFileExist(fname)) {
                TSTR buf1;
                TSTR buf2 = GetString(IDS_RB_SAVEOBJECT);
                buf1.printf(GetString(IDS_RB_FILEEXISTS),fname);
                if (IDYES!=MessageBox(
                    theCppOut.hPanel,
                    buf1,buf2,MB_YESNO|MB_ICONQUESTION)) {
                    goto tryAgain;
                }
            }
            theCppOut.OutputObject(node,fname);
        }
    }
    return TRUE;
}


static BOOL CALLBACK 
CppOutDlgProc(
    HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_INITDIALOG:
        theCppOut.Init(hWnd);			
        break;
		
    case WM_DESTROY:
        theCppOut.Destroy(hWnd);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            theCppOut.iu->CloseUtility();
            break;				
		
        case IDC_CPPOUT_PICK:
            theCppOut.ip->SetPickMode(&thePickMode); 
            break;
        }
        break;

    default:
        return FALSE;
    }
    return TRUE; 
}

CppOut::CppOut()
{
    iu = NULL;
    ip = NULL;	
    hPanel = NULL;	
    iPick = NULL;
}

extern HINSTANCE hInstance;

void 
CppOut::BeginEditParams(Interface *ip,IUtil *iu) 
{
    this->iu = iu;
    this->ip = ip;
    hPanel = ip->AddRollupPage(
        hInstance,
        MAKEINTRESOURCE(IDD_CPPOUT_PANEL),
        CppOutDlgProc,
        GetString(IDS_RB_CPPOBJECTOUT),
        0);
}
	
void 
CppOut::EndEditParams(Interface *ip,IUtil *iu) 
{
    ip->ClearPickMode();
    this->iu = NULL;
    this->ip = NULL;
    if (hPanel) ip->DeleteRollupPage(hPanel);
    hPanel = NULL;
}

void 
CppOut::Init(HWND hWnd)
{
    iPick = GetICustButton(GetDlgItem(hWnd,IDC_CPPOUT_PICK));
    iPick->SetType(CBT_CHECK);
    iPick->SetHighlightColor(GREEN_WASH);
}

void 
CppOut::Destroy(HWND hWnd)
{
    ReleaseICustButton(iPick);
    iPick = NULL;
}

class NullView: public View {
public:
    Point2 ViewToScreen(Point3 p) { return Point2(p.x,p.y); }
    NullView() { worldToView.IdentityMatrix(); screenW=640.0f; screenH = 480.0f; }
};

void 
CppOut::OutputObject(INode *node,TCHAR *fname)
{
    ObjectState os = node->EvalWorldState(theCppOut.ip->GetTime());
    assert(os.obj->SuperClassID()==GEOMOBJECT_CLASS_ID);
    BOOL needDel;
    NullView nullView;
    Mesh *mesh = ((GeomObject*)os.obj)->GetRenderMesh(ip->GetTime(),
                                                      node,nullView,needDel);
    if (!mesh) return;

    FILE *file = fopen(fname,_T("wt"));

    float maxLen = 0.0f, len;
    int i;
    Matrix3 tm = node->GetObjTMAfterWSM(theCppOut.ip->GetTime());
    AffineParts parts;
    decomp_affine(tm, &parts);

    if (file) {
        Box3 bb = mesh->getBoundingBox() * tm;
        Point3 center = bb.Center();
        for (i=0; i<mesh->getNumVerts(); i++) {
            Point3 v = tm * mesh->verts[i] - center;
            len = Length(v);
            if (len > maxLen)
                maxLen = len;
        }
        fprintf(file, "    mesh.setNumVerts(%d);\n", mesh->getNumVerts());
        fprintf(file, "    mesh.setNumFaces(%d);\n", mesh->getNumFaces());
        for (i=0; i<mesh->getNumVerts(); i++) {
            Point3 v = (tm  * mesh->verts[i] - center) / maxLen;
            fprintf(file,"    mesh.setVert(%d, size * Point3(%f,%f,%f));\n",
                    i, v.x, v.y, v.z);
        }

        for (i=0; i<mesh->getNumFaces(); i++) {
            if (parts.f < 0.0f)
                fprintf(file,"    mesh.faces[%d].setVerts(%d,%d,%d);\n",
                        i, mesh->faces[i].v[1], mesh->faces[i].v[0],
                        mesh->faces[i].v[2]);
            else
                fprintf(file,"    mesh.faces[%d].setVerts(%d,%d,%d);\n",
                        i, mesh->faces[i].v[0], mesh->faces[i].v[1],
                        mesh->faces[i].v[2]);
            if (parts.f < 0.0f) 
                fprintf(file,"    mesh.faces[%d].setEdgeVisFlags(%d,%d,%d);\n",
                        i,
                        mesh->faces[i].getEdgeVis(0) ? 1 : 0,
                        mesh->faces[i].getEdgeVis(2) ? 1 : 0,
                        mesh->faces[i].getEdgeVis(1) ? 1 : 0);
            else
                fprintf(file,"    mesh.faces[%d].setEdgeVisFlags(%d,%d,%d);\n",
                        i,
                        mesh->faces[i].getEdgeVis(0) ? 1 : 0,
                        mesh->faces[i].getEdgeVis(1) ? 1 : 0,
                        mesh->faces[i].getEdgeVis(2) ? 1 : 0);
            fprintf(file,"    mesh.faces[%d].setSmGroup(%x);\n",
                    i, mesh->faces[i].smGroup);
        }
		
        fclose(file);
    }	
    if (needDel) delete mesh;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\fog.cpp ===
/**********************************************************************
 *<
    FILE: fog.cpp

    DESCRIPTION:  A VRML 2.0 Fog helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 28 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "fog.h"

//------------------------------------------------------

class FogClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new FogObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_FOG_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(Fog_CLASS_ID1,
                                                    Fog_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static FogClassDesc FogDesc;

ClassDesc* GetFogDesc() { return &FogDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

HWND FogObject::hRollup = NULL;
int FogObject::dlgPrevSel = -1;

TCHAR* fogTypes[] = {_T("EXPONENTIAL"), 
                     _T("LINEAR")};

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  FogObject* th)
{
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG: {
        HWND cb = GetDlgItem(hDlg, IDC_FOG_COMBO);
        int i;
     // gdf this prevents extra entries if the user cancel during create
        ComboBox_ResetContent(cb);
        for(i = 0; i < 2; i++) 
            ComboBox_AddString(cb, fogTypes[i]);
        int type;
        th->pblock->GetValue(PB_TYPE, th->iObjParams->GetTime(),
                             type, FOREVER);
        ComboBox_SelectString(cb, 0, fogTypes[type]);
        return TRUE;
    }

    case WM_COMMAND:			
        switch(HIWORD(wParam)) {
        case LBN_SELCHANGE:
            HWND cb = GetDlgItem(hDlg, IDC_FOG_COMBO);
            int curSel = ComboBox_GetCurSel(cb);
            th->pblock->SetValue(PB_TYPE, th->iObjParams->GetTime(), curSel);
            return TRUE;
        }
        
    default:
        return FALSE;
    }

    return FALSE;
}

static ParamUIDesc descParam[] = {
  // Color
  ParamUIDesc(PB_COLOR,
              TYPE_COLORSWATCH, IDC_COLOR_SWATCH),
  ParamUIDesc(
              PB_VIS_RANGE,
              EDITTYPE_UNIVERSE,
              IDC_VR_EDIT, IDC_VR_SPIN,
              0.0f, 100000.0f,
              SPIN_AUTOSCALE),	

  ParamUIDesc(
              PB_FOG_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 100000.0f,
              SPIN_AUTOSCALE),

};

#define PARAMDESC_LENGTH 3

static ParamBlockDescID descVer0[] = {
  { TYPE_INT, NULL, FALSE, 0 },
  { TYPE_RGBA, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_FLOAT, NULL, FALSE, 3 }
};

// Current version
// static ParamVersionDesc curVersion(descVer0, PB_FOG_LENGTH, 0);
#define CURRENT_VERSION	0

class FogParamDlgProc : public ParamMapUserDlgProc {
public:
  FogObject *ob;

  FogParamDlgProc(FogObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL FogParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *FogObject::pmapParam = NULL;

void
FogObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        
        // Left over from last Fog created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_FOG),
                                     _T("Fog"),
                                     0);
    }
    
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new FogParamDlgProc(this));
    }
}

void
FogObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

FogObject::FogObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_FOG_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_TYPE, 0, 0);
    pb->SetValue(PB_COLOR, 0, Point3(1,1,1));
    pb->SetValue(PB_VIS_RANGE, 0, 0.0f);
    pb->SetValue(PB_FOG_SIZE, 1, 1.0f);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    
}

FogObject::~FogObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *FogObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
FogObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
//     int i;
//     switch (message) {
//     }
     return REF_SUCCEED;
}

RefTargetHandle
FogObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    return NULL;
}

void
FogObject::SetReference(int ind, RefTargetHandle rtarg)
{
    pblock = (IParamBlock*) rtarg;
}

ObjectState
FogObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
FogObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
FogObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
FogObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
FogObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
FogObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_FOG_SIZE, t, size, FOREVER);
#include "fogob.cpp"    
}

int
FogObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_FOG_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 1.0f, 0.0f, 0.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
FogObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class FogCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    FogObject *fogObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(FogObject *obj) {fogObject = obj;}

};

			
int
FogCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            fogObject->pblock->SetValue(PB_FOG_SIZE,
                                               fogObject->
                                               iObjParams->GetTime(), radius);
            fogObject->pmapParam->Invalidate();										
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(fogObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static FogCreateCallBack FogCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
FogObject::GetCreateMouseCallBack() 
{
    FogCreateCB.SetObj(this);
    return(&FogCreateCB);
}

RefTargetHandle
FogObject::Clone(RemapDir& remap)
{
    FogObject* ni = new FogObject();
    ni->ReplaceReference(0, pblock->Clone(remap));
    return ni;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\dllmain.cpp ===
/**********************************************************************
 *<
	FILE: dllmain.cpp

	DESCRIPTION:   DLL implementation of primitives

	CREATED BY: Charles Thaeler

        BASED on helpers.cpp

	HISTORY: created 12 February 1996

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"

//extern ClassDesc* GetMrBlueDesc();
extern ClassDesc* GetLODDesc();
extern ClassDesc* GetVRBLDesc();
extern ClassDesc* GetVRMLInsertDesc();
extern ClassDesc* GetVRMLMtlDesc();
extern ClassDesc *GetOmniLightDesc();
extern ClassDesc *GetTSpotLightDesc();
extern ClassDesc *GetDirLightDesc();
extern ClassDesc *GetFSpotLightDesc();
extern ClassDesc* GetPolyCounterDesc();
extern ClassDesc* GetTimeSensorDesc();
extern ClassDesc* GetNavInfoDesc();
extern ClassDesc* GetBackgroundDesc();
extern ClassDesc* GetFogDesc();
extern ClassDesc* GetAudioClipDesc();
extern ClassDesc* GetSoundDesc();
extern ClassDesc* GetTouchSensorDesc();
extern ClassDesc* GetProxSensorDesc();
extern ClassDesc* GetAnchorDesc();
extern ClassDesc* GetBillboardDesc();
extern ClassDesc* GetCppOutDesc();

HINSTANCE hInstance;
int controlsInit = FALSE;

TCHAR
*GetString(int id)
{
	static TCHAR buf[256];

	if (hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}


/** public functions **/
BOOL WINAPI
DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved)
{
	hInstance = hinstDLL;

	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
}

//------------------------------------------------------
// This is the interface to MAX:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() {
	return GetString(IDS_DLL_INFO);
}

#define NUM_BASE_CLASSES 14
#ifdef _DEBUG
#define NUM_CLASSES (NUM_BASE_CLASSES+1)
#else
#define NUM_CLASSES NUM_BASE_CLASSES
#endif

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses()
{
	return NUM_CLASSES;
}

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i)
{
    switch(i) {
    case 0: return GetAnchorDesc();
    case 1: return GetTouchSensorDesc();
    case 2: return GetProxSensorDesc();
    case 3: return GetTimeSensorDesc();
    case 4: return GetNavInfoDesc();
    case 5: return GetBackgroundDesc();
    case 6: return GetFogDesc();
    case 7: return GetAudioClipDesc();
    case 8: return GetSoundDesc();
    case 9: return GetBillboardDesc();
    case 10: return GetLODDesc();
    case 11: return GetVRBLDesc();
    case 12: return GetVRMLInsertDesc();
    case 13: return GetPolyCounterDesc();
    //case 14: return GetMrBlueDesc();
#ifdef _DEBUG
    case NUM_BASE_CLASSES: return GetCppOutDesc();
#endif
    default: return 0;
    }
    
}

// Return version so can detect obsolete DLLs -- NOTE THIS IS THE API VERSION NUMBER
//                                               NOT THE VERSION OF THE DLL.
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

// Let the plug-in register itself for deferred loading
__declspec( dllexport ) ULONG CanAutoDefer()
{
	return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\fogob.cpp ===
mesh.setNumVerts(112);
    mesh.setNumFaces(213);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669280));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.236998,0.150711,0.215380));
    mesh.setVert(11, size * Point3(-0.254205,0.150711,0.176778));
    mesh.setVert(12, size * Point3(-0.254205,0.150711,0.215380));
    mesh.setVert(13, size * Point3(-0.345763,0.150711,0.215380));
    mesh.setVert(14, size * Point3(-0.345784,0.150711,0.107520));
    mesh.setVert(15, size * Point3(-0.366152,0.150711,0.107520));
    mesh.setVert(16, size * Point3(-0.384669,0.150711,0.052433));
    mesh.setVert(17, size * Point3(-0.345784,0.150711,0.052433));
    mesh.setVert(18, size * Point3(-0.345784,0.150711,-0.079500));
    mesh.setVert(19, size * Point3(-0.249960,0.150711,-0.079500));
    mesh.setVert(20, size * Point3(-0.249960,0.150711,0.050581));
    mesh.setVert(21, size * Point3(-0.207834,0.150711,0.050581));
    mesh.setVert(22, size * Point3(-0.190670,0.150711,0.107520));
    mesh.setVert(23, size * Point3(-0.249960,0.150711,0.107520));
    mesh.setVert(24, size * Point3(-0.249960,0.150711,0.157223));
    mesh.setVert(25, size * Point3(-0.190822,0.150711,0.157053));
    mesh.setVert(26, size * Point3(-0.176355,0.150711,0.215380));
    mesh.setVert(27, size * Point3(-0.236998,-0.129356,0.215380));
    mesh.setVert(28, size * Point3(-0.254205,-0.129356,0.176778));
    mesh.setVert(29, size * Point3(-0.254205,-0.129356,0.215380));
    mesh.setVert(30, size * Point3(-0.345763,-0.129356,0.215380));
    mesh.setVert(31, size * Point3(-0.345784,-0.129356,0.107520));
    mesh.setVert(32, size * Point3(-0.366152,-0.129356,0.107520));
    mesh.setVert(33, size * Point3(-0.384669,-0.129356,0.052433));
    mesh.setVert(34, size * Point3(-0.345784,-0.129356,0.052433));
    mesh.setVert(35, size * Point3(-0.345784,-0.129356,-0.079500));
    mesh.setVert(36, size * Point3(-0.249960,-0.129356,-0.079500));
    mesh.setVert(37, size * Point3(-0.249960,-0.129356,0.050581));
    mesh.setVert(38, size * Point3(-0.207834,-0.129356,0.050581));
    mesh.setVert(39, size * Point3(-0.190670,-0.129356,0.107520));
    mesh.setVert(40, size * Point3(-0.249960,-0.129356,0.107520));
    mesh.setVert(41, size * Point3(-0.249960,-0.129356,0.157223));
    mesh.setVert(42, size * Point3(-0.190822,-0.129356,0.157053));
    mesh.setVert(43, size * Point3(-0.176355,-0.129356,0.215380));
    mesh.setVert(44, size * Point3(0.081961,0.150711,0.127938));
    mesh.setVert(45, size * Point3(-0.045110,0.150711,0.128352));
    mesh.setVert(46, size * Point3(-0.065862,0.150711,0.080141));
    mesh.setVert(47, size * Point3(-0.065862,0.150711,0.128352));
    mesh.setVert(48, size * Point3(-0.152696,0.150711,0.127109));
    mesh.setVert(49, size * Point3(-0.152696,0.150711,-0.078961));
    mesh.setVert(50, size * Point3(-0.030282,0.150711,-0.079500));
    mesh.setVert(51, size * Point3(-0.006565,0.150711,-0.038143));
    mesh.setVert(52, size * Point3(-0.006565,0.150711,-0.079500));
    mesh.setVert(53, size * Point3(0.081961,0.150711,-0.079210));
    mesh.setVert(54, size * Point3(0.081961,-0.129356,0.127938));
    mesh.setVert(55, size * Point3(-0.045110,-0.129356,0.128352));
    mesh.setVert(56, size * Point3(-0.065862,-0.129356,0.080141));
    mesh.setVert(57, size * Point3(-0.065862,-0.129356,0.128352));
    mesh.setVert(58, size * Point3(-0.152696,-0.129356,0.127109));
    mesh.setVert(59, size * Point3(-0.152696,-0.129356,-0.078961));
    mesh.setVert(60, size * Point3(-0.030282,-0.129356,-0.079500));
    mesh.setVert(61, size * Point3(-0.006565,-0.129356,-0.038143));
    mesh.setVert(62, size * Point3(-0.006565,-0.129356,-0.079500));
    mesh.setVert(63, size * Point3(0.081961,-0.129356,-0.079210));
    mesh.setVert(64, size * Point3(-0.062014,0.150711,-0.025016));
    mesh.setVert(65, size * Point3(-0.062014,0.150711,0.071949));
    mesh.setVert(66, size * Point3(-0.012482,0.150711,0.071044));
    mesh.setVert(67, size * Point3(-0.012482,0.150711,-0.024597));
    mesh.setVert(68, size * Point3(-0.062014,-0.129356,-0.025016));
    mesh.setVert(69, size * Point3(-0.062014,-0.129356,0.071949));
    mesh.setVert(70, size * Point3(-0.012482,-0.129356,0.071044));
    mesh.setVert(71, size * Point3(-0.012482,-0.129356,-0.024597));
    mesh.setVert(72, size * Point3(0.345221,0.150711,-0.032282));
    mesh.setVert(73, size * Point3(0.164419,0.150711,-0.032417));
    mesh.setVert(74, size * Point3(0.164419,0.150711,0.007091));
    mesh.setVert(75, size * Point3(0.345541,0.150711,0.007066));
    mesh.setVert(76, size * Point3(0.345283,0.150711,0.129277));
    mesh.setVert(77, size * Point3(0.107241,0.150711,0.128894));
    mesh.setVert(78, size * Point3(0.107241,0.150711,0.007451));
    mesh.setVert(79, size * Point3(0.147636,0.150711,0.007066));
    mesh.setVert(80, size * Point3(0.107241,0.150711,-0.037390));
    mesh.setVert(81, size * Point3(0.107241,0.150711,-0.079347));
    mesh.setVert(82, size * Point3(0.249133,0.150711,-0.079500));
    mesh.setVert(83, size * Point3(0.248772,0.150711,-0.112367));
    mesh.setVert(84, size * Point3(0.126727,0.150711,-0.112367));
    mesh.setVert(85, size * Point3(0.107241,0.150711,-0.160974));
    mesh.setVert(86, size * Point3(0.345648,0.150711,-0.160974));
    mesh.setVert(87, size * Point3(0.345221,-0.129356,-0.032282));
    mesh.setVert(88, size * Point3(0.164419,-0.129356,-0.032417));
    mesh.setVert(89, size * Point3(0.164419,-0.129356,0.007091));
    mesh.setVert(90, size * Point3(0.345541,-0.129356,0.007066));
    mesh.setVert(91, size * Point3(0.345283,-0.129356,0.129277));
    mesh.setVert(92, size * Point3(0.107241,-0.129356,0.128894));
    mesh.setVert(93, size * Point3(0.107241,-0.129356,0.007451));
    mesh.setVert(94, size * Point3(0.147636,-0.129356,0.007066));
    mesh.setVert(95, size * Point3(0.107241,-0.129356,-0.037390));
    mesh.setVert(96, size * Point3(0.107241,-0.129356,-0.079347));
    mesh.setVert(97, size * Point3(0.249133,-0.129356,-0.079500));
    mesh.setVert(98, size * Point3(0.248772,-0.129356,-0.112367));
    mesh.setVert(99, size * Point3(0.126727,-0.129356,-0.112367));
    mesh.setVert(100, size * Point3(0.107241,-0.129356,-0.160974));
    mesh.setVert(101, size * Point3(0.345648,-0.129356,-0.160974));
    mesh.setVert(102, size * Point3(0.252093,0.150711,0.046878));
    mesh.setVert(103, size * Point3(0.199576,0.150711,0.046878));
    mesh.setVert(104, size * Point3(0.199626,0.150711,0.087151));
    mesh.setVert(105, size * Point3(0.235846,0.150711,0.087151));
    mesh.setVert(106, size * Point3(0.252309,0.150711,0.127201));
    mesh.setVert(107, size * Point3(0.252093,-0.129356,0.046878));
    mesh.setVert(108, size * Point3(0.199576,-0.129356,0.046878));
    mesh.setVert(109, size * Point3(0.199626,-0.129356,0.087151));
    mesh.setVert(110, size * Point3(0.235846,-0.129356,0.087151));
    mesh.setVert(111, size * Point3(0.252309,-0.129356,0.127201));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,11,28);
    mesh.faces[13].setEdgeVisFlags(1,1,0);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(10,28,27);
    mesh.faces[14].setEdgeVisFlags(0,1,1);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(11,12,29);
    mesh.faces[15].setEdgeVisFlags(1,1,0);
    mesh.faces[15].setSmGroup(4);
    mesh.faces[16].setVerts(11,29,28);
    mesh.faces[16].setEdgeVisFlags(0,1,1);
    mesh.faces[16].setSmGroup(4);
    mesh.faces[17].setVerts(12,13,30);
    mesh.faces[17].setEdgeVisFlags(1,1,0);
    mesh.faces[17].setSmGroup(2);
    mesh.faces[18].setVerts(12,30,29);
    mesh.faces[18].setEdgeVisFlags(0,1,1);
    mesh.faces[18].setSmGroup(2);
    mesh.faces[19].setVerts(13,14,31);
    mesh.faces[19].setEdgeVisFlags(1,1,0);
    mesh.faces[19].setSmGroup(4);
    mesh.faces[20].setVerts(13,31,30);
    mesh.faces[20].setEdgeVisFlags(0,1,1);
    mesh.faces[20].setSmGroup(4);
    mesh.faces[21].setVerts(14,15,32);
    mesh.faces[21].setEdgeVisFlags(1,1,0);
    mesh.faces[21].setSmGroup(2);
    mesh.faces[22].setVerts(14,32,31);
    mesh.faces[22].setEdgeVisFlags(0,1,1);
    mesh.faces[22].setSmGroup(2);
    mesh.faces[23].setVerts(15,16,33);
    mesh.faces[23].setEdgeVisFlags(1,1,0);
    mesh.faces[23].setSmGroup(4);
    mesh.faces[24].setVerts(15,33,32);
    mesh.faces[24].setEdgeVisFlags(0,1,1);
    mesh.faces[24].setSmGroup(4);
    mesh.faces[25].setVerts(16,17,34);
    mesh.faces[25].setEdgeVisFlags(1,1,0);
    mesh.faces[25].setSmGroup(2);
    mesh.faces[26].setVerts(16,34,33);
    mesh.faces[26].setEdgeVisFlags(0,1,1);
    mesh.faces[26].setSmGroup(2);
    mesh.faces[27].setVerts(17,18,35);
    mesh.faces[27].setEdgeVisFlags(1,1,0);
    mesh.faces[27].setSmGroup(4);
    mesh.faces[28].setVerts(17,35,34);
    mesh.faces[28].setEdgeVisFlags(0,1,1);
    mesh.faces[28].setSmGroup(4);
    mesh.faces[29].setVerts(18,19,36);
    mesh.faces[29].setEdgeVisFlags(1,1,0);
    mesh.faces[29].setSmGroup(2);
    mesh.faces[30].setVerts(18,36,35);
    mesh.faces[30].setEdgeVisFlags(0,1,1);
    mesh.faces[30].setSmGroup(2);
    mesh.faces[31].setVerts(19,20,37);
    mesh.faces[31].setEdgeVisFlags(1,1,0);
    mesh.faces[31].setSmGroup(4);
    mesh.faces[32].setVerts(19,37,36);
    mesh.faces[32].setEdgeVisFlags(0,1,1);
    mesh.faces[32].setSmGroup(4);
    mesh.faces[33].setVerts(20,21,38);
    mesh.faces[33].setEdgeVisFlags(1,1,0);
    mesh.faces[33].setSmGroup(2);
    mesh.faces[34].setVerts(20,38,37);
    mesh.faces[34].setEdgeVisFlags(0,1,1);
    mesh.faces[34].setSmGroup(2);
    mesh.faces[35].setVerts(21,22,39);
    mesh.faces[35].setEdgeVisFlags(1,1,0);
    mesh.faces[35].setSmGroup(4);
    mesh.faces[36].setVerts(21,39,38);
    mesh.faces[36].setEdgeVisFlags(0,1,1);
    mesh.faces[36].setSmGroup(4);
    mesh.faces[37].setVerts(22,23,40);
    mesh.faces[37].setEdgeVisFlags(1,1,0);
    mesh.faces[37].setSmGroup(2);
    mesh.faces[38].setVerts(22,40,39);
    mesh.faces[38].setEdgeVisFlags(0,1,1);
    mesh.faces[38].setSmGroup(2);
    mesh.faces[39].setVerts(23,24,41);
    mesh.faces[39].setEdgeVisFlags(1,1,0);
    mesh.faces[39].setSmGroup(4);
    mesh.faces[40].setVerts(23,41,40);
    mesh.faces[40].setEdgeVisFlags(0,1,1);
    mesh.faces[40].setSmGroup(4);
    mesh.faces[41].setVerts(24,25,42);
    mesh.faces[41].setEdgeVisFlags(1,1,0);
    mesh.faces[41].setSmGroup(2);
    mesh.faces[42].setVerts(24,42,41);
    mesh.faces[42].setEdgeVisFlags(0,1,1);
    mesh.faces[42].setSmGroup(2);
    mesh.faces[43].setVerts(25,26,43);
    mesh.faces[43].setEdgeVisFlags(1,1,0);
    mesh.faces[43].setSmGroup(4);
    mesh.faces[44].setVerts(25,43,42);
    mesh.faces[44].setEdgeVisFlags(0,1,1);
    mesh.faces[44].setSmGroup(4);
    mesh.faces[45].setVerts(26,10,27);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(2);
    mesh.faces[46].setVerts(26,27,43);
    mesh.faces[46].setEdgeVisFlags(0,1,1);
    mesh.faces[46].setSmGroup(2);
    mesh.faces[47].setVerts(44,45,55);
    mesh.faces[47].setEdgeVisFlags(1,1,0);
    mesh.faces[47].setSmGroup(1);
    mesh.faces[48].setVerts(44,55,54);
    mesh.faces[48].setEdgeVisFlags(0,1,1);
    mesh.faces[48].setSmGroup(1);
    mesh.faces[49].setVerts(45,46,56);
    mesh.faces[49].setEdgeVisFlags(1,1,0);
    mesh.faces[49].setSmGroup(4);
    mesh.faces[50].setVerts(45,56,55);
    mesh.faces[50].setEdgeVisFlags(0,1,1);
    mesh.faces[50].setSmGroup(4);
    mesh.faces[51].setVerts(46,47,57);
    mesh.faces[51].setEdgeVisFlags(1,1,0);
    mesh.faces[51].setSmGroup(2);
    mesh.faces[52].setVerts(46,57,56);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(2);
    mesh.faces[53].setVerts(47,48,58);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(4);
    mesh.faces[54].setVerts(47,58,57);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(4);
    mesh.faces[55].setVerts(48,49,59);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(2);
    mesh.faces[56].setVerts(48,59,58);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(2);
    mesh.faces[57].setVerts(49,50,60);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(4);
    mesh.faces[58].setVerts(49,60,59);
    mesh.faces[58].setEdgeVisFlags(0,1,1);
    mesh.faces[58].setSmGroup(4);
    mesh.faces[59].setVerts(50,51,61);
    mesh.faces[59].setEdgeVisFlags(1,1,0);
    mesh.faces[59].setSmGroup(2);
    mesh.faces[60].setVerts(50,61,60);
    mesh.faces[60].setEdgeVisFlags(0,1,1);
    mesh.faces[60].setSmGroup(2);
    mesh.faces[61].setVerts(51,52,62);
    mesh.faces[61].setEdgeVisFlags(1,1,0);
    mesh.faces[61].setSmGroup(4);
    mesh.faces[62].setVerts(51,62,61);
    mesh.faces[62].setEdgeVisFlags(0,1,1);
    mesh.faces[62].setSmGroup(4);
    mesh.faces[63].setVerts(52,53,63);
    mesh.faces[63].setEdgeVisFlags(1,1,0);
    mesh.faces[63].setSmGroup(2);
    mesh.faces[64].setVerts(52,63,62);
    mesh.faces[64].setEdgeVisFlags(0,1,1);
    mesh.faces[64].setSmGroup(2);
    mesh.faces[65].setVerts(53,44,54);
    mesh.faces[65].setEdgeVisFlags(1,1,0);
    mesh.faces[65].setSmGroup(4);
    mesh.faces[66].setVerts(53,54,63);
    mesh.faces[66].setEdgeVisFlags(0,1,1);
    mesh.faces[66].setSmGroup(4);
    mesh.faces[67].setVerts(64,65,69);
    mesh.faces[67].setEdgeVisFlags(1,1,0);
    mesh.faces[67].setSmGroup(1);
    mesh.faces[68].setVerts(64,69,68);
    mesh.faces[68].setEdgeVisFlags(0,1,1);
    mesh.faces[68].setSmGroup(1);
    mesh.faces[69].setVerts(65,66,70);
    mesh.faces[69].setEdgeVisFlags(1,1,0);
    mesh.faces[69].setSmGroup(4);
    mesh.faces[70].setVerts(65,70,69);
    mesh.faces[70].setEdgeVisFlags(0,1,1);
    mesh.faces[70].setSmGroup(4);
    mesh.faces[71].setVerts(66,67,71);
    mesh.faces[71].setEdgeVisFlags(1,1,0);
    mesh.faces[71].setSmGroup(2);
    mesh.faces[72].setVerts(66,71,70);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(2);
    mesh.faces[73].setVerts(67,64,68);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(4);
    mesh.faces[74].setVerts(67,68,71);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(4);
    mesh.faces[75].setVerts(72,73,88);
    mesh.faces[75].setEdgeVisFlags(1,1,0);
    mesh.faces[75].setSmGroup(1);
    mesh.faces[76].setVerts(72,88,87);
    mesh.faces[76].setEdgeVisFlags(0,1,1);
    mesh.faces[76].setSmGroup(1);
    mesh.faces[77].setVerts(73,74,89);
    mesh.faces[77].setEdgeVisFlags(1,1,0);
    mesh.faces[77].setSmGroup(4);
    mesh.faces[78].setVerts(73,89,88);
    mesh.faces[78].setEdgeVisFlags(0,1,1);
    mesh.faces[78].setSmGroup(4);
    mesh.faces[79].setVerts(74,75,90);
    mesh.faces[79].setEdgeVisFlags(1,1,0);
    mesh.faces[79].setSmGroup(2);
    mesh.faces[80].setVerts(74,90,89);
    mesh.faces[80].setEdgeVisFlags(0,1,1);
    mesh.faces[80].setSmGroup(2);
    mesh.faces[81].setVerts(75,76,91);
    mesh.faces[81].setEdgeVisFlags(1,1,0);
    mesh.faces[81].setSmGroup(4);
    mesh.faces[82].setVerts(75,91,90);
    mesh.faces[82].setEdgeVisFlags(0,1,1);
    mesh.faces[82].setSmGroup(4);
    mesh.faces[83].setVerts(76,77,92);
    mesh.faces[83].setEdgeVisFlags(1,1,0);
    mesh.faces[83].setSmGroup(2);
    mesh.faces[84].setVerts(76,92,91);
    mesh.faces[84].setEdgeVisFlags(0,1,1);
    mesh.faces[84].setSmGroup(2);
    mesh.faces[85].setVerts(77,78,93);
    mesh.faces[85].setEdgeVisFlags(1,1,0);
    mesh.faces[85].setSmGroup(4);
    mesh.faces[86].setVerts(77,93,92);
    mesh.faces[86].setEdgeVisFlags(0,1,1);
    mesh.faces[86].setSmGroup(4);
    mesh.faces[87].setVerts(78,79,94);
    mesh.faces[87].setEdgeVisFlags(1,1,0);
    mesh.faces[87].setSmGroup(2);
    mesh.faces[88].setVerts(78,94,93);
    mesh.faces[88].setEdgeVisFlags(0,1,1);
    mesh.faces[88].setSmGroup(2);
    mesh.faces[89].setVerts(79,80,95);
    mesh.faces[89].setEdgeVisFlags(1,1,0);
    mesh.faces[89].setSmGroup(4);
    mesh.faces[90].setVerts(79,95,94);
    mesh.faces[90].setEdgeVisFlags(0,1,1);
    mesh.faces[90].setSmGroup(4);
    mesh.faces[91].setVerts(80,81,96);
    mesh.faces[91].setEdgeVisFlags(1,1,0);
    mesh.faces[91].setSmGroup(2);
    mesh.faces[92].setVerts(80,96,95);
    mesh.faces[92].setEdgeVisFlags(0,1,1);
    mesh.faces[92].setSmGroup(2);
    mesh.faces[93].setVerts(81,82,97);
    mesh.faces[93].setEdgeVisFlags(1,1,0);
    mesh.faces[93].setSmGroup(4);
    mesh.faces[94].setVerts(81,97,96);
    mesh.faces[94].setEdgeVisFlags(0,1,1);
    mesh.faces[94].setSmGroup(4);
    mesh.faces[95].setVerts(82,83,98);
    mesh.faces[95].setEdgeVisFlags(1,1,0);
    mesh.faces[95].setSmGroup(2);
    mesh.faces[96].setVerts(82,98,97);
    mesh.faces[96].setEdgeVisFlags(0,1,1);
    mesh.faces[96].setSmGroup(2);
    mesh.faces[97].setVerts(83,84,99);
    mesh.faces[97].setEdgeVisFlags(1,1,0);
    mesh.faces[97].setSmGroup(4);
    mesh.faces[98].setVerts(83,99,98);
    mesh.faces[98].setEdgeVisFlags(0,1,1);
    mesh.faces[98].setSmGroup(4);
    mesh.faces[99].setVerts(84,85,100);
    mesh.faces[99].setEdgeVisFlags(1,1,0);
    mesh.faces[99].setSmGroup(2);
    mesh.faces[100].setVerts(84,100,99);
    mesh.faces[100].setEdgeVisFlags(0,1,1);
    mesh.faces[100].setSmGroup(2);
    mesh.faces[101].setVerts(85,86,101);
    mesh.faces[101].setEdgeVisFlags(1,1,0);
    mesh.faces[101].setSmGroup(4);
    mesh.faces[102].setVerts(85,101,100);
    mesh.faces[102].setEdgeVisFlags(0,1,1);
    mesh.faces[102].setSmGroup(4);
    mesh.faces[103].setVerts(86,72,87);
    mesh.faces[103].setEdgeVisFlags(1,1,0);
    mesh.faces[103].setSmGroup(2);
    mesh.faces[104].setVerts(86,87,101);
    mesh.faces[104].setEdgeVisFlags(0,1,1);
    mesh.faces[104].setSmGroup(2);
    mesh.faces[105].setVerts(102,103,108);
    mesh.faces[105].setEdgeVisFlags(1,1,0);
    mesh.faces[105].setSmGroup(1);
    mesh.faces[106].setVerts(102,108,107);
    mesh.faces[106].setEdgeVisFlags(0,1,1);
    mesh.faces[106].setSmGroup(1);
    mesh.faces[107].setVerts(103,104,109);
    mesh.faces[107].setEdgeVisFlags(1,1,0);
    mesh.faces[107].setSmGroup(4);
    mesh.faces[108].setVerts(103,109,108);
    mesh.faces[108].setEdgeVisFlags(0,1,1);
    mesh.faces[108].setSmGroup(4);
    mesh.faces[109].setVerts(104,105,110);
    mesh.faces[109].setEdgeVisFlags(1,1,0);
    mesh.faces[109].setSmGroup(2);
    mesh.faces[110].setVerts(104,110,109);
    mesh.faces[110].setEdgeVisFlags(0,1,1);
    mesh.faces[110].setSmGroup(2);
    mesh.faces[111].setVerts(105,106,111);
    mesh.faces[111].setEdgeVisFlags(1,1,0);
    mesh.faces[111].setSmGroup(4);
    mesh.faces[112].setVerts(105,111,110);
    mesh.faces[112].setEdgeVisFlags(0,1,1);
    mesh.faces[112].setSmGroup(4);
    mesh.faces[113].setVerts(106,102,107);
    mesh.faces[113].setEdgeVisFlags(1,1,0);
    mesh.faces[113].setSmGroup(2);
    mesh.faces[114].setVerts(106,107,111);
    mesh.faces[114].setEdgeVisFlags(0,1,1);
    mesh.faces[114].setSmGroup(2);
    mesh.faces[115].setVerts(15,17,16);
    mesh.faces[115].setEdgeVisFlags(0,1,1);
    mesh.faces[115].setSmGroup(10);
    mesh.faces[116].setVerts(14,17,15);
    mesh.faces[116].setEdgeVisFlags(0,0,1);
    mesh.faces[116].setSmGroup(10);
    mesh.faces[117].setVerts(21,23,22);
    mesh.faces[117].setEdgeVisFlags(0,1,1);
    mesh.faces[117].setSmGroup(10);
    mesh.faces[118].setVerts(20,23,21);
    mesh.faces[118].setEdgeVisFlags(0,0,1);
    mesh.faces[118].setSmGroup(10);
    mesh.faces[119].setVerts(25,10,26);
    mesh.faces[119].setEdgeVisFlags(0,1,1);
    mesh.faces[119].setSmGroup(10);
    mesh.faces[120].setVerts(24,10,25);
    mesh.faces[120].setEdgeVisFlags(0,0,1);
    mesh.faces[120].setSmGroup(10);
    mesh.faces[121].setVerts(24,11,10);
    mesh.faces[121].setEdgeVisFlags(0,1,0);
    mesh.faces[121].setSmGroup(10);
    mesh.faces[122].setVerts(18,20,19);
    mesh.faces[122].setEdgeVisFlags(0,1,1);
    mesh.faces[122].setSmGroup(10);
    mesh.faces[123].setVerts(17,20,18);
    mesh.faces[123].setEdgeVisFlags(0,0,1);
    mesh.faces[123].setSmGroup(10);
    mesh.faces[124].setVerts(17,23,20);
    mesh.faces[124].setEdgeVisFlags(0,0,0);
    mesh.faces[124].setSmGroup(10);
    mesh.faces[125].setVerts(14,23,17);
    mesh.faces[125].setEdgeVisFlags(0,0,0);
    mesh.faces[125].setSmGroup(10);
    mesh.faces[126].setVerts(13,23,14);
    mesh.faces[126].setEdgeVisFlags(0,0,1);
    mesh.faces[126].setSmGroup(10);
    mesh.faces[127].setVerts(13,24,23);
    mesh.faces[127].setEdgeVisFlags(0,1,0);
    mesh.faces[127].setSmGroup(10);
    mesh.faces[128].setVerts(13,11,24);
    mesh.faces[128].setEdgeVisFlags(0,0,0);
    mesh.faces[128].setSmGroup(10);
    mesh.faces[129].setVerts(12,11,13);
    mesh.faces[129].setEdgeVisFlags(1,0,1);
    mesh.faces[129].setSmGroup(10);
    mesh.faces[130].setVerts(65,45,44);
    mesh.faces[130].setEdgeVisFlags(0,1,0);
    mesh.faces[130].setSmGroup(10);
    mesh.faces[131].setVerts(65,46,45);
    mesh.faces[131].setEdgeVisFlags(0,1,0);
    mesh.faces[131].setSmGroup(10);
    mesh.faces[132].setVerts(44,66,65);
    mesh.faces[132].setEdgeVisFlags(0,1,0);
    mesh.faces[132].setSmGroup(10);
    mesh.faces[133].setVerts(53,66,44);
    mesh.faces[133].setEdgeVisFlags(0,0,1);
    mesh.faces[133].setSmGroup(10);
    mesh.faces[134].setVerts(53,67,66);
    mesh.faces[134].setEdgeVisFlags(0,1,0);
    mesh.faces[134].setSmGroup(10);
    mesh.faces[135].setVerts(46,48,47);
    mesh.faces[135].setEdgeVisFlags(0,1,1);
    mesh.faces[135].setSmGroup(10);
    mesh.faces[136].setVerts(46,49,48);
    mesh.faces[136].setEdgeVisFlags(0,1,0);
    mesh.faces[136].setSmGroup(10);
    mesh.faces[137].setVerts(65,49,46);
    mesh.faces[137].setEdgeVisFlags(0,0,0);
    mesh.faces[137].setSmGroup(10);
    mesh.faces[138].setVerts(64,49,65);
    mesh.faces[138].setEdgeVisFlags(0,0,1);
    mesh.faces[138].setSmGroup(10);
    mesh.faces[139].setVerts(64,50,49);
    mesh.faces[139].setEdgeVisFlags(0,1,0);
    mesh.faces[139].setSmGroup(10);
    mesh.faces[140].setVerts(64,51,50);
    mesh.faces[140].setEdgeVisFlags(0,1,0);
    mesh.faces[140].setSmGroup(10);
    mesh.faces[141].setVerts(67,51,64);
    mesh.faces[141].setEdgeVisFlags(0,0,1);
    mesh.faces[141].setSmGroup(10);
    mesh.faces[142].setVerts(53,51,67);
    mesh.faces[142].setEdgeVisFlags(0,0,0);
    mesh.faces[142].setSmGroup(10);
    mesh.faces[143].setVerts(52,51,53);
    mesh.faces[143].setEdgeVisFlags(1,0,1);
    mesh.faces[143].setSmGroup(10);
    mesh.faces[144].setVerts(74,103,102);
    mesh.faces[144].setEdgeVisFlags(0,1,0);
    mesh.faces[144].setSmGroup(10);
    mesh.faces[145].setVerts(102,75,74);
    mesh.faces[145].setEdgeVisFlags(0,1,0);
    mesh.faces[145].setSmGroup(10);
    mesh.faces[146].setVerts(102,76,75);
    mesh.faces[146].setEdgeVisFlags(0,1,0);
    mesh.faces[146].setSmGroup(10);
    mesh.faces[147].setVerts(106,76,102);
    mesh.faces[147].setEdgeVisFlags(0,0,1);
    mesh.faces[147].setSmGroup(10);
    mesh.faces[148].setVerts(106,77,76);
    mesh.faces[148].setEdgeVisFlags(0,1,0);
    mesh.faces[148].setSmGroup(10);
    mesh.faces[149].setVerts(84,86,85);
    mesh.faces[149].setEdgeVisFlags(0,1,1);
    mesh.faces[149].setSmGroup(10);
    mesh.faces[150].setVerts(83,86,84);
    mesh.faces[150].setEdgeVisFlags(0,0,1);
    mesh.faces[150].setSmGroup(10);
    mesh.faces[151].setVerts(83,72,86);
    mesh.faces[151].setEdgeVisFlags(0,1,0);
    mesh.faces[151].setSmGroup(10);
    mesh.faces[152].setVerts(82,72,83);
    mesh.faces[152].setEdgeVisFlags(0,0,1);
    mesh.faces[152].setSmGroup(10);
    mesh.faces[153].setVerts(82,73,72);
    mesh.faces[153].setEdgeVisFlags(0,1,0);
    mesh.faces[153].setSmGroup(10);
    mesh.faces[154].setVerts(81,73,82);
    mesh.faces[154].setEdgeVisFlags(0,0,1);
    mesh.faces[154].setSmGroup(10);
    mesh.faces[155].setVerts(80,73,81);
    mesh.faces[155].setEdgeVisFlags(0,0,1);
    mesh.faces[155].setSmGroup(10);
    mesh.faces[156].setVerts(79,73,80);
    mesh.faces[156].setEdgeVisFlags(0,0,1);
    mesh.faces[156].setSmGroup(10);
    mesh.faces[157].setVerts(79,74,73);
    mesh.faces[157].setEdgeVisFlags(0,1,0);
    mesh.faces[157].setSmGroup(10);
    mesh.faces[158].setVerts(105,77,106);
    mesh.faces[158].setEdgeVisFlags(0,0,1);
    mesh.faces[158].setSmGroup(10);
    mesh.faces[159].setVerts(104,77,105);
    mesh.faces[159].setEdgeVisFlags(0,0,1);
    mesh.faces[159].setSmGroup(10);
    mesh.faces[160].setVerts(104,78,77);
    mesh.faces[160].setEdgeVisFlags(0,1,0);
    mesh.faces[160].setSmGroup(10);
    mesh.faces[161].setVerts(104,79,78);
    mesh.faces[161].setEdgeVisFlags(0,1,0);
    mesh.faces[161].setSmGroup(10);
    mesh.faces[162].setVerts(103,79,104);
    mesh.faces[162].setEdgeVisFlags(0,0,1);
    mesh.faces[162].setSmGroup(10);
    mesh.faces[163].setVerts(74,79,103);
    mesh.faces[163].setEdgeVisFlags(0,0,0);
    mesh.faces[163].setSmGroup(10);
    mesh.faces[164].setVerts(32,33,34);
    mesh.faces[164].setEdgeVisFlags(1,1,0);
    mesh.faces[164].setSmGroup(10);
    mesh.faces[165].setVerts(31,32,34);
    mesh.faces[165].setEdgeVisFlags(1,0,0);
    mesh.faces[165].setSmGroup(10);
    mesh.faces[166].setVerts(38,39,40);
    mesh.faces[166].setEdgeVisFlags(1,1,0);
    mesh.faces[166].setSmGroup(10);
    mesh.faces[167].setVerts(37,38,40);
    mesh.faces[167].setEdgeVisFlags(1,0,0);
    mesh.faces[167].setSmGroup(10);
    mesh.faces[168].setVerts(42,43,27);
    mesh.faces[168].setEdgeVisFlags(1,1,0);
    mesh.faces[168].setSmGroup(10);
    mesh.faces[169].setVerts(41,42,27);
    mesh.faces[169].setEdgeVisFlags(1,0,0);
    mesh.faces[169].setSmGroup(10);
    mesh.faces[170].setVerts(41,27,28);
    mesh.faces[170].setEdgeVisFlags(0,1,0);
    mesh.faces[170].setSmGroup(10);
    mesh.faces[171].setVerts(35,36,37);
    mesh.faces[171].setEdgeVisFlags(1,1,0);
    mesh.faces[171].setSmGroup(10);
    mesh.faces[172].setVerts(34,35,37);
    mesh.faces[172].setEdgeVisFlags(1,0,0);
    mesh.faces[172].setSmGroup(10);
    mesh.faces[173].setVerts(34,37,40);
    mesh.faces[173].setEdgeVisFlags(0,0,0);
    mesh.faces[173].setSmGroup(10);
    mesh.faces[174].setVerts(31,34,40);
    mesh.faces[174].setEdgeVisFlags(0,0,0);
    mesh.faces[174].setSmGroup(10);
    mesh.faces[175].setVerts(30,31,40);
    mesh.faces[175].setEdgeVisFlags(1,0,0);
    mesh.faces[175].setSmGroup(10);
    mesh.faces[176].setVerts(30,40,41);
    mesh.faces[176].setEdgeVisFlags(0,1,0);
    mesh.faces[176].setSmGroup(10);
    mesh.faces[177].setVerts(30,41,28);
    mesh.faces[177].setEdgeVisFlags(0,0,0);
    mesh.faces[177].setSmGroup(10);
    mesh.faces[178].setVerts(29,30,28);
    mesh.faces[178].setEdgeVisFlags(1,0,1);
    mesh.faces[178].setSmGroup(10);
    mesh.faces[179].setVerts(69,54,55);
    mesh.faces[179].setEdgeVisFlags(0,1,0);
    mesh.faces[179].setSmGroup(10);
    mesh.faces[180].setVerts(69,55,56);
    mesh.faces[180].setEdgeVisFlags(0,1,0);
    mesh.faces[180].setSmGroup(10);
    mesh.faces[181].setVerts(54,69,70);
    mesh.faces[181].setEdgeVisFlags(0,1,0);
    mesh.faces[181].setSmGroup(10);
    mesh.faces[182].setVerts(63,54,70);
    mesh.faces[182].setEdgeVisFlags(1,0,0);
    mesh.faces[182].setSmGroup(10);
    mesh.faces[183].setVerts(63,70,71);
    mesh.faces[183].setEdgeVisFlags(0,1,0);
    mesh.faces[183].setSmGroup(10);
    mesh.faces[184].setVerts(56,57,58);
    mesh.faces[184].setEdgeVisFlags(1,1,0);
    mesh.faces[184].setSmGroup(10);
    mesh.faces[185].setVerts(56,58,59);
    mesh.faces[185].setEdgeVisFlags(0,1,0);
    mesh.faces[185].setSmGroup(10);
    mesh.faces[186].setVerts(69,56,59);
    mesh.faces[186].setEdgeVisFlags(0,0,0);
    mesh.faces[186].setSmGroup(10);
    mesh.faces[187].setVerts(68,69,59);
    mesh.faces[187].setEdgeVisFlags(1,0,0);
    mesh.faces[187].setSmGroup(10);
    mesh.faces[188].setVerts(68,59,60);
    mesh.faces[188].setEdgeVisFlags(0,1,0);
    mesh.faces[188].setSmGroup(10);
    mesh.faces[189].setVerts(68,60,61);
    mesh.faces[189].setEdgeVisFlags(0,1,0);
    mesh.faces[189].setSmGroup(10);
    mesh.faces[190].setVerts(71,68,61);
    mesh.faces[190].setEdgeVisFlags(1,0,0);
    mesh.faces[190].setSmGroup(10);
    mesh.faces[191].setVerts(63,71,61);
    mesh.faces[191].setEdgeVisFlags(0,0,0);
    mesh.faces[191].setSmGroup(10);
    mesh.faces[192].setVerts(62,63,61);
    mesh.faces[192].setEdgeVisFlags(1,0,1);
    mesh.faces[192].setSmGroup(10);
    mesh.faces[193].setVerts(89,107,108);
    mesh.faces[193].setEdgeVisFlags(0,1,0);
    mesh.faces[193].setSmGroup(10);
    mesh.faces[194].setVerts(107,89,90);
    mesh.faces[194].setEdgeVisFlags(0,1,0);
    mesh.faces[194].setSmGroup(10);
    mesh.faces[195].setVerts(107,90,91);
    mesh.faces[195].setEdgeVisFlags(0,1,0);
    mesh.faces[195].setSmGroup(10);
    mesh.faces[196].setVerts(111,107,91);
    mesh.faces[196].setEdgeVisFlags(1,0,0);
    mesh.faces[196].setSmGroup(10);
    mesh.faces[197].setVerts(111,91,92);
    mesh.faces[197].setEdgeVisFlags(0,1,0);
    mesh.faces[197].setSmGroup(10);
    mesh.faces[198].setVerts(99,100,101);
    mesh.faces[198].setEdgeVisFlags(1,1,0);
    mesh.faces[198].setSmGroup(10);
    mesh.faces[199].setVerts(98,99,101);
    mesh.faces[199].setEdgeVisFlags(1,0,0);
    mesh.faces[199].setSmGroup(10);
    mesh.faces[200].setVerts(98,101,87);
    mesh.faces[200].setEdgeVisFlags(0,1,0);
    mesh.faces[200].setSmGroup(10);
    mesh.faces[201].setVerts(97,98,87);
    mesh.faces[201].setEdgeVisFlags(1,0,0);
    mesh.faces[201].setSmGroup(10);
    mesh.faces[202].setVerts(97,87,88);
    mesh.faces[202].setEdgeVisFlags(0,1,0);
    mesh.faces[202].setSmGroup(10);
    mesh.faces[203].setVerts(96,97,88);
    mesh.faces[203].setEdgeVisFlags(1,0,0);
    mesh.faces[203].setSmGroup(10);
    mesh.faces[204].setVerts(95,96,88);
    mesh.faces[204].setEdgeVisFlags(1,0,0);
    mesh.faces[204].setSmGroup(10);
    mesh.faces[205].setVerts(94,95,88);
    mesh.faces[205].setEdgeVisFlags(1,0,0);
    mesh.faces[205].setSmGroup(10);
    mesh.faces[206].setVerts(94,88,89);
    mesh.faces[206].setEdgeVisFlags(0,1,0);
    mesh.faces[206].setSmGroup(10);
    mesh.faces[207].setVerts(110,111,92);
    mesh.faces[207].setEdgeVisFlags(1,0,0);
    mesh.faces[207].setSmGroup(10);
    mesh.faces[208].setVerts(109,110,92);
    mesh.faces[208].setEdgeVisFlags(1,0,0);
    mesh.faces[208].setSmGroup(10);
    mesh.faces[209].setVerts(109,92,93);
    mesh.faces[209].setEdgeVisFlags(0,1,0);
    mesh.faces[209].setSmGroup(10);
    mesh.faces[210].setVerts(109,93,94);
    mesh.faces[210].setEdgeVisFlags(0,1,0);
    mesh.faces[210].setSmGroup(10);
    mesh.faces[211].setVerts(108,109,94);
    mesh.faces[211].setEdgeVisFlags(1,0,0);
    mesh.faces[211].setSmGroup(10);
    mesh.faces[212].setVerts(89,108,94);
    mesh.faces[212].setEdgeVisFlags(0,0,0);
    mesh.faces[212].setSmGroup(10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\lodob.cpp ===
mesh.setNumVerts(84);
    mesh.setNumFaces(157);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669281));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.255886,0.138565,-0.062750));
    mesh.setVert(11, size * Point3(-0.255886,0.138565,0.120327));
    mesh.setVert(12, size * Point3(-0.333921,0.138565,0.120327));
    mesh.setVert(13, size * Point3(-0.355971,0.138565,0.061940));
    mesh.setVert(14, size * Point3(-0.335218,0.138565,0.061940));
    mesh.setVert(15, size * Point3(-0.335218,0.138565,-0.115746));
    mesh.setVert(16, size * Point3(-0.172808,0.138565,-0.115746));
    mesh.setVert(17, size * Point3(-0.153478,0.138565,-0.062750));
    mesh.setVert(18, size * Point3(-0.255886,-0.139386,-0.062750));
    mesh.setVert(19, size * Point3(-0.255886,-0.139386,0.120327));
    mesh.setVert(20, size * Point3(-0.333921,-0.139386,0.120327));
    mesh.setVert(21, size * Point3(-0.355971,-0.139386,0.061940));
    mesh.setVert(22, size * Point3(-0.335218,-0.139386,0.061940));
    mesh.setVert(23, size * Point3(-0.335218,-0.139386,-0.115746));
    mesh.setVert(24, size * Point3(-0.172808,-0.139386,-0.115746));
    mesh.setVert(25, size * Point3(-0.153478,-0.139386,-0.062750));
    mesh.setVert(26, size * Point3(0.085455,0.138565,0.122003));
    mesh.setVert(27, size * Point3(0.007125,0.138565,0.121810));
    mesh.setVert(28, size * Point3(-0.018307,0.138565,0.121810));
    mesh.setVert(29, size * Point3(-0.134618,0.138565,0.121516));
    mesh.setVert(30, size * Point3(-0.134618,0.138565,-0.115955));
    mesh.setVert(31, size * Point3(-0.057985,0.138565,-0.115746));
    mesh.setVert(32, size * Point3(-0.037301,0.138565,-0.115746));
    mesh.setVert(33, size * Point3(0.085455,0.138565,-0.115144));
    mesh.setVert(34, size * Point3(0.085455,-0.139386,0.122003));
    mesh.setVert(35, size * Point3(0.007125,-0.139386,0.121809));
    mesh.setVert(36, size * Point3(-0.018307,-0.139386,0.121809));
    mesh.setVert(37, size * Point3(-0.134618,-0.139386,0.121516));
    mesh.setVert(38, size * Point3(-0.134618,-0.139386,-0.115955));
    mesh.setVert(39, size * Point3(-0.057985,-0.139386,-0.115746));
    mesh.setVert(40, size * Point3(-0.037301,-0.139386,-0.115746));
    mesh.setVert(41, size * Point3(0.085455,-0.139386,-0.115145));
    mesh.setVert(42, size * Point3(-0.054673,0.138565,-0.060142));
    mesh.setVert(43, size * Point3(-0.054673,0.138565,0.059561));
    mesh.setVert(44, size * Point3(0.001288,0.138565,0.059804));
    mesh.setVert(45, size * Point3(0.001288,0.138565,-0.060038));
    mesh.setVert(46, size * Point3(-0.054673,-0.139386,-0.060142));
    mesh.setVert(47, size * Point3(-0.054673,-0.139386,0.059561));
    mesh.setVert(48, size * Point3(0.001288,-0.139386,0.059804));
    mesh.setVert(49, size * Point3(0.001288,-0.139386,-0.060038));
    mesh.setVert(50, size * Point3(0.351315,0.138565,0.096018));
    mesh.setVert(51, size * Point3(0.343347,0.138565,0.112817));
    mesh.setVert(52, size * Point3(0.328257,0.138565,0.121810));
    mesh.setVert(53, size * Point3(0.229578,0.138565,0.121810));
    mesh.setVert(54, size * Point3(0.206520,0.138565,0.069971));
    mesh.setVert(55, size * Point3(0.206520,0.138565,0.120269));
    mesh.setVert(56, size * Point3(0.133952,0.138565,0.120269));
    mesh.setVert(57, size * Point3(0.109874,0.138565,0.061940));
    mesh.setVert(58, size * Point3(0.129145,0.138565,0.061940));
    mesh.setVert(59, size * Point3(0.129145,0.138565,-0.115746));
    mesh.setVert(60, size * Point3(0.323503,0.138565,-0.115746));
    mesh.setVert(61, size * Point3(0.343640,0.138565,-0.109611));
    mesh.setVert(62, size * Point3(0.351315,0.138565,-0.092670));
    mesh.setVert(63, size * Point3(0.351315,-0.139386,0.096018));
    mesh.setVert(64, size * Point3(0.343347,-0.139386,0.112817));
    mesh.setVert(65, size * Point3(0.328257,-0.139386,0.121809));
    mesh.setVert(66, size * Point3(0.229578,-0.139386,0.121809));
    mesh.setVert(67, size * Point3(0.206520,-0.139386,0.069971));
    mesh.setVert(68, size * Point3(0.206520,-0.139386,0.120269));
    mesh.setVert(69, size * Point3(0.133952,-0.139386,0.120269));
    mesh.setVert(70, size * Point3(0.109874,-0.139386,0.061940));
    mesh.setVert(71, size * Point3(0.129145,-0.139386,0.061940));
    mesh.setVert(72, size * Point3(0.129145,-0.139386,-0.115746));
    mesh.setVert(73, size * Point3(0.323503,-0.139386,-0.115746));
    mesh.setVert(74, size * Point3(0.343640,-0.139386,-0.109611));
    mesh.setVert(75, size * Point3(0.351315,-0.139386,-0.092670));
    mesh.setVert(76, size * Point3(0.211419,0.138565,-0.061894));
    mesh.setVert(77, size * Point3(0.211419,0.138565,0.059547));
    mesh.setVert(78, size * Point3(0.268491,0.138565,0.059181));
    mesh.setVert(79, size * Point3(0.268491,0.138565,-0.061913));
    mesh.setVert(80, size * Point3(0.211419,-0.139386,-0.061894));
    mesh.setVert(81, size * Point3(0.211419,-0.139386,0.059547));
    mesh.setVert(82, size * Point3(0.268491,-0.139386,0.059181));
    mesh.setVert(83, size * Point3(0.268491,-0.139386,-0.061913));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,11,19);
    mesh.faces[13].setEdgeVisFlags(1,1,0);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(10,19,18);
    mesh.faces[14].setEdgeVisFlags(0,1,1);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(11,12,20);
    mesh.faces[15].setEdgeVisFlags(1,1,0);
    mesh.faces[15].setSmGroup(4);
    mesh.faces[16].setVerts(11,20,19);
    mesh.faces[16].setEdgeVisFlags(0,1,1);
    mesh.faces[16].setSmGroup(4);
    mesh.faces[17].setVerts(12,13,21);
    mesh.faces[17].setEdgeVisFlags(1,1,0);
    mesh.faces[17].setSmGroup(2);
    mesh.faces[18].setVerts(12,21,20);
    mesh.faces[18].setEdgeVisFlags(0,1,1);
    mesh.faces[18].setSmGroup(2);
    mesh.faces[19].setVerts(13,14,22);
    mesh.faces[19].setEdgeVisFlags(1,1,0);
    mesh.faces[19].setSmGroup(4);
    mesh.faces[20].setVerts(13,22,21);
    mesh.faces[20].setEdgeVisFlags(0,1,1);
    mesh.faces[20].setSmGroup(4);
    mesh.faces[21].setVerts(14,15,23);
    mesh.faces[21].setEdgeVisFlags(1,1,0);
    mesh.faces[21].setSmGroup(2);
    mesh.faces[22].setVerts(14,23,22);
    mesh.faces[22].setEdgeVisFlags(0,1,1);
    mesh.faces[22].setSmGroup(2);
    mesh.faces[23].setVerts(15,16,24);
    mesh.faces[23].setEdgeVisFlags(1,1,0);
    mesh.faces[23].setSmGroup(4);
    mesh.faces[24].setVerts(15,24,23);
    mesh.faces[24].setEdgeVisFlags(0,1,1);
    mesh.faces[24].setSmGroup(4);
    mesh.faces[25].setVerts(16,17,25);
    mesh.faces[25].setEdgeVisFlags(1,1,0);
    mesh.faces[25].setSmGroup(2);
    mesh.faces[26].setVerts(16,25,24);
    mesh.faces[26].setEdgeVisFlags(0,1,1);
    mesh.faces[26].setSmGroup(2);
    mesh.faces[27].setVerts(17,10,18);
    mesh.faces[27].setEdgeVisFlags(1,1,0);
    mesh.faces[27].setSmGroup(4);
    mesh.faces[28].setVerts(17,18,25);
    mesh.faces[28].setEdgeVisFlags(0,1,1);
    mesh.faces[28].setSmGroup(4);
    mesh.faces[29].setVerts(26,27,35);
    mesh.faces[29].setEdgeVisFlags(1,1,0);
    mesh.faces[29].setSmGroup(1);
    mesh.faces[30].setVerts(26,35,34);
    mesh.faces[30].setEdgeVisFlags(0,1,1);
    mesh.faces[30].setSmGroup(1);
    mesh.faces[31].setVerts(27,28,36);
    mesh.faces[31].setEdgeVisFlags(1,1,0);
    mesh.faces[31].setSmGroup(4);
    mesh.faces[32].setVerts(27,36,35);
    mesh.faces[32].setEdgeVisFlags(0,1,1);
    mesh.faces[32].setSmGroup(4);
    mesh.faces[33].setVerts(28,29,37);
    mesh.faces[33].setEdgeVisFlags(1,1,0);
    mesh.faces[33].setSmGroup(2);
    mesh.faces[34].setVerts(28,37,36);
    mesh.faces[34].setEdgeVisFlags(0,1,1);
    mesh.faces[34].setSmGroup(2);
    mesh.faces[35].setVerts(29,30,38);
    mesh.faces[35].setEdgeVisFlags(1,1,0);
    mesh.faces[35].setSmGroup(4);
    mesh.faces[36].setVerts(29,38,37);
    mesh.faces[36].setEdgeVisFlags(0,1,1);
    mesh.faces[36].setSmGroup(4);
    mesh.faces[37].setVerts(30,31,39);
    mesh.faces[37].setEdgeVisFlags(1,1,0);
    mesh.faces[37].setSmGroup(2);
    mesh.faces[38].setVerts(30,39,38);
    mesh.faces[38].setEdgeVisFlags(0,1,1);
    mesh.faces[38].setSmGroup(2);
    mesh.faces[39].setVerts(31,32,40);
    mesh.faces[39].setEdgeVisFlags(1,1,0);
    mesh.faces[39].setSmGroup(4);
    mesh.faces[40].setVerts(31,40,39);
    mesh.faces[40].setEdgeVisFlags(0,1,1);
    mesh.faces[40].setSmGroup(4);
    mesh.faces[41].setVerts(32,33,41);
    mesh.faces[41].setEdgeVisFlags(1,1,0);
    mesh.faces[41].setSmGroup(2);
    mesh.faces[42].setVerts(32,41,40);
    mesh.faces[42].setEdgeVisFlags(0,1,1);
    mesh.faces[42].setSmGroup(2);
    mesh.faces[43].setVerts(33,26,34);
    mesh.faces[43].setEdgeVisFlags(1,1,0);
    mesh.faces[43].setSmGroup(4);
    mesh.faces[44].setVerts(33,34,41);
    mesh.faces[44].setEdgeVisFlags(0,1,1);
    mesh.faces[44].setSmGroup(4);
    mesh.faces[45].setVerts(42,43,47);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(1);
    mesh.faces[46].setVerts(42,47,46);
    mesh.faces[46].setEdgeVisFlags(0,1,1);
    mesh.faces[46].setSmGroup(1);
    mesh.faces[47].setVerts(43,44,48);
    mesh.faces[47].setEdgeVisFlags(1,1,0);
    mesh.faces[47].setSmGroup(4);
    mesh.faces[48].setVerts(43,48,47);
    mesh.faces[48].setEdgeVisFlags(0,1,1);
    mesh.faces[48].setSmGroup(4);
    mesh.faces[49].setVerts(44,45,49);
    mesh.faces[49].setEdgeVisFlags(1,1,0);
    mesh.faces[49].setSmGroup(2);
    mesh.faces[50].setVerts(44,49,48);
    mesh.faces[50].setEdgeVisFlags(0,1,1);
    mesh.faces[50].setSmGroup(2);
    mesh.faces[51].setVerts(45,42,46);
    mesh.faces[51].setEdgeVisFlags(1,1,0);
    mesh.faces[51].setSmGroup(4);
    mesh.faces[52].setVerts(45,46,49);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(4);
    mesh.faces[53].setVerts(50,51,64);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(1);
    mesh.faces[54].setVerts(50,64,63);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(1);
    mesh.faces[55].setVerts(51,52,65);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(4);
    mesh.faces[56].setVerts(51,65,64);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(4);
    mesh.faces[57].setVerts(52,53,66);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(2);
    mesh.faces[58].setVerts(52,66,65);
    mesh.faces[58].setEdgeVisFlags(0,1,1);
    mesh.faces[58].setSmGroup(2);
    mesh.faces[59].setVerts(53,54,67);
    mesh.faces[59].setEdgeVisFlags(1,1,0);
    mesh.faces[59].setSmGroup(4);
    mesh.faces[60].setVerts(53,67,66);
    mesh.faces[60].setEdgeVisFlags(0,1,1);
    mesh.faces[60].setSmGroup(4);
    mesh.faces[61].setVerts(54,55,68);
    mesh.faces[61].setEdgeVisFlags(1,1,0);
    mesh.faces[61].setSmGroup(2);
    mesh.faces[62].setVerts(54,68,67);
    mesh.faces[62].setEdgeVisFlags(0,1,1);
    mesh.faces[62].setSmGroup(2);
    mesh.faces[63].setVerts(55,56,69);
    mesh.faces[63].setEdgeVisFlags(1,1,0);
    mesh.faces[63].setSmGroup(4);
    mesh.faces[64].setVerts(55,69,68);
    mesh.faces[64].setEdgeVisFlags(0,1,1);
    mesh.faces[64].setSmGroup(4);
    mesh.faces[65].setVerts(56,57,70);
    mesh.faces[65].setEdgeVisFlags(1,1,0);
    mesh.faces[65].setSmGroup(2);
    mesh.faces[66].setVerts(56,70,69);
    mesh.faces[66].setEdgeVisFlags(0,1,1);
    mesh.faces[66].setSmGroup(2);
    mesh.faces[67].setVerts(57,58,71);
    mesh.faces[67].setEdgeVisFlags(1,1,0);
    mesh.faces[67].setSmGroup(4);
    mesh.faces[68].setVerts(57,71,70);
    mesh.faces[68].setEdgeVisFlags(0,1,1);
    mesh.faces[68].setSmGroup(4);
    mesh.faces[69].setVerts(58,59,72);
    mesh.faces[69].setEdgeVisFlags(1,1,0);
    mesh.faces[69].setSmGroup(2);
    mesh.faces[70].setVerts(58,72,71);
    mesh.faces[70].setEdgeVisFlags(0,1,1);
    mesh.faces[70].setSmGroup(2);
    mesh.faces[71].setVerts(59,60,73);
    mesh.faces[71].setEdgeVisFlags(1,1,0);
    mesh.faces[71].setSmGroup(4);
    mesh.faces[72].setVerts(59,73,72);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(4);
    mesh.faces[73].setVerts(60,61,74);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(2);
    mesh.faces[74].setVerts(60,74,73);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(2);
    mesh.faces[75].setVerts(61,62,75);
    mesh.faces[75].setEdgeVisFlags(1,1,0);
    mesh.faces[75].setSmGroup(4);
    mesh.faces[76].setVerts(61,75,74);
    mesh.faces[76].setEdgeVisFlags(0,1,1);
    mesh.faces[76].setSmGroup(4);
    mesh.faces[77].setVerts(62,50,63);
    mesh.faces[77].setEdgeVisFlags(1,1,0);
    mesh.faces[77].setSmGroup(2);
    mesh.faces[78].setVerts(62,63,75);
    mesh.faces[78].setEdgeVisFlags(0,1,1);
    mesh.faces[78].setSmGroup(2);
    mesh.faces[79].setVerts(76,77,81);
    mesh.faces[79].setEdgeVisFlags(1,1,0);
    mesh.faces[79].setSmGroup(1);
    mesh.faces[80].setVerts(76,81,80);
    mesh.faces[80].setEdgeVisFlags(0,1,1);
    mesh.faces[80].setSmGroup(1);
    mesh.faces[81].setVerts(77,78,82);
    mesh.faces[81].setEdgeVisFlags(1,1,0);
    mesh.faces[81].setSmGroup(4);
    mesh.faces[82].setVerts(77,82,81);
    mesh.faces[82].setEdgeVisFlags(0,1,1);
    mesh.faces[82].setSmGroup(4);
    mesh.faces[83].setVerts(78,79,83);
    mesh.faces[83].setEdgeVisFlags(1,1,0);
    mesh.faces[83].setSmGroup(2);
    mesh.faces[84].setVerts(78,83,82);
    mesh.faces[84].setEdgeVisFlags(0,1,1);
    mesh.faces[84].setSmGroup(2);
    mesh.faces[85].setVerts(79,76,80);
    mesh.faces[85].setEdgeVisFlags(1,1,0);
    mesh.faces[85].setSmGroup(4);
    mesh.faces[86].setVerts(79,80,83);
    mesh.faces[86].setEdgeVisFlags(0,1,1);
    mesh.faces[86].setSmGroup(4);
    mesh.faces[87].setVerts(12,14,13);
    mesh.faces[87].setEdgeVisFlags(0,1,1);
    mesh.faces[87].setSmGroup(10);
    mesh.faces[88].setVerts(16,10,17);
    mesh.faces[88].setEdgeVisFlags(0,1,1);
    mesh.faces[88].setSmGroup(10);
    mesh.faces[89].setVerts(15,10,16);
    mesh.faces[89].setEdgeVisFlags(0,0,1);
    mesh.faces[89].setSmGroup(10);
    mesh.faces[90].setVerts(14,10,15);
    mesh.faces[90].setEdgeVisFlags(0,0,1);
    mesh.faces[90].setSmGroup(10);
    mesh.faces[91].setVerts(14,11,10);
    mesh.faces[91].setEdgeVisFlags(0,1,0);
    mesh.faces[91].setSmGroup(10);
    mesh.faces[92].setVerts(14,12,11);
    mesh.faces[92].setEdgeVisFlags(0,1,0);
    mesh.faces[92].setSmGroup(10);
    mesh.faces[93].setVerts(26,44,43);
    mesh.faces[93].setEdgeVisFlags(0,1,0);
    mesh.faces[93].setSmGroup(10);
    mesh.faces[94].setVerts(43,27,26);
    mesh.faces[94].setEdgeVisFlags(0,1,0);
    mesh.faces[94].setSmGroup(10);
    mesh.faces[95].setVerts(43,28,27);
    mesh.faces[95].setEdgeVisFlags(0,1,0);
    mesh.faces[95].setSmGroup(10);
    mesh.faces[96].setVerts(33,44,26);
    mesh.faces[96].setEdgeVisFlags(0,0,1);
    mesh.faces[96].setSmGroup(10);
    mesh.faces[97].setVerts(33,45,44);
    mesh.faces[97].setEdgeVisFlags(0,1,0);
    mesh.faces[97].setSmGroup(10);
    mesh.faces[98].setVerts(32,45,33);
    mesh.faces[98].setEdgeVisFlags(0,0,1);
    mesh.faces[98].setSmGroup(10);
    mesh.faces[99].setVerts(32,42,45);
    mesh.faces[99].setEdgeVisFlags(0,1,0);
    mesh.faces[99].setSmGroup(10);
    mesh.faces[100].setVerts(43,29,28);
    mesh.faces[100].setEdgeVisFlags(0,1,0);
    mesh.faces[100].setSmGroup(10);
    mesh.faces[101].setVerts(43,30,29);
    mesh.faces[101].setEdgeVisFlags(0,1,0);
    mesh.faces[101].setSmGroup(10);
    mesh.faces[102].setVerts(42,30,43);
    mesh.faces[102].setEdgeVisFlags(0,0,1);
    mesh.faces[102].setSmGroup(10);
    mesh.faces[103].setVerts(42,31,30);
    mesh.faces[103].setEdgeVisFlags(0,1,0);
    mesh.faces[103].setSmGroup(10);
    mesh.faces[104].setVerts(32,31,42);
    mesh.faces[104].setEdgeVisFlags(1,0,0);
    mesh.faces[104].setSmGroup(10);
    mesh.faces[105].setVerts(50,78,77);
    mesh.faces[105].setEdgeVisFlags(0,1,0);
    mesh.faces[105].setSmGroup(10);
    mesh.faces[106].setVerts(62,78,50);
    mesh.faces[106].setEdgeVisFlags(0,0,1);
    mesh.faces[106].setSmGroup(10);
    mesh.faces[107].setVerts(62,79,78);
    mesh.faces[107].setEdgeVisFlags(0,1,0);
    mesh.faces[107].setSmGroup(10);
    mesh.faces[108].setVerts(56,58,57);
    mesh.faces[108].setEdgeVisFlags(0,1,1);
    mesh.faces[108].setSmGroup(10);
    mesh.faces[109].setVerts(77,51,50);
    mesh.faces[109].setEdgeVisFlags(0,1,0);
    mesh.faces[109].setSmGroup(10);
    mesh.faces[110].setVerts(77,52,51);
    mesh.faces[110].setEdgeVisFlags(0,1,0);
    mesh.faces[110].setSmGroup(10);
    mesh.faces[111].setVerts(77,53,52);
    mesh.faces[111].setEdgeVisFlags(0,1,0);
    mesh.faces[111].setSmGroup(10);
    mesh.faces[112].setVerts(77,54,53);
    mesh.faces[112].setEdgeVisFlags(0,1,0);
    mesh.faces[112].setSmGroup(10);
    mesh.faces[113].setVerts(61,79,62);
    mesh.faces[113].setEdgeVisFlags(0,0,1);
    mesh.faces[113].setSmGroup(10);
    mesh.faces[114].setVerts(60,79,61);
    mesh.faces[114].setEdgeVisFlags(0,0,1);
    mesh.faces[114].setSmGroup(10);
    mesh.faces[115].setVerts(59,79,60);
    mesh.faces[115].setEdgeVisFlags(0,0,1);
    mesh.faces[115].setSmGroup(10);
    mesh.faces[116].setVerts(59,76,79);
    mesh.faces[116].setEdgeVisFlags(0,1,0);
    mesh.faces[116].setSmGroup(10);
    mesh.faces[117].setVerts(58,76,59);
    mesh.faces[117].setEdgeVisFlags(0,0,1);
    mesh.faces[117].setSmGroup(10);
    mesh.faces[118].setVerts(58,77,76);
    mesh.faces[118].setEdgeVisFlags(0,1,0);
    mesh.faces[118].setSmGroup(10);
    mesh.faces[119].setVerts(58,54,77);
    mesh.faces[119].setEdgeVisFlags(0,0,0);
    mesh.faces[119].setSmGroup(10);
    mesh.faces[120].setVerts(56,54,58);
    mesh.faces[120].setEdgeVisFlags(0,0,0);
    mesh.faces[120].setSmGroup(10);
    mesh.faces[121].setVerts(55,54,56);
    mesh.faces[121].setEdgeVisFlags(1,0,1);
    mesh.faces[121].setSmGroup(10);
    mesh.faces[122].setVerts(20,21,22);
    mesh.faces[122].setEdgeVisFlags(1,1,0);
    mesh.faces[122].setSmGroup(10);
    mesh.faces[123].setVerts(24,25,18);
    mesh.faces[123].setEdgeVisFlags(1,1,0);
    mesh.faces[123].setSmGroup(10);
    mesh.faces[124].setVerts(23,24,18);
    mesh.faces[124].setEdgeVisFlags(1,0,0);
    mesh.faces[124].setSmGroup(10);
    mesh.faces[125].setVerts(22,23,18);
    mesh.faces[125].setEdgeVisFlags(1,0,0);
    mesh.faces[125].setSmGroup(10);
    mesh.faces[126].setVerts(22,18,19);
    mesh.faces[126].setEdgeVisFlags(0,1,0);
    mesh.faces[126].setSmGroup(10);
    mesh.faces[127].setVerts(22,19,20);
    mesh.faces[127].setEdgeVisFlags(0,1,0);
    mesh.faces[127].setSmGroup(10);
    mesh.faces[128].setVerts(34,47,48);
    mesh.faces[128].setEdgeVisFlags(0,1,0);
    mesh.faces[128].setSmGroup(10);
    mesh.faces[129].setVerts(47,34,35);
    mesh.faces[129].setEdgeVisFlags(0,1,0);
    mesh.faces[129].setSmGroup(10);
    mesh.faces[130].setVerts(47,35,36);
    mesh.faces[130].setEdgeVisFlags(0,1,0);
    mesh.faces[130].setSmGroup(10);
    mesh.faces[131].setVerts(41,34,48);
    mesh.faces[131].setEdgeVisFlags(1,0,0);
    mesh.faces[131].setSmGroup(10);
    mesh.faces[132].setVerts(41,48,49);
    mesh.faces[132].setEdgeVisFlags(0,1,0);
    mesh.faces[132].setSmGroup(10);
    mesh.faces[133].setVerts(40,41,49);
    mesh.faces[133].setEdgeVisFlags(1,0,0);
    mesh.faces[133].setSmGroup(10);
    mesh.faces[134].setVerts(40,49,46);
    mesh.faces[134].setEdgeVisFlags(0,1,0);
    mesh.faces[134].setSmGroup(10);
    mesh.faces[135].setVerts(47,36,37);
    mesh.faces[135].setEdgeVisFlags(0,1,0);
    mesh.faces[135].setSmGroup(10);
    mesh.faces[136].setVerts(47,37,38);
    mesh.faces[136].setEdgeVisFlags(0,1,0);
    mesh.faces[136].setSmGroup(10);
    mesh.faces[137].setVerts(46,47,38);
    mesh.faces[137].setEdgeVisFlags(1,0,0);
    mesh.faces[137].setSmGroup(10);
    mesh.faces[138].setVerts(46,38,39);
    mesh.faces[138].setEdgeVisFlags(0,1,0);
    mesh.faces[138].setSmGroup(10);
    mesh.faces[139].setVerts(40,46,39);
    mesh.faces[139].setEdgeVisFlags(0,0,1);
    mesh.faces[139].setSmGroup(10);
    mesh.faces[140].setVerts(63,81,82);
    mesh.faces[140].setEdgeVisFlags(0,1,0);
    mesh.faces[140].setSmGroup(10);
    mesh.faces[141].setVerts(75,63,82);
    mesh.faces[141].setEdgeVisFlags(1,0,0);
    mesh.faces[141].setSmGroup(10);
    mesh.faces[142].setVerts(75,82,83);
    mesh.faces[142].setEdgeVisFlags(0,1,0);
    mesh.faces[142].setSmGroup(10);
    mesh.faces[143].setVerts(69,70,71);
    mesh.faces[143].setEdgeVisFlags(1,1,0);
    mesh.faces[143].setSmGroup(10);
    mesh.faces[144].setVerts(81,63,64);
    mesh.faces[144].setEdgeVisFlags(0,1,0);
    mesh.faces[144].setSmGroup(10);
    mesh.faces[145].setVerts(81,64,65);
    mesh.faces[145].setEdgeVisFlags(0,1,0);
    mesh.faces[145].setSmGroup(10);
    mesh.faces[146].setVerts(81,65,66);
    mesh.faces[146].setEdgeVisFlags(0,1,0);
    mesh.faces[146].setSmGroup(10);
    mesh.faces[147].setVerts(81,66,67);
    mesh.faces[147].setEdgeVisFlags(0,1,0);
    mesh.faces[147].setSmGroup(10);
    mesh.faces[148].setVerts(74,75,83);
    mesh.faces[148].setEdgeVisFlags(1,0,0);
    mesh.faces[148].setSmGroup(10);
    mesh.faces[149].setVerts(73,74,83);
    mesh.faces[149].setEdgeVisFlags(1,0,0);
    mesh.faces[149].setSmGroup(10);
    mesh.faces[150].setVerts(72,73,83);
    mesh.faces[150].setEdgeVisFlags(1,0,0);
    mesh.faces[150].setSmGroup(10);
    mesh.faces[151].setVerts(72,83,80);
    mesh.faces[151].setEdgeVisFlags(0,1,0);
    mesh.faces[151].setSmGroup(10);
    mesh.faces[152].setVerts(71,72,80);
    mesh.faces[152].setEdgeVisFlags(1,0,0);
    mesh.faces[152].setSmGroup(10);
    mesh.faces[153].setVerts(71,80,81);
    mesh.faces[153].setEdgeVisFlags(0,1,0);
    mesh.faces[153].setSmGroup(10);
    mesh.faces[154].setVerts(71,81,67);
    mesh.faces[154].setEdgeVisFlags(0,0,0);
    mesh.faces[154].setSmGroup(10);
    mesh.faces[155].setVerts(69,71,67);
    mesh.faces[155].setEdgeVisFlags(0,0,0);
    mesh.faces[155].setSmGroup(10);
    mesh.faces[156].setVerts(68,69,67);
    mesh.faces[156].setEdgeVisFlags(1,0,1);
    mesh.faces[156].setSmGroup(10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\inline.cpp ===
/**********************************************************************
 *<
    FILE: vrml_ins.cpp

    DESCRIPTION:  A VRML Insert helper implementation
 
    CREATED BY: Charles Thaeler
  
    HISTORY: created 6 Mar. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "bookmark.h"
#include "inline.h"

// Parameter block indices
#define PB_LENGTH	0

//------------------------------------------------------

class VRMLInsertClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE) { return new VRMLInsObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_INLINE_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(VRML_INS_CLASS_ID1,
                                                    VRML_INS_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static VRMLInsertClassDesc vrmlInsertDesc;

ClassDesc* GetVRMLInsertDesc() { return &vrmlInsertDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ISpinnerControl *VRMLInsObject::sizeSpin = NULL;

HWND VRMLInsObject::hRollup = NULL;

BOOL CALLBACK
VRMLInsRollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    VRMLInsObject *th = (VRMLInsObject *)GetWindowLong( hDlg, GWL_USERDATA );	
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG: {
        th = (VRMLInsObject *)lParam;
        BOOL usingsize = th->GetUseSize();
        SetWindowLong( hDlg, GWL_USERDATA, (LONG)th );
        SetDlgFont( hDlg, th->iObjParams->GetAppHFont() );

        th->sizeSpin = GetISpinner(GetDlgItem(hDlg,IDC_INS_SIZE_SPINNER));
        th->sizeSpin->SetLimits( 0, 999999, FALSE );
        th->sizeSpin->SetScale( 1.0f );
        th->sizeSpin->SetValue( th->GetSize(), FALSE );
        th->sizeSpin->LinkToEdit( GetDlgItem(hDlg,IDC_INS_SIZE), EDITTYPE_POS_FLOAT );
        EnableWindow(GetDlgItem(hDlg, IDC_INS_SIZE), TRUE);
        EnableWindow(GetDlgItem(hDlg, IDC_INS_SIZE_SPINNER), TRUE);

        SendMessage(GetDlgItem(hDlg,IDC_INS_URL), WM_SETTEXT, 0, (LPARAM)th->insURL.data());
        EnableWindow(GetDlgItem(hDlg, IDC_INS_URL), TRUE);

        CheckDlgButton(hDlg, IDC_INS_BBOX_SIZE, usingsize);
        CheckDlgButton(hDlg, IDC_INS_BBOX_DEF, !usingsize);

    }
    return TRUE;			

    case WM_DESTROY:
        ReleaseISpinner( th->sizeSpin );
        return FALSE;

    case CC_SPINNER_CHANGE:
        switch ( LOWORD(wParam) ) {
        case IDC_INS_SIZE_SPINNER:
            th->SetSize( th->sizeSpin->GetFVal() );
            th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_INTERACTIVE);
            break;
        }
        return TRUE;

    case CC_SPINNER_BUTTONUP:
        th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_END);
        return TRUE;

    case WM_MOUSEACTIVATE:
        th->iObjParams->RealizeParamPanel();
        return FALSE;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
        th->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
        return FALSE;

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_BOOKMARKS:
            // do bookmarks
            if (GetBookmarkURL(th->iObjParams, &th->insURL, NULL, NULL)) {
                // get the new URL information;
                SendMessage(GetDlgItem(hDlg,IDC_INS_URL), WM_SETTEXT, 0,
                            (LPARAM)th->insURL.data());
            }
            break;
        case IDC_INS_URL:
            switch(HIWORD(wParam)) {
            case EN_SETFOCUS:
                DisableAccelerators();					
                break;
            case EN_KILLFOCUS:
                EnableAccelerators();
                break;
            case EN_CHANGE:
                int len = SendDlgItemMessage(hDlg, IDC_INS_URL, WM_GETTEXTLENGTH, 0, 0);
                TSTR temp;
                temp.Resize(len+1);
                SendDlgItemMessage(hDlg, IDC_INS_URL, WM_GETTEXT, len+1, (LPARAM)temp.data());
                th->insURL = temp;
                break;
            }
            break;
        case IDC_INS_BBOX_SIZE:
        case IDC_INS_BBOX_DEF:
            th->SetUseSize(IsDlgButtonChecked(hDlg, IDC_INS_BBOX_SIZE));
            break;
        }
        return FALSE;

    default:
        return FALSE;
    }
}


void
VRMLInsObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
    iObjParams = ip;
	
    if ( !hRollup ) {
        hRollup = ip->AddRollupPage(
            hInstance,
            MAKEINTRESOURCE(IDD_INS),
            VRMLInsRollupDialogProc,
            GetString(IDS_VRML_INS_TITLE),
            (LPARAM)this );
 
        ip->RegisterDlgWnd(hRollup);
    } else {
        SetWindowLong( hRollup, GWL_USERDATA, (LONG)this );
		
        // Init the dialog to our values.
    }
}
		
void
VRMLInsObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (hRollup) {
            ip->UnRegisterDlgWnd(hRollup);
            ip->DeleteRollupPage(hRollup);
            hRollup = NULL;
        }
    } else {
        if (hRollup)
            SetWindowLong( hRollup, GWL_USERDATA, 0 );
    }
	
    iObjParams = NULL;
}

VRMLInsObject::VRMLInsObject() : HelperObject() 
{
    radius = 0.0f;
    useSize = TRUE;
    // Initialize the object from the dlg versions
}

VRMLInsObject::~VRMLInsObject()
{
}

void
VRMLInsObject::SetSize( float r )
{
    radius = r;
    NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

IObjParam *VRMLInsObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
VRMLInsObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message ) 
{
    switch (message) {
    case REFMSG_CHANGE:
        // UpdateUI(iObjParams->GetTime());
        break;

    case REFMSG_GET_PARAM_DIM: {
        GetParamDim *gpd = (GetParamDim*)partID;
        switch (gpd->index) {
        case 0:
            gpd->dim = stdWorldDim;
            break;				
        }
        return REF_STOP; 
    }

    case REFMSG_GET_PARAM_NAME: {
        GetParamName *gpn = (GetParamName*)partID;
        switch (gpn->index) {
        case 0:
            // gpn->name = TSTR(GetResString(IDS_DB_TAPE_LENGTH));
            break;												
        }
        return REF_STOP; 
    }
    }
    return(REF_SUCCEED);
}

ObjectState
VRMLInsObject::Eval(TimeValue time){
    return ObjectState(this);
}

Interval
VRMLInsObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    // UpdateUI(time);
    return ivalid;	
}

void
VRMLInsObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
#ifdef FIXED_SIZE
    float scaleFactor = vpt->GetVPWorldWidth(tm.GetTrans())/(float)360.0;
    if (scaleFactor!=1.0f)
        tm.Scale(Point3(scaleFactor,scaleFactor,scaleFactor));
#endif
}

void
VRMLInsObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();
#ifdef FIXED_SIZE
    float scaleFactor = vpt->GetVPWorldWidth(m.GetTrans())/(float)360.0;
    box.Scale(scaleFactor);
#endif
}

void
VRMLInsObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}

void
VRMLInsObject::MakeQuad(int *f, int a, int b, int c, int d, int vab, int vbc, int vcd, int vda)
{
    mesh.faces[*f].setVerts(a, b, c);			// back Face
    mesh.faces[*f].setEdgeVisFlags(vab, vbc, 0);
    mesh.faces[(*f)++].setSmGroup(0);

    mesh.faces[*f].setVerts(c, d, a);
    mesh.faces[*f].setEdgeVisFlags(vcd, vda, 0);
    mesh.faces[(*f)++].setSmGroup(0);
}

void
VRMLInsObject::BuildMesh()
{
    float r = radius,
        r2 = r/3.0f;

    mesh.setNumVerts(28);
    mesh.setNumFaces(52);

    int v = 0;
    mesh.setVert(v++, Point3(  -r2,  r2,  r2));  //0 -- back of center cube of the plus
    mesh.setVert(v++, Point3(  -r2,  r2, -r2));
    mesh.setVert(v++, Point3(   r2,  r2, -r2));
    mesh.setVert(v++, Point3(   r2,  r2,  r2));

    mesh.setVert(v++, Point3(  -r2, -r2,  r2));  //4 -- front of center cube of the plus
    mesh.setVert(v++, Point3(  -r2, -r2, -r2));
    mesh.setVert(v++, Point3(   r2, -r2, -r2));
    mesh.setVert(v++, Point3(   r2, -r2,  r2));

    mesh.setVert(v++, Point3( -r2,  -r,  r2));   //8 -- front of the plus
    mesh.setVert(v++, Point3( -r2,  -r, -r2));
    mesh.setVert(v++, Point3(  r2,  -r, -r2));
    mesh.setVert(v++, Point3(  r2,  -r,  r2));

    mesh.setVert(v++, Point3(  -r,  r2,  r2));   //12 -- left end
    mesh.setVert(v++, Point3(  -r,  r2, -r2));
    mesh.setVert(v++, Point3(  -r, -r2, -r2));
    mesh.setVert(v++, Point3(  -r, -r2,  r2));

    mesh.setVert(v++, Point3(   r,  r2,  r2));   //16 -- right end
    mesh.setVert(v++, Point3(   r,  r2, -r2));
    mesh.setVert(v++, Point3(   r, -r2, -r2));
    mesh.setVert(v++, Point3(   r, -r2,  r2));

    mesh.setVert(v++, Point3( -r2,  r2,   r));   //20 -- top end
    mesh.setVert(v++, Point3(  r2,  r2,   r));
    mesh.setVert(v++, Point3(  r2, -r2,   r));
    mesh.setVert(v++, Point3( -r2, -r2,   r));

    mesh.setVert(v++, Point3( -r,  r,  -r));     //24 -- bottom end
    mesh.setVert(v++, Point3(  r,  r,  -r));
    mesh.setVert(v++, Point3(  r, -r,  -r));
    mesh.setVert(v++, Point3( -r, -r,  -r));

    /* Now the Faces */
    int f = 0;
    // TOP
    MakeQuad(&f, 23, 22, 21, 20, 1, 1, 1, 1);  // Top
    MakeQuad(&f,  7, 22, 23,  4, 1, 0, 0, 1);  // Front
    MakeQuad(&f,  3, 21, 22,  7, 1, 0, 0, 1);  // Right
    MakeQuad(&f,  0, 20, 21,  3, 1, 0, 0, 0);  // Back
    MakeQuad(&f,  4, 23, 20,  0, 1, 0, 0, 1);  // Left

    // FRONT
    MakeQuad(&f,  8,  9, 10, 11, 1, 1, 1, 1);  // End
    MakeQuad(&f,  4,  8, 11,  7, 1, 0, 0, 0);  // Top
    MakeQuad(&f,  7, 11, 10,  6, 1, 0, 0, 1);  // Right
    MakeQuad(&f,  6, 10,  9,  5, 1, 0, 1, 1);  // Bottom
    MakeQuad(&f,  5,  9,  8,  4, 1, 0, 0, 1);  // Left

    // LEFT
    MakeQuad(&f, 12, 13, 14, 15, 1, 1, 1, 1);  // End
    MakeQuad(&f,  0, 12, 15,  4, 1, 0, 0, 0);  // Top
    MakeQuad(&f,  4, 15, 14,  5, 1, 0, 0, 0);  // Right
    MakeQuad(&f,  5, 14, 13,  1, 1, 0, 0, 1);  // Bottom
    MakeQuad(&f,  1, 13, 12,  0, 1, 0, 0, 0);  // Left

    // BACK
    MakeQuad(&f,  3,  2,  1,  0, 0, 1, 0, 0);  // Left

    // RIGHT
    MakeQuad(&f, 19, 18, 17, 16, 1, 1, 1, 1);  // End
    MakeQuad(&f,  7, 19, 16,  3, 1, 0, 0, 0);  // Top
    MakeQuad(&f,  3, 16, 17,  2, 1, 0, 0, 0);  // Right
    MakeQuad(&f,  2, 17, 18,  6, 1, 0, 0, 1);  // Bottom
    MakeQuad(&f,  6, 18, 19,  7, 1, 0, 0, 0);  // Left

    // BASE
    MakeQuad(&f, 24, 25, 26, 27, 1, 1, 1, 1);  // Bottom
    MakeQuad(&f,  5, 27, 26,  6, 1, 0, 0, 0);  // Front
    MakeQuad(&f,  6, 26, 25,  2, 1, 0, 0, 0);  // Right
    MakeQuad(&f,  2, 25, 24,  1, 1, 0, 0, 0);  // Back
    MakeQuad(&f,  1, 24, 27,  5, 1, 0, 0, 0);  // Left


    mesh.InvalidateGeomCache();
    mesh.EnableEdgeList(1);
}

int
VRMLInsObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    if (radius <= 0.0)
        return 0;
    BuildMesh();
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.0f, 1.0f, 0.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);
    gw->setRndLimits(rlim);
    return(0);
}

int
VRMLInsObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class VRMLInsCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    VRMLInsObject *vrmlInsObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(VRMLInsObject *obj) {vrmlInsObject = obj;}

};

			
int
VRMLInsCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg				
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            vrmlInsObject->radius = Length(p1-p0);
            if (vrmlInsObject->sizeSpin)
                vrmlInsObject->sizeSpin->SetValue( vrmlInsObject->radius, FALSE );
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
                mat.PreRotateZ(vrmlInsObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {										
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static VRMLInsCreateCallBack vrmlInsCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
VRMLInsObject::GetCreateMouseCallBack() 
{
    vrmlInsCreateCB.SetObj(this);
    return(&vrmlInsCreateCB);
}

// IO
#define VRML_INS_SIZE_CHUNK		0xacb0
#define VRML_INS_URL_CHUNK		0xacb1
#define VRML_INS_BBOX_CHUNK     0xacb2

IOResult
VRMLInsObject::Save(ISave *isave)
{
    ULONG written;

    isave->BeginChunk(VRML_INS_SIZE_CHUNK);
    isave->Write(&radius, sizeof(float), &written);
    isave->EndChunk();

    isave->BeginChunk(VRML_INS_URL_CHUNK);
#ifdef _UNICODE
    isave->WriteWString(insURL.data());
#else
    isave->WriteCString(insURL.data());
#endif
    isave->EndChunk();

    isave->BeginChunk(VRML_INS_BBOX_CHUNK);
    isave->Write(&useSize, sizeof(int), &written);
    isave->EndChunk();

    return IO_OK;
}

IOResult
VRMLInsObject::Load(ILoad *iload)
{
    ULONG nread;
    IOResult res;

    while (IO_OK==(res=iload->OpenChunk())) {
        switch(iload->CurChunkID()) {
        case VRML_INS_SIZE_CHUNK:
            iload->Read(&radius, sizeof(float), &nread);
            break;
        case VRML_INS_URL_CHUNK: {
            char *n;
#ifdef _UNICODE
            iload->ReadWStringChunk(&n);
#else
            iload->ReadCStringChunk(&n);
#endif
            insURL = n;
            break;
        }
        case VRML_INS_BBOX_CHUNK: {
            iload->Read((int *)&useSize, sizeof(int), &nread);
            break;
        }
        }
        iload->CloseChunk();
        if (res!=IO_OK) 
            return res;
    }
    return IO_OK;
}

RefTargetHandle
VRMLInsObject::Clone(RemapDir& remap)
{
    VRMLInsObject* vi = new VRMLInsObject();
    vi->radius = radius;
    vi->insURL = insURL;
    vi->useSize = useSize;
    return vi;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\inlist.h ===
/**********************************************************************
 *<
    FILE: inlist.h
 
    DESCRIPTION:  Defines a List of INodes
 
    CREATED BY: Scott Morrison
 
    HISTORY: created January 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef _INLIST_H_
#define _INLIST_H_

// List of inodes.

class INodeList
{
public:
  INodeList(INode* nd) {node = nd; next = NULL; }
  ~INodeList() {delete next;}
  INodeList* AddNode(INode* nd)
    {INodeList *n = new INodeList(nd); n->next = this; return n;}
  BOOL NodeInList(INode* nd) {
    for(INodeList *l = this; l; l = l->next)
      if (l->node == nd)
        return TRUE;
    return FALSE;
  }
  INode*     GetNode() { return node; }
  INodeList* GetNext() { return next; }

private:  
  INode     *node;
  INodeList *next;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\inline.h ===
/**********************************************************************
 *<
    FILE: vrml_ins.h
 
    DESCRIPTION:  Defines a VRML Insert Helper Class
 
    CREATED BY: Charles Thaeler
 
    HISTORY: created 6 Feb. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __VRML_INS__H__
 
#define __VRML_INS__H__
 
#define VRML_INS_CLASS_ID1 0xACAD4567
#define VRML_INS_CLASS_ID2 0x0

extern ClassDesc* GetVRMLInsDesc();

class VRMLInsCreateCallBack;

class VRMLInsObject: public HelperObject {			   
    friend class VRMLInsCreateCallBack;
    friend BOOL CALLBACK VRMLInsRollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );

    // Class vars
    static HWND hRollup;
    static ISpinnerControl *sizeSpin;


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void MakeQuad(int *f, int a, int b, int c, int d, int vab, int vbc, int vcd, int vda);
    void BuildMesh(void);
    TSTR insURL;
    BOOL useSize;

public:
    VRMLInsObject();
    ~VRMLInsObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
    //	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_INLINE)); }


    void SetSize(float r);
    float GetSize(void) { return radius; }
    void SetUseSize(int v) { useSize = v; }
    BOOL GetUseSize(void) { return useSize; }

    TSTR& GetUrl(void) { return insURL; }

    // From Object
    ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_INLINE)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(VRML_INS_CLASS_ID1,
                                         VRML_INS_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_INLINE_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam ){return(0);}

    // IO
    IOResult Save(ISave *isave);
    IOResult Load(ILoad *iload);
};				


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\navinfo.cpp ===
/**********************************************************************
 *<
    FILE: navinfo.cpp

    DESCRIPTION:  A VRML Navigation Info Helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 19 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "navinfo.h"

//------------------------------------------------------

class NavInfoClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new NavInfoObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_NAV_INFO_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(NavInfo_CLASS_ID1,
                                                    NavInfo_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static NavInfoClassDesc NavInfoDesc;

ClassDesc* GetNavInfoDesc() { return &NavInfoDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

HWND NavInfoObject::hRollup = NULL;
int NavInfoObject::dlgPrevSel = -1;

TCHAR* navTypes[] =
    {_T("WALK"), _T("EXAMINE"), _T("FLY"), _T("NONE")};

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  NavInfoObject* th)
{
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG: {
        HWND cb = GetDlgItem(hDlg, IDC_TYPE);
        int i;
        for(i = 0; i < 4; i++) 
            ComboBox_AddString(cb, navTypes[i]);
        int type;
        th->pblock->GetValue(PB_TYPE, th->iObjParams->GetTime(), type, FOREVER);
        if (type < 0 || type > 3)
            type = 0;
        ComboBox_SelectString(cb, 0, navTypes[type]);
        return TRUE;
    }

    case WM_COMMAND:			
        switch(HIWORD(wParam)) {
        case LBN_SELCHANGE:
            HWND cb = GetDlgItem(hDlg, IDC_TYPE);
            int curSel = ComboBox_GetCurSel(cb);
            if (curSel < 0 || curSel > 3)
                curSel = 0;
            th->pblock->SetValue(PB_TYPE, th->iObjParams->GetTime(), curSel);
            return TRUE;
        }
        
    default:
        return FALSE;
    }

    return FALSE;
}

static ParamUIDesc descParam[] = {
  // Collision
  ParamUIDesc(
              PB_COLLISION,
              EDITTYPE_UNIVERSE,
              IDC_COLLISION_EDIT, IDC_COLLISION_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Size
  ParamUIDesc(
              PB_NI_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Terrain
  ParamUIDesc(
              PB_TERRAIN,
              EDITTYPE_UNIVERSE,
              IDC_TERRAIN_EDIT, IDC_TERRAIN_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	


  // Step Height
  ParamUIDesc(
              PB_STEP,
              EDITTYPE_UNIVERSE,
              IDC_STEP_EDIT, IDC_STEP_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Loop
  ParamUIDesc(PB_HEADLIGHT, TYPE_SINGLECHEKBOX, IDC_HEADLIGHT),

  // Speed
  ParamUIDesc(
              PB_SPEED,
              EDITTYPE_UNIVERSE,
              IDC_SPEED_EDIT, IDC_SPEED_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Visibilit Limit
  ParamUIDesc(
              PB_VIS_LIMIT,
              EDITTYPE_UNIVERSE,
              IDC_VIS_LIMIT_EDIT, IDC_VIS_LIMIT_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	
};

  

#define PARAMDESC_LENGTH 7

static ParamBlockDescID descVer0[] = {
  { TYPE_INT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_FLOAT, NULL, FALSE, 3 },
  { TYPE_FLOAT, NULL, FALSE, 4 },
  { TYPE_FLOAT, NULL, FALSE, 5 },
  { TYPE_FLOAT, NULL, FALSE, 6 },
};

static ParamBlockDescID descVer1[] = {
  { TYPE_INT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_FLOAT, NULL, FALSE, 3 },
  { TYPE_FLOAT, NULL, FALSE, 4 },
  { TYPE_FLOAT, NULL, FALSE, 5 },
  { TYPE_FLOAT, NULL, FALSE, 6 },
  { TYPE_FLOAT, NULL, FALSE, 7 },
};

#define NUM_OLD_VERSIONS 1

static ParamVersionDesc versions[] = {
  ParamVersionDesc(descVer0,7,0),
};

// Current version
#define CURRENT_VERSION	1
static ParamVersionDesc curVersion(descVer1, PB_NA_LENGTH, CURRENT_VERSION);

class NavInfoParamDlgProc : public ParamMapUserDlgProc {
public:
  NavInfoObject *ob;

  NavInfoParamDlgProc(NavInfoObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL NavInfoParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *NavInfoObject::pmapParam = NULL;

IOResult
NavInfoObject::Load(ILoad *iload) 
{
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(versions,
                                                     NUM_OLD_VERSIONS,
                                                     &curVersion,this,0));
  return IO_OK;
}

void
NavInfoObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        
        // Left over from last NavInfo created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_NAV_INFO),
                                     _T("NavigationInfo"),
                                     0);
    }
    
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new NavInfoParamDlgProc(this));
    }
}

void
NavInfoObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

NavInfoObject::NavInfoObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer1, PB_NA_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_TYPE, 0, 0);
    pb->SetValue(PB_HEADLIGHT, 0, FALSE);
    pb->SetValue(PB_VIS_LIMIT, 0, 0.0f);
    pb->SetValue(PB_SPEED, 0, 1.0f);
    pb->SetValue(PB_COLLISION, 0, 0.25f);
    pb->SetValue(PB_TERRAIN, 0, 1.6f);
    pb->SetValue(PB_STEP, 0, 0.75f);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    
}

NavInfoObject::~NavInfoObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *NavInfoObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
NavInfoObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
//     int i;
//     switch (message) {
//     }
     return REF_SUCCEED;
}

RefTargetHandle
NavInfoObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    return NULL;
}

void
NavInfoObject::SetReference(int ind, RefTargetHandle rtarg)
{
    pblock = (IParamBlock*) rtarg;
}

ObjectState
NavInfoObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
NavInfoObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
NavInfoObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
NavInfoObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    BuildMesh(t);
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
NavInfoObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    BuildMesh(t);
    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
NavInfoObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_NI_SIZE, t, size, FOREVER);
#include "niob.cpp"
}

int
NavInfoObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_NI_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.0f, 0.0f, 1.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
NavInfoObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class NavInfoCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    NavInfoObject *navInfoObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(NavInfoObject *obj) {navInfoObject = obj;}

};

			
int
NavInfoCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            navInfoObject->pblock->SetValue(PB_NI_SIZE,
                                               navInfoObject->
                                               iObjParams->GetTime(), radius);
            navInfoObject->pmapParam->Invalidate();
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(navInfoObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static NavInfoCreateCallBack NavInfoCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
NavInfoObject::GetCreateMouseCallBack() 
{
    NavInfoCreateCB.SetObj(this);
    return(&NavInfoCreateCB);
}

RefTargetHandle
NavInfoObject::Clone(RemapDir& remap)
{
    NavInfoObject* ni = new NavInfoObject();
    ni->ReplaceReference(0, pblock->Clone(remap));
    return ni;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\lod.h ===
/**********************************************************************
 *<
    FILE: lod.h
 
    DESCRIPTION:  Defines a Mr. Blue Helper Class
 
    CREATED BY: Charles Thaeler
 
    HISTORY: created 29 Feb. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __LOD__H__
 
#define __LOD__H__
 
#define LOD_CLASS_ID1 0xACAD3456
#define LOD_CLASS_ID2 0x0

extern ClassDesc* GetLODDesc();

class LODCreateCallBack;
class LODObjPick;

class LODObj {
public:
	INode *node;
	TSTR listStr;
	float dist;
	void ResetStr(void) {
		if (node)
			listStr.printf("%s   %g", node->GetName(), dist);
		else listStr.printf("%s   %g", _T("NO_NAME"), dist);
	}
	void SetDist(float d) { dist = d; ResetStr(); }
	LODObj(INode *n = NULL, float d = 0.0f) {
		node = n;
		dist = d;
		ResetStr();
	}
};

class LODObject: public HelperObject {			   
	friend class LODCreateCallBack;
	friend class LODObjPick;
	friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam );
	friend void BuildObjectList(LODObject *ob);

	// Class vars
    static HWND hRollup;
	static ISpinnerControl *sizeSpin;
	static ISpinnerControl *distSpin;
	static ICustButton *lodPickButton;
	static int dlgPrevSel;


	RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
	   PartID& partID, RefMessage message );
	float radius;
	float dlgCurSelDist;
	static IObjParam *iObjParams;

	Mesh mesh;
	void BuildMesh(void);
	void GetDistPoints(float radius, Point3 *x, Point3 *y, Point3 *z);
	void DrawDistSphere(TimeValue t, INode* inode, GraphicsWindow *gw);

	Tab<LODObj*> lodObjects;
	CommandMode *previousMode;

public:
	LODObject();
	~LODObject();


        RefTargetHandle Clone(RemapDir& remap = NoRemap());

	// From BaseObject
	void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
	int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
//	void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
	int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
	CreateMouseCallBack* GetCreateMouseCallBack();
	void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
	void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
	TCHAR *GetObjectName() { return _T(GetString(IDS_LOD)); }


	void SetSize(float r);
	float GetSize(void) { return radius; }
	void SetCurDist(float d);
	float GetCurDist(void) { return dlgCurSelDist; }

	Tab<LODObj*> GetLODObjects() { return lodObjects; }

	// From Object
	ObjectState Eval(TimeValue time);
	void InitNodeName(TSTR& s) { s = _T(GetString(IDS_LOD)); }
	Interval ObjectValidity();
	Interval ObjectValidity(TimeValue time);
	int DoOwnSelectHilite() { return 1; }

	void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
	void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

	// Animatable methods
	void DeleteThis() { delete this; }
	Class_ID ClassID() { return Class_ID(LOD_CLASS_ID1,
                                         LOD_CLASS_ID2);}  
	void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_LOD_CLASS))); }
	int IsKeyable(){ return 1;}
	LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
            WPARAM wParam,   LPARAM lParam ){return(0);}


	int NumRefs() {return lodObjects.Count();}
	RefTargetHandle GetReference(int i);
	void SetReference(int i, RefTargetHandle rtarg);

	// IO
	IOResult Save(ISave *isave);
	IOResult Load(ILoad *iload);
};				


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\lod.cpp ===
/**********************************************************************
 *<
    FILE: lod.cpp

    DESCRIPTION:  A VRML Level Of Detail helper implementation
 
    CREATED BY: Charles Thaeler
  
    HISTORY: created 29 Feb. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "lod.h"

// Parameter block indices
#define PB_LENGTH	0

//------------------------------------------------------

class LODClassDesc:public ClassDesc {
public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading = FALSE) { return new LODObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_LOD_CLASS));}
	SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
	Class_ID 		ClassID() { return Class_ID(LOD_CLASS_ID1,
                                                LOD_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static LODClassDesc lodDesc;

ClassDesc* GetLODDesc() { return &lodDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ISpinnerControl *LODObject::sizeSpin = NULL;
ISpinnerControl *LODObject::distSpin = NULL;
ICustButton *LODObject::lodPickButton = NULL;

HWND LODObject::hRollup = NULL;
int LODObject::dlgPrevSel = -1;

class LODObjPick : public PickModeCallback {
	LODObject *lod;
public:		

	BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
	BOOL Pick(IObjParam *ip,ViewExp *vpt);	

	void EnterMode(IObjParam *ip);
	void ExitMode(IObjParam *ip);

	HCURSOR GetHitCursor(IObjParam *ip);
	void SetLOD(LODObject *l) { lod = l; }
};

static LODObjPick thePick;

BOOL
LODObjPick::HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags)
{
	INode *node = ip->PickNode(hWnd, m);
	if (node == NULL)
		return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
	if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2)))
		return FALSE;
	return TRUE;
}

void
LODObjPick::EnterMode(IObjParam *ip)
{
	ip->PushPrompt(GetString(IDS_LOD_PICK_MODE));
}

void
LODObjPick::ExitMode(IObjParam *ip)
{
	ip->PopPrompt();
}

BOOL
LODObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
	if (vpt->HitCount() == 0)
		return FALSE;

	INode *node;
	if ((node = vpt->GetClosestHit()) != NULL) {
		// Check to see if we have a reference to this object already
		for (int i = 0; i < lod->lodObjects.Count(); i++) {
			if (lod->lodObjects[i]->node == node)
				return FALSE; // Can't click those we already have
		}

		LODObj *obj = new LODObj(node);
		int id = lod->lodObjects.Append(1, &obj);

		RefResult ret = lod->MakeRefByID(FOREVER, id, node);

		HWND hw = lod->hRollup;
		int ind = SendMessage(GetDlgItem(hw,IDC_LOD_LIST), LB_ADDSTRING, 0, (LPARAM)obj->listStr.data());
		SendMessage(GetDlgItem(hw,IDC_LOD_LIST), LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
		EnableWindow(GetDlgItem(hw, IDC_LOD_DEL), (lod->lodObjects.Count() > 0));
	}
	return FALSE;
}


HCURSOR
LODObjPick::GetHitCursor(IObjParam *ip)
{
	return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

void
BuildObjectList(LODObject *ob)
{
	if (ob && ob->hRollup) {
		int count, i;

		count = SendDlgItemMessage(ob->hRollup, IDC_LOD_LIST, LB_GETCOUNT, 0, 0);

		// First remove any objects on the list
		for (i = count - 1; i >= 0; i--)
			SendDlgItemMessage(ob->hRollup, IDC_LOD_LIST, LB_DELETESTRING, (WPARAM) i, 0);

		for (i = 0; i < ob->lodObjects.Count(); i++) {
			LODObj *obj = ob->lodObjects[i];
			obj->ResetStr(); // Make sure we're up to date

			// for now just load the name, we might want to add the frame range as some point
			int ind = SendMessage(GetDlgItem(ob->hRollup,IDC_LOD_LIST), LB_ADDSTRING, 0,
				(LPARAM)obj->listStr.data());
			SendMessage(GetDlgItem(ob->hRollup,IDC_LOD_LIST), LB_SETITEMDATA,
				(WPARAM)ind, (LPARAM)obj);
		}
	}
}

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
	LODObject *th = (LODObject *)GetWindowLong( hDlg, GWL_USERDATA );	
	if ( !th && message != WM_INITDIALOG ) return FALSE;

	switch ( message ) {
	case WM_INITDIALOG: {
		th = (LODObject *)lParam;
		SetWindowLong( hDlg, GWL_USERDATA, (LONG)th );
		SetDlgFont( hDlg, th->iObjParams->GetAppHFont() );

		th->sizeSpin = GetISpinner(GetDlgItem(hDlg,IDC_LOD_SIZE_SPINNER));
		th->sizeSpin->SetLimits( 0, 999999, FALSE );
		th->sizeSpin->SetScale( 1.0f );
		th->sizeSpin->SetValue( th->GetSize(), FALSE );
		th->sizeSpin->LinkToEdit( GetDlgItem(hDlg,IDC_LOD_SIZE), EDITTYPE_POS_FLOAT );
		EnableWindow(GetDlgItem(hDlg, IDC_LOD_SIZE), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_LOD_SIZE_SPINNER), TRUE);

		th->distSpin = GetISpinner(GetDlgItem(hDlg,IDC_LOD_DIST_SPINNER));
		th->distSpin->SetLimits( 0, 999999, FALSE );
		th->distSpin->SetScale( 1.0f );
		th->distSpin->SetValue( 0, FALSE );
		th->distSpin->LinkToEdit( GetDlgItem(hDlg,IDC_LOD_DIST), EDITTYPE_POS_FLOAT );
		// Disable till there is a selected object on the list
		EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST), FALSE);
		EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST_SPINNER), FALSE);

		th->lodPickButton = GetICustButton(GetDlgItem(hDlg,IDC_LOD_PICK));
		th->lodPickButton->SetType(CBT_CHECK);
		th->lodPickButton->SetButtonDownNotify(TRUE);
		th->lodPickButton->SetHighlightColor(GREEN_WASH);

		// Now we need to fill in the list box IDC_LOD_LIST
		th->hRollup = hDlg;
		BuildObjectList(th);

		EnableWindow(GetDlgItem(hDlg, IDC_LOD_DEL), (th->lodObjects.Count() > 0));
		th->dlgPrevSel = -1;
		}
		return TRUE;			

	case WM_DESTROY:
		th->iObjParams->ClearPickMode();
		th->previousMode = NULL;
		ReleaseISpinner( th->sizeSpin );
		ReleaseISpinner( th->distSpin );
		ReleaseICustButton( th->lodPickButton );
		return FALSE;

	case CC_SPINNER_CHANGE:
		switch ( LOWORD(wParam) ) {
		case IDC_LOD_SIZE_SPINNER:
			th->SetSize( th->sizeSpin->GetFVal() );
			th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_INTERACTIVE);
			break;
		case IDC_LOD_DIST_SPINNER:
			th->SetCurDist(th->distSpin->GetFVal());
			th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_INTERACTIVE);
			int sel = SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_GETCURSEL, 0, 0);
			LODObj *obj = (LODObj *)SendDlgItemMessage(hDlg,
								IDC_LOD_LIST, LB_GETITEMDATA, sel, 0);
			obj->dist = th->dlgCurSelDist;  
			obj->ResetStr();
			SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_DELETESTRING,
				sel, 0);
			int ind = SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_ADDSTRING, 0,
				(LPARAM)obj->listStr.data());
			SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_SETITEMDATA,
				(WPARAM)ind, (LPARAM)obj);
			SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_SETCURSEL, (WPARAM)ind, 0);
			break;
		}
		return TRUE;
	case CC_SPINNER_BUTTONDOWN:
		th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_BEGIN);
		return TRUE;
	case CC_SPINNER_BUTTONUP:
		th->iObjParams->RedrawViews(th->iObjParams->GetTime(),REDRAW_END);
		return TRUE;

	case WM_MOUSEACTIVATE:
		th->iObjParams->RealizeParamPanel();
		return FALSE;

	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
	case WM_MOUSEMOVE:
		th->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
		return FALSE;

	case WM_COMMAND:			
		switch( LOWORD(wParam) ) {
		case IDC_LOD_PICK: // Pick an object from the scene
			// Set the pickmode...
			switch (HIWORD(wParam)) {
			case BN_BUTTONDOWN:
				if (th->previousMode) {
					// reset the command mode
					th->iObjParams->SetCommandMode(th->previousMode);
					th->previousMode = NULL;
				} else {
					th->previousMode = th->iObjParams->GetCommandMode();
					thePick.SetLOD(th);
					th->iObjParams->SetPickMode(&thePick);
				}
				break;
			}
			break;
		case IDC_LOD_DEL: { // Delete the object from the list
			int index =	SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_GETCURSEL, 0, 0);
			if (index != LB_ERR) {
				LODObj *obj = (LODObj *)SendDlgItemMessage(hDlg,
										IDC_LOD_LIST, LB_GETITEMDATA, index, 0);
				for (int i = 0; i < th->lodObjects.Count(); i++) {
					if (obj == th->lodObjects[i]) {
						// remove the item from the list
						SendDlgItemMessage(hDlg, IDC_LOD_LIST, LB_DELETESTRING,
							(WPARAM) index, 0);
						th->dlgPrevSel = -1;
						// Remove the reference to obj->node
						th->DeleteReference(th->FindRef((RefTargetHandle)obj->node));
						// remove the object from the table
						th->lodObjects.Delete(i, 1);
						break;
					}
				}
				EnableWindow(GetDlgItem(hDlg, IDC_LOD_DEL), (th->lodObjects.Count() > 0));
				if (th->lodObjects.Count() <= 0) {
					th->SetCurDist(-1.0f);
					th->iObjParams->RedrawViews(th->iObjParams->GetTime());
				}
			}
			}
			break;
		case IDC_LOD_LIST:
			switch(HIWORD(wParam)) {
			case LBN_SELCHANGE: {
				int sel = SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_GETCURSEL, 0, 0);
				if (th->dlgPrevSel != -1) {
					// save any editing
					LODObj *obj = (LODObj *)SendDlgItemMessage(hDlg,
										IDC_LOD_LIST, LB_GETITEMDATA, th->dlgPrevSel, 0);
					obj->dist = th->distSpin->GetFVal();
					obj->ResetStr();
					SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_DELETESTRING,
						th->dlgPrevSel, 0);
					int ind = SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_ADDSTRING, 0,
						(LPARAM)obj->listStr.data());
					SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_SETITEMDATA,
						(WPARAM)ind, (LPARAM)obj);
					SendMessage(GetDlgItem(hDlg,IDC_LOD_LIST), LB_SETCURSEL, sel, 0);
				}
				th->dlgPrevSel = sel;
				if (sel >= 0) {
					LODObj *obj = (LODObj *)SendDlgItemMessage(hDlg,
											IDC_LOD_LIST, LB_GETITEMDATA, sel, 0);
					assert(obj);

					th->distSpin->SetValue( obj->dist, TRUE );
					th->SetCurDist(obj->dist);
					EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST), TRUE);
					EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST_SPINNER), TRUE);
				} else {
					EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST), FALSE);
					EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST_SPINNER), FALSE);
					th->SetCurDist(-1.0f);
				}
				th->iObjParams->RedrawViews(th->iObjParams->GetTime());
				}
				break;
			case LBN_SELCANCEL:
				EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST), FALSE);
				EnableWindow(GetDlgItem(hDlg, IDC_LOD_DIST_SPINNER), FALSE);
				break;
			}
			break;
		}
		return FALSE;

	default:
		return FALSE;
	}
}


void
LODObject::BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev )
{
	iObjParams = ip;

	if ( !hRollup ) {
        hRollup = ip->AddRollupPage(
                hInstance,
                MAKEINTRESOURCE(IDD_LOD),
                RollupDialogProc,
                GetString(IDS_LOD_TITLE),
                (LPARAM)this );
 
        ip->RegisterDlgWnd(hRollup);
	} else {
		SetWindowLong( hRollup, GWL_USERDATA, (LONG)this );
	}
	dlgCurSelDist = -1.0f; // Start with no visible distance sphere
}
		
void
LODObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
	if ( flags&END_EDIT_REMOVEUI ) {		
        if (hRollup) {
            ip->UnRegisterDlgWnd(hRollup);
            ip->DeleteRollupPage(hRollup);
            hRollup = NULL;
        }
	} else {
		if (hRollup)
			SetWindowLong( hRollup, GWL_USERDATA, 0 );
	}
	
	iObjParams = NULL;
	dlgCurSelDist = -1.0f; // End with no visible distance sphere
}

LODObject::LODObject() : HelperObject() 
{
	dlgCurSelDist = -1.0f;
	previousMode = NULL;
	BuildObjectList(this);
}

LODObject::~LODObject()
{
	DeleteAllRefsFromMe();
	for (int i = 0; i < lodObjects.Count(); i++) {
		LODObj *obj = lodObjects[0];
		lodObjects.Delete(0, 1);
		delete obj;
	}
}

void
LODObject::SetSize( float r )
{
	radius = r;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

void
LODObject::SetCurDist( float d )
{
	dlgCurSelDist = d;
	NotifyDependents(FOREVER, PART_OBJ, REFMSG_CHANGE);
}

IObjParam *LODObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
LODObject::NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
     PartID& partID, RefMessage message ) 
{
	int i;
	switch (message) {
	case REFMSG_TARGET_DELETED:
		// Find the ID on the list and call ResetStr
		for (i = 0; i < lodObjects.Count(); i++) {
			if (lodObjects[i]->node == hTarget) {
				// Do I need to remove the reference? FIXME
				lodObjects.Delete(i, 1); 
			}
		}
		break;
	case REFMSG_NODE_NAMECHANGE:
		// Find the ID on the list and call ResetStr
		for (i = 0; i < lodObjects.Count(); i++) {
			if (lodObjects[i]->node == hTarget) {
				// Found it
				lodObjects[i]->ResetStr();
				break;
			}
		}
		break;
	}
	return REF_SUCCEED;
}

RefTargetHandle
LODObject::GetReference(int ind)
{
	if (ind >= lodObjects.Count()) return NULL;

	return lodObjects[ind]->node;
}

void
LODObject::SetReference(int ind, RefTargetHandle rtarg)
{
	if (ind >= lodObjects.Count()) return;

	lodObjects[ind]->node = (INode *)rtarg;
	lodObjects[ind]->ResetStr();
}

ObjectState
LODObject::Eval(TimeValue time){
	return ObjectState(this);
}

Interval
LODObject::ObjectValidity(TimeValue time)
{
	Interval ivalid;
	ivalid.SetInfinite();
	return ivalid;	
}

void
LODObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
	tm = inode->GetObjectTM(t);
}

void
LODObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
	Matrix3 m = inode->GetObjectTM(t);
	box = mesh.getBoundingBox();
	if (dlgCurSelDist >= 0.0f) {
		Point3 x[32], y[32], z[32];
		GetDistPoints(dlgCurSelDist, x, y, z);
		for (int i = 0; i < 32; i++) {
			box += x[i];
			box += y[i];
			box += z[i];
		}
	}

}

void
LODObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt, Box3& box )
{
	Matrix3 tm;
	GetMat(t,inode,vpt,tm);

	int nv = mesh.getNumVerts();
	box.Init();
	for (int i=0; i<nv; i++) 
		box += tm*mesh.getVert(i);
	if (dlgCurSelDist >= 0.0f) {
		Point3 x[32], y[32], z[32];
		GetDistPoints(dlgCurSelDist, x, y, z);
		for (int i = 0; i < 32; i++) {
			box += tm*x[i];
			box += tm*y[i];
			box += tm*z[i];
		}
	}
}


void
LODObject::BuildMesh()
{
    float size = radius;
#include "lodob.cpp"
}

void
LODObject::GetDistPoints(float radius, Point3 *x, Point3 *y, Point3 *z)
{
	float dang = PI / ( 2.0f * 8.0f);
	float ang = 0.0f;
	for (int i = 0; i < 32; i++ ) {
		z[i].x = x[i].y = y[i].x = radius * (float) cos(ang);
		z[i].y = x[i].z = y[i].z = radius * (float) sin(ang);
		z[i].z = x[i].x = y[i].y = 0.0f;
		ang += dang;
	}
}

void
LODObject::DrawDistSphere(TimeValue t, INode* inode, GraphicsWindow *gw)
{
	Matrix3 tm = inode->GetObjectTM(t);
	gw->setTransform(tm);

	Point3 x[33], y[33], z[33];
	GetDistPoints(dlgCurSelDist, x, y, z);
	
	if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, 0.0f, 0.0f, 1.0f);
	gw->polyline(32, x, NULL, NULL, TRUE, NULL);
	gw->polyline(32, y, NULL, NULL, TRUE, NULL);
	gw->polyline(32, z, NULL, NULL, TRUE, NULL);
}

int
LODObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
	if (radius <= 0.0)
		return 0;
	BuildMesh();
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();
	Material *mtl = gw->getMaterial();

	DWORD rlim = gw->getRndLimits();
	gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	if (inode->Selected()) 
		gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
	else if(!inode->IsFrozen())
		gw->setColor( LINE_COLOR, 0.0f, 1.0f, 1.0f);
	mesh.render( gw, mtl, NULL, COMP_ALL);
	if (inode->Selected() && dlgCurSelDist >= 0.0f)
		DrawDistSphere(t, inode, gw);

	gw->setRndLimits(rlim);
	return(0);
}

int
LODObject::HitTest(TimeValue t, INode *inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt)
{
	HitRegion hitRegion;
	DWORD	savedLimits;
	int res = FALSE;
	Matrix3 m;
	GraphicsWindow *gw = vpt->getGW();	
	Material *mtl = gw->getMaterial();
	MakeHitRegion(hitRegion,type,crossing,4,p);	
	gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
	GetMat(t,inode,vpt,m);
	gw->setTransform(m);
	gw->clearHitCode();
	if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
		return TRUE;
	gw->setRndLimits(savedLimits);
	return res;
}

class LODCreateCallBack : public CreateMouseCallBack {
	private:
		IPoint2 sp0;
		Point3 p0;
		LODObject *lodObject;

	public:
		int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
			Matrix3& mat);
		void SetObj(LODObject *obj) {lodObject = obj;}

};

			
int
LODCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags, IPoint2 m, Matrix3& mat)
{	
	Point3 p1,center;

	switch ( msg ) {
	case MOUSE_POINT:
	case MOUSE_MOVE:
		switch ( point ) {
		case 0:  // only happens with MOUSE_POINT msg				
			sp0 = m;
			p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
			mat.SetTrans(p0);
			break;
		case 1:
			mat.IdentityMatrix();
			p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
			mat.SetTrans(p0);
			lodObject->radius = Length(p1-p0);
			if (lodObject->sizeSpin)
				lodObject->sizeSpin->SetValue( lodObject->radius, FALSE );
			if (flags&MOUSE_CTRL) {
				float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);					
				mat.PreRotateZ(lodObject->iObjParams->SnapAngle(ang));
			}

			if (msg==MOUSE_POINT) {										
				return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
			}
			break;					   
		}			
		break;
	case MOUSE_ABORT:
		return CREATE_ABORT;
	}
	
	return TRUE;
}

// A single instance of the callback object.
static LODCreateCallBack lodCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
LODObject::GetCreateMouseCallBack() 
{
	lodCreateCB.SetObj(this);
	return(&lodCreateCB);
}

// IO
#define LOD_SIZE_CHUNK		0xaca0
#define LOD_OBJ_DIST_CHUNK	0xaca1

IOResult
LODObject::Save(ISave *isave)
{
	ULONG written;

	isave->BeginChunk(LOD_SIZE_CHUNK);
	isave->Write(&radius, sizeof(float), &written);
	isave->EndChunk();

	int c = lodObjects.Count();
	if (c > 0) {
		for (int i = 0; i < c; i++) {
			float dist = lodObjects[i]->dist;
			written = 0;
			isave->BeginChunk(LOD_OBJ_DIST_CHUNK);
			isave->Write(&dist, sizeof(float), &written);
			isave->EndChunk();
		}
	}
	return IO_OK;
}

IOResult
LODObject::Load(ILoad *iload)
{
	ULONG nread;
	IOResult res;
	float dist;
	LODObj *obj;

	while (IO_OK==(res=iload->OpenChunk())) {
		switch(iload->CurChunkID()) {
		case LOD_SIZE_CHUNK:
			iload->Read(&radius, sizeof(float), &nread );
			break;
		case LOD_OBJ_DIST_CHUNK:
			iload->Read(&dist, sizeof(float), &nread );
			obj = new LODObj(NULL, dist);
			lodObjects.Append(1, &obj);
			break;
		}
		iload->CloseChunk();
		if (res!=IO_OK) 
			return res;
	}
	return IO_OK;
}

RefTargetHandle
LODObject::Clone(RemapDir& remap)
{
    LODObject* ts = new LODObject();
    ts->lodObjects.SetCount(lodObjects.Count());
    ts->radius = radius;
    for(int i = 0; i < lodObjects.Count(); i++) {
        ts->lodObjects[i] = new LODObj;
        ts->lodObjects[i]->dist = lodObjects[i]->dist;
        ts->ReplaceReference(i, lodObjects[i]->node);
    }
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\normtab.h ===
/**********************************************************************
 *<
	FILE: normtab.h

	DESCRIPTION:  Normal Hash Table class defs

	CREATED BY: Scott Morrison

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#define NUM_NORMS 10000.0f
#define normNorm(w) ((float) ((int) (NUM_NORMS * (w))))

// Truncate normals into the specified range.
inline 
Point3 NormalizeNorm(Point3 norm)
{
    Point3 p;
    p.x = normNorm(norm.x);
    p.y = normNorm(norm.y);
    p.z = normNorm(norm.z);
    return p;
}

// A normal table hash bucket.
class NormalDesc {
public:
    NormalDesc(Point3& norm) {
        n = NormalizeNorm(norm);
        index = -1;
        next = NULL;
    }
    ~NormalDesc() { delete next; }
    Point3 n;           // The normalize normal
    int    index;       // The index in the index face set
    NormalDesc* next;   // Next hash bucket.
};

// Un-comment this line to get data on the normal hash table
// #define DEBUG_NORM_HASH

// Hash table for rendering normals
class NormalTable 
{
public:
    NormalTable();
    ~NormalTable();

    void AddNormal(Point3& norm);
    int GetIndex(Point3& norm);
    NormalDesc* Get(int i) { return tab[i]; }
    void PrintStats(FILE* mStream);
    
private:
    DWORD HashCode(Point3 &norm);
    Tab<NormalDesc*> tab;
};


#define NORM_TABLE_SIZE 1001
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\niob.cpp ===
mesh.setNumVerts(60);
    mesh.setNumFaces(97);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669281));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(-0.003537,0.009140,0.270244));
    mesh.setVert(11, size * Point3(0.235070,-0.086041,0.270244));
    mesh.setVert(12, size * Point3(0.235070,0.104322,0.270244));
    mesh.setVert(13, size * Point3(-0.242145,0.104322,0.270244));
    mesh.setVert(14, size * Point3(-0.242145,-0.086041,0.270244));
    mesh.setVert(15, size * Point3(-0.003537,0.009140,0.521651));
    mesh.setVert(16, size * Point3(-0.003537,0.009140,0.521651));
    mesh.setVert(17, size * Point3(-0.003537,0.009140,0.521651));
    mesh.setVert(18, size * Point3(-0.003537,0.009140,0.521651));
    mesh.setVert(19, size * Point3(-0.003537,0.009140,0.521651));
    mesh.setVert(20, size * Point3(-0.004383,0.010493,0.092095));
    mesh.setVert(21, size * Point3(0.030973,0.010493,0.092095));
    mesh.setVert(22, size * Point3(-0.004383,0.045849,0.092095));
    mesh.setVert(23, size * Point3(-0.039738,0.010493,0.092095));
    mesh.setVert(24, size * Point3(-0.004383,-0.024862,0.092095));
    mesh.setVert(25, size * Point3(0.030973,0.010493,0.268871));
    mesh.setVert(26, size * Point3(-0.004383,0.045849,0.268871));
    mesh.setVert(27, size * Point3(-0.039738,0.010493,0.268871));
    mesh.setVert(28, size * Point3(-0.004383,-0.024862,0.268871));
    mesh.setVert(29, size * Point3(-0.004383,0.010493,0.268871));
    mesh.setVert(30, size * Point3(-0.104335,0.089141,-0.307304));
    mesh.setVert(31, size * Point3(-0.104335,0.089141,-0.004492));
    mesh.setVert(32, size * Point3(0.098986,0.089141,-0.307304));
    mesh.setVert(33, size * Point3(0.151108,0.089141,-0.307304));
    mesh.setVert(34, size * Point3(0.151108,0.089141,0.077963));
    mesh.setVert(35, size * Point3(0.102423,0.089141,0.077963));
    mesh.setVert(36, size * Point3(0.102423,0.089141,-0.224858));
    mesh.setVert(37, size * Point3(-0.100897,0.089141,0.077963));
    mesh.setVert(38, size * Point3(-0.153019,0.089141,0.077963));
    mesh.setVert(39, size * Point3(-0.153019,0.089141,-0.307304));
    mesh.setVert(40, size * Point3(-0.104335,-0.061119,-0.307304));
    mesh.setVert(41, size * Point3(-0.104335,-0.061119,-0.004492));
    mesh.setVert(42, size * Point3(0.098986,-0.061119,-0.307304));
    mesh.setVert(43, size * Point3(0.151108,-0.061119,-0.307304));
    mesh.setVert(44, size * Point3(0.151108,-0.061119,0.077963));
    mesh.setVert(45, size * Point3(0.102423,-0.061119,0.077963));
    mesh.setVert(46, size * Point3(0.102423,-0.061119,-0.224858));
    mesh.setVert(47, size * Point3(-0.100897,-0.061119,0.077963));
    mesh.setVert(48, size * Point3(-0.153019,-0.061119,0.077963));
    mesh.setVert(49, size * Point3(-0.153019,-0.061119,-0.307304));
    mesh.setVert(50, size * Point3(-0.004383,0.010493,-0.541484));
    mesh.setVert(51, size * Point3(0.030973,0.010493,-0.541484));
    mesh.setVert(52, size * Point3(-0.004383,0.045849,-0.541484));
    mesh.setVert(53, size * Point3(-0.039738,0.010493,-0.541484));
    mesh.setVert(54, size * Point3(-0.004383,-0.024862,-0.541484));
    mesh.setVert(55, size * Point3(0.030973,0.010493,-0.364708));
    mesh.setVert(56, size * Point3(-0.004383,0.045849,-0.364708));
    mesh.setVert(57, size * Point3(-0.039738,0.010493,-0.364708));
    mesh.setVert(58, size * Point3(-0.004383,-0.024862,-0.364708));
    mesh.setVert(59, size * Point3(-0.004383,0.010493,-0.364708));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,12,11);
    mesh.faces[13].setEdgeVisFlags(0,1,0);
    mesh.faces[13].setSmGroup(1);
    mesh.faces[14].setVerts(10,13,12);
    mesh.faces[14].setEdgeVisFlags(0,1,0);
    mesh.faces[14].setSmGroup(1);
    mesh.faces[15].setVerts(10,14,13);
    mesh.faces[15].setEdgeVisFlags(0,1,0);
    mesh.faces[15].setSmGroup(1);
    mesh.faces[16].setVerts(10,11,14);
    mesh.faces[16].setEdgeVisFlags(0,1,0);
    mesh.faces[16].setSmGroup(1);
    mesh.faces[17].setVerts(11,16,15);
    mesh.faces[17].setEdgeVisFlags(0,1,1);
    mesh.faces[17].setSmGroup(8);
    mesh.faces[18].setVerts(11,12,16);
    mesh.faces[18].setEdgeVisFlags(1,1,0);
    mesh.faces[18].setSmGroup(8);
    mesh.faces[19].setVerts(12,17,16);
    mesh.faces[19].setEdgeVisFlags(0,1,1);
    mesh.faces[19].setSmGroup(8);
    mesh.faces[20].setVerts(12,13,17);
    mesh.faces[20].setEdgeVisFlags(1,1,0);
    mesh.faces[20].setSmGroup(8);
    mesh.faces[21].setVerts(13,18,17);
    mesh.faces[21].setEdgeVisFlags(0,1,1);
    mesh.faces[21].setSmGroup(8);
    mesh.faces[22].setVerts(13,14,18);
    mesh.faces[22].setEdgeVisFlags(1,1,0);
    mesh.faces[22].setSmGroup(8);
    mesh.faces[23].setVerts(14,15,18);
    mesh.faces[23].setEdgeVisFlags(0,1,1);
    mesh.faces[23].setSmGroup(8);
    mesh.faces[24].setVerts(14,11,15);
    mesh.faces[24].setEdgeVisFlags(1,1,0);
    mesh.faces[24].setSmGroup(8);
    mesh.faces[25].setVerts(19,15,16);
    mesh.faces[25].setEdgeVisFlags(0,1,0);
    mesh.faces[25].setSmGroup(1);
    mesh.faces[26].setVerts(19,16,17);
    mesh.faces[26].setEdgeVisFlags(0,1,0);
    mesh.faces[26].setSmGroup(1);
    mesh.faces[27].setVerts(19,17,18);
    mesh.faces[27].setEdgeVisFlags(0,1,0);
    mesh.faces[27].setSmGroup(1);
    mesh.faces[28].setVerts(19,18,15);
    mesh.faces[28].setEdgeVisFlags(0,1,0);
    mesh.faces[28].setSmGroup(1);
    mesh.faces[29].setVerts(20,22,21);
    mesh.faces[29].setEdgeVisFlags(0,1,0);
    mesh.faces[29].setSmGroup(1);
    mesh.faces[30].setVerts(20,23,22);
    mesh.faces[30].setEdgeVisFlags(0,1,0);
    mesh.faces[30].setSmGroup(1);
    mesh.faces[31].setVerts(20,24,23);
    mesh.faces[31].setEdgeVisFlags(0,1,0);
    mesh.faces[31].setSmGroup(1);
    mesh.faces[32].setVerts(20,21,24);
    mesh.faces[32].setEdgeVisFlags(0,1,0);
    mesh.faces[32].setSmGroup(1);
    mesh.faces[33].setVerts(21,26,25);
    mesh.faces[33].setEdgeVisFlags(0,1,1);
    mesh.faces[33].setSmGroup(8);
    mesh.faces[34].setVerts(21,22,26);
    mesh.faces[34].setEdgeVisFlags(1,1,0);
    mesh.faces[34].setSmGroup(8);
    mesh.faces[35].setVerts(22,27,26);
    mesh.faces[35].setEdgeVisFlags(0,1,1);
    mesh.faces[35].setSmGroup(8);
    mesh.faces[36].setVerts(22,23,27);
    mesh.faces[36].setEdgeVisFlags(1,1,0);
    mesh.faces[36].setSmGroup(8);
    mesh.faces[37].setVerts(23,28,27);
    mesh.faces[37].setEdgeVisFlags(0,1,1);
    mesh.faces[37].setSmGroup(8);
    mesh.faces[38].setVerts(23,24,28);
    mesh.faces[38].setEdgeVisFlags(1,1,0);
    mesh.faces[38].setSmGroup(8);
    mesh.faces[39].setVerts(24,25,28);
    mesh.faces[39].setEdgeVisFlags(0,1,1);
    mesh.faces[39].setSmGroup(8);
    mesh.faces[40].setVerts(24,21,25);
    mesh.faces[40].setEdgeVisFlags(1,1,0);
    mesh.faces[40].setSmGroup(8);
    mesh.faces[41].setVerts(29,25,26);
    mesh.faces[41].setEdgeVisFlags(0,1,0);
    mesh.faces[41].setSmGroup(1);
    mesh.faces[42].setVerts(29,26,27);
    mesh.faces[42].setEdgeVisFlags(0,1,0);
    mesh.faces[42].setSmGroup(1);
    mesh.faces[43].setVerts(29,27,28);
    mesh.faces[43].setEdgeVisFlags(0,1,0);
    mesh.faces[43].setSmGroup(1);
    mesh.faces[44].setVerts(29,28,25);
    mesh.faces[44].setEdgeVisFlags(0,1,0);
    mesh.faces[44].setSmGroup(1);
    mesh.faces[45].setVerts(30,31,41);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(1);
    mesh.faces[46].setVerts(30,41,40);
    mesh.faces[46].setEdgeVisFlags(0,1,1);
    mesh.faces[46].setSmGroup(1);
    mesh.faces[47].setVerts(31,32,42);
    mesh.faces[47].setEdgeVisFlags(1,1,0);
    mesh.faces[47].setSmGroup(4);
    mesh.faces[48].setVerts(31,42,41);
    mesh.faces[48].setEdgeVisFlags(0,1,1);
    mesh.faces[48].setSmGroup(4);
    mesh.faces[49].setVerts(32,33,43);
    mesh.faces[49].setEdgeVisFlags(1,1,0);
    mesh.faces[49].setSmGroup(2);
    mesh.faces[50].setVerts(32,43,42);
    mesh.faces[50].setEdgeVisFlags(0,1,1);
    mesh.faces[50].setSmGroup(2);
    mesh.faces[51].setVerts(33,34,44);
    mesh.faces[51].setEdgeVisFlags(1,1,0);
    mesh.faces[51].setSmGroup(4);
    mesh.faces[52].setVerts(33,44,43);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(4);
    mesh.faces[53].setVerts(34,35,45);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(2);
    mesh.faces[54].setVerts(34,45,44);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(2);
    mesh.faces[55].setVerts(35,36,46);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(4);
    mesh.faces[56].setVerts(35,46,45);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(4);
    mesh.faces[57].setVerts(36,37,47);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(2);
    mesh.faces[58].setVerts(36,47,46);
    mesh.faces[58].setEdgeVisFlags(0,1,1);
    mesh.faces[58].setSmGroup(2);
    mesh.faces[59].setVerts(37,38,48);
    mesh.faces[59].setEdgeVisFlags(1,1,0);
    mesh.faces[59].setSmGroup(4);
    mesh.faces[60].setVerts(37,48,47);
    mesh.faces[60].setEdgeVisFlags(0,1,1);
    mesh.faces[60].setSmGroup(4);
    mesh.faces[61].setVerts(38,39,49);
    mesh.faces[61].setEdgeVisFlags(1,1,0);
    mesh.faces[61].setSmGroup(2);
    mesh.faces[62].setVerts(38,49,48);
    mesh.faces[62].setEdgeVisFlags(0,1,1);
    mesh.faces[62].setSmGroup(2);
    mesh.faces[63].setVerts(39,30,40);
    mesh.faces[63].setEdgeVisFlags(1,1,0);
    mesh.faces[63].setSmGroup(4);
    mesh.faces[64].setVerts(39,40,49);
    mesh.faces[64].setEdgeVisFlags(0,1,1);
    mesh.faces[64].setSmGroup(4);
    mesh.faces[65].setVerts(38,30,39);
    mesh.faces[65].setEdgeVisFlags(0,1,1);
    mesh.faces[65].setSmGroup(10);
    mesh.faces[66].setVerts(38,31,30);
    mesh.faces[66].setEdgeVisFlags(0,1,0);
    mesh.faces[66].setSmGroup(10);
    mesh.faces[67].setVerts(37,31,38);
    mesh.faces[67].setEdgeVisFlags(0,0,1);
    mesh.faces[67].setSmGroup(10);
    mesh.faces[68].setVerts(36,31,37);
    mesh.faces[68].setEdgeVisFlags(0,0,1);
    mesh.faces[68].setSmGroup(10);
    mesh.faces[69].setVerts(36,32,31);
    mesh.faces[69].setEdgeVisFlags(0,1,0);
    mesh.faces[69].setSmGroup(10);
    mesh.faces[70].setVerts(36,33,32);
    mesh.faces[70].setEdgeVisFlags(0,1,0);
    mesh.faces[70].setSmGroup(10);
    mesh.faces[71].setVerts(36,34,33);
    mesh.faces[71].setEdgeVisFlags(0,1,0);
    mesh.faces[71].setSmGroup(10);
    mesh.faces[72].setVerts(35,34,36);
    mesh.faces[72].setEdgeVisFlags(1,0,1);
    mesh.faces[72].setSmGroup(10);
    mesh.faces[73].setVerts(48,49,40);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(10);
    mesh.faces[74].setVerts(48,40,41);
    mesh.faces[74].setEdgeVisFlags(0,1,0);
    mesh.faces[74].setSmGroup(10);
    mesh.faces[75].setVerts(47,48,41);
    mesh.faces[75].setEdgeVisFlags(1,0,0);
    mesh.faces[75].setSmGroup(10);
    mesh.faces[76].setVerts(46,47,41);
    mesh.faces[76].setEdgeVisFlags(1,0,0);
    mesh.faces[76].setSmGroup(10);
    mesh.faces[77].setVerts(46,41,42);
    mesh.faces[77].setEdgeVisFlags(0,1,0);
    mesh.faces[77].setSmGroup(10);
    mesh.faces[78].setVerts(46,42,43);
    mesh.faces[78].setEdgeVisFlags(0,1,0);
    mesh.faces[78].setSmGroup(10);
    mesh.faces[79].setVerts(46,43,44);
    mesh.faces[79].setEdgeVisFlags(0,1,0);
    mesh.faces[79].setSmGroup(10);
    mesh.faces[80].setVerts(45,46,44);
    mesh.faces[80].setEdgeVisFlags(1,0,1);
    mesh.faces[80].setSmGroup(10);
    mesh.faces[81].setVerts(50,52,51);
    mesh.faces[81].setEdgeVisFlags(0,1,0);
    mesh.faces[81].setSmGroup(1);
    mesh.faces[82].setVerts(50,53,52);
    mesh.faces[82].setEdgeVisFlags(0,1,0);
    mesh.faces[82].setSmGroup(1);
    mesh.faces[83].setVerts(50,54,53);
    mesh.faces[83].setEdgeVisFlags(0,1,0);
    mesh.faces[83].setSmGroup(1);
    mesh.faces[84].setVerts(50,51,54);
    mesh.faces[84].setEdgeVisFlags(0,1,0);
    mesh.faces[84].setSmGroup(1);
    mesh.faces[85].setVerts(51,56,55);
    mesh.faces[85].setEdgeVisFlags(0,1,1);
    mesh.faces[85].setSmGroup(8);
    mesh.faces[86].setVerts(51,52,56);
    mesh.faces[86].setEdgeVisFlags(1,1,0);
    mesh.faces[86].setSmGroup(8);
    mesh.faces[87].setVerts(52,57,56);
    mesh.faces[87].setEdgeVisFlags(0,1,1);
    mesh.faces[87].setSmGroup(8);
    mesh.faces[88].setVerts(52,53,57);
    mesh.faces[88].setEdgeVisFlags(1,1,0);
    mesh.faces[88].setSmGroup(8);
    mesh.faces[89].setVerts(53,58,57);
    mesh.faces[89].setEdgeVisFlags(0,1,1);
    mesh.faces[89].setSmGroup(8);
    mesh.faces[90].setVerts(53,54,58);
    mesh.faces[90].setEdgeVisFlags(1,1,0);
    mesh.faces[90].setSmGroup(8);
    mesh.faces[91].setVerts(54,55,58);
    mesh.faces[91].setEdgeVisFlags(0,1,1);
    mesh.faces[91].setSmGroup(8);
    mesh.faces[92].setVerts(54,51,55);
    mesh.faces[92].setEdgeVisFlags(1,1,0);
    mesh.faces[92].setSmGroup(8);
    mesh.faces[93].setVerts(59,55,56);
    mesh.faces[93].setEdgeVisFlags(0,1,0);
    mesh.faces[93].setSmGroup(1);
    mesh.faces[94].setVerts(59,56,57);
    mesh.faces[94].setEdgeVisFlags(0,1,0);
    mesh.faces[94].setSmGroup(1);
    mesh.faces[95].setVerts(59,57,58);
    mesh.faces[95].setEdgeVisFlags(0,1,0);
    mesh.faces[95].setSmGroup(1);
    mesh.faces[96].setVerts(59,58,55);
    mesh.faces[96].setEdgeVisFlags(0,1,0);
    mesh.faces[96].setSmGroup(1);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\ntrack.h ===
// FIXME this should be exported from the SDK!
#include "notetrck.h"

class NoteKey {
	public:
		TimeValue time;
		TSTR note;
		DWORD flags;
		
		NoteKey(TimeValue t,const TSTR &n,DWORD f=0) {time=t;note=n;flags=f;}
		NoteKey(NoteKey& n) {time=n.time;note=n.note;flags=n.flags;}

		void SetFlag(DWORD mask) { flags|=(mask); }
		void ClearFlag(DWORD mask) { flags &= ~(mask); }
		BOOL TestFlag(DWORD mask) { return(flags&(mask)?1:0); }
	};

class NoteKeyTab : public Tab<NoteKey*> {
	public:
		~NoteKeyTab() {Clear();}
		void Clear();
		void DelKey(int i) {delete (*this)[i]; Delete(i,1);}
		NoteKeyTab &operator=(NoteKeyTab &keys);
		void KeysChanged();
	};

class DefNoteTrack : public NoteTrack {
	public:
		NoteKeyTab keys;
		
		DefNoteTrack() {}
		DefNoteTrack(DefNoteTrack &n) {keys=n.keys;}
		DefNoteTrack& operator=(DefNoteTrack &track) {keys=track.keys;return *this;}
		void HoldTrack();

		Class_ID ClassID() {return Class_ID(NOTETRACK_CLASS_ID,0);}

		// Tree view methods from animatable
		int NumKeys() {return keys.Count();}
		TimeValue GetKeyTime(int index) {return keys[index]->time;}
		void MapKeys(TimeMap *map,DWORD flags );
		void DeleteKeys( DWORD flags );
		void CloneSelectedKeys();		
		void DeleteTime( Interval iv, DWORD flags );
		void ReverseTime( Interval iv, DWORD flags );
		void ScaleTime( Interval iv, float s);
		void InsertTime( TimeValue ins, TimeValue amount );
		void AddNewKey(TimeValue t,DWORD flags);
		int GetSelKeyCoords(TimeValue &t, float &val,DWORD flags);
		void SetSelKeyCoords(TimeValue t, float val,DWORD flags);
		int GetTrackVSpace( int lineHeight ) {return 1;}
		BOOL CanCopyTrack(Interval iv,DWORD flags) {return 1;}
		BOOL CanPasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags) {return cobj->ClassID()==ClassID();}
		TrackClipObject *CopyTrack(Interval iv,DWORD flags);
		void PasteTrack(TrackClipObject *cobj,Interval iv,DWORD flags);
		Interval GetTimeRange(DWORD flags) ;		
		int HitTestTrack(TrackHitTab& hits,Rect& rcHit,Rect& rcTrack,float zoom,int scroll,DWORD flags );
		int PaintTrack(HDC hdc,Rect& rcTrack,Rect& rcPaint,float zoom,int scroll,DWORD flags );
		void SelectKeys( TrackHitTab& sel, DWORD flags );
		int NumSelKeys();
		void FlagKey(TrackHitRecord hit);
		int GetFlagKeyIndex();		
		BOOL IsAnimated() {return keys.Count()>1;}
		void EditTrackParams(TimeValue t,ParamDimensionBase *dim,TCHAR *pname,HWND hParent,IObjParam *ip,DWORD flags);
		int TrackParamsType() {return TRACKPARAMS_KEY;}
		BOOL SupportTimeOperations() {return TRUE;}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		void DeleteThis() {delete this;}
		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget,
	         PartID& partID, RefMessage message) {return REF_SUCCEED;}
	};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\navinfo.h ===
/**********************************************************************
 *<
    FILE: navinfo.h
 
    DESCRIPTION:  Defines a NavigationInformation VRML 2.0 helper object
 
    CREATED BY: Scott Morrison
 
    HISTORY: created August 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __NavInfo__H__
 
#define __NavInfo__H__
 
#define NavInfo_CLASS_ID1 0xACAD3442
#define NavInfo_CLASS_ID2 0xF00DBAD

#define NavInfoClassID Class_ID(NavInfo_CLASS_ID1, NavInfo_CLASS_ID2)

extern ClassDesc* GetNavInfoDesc();

class NavInfoCreateCallBack;

class NavInfoObject: public HelperObject {			   
    friend class NavInfoCreateCallBack;
    friend class NavInfoObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(NavInfoObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;


    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    IParamBlock *pblock;
    static IParamMap *pmapParam;

    NavInfoObject();
    ~NavInfoObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
    void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_NAV_INFO)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_NAV_INFO)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
    void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(NavInfo_CLASS_ID1,
                                         NavInfo_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_NAV_INFO_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

    IOResult Load(ILoad *iload) ;
};				

#define PB_TYPE       0
#define PB_HEADLIGHT  1
#define PB_VIS_LIMIT  2
#define PB_SPEED      3
#define PB_COLLISION  4
#define PB_TERRAIN    5
#define PB_STEP       6
#define PB_NI_SIZE    7
#define PB_NA_LENGTH  8

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\polycnt.cpp ===
/**********************************************************************
 *<
	FILE: polycnt.cpp

	DESCRIPTION:  A polygon counter utility plugin

	CREATED BY: Scott Morrison

	HISTORY: created May 15, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"
#include "appd.h"

// The polygon counter utility plugin displays a modeless dialog
// with a count of the current number of polygons in the scene
// and the current selection set.  You can assign a budget to each of
// these, and a bar graph turns red as you approach the budget.
class PolygonCounter : public UtilityObj {
	public:
    PolygonCounter() {
        hDlg            = NULL;
        ip              = NULL;
        iu              = NULL;
        maxPolys        = NULL;
        maxSelected     = NULL;
    }
    // From UtilityObj
    void BeginEditParams(Interface *ip,IUtil *iu);
    void EndEditParams(Interface *ip,IUtil *iu);
    void SelectionSetChanged(Interface *ip,IUtil *iu) {}
    void DeleteThis() {}

    void Init();
    void End();
    void DrawBars();
    void DrawBar(HWND hWnd, int faces, int maxFaces);
    void DrawBar();

    Interface*        ip;
    IUtil*            iu;
    HWND              hDlg;
    ISpinnerControl*  maxPolys;
    ISpinnerControl*  maxSelected;
};

static PolygonCounter thePolyCounter;

class PolygonCounterClassDesc:public ClassDesc {
public:
    int 			IsPublic() {return 1;}
    void *			Create(BOOL loading = FALSE)
        {return &thePolyCounter;}
    const TCHAR * ClassName() {return _T(GetString(IDS_POLYGON_COUNTER_CLASS));}
    SClass_ID	  SuperClassID() {return UTILITY_CLASS_ID;}
    Class_ID	  ClassID() {return Class_ID(0x585b47d1, 0x4f807635);}
    const TCHAR*  Category() {return _T("");}
};

static PolygonCounterClassDesc classDesc;
ClassDesc* GetPolyCounterDesc() {return &classDesc;}

static int faceCount = 0;
static int selFaceCount  = 0;

static void
InitFaceCount()
{
    faceCount = selFaceCount = 0;
}

// Traverse the node counting polygons.  
static void
TraverseNode(INode* node, TimeValue t)
{
    const ObjectState& os = node->EvalWorldState(t);
    Object* ob = os.obj;
    if (ob!=NULL) {
        int numFaces, numVerts;
        GetPolygonCount(t, ob, numFaces, numVerts);
        faceCount += numFaces;
        if (node->Selected())
            selFaceCount += numFaces;
    }

    int i, numChildren = node->NumberOfChildren();
    for(i=0; i<numChildren; i++)
        TraverseNode(node->GetChildNode(i), t);
}

// Traverse all the nodes in the scene graph.
static void
CountFaces(Interface* ip)
{
    TraverseNode(ip->GetRootNode(), ip->GetTime());
}

// Handler for the modeless polygon counter dialog.
static BOOL CALLBACK
PolyCountDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
                              LPARAM lParam) 
{
    int val;
    TCHAR buf[32];

    switch (msg) {
    case WM_INITDIALOG:
        thePolyCounter.hDlg = hDlg;
        CenterWindow(hDlg, GetParent(hDlg));
        thePolyCounter.maxPolys =
            GetISpinner(GetDlgItem(hDlg, IDC_MAX_POLY_SPIN));
        thePolyCounter.maxPolys->SetScale(10.0f);
        thePolyCounter.maxPolys->SetLimits(0, 1000000);
        thePolyCounter.maxPolys->LinkToEdit(GetDlgItem(hDlg,
                                                       IDC_MAX_POLY_EDIT),
                                            EDITTYPE_INT);
        thePolyCounter.maxPolys->SetResetValue(10000);
        GetAppData(thePolyCounter.ip, MAX_POLYS_ID, _T("10000"), buf, 32);
        val = atoi(buf);
        thePolyCounter.maxPolys->SetValue(val, FALSE);

        thePolyCounter.maxSelected =
            GetISpinner(GetDlgItem(hDlg, IDC_MAX_SELECTED_SPIN));
        thePolyCounter.maxSelected->SetScale(10.0f);
        thePolyCounter.maxSelected->SetLimits(0, 1000000);
        thePolyCounter.maxSelected->LinkToEdit(GetDlgItem(hDlg,
                                                    IDC_MAX_SELECTED_EDIT),
                                               EDITTYPE_INT);
        thePolyCounter.maxSelected->SetResetValue(1000);
        GetAppData(thePolyCounter.ip, MAX_SELECTED_ID, _T("1000"), buf, 32);
        val = atoi(buf);
        thePolyCounter.maxSelected->SetValue(val, FALSE);
        InitFaceCount();
        CountFaces(thePolyCounter.ip);
        break;
    case CC_SPINNER_CHANGE:
    case WM_CUSTEDIT_ENTER:
        val = thePolyCounter.maxPolys->GetIVal();
        sprintf(buf, _T("%d"), val);
        WriteAppData(thePolyCounter.ip, MAX_POLYS_ID, buf);
        val = thePolyCounter.maxSelected->GetIVal();
        sprintf(buf, _T("%d"), val);
        WriteAppData(thePolyCounter.ip, MAX_SELECTED_ID, buf);
    case WM_PAINT:
        thePolyCounter.DrawBars();
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            ReleaseISpinner(thePolyCounter.maxPolys);
            ReleaseISpinner(thePolyCounter.maxSelected);
            if (thePolyCounter.iu)
                thePolyCounter.iu->CloseUtility();
            thePolyCounter.hDlg = NULL;
            thePolyCounter.End();
            break;
        }
    }
    return FALSE;
        
}

extern HINSTANCE hInstance;

void 
PolygonCounter::EndEditParams(Interface* ip, IUtil* u) {
	this->iu = u;
}

// Bring the dialog up
void 
PolygonCounter::BeginEditParams(Interface* ip, IUtil* u)
{
    this->iu = u;
    this->ip = ip;
    if (!hDlg) {
        this->Init();
        hDlg = CreateDialogParam(hInstance, MAKEINTRESOURCE(IDD_POLYCOUNT), 
                          GetActiveWindow(), PolyCountDlgProc,
                          (LPARAM) this);
    } else
        SetActiveWindow(hDlg);

    u->CloseUtility();
}

// Get redraw views callbacks
class PolyCountCallback: public RedrawViewsCallback
{
    void proc(Interface *ip);
};

// Count the polygons and dislpay the bar graph after every redraw views
void
PolyCountCallback::proc(Interface* ip)
{
    InitFaceCount();
    CountFaces(ip);
    thePolyCounter.DrawBars();
}

PolyCountCallback pccb;

void 
PolygonCounter::Init()
{
    ip->RegisterRedrawViewsCallback(&pccb);
}

void
PolygonCounter::End()
{
    ip->UnRegisterRedrawViewsCallback(&pccb);
}

// Draw the bar graph for a polygon counter
void
PolygonCounter::DrawBar(HWND hWnd, int faces, int maxFaces)
{
    HDC hdc = GetDC(hWnd);
    RECT r;
    GetClientRect(hWnd, &r);
    int numBlocks = 50;
    float facesPerBlock = maxFaces / ((float) numBlocks - 1);
    int blockBorder = 1;
    int blockWidth = (r.right - r.left - blockBorder * (numBlocks + 1)) / numBlocks;
    int blockHeight = r.bottom - r.top - 2 * blockBorder;
    int yellowBlock = numBlocks - 15;
    int redBlock =    numBlocks - 5;
    int i;
    float face;

 // Clear it out
    HBRUSH hb = CreateSolidBrush(RGB(0,0,0));
    r.bottom--; r.top++; r.left++; r.right--;
    FillRect(hdc, &r, hb);
    DeleteObject(hb);
    hb = CreateSolidBrush(RGB(0, 255, 0));
    int left = r.left;
    r.top = r.top + blockBorder;
    r.bottom = r.bottom - blockBorder;
    for (i = 0, face = 0.0f; i < numBlocks + 1 && face <= (float) faces; i++, face += facesPerBlock) {
     // draw a block
        r.left = left + (i) * (blockWidth + blockBorder) + blockBorder;
        r.right = r.left + blockWidth;
        if (i == yellowBlock) {
            DeleteObject(hb);
            hb = CreateSolidBrush(RGB(255, 255, 0)); 
        } else if (i == redBlock) {
            DeleteObject(hb);
            hb = CreateSolidBrush(RGB(255, 0, 0));
        }
        FillRect(hdc, &r, hb);
    }

    DeleteObject(hb);
    DeleteDC(hdc);
}

// Fill in all the data in the polygon counter dialog.
void
PolygonCounter::DrawBars()
{
    TCHAR buf[32];
    int val;

    GetAppData(thePolyCounter.ip, MAX_POLYS_ID, _T("10000"), buf, 32);
    val = atoi(buf);
    thePolyCounter.maxPolys->SetValue(val, FALSE);
    GetAppData(thePolyCounter.ip, MAX_SELECTED_ID, _T("1000"), buf, 32);
    val = atoi(buf);
    thePolyCounter.maxSelected->SetValue(val, FALSE);

    HWND hName = GetDlgItem(thePolyCounter.hDlg, IDC_POLY_COUNT);
    TCHAR str[256];
    sprintf(str, _T("%d"), faceCount);
    Static_SetText(hName, str);
    
    hName = GetDlgItem(thePolyCounter.hDlg, IDC_SEL_COUNT);
    sprintf(str, _T("%d"), selFaceCount);
    Static_SetText(hName, str);

    HWND hPolyBar = GetDlgItem(hDlg, IDC_POLY_BAR);
    int maxFaces = maxPolys->GetIVal();
    DrawBar(hPolyBar, faceCount, maxFaces);
    HWND hSelBar = GetDlgItem(hDlg, IDC_SELECTED_BAR);
    int maxSel = maxSelected->GetIVal();
    DrawBar(hSelBar,  selFaceCount, maxSel);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\pmesh.h ===
/**********************************************************************
 *<
	FILE: pmesh.h

	DESCRIPTION:  simple Polygon class module

	CREATED BY: greg finch

	HISTORY: created 1 december, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "meshadj.h"

#define COPLANAR_NORMAL_EPSILON 0.1 // in degrees
#define LineEPSILON             1e-03f

struct AEdge {
    int e0;
    int e1;
};

AEdge AdjoiningEdge(DWORD*, DWORD*);

enum PType { OutputTriangles, OutputQuads, OutputNGons, OutputVisibleEdges };
enum EType { HiddenEdge, CoplanarEdge, VisibleEdge };

/*
#define     Edge_A     (1<<0)
#define     Edge_B     (1<<1)
#define     Edge_C     (1<<2)
*/
class PMEdge {
    EType       mType;          // type of edge (hidden, etc...)
    int         mVertex0;       // index of the first vertex
    int         mVertex1;       // index of the ccw vertex
    int         mFace0;         // the face on the left
    int         mFace0Flags;    // this is the the ccw index numbers ei. AB, BC, CA
    int         mFace1;         // the face on the right
    int         mFace1Flags;    // this is the the ccw index numbers ei. AB, BC, CA
public:
    PMEdge() {
        mType = HiddenEdge;
        mVertex0 = -1;
        mVertex1 = -1;
        mFace0   = -1;
        mFace1   = -1;
    }
    int     GetVIndex(int i)
                { return (i ? mVertex1 : mVertex0); }
    void    SetVIndex(int i, int v)
                { (i ? mVertex1 = v : mVertex0 = v); }
    int     GetFaceFlags(int i)
                { return (i ? mFace1Flags : mFace0Flags); }
    int     GetFace(int i)
                { return (i ? mFace1 : mFace0); }
    void    SetFace(int i, int face, int flags)
                { (i ? mFace1 = face : mFace0 = face);
                  (i ? mFace1Flags = flags : mFace0Flags = flags); }
    void    SetEdgeVisiblity(EType type)
                { mType = type; }
    EType   GetEdgeVisiblity()
                { return mType; }
};

class PMPoly {
    PType       mType;      // type of polygon tri, quad, ngon, etc...
    Point3      mFNormal;   // the face normal
    Tab<PMEdge> mEdges;     // the polygon edges
    //Tab<PMEdge> mTEdges;    // the polygon texture edges
    Tab<int>    mPolygon;   // the the ccw vert indices
    Tab<int>    mTPolygon;  // the the ccw texture vert indices
    Tab<int>    mTriFaces;  // the coplanar tri faces indices
    Tab<UVVert> mTVerts;    // the polygon texture verts
    Tab<Point3> mVNormals;  // the vertex normals
    Tab<Point3> mVerts;     // the polygon verts
public:
    PMPoly() {
        mType    = OutputTriangles;
    }
    ~PMPoly() {
        if (mEdges.Count())
            mEdges.Delete(0,    mEdges.Count());
        //if (mTEdges.Count())
        //    mTEdges.Delete(0,   mTEdges.Count());
        if (mPolygon.Count())
            mPolygon.Delete(0,  mPolygon.Count());
        if (mTPolygon.Count())
            mTPolygon.Delete(0, mTPolygon.Count());
        if (mTriFaces.Count())
            mTriFaces.Delete(0, mTriFaces.Count());
        if (mTVerts.Count())
            mTVerts.Delete(0,   mTVerts.Count());
        if (mVNormals.Count())
            mVNormals.Delete(0, mVNormals.Count());
        if (mVerts.Count())
            mVerts.Delete(0,    mVerts.Count());
    }

    void    Shrink()
                { mEdges.Shrink();
                  //mTEdges.Shrink();
                  mPolygon.Shrink();
                  mTPolygon.Shrink();
                  mTriFaces.Shrink();
                  //mNormals.Shrink();
                  mTVerts.Shrink();
                  mVerts.Shrink(); }
    PType   GetType()
                { return mType; }
    Point3  GetFNormal()
                { return mFNormal; }
    void    SetFNormal(Point3 fNormal)
                { mFNormal = fNormal; }
    int     GetEdgeCnt()
                { return mEdges.Count(); }
    PMEdge  GetEdge(int i)
                { return mEdges[i]; }
    int     AddEdge(PMEdge* newEdge)
             // return the location inserted
                { return mEdges.Insert(mEdges.Count(), 1, newEdge);}
    /*
    int     GetTEdgeCnt()
                { return mTEdges.Count(); }
    PMEdge  GetTEdge(int i)
                { return mTEdges[i]; }
    int     AddTEdge(PMEdge* newEdge)
             // return the location inserted
                { return mTEdges.Insert(mTEdges.Count(), 1, newEdge);}
    */
    int     GetTriFaceCnt()
                { return mTriFaces.Count(); }
    int     GetTriFace(int i)
                { return mTriFaces[i]; }
    int     AddTriFace(int* index)
                { return mTriFaces.Insert(mTriFaces.Count(), 1, index); }
    int     GetVertCnt()
                { return mVerts.Count(); }
    Point3  GetVert(int i)
                { return mVerts[i]; }
    int     AddVert(Point3* newVert)
                { return mVerts.Insert(mVerts.Count(), 1, newVert); }
    int     RemoveLastVert()
                { return mVerts.Delete(mVerts.Count() - 1, 1); }
    int     RemoveFirstVert()
                { return mVerts.Delete(0, 1); }
    int     GetTVertCnt()
                { return mTVerts.Count(); }
    UVVert  GetTVert(int i)
                { return mTVerts[i]; }
    int     AddTVert(UVVert* newTVert)
                { return mTVerts.Insert(mTVerts.Count(), 1, newTVert); }
    int     RemoveLastTVert()
                { return mTVerts.Delete(mTVerts.Count() - 1, 1); }
    int     RemoveFirstTVert()
                { return mTVerts.Delete(0, 1); }
    int     GetVNormalCnt()
                { return mVNormals.Count(); }
    Point3  GetVNormal(int i)
                { return mVNormals[i]; }
    int     AddVNormal(Point3* newVNormal)
                { return mVNormals.Insert(mVNormals.Count(), 1, newVNormal); }
    int     RemoveFirstVNormal()
                { return mVNormals.Delete(0, 1); }
    int     RemoveLastVNormal()
                { return mVNormals.Delete(mVNormals.Count() - 1, 1); }
    int     GetVIndexCnt()
                { return mPolygon.Count(); }
    int     GetVIndex(int i)
                { return mPolygon[i]; }
    int     AddToPolygon(int index)
                { return mPolygon.Insert(mPolygon.Count(), 1, &index); }
    int     RemoveLastFromPolygon()
                { return mPolygon.Delete(mPolygon.Count() - 1, 1); }
    int     RemoveFirstFromPolygon()
                { return mPolygon.Delete(0, 1); }
    int     GetTVIndexCnt()
                { return mTPolygon.Count(); }
    int     GetTVIndex(int i)
                { return mTPolygon[i]; }
    int     AddToTPolygon(int index)
                { return mTPolygon.Insert(mTPolygon.Count(), 1, &index); }
    int     RemoveLastFromTPolygon()
                { return mTPolygon.Delete(mTPolygon.Count() - 1, 1); }
    int     RemoveFirstFromTPolygon()
                { return mTPolygon.Delete(0, 1); }
};

class PMesh {
public:
	PMesh(Mesh&, PType, BOOL);
    ~PMesh();

    BOOL    GenPolygons();          // generate the polygons:
                                    //    returns TRUE if concave
    int     GetPolygonCnt()         // get the number of polygons
                { return mPolygons.Count(); };
    PMPoly* GetPolygon(int num)     // get a polygon
                { return &mPolygons[num]; };
    int     GetVertexCnt()          // get the number of vertices
                { return mVertices.Count(); };
    Point3  GetVertex(int num)      // get a vertex
                { return mVertices[num]; };
    int     GetTVertexCnt()         // get the number of vertices
                { return mTVertices.Count(); };
    Point3  GetTVertex(int num)     // get a vertex
                { return mTVertices[num]; };
    int     LookUpVert(int num);    // get the pmesh to trimesh mapping
    int     LookUpTVert(int num);   // get the pmesh to trimesh mapping

private:
	Mesh            mOrgMesh;               // the orginal mesh which PMesh is generated from
    PType           mType;                  // enum { OutputTriangles, OutputQuads, OutputNGons, OutputVisibleEdges };
    BOOL            mIsTextured;            // has UV coords
    double          mCosEps;                // allowable normals angular delta
    AdjEdgeList*    mAdjEdges;              // used to check for coplanar faces
    AdjFaceList*    mAdjFaces;              // used to check for coplanar faces
    int*            mSuppressEdges;         // internal, suppressed edges

    Tab<PMPoly> mPolygons;                  // used to store the polygons
    int         AddPolygon(PMPoly* newPoly) // return the location inserted
                    { return mPolygons.Insert(mPolygons.Count(), 1, newPoly); }

    Tab<Point3> mVertices;          // used to store the meshes verticies
    BitArray    mVMapping;          // used to store the vertices used
    int         AddVertex(Point3* newVert)
                    { return mVertices.Insert(mVertices.Count(), 1, newVert); }
    
    Tab<Point3> mTVertices;         // used to store the meshes verticies
    BitArray    mTVMapping;         // used to store the texture vertices used
    int         AddTVertex(Point3* newVert) 
                    { return mTVertices.Insert(mTVertices.Count(), 1, newVert); }

    void    GenCPFaces();           // generate the coplanar faces
    void    AddCPTriFaces(int faceNum, int polyCnt, BitArray& uFaces, BitArray& wFaces); //add tri face to polygon
    void    GenEdges();             // generate the visible edges
    void    GenVertices();          // generate the vertices
    void    CheckAdjacentFaces(int, BitArray&);
    BOOL    CheckIfMatIDsMatch(int faceNum, int adjFaceNum);    // make sure matID is the same
    BOOL    CheckIfUVVertMatch(AEdge edge, int faceNum, int adjFaceNum);    // make sure the UVVert is the same
    BOOL    CheckIfCoplanar(int, int);      // check if a face and an adj face are coplanar
    BOOL    CheckIfColinear(Point3 first, Point3 second, Point3 third);  // check if three verts are colinear
    void    GetNextEdge(int polyNum, int v0Prev, int edgeNum, BitArray& uVerts, BitArray& uEdges); // traverse the edges
    BOOL    IsValidFace(int);               // check for bad faces
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\pmesh.cpp ===
/**********************************************************************
 *<
	FILE: pmesh.cpp

	DESCRIPTION:  simple Polygon class module

	CREATED BY: greg finch

	HISTORY: created 1 december, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"
#include "pmesh.h"

#define EDGEFLAGS(i) (i == 0 ? EDGE_A : i == 1 ? EDGE_B : EDGE_C)

PMesh::PMesh(Mesh& om, PType type, BOOL gTV) {
    int i;
    mOrgMesh        = om;
    mType           = type;
    mIsTextured     = gTV;
    mCosEps         = cos(COPLANAR_NORMAL_EPSILON * PI / 180);
    mAdjEdges       = new AdjEdgeList(mOrgMesh);
	mAdjFaces       = new AdjFaceList(mOrgMesh, *mAdjEdges);

    mSuppressEdges = new int[om.getNumFaces()];
    for (i = 0; i < om.getNumFaces(); i++)
        mSuppressEdges[i] = 0;

    mOrgMesh.buildRenderNormals();
}
	
PMesh::~PMesh() {
    if (mPolygons.Count())
        mPolygons.Delete(0, mPolygons.Count());
    if (mVertices.Count())
        mVertices.Delete(0, mVertices.Count());
    if (mTVertices.Count())
        mTVertices.Delete(0, mTVertices.Count());

    delete [] mSuppressEdges;
    delete mAdjEdges;
    delete mAdjFaces;
}

BOOL
PMesh::CheckIfMatIDsMatch(int faceNum, int adjFaceNum)
{
    int     faceMatID       =  mOrgMesh.faces[faceNum].getMatID();
    int     adjFaceNumID    =  mOrgMesh.faces[adjFaceNum].getMatID();
    if (faceMatID == adjFaceNumID)
        return TRUE;    // everything is OK to collapse
    else
        return FALSE;
}

BOOL
PMesh::CheckIfUVVertMatch(AEdge edge, int faceNum, int adjFaceNum)
{
    UVVert e0_v0;
    UVVert e0_v1;
    UVVert e1_v0;
    UVVert e1_v1;

    return TRUE;    //FIXME 
 // don't have TVerts so we don't care
    if (mOrgMesh.getNumTVerts() <= 0) return TRUE;

    e0_v0 = mOrgMesh.getTVert(mOrgMesh.tvFace[faceNum].t[edge.e0]);
    e0_v1 = mOrgMesh.getTVert(mOrgMesh.tvFace[faceNum].t[(edge.e0 + 1) % 3]);
    e1_v0 = mOrgMesh.getTVert(mOrgMesh.tvFace[adjFaceNum].t[edge.e1]);
    e1_v1 = mOrgMesh.getTVert(mOrgMesh.tvFace[adjFaceNum].t[(edge.e1 + 1) % 3]);
    
    if ((e0_v0 == e1_v1) && (e0_v1 == e1_v0))
        return TRUE;    // everything is OK to collapse
    else
        return FALSE;
}

BOOL
PMesh::CheckIfCoplanar(int faceNum, int adjFaceNum)
{
    Point3  faceNormal;
    Point3  adjFaceNormal;

    faceNormal    = mOrgMesh.getFaceNormal(faceNum);
    adjFaceNormal = mOrgMesh.getFaceNormal(adjFaceNum);
 // check for degenerate face
    if (Length(faceNormal) && Length(adjFaceNormal))
        return (DotProd(faceNormal, adjFaceNormal) > mCosEps);
    else
        return FALSE;
}

void
PMesh::CheckAdjacentFaces(int faceNum, BitArray& uFaces)
{
    Point3  faceNormal;
    Point3  adjFaceNormal;
    int     adjFaceNum;
    int     visEdge;   // visable edge for face 0
    
    DWORD   face0[3];
    DWORD   face1[3];

    if (mType == OutputTriangles || mType == OutputQuads) {
        int     hFaceNum = -1;
        AEdge   hEdge;
        for (int i = 0; i < 3; i++) {
            adjFaceNum = mAdjFaces->list[faceNum].f[i];
         // teapot generate -1 for some faces !?
            if (adjFaceNum == -1) continue;
         // face was already written
            if (uFaces[adjFaceNum]) continue;
         // check for degenerate polygons like those in cones.
            if (!IsValidFace(adjFaceNum)) continue;
            if (mOrgMesh.faces[adjFaceNum].flags & FACE_HIDDEN) continue;
            if (!CheckIfCoplanar(faceNum, adjFaceNum)) continue;
            if (!CheckIfMatIDsMatch(faceNum, adjFaceNum)) continue;

            hFaceNum = adjFaceNum;

            face0[0] = mOrgMesh.faces[faceNum].v[0];
            face0[1] = mOrgMesh.faces[faceNum].v[1];
            face0[2] = mOrgMesh.faces[faceNum].v[2];
            face1[0] = mOrgMesh.faces[adjFaceNum].v[0];
            face1[1] = mOrgMesh.faces[adjFaceNum].v[1];
            face1[2] = mOrgMesh.faces[adjFaceNum].v[2];
         // find the shared coplanar edge
            AEdge edge = AdjoiningEdge(face0, face1);
            hEdge = edge;

            if (mIsTextured)
                if (!CheckIfUVVertMatch(edge, faceNum, adjFaceNum)) continue;

            visEdge = mOrgMesh.faces[faceNum].flags;
         // see if the coplanar edge is a visible edge
            /*
            #define EDGE_A		(1<<0)
            #define EDGE_B		(1<<1)
            #define EDGE_C		(1<<2)
            */
            if (visEdge & (1<<edge.e0)) continue;
        }
        if (hFaceNum != -1) {
/*
            mOrgMesh.faces[faceNum].setEdgeVis(0, EDGE_VIS);
            mOrgMesh.faces[faceNum].setEdgeVis(1, EDGE_VIS);
            mOrgMesh.faces[faceNum].setEdgeVis(2, EDGE_VIS);
            mOrgMesh.faces[faceNum].setEdgeVis(hEdge.e0, EDGE_INVIS);
            mOrgMesh.faces[hFaceNum].setEdgeVis(0, EDGE_VIS);
            mOrgMesh.faces[hFaceNum].setEdgeVis(1, EDGE_VIS);
            mOrgMesh.faces[hFaceNum].setEdgeVis(2, EDGE_VIS);
            mOrgMesh.faces[hFaceNum].setEdgeVis(hEdge.e1, EDGE_INVIS);
*/
            mSuppressEdges[faceNum] = EDGEFLAGS(hEdge.e0);
            mSuppressEdges[hFaceNum] = EDGEFLAGS(hEdge.e1);
            uFaces.Set(hFaceNum);
        } else {    // single face
            /*
            mOrgMesh.faces[faceNum].setEdgeVis(0, EDGE_VIS);
            mOrgMesh.faces[faceNum].setEdgeVis(1, EDGE_VIS);
            mOrgMesh.faces[faceNum].setEdgeVis(2, EDGE_VIS);
*/
            mSuppressEdges[faceNum] = 0;
        }
        return;
    } else {
        for (int i = 0; i < 3; i++) {
            adjFaceNum = mAdjFaces->list[faceNum].f[i];
         // teapot generate -1 for some faces !?
            if (adjFaceNum == -1) continue;
         // check for degenerate polygons like those in cones.
            if (!IsValidFace(adjFaceNum)) continue;
            if (mOrgMesh.faces[adjFaceNum].flags & FACE_HIDDEN) continue;
            if (!CheckIfCoplanar(faceNum, adjFaceNum)) continue;
            if (!CheckIfMatIDsMatch(faceNum, adjFaceNum)) continue;

            face0[0] = mOrgMesh.faces[faceNum].v[0];
            face0[1] = mOrgMesh.faces[faceNum].v[1];
            face0[2] = mOrgMesh.faces[faceNum].v[2];
            face1[0] = mOrgMesh.faces[adjFaceNum].v[0];
            face1[1] = mOrgMesh.faces[adjFaceNum].v[1];
            face1[2] = mOrgMesh.faces[adjFaceNum].v[2];
         // find the shared coplanar edge
            AEdge edge = AdjoiningEdge(face0, face1);
            
            if (mIsTextured)
                if (!CheckIfUVVertMatch(edge, faceNum, adjFaceNum)) continue;

         // if respecting visible lines.
            visEdge = mOrgMesh.faces[adjFaceNum].flags;
            /*
            #define EDGE_A		(1<<0)
            #define EDGE_B		(1<<1)
            #define EDGE_C		(1<<2)
            */
         // see if the coplanar edge is a visible edge
            if ((visEdge & (1<<edge.e1)) &&
                (mType == OutputVisibleEdges) &&
                !uFaces[adjFaceNum])
                continue;

/*
            mOrgMesh.faces[faceNum].setEdgeVis(edge.e0, EDGE_INVIS);
            mOrgMesh.faces[adjFaceNum].setEdgeVis(edge.e1, EDGE_INVIS);
*/
         // face was already written
            if (uFaces[adjFaceNum] && mType == OutputVisibleEdges)
                continue;

            mSuppressEdges[faceNum] |= EDGEFLAGS(edge.e0);
            mSuppressEdges[adjFaceNum] |= EDGEFLAGS(edge.e1);
            if (uFaces[adjFaceNum])
                continue;

            uFaces.Set(adjFaceNum);
            CheckAdjacentFaces(adjFaceNum, uFaces);
        }
    }
}

// this is for things like four sided cones which have 8 verts and 12 faces !?
BOOL
PMesh::IsValidFace(int face) {
    Point3  pts[3];
    
    pts[0] = mOrgMesh.getVert(mOrgMesh.faces[face].v[0]);
    pts[1] = mOrgMesh.getVert(mOrgMesh.faces[face].v[1]);
    pts[2] = mOrgMesh.getVert(mOrgMesh.faces[face].v[2]);

    if (pts[0] == pts[1]) return FALSE;
    if (pts[0] == pts[2]) return FALSE;
    if (pts[1] == pts[2]) return FALSE;
    
    return TRUE;
}

// generate the coplanar faces
void
PMesh::GenCPFaces()
{
    int i;
 // used to store the faces used
    BitArray uFaces;
    uFaces.SetSize(mOrgMesh.getNumFaces());

 // used to store the faces written
    BitArray wFaces;
    wFaces.SetSize(mOrgMesh.getNumFaces());

    PMPoly  newPolygon;
    int     polyCnt;

 // generate a list of coplanar faces
    uFaces.ClearAll();
    wFaces.ClearAll();
    polyCnt = 0;
    for (i = 0; i < mOrgMesh.getNumFaces(); i++) {
     // skip faces that have been written
        if (!uFaces[i]) {
            if (mOrgMesh.faces[i].flags & FACE_HIDDEN)
                continue;
            if (!IsValidFace(i))
                continue;
            uFaces.Set(i);
            if (mType != OutputTriangles)
                CheckAdjacentFaces(i, uFaces);

            newPolygon.SetFNormal(mOrgMesh.getFaceNormal(i));
            AddPolygon(&newPolygon);
            //if (mIsTextured) AddTPolygon(&newPolygon);

         // loop thur CP faces an add tri faces to list
            wFaces ^= uFaces;
            AddCPTriFaces(i, polyCnt, uFaces, wFaces);
            wFaces  = uFaces;
            polyCnt++;
		}
    }
}

void
PMesh::AddCPTriFaces(int faceNum, int polyCnt, BitArray& uFaces, BitArray& wFaces)
{
    int adjFaceNum;

    mPolygons[polyCnt].AddTriFace(&faceNum);
    wFaces.Clear(faceNum);
    if (mType == OutputTriangles) return;

    for (int i = 0; i < 3; i++) {
        adjFaceNum = mAdjFaces->list[faceNum].f[i];
     // teapot generate -1 for some faces!?
        if (adjFaceNum == -1) continue;

        if (wFaces[adjFaceNum]) {
            wFaces.Clear(adjFaceNum);
            if (mType == OutputQuads) {
                mPolygons[polyCnt].AddTriFace(&adjFaceNum);
                return;
            }
            AddCPTriFaces(adjFaceNum, polyCnt, uFaces, wFaces);
        }
    }
}

void
PMesh::GenEdges()
{
    int i, j;
    PMEdge  newEdge;
    int     numEdges = 0;
    int     visEdge  = 0;
    int     face[3];
    int     tFace;
    
    for (i = 0; i < GetPolygonCnt(); i++) {
        for (j = 0; j < mPolygons[i].GetTriFaceCnt(); j++) {
            /*
            if (mIsTextured) {
                tFace[0] = mOrgMesh.tvFace[mPolygons[i].GetTriFace(j)].t[0];
                tFace[1] = mOrgMesh.tvFace[mPolygons[i].GetTriFace(j)].t[1];
                tFace[2] = mOrgMesh.tvFace[mPolygons[i].GetTriFace(j)].t[2];
		    }
            */
            tFace = mPolygons[i].GetTriFace(j);
      	    face[0] = mOrgMesh.faces[tFace].v[0];
    		face[1] = mOrgMesh.faces[tFace].v[1];
	    	face[2] = mOrgMesh.faces[tFace].v[2];
//            visEdge = mOrgMesh.faces[tFace].flags | ~mSuppressEdges[tFace]; // ??
            visEdge = ~mSuppressEdges[tFace];                                 // ??

            if (visEdge & EDGE_A) {
                numEdges++;
                newEdge.SetEdgeVisiblity(VisibleEdge);
                newEdge.SetVIndex(0, face[0]);
                newEdge.SetVIndex(1, face[1]);
                newEdge.SetFace(0, tFace, EDGE_A);
                mPolygons[i].AddEdge(&newEdge);
                /*
                if (mIsTextured) {
                    newEdge.SetVIndex(0, tFace[0]);
                    newEdge.SetVIndex(1, tFace[1]);
                    mPolygons[i].AddTEdge(&newEdge);
                }
                */
            }
            if (visEdge & EDGE_B) {
                numEdges++;
                newEdge.SetEdgeVisiblity(VisibleEdge);
                newEdge.SetVIndex(0, face[1]);
                newEdge.SetVIndex(1, face[2]);
                newEdge.SetFace(0, tFace, EDGE_B);
                mPolygons[i].AddEdge(&newEdge);
                /*
                if (mIsTextured) {
                    newEdge.SetVIndex(0, tFace[1]);
                    newEdge.SetVIndex(1, tFace[2]);
                    mPolygons[i].AddTEdge(&newEdge);
                }
                */
            }
            if (visEdge & EDGE_C) {
                numEdges++;
                newEdge.SetEdgeVisiblity(VisibleEdge);
                newEdge.SetVIndex(0, face[2]);
                newEdge.SetVIndex(1, face[0]);
                newEdge.SetFace(0, tFace, EDGE_C);
                mPolygons[i].AddEdge(&newEdge);
                /*
                if (mIsTextured) {
                    newEdge.SetVIndex(0, tFace[2]);
                    newEdge.SetVIndex(1, tFace[0]);
                    mPolygons[i].AddTEdge(&newEdge);
                }
                */
            }
        }
    }
}

BOOL
PMesh::GenPolygons()
{
    int i;
    
    int numVerts = mOrgMesh.getNumVerts();
    mVMapping.SetSize(numVerts);
    mVMapping.ClearAll();

    int numTVerts = mOrgMesh.getNumTVerts();
    mTVMapping.SetSize(numTVerts);
    mTVMapping.ClearAll();
    
 // keep track of which vertices have been added
    BitArray aVerts;
    aVerts.SetSize(numVerts);
    aVerts.ClearAll();

    BitArray aTVerts;
    aTVerts.SetSize(numTVerts);
    aTVerts.ClearAll();

    GenCPFaces();   // generate the polygons' triangle face lists
    GenEdges();     // generate the polygons' visible edge lists
    GenVertices();  // generate the list of verts that make up the polygons

    for (i = 0; i < numVerts; i++) {
        if (mVMapping[i] && !aVerts[i]) {
            AddVertex(&mOrgMesh.getVert(i));
            aVerts.Set(i);
        }
    }
    if (mIsTextured) {
        for (i = 0; i < numTVerts; i++) {
            if (mTVMapping[i] && !aTVerts[i]) {
                AddTVertex(&mOrgMesh.getTVert(i));
                aTVerts.Set(i);
            }
        }
    }
    
    mPolygons.Shrink();
    for (i = 0; i < mPolygons.Count(); i++) {
        mPolygons[i].Shrink();
    }
    mVertices.Shrink();
    mTVertices.Shrink();

    // test for concavity

    for (i = 0; i < GetPolygonCnt(); i++) {
        Point3 o, p, q, r, s;
        int j;
        int u = mPolygons[i].GetVIndexCnt();
        int vex = 0;

        if (u > 3) {
            for (j = 0; j <= u + 1; j++) {
                int w = LookUpVert(mPolygons[i].GetVIndex(j%u));
                p = GetVertex(w);
                if (vex > 1) {
                    r = Normalize((q - o) ^ (p - q));
                    if (vex == 2)
                        s = r;
                    else if (DotProd(s, r) < 0.0)
                        return TRUE;                // concave
                }
                o = q;
                q = p;
                vex++;
            }
        }
    }
    return FALSE;                                   // convex
}

BOOL
PMesh::CheckIfColinear(Point3 first, Point3 second, Point3 third)
{
    Point3  distance0;  // distance from vertLast to edge's v0
    float   length0;
    Point3  distance1;  // distance from edge's v0 to v1
    float   length1;

    distance0 = second - first;
    length0   = Length(distance0);
    distance1 = third - second;
    length1   = Length(distance1);
    
    if (length0 && length1)
        return (DotProd(distance0, distance1)/(length0*length1) > mCosEps);
    else
        return TRUE;
}

void
PMesh::GetNextEdge(int polyNum, int v0Prev, int vertNum,
                   BitArray& uVerts, BitArray& uEdges/*, BOOL tFace*/)
{
    int         i;
    int         v0, v1;     // face vertex index
    int         tV0 = 0;    // texture face vertex index
    int         tV1 = 0;    // texture face vertex index
    Point3      vert;
    UVVert      tVert;
    int         eFace;      // this the face0 of the edge
    int         numEdges;
    //BitArray*   mapping;
    PMEdge      edge;
    Point3      clv0, clv1, clv2;   // colinear verts

    Point3   norm;
    RVertex* rv;
    int      norCnt;
    int      smGroup;

    //if (tFace) {
        //numEdges = mPolygons[polyNum].GetTEdgeCnt();
        //mapping  = &mTVMapping;
    //} else {
        numEdges = mPolygons[polyNum].GetEdgeCnt();
        //mapping  = &mVMapping;
    //}

    for (i = 0; i < numEdges; i++) {
        //if (tFace) {
            //edge = mPolygons[polyNum].GetTEdge(i);
        //} else {
            edge = mPolygons[polyNum].GetEdge(i);
        //}

        v0 = edge.GetVIndex(0);
        v1 = edge.GetVIndex(1);

        eFace = edge.GetFace(0);

        if (mIsTextured) {
            if (edge.GetFaceFlags(0) & EDGE_A) {
                tV0 = mOrgMesh.tvFace[eFace].t[0];
                tV1 = mOrgMesh.tvFace[eFace].t[1];
            } else if (edge.GetFaceFlags(0) & EDGE_B) {
                    tV0 = mOrgMesh.tvFace[eFace].t[1];
                    tV1 = mOrgMesh.tvFace[eFace].t[2];
            } else if (edge.GetFaceFlags(0) & EDGE_C) {
                    tV0 = mOrgMesh.tvFace[eFace].t[2];
                    tV1 = mOrgMesh.tvFace[eFace].t[0];
            }
        }

        if (v0 == vertNum) {
            if (uEdges[i])  // must be a T check other edges
                continue;
            uEdges.Set(i);
            if (!uVerts[v1]) {
                if (edge.GetEdgeVisiblity() == VisibleEdge) {
                    if (!uVerts[v0]) {
                        uVerts.Set(v0);
                        //if (!(*mapping)[v0])
                            //mapping->Set(v0);
                        if (!mVMapping[v0])
                            mVMapping.Set(v0);

                        vert = mOrgMesh.getVert(v0);
                        mPolygons[polyNum].AddVert(&vert);
                        mPolygons[polyNum].AddToPolygon(v0);

                     // add the vertex normal
                        norm    = mPolygons[polyNum].GetFNormal();
                        rv      = mOrgMesh.getRVertPtr(v0);
                        norCnt  = (int) (rv->rFlags & NORCT_MASK);
                        smGroup = mOrgMesh.faces[eFace].getSmGroup();

                        if (rv->rFlags & SPECIFIED_NORMAL) {
                            norm = rv->rn.getNormal();
                        } else if (norCnt && smGroup) {
                            if (norCnt == 1)
                                norm = rv->rn.getNormal();
                            else for (int k = 0; k < norCnt; k++) {
                                if (rv->ern[k].getSmGroup() & smGroup) {
                                    norm = rv->ern[k].getNormal();
                                    break;
                                }
                            }
                        }
                        mPolygons[polyNum].AddVNormal(&norm);

                        if (mIsTextured) {
                            if (!mTVMapping[tV0])
                                mTVMapping.Set(tV0);
                            tVert = mOrgMesh.getTVert(tV0);
                            mPolygons[polyNum].AddTVert(&tVert);
                            mPolygons[polyNum].AddToTPolygon(tV0);
                        }
                    } else {    // see if it is colinear
                        if (v0Prev != -1) {  // if this is not the first edge
                            clv0 = mOrgMesh.getVert(v0Prev);
                            clv1 = mOrgMesh.getVert(v0);
                            clv2 = mOrgMesh.getVert(v1);
                            if (CheckIfColinear(clv0, clv1, clv2)) {
                             // remove the last vert and vert normal added
                                mPolygons[polyNum].RemoveLastVert();
                                mPolygons[polyNum].RemoveLastVNormal();
                                mPolygons[polyNum].RemoveLastFromPolygon();
                                uVerts.Clear(v0);
                                mVMapping.Clear(v0);
                                if (mIsTextured) {
                                    mPolygons[polyNum].RemoveLastTVert();
                                    mPolygons[polyNum].RemoveLastFromTPolygon();
                                    mTVMapping.Clear(tV0);
                                }
                            }
                        }
                        else
                            assert(FALSE);
                    }
                    if (!uVerts[v1]) {
                        uVerts.Set(v1);
                        //if (!(*mapping)[v1])
                            //mapping->Set(v1);
                        if (!mVMapping[v1])
                            mVMapping.Set(v1);
                        vert = mOrgMesh.getVert(v1);
                        mPolygons[polyNum].AddVert(&vert);
                        mPolygons[polyNum].AddToPolygon(v1);

                     // add the vertex normal
                        norm    = mPolygons[polyNum].GetFNormal();
                        rv      = mOrgMesh.getRVertPtr(v1);
                        norCnt  = (int) (rv->rFlags & NORCT_MASK);
                        smGroup = mOrgMesh.faces[eFace].getSmGroup();

                        if (rv->rFlags & SPECIFIED_NORMAL) {
                            norm = rv->rn.getNormal();
                        } else if (norCnt && smGroup) {
                            if (norCnt == 1)
                                norm = rv->rn.getNormal();
                            else for (int k = 0; k < norCnt; k++) {
                                if (rv->ern[k].getSmGroup() & smGroup) {
                                    norm = rv->ern[k].getNormal();
                                    break;
                                }
                            }
                        }
                        mPolygons[polyNum].AddVNormal(&norm);

                        if (mIsTextured) {
                            if (!mTVMapping[tV1])
                                mTVMapping.Set(tV1);
                            tVert = mOrgMesh.getTVert(tV1);
                            mPolygons[polyNum].AddTVert(&tVert);
                            mPolygons[polyNum].AddToTPolygon(tV1);
                        }
                    }
                }
                GetNextEdge(polyNum, v0, v1, uVerts, uEdges);
                return;
            } else {
             // last edge; check if polygon has a hole or last/first vert is colinear
                PMEdge  firstEdge;
                PMEdge  tstEdge;

             // must have a hole in the face or a non contiguous edge list
                if (numEdges > uEdges.NumberSet()) {
                    float   shortDist;  // shortest distance between verts of outside/inside edges
                    float   tstDist;    // current distance
                    Point3  vert0;      // first vert0 of edge0
                    Point3  vert1;      // vert0 of current edge

                    int     tVert0 = 0;     // index of the texture vert0 of the edge

                    int     first = TRUE;

                    firstEdge = mPolygons[polyNum].GetEdge(0);
                    vert0 = mOrgMesh.getVert(firstEdge.GetVIndex(0));
                    
                    for (int j = 0; j < numEdges; j++) {
                        if (!uEdges[j]) {
                         // find the closest vert
                            tstEdge   = mPolygons[polyNum].GetEdge(j);
                            vert1     = mOrgMesh.getVert(tstEdge.GetVIndex(0));
                            if (!first) {
                                tstDist = Length(vert1 - vert0);
                                if (fabs(tstDist) < fabs(shortDist)) { // inside or outside
                                    shortDist = tstDist;
                                    edge = tstEdge;
                                }
                            } else {
                                shortDist = Length(vert1 - vert0);
                                edge = tstEdge;
                                first = FALSE;
                            }
                        }
                    }
                    if (!first) {   // this should always be the case, but ...
                     // insert first vert into the polylist
                        mPolygons[polyNum].AddToPolygon(firstEdge.GetVIndex(0));
                        if (mIsTextured) {
                            if (firstEdge.GetFaceFlags(0) & EDGE_A) {
                                tVert0 = mOrgMesh.tvFace[firstEdge.GetFace(0)].t[0];
                            } else if (firstEdge.GetFaceFlags(0) & EDGE_B) {
                                tVert0 = mOrgMesh.tvFace[firstEdge.GetFace(0)].t[1];
                            } else if (firstEdge.GetFaceFlags(0) & EDGE_C) {
                                tVert0 = mOrgMesh.tvFace[firstEdge.GetFace(0)].t[2];
                            }
                            mPolygons[polyNum].AddToTPolygon(tVert0);
                        }

                     // walk thru the inside edges
                        GetNextEdge(polyNum, -1, edge.GetVIndex(0), uVerts, uEdges);
                     // insert last vert into the polylist
                        mPolygons[polyNum].AddToPolygon(edge.GetVIndex(0));
                        if (mIsTextured) {
                            if (edge.GetFaceFlags(0) & EDGE_A) {
                                tVert0 = mOrgMesh.tvFace[edge.GetFace(0)].t[0];
                            } else if (edge.GetFaceFlags(0) & EDGE_B) {
                                tVert0 = mOrgMesh.tvFace[edge.GetFace(0)].t[1];
                            } else if (edge.GetFaceFlags(0) & EDGE_C) {
                                tVert0 = mOrgMesh.tvFace[edge.GetFace(0)].t[2];
                            }
                            mPolygons[polyNum].AddToTPolygon(tVert0);
                        }

                     // done
                        return;
                    } else assert(FALSE);
                }

             // check last vertex
                firstEdge = mPolygons[polyNum].GetEdge(0);
                if (v0Prev == -1) assert(FALSE);
                clv0 = mOrgMesh.getVert(v0Prev);
                clv1 = mOrgMesh.getVert(v0);
                clv2 = mOrgMesh.getVert(v1);

                if (CheckIfColinear(clv0, clv1, clv2)) {
                 // remove the last vert and vert normal added
                    mPolygons[polyNum].RemoveLastVert();
                    mPolygons[polyNum].RemoveLastVNormal();
                    mPolygons[polyNum].RemoveLastFromPolygon();
                    uVerts.Clear(v0);
                    mVMapping.Clear(v0);
                    if (mIsTextured) {
                        mPolygons[polyNum].RemoveLastTVert();
                        mPolygons[polyNum].RemoveLastFromTPolygon();
                        mTVMapping.Clear(tV0);
                    }
                }

             // check if last/first edges are colinear
                clv0 = mOrgMesh.getVert(v0);
                clv1 = mOrgMesh.getVert(firstEdge.GetVIndex(0));
                clv2 = mOrgMesh.getVert(firstEdge.GetVIndex(1));

                if (CheckIfColinear(clv0, clv1, clv2)) {
                 // remove the first vert and normal added
                    mPolygons[polyNum].RemoveFirstVert();
                    mPolygons[polyNum].RemoveFirstVNormal();
                    mPolygons[polyNum].RemoveFirstFromPolygon();
                    uVerts.Clear(v1);
                    mVMapping.Clear(v1);
                    if (mIsTextured) {
                        mPolygons[polyNum].RemoveFirstTVert();
                        mPolygons[polyNum].RemoveFirstFromTPolygon();
                        mTVMapping.Clear(tV1);
                    }
                }
            }
        }
    }
}

void
PMesh::GenVertices()
{
 // used to store the verts used
    BitArray uVerts;
 // used to store the edges used
    BitArray uEdges;
    int i;
    int numVerts    = mOrgMesh.getNumVerts();
    //int numTVerts   = mOrgMesh.getNumTVerts();

    for (i = 0; i < GetPolygonCnt(); i++) {
        uEdges.SetSize(mPolygons[i].GetEdgeCnt());
        uEdges.ClearAll();
        uVerts.SetSize(numVerts);
        uVerts.ClearAll();
        GetNextEdge(i, -1, mPolygons[i].GetEdge(0).GetVIndex(0), uVerts, uEdges);
    }

    /*
    if (mIsTextured) {
        for (i = 0; i < GetPolygonCnt(); i++) {
            uEdges.SetSize(mPolygons[i].GetTEdgeCnt());
            uEdges.ClearAll();
            uVerts.SetSize(numTVerts);
            uVerts.ClearAll();
            GetNextEdge(i, -1, mPolygons[i].GetTEdge(0).GetVIndex(0), uVerts, uEdges, TRUE);
        }
    }
    */
}

// cheeze function to find the adjoining edge
AEdge
AdjoiningEdge(DWORD* face0, DWORD* face1) {
    AEdge edge;
    if (face0[0] == face1[1] && face0[1] == face1[0]) {
        edge.e0 = 0;
        edge.e1 = 0;
        return edge;
    }
    if (face0[0] == face1[2] && face0[1] == face1[1]) {
        edge.e0 = 0;
        edge.e1 = 1;
        return edge;
    }
    if (face0[0] == face1[0] && face0[1] == face1[2]) {
        edge.e0 = 0;
        edge.e1 = 2;
        return edge;
    }
    if (face0[1] == face1[1] && face0[2] == face1[0]) {
        edge.e0 = 1;
        edge.e1 = 0;
        return edge;
    }
    if (face0[1] == face1[2] && face0[2] == face1[1]) {
        edge.e0 = 1;
        edge.e1 = 1;
        return edge;
    }
    if (face0[1] == face1[0] && face0[2] == face1[2]) {
        edge.e0 = 1;
        edge.e1 = 2;
        return edge;
    }
    if (face0[2] == face1[1] && face0[0] == face1[0]) {
        edge.e0 = 2;
        edge.e1 = 0;
        return edge;
    }
    if (face0[2] == face1[2] && face0[0] == face1[1]) {
        edge.e0 = 2;
        edge.e1 = 1;
        return edge;
    }
    if (face0[2] == face1[0] && face0[0] == face1[2]) {
        edge.e0 = 2;
        edge.e1 = 2;
        return edge;
    }
 // when all else fails
	edge.e0 = 0;
    edge.e1 = 0;
    return edge;
}

int
PMesh::LookUpTVert(int num) {
    int cnt = 0;
    for (int i = 0; i < num; i++) {
        if (mTVMapping[i]) cnt++;
    }
    return cnt;
}

int
PMesh::LookUpVert(int num) {
    int cnt = 0;
    for (int i = 0; i < num; i++) {
        if (mVMapping[i]) cnt++;
    }
    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\prox.cpp ===
/**********************************************************************
 *<
    FILE: prox.cpp

    DESCRIPTION:  A VRML ProximitySensor Helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 4 Sept, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "prox.h"

//------------------------------------------------------

class ProxSensorClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new ProxSensorObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_PROX_SENSOR_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(ProxSensor_CLASS_ID1,
                                                    ProxSensor_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static ProxSensorClassDesc ProxSensorDesc;

ClassDesc* GetProxSensorDesc() { return &ProxSensorDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ICustButton *ProxSensorObject::ProxSensorPickButton = NULL;

HWND ProxSensorObject::hRollup = NULL;
int ProxSensorObject::dlgPrevSel = -1;

class ProxSensorObjPick : public PickModeCallback {
    ProxSensorObject *proxSensor;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetProxSensor(ProxSensorObject *l) { proxSensor = l; }
};

//static ProxSensorObjPick thePick;
static  ProxSensorObjPick   thePick;
static  BOOL                pickMode    = FALSE;
static  CommandMode*        lastMode    = NULL;

static void
SetPickMode(ProxSensorObject* o) {
    if (pickMode || !o) {
        pickMode = FALSE;
        GetCOREInterface()->PushCommandMode(lastMode);
        lastMode = NULL;
        GetCOREInterface()->ClearPickMode();
    } else {
        pickMode = TRUE;
        lastMode = GetCOREInterface()->GetCommandMode();
        thePick.SetProxSensor(o);
        GetCOREInterface()->SetPickMode(&thePick);
    }
}

BOOL
ProxSensorObjPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(ProxSensor_CLASS_ID1, ProxSensor_CLASS_ID2)))
        return FALSE;
    return TRUE;
}

void
ProxSensorObjPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(GetString(IDS_TouchSensor_PICK_MODE));
}

void
ProxSensorObjPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
ProxSensorObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        // Check to see if we have a reference to this object already
        for (int i = 0; i < proxSensor->objects.Count(); i++) {
            if (proxSensor->objects[i]->node == node)
                return FALSE; // Can't click those we already have
        }

        ProxSensorObj *obj = new ProxSensorObj(node);
        int id = proxSensor->objects.Append(1, &obj);
        proxSensor->pblock->SetValue(PB_PS_NUMOBJS,
                                     proxSensor->iObjParams->GetTime(),
                                     proxSensor->objects.Count());

        RefResult ret = proxSensor->MakeRefByID(FOREVER, id+1, node);

        HWND hw = proxSensor->hRollup;
        int ind = SendMessage(GetDlgItem(hw,IDC_LIST),
                              LB_ADDSTRING, 0, (LPARAM)obj->listStr.data());
        SendMessage(GetDlgItem(hw,IDC_LIST),
                    LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        EnableWindow(GetDlgItem(hw, IDC_DEL),
                     proxSensor->objects.Count() > 0);
    }
    return FALSE;
}


HCURSOR
ProxSensorObjPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

void
BuildObjectList(ProxSensorObject *ob)
{
    if (ob && ob->hRollup) {
        int count, i;

        count = SendDlgItemMessage(ob->hRollup, IDC_LIST,
                                   LB_GETCOUNT, 0, 0);

        // First remove any objects on the list
        for (i = count - 1; i >= 0; i--)
            SendDlgItemMessage(ob->hRollup, IDC_LIST,
                               LB_DELETESTRING, (WPARAM) i, 0);

        for (i = 0; i < ob->objects.Count(); i++) {
            ProxSensorObj *obj = ob->objects[i];
            obj->ResetStr(); // Make sure we're up to date

            // for now just load the name, we might want to add 
            // the frame range as some point
            int ind = SendMessage(GetDlgItem(ob->hRollup,IDC_LIST),
                                  LB_ADDSTRING, 0,
                                  (LPARAM)obj->listStr.data());
            SendMessage(GetDlgItem(ob->hRollup,IDC_LIST),
                        LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        }
    }
}

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  ProxSensorObject* th)
{
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG:

        th->ProxSensorPickButton = GetICustButton(GetDlgItem(hDlg,
                                                  IDC_PICK));
        th->ProxSensorPickButton->SetType(CBT_CHECK);
        th->ProxSensorPickButton->SetButtonDownNotify(TRUE);
        th->ProxSensorPickButton->SetHighlightColor(GREEN_WASH);
        th->ProxSensorPickButton->SetCheck(FALSE);

        // Now we need to fill in the list box IDC_LIST
        th->hRollup = hDlg;
        BuildObjectList(th);

//        EnableWindow(GetDlgItem(hDlg, IDC_DEL),
//                     (th->objects.Count() > 0));
        th->dlgPrevSel = -1;

        if (pickMode) SetPickMode(th);

        return TRUE;			

    case WM_DESTROY:
        if (pickMode) SetPickMode(th);
        //th->iObjParams->ClearPickMode();
        //th->previousMode = NULL;
        ReleaseICustButton( th->ProxSensorPickButton );
        return FALSE;

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_PICK: // Pick an object from the scene
            // Set the pickmode...
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                SetPickMode(th);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    thePick.SetProxSensor(th);
                    th->iObjParams->SetPickMode(&thePick);
                }
                */
                break;
            }
            break;
        case IDC_DEL: { // Delete the object from the list
            int index =	SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                    LB_GETCURSEL, 0, 0);
            if (index != LB_ERR) {
                ProxSensorObj *obj = (ProxSensorObj *)
                    SendDlgItemMessage(hDlg, IDC_LIST,
                                       LB_GETITEMDATA, index, 0);
                for (int i = 0; i < th->objects.Count(); i++) {
                    if (obj == th->objects[i]) {
                        // remove the item from the list
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_DELETESTRING,
                                           (WPARAM) index, 0);
                        th->dlgPrevSel = -1;
                        // remove the object from the table
                        th->DeleteReference(i+1);
                        th->objects.Delete(i, 1);
                        th->pblock->SetValue(PB_PS_NUMOBJS,
                                             th->iObjParams->GetTime(),
                                             th->objects.Count());
                        break;
                    }
                }
                EnableWindow(GetDlgItem(hDlg, IDC_DEL),
                             (th->objects.Count() > 0));
                if (th->objects.Count() <= 0) {
                    th->iObjParams->RedrawViews(th->iObjParams->GetTime());
                }
            }
        }
        break;
        case IDC_LIST:
            switch(HIWORD(wParam)) {
            case LBN_SELCHANGE: {
                int sel = SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                      LB_GETCURSEL, 0, 0);
                if (th->dlgPrevSel != -1) {
                    // save any editing
                    ProxSensorObj *obj = (ProxSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_GETITEMDATA, th->dlgPrevSel, 0);
                    obj->ResetStr();
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_DELETESTRING, th->dlgPrevSel, 0);
                    int ind = SendMessage(GetDlgItem(hDlg,
                                                     IDC_LIST),
                                          LB_ADDSTRING, 0,
                                          (LPARAM)obj->listStr.data());
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_SETCURSEL, sel, 0);
                }
                th->dlgPrevSel = sel;
                if (sel >= 0) {
                    ProxSensorObj *obj = (ProxSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_GETITEMDATA, sel, 0);
                    assert(obj);

                } else {
                }
                th->iObjParams->RedrawViews(th->iObjParams->GetTime());
            }
            break;
            case LBN_SELCANCEL:
                break;
            }
            break;
        }
        return FALSE;
    default:
        return FALSE;
    }
}

static ParamUIDesc descParam[] = {
  // Length
  ParamUIDesc(
              PB_PS_LENGTH,
              EDITTYPE_UNIVERSE,
              IDC_LENGTH_EDIT, IDC_LENGTH_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Width
  ParamUIDesc(
              PB_PS_WIDTH,
              EDITTYPE_UNIVERSE,
              IDC_WIDTH_EDIT, IDC_WIDTH_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Height
  ParamUIDesc(
              PB_PS_HEIGHT,
              EDITTYPE_UNIVERSE,
              IDC_HEIGHT_EDIT, IDC_HEIGHT_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Enabled
  ParamUIDesc(PB_PS_ENABLED, TYPE_SINGLECHEKBOX, IDC_ENABLE),

};

  

#define PARAMDESC_LENGTH 4

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_FLOAT, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_INT, NULL, FALSE, 3 },
  { TYPE_INT, NULL, FALSE, 4 },
};


//static ParamVersionDesc versions[] = {
//  ParamVersionDesc(descVer0,5,0),
//};

//#define NUM_OLD_VERSIONS 1

#define CURRENT_VERSION	0
// Current version
static ParamVersionDesc curVersion(descVer0, PB_PS_LENGTH, CURRENT_VERSION);

class ProxSensorParamDlgProc : public ParamMapUserDlgProc {
public:
  ProxSensorObject *ob;

  ProxSensorParamDlgProc(ProxSensorObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL ProxSensorParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *ProxSensorObject::pmapParam = NULL;

#if 0
IOResult
ProxSensorObject::Load(ILoad *iload) 
{
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(versions,
                                                     NUM_OLD_VERSIONS,
                                                     &curVersion,this,0));
  return IO_OK;
}

#endif

void
ProxSensorObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                   Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        // Left over from last ProxSensor created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_PROX_SENSOR),
                                     _T("Prox Sensor"),
                                     0);
    }
    
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new ProxSensorParamDlgProc(this));
    }
}
		
void
ProxSensorObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
//    iObjParams = NULL;
}

ProxSensorObject::ProxSensorObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_PS_PB_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_PS_LENGTH, 0, 0.0f);
    pb->SetValue(PB_PS_WIDTH, 0, 0.0f);
    pb->SetValue(PB_PS_HEIGHT, 0, 0.0f);
    pb->SetValue(PB_PS_ENABLED, 0, TRUE);
    pb->SetValue(PB_PS_NUMOBJS, 0, 0);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    previousMode = NULL;
    objects.SetCount(0);
    BuildObjectList(this);
}

ProxSensorObject::~ProxSensorObject()
{
    DeleteAllRefsFromMe();
    for (int i = 0; i < objects.Count(); i++) {
        ProxSensorObj *obj = objects[i];
        delete obj;
    }
}

IObjParam *ProxSensorObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
ProxSensorObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
    int i;
    switch (message) {
    case REFMSG_TARGET_DELETED:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < objects.Count(); i++) {
            if (objects[i]->node == hTarget) {
                // Do I need to remove the reference? FIXME
                objects.Delete(i, 1); 
                int numObjs;
                pblock->GetValue(PB_PS_NUMOBJS, 0, numObjs,
                                 FOREVER);
                numObjs--;
                pblock->SetValue(PB_PS_NUMOBJS, 0, numObjs);
            }
        }
        break;
    case REFMSG_NODE_NAMECHANGE:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < objects.Count(); i++) {
            if (objects[i]->node == hTarget) {
                // Found it
                objects[i]->ResetStr();
                break;
            }
        }
        break;
    }
    return REF_SUCCEED;
}

RefTargetHandle
ProxSensorObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    if (ind > objects.Count()) return NULL;

    if (objects[ind-1] == NULL)
        return NULL;
    return objects[ind-1]->node;
}

void
ProxSensorObject::SetReference(int ind, RefTargetHandle rtarg)
{
    if (ind == 0) {
        pblock = (IParamBlock*) rtarg;
        if (pblock) {
            int numObjs;
            pblock->GetValue(PB_PS_NUMOBJS, 0, numObjs,
                             FOREVER);
            if (objects.Count() == 0) {
                objects.SetCount(numObjs);
                for(int i = 0; i < numObjs; i++)
                    objects[i] = new ProxSensorObj();
            }
        }
        return;
    }
    else if (ind > objects.Count())
        return;

    objects[ind-1]->node = (INode *)rtarg;
    objects[ind-1]->ResetStr();
}

ObjectState
ProxSensorObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
ProxSensorObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
ProxSensorObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
ProxSensorObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
ProxSensorObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


static void 
MakeQuad(Face *f, int a, int b , int c , int d, int sg) 
{
    f[0].setVerts( a, b, c);
    f[0].setSmGroup(sg);
    f[0].setEdgeVisFlags(1,1,0);
    f[1].setVerts( c, d, a);
    f[1].setSmGroup(sg);
    f[1].setEdgeVisFlags(1,1,0);
}

void
ProxSensorObject::BuildMesh(TimeValue t)
{
    int nverts = 8;
    int nfaces = 12;
    Point3 va;
    Point3 vb;

    float length, width, height;
    pblock->GetValue(PB_PS_LENGTH, t, length, FOREVER);
    pblock->GetValue(PB_PS_WIDTH, t, width, FOREVER);
    pblock->GetValue(PB_PS_HEIGHT, t, height, FOREVER);
    float x = width/2.0f;
    float y = length/2.0f;
    float z = height;
    va = Point3(-x, -y, 0.0f);
    vb = Point3( x,  y, z);
    
    mesh.setNumVerts(nverts);
    mesh.setNumFaces(nfaces);
    
    mesh.setVert(0, Point3( va.x, va.y, va.z));
    mesh.setVert(1, Point3( vb.x, va.y, va.z));
    mesh.setVert(2, Point3( va.x, vb.y, va.z));
    mesh.setVert(3, Point3( vb.x, vb.y, va.z));
    mesh.setVert(4, Point3( va.x, va.y, vb.z));
    mesh.setVert(5, Point3( vb.x, va.y, vb.z));
    mesh.setVert(6, Point3( va.x, vb.y, vb.z));
    mesh.setVert(7, Point3( vb.x, vb.y, vb.z));
    
    MakeQuad(&(mesh.faces[ 0]), 0,2,3,1,  1);
    MakeQuad(&(mesh.faces[ 2]), 2,0,4,6,  2);
    MakeQuad(&(mesh.faces[ 4]), 3,2,6,7,  4);
    MakeQuad(&(mesh.faces[ 6]), 1,3,7,5,  8);
    MakeQuad(&(mesh.faces[ 8]), 0,1,5,4, 16);
    MakeQuad(&(mesh.faces[10]), 4,5,7,6, 32);
    mesh.InvalidateGeomCache();
    mesh.EnableEdgeList(1);
}

int
ProxSensorObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 1.0f, 0.5f, 0.5f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
ProxSensorObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class ProxSensorCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0, sp1;
    Point3 p0,p1;
    ProxSensorObject *ob;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(ProxSensorObject *obj) {ob = obj;}

};

			
int ProxSensorCreateCallBack::proc(ViewExp *vpt,int msg, int point,
                                   int flags, IPoint2 m, Matrix3& mat )
{
    Point3 d;
    if (msg==MOUSE_POINT||msg==MOUSE_MOVE) {
        switch(point) {
        case 0:
            sp0 = m;
            ob->pblock->SetValue(PB_PS_WIDTH,0,0.0f);
            ob->pblock->SetValue(PB_PS_LENGTH,0,0.0f);
            ob->pblock->SetValue(PB_PS_HEIGHT,0,0.0f);

            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            p1 = p0 + Point3(.01,.01,.01);
            mat.SetTrans(float(.5)*(p0+p1));				
            break;
        case 1:
            sp1 = m;
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            p1.z = p0.z +(float).01; 
            mat.SetTrans(float(.5)*(p0+p1));
            d = p1-p0;

            ob->pblock->SetValue(PB_PS_WIDTH,0,float(fabs(d.x)));
            ob->pblock->SetValue(PB_PS_LENGTH,0,float(fabs(d.y)));
            ob->pblock->SetValue(PB_PS_HEIGHT,0,float(fabs(d.z)));
            ob->pmapParam->Invalidate();										
            
            if (msg==MOUSE_POINT && 
                (Length(sp1-sp0)<3 || Length(d)<0.1f)) {
                return CREATE_ABORT;
            }
            break;
        case 2:
            p1.z = vpt->SnapLength(vpt->GetCPDisp(p1,Point3(0,0,1),sp1,m));
            
            d = p1-p0;


            ob->pblock->SetValue(PB_PS_WIDTH,0,float(fabs(d.x)));
            ob->pblock->SetValue(PB_PS_LENGTH,0,float(fabs(d.y)));
            ob->pblock->SetValue(PB_PS_HEIGHT,0,float(fabs(d.z)));
            ob->pmapParam->Invalidate();				
            
            if (msg==MOUSE_POINT) {
                return CREATE_STOP;
            }
            break;
        }
    }
    else
	if (msg == MOUSE_ABORT) {		
            return CREATE_ABORT;
        }
    
    return TRUE;
}

// A single instance of the callback object.
static ProxSensorCreateCallBack ProxSensorCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
ProxSensorObject::GetCreateMouseCallBack() 
{
    ProxSensorCreateCB.SetObj(this);
    return(&ProxSensorCreateCB);
}

RefTargetHandle
ProxSensorObject::Clone(RemapDir& remap)
{
    ProxSensorObject* ts = new ProxSensorObject();
    ts->ReplaceReference(0, pblock->Clone(remap));
    ts->objects.SetCount(objects.Count());
    for(int i = 0; i < objects.Count(); i++)
        ts->ReplaceReference(i+1, objects[i]->node);
    
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\prox.h ===
/**********************************************************************
 *<
    FILE: prox.h
 
    DESCRIPTION:  Defines a VRML 2.0 ProximitySensor helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 5 Sept. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __ProxSensor__H__
 
#define __ProxSensor__H__
 
#define ProxSensor_CLASS_ID1 0x21fa3942
#define ProxSensor_CLASS_ID2 0xF002BD7D

#define ProxSensorClassID Class_ID(ProxSensor_CLASS_ID1, ProxSensor_CLASS_ID2)

extern ClassDesc* GetProxSensorDesc();

class ProxSensorCreateCallBack;
class ProxSensorObjPick;

class ProxSensorObj {
  public:
    INode *node;
    TSTR listStr;
    void ResetStr(void) {
        if (node)
            listStr.printf("%s", node->GetName());
        else listStr.printf("%s", _T("NO_NAME"));
    }
    ProxSensorObj(INode *n = NULL) {
        node = n;
        ResetStr();
    }
};

class ProxSensorObject: public HelperObject {			   
    friend class ProxSensorCreateCallBack;
    friend class ProxSensorObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(ProxSensorObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;
    BOOL needsScript;  // Do we need to generate a script node?

    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    Tab<ProxSensorObj*> objects;
    CommandMode *previousMode;

    static ICustButton *ProxSensorPickButton;
    IParamBlock *pblock;
    static IParamMap *pmapParam;

    ProxSensorObject();
    ~ProxSensorObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
           void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_PROX_SENSOR)); }


    Tab<ProxSensorObj*> GetObjects() { return objects; }

    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_PROX_SENSOR)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
           void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(ProxSensor_CLASS_ID1,
                                         ProxSensor_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_PROX_SENSOR_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return objects.Count() + 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);
//    IOResult Load(ILoad *iload) ;

};				

#define PB_PS_HEIGHT        0
#define PB_PS_WIDTH         1
#define PB_PS_LENGTH        2
#define PB_PS_ENABLED       3
#define PB_PS_NUMOBJS       4
#define PB_PS_PB_LENGTH     5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\TARGET.H ===
/**********************************************************************
 *<
	FILE: target.h

	DESCRIPTION:  Defines a Target Object Class

	CREATED BY: Dan Silva

	HISTORY: created 11 January 1995

 *>	Copyright (c) 1994, All Rights Reserved.
 **********************************************************************/

#ifndef __TARGET__H__ 

#define __TARGET__H__

class TargetObject: public GeomObject {			   
	friend class TargetObjectCreateCallBack;
	friend BOOL CALLBACK TargetParamDialogProc( HWND hDlg, UINT message, 
		WPARAM wParam, LPARAM lParam );
	
		// Mesh cache
		static HWND hSimpleCamParams;
		static IObjParam* iObjParams;		
		static Mesh mesh;		
		static int meshBuilt;

		void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
		void BuildMesh();

	//  inherited virtual methods for Reference-management
		RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
		   PartID& partID, RefMessage message );

	public:
		TargetObject();

		//  inherited virtual methods:

		// From BaseObject
		int HitTest(TimeValue t, INode* inode, int type, int crossing, int flags, IPoint2 *p, ViewExp *vpt);
		void Snap(TimeValue t, INode* inode, SnapInfo *snap, IPoint2 *p, ViewExp *vpt);
		int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
		CreateMouseCallBack* GetCreateMouseCallBack();
		void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
		void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
		TCHAR *GetObjectName() { return GetString(IDS_DB_TARGET); }

		// From Object
		ObjectState Eval(TimeValue time);
		void InitNodeName(TSTR& s) { s = GetString(IDS_DB_TARGET); }
		ObjectHandle ApplyTransform(Matrix3& matrix);
		int UsesWireColor() { return 0; }
		int IsRenderable() { return 0; }

		// From GeomObject
		int IntersectRay(TimeValue t, Ray& r, float& at);
		ObjectHandle CreateTriObjRep(TimeValue t);  // for rendering, also for deformation		
		void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
		void GetDeformBBox(TimeValue t, Box3& box, Matrix3 *tm, BOOL useSel );

		// Animatable methods
		void DeleteThis() { delete this; }
		Class_ID ClassID() { return Class_ID(TARGET_CLASS_ID,0); }  
		void GetClassName(TSTR& s) { s = TSTR(GetString(IDS_DB_TARGET)); }
		int IsKeyable(){ return 1;}
		LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
	            WPARAM wParam,   LPARAM lParam ){return(0);}

		// From ref.h
		RefTargetHandle Clone(RemapDir& remap = NoRemap());

		// IO
		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);
	};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\sound.h ===
/**********************************************************************
 *<
    FILE: sound.h
 
    DESCRIPTION:  Defines a VRML 2.0 Sound node helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 29 Feb. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __Sound__H__
 
#define __Sound__H__
 
#define Sound_CLASS_ID1 0xAC92442
#define Sound_CLASS_ID2 0xF83deAD

#define SoundClassID Class_ID(Sound_CLASS_ID1, Sound_CLASS_ID2)

extern ClassDesc* GetSoundDesc();

class SoundCreateCallBack;
class SoundObjPick;

class SoundObject: public HelperObject {			   
    friend class SoundCreateCallBack;
    friend class SoundObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(SoundObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;
    static ISpinnerControl *minBackSpin;
    static ISpinnerControl *maxBackSpin;
    static ISpinnerControl *minFrontSpin;
    static ISpinnerControl *maxFrontSpin;

    BOOL needsScript;  // Do we need to generate a script node?

    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    static IObjParam *iObjParams;

    INode *audioClip;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    CommandMode *previousMode;

    static ICustButton *SoundPickButton;
    IParamBlock *pblock;
    static IParamMap *pmapParam;

    SoundObject();
    ~SoundObject();
    void DrawEllipsoids(TimeValue t, INode* node, GraphicsWindow* gw);

    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
           void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_SOUND)); }


    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_SOUND)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Specific to sound object
	float GetMinBack(TimeValue t, Interval& valid = Interval(0,0));
	float GetMaxBack(TimeValue t, Interval& valid = Interval(0,0));
	float GetMinFront(TimeValue t, Interval& valid = Interval(0,0));
	float GetMaxFront(TimeValue t, Interval& valid = Interval(0,0));
    void SetMinBack(TimeValue t, float f);
    void SetMaxBack(TimeValue t, float f);
    void SetMinFront(TimeValue t, float f);
    void SetMaxFront(TimeValue t, float f);
    
    // Animatable methods
           void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(Sound_CLASS_ID1,
                                         Sound_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_SOUND_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return 2;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);

};				

#define PB_SND_SIZE       0
#define PB_SND_INTENSITY  1
#define PB_SND_MAX_BACK   2
#define PB_SND_MIN_BACK   3
#define PB_SND_MAX_FRONT  4
#define PB_SND_MIN_FRONT  5
#define PB_SND_PRIORITY   6
#define PB_SND_SPATIALIZE 7
#define PB_SND_LENGTH     8

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\sound.cpp ===
/**********************************************************************
 *<
    FILE: sound.cpp

    DESCRIPTION:  A VRML 2.0 Sound Helper object
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 29 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "sound.h"
#include "audio.h"

#define SEGMENTS 32

ISpinnerControl *SoundObject::minBackSpin;
ISpinnerControl *SoundObject::maxBackSpin;
ISpinnerControl *SoundObject::minFrontSpin;
ISpinnerControl *SoundObject::maxFrontSpin;

//------------------------------------------------------

class SoundClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new SoundObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_SOUND_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(Sound_CLASS_ID1,
                                                    Sound_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static SoundClassDesc SoundDesc;

ClassDesc* GetSoundDesc() { return &SoundDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ICustButton *SoundObject::SoundPickButton = NULL;

HWND SoundObject::hRollup = NULL;
int SoundObject::dlgPrevSel = -1;

class SoundObjPick : public PickModeCallback {
    SoundObject *sound;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetSound(SoundObject *l) { sound = l; }
};

//static SoundObjPick thePick;
static  SoundObjPick    thePick;
static  BOOL            pickMode    = FALSE;
static  CommandMode*    lastMode    = NULL;

static void
SetPickMode(SoundObject* o) {
    if (pickMode) {
        pickMode = FALSE;
        GetCOREInterface()->PushCommandMode(lastMode);
        lastMode = NULL;
        GetCOREInterface()->ClearPickMode();
    } else {
        pickMode = TRUE;
        lastMode = GetCOREInterface()->GetCommandMode();
        thePick.SetSound(o);
        GetCOREInterface()->SetPickMode(&thePick);
    }
}

BOOL
SoundObjPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    return obj->ClassID() == AudioClipClassID;
}

void
SoundObjPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(_T(GetString(IDS_PICK_AUDIOCLIP)));
}

void
SoundObjPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
SoundObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        RefResult ret = sound->MakeRefByID(FOREVER, 1, node);

        SetPickMode(NULL);
     // sound->iObjParams->SetCommandMode(sound->previousMode);
     // sound->previousMode = NULL;
        sound->SoundPickButton->SetCheck(FALSE);
        HWND hw = sound->hRollup;
        Static_SetText(GetDlgItem(hw,IDC_NAME), sound->audioClip->GetName());
        return FALSE;
    }
    return FALSE;
}


HCURSOR
SoundObjPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

#define RELEASE_SPIN(x)   if (th->x) { ReleaseISpinner(th->x); th->x = NULL;}
#define RELEASE_BUT(x)   if (th->x) { ReleaseICustButton(th->x); th->x = NULL;}

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  SoundObject* th)
{
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG:
        {
        float minF, minB, maxF, maxB;
        TimeValue t = 0;

        th->SoundPickButton = GetICustButton(GetDlgItem(hDlg,
                                                  IDC_AUDIO_CLIP_PICK));
        th->SoundPickButton->SetType(CBT_CHECK);
        th->SoundPickButton->SetButtonDownNotify(TRUE);
        th->SoundPickButton->SetHighlightColor(GREEN_WASH);
        th->SoundPickButton->SetCheck(FALSE);

        th->pblock->GetValue(PB_SND_MIN_FRONT, t, minF, FOREVER);
        th->pblock->GetValue(PB_SND_MIN_BACK, t, minB, FOREVER);
        th->pblock->GetValue(PB_SND_MAX_FRONT, t, maxF, FOREVER);
        th->pblock->GetValue(PB_SND_MAX_BACK, t, maxB, FOREVER);
/*
        th->minBackSpin->SetValue(minB, FALSE);
        th->maxBackSpin->SetValue(maxB, FALSE);
        th->minFrontSpin->SetValue(minF, FALSE);
        th->maxFrontSpin->SetValue(maxF, FALSE);
*/

        // Now we need to fill in the list box IDC_Sound_LIST
        th->hRollup = hDlg;

        if (th->audioClip)
            Static_SetText(GetDlgItem(hDlg,IDC_NAME),
                           th->audioClip->GetName());

        if (pickMode) SetPickMode(th);

        return TRUE;			
        }
    case WM_DESTROY:
        if (pickMode) SetPickMode(th);
     // th->iObjParams->ClearPickMode();
     // th->previousMode = NULL;
		RELEASE_SPIN(minBackSpin);
		RELEASE_SPIN(maxBackSpin);
		RELEASE_SPIN(minFrontSpin);
		RELEASE_SPIN(maxFrontSpin);

        RELEASE_BUT(SoundPickButton);
        return FALSE;

	case CC_SPINNER_BUTTONDOWN:
        {
        int id = LOWORD(wParam);
        switch ( id ) {
        case IDC_MIN_BACK_SPIN:
        case IDC_MAX_BACK_SPIN:
        case IDC_MIN_FRONT_SPIN:
        case IDC_MAX_FRONT_SPIN:
    		theHold.Begin();
		    return TRUE;
        default:
            return FALSE;
        } }
        break;

	case WM_CUSTEDIT_ENTER:
	case CC_SPINNER_BUTTONUP:
        {
        int id = LOWORD(wParam);
        switch ( id ) {
        case IDC_MIN_BACK_SPIN:
        case IDC_MAX_BACK_SPIN:
        case IDC_MIN_FRONT_SPIN:
        case IDC_MAX_FRONT_SPIN:
		    if (HIWORD(wParam) || message==WM_CUSTEDIT_ENTER) 
			    theHold.Accept(GetString(IDS_DS_PARAMCHG));
		    else 
			    theHold.Cancel();
    		return TRUE;
        default:
            return FALSE;
        } }

    case CC_SPINNER_CHANGE:
        {
        float minB, maxB, minF, maxF;
        int id = LOWORD(wParam);
	    TimeValue t = 0;    // not really needed...yet

        switch ( id ) {
        case IDC_MIN_BACK_SPIN:
        case IDC_MAX_BACK_SPIN:
        case IDC_MIN_FRONT_SPIN:
        case IDC_MAX_FRONT_SPIN:
            if (!theHold.Holding()) theHold.Begin();
            minB = th->minBackSpin->GetFVal();
            maxB = th->maxBackSpin->GetFVal();
            minF = th->minFrontSpin->GetFVal();
            maxF = th->maxFrontSpin->GetFVal();

            if (minB > minF) {
                if (id == IDC_MIN_BACK_SPIN)
                    minF = minB;
                else if (id == IDC_MIN_FRONT_SPIN)
                    minB = minF;
            }
            if (maxB > maxF) {
                if (id == IDC_MAX_BACK_SPIN)
                    maxF = maxB;
                else if (id == IDC_MAX_FRONT_SPIN)
                    maxB = maxF;
            }
            if (minB > maxB) {
                if (id == IDC_MIN_BACK_SPIN)
                    maxB = minB;
                else
                    minB = maxB;
            }
            if (minF > maxF) {
                if (id == IDC_MIN_FRONT_SPIN)
                    maxF = minF;
                else
                    minF = maxF;
            }

            th->minBackSpin->SetValue(minB, FALSE);
            th->maxBackSpin->SetValue(maxB, FALSE);
            th->minFrontSpin->SetValue(minF, FALSE);
            th->maxFrontSpin->SetValue(maxF, FALSE);
            th->SetMinBack(t, minB);
            th->SetMaxBack(t, maxB);
            th->SetMinFront(t, minF);
            th->SetMaxFront(t, maxF);

            return TRUE;
        default:
            return FALSE;
        }
        }

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_AUDIO_CLIP_PICK: // Pick an object from the scene
            // Set the pickmode...
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                SetPickMode(th);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    thePick.SetSound(th);
                    th->iObjParams->SetPickMode(&thePick);
                }
                */
                return TRUE;
                break;
            }
            break;
        }
        return FALSE;
    default:
        return FALSE;
    }
}

static ParamUIDesc descParam[] = {
  // Intensity
  ParamUIDesc(
              PB_SND_INTENSITY,
              EDITTYPE_UNIVERSE,
              IDC_INTENSITY_EDIT, IDC_INTENSITY_SPIN,
              0.0f, 1.0f,
              0.1f),	

  // Priority
  ParamUIDesc(
              PB_SND_PRIORITY,
              EDITTYPE_UNIVERSE,
              IDC_PRIORITY_EDIT, IDC_PRIORITY_SPIN,
              0.0f, 1.0f,
              0.1f),	

  // Spatialize
  ParamUIDesc(PB_SND_SPATIALIZE, TYPE_SINGLECHEKBOX, IDC_SPATIALIZE),

  // Min Back
  ParamUIDesc(
              PB_SND_MIN_BACK,
              EDITTYPE_UNIVERSE,
              IDC_MIN_BACK_EDIT, IDC_MIN_BACK_SPIN,
              0.0f, 10000.0f,
              SPIN_AUTOSCALE),	

  // Max Back
  ParamUIDesc(
              PB_SND_MAX_BACK,
              EDITTYPE_UNIVERSE,
              IDC_MAX_BACK_EDIT, IDC_MAX_BACK_SPIN,
              0.0f, 10000.0f,
              SPIN_AUTOSCALE),	

  // Min Front
  ParamUIDesc(
              PB_SND_MIN_FRONT,
              EDITTYPE_UNIVERSE,
              IDC_MIN_FRONT_EDIT, IDC_MIN_FRONT_SPIN,
              0.0f, 10000.0f,
              SPIN_AUTOSCALE),	

  // Max Front
  ParamUIDesc(
              PB_SND_MAX_FRONT,
              EDITTYPE_UNIVERSE,
              IDC_MAX_FRONT_EDIT, IDC_MAX_FRONT_SPIN,
              0.0f, 10000.0f,
              SPIN_AUTOSCALE),

  // Icon Size
  ParamUIDesc(
              PB_SND_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_ICON_EDIT, IDC_ICON_SPIN,
              0.0f, 10000.0f,
              SPIN_AUTOSCALE),	

};

  

#define PARAMDESC_LENGTH 8

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_FLOAT, NULL, FALSE, 1 },
  { TYPE_FLOAT, NULL, FALSE, 2 },
  { TYPE_FLOAT, NULL, FALSE, 3 },
  { TYPE_FLOAT, NULL, FALSE, 4 },
  { TYPE_FLOAT, NULL, FALSE, 5 },
  { TYPE_FLOAT, NULL, FALSE, 6 },
  { TYPE_INT, NULL, FALSE, 7 },
};

#define CURRENT_VERSION	0

class SoundParamDlgProc : public ParamMapUserDlgProc {
public:
  SoundObject *ob;

  SoundParamDlgProc(SoundObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL SoundParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *SoundObject::pmapParam = NULL;

float SoundObject::GetMinBack(TimeValue t, Interval& valid)
{
	Interval iv;

	float f, g;
	pblock->GetValue( PB_SND_MIN_BACK, t, f, valid );
	pblock->GetValue( PB_SND_MAX_BACK, t, g, valid );
	if(g < f )
		return g;
	return f;
}

float SoundObject::GetMaxBack(TimeValue t, Interval& valid)
{
	Interval iv;

	float f, g;
	pblock->GetValue( PB_SND_MAX_BACK, t, f, valid );
	pblock->GetValue( PB_SND_MIN_BACK, t, g, valid );
	if(g > f )
		return g;
	return f;
}

float SoundObject::GetMinFront(TimeValue t, Interval& valid)
{
	Interval iv;

	float f, g;
	pblock->GetValue( PB_SND_MIN_FRONT, t, f, valid );
	pblock->GetValue( PB_SND_MAX_FRONT, t, g, valid );
	if(g < f )
		return g;
	return f;
}

float SoundObject::GetMaxFront(TimeValue t, Interval& valid)
{
	Interval iv;

	float f, g;
	pblock->GetValue( PB_SND_MAX_FRONT, t, f, valid );
	pblock->GetValue( PB_SND_MIN_FRONT, t, g, valid );
	if(g > f )
		return g;
	return f;
}

void SoundObject::SetMinBack(TimeValue t, float f)
{
	pblock->SetValue( PB_SND_MIN_BACK, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SoundObject::SetMaxBack(TimeValue t, float f)
{
	pblock->SetValue( PB_SND_MAX_BACK, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SoundObject::SetMinFront(TimeValue t, float f)
{
	pblock->SetValue( PB_SND_MIN_FRONT, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void SoundObject::SetMaxFront(TimeValue t, float f)
{
	pblock->SetValue( PB_SND_MAX_FRONT, t, f );
	NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
}

void
SoundObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                   Animatable *prev )
{
    iObjParams = ip;
	TimeValue t = ip->GetTime();    // not really needed...yet

  if (pmapParam) {
		
    // Left over from last Sound created		
    pmapParam->SetParamBlock(pblock);
  } else {

    // Gotta make a new one.
    pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                 pblock,
                                 ip,
                                 hInstance,
                                 MAKEINTRESOURCE(IDD_SOUND),
                                 _T("Sound"),
                                 0);
  }

  if (pmapParam) {
    // A callback for dialog
    pmapParam->SetUserDlgProc(new SoundParamDlgProc(this));
  }

    minBackSpin = GetISpinner( GetDlgItem(hRollup, IDC_MIN_BACK_SPIN) );
    maxBackSpin = GetISpinner( GetDlgItem(hRollup, IDC_MAX_BACK_SPIN) );
    minFrontSpin = GetISpinner( GetDlgItem(hRollup, IDC_MIN_FRONT_SPIN) );
    maxFrontSpin = GetISpinner( GetDlgItem(hRollup, IDC_MAX_FRONT_SPIN) );

	minBackSpin->SetLimits(0.0f, 10000.0f, FALSE);
	minBackSpin->SetValue(GetMinBack(t),FALSE);
	minBackSpin->SetScale(1.0f);
	minBackSpin->LinkToEdit( GetDlgItem(hRollup, IDC_MIN_BACK_EDIT), EDITTYPE_UNIVERSE );
	maxBackSpin->SetLimits(0.0f, 10000.0f, FALSE);
	maxBackSpin->SetValue(GetMaxBack(t),FALSE);
	maxBackSpin->SetScale(1.0f);
	maxBackSpin->LinkToEdit( GetDlgItem(hRollup, IDC_MAX_BACK_EDIT), EDITTYPE_UNIVERSE );
	minFrontSpin->SetLimits(0.0f, 10000.0f, FALSE);
	minFrontSpin->SetValue(GetMinFront(t),FALSE);
	minFrontSpin->SetScale(1.0f);
	minFrontSpin->LinkToEdit( GetDlgItem(hRollup, IDC_MIN_FRONT_EDIT), EDITTYPE_UNIVERSE );
	maxFrontSpin->SetLimits(0.0f, 10000.0f, FALSE);
	maxFrontSpin->SetValue(GetMaxFront(t),FALSE);
	maxFrontSpin->SetScale(1.0f);
	maxFrontSpin->LinkToEdit( GetDlgItem(hRollup, IDC_MAX_FRONT_EDIT), EDITTYPE_UNIVERSE );
}
		
void
SoundObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
}

SoundObject::SoundObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_SND_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_SND_SIZE, 0, 0.0f);
    pb->SetValue(PB_SND_SPATIALIZE, 0, TRUE);
    pb->SetValue(PB_SND_MAX_BACK, 0, 10.0f);
    pb->SetValue(PB_SND_MIN_BACK, 0, 1.0f);
    pb->SetValue(PB_SND_MAX_FRONT, 0, 10.0f);
    pb->SetValue(PB_SND_MIN_FRONT, 0, 1.0f);
    pb->SetValue(PB_SND_PRIORITY, 0, 0.0f);
    pb->SetValue(PB_SND_INTENSITY, 0, 1.0f);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    previousMode = NULL;
    audioClip = NULL;
}

SoundObject::~SoundObject()
{
    DeleteAllRefsFromMe();
}

IObjParam *SoundObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
SoundObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
    // FIXME handle these messages
    switch (message) {
    case REFMSG_TARGET_DELETED:
        if (hTarget == (RefTargetHandle) audioClip)
            audioClip = NULL;
        break;
    case REFMSG_NODE_NAMECHANGE: 
        if (hTarget == (RefTargetHandle) audioClip && hRollup)
            Static_SetText(GetDlgItem(hRollup,IDC_NAME),
                           audioClip->GetName());
        break;
    }
    return REF_SUCCEED;
}

RefTargetHandle
SoundObject::GetReference(int ind)
{
    if (ind == 0)
        return pblock;
    if (ind == 1)
        return audioClip;

    return NULL;
}

void
SoundObject::SetReference(int ind, RefTargetHandle rtarg)
{
    if (ind == 0) {
        pblock = (IParamBlock*) rtarg;
    } else if (ind == 1)
        audioClip = (INode*) rtarg;
}

ObjectState
SoundObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
SoundObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
SoundObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
GetEllipsePoints(float front, float back, Point3* ellipse)
{
    float a = (back + front)/2.0f;
    float c = (front - back)/2.0f;
    float b = (float) sqrt(a*a - c*c);
    int i;
    float delTheta = (2  * PI) / float(SEGMENTS);
    float theta;
    for(i = 0, theta = 0.0f; i < SEGMENTS; i++, theta += delTheta) {
        ellipse[i].x = b*float(cos(theta));
        ellipse[i].y = -(a*float(sin(theta)) + c);
        ellipse[i].z = 0.0f;
    }
    for(i = 0; i < SEGMENTS; i++) {
        ellipse[SEGMENTS+i].x = ellipse[i].z;
        ellipse[SEGMENTS+i].y = ellipse[i].y;
        ellipse[SEGMENTS+i].z = ellipse[i].x;
    }
}

void
SoundObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    BuildMesh(t);
    box = mesh.getBoundingBox();
    if (inode->Selected()) {
        float minFront, minBack, maxFront, maxBack;
        pblock->GetValue(PB_SND_MIN_FRONT, t, minFront, FOREVER);
        pblock->GetValue(PB_SND_MIN_BACK, t, minBack, FOREVER);
        pblock->GetValue(PB_SND_MAX_FRONT, t, maxFront, FOREVER);
        pblock->GetValue(PB_SND_MAX_BACK, t, maxBack, FOREVER);

        Point3 ellipse[2*SEGMENTS];
        GetEllipsePoints(minFront, minBack, ellipse);
        int i;
        for(i = 0; i < 2*SEGMENTS; i++) {
            box += ellipse[i];
        }
        GetEllipsePoints(maxFront, maxBack, ellipse);
        for(i = 0; i < 2*SEGMENTS; i++) {
            box += ellipse[i];
        }
    }
}

void
SoundObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    GetLocalBoundBox(t, inode, vpt, box);
    box = box * tm;
//    for (int i=0; i<nv; i++) 
//        box += tm*mesh.getVert(i);
}


void
SoundObject::BuildMesh(TimeValue t)
{
    float length;
    pblock->GetValue(PB_SND_SIZE, t, length, FOREVER);
    mesh.setNumVerts(11);
    mesh.setNumFaces(5);
    mesh.setVert(0, Point3(-length, 0.0f, length));
    mesh.setVert(1, Point3( length, 0.0f, length));
    mesh.setVert(2, Point3( length, 0.0f, -length));
    mesh.setVert(3, Point3(-length, 0.0f, -length));
    mesh.setVert(4, Point3(   0.0f, 0.0f,   0.0f));
    mesh.setVert(5, Point3(   0.0f, -3*length,   0.0f));
    mesh.setVert(6, Point3(   0.0f, 0.0f,   0.0f));
    length *= 0.3f;
    mesh.setVert(7, Point3(-length, -7.0f*length, length));
    mesh.setVert(8, Point3( length, -7.0f*length, length));
    mesh.setVert(9, Point3( length, -7.0f*length, -length));
    mesh.setVert(10, Point3(-length,-7.0f*length, -length));
    
    mesh.faces[0].setEdgeVisFlags(1,0,1);
    mesh.faces[0].setSmGroup(1);
    mesh.faces[0].setVerts(0,1,3);
    
    mesh.faces[1].setEdgeVisFlags(1,1,0);
    mesh.faces[1].setSmGroup(1);
    mesh.faces[1].setVerts(1,2,3);
    
    mesh.faces[2].setEdgeVisFlags(1,1,0);
    mesh.faces[2].setSmGroup(1);
    mesh.faces[2].setVerts(4,5,6);
    
    mesh.faces[3].setEdgeVisFlags(0,1,1);
    mesh.faces[3].setSmGroup(1);
    mesh.faces[3].setVerts(7,9,5);
    
    mesh.faces[4].setEdgeVisFlags(0,1,1);
    mesh.faces[4].setSmGroup(1);
    mesh.faces[4].setVerts(10,8,5);

    mesh.InvalidateGeomCache();
    mesh.EnableEdgeList(1);
}

void
SoundObject::DrawEllipsoids(TimeValue t, INode* inode, GraphicsWindow* gw)
{
    Matrix3 tm = inode->GetObjectTM(t);
    gw->setTransform(tm);
    float minFront, minBack, maxFront, maxBack;
    pblock->GetValue(PB_SND_MIN_FRONT, t, minFront, FOREVER);
    pblock->GetValue(PB_SND_MIN_BACK, t, minBack, FOREVER);
    pblock->GetValue(PB_SND_MAX_FRONT, t, maxFront, FOREVER);
    pblock->GetValue(PB_SND_MAX_BACK, t, maxBack, FOREVER);

    Point3 ellipse[2*SEGMENTS+1];

    // Draw the Min ellipsoid in Blue
    gw->setColor( LINE_COLOR, 0.0f, 0.0f, 1.0f);
    GetEllipsePoints(minFront, minBack, ellipse);
    gw->polyline(SEGMENTS, ellipse, NULL, NULL, TRUE, NULL);
    gw->polyline(SEGMENTS, ellipse+SEGMENTS, NULL, NULL, TRUE, NULL);

    // Draw the Max ellipsoid in Red
    gw->setColor( LINE_COLOR, 1.0f, 0.0f, 0.0f);
    GetEllipsePoints(maxFront, maxBack, ellipse);
    gw->polyline(SEGMENTS, ellipse, NULL, NULL, TRUE, NULL);
    gw->polyline(SEGMENTS, ellipse+SEGMENTS, NULL, NULL, TRUE, NULL);
}

int
SoundObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_SND_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.5f, 0.3f, 1.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    if (inode->Selected()) {
        DrawEllipsoids(t, inode, gw);
    }

    gw->setRndLimits(rlim);
    return(0);
}

int
SoundObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class SoundCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    SoundObject *soundObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(SoundObject *obj) {soundObject = obj;}

};

			
int
SoundCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            soundObject->pblock->SetValue(PB_SND_SIZE,
                                               soundObject->
                                               iObjParams->GetTime(), radius);
            soundObject->pmapParam->Invalidate();										
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(soundObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static SoundCreateCallBack SoundCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
SoundObject::GetCreateMouseCallBack() 
{
    SoundCreateCB.SetObj(this);
    return(&SoundCreateCB);
}

RefTargetHandle
SoundObject::Clone(RemapDir& remap)
{
    SoundObject* ts = new SoundObject();
    ts->ReplaceReference(0, pblock->Clone(remap));
    if (audioClip)
        ts->ReplaceReference(1, audioClip);
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\timer.h ===
/**********************************************************************
 *<
    FILE: timer.h
 
    DESCRIPTION:  Defines a VRML 2.0 TimeSensor helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 29 Aug. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __TimeSensor__H__
 
#define __TimeSensor__H__
 
#define TimeSensor_CLASS_ID1 0xACAD3442
#define TimeSensor_CLASS_ID2 0xF00BAD

#define TimeSensorClassID Class_ID(TimeSensor_CLASS_ID1, TimeSensor_CLASS_ID2)

extern ClassDesc* GetTimeSensorDesc();

class TimeSensorCreateCallBack;
class TimeSensorObjPick;

class TimeSensorObj {
  public:
    INode *node;
    TSTR listStr;
    void ResetStr(void) {
        if (node)
            listStr.printf("%s", node->GetName());
        else listStr.printf("%s", _T("NO_NAME"));
    }
    TimeSensorObj(INode *n = NULL) {
        node = n;
        ResetStr();
    }
};

class TimeSensorObject: public HelperObject {			   
    friend class TimeSensorCreateCallBack;
    friend class TimeSensorObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(TimeSensorObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;
    BOOL needsScript;  // Do we need to generate a script node?

    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    Tab<TimeSensorObj*> TimeSensorObjects;
    CommandMode *previousMode;

    static ICustButton *TimeSensorPickButton;
    IParamBlock *pblock;
    static IParamMap *pmapParam;

    TimeSensorObject();
    ~TimeSensorObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
           void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_TIME_SENSOR)); }


    Tab<TimeSensorObj*> GetTimeSensorObjects() { return TimeSensorObjects; }

    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_TIME_SENSOR)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
           void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(TimeSensor_CLASS_ID1,
                                         TimeSensor_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_TIME_SENSOR_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return TimeSensorObjects.Count() + 1;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);
    IOResult Load(ILoad *iload) ;

};				

#define PB_SIZE          0
#define PB_LOOP          1
#define PB_START_TIME    2
#define PB_STOP_TIME     3
#define PB_NUMOBJS       4
#define PB_START_ON_LOAD 5
#define PB_LENGTH        6

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\timer.cpp ===
/**********************************************************************
 *<
    FILE: timer.cpp

    DESCRIPTION:  A VRML Time Sensor Helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 15 Aug, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "timer.h"

//------------------------------------------------------

class TimeSensorClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new TimeSensorObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_TIME_SENSOR_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(TimeSensor_CLASS_ID1,
                                                    TimeSensor_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static TimeSensorClassDesc TimeSensorDesc;

ClassDesc* GetTimeSensorDesc() { return &TimeSensorDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ICustButton *TimeSensorObject::TimeSensorPickButton = NULL;

HWND TimeSensorObject::hRollup = NULL;
int TimeSensorObject::dlgPrevSel = -1;

class TimeSensorObjPick : public PickModeCallback {
    TimeSensorObject *timeSensor;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetTimeSensor(TimeSensorObject *l) { timeSensor = l; }
};

static  TimeSensorObjPick   thePick;
static  BOOL                pickMode    = FALSE;
static  CommandMode*        lastMode    = NULL;

static void
SetPickMode(TimeSensorObject* tso) {
    if (pickMode) {
        pickMode = FALSE;
        GetCOREInterface()->PushCommandMode(lastMode);
        lastMode = NULL;
        GetCOREInterface()->ClearPickMode();
    } else {
        pickMode = TRUE;
        lastMode = GetCOREInterface()->GetCommandMode();
        thePick.SetTimeSensor(tso);
        GetCOREInterface()->SetPickMode(&thePick);
    }
}

BOOL
TimeSensorObjPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(TimeSensor_CLASS_ID1, TimeSensor_CLASS_ID2)))
        return FALSE;
    return TRUE;
}

void
TimeSensorObjPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(GetString(IDS_TimeSensor_PICK_MODE));
}

void
TimeSensorObjPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
TimeSensorObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        // Check to see if we have a reference to this object already
        for (int i = 0; i < timeSensor->TimeSensorObjects.Count(); i++) {
            if (timeSensor->TimeSensorObjects[i]->node == node)
                return FALSE; // Can't click those we already have
        }

        TimeSensorObj *obj = new TimeSensorObj(node);
        int id = timeSensor->TimeSensorObjects.Append(1, &obj);
        timeSensor->pblock->SetValue(PB_NUMOBJS,
                                     timeSensor->iObjParams->GetTime(),
                                     timeSensor->TimeSensorObjects.Count());

        RefResult ret = timeSensor->MakeRefByID(FOREVER, id+1, node);

        HWND hw = timeSensor->hRollup;
        int ind = SendMessage(GetDlgItem(hw,IDC_TimeSensor_LIST),
                              LB_ADDSTRING, 0, (LPARAM)obj->listStr.data());
        SendMessage(GetDlgItem(hw,IDC_TimeSensor_LIST),
                    LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        EnableWindow(GetDlgItem(hw, IDC_TimeSensor_DEL),
                     timeSensor->TimeSensorObjects.Count() > 0);
    }
    return FALSE;
}


HCURSOR
TimeSensorObjPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

void
BuildObjectList(TimeSensorObject *ob)
{
    if (ob && ob->hRollup) {
        int count, i;

        count = SendDlgItemMessage(ob->hRollup, IDC_TimeSensor_LIST,
                                   LB_GETCOUNT, 0, 0);

        // First remove any objects on the list
        for (i = count - 1; i >= 0; i--)
            SendDlgItemMessage(ob->hRollup, IDC_TimeSensor_LIST,
                               LB_DELETESTRING, (WPARAM) i, 0);

        for (i = 0; i < ob->TimeSensorObjects.Count(); i++) {
            TimeSensorObj *obj = ob->TimeSensorObjects[i];
            obj->ResetStr(); // Make sure we're up to date

            // for now just load the name, we might want to add 
            // the frame range as some point
            int ind = SendMessage(GetDlgItem(ob->hRollup,IDC_TimeSensor_LIST),
                                  LB_ADDSTRING, 0,
                                  (LPARAM)obj->listStr.data());
            SendMessage(GetDlgItem(ob->hRollup,IDC_TimeSensor_LIST),
                        LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        }
    }
}

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  TimeSensorObject* th)
{
	int loop = FALSE;  // used to test for IDC_LOOP

    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG:
//        SetDlgFont( hDlg, th->iObjParams->GetAppHFont() );

        th->TimeSensorPickButton = GetICustButton(GetDlgItem(hDlg,IDC_TimeSensor_PICK));
        th->TimeSensorPickButton->SetType(CBT_CHECK);
        th->TimeSensorPickButton->SetButtonDownNotify(TRUE);
        th->TimeSensorPickButton->SetHighlightColor(GREEN_WASH);
        th->TimeSensorPickButton->SetCheck(FALSE);
		
		// only enable IDC_START_ON_LOAD if IDC_LOOP is checked
		th->pblock->GetValue(PB_LOOP, th->iObjParams->GetTime(), loop, FOREVER);
	    EnableWindow(GetDlgItem(hDlg, IDC_START_ON_LOAD), loop);

        // Now we need to fill in the list box IDC_TimeSensor_LIST
        th->hRollup = hDlg;
        BuildObjectList(th);

//        EnableWindow(GetDlgItem(hDlg, IDC_TimeSensor_DEL),
//                     (th->TimeSensorObjects.Count() > 0));
        th->dlgPrevSel = -1;

        if (pickMode) SetPickMode(th);
                
        return TRUE;			

    case WM_DESTROY:
        if (pickMode) SetPickMode(th);
        //th->iObjParams->ClearPickMode();
        //th->previousMode = NULL;
        ReleaseICustButton( th->TimeSensorPickButton );
        return FALSE;

    case WM_MOUSEACTIVATE:
//        th->iObjParams->RealizeParamPanel();
        return FALSE;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
//        th->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
        return FALSE;

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
		case IDC_LOOP:	// only enable IDC_START_ON_LOAD if IDC_LOOP is checked
			if (!IsDlgButtonChecked( hDlg, IDC_LOOP)) {
				CheckDlgButton(hDlg, IDC_START_ON_LOAD, 0);
                th->pblock->SetValue(PB_START_ON_LOAD,th->iObjParams->GetTime(),FALSE);
			}
			EnableWindow(GetDlgItem(hDlg, IDC_START_ON_LOAD), IsDlgButtonChecked( hDlg, IDC_LOOP));
        break;
		case IDC_TimeSensor_PICK: // Pick an object from the scene
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                SetPickMode(th);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    thePick.SetTimeSensor(th);
                    th->iObjParams->SetPickMode(&thePick);
                }
                */
                break;
            }
            break;
        case IDC_TimeSensor_DEL: { // Delete the object from the list
            int index =	SendMessage(GetDlgItem(hDlg,IDC_TimeSensor_LIST),
                                    LB_GETCURSEL, 0, 0);
            if (index != LB_ERR) {
                TimeSensorObj *obj = (TimeSensorObj *)
                    SendDlgItemMessage(hDlg, IDC_TimeSensor_LIST,
                                       LB_GETITEMDATA, index, 0);
                for (int i = 0; i < th->TimeSensorObjects.Count(); i++) {
                    if (obj == th->TimeSensorObjects[i]) {
                        // remove the item from the list
                        SendDlgItemMessage(hDlg, IDC_TimeSensor_LIST,
                                           LB_DELETESTRING,
                                           (WPARAM) index, 0);
                        th->dlgPrevSel = -1;
                        // remove the object from the table
                        th->DeleteReference(i+1);
                        th->TimeSensorObjects.Delete(i, 1);
                        th->pblock->SetValue(PB_NUMOBJS,
                                             th->iObjParams->GetTime(),
                                             th->TimeSensorObjects.Count());
                        break;
                    }
                }
                EnableWindow(GetDlgItem(hDlg, IDC_TimeSensor_DEL),
                             (th->TimeSensorObjects.Count() > 0));
                if (th->TimeSensorObjects.Count() <= 0) {
                    th->iObjParams->RedrawViews(th->iObjParams->GetTime());
                }
            }
        }
        break;
        case IDC_TimeSensor_LIST:
            switch(HIWORD(wParam)) {
            case LBN_SELCHANGE: {
                int sel = SendMessage(GetDlgItem(hDlg,IDC_TimeSensor_LIST),
                                      LB_GETCURSEL, 0, 0);
                if (th->dlgPrevSel != -1) {
                    // save any editing
                    TimeSensorObj *obj = (TimeSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_TimeSensor_LIST,
                                           LB_GETITEMDATA, th->dlgPrevSel, 0);
                    obj->ResetStr();
                    SendMessage(GetDlgItem(hDlg,IDC_TimeSensor_LIST),
                                LB_DELETESTRING, th->dlgPrevSel, 0);
                    int ind = SendMessage(GetDlgItem(hDlg,
                                                     IDC_TimeSensor_LIST),
                                          LB_ADDSTRING, 0,
                                          (LPARAM)obj->listStr.data());
                    SendMessage(GetDlgItem(hDlg,IDC_TimeSensor_LIST),
                                LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
                    SendMessage(GetDlgItem(hDlg,IDC_TimeSensor_LIST),
                                LB_SETCURSEL, sel, 0);
                }
                th->dlgPrevSel = sel;
                if (sel >= 0) {
                    TimeSensorObj *obj = (TimeSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_TimeSensor_LIST,
                                           LB_GETITEMDATA, sel, 0);
                    assert(obj);

                } else {
                }
                th->iObjParams->RedrawViews(th->iObjParams->GetTime());
            }
            break;
            case LBN_SELCANCEL:
                break;
            }
            break;
		}
		return FALSE;
    default:
        return FALSE;
    }
}

static ParamUIDesc descParam[] = {
  // Size
  ParamUIDesc(
              PB_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_TimeSensor_SIZE, IDC_TimeSensor_SIZE_SPINNER,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Loop
  ParamUIDesc(PB_LOOP, TYPE_SINGLECHEKBOX, IDC_LOOP),

  // Start On Load
  ParamUIDesc(PB_START_ON_LOAD, TYPE_SINGLECHEKBOX, IDC_START_ON_LOAD),

  // Start Time
  ParamUIDesc(
              PB_START_TIME,
              EDITTYPE_TIME,
              IDC_START_EDIT, IDC_START_SPIN,
              -999999999.0f,999999999.0f,
              10.0f),

  // Stop Time
  ParamUIDesc(
              PB_STOP_TIME,
              EDITTYPE_TIME,
              IDC_STOP_EDIT, IDC_STOP_SPIN,
              -999999999.0f,999999999.0f,
              10.0f),
};

  

#define PARAMDESC_LENGTH 5

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
  { TYPE_INT, NULL, FALSE, 2 },
  { TYPE_INT, NULL, FALSE, 3 },
  { TYPE_INT, NULL, FALSE, 4 }
};

static ParamBlockDescID descVer1[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
  { TYPE_INT, NULL, FALSE, 2 },
  { TYPE_INT, NULL, FALSE, 3 },
  { TYPE_INT, NULL, FALSE, 4 },
  { TYPE_INT, NULL, FALSE, 5 },
};

static ParamVersionDesc versions[] = {
  ParamVersionDesc(descVer0,5,0),
};

#define NUM_OLD_VERSIONS 1

#define CURRENT_VERSION	1
// Current version
static ParamVersionDesc curVersion(descVer1, PB_LENGTH, CURRENT_VERSION);

class TimeSensorParamDlgProc : public ParamMapUserDlgProc {
public:
  TimeSensorObject *ob;

  TimeSensorParamDlgProc(TimeSensorObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL TimeSensorParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *TimeSensorObject::pmapParam = NULL;

IOResult
TimeSensorObject::Load(ILoad *iload) 
{
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(versions,
                                                     NUM_OLD_VERSIONS,
                                                     &curVersion,this,0));
  return IO_OK;
}

void
TimeSensorObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                   Animatable *prev )
{
    iObjParams = ip;

  if (pmapParam) {
		
    // Left over from last TimeSensor created		
    pmapParam->SetParamBlock(pblock);
  } else {

    // Gotta make a new one.
    pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                 pblock,
                                 ip,
                                 hInstance,
                                 MAKEINTRESOURCE(IDD_TimeSensor),
                                 _T("Time Sensor"),
                                 0);
  }

  if (pmapParam) {
    // A callback for dialog
    pmapParam->SetUserDlgProc(new TimeSensorParamDlgProc(this));
  }
}
		
void
TimeSensorObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
//    iObjParams = NULL;
}

TimeSensorObject::TimeSensorObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer1, PB_LENGTH,
                                           CURRENT_VERSION);
    TimeValue start = TheManager->Max()->GetAnimRange().Start();
    TimeValue end   = TheManager->Max()->GetAnimRange().End();
    pb->SetValue(PB_SIZE, 0, 0.0f);
    pb->SetValue(PB_LOOP, 0, FALSE);
    pb->SetValue(PB_START_ON_LOAD, 0, FALSE);
    pb->SetValue(PB_START_TIME, 0, start);
    pb->SetValue(PB_STOP_TIME, 0, end);
    pb->SetValue(PB_NUMOBJS, 0, 0);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    previousMode = NULL;
    TimeSensorObjects.SetCount(0);
    BuildObjectList(this);
    
}

TimeSensorObject::~TimeSensorObject()
{
    DeleteAllRefsFromMe();
    for (int i = 0; i < TimeSensorObjects.Count(); i++) {
        TimeSensorObj *obj = TimeSensorObjects[i];
        delete obj;
    }
}

IObjParam *TimeSensorObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
TimeSensorObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
    int i;
    switch (message) {
    case REFMSG_TARGET_DELETED:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < TimeSensorObjects.Count(); i++) {
            if (TimeSensorObjects[i]->node == hTarget) {
                TimeSensorObjects.Delete(i, 1); 
                // Do I need to remove the reference? FIXME
                int numObjs;
                pblock->GetValue(PB_NUMOBJS, 0, numObjs,
                                 FOREVER);
                numObjs--;
                pblock->SetValue(PB_NUMOBJS, 0, numObjs);
            }
        }
        break;
    case REFMSG_NODE_NAMECHANGE:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < TimeSensorObjects.Count(); i++) {
            if (TimeSensorObjects[i]->node == hTarget) {
                // Found it
                TimeSensorObjects[i]->ResetStr();
                break;
            }
        }
        break;
    }
    return REF_SUCCEED;
}

RefTargetHandle
TimeSensorObject::GetReference(int ind)
{
    if (ind == 0)
        return (RefTargetHandle) pblock;
    if (ind > TimeSensorObjects.Count()) return NULL;

    if (TimeSensorObjects[ind-1] == NULL)
        return NULL;
    return TimeSensorObjects[ind-1]->node;
}

void
TimeSensorObject::SetReference(int ind, RefTargetHandle rtarg)
{
    if (ind == 0) {
        pblock = (IParamBlock*) rtarg;
        if (pblock) {
            int numObjs;
            pblock->GetValue(PB_NUMOBJS, 0, numObjs,
                             FOREVER);
            if (TimeSensorObjects.Count() == 0) {
                TimeSensorObjects.SetCount(numObjs);
                for(int i = 0; i < numObjs; i++)
                    TimeSensorObjects[i] = new TimeSensorObj();
            }
        }
        return;
    }
    else if (ind > TimeSensorObjects.Count())
        return;

    TimeSensorObjects[ind-1]->node = (INode *)rtarg;
    TimeSensorObjects[ind-1]->ResetStr();
}

ObjectState
TimeSensorObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
TimeSensorObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
TimeSensorObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
TimeSensorObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    box = mesh.getBoundingBox();

}

void
TimeSensorObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
TimeSensorObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_SIZE, t, size, FOREVER);
#include "clockob.cpp"
}

int
TimeSensorObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.0f, 1.0f, 0.0f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
TimeSensorObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class TimeSensorCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    TimeSensorObject *timeSensorObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(TimeSensorObject *obj) {timeSensorObject = obj;}

};

			
int
TimeSensorCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            timeSensorObject->pblock->SetValue(PB_SIZE,
                                               timeSensorObject->
                                               iObjParams->GetTime(), radius);
            timeSensorObject->pmapParam->Invalidate();
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(timeSensorObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static TimeSensorCreateCallBack TimeSensorCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
TimeSensorObject::GetCreateMouseCallBack() 
{
    TimeSensorCreateCB.SetObj(this);
    return(&TimeSensorCreateCB);
}

RefTargetHandle
TimeSensorObject::Clone(RemapDir& remap)
{
    TimeSensorObject* ts = new TimeSensorObject();
    ts->ReplaceReference(0, pblock->Clone(remap));
    ts->TimeSensorObjects.SetCount(TimeSensorObjects.Count());
    for(int i = 0; i < TimeSensorObjects.Count(); i++)
        ts->ReplaceReference(i+1, TimeSensorObjects[i]->node);
    
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vrmlexp.rc
//
#define IDS_DB_TRIGGER_DIST             1
#define IDS_ANIM_PICK_MODE              2
#define IDS_LOD_PICK_MODE               3
#define IDS_OPEN_FAILED                 4
#define IDS_HL_TITLE                    5
#define IDS_VPT_TITLE                   6
#define IDS_ANIM_TITLE                  7
#define IDS_ACTION_TITLE                8
#define IDS_TRIGGERS_TITLE              9
#define IDS_LOD_TITLE                   10
#define IDS_VRML_INS_TITLE              11
#define IDS_DLL_INFO                    12
#define IDS_VRML_EXPORT                 13
#define IDS_DS_AMBIENT                  14
#define IDS_DS_DIFFUSE                  15
#define IDS_DS_SPECULAR                 16
#define IDS_DS_NONE                     17
#define IDS_DS_LOCKAD                   18
#define IDS_DS_LOCKCOL                  19
#define IDS_DS_PARAMCHG                 20
#define IDS_DS_LOCK_DS                  21
#define IDS_DS_BASIC                    22
#define IDS_DS_SHININESS                23
#define IDS_DS_SELFI                    24
#define IDS_DS_OPACITY                  25
#define IDS_DS_MAP_TEXTURE_ERR          26
#define IDS_DS_INVAL_NAME               27
#define IDS_DS_SELECT_FILE              28
#define IDS_DS_STANDARD                 29
#define IDS_DS_BITMAP                   30
#define IDS_TH_SCENEEXPORT              31
#define IDS_TimeSensor_PICK_MODE        32
#define IDS_TouchSensor_PICK_MODE       33
#define IDS_POLYGON_COUNTER_CLASS       34
#define IDS_ANCHOR_CLASS                35
#define IDS_TOUCH_SENSOR_CLASS          36
#define IDS_TIME_SENSOR_CLASS           37
#define IDS_NAV_INFO_CLASS              38
#define IDS_BACKGROUND_CLASS            39
#define IDS_FOG_CLASS                   40
#define IDS_AUDIO_CLIP_CLASS            41
#define IDS_SOUND_CLASS                 42
#define IDS_BILLBOARD_CLASS             43
#define IDS_LOD_CLASS                   44
#define IDS_INLINE_CLASS                45
#define IDS_ANCHOR                      46
#define IDS_TOUCH_SENSOR                47
#define IDS_TIME_SENSOR                 48
#define IDS_NAV_INFO                    49
#define IDS_BACKGROUND                  50
#define IDS_FOG                         51
#define IDS_AUDIO_CLIP                  52
#define IDS_SOUND                       53
#define IDS_BILLBOARD                   54
#define IDS_LOD                         55
#define IDS_INLINE                      56
#define IDS_VRML_EXPORT_CLASS           57
#define IDS_PROX_SENSOR_CLASS           58
#define IDS_PROX_SENSOR                 59
#define IDS_PICK_TRIGGER                69
#define IDS_PICK_AUDIOCLIP              70
#define IDS_OUT_TRIANGLES               71
#define IDS_OUT_QUADS                   72
#define IDS_OUT_NGONS                   73
#define IDS_OUT_VIS_EDGES               74
#define IDD_CPPOUT_PANEL                103
#define IDD_LOD                         116
#define IDD_INS                         117
#define IDD_VRBLEXP                     118
#define IDD_URL_BOOKMARKS               119
#define IDC_LOD_CURSOR                  122
#define IDB_VMTL_BUTTONS                122
#define IDC_ANIM_CURSOR                 123
#define IDB_VMTL_MASKBUTTONS            123
#define IDD_SAMPLE_RATES                127
#define IDD_WORLD_INFO                  129
#define IDD_ABOUT                       130
#define IDD_PROGRESSDLG                 131
#define IDC_CROSS_HAIR                  156
#define IDD_POLYCOUNT                   329
#define IDC_CPPOUT_PICK                 1002
#define IDD_TimeSensor                  1034
#define IDD_NAV_INFO                    1035
#define IDD_BACKGROUND_COLORS           1036
#define IDD_BACKGROUND_IMAGES           1037
#define IDD_FOG                         1038
#define IDD_AUDIO_CLIP                  1039
#define IDC_COLOR_SWATCH_2              1040
#define IDD_SOUND                       1040
#define IDC_COLOR_SWATCH_3              1041
#define IDD_TOUCH_SENSOR                1041
#define IDD_PROX_SENSOR                 1042
#define IDD_BACKGROUND_COLORS1          1043
#define IDD_ANCHOR                      1044
#define IDD_BBOARD                      1045
#define IDC_TFORM_ONCE                  1061
#define IDC_HYPERLINK                   1061
#define IDC_COORD_ONCE                  1062
#define IDC_FLIPBOOK_ONCE               1063
#define IDC_URL                         1068
#define IDC_URL_PREFIX                  1068
#define IDC_TITLE                       1068
#define IDC_BACK                        1068
#define IDC_INFO                        1069
#define IDC_BOTTOM                      1069
#define IDC_FRONT                       1070
#define IDC_LEFT                        1071
#define IDC_RIGHT                       1072
#define IDC_TOP                         1073
#define IDC_LOD_SIZE                    1094
#define IDC_LOD_SIZE_SPINNER            1095
#define IDC_LOD_PICK                    1096
#define IDC_LOD_DIST                    1098
#define IDC_LOD_DIST_SPINNER            1099
#define IDC_LOD_LIST                    1101
#define IDC_LOD_DEL                     1102
#define IDC_INS_URL                     1103
#define IDC_INS_SIZE                    1104
#define IDC_INS_SIZE_SPINNER            1105
#define IDC_INS_BBOX_SIZE               1106
#define IDC_INS_BBOX_DEF                1107
#define IDC_GENNORMALS                  1109
#define IDC_INDENT                      1110
#define IDC_CPV_CALC                    1111
#define IDC_CAMERA_COMBO                1113
#define IDC_ADD                         1114
#define IDC_NAV_INFO_COMBO              1114
#define IDC_DELETE                      1115
#define IDC_BACKGROUND_COMBO            1115
#define IDC_IMPORT                      1116
#define IDC_FOG_COMBO                   1116
#define IDC_DESC                        1118
#define IDC_URL_LIST                    1120
#define IDC_BOOKMARKS                   1121
#define IDC_USE_PREFIX                  1127
#define IDC_DIGITS                      1136
#define IDC_POLY_COUNT                  1139
#define IDC_SEL_COUNT                   1140
#define IDC_POLY_BAR                    1141
#define IDC_SELECTED_BAR                1142
#define IDC_LOOP                        1144
#define IDC_START_EDIT                  1147
#define IDC_START_SPIN                  1148
#define IDC_STOP_EDIT                   1149
#define IDC_STOP_SPIN                   1150
#define IDC_COORD_INTERP                1151
#define IDC_MAX_FRONT_EDIT              1151
#define IDC_MAX_FRONT_SPIN              1152
#define IDC_FLIP_BOOK                   1152
#define IDC_SAMPLE_RATES                1153
#define IDC_TFORM_CUSTOM                1156
#define IDC_TFORM_EDIT                  1157
#define IDC_TFORM_SPIN                  1158
#define IDC_COORD_EDIT                  1159
#define IDC_TimeSensor_SIZE             1159
#define IDC_COLOR_3_ANGLE_EDIT          1159
#define IDC_COORD_SPIN                  1160
#define IDC_TimeSensor_SIZE_SPINNER     1160
#define IDC_COLOR_3_ANGLE_SPIN          1160
#define IDC_COORD_CUSTOM                1161
#define IDC_TimeSensor_PICK             1161
#define IDC_TimeSensor_LIST             1162
#define IDC_FLIPBOOK_EDIT               1162
#define IDC_TimeSensor_DEL              1163
#define IDC_FLIPBOOK_SPIN               1163
#define IDC_HEADLIGHT                   1164
#define IDC_FLIPBOOK_CUSTOM             1164
#define IDC_VIS_LIMIT_EDIT              1165
#define IDC_VIS_LIMIT_SPIN              1166
#define IDC_COLLISION_EDIT              1167
#define IDC_COLLISION_SPIN              1168
#define IDC_TYPE                        1169
#define IDC_TERRAIN_EDIT                1170
#define IDC_TERRAIN_SPIN                1171
#define IDC_STEP_EDIT                   1172
#define IDC_STEP_SPIN                   1173
#define IDC_SPEED_EDIT                  1174
#define IDC_SPEED_SPIN                  1175
#define IDC_WORLD_INFO                  1176
#define IDC_EXP_HELP                    1177
#define IDC_EXPORT_HIDDEN               1178
#define IDC_PRIM                        1179
#define IDC_1_COLOR                     1180
#define IDC_ENABLE_PROGRESS_BAR         1180
#define IDC_2_COLOR                     1181
#define IDC_COLOR_PER_VERTEX            1181
#define IDC_COLOR_PER_VERTEX1           1181
#define IDC_3_COLOR                     1182
#define IDC_COLOR_SWATCH_1              1183
#define IDC_COLOR_2_ANGLE_EDIT          1184
#define IDC_COLOR_2_ANGLE_SPIN          1185
#define IDC_COLOR_SWATCH                1187
#define IDC_VR_EDIT                     1188
#define IDC_VR_SPIN                     1189
#define IDC_PITCH_EDIT                  1191
#define IDC_PITCH_SPIN                  1192
#define IDC_INTENSITY_EDIT              1193
#define IDC_INTENSITY_SPIN              1194
#define IDC_MIN_BACK_EDIT               1195
#define IDC_MIN_BACK_SPIN               1196
#define IDC_MIN_FRONT_EDIT              1197
#define IDC_MIN_FRONT_SPIN              1198
#define IDC_MAX_BACK_EDIT               1199
#define IDC_MAX_BACK_SPIN               1200
#define IDC_NAME                        1201
#define IDC_AUDIO_CLIP_PICK             1202
#define IDC_SPATIALIZE                  1203
#define IDC_PRIORITY_EDIT               1204
#define IDC_START_ON_LOAD               1204
#define IDC_PRIORITY_SPIN               1205
#define IDC_ICON_EDIT                   1206
#define IDC_ICON_SPIN                   1207
#define IDC_ENABLE                      1209
#define IDC_PICK                        1210
#define IDC_SIZE_EDIT                   1211
#define IDC_SIZE_SPIN                   1212
#define IDC_LIST                        1213
#define IDC_DEL                         1214
#define IDC_WIDTH_EDIT                  1215
#define IDC_PICK_PARENT                 1215
#define IDC_WIDTH_SPIN                  1216
#define IDC_HEIGHT_EDIT                 1217
#define IDC_HEIGHT_SPIN                 1218
#define IDC_LENGTH_EDIT                 1219
#define IDC_LENGTH_SPIN                 1220
#define IDC_TRIGGER_OBJ                 1221
#define IDC_ANCHOR_URL                  1226
#define IDC_PARAMETER                   1227
#define IDC_CAMERA                      1228
#define IDC_SET_CAMERA                  1229
#define IDC_ALIGN                       1230
#define IDC_POLYGON_TYPE                1231
#define IDC_PROGRESS_NNAME              1236
#define IDC_CPV_MAX                     1238
#define IDC_MAX_POLY_EDIT               1349
#define IDC_MAX_POLY_SPIN               1350
#define IDC_MAX_SELECTED_EDIT           1351
#define IDC_MAX_SELECTED_SPIN           1352
#define IDS_DS_CREATE                   10008
#define IDS_DS_EXCLUDE__                10122
#define IDS_DS_INCLUDE__                10123
#define IDS_DS_LIGHTCOL                 10175
#define IDS_DB_TDIST                    20072
#define IDS_DB_MULTIPLIER               20315
#define IDS_DB_ATTENSTART               20316
#define IDS_DB_ATTENEND                 20317
#define IDS_DB_HOTSIZE                  20318
#define IDS_DB_FALLSIZE                 20319
#define IDS_DB_COLOR                    20320
#define IDS_DB_ASPECT_RATIO             20323
#define IDS_DB_TAPE_LENGTH              20326
#define IDS_DB_NRANGE                   20453
#define IDS_DB_FRANGE                   20454
#define IDS_RB_OBJECT                   30004
#define IDS_RB_PARAMETERS               30028
#define IDS_RB_ANGLE                    30029
#define IDS_RB_AMOUNT                   30031
#define IDS_RB_RED                      30049
#define IDS_RB_GREEN                    30050
#define IDS_RB_BLUE                     30051
#define IDS_RB_HOTSIZE                  30052
#define IDS_RB_TRANSFORM                30053
#define IDS_RB_BASEPARAMS               30054
#define IDS_DB_TARGET                   30055
#define IDS_DB_DOT_TARGET               30056
#define IDS_DB_OMNI                     30057
#define IDS_DB_TARGET_SPOT              30058
#define IDS_DB_DIRECTIONAL              30059
#define IDS_DB_FREE_SPOT                30060
#define IDS_DB_NONE                     30061
#define IDS_DB_GENERAL_PARAMS           30064
#define IDS_DB_DIR_PARAMS               30065
#define IDS_DB_SPOT_PARAMS              30066
#define IDS_DB_SHADOW_PARAMS            30067
#define IDS_DB_SELECT_TO_FIT            30068
#define IDS_DB_OMNI_LIGHT               30069
#define IDS_DB_DIR_LIGHT                30070
#define IDS_DB_DIRECT                   30071
#define IDS_DB_FSPOT                    30072
#define IDS_DB_SPOT                     30073
#define IDS_DB_LIGHT                    30074
#define IDS_DB_TAPE                     30075
#define IDS_DB_GENERAL                  30076
#define IDS_RB_GEOMETERIC               30157
#define IDS_RB_SHAPES                   30158
#define IDS_RB_LIGHTS                   30159
#define IDS_RB_CPPOBJECTOUT             30619
#define IDS_RB_CPPFILES                 30620
#define IDS_RB_SAVEOBJECT               30621
#define IDS_RB_FILEEXISTS               30625
#define IDS_RB_MAPSIZE                  30640
#define IDS_RB_MAPBIAS                  30641
#define IDS_RB_MAPRANGE                 30642
#define IDS_RB_RAYBIAS                  30643
#define IDS_RB_NEARPLANE                30644
#define IDS_RB_FARPLANE                 30645
#define IDS_PRS_URL                     30646
#define IDS_PRS_DESCRIPTION             30647
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        132
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1239
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\touch.cpp ===
/**********************************************************************
 *<
    FILE: touch.cpp

    DESCRIPTION:  A VRML Touch Sensor Helper
 
    CREATED BY: Scott Morrison
  
    HISTORY: created 4 Sept, 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#include "vrml.h"
#include "touch.h"

//------------------------------------------------------

class TouchSensorClassDesc:public ClassDesc {
public:
    int 			IsPublic() { return 1; }
    void *			Create(BOOL loading = FALSE)
    { return new TouchSensorObject; }
    const TCHAR * ClassName() {return _T(GetString(IDS_TOUCH_SENSOR_CLASS));}
    SClass_ID		SuperClassID() { return HELPER_CLASS_ID; }
    Class_ID 		ClassID() { return Class_ID(TouchSensor_CLASS_ID1, TouchSensor_CLASS_ID2); }
    const TCHAR* 	Category() { return _T("VRML97");  }
};

static TouchSensorClassDesc TouchSensorDesc;

ClassDesc* GetTouchSensorDesc() { return &TouchSensorDesc; }

// in prim.cpp  - The dll instance handle
extern HINSTANCE hInstance;

ICustButton *TouchSensorObject::ParentPickButton = NULL;

HWND TouchSensorObject::hRollup = NULL;
int TouchSensorObject::dlgPrevSel = -1;

class ParentObjPick : public PickModeCallback {
    TouchSensorObject *parent;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetTouchSensor(TouchSensorObject *l) { parent = l; }
};

//static ParentObjPick    theParentPick;
#define     PARENT_PICK_MODE    1
#define     TOUCH_PICK_MODE     2

static ParentObjPick    thePPick;
static int              pickMode    = 0;
static CommandMode*     lastMode    = NULL;

static void
SetPickMode(PickModeCallback* p, int w = 0) {
    if (pickMode || !p) {
        pickMode = 0;
        GetCOREInterface()->PushCommandMode(lastMode);
        lastMode = NULL;
        GetCOREInterface()->ClearPickMode();
    } else {
        pickMode = w;
        lastMode = GetCOREInterface()->GetCommandMode();
     // thePick.SetTouchSensor(o);
        GetCOREInterface()->SetPickMode(p);
    }
}

BOOL
ParentObjPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(TouchSensor_CLASS_ID1, TouchSensor_CLASS_ID2)))
        return FALSE;
    return TRUE;
}

void
ParentObjPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(_T(GetString(IDS_PICK_TRIGGER)));
}

void
ParentObjPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
ParentObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        parent->ReplaceReference(1, node);

        SetPickMode(NULL);
     // parent->iObjParams->SetCommandMode(parent->previousMode);
     // parent->previousMode = NULL;
        parent->ParentPickButton->SetCheck(FALSE);
        HWND hw = parent->hRollup;
        Static_SetText(GetDlgItem(hw,IDC_TRIGGER_OBJ),
                       parent->triggerObject->GetName());
        return FALSE;
    }
    return FALSE;
}


HCURSOR
ParentObjPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

ICustButton *TouchSensorObject::TouchSensorPickButton = NULL;

class TouchSensorObjPick : public PickModeCallback {
    TouchSensorObject *touchSensor;
public:		

    BOOL HitTest(IObjParam *ip,HWND hWnd,ViewExp *vpt,IPoint2 m,int flags);
    BOOL Pick(IObjParam *ip,ViewExp *vpt);	

    void EnterMode(IObjParam *ip);
    void ExitMode(IObjParam *ip);

    HCURSOR GetHitCursor(IObjParam *ip);
    void SetTouchSensor(TouchSensorObject *l) { touchSensor = l; }
};

// static TouchSensorObjPick thePick;
static  TouchSensorObjPick  theTSPick;

BOOL
TouchSensorObjPick::HitTest(IObjParam *ip, HWND hWnd, ViewExp *vpt, IPoint2 m,
                           int flags)
{
    INode *node = ip->PickNode(hWnd, m);
    if (node == NULL)
        return FALSE;
    Object* obj = node->EvalWorldState(0).obj;
    if ((obj->SuperClassID() == HELPER_CLASS_ID &&
         obj->ClassID() == Class_ID(TouchSensor_CLASS_ID1, TouchSensor_CLASS_ID2)))
        return FALSE;
    return TRUE;
}

void
TouchSensorObjPick::EnterMode(IObjParam *ip)
{
    ip->PushPrompt(GetString(IDS_TouchSensor_PICK_MODE));
}

void
TouchSensorObjPick::ExitMode(IObjParam *ip)
{
    ip->PopPrompt();
}

BOOL
TouchSensorObjPick::Pick(IObjParam *ip,ViewExp *vpt)
{
    if (vpt->HitCount() == 0)
        return FALSE;

    INode *node;
    if ((node = vpt->GetClosestHit()) != NULL) {
        // Check to see if we have a reference to this object already
        for (int i = 0; i < touchSensor->objects.Count(); i++) {
            if (touchSensor->objects[i]->node == node)
                return FALSE; // Can't click those we already have
        }

        TouchSensorObj *obj = new TouchSensorObj(node);
        int id = touchSensor->objects.Append(1, &obj);
        touchSensor->pblock->SetValue(PB_TS_NUMOBJS,
                                     touchSensor->iObjParams->GetTime(),
                                     touchSensor->objects.Count());

        RefResult ret = touchSensor->MakeRefByID(FOREVER, id+2, node);

        HWND hw = touchSensor->hRollup;
        int ind = SendMessage(GetDlgItem(hw,IDC_LIST),
                              LB_ADDSTRING, 0, (LPARAM)obj->listStr.data());
        SendMessage(GetDlgItem(hw,IDC_LIST),
                    LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        EnableWindow(GetDlgItem(hw, IDC_DEL),
                     touchSensor->objects.Count() > 0);
    }
    return FALSE;
}


HCURSOR
TouchSensorObjPick::GetHitCursor(IObjParam *ip)
{
    return LoadCursor(hInstance, MAKEINTRESOURCE(IDC_LOD_CURSOR));
}

void
BuildObjectList(TouchSensorObject *ob)
{
    if (ob && ob->hRollup) {
        int count, i;

        count = SendDlgItemMessage(ob->hRollup, IDC_LIST,
                                   LB_GETCOUNT, 0, 0);

        // First remove any objects on the list
        for (i = count - 1; i >= 0; i--)
            SendDlgItemMessage(ob->hRollup, IDC_LIST,
                               LB_DELETESTRING, (WPARAM) i, 0);

        for (i = 0; i < ob->objects.Count(); i++) {
            TouchSensorObj *obj = ob->objects[i];
            obj->ResetStr(); // Make sure we're up to date

            // for now just load the name, we might want to add 
            // the frame range as some point
            int ind = SendMessage(GetDlgItem(ob->hRollup,IDC_LIST),
                                  LB_ADDSTRING, 0,
                                  (LPARAM)obj->listStr.data());
            SendMessage(GetDlgItem(ob->hRollup,IDC_LIST),
                        LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
        }
    }
}

BOOL CALLBACK
RollupDialogProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam ,
                  TouchSensorObject* th)
{
    if ( !th && message != WM_INITDIALOG ) return FALSE;

    switch ( message ) {
    case WM_INITDIALOG:
//        SetDlgFont( hDlg, th->iObjParams->GetAppHFont() );

        th->TouchSensorPickButton = GetICustButton(GetDlgItem(hDlg,IDC_PICK));
        th->TouchSensorPickButton->SetType(CBT_CHECK);
        th->TouchSensorPickButton->SetButtonDownNotify(TRUE);
        th->TouchSensorPickButton->SetHighlightColor(GREEN_WASH);
        th->TouchSensorPickButton->SetCheck(FALSE);

        th->ParentPickButton = GetICustButton(GetDlgItem(hDlg,IDC_PICK_PARENT));
        th->ParentPickButton->SetType(CBT_CHECK);
        th->ParentPickButton->SetButtonDownNotify(TRUE);
        th->ParentPickButton->SetHighlightColor(GREEN_WASH);
        th->ParentPickButton->SetCheck(FALSE);
        
        // Now we need to fill in the list box IDC_LIST
        th->hRollup = hDlg;
        BuildObjectList(th);

//        EnableWindow(GetDlgItem(hDlg, IDC_DEL),
//                     (th->objects.Count() > 0));
        th->dlgPrevSel = -1;
        if (th->triggerObject)
            Static_SetText(GetDlgItem(hDlg,IDC_TRIGGER_OBJ),
                           th->triggerObject->GetName());
        
        if (pickMode) SetPickMode(NULL);
        return TRUE;			

    case WM_DESTROY:
        if (pickMode) SetPickMode(NULL);
     // th->iObjParams->ClearPickMode();
     // th->previousMode = NULL;
        ReleaseICustButton( th->TouchSensorPickButton );
        ReleaseICustButton( th->ParentPickButton );
        return FALSE;

    case WM_MOUSEACTIVATE:
//        th->iObjParams->RealizeParamPanel();
        return FALSE;

    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MOUSEMOVE:
//        th->iObjParams->RollupMouseMessage(hDlg,message,wParam,lParam);
        return FALSE;

    case WM_COMMAND:			
        switch( LOWORD(wParam) ) {
        case IDC_PICK: // Pick an object from the scene
            // Set the pickmode...
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                if (pickMode == PARENT_PICK_MODE) {
                    SetPickMode(NULL);
                    th->ParentPickButton->SetCheck(FALSE);
                }
                theTSPick.SetTouchSensor(th);
                SetPickMode(&theTSPick, TOUCH_PICK_MODE);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    thePick.SetTouchSensor(th);
                    th->iObjParams->SetPickMode(&thePick);
                }
                */
                break;
            }
            break;
        case IDC_PICK_PARENT: // Pick an object from the scene
            // Set the pickmode...
            switch (HIWORD(wParam)) {
            case BN_BUTTONDOWN:
                if (pickMode == TOUCH_PICK_MODE) {
                    SetPickMode(NULL);
                    th->TouchSensorPickButton->SetCheck(FALSE);
                }
                thePPick.SetTouchSensor(th);
                SetPickMode(&thePPick, PARENT_PICK_MODE);
                /*
                if (th->previousMode) {
                    // reset the command mode
                    th->iObjParams->SetCommandMode(th->previousMode);
                    th->previousMode = NULL;
                } else {
                    th->previousMode = th->iObjParams->GetCommandMode();
                    theParentPick.SetTouchSensor(th);
                    th->iObjParams->SetPickMode(&theParentPick);
                }
                */
                break;
            }
            break;
        case IDC_DEL: { // Delete the object from the list
            int index =	SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                    LB_GETCURSEL, 0, 0);
            if (index != LB_ERR) {
                TouchSensorObj *obj = (TouchSensorObj *)
                    SendDlgItemMessage(hDlg, IDC_LIST,
                                       LB_GETITEMDATA, index, 0);
                for (int i = 0; i < th->objects.Count(); i++) {
                    if (obj == th->objects[i]) {
                        // remove the item from the list
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_DELETESTRING,
                                           (WPARAM) index, 0);
                        th->dlgPrevSel = -1;
                        // Remove the reference to obj->node
                        th->DeleteReference(i+2);
                        // remove the object from the table
                        th->objects.Delete(i, 1);
                        th->pblock->SetValue(PB_TS_NUMOBJS,
                                             th->iObjParams->GetTime(),
                                             th->objects.Count());
                        break;
                    }
                }
                EnableWindow(GetDlgItem(hDlg, IDC_DEL),
                             (th->objects.Count() > 0));
                if (th->objects.Count() <= 0) {
                    th->iObjParams->RedrawViews(th->iObjParams->GetTime());
                }
            }
        }
        break;
        case IDC_LIST:
            switch(HIWORD(wParam)) {
            case LBN_SELCHANGE: {
                int sel = SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                      LB_GETCURSEL, 0, 0);
                if (th->dlgPrevSel != -1) {
                    // save any editing
                    TouchSensorObj *obj = (TouchSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_GETITEMDATA, th->dlgPrevSel, 0);
                    obj->ResetStr();
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_DELETESTRING, th->dlgPrevSel, 0);
                    int ind = SendMessage(GetDlgItem(hDlg,
                                                     IDC_LIST),
                                          LB_ADDSTRING, 0,
                                          (LPARAM)obj->listStr.data());
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_SETITEMDATA, (WPARAM)ind, (LPARAM)obj);
                    SendMessage(GetDlgItem(hDlg,IDC_LIST),
                                LB_SETCURSEL, sel, 0);
                }
                th->dlgPrevSel = sel;
                if (sel >= 0) {
                    TouchSensorObj *obj = (TouchSensorObj *)
                        SendDlgItemMessage(hDlg, IDC_LIST,
                                           LB_GETITEMDATA, sel, 0);
                    assert(obj);

                } else {
                }
                th->iObjParams->RedrawViews(th->iObjParams->GetTime());
            }
            break;
            case LBN_SELCANCEL:
                break;
            }
            break;
        }
        return FALSE;
    default:
        return FALSE;
    }
}

static ParamUIDesc descParam[] = {
  // Size
  ParamUIDesc(
              PB_TS_SIZE,
              EDITTYPE_UNIVERSE,
              IDC_SIZE_EDIT, IDC_SIZE_SPIN,
              0.0f, 1000.0f,
              SPIN_AUTOSCALE),	

  // Loop
  ParamUIDesc(PB_TS_ENABLED, TYPE_SINGLECHEKBOX, IDC_ENABLE),

};

  

#define PARAMDESC_LENGTH 2

static ParamBlockDescID descVer0[] = {
  { TYPE_FLOAT, NULL, FALSE, 0 },
  { TYPE_INT, NULL, FALSE, 1 },
  { TYPE_INT, NULL, FALSE, 2 },
};


//static ParamVersionDesc versions[] = {
//  ParamVersionDesc(descVer0,5,0),
//};

//#define NUM_OLD_VERSIONS 1

#define CURRENT_VERSION	0
// Current version
static ParamVersionDesc curVersion(descVer0, PB_TS_LENGTH, CURRENT_VERSION);

class TouchSensorParamDlgProc : public ParamMapUserDlgProc {
public:
  TouchSensorObject *ob;

  TouchSensorParamDlgProc(TouchSensorObject *o) { ob = o; }
  BOOL DlgProc(TimeValue t, IParamMap *map,HWND hWnd, UINT msg,
               WPARAM wParam, LPARAM lParam);
  void DeleteThis() {delete this;}
};

BOOL TouchSensorParamDlgProc::DlgProc(TimeValue t, IParamMap *map, HWND hWnd,
                                     UINT msg, WPARAM wParam, LPARAM lParam)
{
    return RollupDialogProc( hWnd, msg, wParam, lParam, ob );
}

IParamMap *TouchSensorObject::pmapParam = NULL;

#if 0
IOResult
TouchSensorObject::Load(ILoad *iload) 
{
  iload->RegisterPostLoadCallback(new ParamBlockPLCB(versions,
                                                     NUM_OLD_VERSIONS,
                                                     &curVersion,this,0));
  return IO_OK;
}

#endif

void
TouchSensorObject::BeginEditParams( IObjParam *ip, ULONG flags,
                                   Animatable *prev )
{
    iObjParams = ip;
    
    if (pmapParam) {
        // Left over from last TouchSensor created		
        pmapParam->SetParamBlock(pblock);
    } else {
        
        // Gotta make a new one.
        pmapParam = CreateCPParamMap(descParam,PARAMDESC_LENGTH,
                                     pblock,
                                     ip,
                                     hInstance,
                                     MAKEINTRESOURCE(IDD_TOUCH_SENSOR),
                                     _T("Touch Sensor"),
                                     0);
    }
    
    if (pmapParam) {
        // A callback for dialog
        pmapParam->SetUserDlgProc(new TouchSensorParamDlgProc(this));
    }
}
		
void
TouchSensorObject::EndEditParams( IObjParam *ip, ULONG flags,Animatable *prev)
{
    if ( flags&END_EDIT_REMOVEUI ) {		
        if (pmapParam) DestroyCPParamMap(pmapParam);
        pmapParam  = NULL;
    }	
//    iObjParams = NULL;
}

TouchSensorObject::TouchSensorObject() : HelperObject() 
{
    IParamBlock* pb = CreateParameterBlock(descVer0, PB_TS_LENGTH,
                                           CURRENT_VERSION);
    pb->SetValue(PB_TS_SIZE, 0, 0.0f);
    pb->SetValue(PB_TS_ENABLED, 0, TRUE);
    pb->SetValue(PB_TS_NUMOBJS, 0, 0);
    MakeRefByID(FOREVER, 0, pb);
    assert(pblock);
    previousMode = NULL;
    triggerObject = NULL;
    objects.SetCount(0);
    BuildObjectList(this);
}

TouchSensorObject::~TouchSensorObject()
{
    DeleteAllRefsFromMe();
    for (int i = 0; i < objects.Count(); i++) {
        TouchSensorObj *obj = objects[i];
        delete obj;
    }
}

IObjParam *TouchSensorObject::iObjParams;

// This is only called if the object MAKES references to other things.
RefResult
TouchSensorObject::NotifyRefChanged(Interval changeInt,
                                   RefTargetHandle hTarget, PartID& partID,
                                   RefMessage message ) 
{
    int i;
    switch (message) {
    case REFMSG_TARGET_DELETED:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < objects.Count(); i++) {
            if (objects[i]->node == hTarget) {
                // Do I need to remove the reference? FIXME
                objects.Delete(i, 1); 
            }
            int numObjs;
            pblock->GetValue(PB_TS_NUMOBJS, 0, numObjs,
                             FOREVER);
            numObjs--;
            pblock->SetValue(PB_TS_NUMOBJS, 0, numObjs);
        }
        if (hTarget == triggerObject)
            triggerObject = NULL;
        break;
    case REFMSG_NODE_NAMECHANGE:
        // Find the ID on the list and call ResetStr
        for (i = 0; i < objects.Count(); i++) {
            if (objects[i]->node == hTarget) {
                // Found it
                objects[i]->ResetStr();
                break;
            }
        }
        break;
    }
    return REF_SUCCEED;
}

RefTargetHandle
TouchSensorObject::GetReference(int ind)
{
    if (ind == 0)
        return pblock;
    if (ind == 1)
        return triggerObject;
    if (ind-1 > objects.Count()) return NULL;

    if (objects[ind-2] == NULL)
        return NULL;
    return objects[ind-2]->node;
}

void
TouchSensorObject::SetReference(int ind, RefTargetHandle rtarg)
{
    if (ind == 0) {
        pblock = (IParamBlock*) rtarg;
        if (pblock) {
            int numObjs;
            pblock->GetValue(PB_TS_NUMOBJS, 0, numObjs,
                             FOREVER);
            if (objects.Count() == 0) {
                objects.SetCount(numObjs);
                for(int i = 0; i < numObjs; i++)
                    objects[i] = new TouchSensorObj();
            }
        }
        return;
    }
    if (ind == 1) {
        triggerObject = (INode*) rtarg;
        return;
    }
    if (ind-1 > objects.Count())
        return;

    objects[ind-2]->node = (INode *)rtarg;
    objects[ind-2]->ResetStr();
}

ObjectState
TouchSensorObject::Eval(TimeValue time)
{
    return ObjectState(this);
}

Interval
TouchSensorObject::ObjectValidity(TimeValue time)
{
    Interval ivalid;
    ivalid.SetInfinite();
    return ivalid;	
}

void
TouchSensorObject::GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm)
{
    tm = inode->GetObjectTM(t);
}

void
TouchSensorObject::GetLocalBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 m = inode->GetObjectTM(t);
    BuildMesh(t);
    box = mesh.getBoundingBox();

}

void
TouchSensorObject::GetWorldBoundBox(TimeValue t, INode* inode, ViewExp* vpt,
                                   Box3& box )
{
    Matrix3 tm;
    GetMat(t,inode,vpt,tm);

    BuildMesh(t);
    int nv = mesh.getNumVerts();
    box.Init();
    for (int i=0; i<nv; i++) 
        box += tm*mesh.getVert(i);
}


void
TouchSensorObject::BuildMesh(TimeValue t)
{
    float size;
    pblock->GetValue(PB_TS_SIZE, t, size, FOREVER);
#include "touchob.cpp"
}

int
TouchSensorObject::Display(TimeValue t, INode* inode, ViewExp *vpt, int flags)
{
    float radius;
    pblock->GetValue(PB_TS_SIZE, t, radius, FOREVER);
    if (radius <= 0.0)
        return 0;
    BuildMesh(t);
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();
    Material *mtl = gw->getMaterial();

    DWORD rlim = gw->getRndLimits();
    gw->setRndLimits(GW_WIREFRAME|GW_BACKCULL);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    if (inode->Selected()) 
        gw->setColor( LINE_COLOR, 1.0f, 1.0f, 1.0f);
    else if(!inode->IsFrozen())
        gw->setColor( LINE_COLOR, 0.4f, 1.0f, 0.6f);
    mesh.render( gw, mtl, NULL, COMP_ALL);

    gw->setRndLimits(rlim);
    return(0);
}

int
TouchSensorObject::HitTest(TimeValue t, INode *inode, int type, int crossing,
                          int flags, IPoint2 *p, ViewExp *vpt)
{
    HitRegion hitRegion;
    DWORD	savedLimits;
    int res = FALSE;
    Matrix3 m;
    GraphicsWindow *gw = vpt->getGW();	
    Material *mtl = gw->getMaterial();
    MakeHitRegion(hitRegion,type,crossing,4,p);	
    gw->setRndLimits(((savedLimits = gw->getRndLimits()) | GW_PICK) & ~GW_ILLUM);
    GetMat(t,inode,vpt,m);
    gw->setTransform(m);
    gw->clearHitCode();
    if (mesh.select( gw, mtl, &hitRegion, flags & HIT_ABORTONHIT )) 
        return TRUE;
    gw->setRndLimits(savedLimits);
    return res;
}

class TouchSensorCreateCallBack : public CreateMouseCallBack {
private:
    IPoint2 sp0;
    Point3 p0;
    TouchSensorObject *touchSensorObject;

public:
    int proc( ViewExp *vpt,int msg, int point, int flags, IPoint2 m, 
              Matrix3& mat);
    void SetObj(TouchSensorObject *obj) {touchSensorObject = obj;}

};

			
int
TouchSensorCreateCallBack::proc(ViewExp *vpt,int msg, int point, int flags,
                               IPoint2 m, Matrix3& mat)
{	
    Point3 p1,center;

    switch ( msg ) {
    case MOUSE_POINT:
    case MOUSE_MOVE:
        switch ( point ) {
        case 0:  // only happens with MOUSE_POINT msg
            sp0 = m;
            p0 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            break;
        case 1:
            mat.IdentityMatrix();
            p1 = vpt->SnapPoint(m,m,NULL,SNAP_IN_PLANE);
            mat.SetTrans(p0);
            float radius = Length(p1-p0);
            touchSensorObject->pblock->SetValue(PB_TS_SIZE,
                                               touchSensorObject->
                                               iObjParams->GetTime(), radius);
            touchSensorObject->pmapParam->Invalidate();										
            if (flags&MOUSE_CTRL) {
                float ang = (float)atan2(p1.y-p0.y,p1.x-p0.x);
                mat.PreRotateZ(touchSensorObject->iObjParams->SnapAngle(ang));
            }

            if (msg==MOUSE_POINT) {
                return (Length(m-sp0)<3)?CREATE_ABORT:CREATE_STOP;
            }
            break;					   
        }			
        break;
    case MOUSE_ABORT:
        return CREATE_ABORT;
    }
	
    return TRUE;
}

// A single instance of the callback object.
static TouchSensorCreateCallBack TouchSensorCreateCB;

// This method allows MAX to access and call our proc method to 
// handle the user input.
CreateMouseCallBack*
TouchSensorObject::GetCreateMouseCallBack() 
{
    TouchSensorCreateCB.SetObj(this);
    return(&TouchSensorCreateCB);
}

RefTargetHandle
TouchSensorObject::Clone(RemapDir& remap)
{
    TouchSensorObject* ts = new TouchSensorObject();
    ts->ReplaceReference(0, pblock->Clone(remap));
    ts->objects.SetCount(objects.Count());
    ts->ReplaceReference(1, triggerObject);
    for(int i = 0; i < objects.Count(); i++)
        ts->ReplaceReference(i+2, objects[i]->node);
    
    return ts;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\touch.h ===
/**********************************************************************
 *<
    FILE: touch.h
 
    DESCRIPTION:  Defines a VRML 2.0 TouchSensor helper
 
    CREATED BY: Scott Morrison
 
    HISTORY: created 4 Sept. 1996
 
 *> Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
 
#ifndef __TouchSensor__H__
 
#define __TouchSensor__H__
 
#define TouchSensor_CLASS_ID1 0x73fa3442
#define TouchSensor_CLASS_ID2 0xF002BDAD

#define TouchSensorClassID Class_ID(TouchSensor_CLASS_ID1, TouchSensor_CLASS_ID2)

extern ClassDesc* GetTouchSensorDesc();

class TouchSensorCreateCallBack;
class TouchSensorObjPick;

class TouchSensorObj {
  public:
    INode *node;
    TSTR listStr;
    void ResetStr(void) {
        if (node)
            listStr.printf("%s", node->GetName());
        else listStr.printf("%s", _T("NO_NAME"));
    }
    TouchSensorObj(INode *n = NULL) {
        node = n;
        ResetStr();
    }
};

class TouchSensorObject: public HelperObject {			   
    friend class TouchSensorCreateCallBack;
    friend class TouchSensorObjPick;
    friend BOOL CALLBACK RollupDialogProc( HWND hDlg, UINT message,
                                           WPARAM wParam, LPARAM lParam );
    friend void BuildObjectList(TouchSensorObject *ob);

  public:

    // Class vars
    static HWND hRollup;
    static int dlgPrevSel;
    BOOL needsScript;  // Do we need to generate a script node?

    RefResult NotifyRefChanged( Interval changeInt, RefTargetHandle hTarget, 
                                PartID& partID, RefMessage message );
    float radius;
    static IObjParam *iObjParams;

    Mesh mesh;
    void BuildMesh(TimeValue t);

    Tab<TouchSensorObj*> objects;
    CommandMode *previousMode;

    static ICustButton *TouchSensorPickButton;
    static ICustButton *ParentPickButton;

    IParamBlock *pblock;
    static IParamMap *pmapParam;

    INode* triggerObject;

    TouchSensorObject();
    ~TouchSensorObject();


    RefTargetHandle Clone(RemapDir& remap = NoRemap());

    // From BaseObject
           void GetMat(TimeValue t, INode* inode, ViewExp* vpt, Matrix3& tm);
    int HitTest(TimeValue t, INode* inode, int type, int crossing,
                int flags, IPoint2 *p, ViewExp *vpt);
    int Display(TimeValue t, INode* inode, ViewExp *vpt, int flags);
    CreateMouseCallBack* GetCreateMouseCallBack();
    void BeginEditParams( IObjParam *ip, ULONG flags,Animatable *prev);
    void EndEditParams( IObjParam *ip, ULONG flags,Animatable *next);
    TCHAR *GetObjectName() { return _T(GetString(IDS_TOUCH_SENSOR)); }


    Tab<TouchSensorObj*> GetObjects() { return objects; }

    // From Object
           ObjectState Eval(TimeValue time);
    void InitNodeName(TSTR& s) { s = _T(GetString(IDS_TOUCH_SENSOR)); }
    Interval ObjectValidity();
    Interval ObjectValidity(TimeValue time);
    int DoOwnSelectHilite() { return 1; }

    void GetWorldBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );
    void GetLocalBoundBox(TimeValue t, INode *mat, ViewExp *vpt, Box3& box );

    // Animatable methods
           void DeleteThis() { delete this; }
    Class_ID ClassID() { return Class_ID(TouchSensor_CLASS_ID1,
                                         TouchSensor_CLASS_ID2);}  
    void GetClassName(TSTR& s) { s = TSTR(_T(GetString(IDS_TOUCH_SENSOR_CLASS))); }
    int IsKeyable(){ return 1;}
    LRESULT CALLBACK TrackViewWinProc( HWND hwnd,  UINT message, 
                                       WPARAM wParam,   LPARAM lParam )
    { return 0; }


    int NumRefs() {return objects.Count() + 2;}
    RefTargetHandle GetReference(int i);
    void SetReference(int i, RefTargetHandle rtarg);
//    IOResult Load(ILoad *iload) ;

};				

#define PB_TS_SIZE          0
#define PB_TS_ENABLED       1
#define PB_TS_NUMOBJS       2
#define PB_TS_LENGTH        3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrml2.cpp ===
/**********************************************************************
 *<
	FILE: vrml2.cpp

	DESCRIPTION:  VRML 2.0 .WRL file export module

	CREATED BY: Scott Morrison

	HISTORY: created 7 June, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include <time.h>
#include "vrml.h"
#include "simpobj.h"
#include "istdplug.h"
#include "inline.h"
#include "lod.h"
#include "inlist.h"
#include "notetrck.h"
#include "bookmark.h"
#include "stdmat.h"
#include "normtab.h"
#include "vrml_api.h"
#include "vrmlexp.h"
#include "decomp.h"
#include "timer.h"
#include "navinfo.h"
#include "backgrnd.h"
#include "fog.h"
#include "audio.h"
#include "sound.h"
#include "touch.h"
#include "prox.h"
#include "appd.h"
#include "anchor.h"
#include "bboard.h"
#include "vrml2.h"
#include "pmesh.h"
#include "evalcol.h"


#ifdef _DEBUG
#define FUNNY_TEST
#endif

//#define TEST_MNMESH
#ifdef TEST_MNMESH
#include "mnmath.h"
#endif

#define MIRROR_BY_VERTICES
// alternative, mirror by scale, is deprecated  --prs.

#define AEQ(a, b) (fabs(a - b) < 0.5 * pow(10.0, -mDigits))

extern TCHAR *GetString(int id);

static HWND hWndPDlg;   // handle of the progress dialog
static HWND hWndPB;     // handle of progress bar 

////////////////////////////////////////////////////////////////////////
// VRML 2.0 Export implementation
////////////////////////////////////////////////////////////////////////

//#define TEMP_TEST
#ifdef TEMP_TEST
static int getworldmat = 0;
#endif

void AngAxisFromQa(const Quat& q, float *ang, Point3& axis) {
	double omega, s, x, y, z, w, l, c;
	x = (double)q.x;	
	y = (double)q.y;	
	z = (double)q.z;	
	w = (double)q.w;	
	l =  sqrt(x*x + y*y + z*z + w*w);
	if (l == 0.0) {
		w = 1.0;	
		y = z = x = 0.0;
		}
	else {	
		c = 1.0/l;
		x *= c;
		y *= c;
		z *= c;
		w *= c;
		}
	omega = acos(w);
	*ang = (float)(2.0*omega);
	s = sin(omega);	
	if (fabs(s) > 0.000001f)
    {
        axis[0] = (float)(x / s);
        axis[1] = (float)(y / s);
        axis[2] = (float)(z / s);
    }
	else
        axis = Point3(0,0,0); // RB: Added this so axis gets initialized
}


Matrix3
GetLocalTM(INode* node, TimeValue t)
{
    Matrix3 tm;
    tm = node->GetObjTMAfterWSM(t);
#ifdef TEMP_TEST
    if (getworldmat)
        return tm;
#endif
    if (!node->GetParentNode()->IsRootNode()) {
        Matrix3 ip = node->GetParentNode()->GetObjTMAfterWSM(t);
        tm = tm * Inverse(ip);
    }
    return tm;
}

inline float
round(float f)
{
    if (f < 0.0f) {
        if (f > -1.0e-5)
            return 0.0f;
        return f;
    }
    if (f < 1.0e-5)
        return 0.0f;
    return f;
}

void
CommaScan(TCHAR* buf)
{
    for(; *buf; buf++) if (*buf == ',') *buf = '.';
}

TCHAR*
VRML2Export::point(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y));
    CommaScan(buf);
    return buf;
}

TCHAR*
VRML2Export::color(Color& c)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    sprintf(buf, format, round(c.r), round(c.g), round(c.b));
    CommaScan(buf);
    return buf;
}

TCHAR*
VRML2Export::color(Point3& c)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    sprintf(buf, format, round(c.x), round(c.y), round(c.z));
    CommaScan(buf);
    return buf;
}


TCHAR*
VRML2Export::floatVal(float f)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg"), mDigits);
    sprintf(buf, format, round(f));
    CommaScan(buf);
    return buf;
}


TCHAR*
VRML2Export::texture(UVVert& uv)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg"), mDigits, mDigits);
    sprintf(buf, format, round(uv.x), round(uv.y));
    CommaScan(buf);
    return buf;
}

// Format a scale value
TCHAR*
VRML2Export::scalePoint(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round( p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round( p.z), round(p.y));
    CommaScan(buf);
    return buf;
}

// Format a normal vector
TCHAR*
VRML2Export::normPoint(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y));
    CommaScan(buf);
    return buf;
}

// Format an axis value
TCHAR*
VRML2Export::axisPoint(Point3& p, float angle)
{
    if (p == Point3(0., 0., 0.)) 
        p = Point3(1., 0., 0.); // default direction
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg %%.%dg"),
            mDigits, mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z),
                round(angle));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y),
                round(angle));
    CommaScan(buf);
    return buf;
}

// Indent to the given level.
void 
VRML2Export::Indent(int level)
{
    if (!mIndent) return;
    assert(level >= 0);
    for(; level; level--)
        fprintf(mStream, _T("  "));
}
    
// Translates name (if necessary) to VRML compliant name.
// Returns name in static buffer, so calling a second time trashes
// the previous contents.
#define CTL_CHARS      31
#define SINGLE_QUOTE   39
static TCHAR * VRMLName(TCHAR *name)
{
    static char buffer[256];
    static int seqnum = 0;
    TCHAR* cPtr;
    int firstCharacter = 1;

    _tcscpy(buffer, name);
    cPtr = buffer;
    while(*cPtr) {
        if( *cPtr <= CTL_CHARS ||
            *cPtr == ' ' ||
            *cPtr == SINGLE_QUOTE ||
            *cPtr == '"' ||
            *cPtr == '\\' ||
            *cPtr == '{' ||
            *cPtr == '}' ||
            *cPtr == ',' ||            
            *cPtr == '.' ||
            *cPtr == '[' ||
            *cPtr == ']' ||
            *cPtr == '-' ||
            *cPtr == '#' ||
            *cPtr >= 127 ||
            (firstCharacter && (*cPtr >= '0' && *cPtr <= '9'))) *cPtr = '_';
        firstCharacter = 0;
        cPtr++;
    }
    if (firstCharacter) {       // if empty name, quick, make one up!
        *cPtr++ = '_';
        *cPtr++ = '_';
        sprintf(cPtr, "%d", seqnum++);
    }
    
    return buffer;
}

// Write beginning of the Transform node.
void
VRML2Export::StartNode(INode* node, int level, BOOL outputName)
{
    TCHAR *nodnam = mNodes.GetNodeName(node);
    Indent(level);
    fprintf(mStream, _T("DEF %s Transform {\n"), nodnam);
    
    // Put note tracks as info nodes
    int numNotes = node->NumNoteTracks();
    for(int i=0; i < numNotes; i++) {
        DefNoteTrack *nt = (DefNoteTrack*) node->GetNoteTrack(i);
        for (int j = 0; j < nt->keys.Count(); j++) {
            NoteKey* nk = nt->keys[j];
            TSTR note = nk->note;
            if (note.Length() > 0) {
                Indent(level+1);
                fprintf(mStream, _T("#Info { string \"frame %d: %s\" }\n"),
                        nk->time/GetTicksPerFrame(), note.data());
            }
        }
    }
}

// Write end of the Transform node.
void
VRML2Export::EndNode(INode *node, Object* obj, int level, BOOL lastChild)
{
    Indent(level);
    if (lastChild || node->GetParentNode()->IsRootNode())
        fprintf(mStream, _T("}\n"));
    else
        fprintf(mStream, _T("},\n"));    
}

/* test
BOOL
VRML2Export::IsBBoxTrigger(INode* node)
{
    Object * obj = node->EvalWorldState(mStart).obj;
    if (obj->ClassID() != Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2))
        return FALSE;
    MrBlueObject* mbo = (MrBlueObject*) obj;
    return mbo->GetBBoxEnabled();
}
*/

static BOOL
HasPivot(INode* node)
{
    Point3 p = node->GetObjOffsetPos();
    return p.x != 0.0f || p.y != 0.0f || p.z != 0.0f;
}

// Write out the transform from the parent node to this current node.
// Return true if it has a mirror transform
BOOL
VRML2Export::OutputNodeTransform(INode* node, int level, BOOL mirrored)
{
    // Root node is always identity
    if (node->IsRootNode())
        return FALSE;

    Matrix3 tm = GetLocalTM(node, mStart);
    int i, j;
    Point3 p;
    Point3 s, axis;
    Quat q;
    float ang;

    BOOL isIdentity = TRUE;
    for (i=0;i<3;i++) {
        for (j=0;j<3;j++) {
            if (i==j) {
                if (tm.GetRow(i)[j] != 1.0) isIdentity = FALSE;
            } else if (fabs(tm.GetRow(i)[j]) > 0.00001) isIdentity = FALSE;
        }
    }


    if (isIdentity) {
        p = tm.GetTrans();
#ifdef MIRROR_BY_VERTICES
        if (mirrored)
            p = - p;
#endif
        Indent(level);
        fprintf(mStream, _T("translation %s\n"), point(p));
        return FALSE;
    }
    AffineParts parts;
#ifdef DDECOMP
    d_decomp_affine(tm, &parts);
#else
    decomp_affine(tm, &parts);      // parts is parts
#endif
    p = parts.t;
    q = parts.q;
    AngAxisFromQa(q, &ang, axis);
#ifdef MIRROR_BY_VERTICES
        if (mirrored)
            p = - p;
#endif
    Indent(level);
    fprintf(mStream, _T("translation %s\n"), point(p));
    Control*rc = node->GetTMController()->GetRotationController();

    if (ang != 0.0f && ang != -0.0f) {
        Indent(level);
        fprintf(mStream, _T("rotation %s\n"), axisPoint(axis, -ang));
    }
    ScaleValue sv(parts.k, parts.u);
    s = sv.s;
#ifndef MIRROR_BY_VERTICES
    if (parts.f < 0.0f)
        s = - s;            // this is where we mirror by scale
#endif
    if (!(AEQ(s.x, 1.0)) || !(AEQ(s.y, 1.0)) || !(AEQ(s.z, 1.0))) {
        Indent(level);
        fprintf(mStream, _T("scale %s\n"), scalePoint(s));
        q = sv.q;
        AngAxisFromQa(q, &ang, axis);
        if (ang != 0.0f && ang != -0.0f) {
            Indent(level);
            fprintf(mStream, _T("scaleOrientation %s\n"),
                    axisPoint(axis, -ang));
        }
    }
    return parts.f < 0.0f;
}

static BOOL
MeshIsAllOneSmoothingGroup(Mesh& mesh)
{
    return FALSE;           // to put out normals whenever they're called for

    int numfaces = mesh.getNumFaces();
    unsigned int sg;
    int i;

    for(i = 0; i < numfaces; i++) {
        if (i == 0) {
            sg = mesh.faces[i].getSmGroup();
            if (sg == 0)
                return FALSE;
        }
        else {
            if (sg != mesh.faces[i].getSmGroup())
                return FALSE;
        }
    }
    return TRUE;
}

#define CurrentWidth() (mIndent ? 2*level : 0)
#define MAX_WIDTH 60

int
VRML2Export::MaybeNewLine(int width, int level)
{
    if (width > MAX_WIDTH) {
        fprintf(mStream, _T("\n"));
        Indent(level);
        return CurrentWidth();
    }
    return width;
}

void
VRML2Export::OutputNormalIndices(Mesh& mesh, NormalTable* normTab, int level)
{
    Point3 n;
    int numfaces = mesh.getNumFaces();
    int i, j, v, norCnt;
    int width = CurrentWidth();

    Indent(level);
    
    fprintf(mStream, _T("normalIndex [\n"));
    Indent(level+1);
    for (i = 0; i < numfaces; i++) {
        int smGroup = mesh.faces[i].getSmGroup();
        for(v = 0; v < 3; v++) {
            int cv = mesh.faces[i].v[v];
            RVertex * rv = mesh.getRVertPtr(cv);
            if (rv->rFlags & SPECIFIED_NORMAL) {
                n = rv->rn.getNormal();
                continue;
            }
            else if((norCnt = (int)(rv->rFlags & NORCT_MASK)) && smGroup) {
                if (norCnt == 1)
                    n = rv->rn.getNormal();
                else for(j = 0; j < norCnt; j++) {
                    if (rv->ern[j].getSmGroup() & smGroup) {
                        n = rv->ern[j].getNormal();
                        break;
                    }
                }
            } else
                n = mesh.getFaceNormal(i);
            int index = normTab->GetIndex(n);
            assert (index != -1);
            width += fprintf(mStream, _T("%d, "), index);
            width = MaybeNewLine(width, level+1);
        }
        width += fprintf(mStream, _T("-1, "));
        width = MaybeNewLine(width, level+1);
    }
    fprintf(mStream, _T("]\n"));
}

NormalTable*
VRML2Export::OutputNormals(Mesh& mesh, int level)
{
    int i, j, norCnt;
    int numverts = mesh.getNumVerts();
    int numfaces = mesh.getNumFaces();
    NormalTable* normTab;


    mesh.buildRenderNormals();

    if (MeshIsAllOneSmoothingGroup(mesh)) {
        return NULL;
    }

    normTab = new NormalTable();

    // Otherwise we have several smoothing groups
    for(int index = 0; index < numfaces; index++) {
        int smGroup = mesh.faces[index].getSmGroup();
        for(i = 0; i < 3; i++) {
            int cv = mesh.faces[index].v[i];
            RVertex * rv = mesh.getRVertPtr(cv);
            if (rv->rFlags & SPECIFIED_NORMAL) {
                normTab->AddNormal(rv->rn.getNormal());
            }
            else if((norCnt = (int)(rv->rFlags & NORCT_MASK)) && smGroup) {
                if (norCnt == 1)
                    normTab->AddNormal(rv->rn.getNormal());
                else for(j = 0; j < norCnt; j++) {
                    normTab->AddNormal(rv->ern[j].getNormal());
                }
            } else
                normTab->AddNormal(mesh.getFaceNormal(index));
        }
    }

    index = 0;
    NormalDesc* nd;
    Indent(level);
    fprintf(mStream, _T("normal "));
    fprintf(mStream, _T("Normal { vector [\n"));
    int width = CurrentWidth();
    Indent(level+1);

    for(i = 0; i < NORM_TABLE_SIZE; i++) {
        for(nd = normTab->Get(i); nd; nd = nd->next) {
            nd->index = index++;
            Point3 p = nd->n / NUM_NORMS;
            width += fprintf(mStream, _T("%s, "), normPoint(p));
            width = MaybeNewLine(width, level+1);
        }
    }
    fprintf(mStream, _T("] }\n"));

    Indent(level);
    fprintf(mStream, _T("normalPerVertex TRUE\n"));
    
#ifdef DEBUG_NORM_HASH
    normTab->PrintStats(mStream);
#endif

    return normTab;
}

void
VRML2Export::OutputPolygonObject(INode* node, TriObject* obj, BOOL isMulti,
                             BOOL isWire, BOOL twoSided, int level,
                             int textureNum, BOOL pMirror)
{
    assert(obj);
    int width;
    int i, j;
    NormalTable* normTab = NULL;
    TextureDesc* td = NULL;
    BOOL dummy, concave;
    Mesh &mesh = obj->GetMesh();
    int numtverts = mesh.getNumTVerts();
    int numfaces = mesh.getNumFaces();

    PMPoly* poly;
    PMesh polyMesh(obj->GetMesh(), (PType) mPolygonType, numtverts);
#ifdef TEST_MNMESH
    MNMesh mnmesh(obj->mesh);
    mnmesh.MakePolyMesh();
    FILE *mnfile = fopen("mnmesh0.txt", "w");
    fprintf(mnfile, "Vertices:\n");
    for (i = 0; i < mnmesh.VNum(); i++)
        fprintf(mnfile, "  %3d)  %8.3f, %8.3f, %8.3f\n", i,
            mnmesh.P(i).x, mnmesh.P(i).y, mnmesh.P(i).z);
    fprintf(mnfile, "Faces:\n");
    for (i = 0; i < mnmesh.FNum(); i++) {
        fprintf(mnfile, "  ");
        MNFace *mnf = mnmesh.F(i);
        for (j = 0; j < mnf->deg; j++) {
            if (j > 0)
                fprintf(mnfile, ", ");
            fprintf(mnfile, "%3d", mnf->vtx[j]);
        }
        fprintf (mnfile, "\n");
    }
    fclose(mnfile);
#endif
    concave = polyMesh.GenPolygons();

    Mtl* mtl = node->GetMtl();
    if (mtl && mtl->IsMultiMtl() && textureNum != -1)
	{
        if (mtl != NULL)
		{
            mtl = mtl->GetSubMtl(textureNum);
            td = GetMtlTex(mtl, dummy);
        }
    }
	else
	{
		td = GetMatTex(node, dummy);
	}
    
    if (!numfaces)
	{
        delete td;
        return;
    }
    
    Indent(level++);
    if (isWire)
        fprintf(mStream, _T("geometry DEF %s-FACES IndexedLineSet {\n"),
            mNodes.GetNodeName(node));
    else
        fprintf(mStream, _T("geometry DEF %s-FACES IndexedFaceSet {\n"),
                mNodes.GetNodeName(node));

    if (!isWire) {
        Indent(level);
        fprintf(mStream, _T("ccw %s\n"), pMirror ? _T("FALSE") : _T("TRUE"));
        Indent(level);
        fprintf(mStream, _T("solid %s\n"), twoSided ? _T("FALSE") : _T("TRUE"));
        Indent(level);
        fprintf(mStream, _T("convex %s\n"), concave ? _T("FALSE") : _T("TRUE"));
    }

 // color-------
    if (mPreLight)
	{
        if (!mCPVSource) {   // 1 if MAX, 0 if we calc
            ColorTab vxColDiffTab;
            calcMixedVertexColors(node, mStart, LIGHT_SCENELIGHT, vxColDiffTab);
            int numColors = 0;
            int cfaces;

            Color c;
            Indent(level);
            fprintf(mStream, _T("colorPerVertex TRUE\n"));
            Indent(level);
            width = CurrentWidth();
            fprintf(mStream, _T("color Color { color [\n"));
            Indent(level+1);
            cfaces = vxColDiffTab.Count();
            for (i = 0; i < cfaces; i++) {
                c = *((Color*) vxColDiffTab[i]);
                if (i == cfaces - 1) width += fprintf(mStream, _T("%s "), color(c));
                else width += fprintf(mStream, _T("%s, "), color(c));
                width = MaybeNewLine(width, level+1);
            }
            Indent(level);
            fprintf(mStream, _T("] }\n"));

            Indent(level);
            fprintf(mStream, _T("colorIndex [\n"));
            width = CurrentWidth();
            Indent(level+1);
            cfaces = polyMesh.GetPolygonCnt();
         // FIXME need to add colorlist to PMesh
            for (i = 0; i < cfaces; i++) {
                poly = polyMesh.GetPolygon(i);
                for (j = 0; j < poly->GetVIndexCnt(); j++) {
                    width += fprintf(mStream, _T("%d, "),
                                polyMesh.LookUpVert(poly->GetVIndex(j)));
			        width  = MaybeNewLine(width, level+1);
                }
                width += fprintf(mStream, _T("-1"));
		        if (i != polyMesh.GetPolygonCnt() - 1) {
        			width += fprintf(mStream, _T(", "));
			        width = MaybeNewLine(width, level+1);
		        }
	        }
	        fprintf(mStream, _T("]\n"));

            for (i = 0; i < vxColDiffTab.Count(); i++) {
                delete (Color*) vxColDiffTab[i];
            }
            vxColDiffTab.ZeroCount();
            vxColDiffTab.Shrink();
        } else {
            int numCVerts = mesh.getNumVertCol();
            if (numCVerts) {
                VertColor vColor;
                Indent(level);
                fprintf(mStream, _T("colorPerVertex TRUE\n"));
                Indent(level);
                width = CurrentWidth();
                fprintf(mStream, _T("color Color { color [\n"));
                Indent(level+1);

                int nVerts = polyMesh.GetVertexCnt();
                for (i = 0; i < nVerts; i++) {
                    /*
                    for (j = 0; j < poly->GetVIndexCnt(); j++) {
                        width += fprintf(mStream, _T("%d, "),
                                    polyMesh.LookUpVert(poly->GetVIndex(j)));
			            width  = MaybeNewLine(width, level+1);
                    }
                    */
                    int vIndex = polyMesh.LookUpVert(i);

                    if (vIndex > numCVerts) {
                        assert(FALSE);
                        break;
                    }

                    vColor = mesh.vertCol[vIndex];
                    if (i == nVerts - 1)
                        width += fprintf(mStream, _T("%s "), color(vColor));
                    else
                        width += fprintf(mStream, _T("%s, "), color(vColor));
                    width = MaybeNewLine(width, level+1);
                }
                Indent(level);
                fprintf(mStream, _T("] }\n"));

                Indent(level);
                fprintf(mStream, _T("colorIndex [\n"));
                width = CurrentWidth();
                Indent(level+1);
                int cfaces = polyMesh.GetPolygonCnt();
             // FIXME need to add colorlist to PMesh
                for (i = 0; i < cfaces; i++) {
                    poly = polyMesh.GetPolygon(i);
                    for (j = 0; j < poly->GetVIndexCnt(); j++) {
                        width += fprintf(mStream, _T("%d, "),
                                    polyMesh.LookUpVert(poly->GetVIndex(j)));
			            width  = MaybeNewLine(width, level+1);
                    }
                    width += fprintf(mStream, _T("-1"));
		            if (i != polyMesh.GetPolygonCnt() - 1) {
        			        width += fprintf(mStream, _T(", "));
			                width = MaybeNewLine(width, level+1);
		            }
	            }
	            fprintf(mStream, _T("]\n"));
            } else {
                mPreLight = FALSE;
            }
        }
    }

    int numColors = 0;
    if (!mPreLight && isMulti && textureNum == -1)
	{
        Color c;
        Indent(level);
        fprintf(mStream, _T("colorPerVertex FALSE\n"));
        Mtl* sub, * mtl = node->GetMtl();
        assert (mtl->IsMultiMtl());
        int num = mtl->NumSubMtls();
        Indent(level);
        width = CurrentWidth();
     
        fprintf(mStream, _T("color Color { color [\n"));
        Indent(level+1);
        for (i = 0; i < num; i++) {
            sub = mtl->GetSubMtl(i);
            if (!sub) continue;
            numColors++;
            c = sub->GetDiffuse(mStart);
            if (i == num - 1) width += fprintf(mStream, _T("%s "), color(c));
            else width += fprintf(mStream, _T("%s, "), color(c));
            width = MaybeNewLine(width, level+1);
        }
        Indent(level);
        fprintf(mStream, _T("] }\n"));
    }
    
	if (!mPreLight && isMulti && numColors > 0 && textureNum == -1)
	{
        Indent(level);
        fprintf(mStream, _T("colorIndex [\n"));
        width = CurrentWidth();
        Indent(level+1);
        numfaces = polyMesh.GetPolygonCnt();
     // FIXME need to add colorlist to PMesh
        for (i = 0; i < numfaces; i++) {
            poly = polyMesh.GetPolygon(i);
            int matID = mesh.faces[poly->GetTriFace(0)].getMatID();
            matID  = (matID % numColors);
            width += fprintf(mStream, _T("%d"), matID);
            if (i != numfaces - 1) {
                width += fprintf(mStream, _T(", "));
                width  = MaybeNewLine(width, level+1);
            }
        }
        fprintf(mStream, _T("]\n"));
    }
    
 // output coordinate---------
    if (textureNum < 1)
	{
        Indent(level);
        fprintf(mStream, _T("coord DEF %s-COORD Coordinate { point [\n"),
                mNodes.GetNodeName(node));
        width = CurrentWidth();
        Indent(level+1);
        for (i = 0; i < polyMesh.GetVertexCnt(); i++) {
            Point3 p = polyMesh.GetVertex(i);
#ifdef MIRROR_BY_VERTICES
            if (pMirror)
                p = - p;
#endif
            width += fprintf(mStream, _T("%s"), point(p));
            if (i == polyMesh.GetVertexCnt() - 1) {
                fprintf(mStream, _T("]\n"));
                Indent(level);
                fprintf(mStream, _T("}\n"));
            } else {
                width += fprintf(mStream, _T(", "));
                width = MaybeNewLine(width, level+1);
            }
        }
    }
	else
	{
        Indent(level);
        fprintf(mStream, _T("coord USE %s-COORD\n"),
                mNodes.GetNodeName(node));
    }

    Indent(level);
	fprintf(mStream, _T("coordIndex [\n"));
	Indent(level+1);
    width = CurrentWidth();
    for (i = 0; i < polyMesh.GetPolygonCnt(); i++)
	{
        poly = polyMesh.GetPolygon(i);
        for (j = 0; j < poly->GetVIndexCnt(); j++)
		{
            width += fprintf(mStream, _T("%d, "), polyMesh.LookUpVert(poly->GetVIndex(j)));
			width  = MaybeNewLine(width, level+1);
        }
        width += fprintf(mStream, _T("-1"));
		if (i != polyMesh.GetPolygonCnt() - 1)
		{
			width += fprintf(mStream, _T(", "));
			width = MaybeNewLine(width, level+1);
		}
	}
	fprintf(mStream, _T("]\n"));

 // Output Texture coordinates
	if (numtverts > 0/* && (td || textureNum == 0)*/ && !isWire)
	{
		if (textureNum < 1)
		{
			Indent(level);
			fprintf(mStream, _T("texCoord DEF %s-TEXCOORD TextureCoordinate { point [\n"), 
				mNodes.GetNodeName(node));

			width = CurrentWidth();
			Indent(level+1);
			for (i = 0; i < polyMesh.GetTVertexCnt(); i++)
			{
				UVVert t = polyMesh.GetTVertex(i);
				width += fprintf(mStream, _T("%s"), texture(t));
				if (i == polyMesh.GetTVertexCnt() - 1)
				{
					fprintf(mStream, _T("]\n"));
					Indent(level);
					fprintf(mStream, _T("}\n"));
				}
				else
				{
					width += fprintf(mStream, _T(", "));
					width = MaybeNewLine(width, level+1);
				}
			}
		}
		else
		{
			Indent(level);
			fprintf(mStream, _T("texCoord USE %s-TEXCOORD\n"), mNodes.GetNodeName(node));
		}
	}

    if (numtverts > 0 && td && !isWire)
	{
        Indent(level);
	    fprintf(mStream, _T("texCoordIndex [\n"));
	    Indent(level+1);
        width = CurrentWidth();
        int tmp = polyMesh.GetPolygonCnt();
        //for (i = 0; i < polyMesh.GetPolygonCnt(); i++) {
        for (i = 0; i < tmp; i++) {
            poly = polyMesh.GetPolygon(i);
            int tmp1 = poly->GetTVIndexCnt();
            //for (j = 0; j < poly->GetTVIndexCnt(); j++) {
            for (j = 0; j < tmp1; j++) {
                int tmp2 = poly->GetTVIndex(j);
                int tmp3 = polyMesh.LookUpTVert(tmp2);
			    width += fprintf(mStream, _T("%d, "),
                                //polyMesh.LookUpTVert(poly->GetTVIndex(j)));
                                tmp3);
			    width  = MaybeNewLine(width, level+1);
		    }
		    width += fprintf(mStream, _T("-1"));
		    if (i != polyMesh.GetPolygonCnt() - 1) {
		    	width += fprintf(mStream, _T(", "));
			    width = MaybeNewLine(width, level+1);
		    }
	    }
	    fprintf(mStream, _T("]\n"));
    }
    
 // output normals
    if (mGenNormals && !isWire && !MeshIsAllOneSmoothingGroup(mesh))
	{
        NormalTable* normTab = NULL;
        normTab = new NormalTable();
    
        for (j = 0; j < polyMesh.GetPolygonCnt(); j++)
		{
            //Point3 n = polyMesh.GetPolygon(j)->GetFNormal();
            for (int k = 0; k < polyMesh.GetPolygon(j)->GetVNormalCnt(); k++)
			{
                Point3 n = polyMesh.GetPolygon(j)->GetVNormal(k);
                normTab->AddNormal(n);
            }
        }
        
        Indent(level);
        fprintf(mStream, _T("normalPerVertex TRUE\n"));
        int index = 0;
        NormalDesc* nd;
        Indent(level);
        fprintf(mStream, _T("normal "));
        fprintf(mStream, _T("Normal { vector [\n"));
        width = CurrentWidth();
        Indent(level+1);
/*
        for (i = 0; i < polyMesh.GetPolygonCnt(); i++) {
            Point3 n = polyMesh.GetPolygon(i)->GetFNormal();
            normTab->AddNormal(n);
            width += fprintf(mStream, _T("%s, "), normPoint(n));
			width  = MaybeNewLine(width, level+1);
		}
*/

        for (i = 0; i < NORM_TABLE_SIZE; i++)
		{
            for (nd = normTab->Get(i); nd; nd = nd->next)
			{
                nd->index = index++;
                Point3 n  = nd->n / NUM_NORMS;
                width    += fprintf(mStream, _T("%s, "), normPoint(n));
			    width     = MaybeNewLine(width, level+1);
            }
		}
        fprintf(mStream, _T("] }\n"));
    
        Indent(level);
        width = CurrentWidth();
        fprintf(mStream, _T("normalIndex [\n"));
        Indent(level+1);
        width = CurrentWidth();
      
        for (i = 0; i < polyMesh.GetPolygonCnt(); i++)
		{
            int index;
            for (int k = 0; k < polyMesh.GetPolygon(i)->GetVNormalCnt(); k++)
			{
                Point3 n = polyMesh.GetPolygon(i)->GetVNormal(k);
                index    = normTab->GetIndex(n);
                width   += fprintf(mStream, _T("%d, "), index);
			    width    = MaybeNewLine(width, level+1);
		    }
		    width += fprintf(mStream, _T("-1, "));
		    width = MaybeNewLine(width, level+1);
	    }
        normTab->PrintStats(mStream);

	    fprintf(mStream, _T("]\n"));  
    
        delete normTab;
    }

    Indent(level);
    fprintf(mStream, _T("}\n"));
    delete td;
}

// Write out the data for a single triangle mesh
void
VRML2Export::OutputTriObject(INode* node, TriObject* obj, BOOL isMulti,
                             BOOL isWire, BOOL twoSided, int level,
                             int textureNum, BOOL pMirror)
{
    assert(obj);
    Mesh &mesh = obj->GetMesh();
    int numverts = mesh.getNumVerts();
    int numtverts = mesh.getNumTVerts();
    int numfaces = mesh.getNumFaces();
    int i, width;
    NormalTable* normTab = NULL;
    TextureDesc* td = NULL;
    BOOL dummy;

    Mtl *mtl = node->GetMtl();
    if (mtl && mtl->IsMultiMtl() && textureNum != -1) {
        if (mtl != NULL) {
            mtl = mtl->GetSubMtl(textureNum);
            td = GetMtlTex(mtl, dummy);
        }
    } else
        td = GetMatTex(node, dummy);
    
    if (numfaces == 0) {
        delete td;
        return;
    }
    
    Indent(level++);
    if (isWire)
        fprintf(mStream, _T("geometry DEF %s-FACES IndexedLineSet {\n"), mNodes.GetNodeName(node));
    else
        fprintf(mStream, _T("geometry DEF %s-FACES IndexedFaceSet {\n"), mNodes.GetNodeName(node));

    if (!isWire) {
        Indent(level);
        fprintf(mStream, _T("ccw %s\n"), pMirror ? _T("FALSE") : _T("TRUE"));
        Indent(level);
        fprintf(mStream, _T("solid %s\n"),
                            twoSided ? _T("FALSE") : _T("TRUE"));
    }

    if (mPreLight) {
        if (!mCPVSource) {  // 1 if MAX, 0 if we calc
            ColorTab vxColDiffTab;
            calcMixedVertexColors(node, mStart, LIGHT_SCENELIGHT, vxColDiffTab);
            int numColors = 0;
            int cfaces;
            Color c;
            Indent(level);
            fprintf(mStream, _T("colorPerVertex TRUE\n"));
            Indent(level);
            width = CurrentWidth();
            fprintf(mStream, _T("color Color { color [\n"));
            Indent(level+1);
            cfaces = vxColDiffTab.Count();
            for (i = 0; i < cfaces; i++) {
                c = *((Color*) vxColDiffTab[i]);
                if (i == cfaces - 1) width += fprintf(mStream, _T("%s "), color(c));
                else width += fprintf(mStream, _T("%s, "), color(c));
                width = MaybeNewLine(width, level+1);
            }
            Indent(level);
            fprintf(mStream, _T("] }\n"));

            Indent(level);
            fprintf(mStream, _T("colorIndex [\n"));
            width = CurrentWidth();
            Indent(level+1);

            for (i = 0; i < numfaces; i++) {
                width += fprintf(mStream, _T("%d, %d, %d, -1"),
                            mesh.faces[i].v[0], mesh.faces[i].v[1],
                            mesh.faces[i].v[2]);
                if (i != numfaces-1) {
                    width += fprintf(mStream, _T(", "));
                    width = MaybeNewLine(width, level+1);
                }
	        }
	        fprintf(mStream, _T("]\n"));

            for (i = 0; i < vxColDiffTab.Count(); i++) {
                delete (Color*) vxColDiffTab[i];
            }
            vxColDiffTab.ZeroCount();
            vxColDiffTab.Shrink();
        } else {
            int numCVerts = mesh.getNumVertCol();
            if (numCVerts) {
                VertColor vColor;
                Indent(level);
                fprintf(mStream, _T("colorPerVertex TRUE\n"));
                Indent(level);
                width = CurrentWidth();
                fprintf(mStream, _T("color Color { color [\n"));
                Indent(level+1);
             // FIXME need to add colorlist to PMesh
                for (i = 0; i < numverts; i++) {
                    vColor = mesh.vertCol[i];
                    if (i == numverts - 1)
                        width += fprintf(mStream, _T("%s "), color(vColor));
                    else
                        width += fprintf(mStream, _T("%s, "), color(vColor));
                    width = MaybeNewLine(width, level+1);
                }
                Indent(level);
                fprintf(mStream, _T("] }\n"));

                Indent(level);
                fprintf(mStream, _T("colorIndex [\n"));
                width = CurrentWidth();
                Indent(level+1);

                for (i = 0; i < numfaces; i++) {
					int id = mesh.faces[i].getMatID();
					if (textureNum == -1 || id == textureNum) {
						if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
							width += fprintf(mStream, _T("%d, %d, %d, -1"),
									mesh.faces[i].v[0], mesh.faces[i].v[1],
									mesh.faces[i].v[2]);
							if (i != numfaces-1) {
								width += fprintf(mStream, _T(", "));
								width = MaybeNewLine(width, level+1);
							}
						}
                    }
	            }
	            fprintf(mStream, _T("]\n"));

            } else {
                mPreLight = FALSE;
            }
        }
    }

    int numColors = 0;
    if (!mPreLight && isMulti && textureNum == -1) {
        Color c;
        Indent(level);
        fprintf(mStream, _T("colorPerVertex FALSE\n"));
        Mtl *sub, *mtl = node->GetMtl();
        assert (mtl->IsMultiMtl());
        int num = mtl->NumSubMtls();
        Indent(level);
        width = CurrentWidth();
        fprintf(mStream, _T("color Color { color [\n"));
        Indent(level+1);
        for(i = 0; i < num; i++) {
            sub = mtl->GetSubMtl(i);
            if (!sub)
                continue;
            numColors++;
            c = sub->GetDiffuse(mStart);
            if (i == num - 1)
                width += fprintf(mStream, _T("%s "), color(c));
            else
                width += fprintf(mStream, _T("%s, "), color(c));
            width = MaybeNewLine(width, level+1);
        }
        Indent(level);
        fprintf(mStream, _T("] }\n"));
    }

    if (textureNum < 1) {
        // Output the vertices
        Indent(level);
        fprintf(mStream, _T("coord DEF %s-COORD Coordinate { point [\n"),mNodes.GetNodeName(node));
        
        width = CurrentWidth();
        Indent(level+1);
        for(i = 0; i < numverts; i++) {
            Point3 p = mesh.verts[i];
#ifdef MIRROR_BY_VERTICES
            if (pMirror)
                p = - p;
#endif
            width += fprintf(mStream, _T("%s"), point(p));
            if (i == numverts-1) {
                fprintf(mStream, _T("]\n"));
                Indent(level);
                fprintf(mStream, _T("}\n"));
            }
            else {
                width += fprintf(mStream, _T(", "));
                width = MaybeNewLine(width, level+1);
            }
        }
    } else {
        Indent(level);
        fprintf(mStream, _T("coord USE %s-COORD\n"),mNodes.GetNodeName(node));
    }
    // Output the normals
    // FIXME share normals on multi-texture objects
    if (mGenNormals && !isWire) {
        normTab = OutputNormals(mesh, level);
    }

    // Output Texture coordinates
    if (numtverts > 0 && (td || textureNum == 0) && !isWire) {
        if (textureNum < 1) {
            Indent(level);
            fprintf(mStream,
                _T("texCoord DEF %s-TEXCOORD TextureCoordinate { point [\n"),mNodes.GetNodeName(node));
            width = CurrentWidth();
            Indent(level+1);
            for(i = 0; i < numtverts; i++) {
                Point3 uvw = mesh.tVerts[i];
                UVVert p = mesh.getTVert(i);
                width += fprintf(mStream, _T("%s"), texture(p));
                if (i == numtverts-1) {
                    fprintf(mStream, _T("]\n"));
                    Indent(level);
                    fprintf(mStream, _T("}\n"));
                }
                else {
                    width += fprintf(mStream, _T(", "));
                    width = MaybeNewLine(width, level+1);
                }
            }
        } else {
            Indent(level);
            fprintf(mStream, _T("texCoord USE %s-TEXCOORD\n"),mNodes.GetNodeName(node));
        }
    }
        
    // Output the triangles
    Indent(level);
    fprintf(mStream, _T("coordIndex [\n"));
    Indent(level+1);
    width = CurrentWidth();
    for(i = 0; i < numfaces; i++) {
        int id = mesh.faces[i].getMatID();
        if (textureNum == -1 || id == textureNum) {
            if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
                width += fprintf(mStream, _T("%d, %d, %d, -1"),
                                 mesh.faces[i].v[0], mesh.faces[i].v[1],
                                 mesh.faces[i].v[2]);
                if (i != numfaces-1) {
                    width += fprintf(mStream, _T(", "));
                    width = MaybeNewLine(width, level+1);
                }
            }
        }
    }
    fprintf(mStream, _T("]\n"));

    if (numtverts > 0 && td && !isWire) {
        Indent(level);
        fprintf(mStream, _T("texCoordIndex [\n"));
        Indent(level+1);
        width = CurrentWidth();
        for(i = 0; i < numfaces; i++) {
            int id = mesh.faces[i].getMatID();
            if (textureNum == -1 || id == textureNum) {
                if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
                    width += fprintf(mStream, _T("%d, %d, %d, -1"),
                                     mesh.tvFace[i].t[0], mesh.tvFace[i].t[1],
                                     mesh.tvFace[i].t[2]);
                    if (i != numfaces-1) {
                        width += fprintf(mStream, _T(", "));
                        width = MaybeNewLine(width, level+1);
                    }
                }
            }
        }
        fprintf(mStream, _T("]\n"));
    }

    if (!mPreLight && isMulti && numColors > 0 && textureNum == -1) {
        Indent(level);
        fprintf(mStream, _T("colorIndex [\n"));
        width = CurrentWidth();
        Indent(level+1);
        for(i = 0; i < numfaces; i++) {
            if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
                int id = mesh.faces[i].getMatID();
                id = (id % numColors);   // this is the way MAX does it
                /*
                if (id >= numColors)
                    id = 0;
                */
                width += fprintf(mStream, _T("%d"), id);
                if (i != numfaces-1) {
                    width += fprintf(mStream, _T(", "));
                    width = MaybeNewLine(width, level+1);
                }
            }
        }
        fprintf(mStream, _T("]\n"));
    }
    if (mGenNormals && normTab && !isWire) {
        OutputNormalIndices(mesh, normTab, level);
        delete normTab;
    }
        
    Indent(level);
    fprintf(mStream, _T("}\n"));
    delete td;

}

BOOL
VRML2Export::HasTexture(INode* node, BOOL &isWire)
{
    TextureDesc* td = GetMatTex(node, isWire);
    if (!td)
        return FALSE;
    delete td;
    return TRUE;
}

TSTR
VRML2Export::PrefixUrl(TSTR& fileName)
{
    if (mUsePrefix && mUrlPrefix.Length() > 0) {
        if (mUrlPrefix[mUrlPrefix.Length() - 1] != '/') {
            TSTR slash = "/";
            return mUrlPrefix + slash + fileName;
        } else
            return mUrlPrefix + fileName;
    }
    else
        return fileName;
}
    
// Get the name of the texture file
TextureDesc*
VRML2Export::GetMatTex(INode* node, BOOL& isWire)
{
    Mtl* mtl = node->GetMtl();
    return GetMtlTex(mtl, isWire);
}


TextureDesc*
VRML2Export::GetMtlTex(Mtl* mtl, BOOL& isWire)
{
    if (!mtl)
        return NULL;

    
    if (mtl->ClassID() != Class_ID(DMTL_CLASS_ID, 0))
        return NULL;

    StdMat* sm = (StdMat*) mtl;

    isWire = sm->GetWire();

    // Check for texture map
    Texmap* tm = (BitmapTex*) sm->GetSubTexmap(ID_DI);
    if (!tm)
        return NULL;

    if (tm->ClassID() != Class_ID(BMTEX_CLASS_ID, 0))
        return NULL;
    BitmapTex* bm = (BitmapTex*) tm;

    TSTR bitmapFile;
    TSTR fileName;

    bitmapFile = bm->GetMapName();
    if (bitmapFile.data() == NULL)
        return NULL;
    int l = strlen(bitmapFile)-1;
    if (l < 0)
        return NULL;
    
    TSTR path;
    SplitPathFile(bitmapFile, &path, &fileName);

    TSTR url = PrefixUrl(fileName);
    TextureDesc* td = new TextureDesc(bm, fileName, url);
    return td;
}

BOOL
VRML2Export::OutputMaterial(INode* node, BOOL& isWire, BOOL& twoSided,
                            int level, int textureNum)
{
    Mtl* mtl = node->GetMtl();
    BOOL isMulti = FALSE;
    isWire = FALSE;
    twoSided = FALSE;

    Indent(level++);
    fprintf(mStream, _T("appearance Appearance {\n"));

    if (mtl && mtl->IsMultiMtl()) {
        if (textureNum > -1)
            mtl = mtl->GetSubMtl(textureNum);
        else
            mtl = mtl->GetSubMtl(0);
        isMulti = TRUE;
        // Use first material for specular, etc.
    }

    // If no material is assigned, use the wire color
    if (!mtl || (mtl->ClassID() != Class_ID(DMTL_CLASS_ID, 0) &&
                 mtl->ClassID() != Class_ID(0x3e0810d6, 0x603532f0))) {
        Color col(node->GetWireColor());
        Indent(level);
        fprintf(mStream, _T("material "));
        fprintf(mStream, _T("Material {\n"));
        Indent(level+1);
        fprintf(mStream, _T("diffuseColor %s\n"), color(col));
//        Indent(level+1);
//        fprintf(mStream, _T("specularColor .9 .9 .9\n"));
//        fprintf(mStream, _T("specularColor %s\n"), color(col));
        Indent(level);
        fprintf(mStream, _T("}\n"));
        Indent(--level);
        fprintf(mStream, _T("}\n"));
        return FALSE;
    }

    StdMat* sm = (StdMat*) mtl;
    isWire = sm->GetWire();
    twoSided = sm->GetTwoSided();

    Interval i = FOREVER;
    sm->Update(0, i);

	// BLOCK: xbox
	{
		Indent(level);
		fprintf(mStream, _T("material MaxMaterial { name \"%s\" }\n"), mtl->GetName());
	}

#if 0 // xbox
    Indent(level);
    fprintf(mStream, _T("material Material {\n"));
    Color c;

    Indent(level+1);
    c = sm->GetDiffuse(mStart);
    fprintf(mStream, _T("diffuseColor %s\n"), color(c));
#if 1
    Indent(level+1);
    c = sm->GetAmbient(mStart);
    fprintf(mStream, _T("ambientIntensity %s\n"), floatVal((c.r+c.g+c.b)/3.0f));
    Indent(level+1);
    c = sm->GetSpecular(mStart);
    c *= sm->GetShinStr(mStart);
    fprintf(mStream, _T("specularColor %s\n"), color(c));
#endif
    float sh = sm->GetShininess(mStart);
    sh = sh * 0.95f + 0.05f;
    Indent(level+1);
    fprintf(mStream, _T("shininess %s\n"), floatVal(sh));
    Indent(level+1);
    fprintf(mStream, _T("transparency %s\n"),
            floatVal(1.0f - sm->GetOpacity(mStart)));
    float si = sm->GetSelfIllum(mStart);
    if (si > 0.0f) {
        Indent(level+1);
        c = sm->GetDiffuse(mStart);
        Point3 p = si*Point3(c.r, c.g, c.b);
        fprintf(mStream, _T("emissiveColor %s\n"), color(p));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
#endif

    if (isMulti && textureNum == -1) {
        Indent(--level);
        fprintf(mStream, _T("}\n"));
        return TRUE;
    }

    BOOL dummy;
    TextureDesc* td = GetMtlTex(mtl, dummy);
    if (!td) {
        Indent(--level);
        fprintf(mStream, _T("}\n"));
        return FALSE;
    }

    Indent(level);
    fprintf(mStream, _T("texture ImageTexture {\n"));
    Indent(level+1);
    fprintf(mStream, _T("url \"%s\"\n"), td->url);
    // fprintf(mStream, _T("repeatS TRUE\n"));
    // fprintf(mStream, _T("repeatT TRUE\n"));
    Indent(level);
    fprintf(mStream, _T("}\n"));

    BitmapTex* bm = td->tex;
    delete td;

    StdUVGen* uvGen = bm->GetUVGen();
    if (!uvGen)
        return FALSE;

    float uOff = uvGen->GetUOffs(mStart);
    float vOff = uvGen->GetVOffs(mStart);
    float uScl = uvGen->GetUScl(mStart);
    float vScl = uvGen->GetVScl(mStart);
    float ang =  uvGen->GetAng(mStart);

    if (uOff == 0.0f && vOff == 0.0f && uScl == 1.0f && vScl == 1.0f &&
        ang == 0.0f) {
        Indent(--level);
        fprintf(mStream, _T("}\n"));
        return FALSE;
    }

    Indent(level);
    fprintf(mStream, _T("textureTransform TextureTransform {\n"));
    Indent(level+1);
    fprintf(mStream, _T("center 0.5 0.5\n"));
    if (uOff != 0.0f || vOff != 0.0f) {
        Indent(level+1);
        UVVert uv = UVVert(uOff+0.5f, vOff+0.5f, 0.0f);
        fprintf(mStream, _T("translation %s\n"), texture(uv));
    }
    if (ang != 0.0f) {
        Indent(level+1);
        fprintf(mStream, _T("rotation %s\n"), floatVal(ang));
    }
    if (uScl != 1.0f || vScl != 1.0f) {
        Indent(level+1);
        UVVert uv = UVVert(uScl, vScl, 0.0f);
        fprintf(mStream, _T("scale %s\n"), texture(uv));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));

    Indent(--level);
    fprintf(mStream, _T("}\n"));
    return FALSE;
}

BOOL
VRML2Export::VrmlOutSphereTest(INode * node, Object *obj)
{
    SimpleObject* so = (SimpleObject*) obj;
    float hemi;
    int basePivot, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject "base pivot" mapped, non-smoothed and hemisphere spheres
    so->pblock->GetValue(SPHERE_RECENTER, mStart, basePivot, FOREVER);
    so->pblock->GetValue(SPHERE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(SPHERE_HEMI, mStart, hemi, FOREVER);
    so->pblock->GetValue(SPHERE_SMOOTH, mStart, smooth, FOREVER);
    if (!smooth || basePivot || (genUV && td) || hemi > 0.0f)
        return FALSE;
    return TRUE;
}

BOOL
VRML2Export::VrmlOutSphere(INode * node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius, hemi;
    int basePivot, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject "base pivot" mapped, non-smoothed and hemisphere spheres
    so->pblock->GetValue(SPHERE_RECENTER, mStart, basePivot, FOREVER);
    so->pblock->GetValue(SPHERE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(SPHERE_HEMI, mStart, hemi, FOREVER);
    so->pblock->GetValue(SPHERE_SMOOTH, mStart, smooth, FOREVER);
    if (!smooth || basePivot || (genUV && td) || hemi > 0.0f)
        return FALSE;

    so->pblock->GetValue(SPHERE_RADIUS, mStart, radius, FOREVER);
    
    Indent(level);

    fprintf(mStream, _T("geometry "));
    
    fprintf(mStream, _T("Sphere { radius %s }\n"), floatVal(radius));
 
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCylinderTest(INode* node, Object *obj)
{
    SimpleObject* so = (SimpleObject*) obj;
    int sliceOn, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject sliced, non-smooth and mapped cylinders
    so->pblock->GetValue(CYLINDER_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CYLINDER_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CYLINDER_SMOOTH, mStart, smooth, FOREVER);
    if (sliceOn || (genUV && td) || !smooth)
        return FALSE;
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCylinderTform(INode* node, Object *obj, int level,
                                  BOOL mirrored)
{
    if (!VrmlOutCylinderTest(node, obj))
        return FALSE;

    float height;
    SimpleObject* so = (SimpleObject*) obj;
    so->pblock->GetValue(CYLINDER_HEIGHT, mStart, height, FOREVER);
#ifdef MIRROR_BY_VERTICES
    if (mirrored)
        height = - height;
#endif

    Indent(level);
    fprintf(mStream, _T("Transform {\n"));
    if (mZUp) {
        Indent(level+1);
        fprintf(mStream, _T("rotation 1 0 0 %s\n"),
                floatVal(float(PI/2.0)));
        Indent(level+1);
        fprintf(mStream, _T("translation 0 0 %s\n"),
                floatVal(float(height/2.0)));
    } else {
        Point3 p = Point3(0.0f, 0.0f, height/2.0f);
        Indent(level+1);
        fprintf(mStream, _T("translation %s\n"), point(p));
    }
    Indent(level+1);
    fprintf(mStream, _T("children [\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCylinder(INode* node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius, height;
    int sliceOn, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject sliced, non-smooth and mapped cylinders
    so->pblock->GetValue(CYLINDER_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CYLINDER_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CYLINDER_SMOOTH, mStart, smooth, FOREVER);
    if (sliceOn || (genUV && td) || !smooth)
        return FALSE;

    so->pblock->GetValue(CYLINDER_RADIUS, mStart, radius, FOREVER);
    so->pblock->GetValue(CYLINDER_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    fprintf(mStream, _T("geometry "));
    fprintf(mStream, _T("Cylinder { radius %s "), floatVal(radius));
    fprintf(mStream, _T("height %s }\n"), floatVal(float(fabs(height))));
    
    return TRUE;
}

BOOL
VRML2Export::VrmlOutConeTest(INode* node, Object *obj)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius2;
    int sliceOn, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject sliced, non-smooth and mappeded cylinders
    so->pblock->GetValue(CONE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CONE_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CONE_SMOOTH, mStart, smooth, FOREVER);
    so->pblock->GetValue(CONE_RADIUS2, mStart, radius2, FOREVER);
    if (sliceOn || (genUV &&td) || !smooth || radius2 > 0.0f)
        return FALSE;
    return TRUE;
}

BOOL
VRML2Export::VrmlOutConeTform(INode* node, Object *obj, int level,
                              BOOL mirrored)
{
    if (!VrmlOutConeTest(node, obj))
        return FALSE;
    Indent(level);
    fprintf(mStream, _T("Transform {\n"));

    float height;
    SimpleObject* so = (SimpleObject*) obj;
    so->pblock->GetValue(CONE_HEIGHT, mStart, height, FOREVER);
#ifdef MIRROR_BY_VERTICES
    if (mirrored)
        height = - height;
#endif

    if (mZUp) {
        Indent(level+1);
        if (height > 0.0f)
            fprintf(mStream, _T("rotation 1 0 0 %s\n"),
                    floatVal(float(PI/2.0)));
        else
            fprintf(mStream, _T("rotation 1 0 0 %s\n"),
                    floatVal(float(-PI/2.0)));
        Indent(level+1);
        fprintf(mStream, _T("translation 0 0 %s\n"),
                floatVal(float(fabs(height)/2.0)));
    } else {
        Point3 p = Point3(0.0f, 0.0f, (float)height/2.0f);
        if (height < 0.0f) {
            Indent(level+1);
            fprintf(mStream, _T("rotation 1 0 0 %s\n"),
                    floatVal(float(PI)));
        }
        Indent(level+1);
        fprintf(mStream, _T("translation %s\n"), point(p));
    }

    Indent(level+1);
    fprintf(mStream, _T("children [\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCone(INode* node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius1, radius2, height;
    int sliceOn, genUV, smooth;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    // Reject sliced, non-smooth and mappeded cylinders
    so->pblock->GetValue(CONE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CONE_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CONE_SMOOTH, mStart, smooth, FOREVER);
    so->pblock->GetValue(CONE_RADIUS2, mStart, radius2, FOREVER);
    if (sliceOn || (genUV &&td) || !smooth || radius2 > 0.0f)
        return FALSE;

    so->pblock->GetValue(CONE_RADIUS1, mStart, radius1, FOREVER);
    so->pblock->GetValue(CONE_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    
    fprintf(mStream, _T("geometry "));

    fprintf(mStream, _T("Cone { bottomRadius %s "), floatVal(radius1));
    fprintf(mStream, _T("height %s }\n"), floatVal(float(fabs(height))));
    
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCubeTest(INode* node, Object *obj)
{
    Mtl* mtl = node->GetMtl();
    // Multi materials need meshes
    if (mtl && mtl->IsMultiMtl())
        return FALSE;

    SimpleObject* so = (SimpleObject*) obj;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    int genUV, lsegs, wsegs, hsegs;
    so->pblock->GetValue(BOXOBJ_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(BOXOBJ_LSEGS,  mStart, lsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_WSEGS,  mStart, hsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_HSEGS,  mStart, wsegs, FOREVER);
    if ((genUV && td) || lsegs > 1 || hsegs > 1 || wsegs > 1)
        return FALSE;

    return TRUE;
}

BOOL
VRML2Export::VrmlOutCubeTform(INode* node, Object *obj, int level,
                              BOOL mirrored)
{
    if (!VrmlOutCubeTest(node, obj))
        return FALSE;
    Indent(level);
    fprintf(mStream, _T("Transform {\n"));

    float height;
    SimpleObject* so = (SimpleObject*) obj;
    so->pblock->GetValue(BOXOBJ_HEIGHT, mStart, height, FOREVER);
#ifdef MIRROR_BY_VERTICES
    if (mirrored)
        height = - height;
#endif

    Point3 p = Point3(0.0f,0.0f,height/2.0f);
    // VRML cubes grow from the middle, MAX grows from z=0
    Indent(level+1);
    fprintf(mStream, _T("translation %s\n"), point(p));

    Indent(level+1);
    fprintf(mStream, _T("children [\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutCube(INode* node, Object *obj, int level)
{
    Mtl* mtl = node->GetMtl();
    // Multi materials need meshes
    if (mtl && mtl->IsMultiMtl())
        return FALSE;

    SimpleObject* so = (SimpleObject*) obj;
    float length, width, height;
    BOOL isWire = FALSE;
    BOOL td = HasTexture(node, isWire);

    if (isWire)
        return FALSE;

    int genUV, lsegs, wsegs, hsegs;
    so->pblock->GetValue(BOXOBJ_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(BOXOBJ_LSEGS,  mStart, lsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_WSEGS,  mStart, hsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_HSEGS,  mStart, wsegs, FOREVER);
    if ((genUV && td) || lsegs > 1 || hsegs > 1 || wsegs > 1)
        return FALSE;

    so->pblock->GetValue(BOXOBJ_LENGTH, mStart, length, FOREVER);
    so->pblock->GetValue(BOXOBJ_WIDTH, mStart,  width,  FOREVER);
    so->pblock->GetValue(BOXOBJ_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    fprintf(mStream, _T("geometry "));
    if (mZUp) {
        fprintf(mStream, _T("Box { size %s "),
                floatVal(float(fabs(width))));
        fprintf(mStream, _T("%s "),
                floatVal(float(fabs(length))));
        fprintf(mStream, _T("%s }\n"),
                floatVal(float(fabs(height))));
    } else {
        fprintf(mStream, _T("Box { size %s "),
                floatVal(float(fabs(width))));
        fprintf(mStream, _T("%s "),
                floatVal(float(fabs(height))));
        fprintf(mStream, _T("%s }\n"),
                floatVal(float(fabs(length))));
    }

    return TRUE;
}

#define INTENDED_ASPECT_RATIO 1.3333

BOOL
VRML2Export::VrmlOutCamera(INode* node, Object* obj, int level)
{
    // Code stolen from render/rend.cpp

    // compute camera transform
    ViewParams vp;
    CameraState cs;
    Interval iv;
    CameraObject *cam = (CameraObject *)obj;
    cam->EvalCameraState(0, iv, &cs);
    vp.fov = (float)(2.0 * atan(tan(cs.fov / 2.0) / INTENDED_ASPECT_RATIO));

    Indent(level);
    fprintf(mStream, _T("DEF %s Viewpoint {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("position 0 0 0\n"));
    Indent(level+1);
    fprintf(mStream, _T("fieldOfView %s\n"), floatVal(vp.fov));
    Indent(level);
    fprintf(mStream, _T("}\n"));

    return TRUE;
}

#define FORDER(A, B) if (B < A) { float fOO = A; A = B; B = fOO; }

BOOL
VRML2Export::VrmlOutSound(INode* node, SoundObject* obj, int level)
{
    float intensity, priority, minBack, maxBack, minFront, maxFront;
    int spatialize;
    
    obj->pblock->GetValue(PB_SND_INTENSITY, mStart, intensity, FOREVER);
    obj->pblock->GetValue(PB_SND_PRIORITY, mStart, priority, FOREVER);
    obj->pblock->GetValue(PB_SND_SPATIALIZE, mStart, spatialize, FOREVER);
    obj->pblock->GetValue(PB_SND_MIN_BACK, mStart, minBack, FOREVER);
    obj->pblock->GetValue(PB_SND_MAX_BACK, mStart, maxBack, FOREVER);
    obj->pblock->GetValue(PB_SND_MIN_FRONT, mStart, minFront, FOREVER);
    obj->pblock->GetValue(PB_SND_MAX_FRONT, mStart, maxFront, FOREVER);

    Point3 dir(0, -1, 0);

    FORDER(minBack, maxBack);
    FORDER(minFront, maxFront);
    if (minFront < minBack) {
        float temp = minFront;
        minFront = minBack;
        minBack = temp;
        temp = maxFront;
        maxFront = maxBack;
        maxBack = temp;
        dir = - dir;
    }

    Indent(level);
    fprintf(mStream, _T("DEF %s Sound {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("direction %s\n"), point(dir));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"), floatVal(intensity));
    Indent(level+1);
    fprintf(mStream, _T("location 0 0 0\n"));
    Indent(level+1);
    fprintf(mStream, _T("maxBack %s\n"), floatVal(maxBack));
    Indent(level+1);
    fprintf(mStream, _T("maxFront %s\n"), floatVal(maxFront));
    Indent(level+1);
    fprintf(mStream, _T("minBack %s\n"), floatVal(minBack));
    Indent(level+1);
    fprintf(mStream, _T("minFront %s\n"), floatVal(minFront));
    Indent(level+1);
    fprintf(mStream, _T("priority %s\n"), floatVal(priority));
    Indent(level+1);
    fprintf(mStream, _T("spatialize %s\n"),
            spatialize ? _T("TRUE") : _T("FALSE"));
    if (obj->audioClip) {
        Indent(level+1);
//        fprintf(mStream, _T("source USE %s\n"), VRMLName(obj->audioClip->GetName()));
        fprintf(mStream, _T("source\n"));
        VrmlOutAudioClip(level + 2, obj->audioClip);
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));

    return TRUE;
}

static INode *
GetTopLevelParent(INode* node)
{
    while(!node->GetParentNode()->IsRootNode())
        node = node->GetParentNode();
    return node;
}

BOOL
VRML2Export::VrmlOutTouchSensor(INode* node, int level)
{
    TouchSensorObject* obj = (TouchSensorObject*)
        node->EvalWorldState(mStart).obj;
    int enabled;
    obj->pblock->GetValue(PB_TS_ENABLED, mStart, enabled, FOREVER);
    Indent(level);
    fprintf(mStream, _T("DEF %s-SENSOR TouchSensor { enabled %s }\n"),mNodes.GetNodeName(node),
            enabled ? _T("TRUE") : _T("FALSE"));

    TCHAR* vrmlObjName = NULL;
    vrmlObjName = VrmlParent(node);
    INode *otop = NULL;
    int size = obj->objects.Count();
    for(int i=0; i < size; i++) {
        TouchSensorObj* animObj = obj->objects[i];
        Object *o = animObj->node->EvalWorldState(mStart).obj;
        if (!o)
            break;
        assert(vrmlObjName);
        if (IsAimTarget(animObj->node))
            break;
        INode* top;
        if (o->ClassID() == TimeSensorClassID)
            top = animObj->node;
        else
            top = GetTopLevelParent(animObj->node);
        ObjectBucket* ob =
            mObjTable.AddObject(top->EvalWorldState(mStart).obj);
        if (top != otop) {
            AddAnimRoute(vrmlObjName, ob->name.data(), node, top);
            AddCameraAnimRoutes(vrmlObjName, node, top);
            otop = top;
        }
    }
    return TRUE;
}

BOOL
VRML2Export::VrmlOutProxSensor(INode* node, ProxSensorObject* obj,
                                int level)
{
    int enabled;
    float length, width, height;

    obj->pblock->GetValue(PB_PS_ENABLED, mStart, enabled, FOREVER);
    obj->pblock->GetValue(PB_PS_LENGTH, mStart, length, FOREVER);
    obj->pblock->GetValue(PB_PS_WIDTH, mStart, width, FOREVER);
    obj->pblock->GetValue(PB_PS_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    fprintf(mStream, _T("DEF %s ProximitySensor {\n"),mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("enabled %s\n"),
            enabled ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    Point3 center(0.0f, 0.0f, height/2.0f);
    fprintf(mStream, _T("center %s\n"), point(center));
    Indent(level+1);
    Point3 size(width, length, height);
    fprintf(mStream, _T("size %s\n"), scalePoint(size));
    Indent(level);
    fprintf(mStream, _T("}\n"));

    TCHAR* vrmlObjName = NULL;
    vrmlObjName = VrmlParent(node);
    INode *otop = NULL;
    int numObjs = obj->objects.Count();
    for(int i=0; i < numObjs; i++) {
        ProxSensorObj* animObj = obj->objects[i];
        Object *o = animObj->node->EvalWorldState(mStart).obj;
        if (!o)
            break;
        assert(vrmlObjName);
        if (IsAimTarget(animObj->node))
            break;
        INode* top;
        if (o->ClassID() == TimeSensorClassID)
            top = animObj->node;
        else
            top = GetTopLevelParent(animObj->node);
        ObjectBucket* ob =
            mObjTable.AddObject(top->EvalWorldState(mStart).obj);
        if (top != otop) {
            AddAnimRoute(vrmlObjName, ob->name.data(), node, top);
            AddCameraAnimRoutes(vrmlObjName, node, top);
            otop = top;
        }
    }
    return TRUE;
}

BOOL
VRML2Export::VrmlOutBillboard(INode* node, Object* obj, int level)
{
    BillboardObject* bb = (BillboardObject*) obj;
    int screenAlign;
    bb->pblock->GetValue(PB_BB_SCREEN_ALIGN, mStart, screenAlign, FOREVER);
    Indent(level);
    fprintf(mStream, _T("DEF %s Billboard {\n"), mNodes.GetNodeName(node));
    if (screenAlign) {
        Indent(level+1);
        fprintf(mStream, _T("axisOfRotation 0 0 0\n"));
    } else {
        Point3 axis(0, 0, 1);
        Indent(level+1);
        fprintf(mStream, _T("axisOfRotation %s\n"), point(axis));
    }
    Indent(level+1);
    fprintf(mStream, _T("children [\n"));
    
    return TRUE;
}

void
VRML2Export::VrmlOutTimeSensor(INode* node, TimeSensorObject* obj, int level)
{
    int start, end, duration, loop, startOnLoad;
    int animEnd = mIp->GetAnimRange().End();
    obj->pblock->GetValue(PB_START_TIME, mStart, start, FOREVER);
    obj->pblock->GetValue(PB_STOP_TIME,  mStart, end, FOREVER);
    obj->pblock->GetValue(PB_LOOP,  mStart, loop, FOREVER);
    obj->pblock->GetValue(PB_START_ON_LOAD,  mStart, startOnLoad, FOREVER);
    obj->needsScript = start != mStart || end != animEnd;
    duration = end - start;
    Indent(level);
    fprintf(mStream, _T("DEF %s-TIMER TimeSensor {\n"),mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("cycleInterval %s\n"),
            floatVal(float(duration) / float(TIME_TICKSPERSEC)));
    Indent(level+1);
    fprintf(mStream, _T("loop %s\n"), loop ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    if (startOnLoad)
        fprintf(mStream, _T("startTime 1\n"));
    else
        fprintf(mStream, _T("stopTime 1\n"));
    fprintf(mStream, _T("}\n"));
    if (obj->needsScript) {
        fprintf(mStream, _T("DEF %s-SCRIPT Script {\n"),mNodes.GetNodeName(node));
        Indent(1);
        fprintf(mStream, _T("eventIn SFFloat fractionIn\n"));
        Indent(1);
        fprintf(mStream, _T("eventOut SFFloat fractionOut\n"));
        Indent(1);
        fprintf(mStream, _T("url \"javascript:\n"));
        Indent(2);
        fprintf(mStream, _T("function fractionIn(i) {\n"));
        Indent(2);
        float fract = (float(end) - float(start))/
                       (float(animEnd) - float(mStart));
        float offset = (start - mStart) /
                       (float(animEnd) - float(mStart));
        fprintf(mStream, _T("fractionOut = %s * i"), floatVal(fract));
        if (offset != 0.0f)
            fprintf(mStream, _T(" + %s;\n"), floatVal(offset));
        else
            fprintf(mStream, _T(";\n"));
        Indent(1);
        fprintf(mStream, _T("}\"\n"));
        fprintf(mStream, _T("}\n"));
    }
}
        

BOOL
VRML2Export::VrmlOutPointLight(INode* node, LightObject* light, int level)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(level);
    fprintf(mStream, _T("DEF %s-LIGHT PointLight {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(level+1);
    fprintf(mStream, _T("location 0 0 0\n"));

    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    fprintf(mStream, _T("radius %s\n"), floatVal(ls.attenEnd));
    if (ls.useAtten) {
        Indent(level+1);
        fprintf(mStream, _T("attenuation 0 1 0\n"));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutDirectLight(INode* node, LightObject* light, int level)
{
    Point3 dir(0,0,-1);

    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(level);
    fprintf(mStream, _T("DEF %s-LIGHT DirectionalLight {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(level+1);
    fprintf(mStream, _T("direction %s\n"), normPoint(dir));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);

    fprintf(mStream, _T("color %s\n"), color(col));

    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutSpotLight(INode* node, LightObject* light, int level)
{
    LightState ls;
    Interval iv = FOREVER;

    Point3 dir(0,0,-1);

    light->EvalLightState(mStart, iv, &ls);
    Indent(level);
    fprintf(mStream, _T("DEF %s-LIGHT SpotLight {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart,FOREVER)));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(level+1);
    fprintf(mStream, _T("location 0 0 0\n"));
    Indent(level+1);
    fprintf(mStream, _T("direction %s\n"), normPoint(dir));
    Indent(level+1);
    fprintf(mStream, _T("cutOffAngle %s\n"),
            floatVal(DegToRad(ls.fallsize)));
    Indent(level+1);
    fprintf(mStream, _T("beamWidth %s\n"), floatVal(DegToRad(ls.hotsize)));
    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    fprintf(mStream, _T("radius %s\n"), floatVal(ls.attenEnd));
    if (ls.useAtten) {
        Indent(level+1);
        fprintf(mStream, _T("attenuation 0 1 0\n"));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutTopPointLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    fprintf(mStream, _T("DEF %s PointLight {\n"), mNodes.GetNodeName(node));
    Indent(1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(1);
    Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
    fprintf(mStream, _T("location %s\n"), point(p));

    Indent(1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(1);
    float radius;
    if (!ls.useAtten || ls.attenEnd == 0.0f)
        radius = Length(mBoundBox.Width());
    else
        radius = ls.attenEnd;
    fprintf(mStream, _T("radius %s\n"), floatVal(radius));
    if (ls.useAtten) {
        Indent(1);
        fprintf(mStream, _T("attenuation 0 1 0\n"));
    }
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutTopDirectLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    fprintf(mStream, _T("DEF %s DirectionalLight {\n"), mNodes.GetNodeName(node));
    Indent(1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Point3 p = Point3(0,0,-1);

    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    Point3 trans, s;
    Quat q;
    AffineParts parts;
    decomp_affine(tm, &parts);
    q = parts.q;
    Matrix3 rot;
    q.MakeMatrix(rot);
    p = p * rot;
    
    Indent(1);
    fprintf(mStream, _T("direction %s\n"), point(p));
    Indent(1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

BOOL
VRML2Export::VrmlOutTopSpotLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);
    fprintf(mStream, _T("DEF %s SpotLight {\n"), mNodes.GetNodeName(node));
    Indent(1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart,FOREVER)));
    Indent(1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(1);
    Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
    fprintf(mStream, _T("location %s\n"), point(p));

    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    p = Point3(0,0,-1);
    Point3 trans, s;
    Quat q;
    Matrix3 rot;
    AffineParts parts;
    decomp_affine(tm, &parts);
    q = parts.q;
    q.MakeMatrix(rot);
    p = p * rot;

    Indent(1);
    fprintf(mStream, _T("direction %s\n"), normPoint(p));
    Indent(1);
    fprintf(mStream, _T("cutOffAngle %s\n"),
            floatVal(DegToRad(ls.fallsize)));
    Indent(1);
    fprintf(mStream, _T("beamWidth %s\n"), floatVal(DegToRad(ls.hotsize)));
    Indent(1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(1);
    float radius;
    if (!ls.useAtten || ls.attenEnd == 0.0f)
        radius = Length(mBoundBox.Width());
    else
        radius = ls.attenEnd;
    fprintf(mStream, _T("radius %s\n"), floatVal(radius));
    if (ls.useAtten) {
        float attn;
        attn = (ls.attenStart <= 1.0f) ? 1.0f : 1.0f/ls.attenStart;
        Indent(1);
        fprintf(mStream, _T("attenuation 0 %s 0\n"), floatVal(attn));
    }
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

void
VRML2Export::OutputTopLevelLight(INode* node, LightObject *light)
{
    Class_ID id = light->ClassID();
    if (id == Class_ID(OMNI_LIGHT_CLASS_ID, 0))
        VrmlOutTopPointLight(node, light);
    else if (id == Class_ID(DIR_LIGHT_CLASS_ID, 0) ||
             id == Class_ID(TDIR_LIGHT_CLASS_ID, 0))
        VrmlOutTopDirectLight(node, light);
    else if (id == Class_ID(SPOT_LIGHT_CLASS_ID, 0) ||
             id == Class_ID(FSPOT_LIGHT_CLASS_ID, 0))
        VrmlOutTopSpotLight(node, light);
    else
        return;
    
    // Write out any animation data
    InitInterpolators(node);
    VrmlOutControllers(node, 0);
    WriteInterpolatorRoutes(0, TRUE);
}

// Output a VRML Inline node.
BOOL
VRML2Export::VrmlOutInline(VRMLInsObject* obj, int level)
{
    Indent(level);
    fprintf(mStream, _T("Inline {\n"));
    Indent(level+1);
    fprintf(mStream, _T("url \"%s\"\n"), obj->GetUrl().data());
    if (obj->GetUseSize())
    {
        float size = obj->GetSize() * 2.0f;
        Indent(level+1);
        fprintf(mStream, _T("bboxSize %s\n"),
                scalePoint(Point3(size, size, size)));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Distance comparison function for sorting LOD lists.
static int
DistComp(LODObj** obj1, LODObj** obj2)
{
    float diff = (*obj1)->dist - (*obj2)->dist;
    if (diff < 0.0f) return -1;
    if (diff > 0.0f) return 1;
    return 0;
}

// Create a level-of-detail object.
BOOL
VRML2Export::VrmlOutLOD(INode *node, LODObject* obj, int level, BOOL mirrored)
{
    int numLod = obj->NumRefs();
    Tab<LODObj*> lodObjects = obj->GetLODObjects();
    int i;

    if (numLod == 0)
        return TRUE;

    lodObjects.Sort((CompareFnc) DistComp);

//    if (numLod > 1) {
        Indent(level);
        fprintf(mStream, _T("LOD {\n"));
        Indent(level+1);
        Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
        fprintf(mStream, _T("center %s\n"), point(p));
        Indent(level+1);
        fprintf(mStream, _T("range [ "));
        for(i = 0; i < numLod-1; i++) {
            if (i < numLod-2)
                fprintf(mStream, _T("%s, "), floatVal(lodObjects[i]->dist));
            else
//                fprintf(mStream, _T("%s ]\n"), floatVal(lodObjects[i]->dist));
                fprintf(mStream, _T("%s "), floatVal(lodObjects[i]->dist));
        }
fprintf(mStream, _T("]\n"));
//    }

    Indent(level+1);
    fprintf(mStream, _T("level [\n"));
    for(i = 0; i < numLod; i++) {
        INode *node = lodObjects[i]->node;
        INode *parent = node->GetParentNode();
        VrmlOutNode(node, parent, level+1, TRUE, FALSE, mirrored);
        if (i != numLod-1) {
            Indent(level);
            fprintf(mStream, _T(",\n"));
        }
    }

//    if (numLod > 1) {
        Indent(level);
        fprintf(mStream, _T("]\n"));
        Indent(level);
        fprintf(mStream, _T("}\n"));
//    }

    return TRUE;
}

BOOL
VRML2Export::VrmlOutSpecialTform(INode* node, Object* obj, int level,
                                 BOOL mirrored)
{
    if (!mPrimitives)
        return FALSE;

    Class_ID id = obj->ClassID();

    // Otherwise look for the primitives we know about
    if (id == Class_ID(CYLINDER_CLASS_ID, 0))
        return VrmlOutCylinderTform(node, obj, level+1, mirrored);

    if (id == Class_ID(CONE_CLASS_ID, 0))
        return VrmlOutConeTform(node, obj, level+1, mirrored);

    if (id == Class_ID(BOXOBJ_CLASS_ID, 0))
        return VrmlOutCubeTform(node, obj, level+1, mirrored);

    return FALSE;
        
}

BOOL
VRML2Export::ObjIsPrim(INode* node, Object* obj)
{
    Class_ID id = obj->ClassID();
    if (id == Class_ID(SPHERE_CLASS_ID, 0))
        return VrmlOutSphereTest(node, obj);

    if (id == Class_ID(CYLINDER_CLASS_ID, 0))
        return VrmlOutCylinderTest(node, obj);

    if (id == Class_ID(CONE_CLASS_ID, 0))
        return VrmlOutConeTest(node, obj);

    if (id == Class_ID(BOXOBJ_CLASS_ID, 0))
        return VrmlOutCubeTest(node, obj);

    return FALSE;
}

// Write out the VRML for node we know about, including Opus nodes, 
// lights, cameras and VRML primitives
BOOL
VRML2Export::VrmlOutSpecial(INode* node, INode* parent,
                             Object* obj, int level, BOOL mirrored)
{
    Class_ID id = obj->ClassID();

    /* test
    if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        level++;
        VrmlOutMrBlue(node, parent, (MrBlueObject*) obj,
                      &level, FALSE);
        return TRUE;
    }
    */
    
    if (id == Class_ID(OMNI_LIGHT_CLASS_ID, 0))
        return VrmlOutPointLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(DIR_LIGHT_CLASS_ID, 0) ||
        id == Class_ID(TDIR_LIGHT_CLASS_ID, 0))
        return VrmlOutDirectLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(SPOT_LIGHT_CLASS_ID, 0) ||
        id == Class_ID(FSPOT_LIGHT_CLASS_ID, 0))
        return VrmlOutSpotLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(VRML_INS_CLASS_ID1, VRML_INS_CLASS_ID2))
        return VrmlOutInline((VRMLInsObject*) obj, level+1);

    if (id == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2))
        return VrmlOutLOD(node, (LODObject*) obj, level+1, mirrored);

    if (id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
        id == Class_ID(LOOKAT_CAM_CLASS_ID, 0))
        return VrmlOutCamera(node, obj, level+1);

    if (id == SoundClassID)
        return VrmlOutSound(node, (SoundObject*) obj, level+1);

    if (id == ProxSensorClassID)
        return VrmlOutProxSensor(node, (ProxSensorObject*) obj, level+1);

    if (id == BillboardClassID)
        return VrmlOutBillboard(node, obj, level+1);

    // If object has modifiers or WSMs attached, do not output as
    // a primitive
    SClass_ID sid = node->GetObjectRef()->SuperClassID();
    if (sid == WSM_DERIVOB_CLASS_ID ||
        sid == DERIVOB_CLASS_ID)
        return FALSE;

    if (!mPrimitives)
        return FALSE;

    // Otherwise look for the primitives we know about
    if (id == Class_ID(SPHERE_CLASS_ID, 0))
        return VrmlOutSphere(node, obj, level+1);

    if (id == Class_ID(CYLINDER_CLASS_ID, 0))
        return VrmlOutCylinder(node, obj, level+1);

    if (id == Class_ID(CONE_CLASS_ID, 0))
        return VrmlOutCone(node, obj, level+1);

    if (id == Class_ID(BOXOBJ_CLASS_ID, 0))
        return VrmlOutCube(node, obj, level+1);

    return FALSE;
        
}

static BOOL
IsLODObject(Object* obj)
{
    return obj->ClassID() == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2);
}

static BOOL
IsEverAnimated(INode* node)
{
    if (!node)
        return FALSE;
    for (; !node->IsRootNode(); node = node->GetParentNode())
        if (node->IsAnimated())
            return TRUE;
    return FALSE;
}

BOOL
VRML2Export::ChildIsAnimated(INode* node)
{
    if (node->IsAnimated())
        return TRUE;

    Object* obj = node->EvalWorldState(mStart).obj;

    if (ObjIsAnimated(obj))
        return TRUE;

    Class_ID id = node->GetTMController()->ClassID();

    if (id != Class_ID(PRS_CONTROL_CLASS_ID, 0))
        return TRUE;

    for (int i = 0; i < node->NumberOfChildren(); i++)
        if (ChildIsAnimated(node->GetChildNode(i)))
            return TRUE;
    return FALSE;
}

static BOOL
IsAnimTrigger(Object *obj)
{
    if (!obj)
        return FALSE;

    Class_ID id = obj->ClassID();
    /* test
    // Mr Blue nodes only 1st class if stand-alone
    if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        MrBlueObject* mbo = (MrBlueObject*) obj;
        return mbo->GetMouseEnabled() && mbo->GetAction() == Animate;
    }
    */
    return FALSE;
}

BOOL
VRML2Export::isVrmlObject(INode * node, Object *obj, INode* parent)
{
    if (!obj)
        return FALSE;

    Class_ID id = obj->ClassID();

    /* test
    
    if (id == Class_ID(OMNI_LIGHT_CLASS_ID, 0))
    // Mr Blue nodes only 1st class if stand-alone
    if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        MrBlueObject* mbo = (MrBlueObject*) obj;
        if ((mbo->GetAction() == HyperLinkJump ||
             mbo->GetAction() == SetViewpoint) &&
            mbo->GetMouseEnabled())
            return parent->IsRootNode();
        else
            return FALSE;
    }
    */

    if (id == Class_ID(VRML_INS_CLASS_ID1, VRML_INS_CLASS_ID2) ||
        id == SoundClassID ||
        id == ProxSensorClassID)
        return TRUE;

    // only animated lights come out in scene graph
    if (IsLight(node))
        return (IsEverAnimated(node) || IsEverAnimated(node->GetTarget()));
    if (IsCamera(node))
        return FALSE;

    if (node->NumberOfChildren() > 0)
        return TRUE;

#ifdef _LEC_
 // LEC uses dummies as place holders and need dummy leaves written.
    if (id == Class_ID(DUMMY_CLASS_ID, 0))
        return TRUE;
#endif

    return (obj->IsRenderable() ||
            id == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2)) &&
        (mExportHidden || !node->IsHidden());
        
}

static BOOL
NodeIsChildOf(INode* child, INode* parent)
{
    if (child == parent)
        return TRUE;
 // skip invalid nodes (ex. user create the list then delete the node from the scene.)
	if (!parent)
		return FALSE;
    int num = parent->NumberOfChildren();
    int i;
    for (i = 0; i < num; i++) {
        if (NodeIsChildOf(child, parent->GetChildNode(i)))
            return TRUE;
    }
    return FALSE;
}

// For objects that change shape, output a CoodinateInterpolator
void
VRML2Export::VrmlOutCoordinateInterpolator(INode* node, Object *obj,
                                           int level, BOOL pMirror)
{
    int sampleRate;
    int t, i, j;
    int width = mIndent ? level * 2 : 0;
    TCHAR name[MAX_PATH];

    if (mCoordSample)
        sampleRate = GetTicksPerFrame();
    else
        sampleRate = TIME_TICKSPERSEC / mCoordSampleRate;

    int end = mIp->GetAnimRange().End();
    int realEnd = end;
    int frames = (end - mStart)/sampleRate + 1;

    if (((end - mStart) % sampleRate) != 0) {
        end += sampleRate;
        frames++;
    }
    
    Indent(level);
    sprintf(name, _T("%s-COORD-INTERP"), mNodes.GetNodeName(node));
    fprintf(mStream, _T("DEF %s CoordinateInterpolator {\n"), name);
    AddInterpolator(name, KEY_COORD, mNodes.GetNodeName(node));
    // Now check to see if a TimeSensor references this node
    INodeList* l;
    for(l = mTimerList; l; l = l->GetNext()) {
        TimeSensorObject* tso = (TimeSensorObject*)
            l->GetNode()->EvalWorldState(mStart).obj;
        for(int j = 0; j < tso->TimeSensorObjects.Count(); j++) {
            INode* anim = tso->TimeSensorObjects[j]->node;
         // skip invalid nodes (ex. user create the list then delete the node from the scene.)
            if (anim && NodeIsChildOf(node, anim)) {
                TSTR oTimer = mTimer;
                TCHAR timer[MAX_PATH];
                sprintf(timer, _T("%s"),mNodes.GetNodeName(l->GetNode()));
                if (tso->needsScript)
                    AddInterpolator(name, KEY_TIMER_SCRIPT, timer);
                else
                    AddInterpolator(name, KEY_TIMER, timer);
            }
        }
    }
            
    Indent(level+1);
    fprintf(mStream, _T("key ["));
    mCycleInterval = (mIp->GetAnimRange().End() - mStart) /
        ((float) GetTicksPerFrame()* GetFrameRate());

    for(i = 0, t = mStart; i < frames; i++, t += sampleRate) {
        if (t > realEnd)
            t = realEnd;
        width += fprintf(mStream, _T("%s, "),
                         floatVal(t / ((float) GetTicksPerFrame()
                                       * GetFrameRate() * mCycleInterval)));
        if (width > 60) {
            fprintf(mStream, _T("\n"));
            Indent(level+3);
            width = mIndent ? level * 2 : 0;
        }
    }
    fprintf(mStream, _T("]\n"));

    Indent(level+1);
    fprintf(mStream, _T("keyValue ["));

    // Now output the values for the interpolator
    for (i = 0, t = mStart; i < frames; i++, t += sampleRate) {
        if (t > realEnd)
            t = realEnd;
        Object *o = node->EvalWorldState(t).obj;
        TriObject *tri = (TriObject *)o->ConvertToType(t, triObjectClassID);
        Mesh &mesh = tri->GetMesh();
                
        int numverts = mesh.getNumVerts();
        for(j = 0; j < numverts; j++) {
            Point3 p = mesh.verts[j];
#ifdef MIRROR_BY_VERTICES
			if (pMirror)
				p = - p;
#endif
            width += fprintf(mStream, _T("%s, "), point(p));
            if (width > 60) {
                fprintf(mStream, _T("\n"));
                Indent(level+3);
                width = mIndent ? level * 2 : 0;
            }
        }
        
        if(o != (Object *) tri)
            tri->DeleteThis();
    }
    fprintf(mStream, _T("]\n"));
    Indent(level+1);
    fprintf(mStream, _T("}\n"));

 // get valid mStart object
    obj = node->EvalWorldState(mStart).obj;
}

BOOL
VRML2Export::ObjIsAnimated(Object *obj)
{
    if (!obj)
        return FALSE;
    Interval iv = obj->ObjectValidity(mStart);
    return !(iv == FOREVER);
}

static BOOL
MtlHasTexture(Mtl* mtl)
{
    if (mtl->ClassID() != Class_ID(DMTL_CLASS_ID, 0))
        return FALSE;

    StdMat* sm = (StdMat*) mtl;
    // Check for texture map
    Texmap* tm = (BitmapTex*) sm->GetSubTexmap(ID_DI);
    if (!tm)
        return FALSE;

    if (tm->ClassID() != Class_ID(BMTEX_CLASS_ID, 0))
        return FALSE;
    BitmapTex* bm = (BitmapTex*) tm;

    TSTR bitmapFile;

    bitmapFile = bm->GetMapName();
    if (bitmapFile.data() == NULL)
        return FALSE;
    int l = strlen(bitmapFile)-1;
    if (l < 0)
        return FALSE;

    return TRUE;
}

static int
NumTextures(INode* node)
{
    float firstxpar;
    Mtl *sub, *mtl = node->GetMtl();
    if (!mtl)
        return 0;

    if (!mtl->IsMultiMtl())
        return 0;
    int num = mtl->NumSubMtls();
    for(int i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        if (!sub)
            continue;
        if (MtlHasTexture(sub))
            return num;
        if (i == 0)
            firstxpar = sub->GetXParency();
        else if (sub->GetXParency() != firstxpar)
            return num;
    }
    return 0;
}

// Write the data for a single object.
// This function also takes care of identifying VRML primitive objects
void
VRML2Export::VrmlOutObject(INode* node, INode* parent, Object* obj, int level,
                           BOOL mirrored)
{
 // need to get a valid obj ptr

    obj = node->EvalWorldState(mStart).obj;
    BOOL isTriMesh = obj->CanConvertToType(triObjectClassID);
    BOOL instance;
    BOOL special = FALSE;
    int numTextures = NumTextures(node);
    int start, end;

    if (numTextures == 0) {
        start = -1;
        end = 0;
    } else {
        start = 0;
        end = numTextures;
    }

    int old_level = level;
    for(int i = start; i < end; i++) {
        if (isTriMesh && obj->IsRenderable()) {
            special = VrmlOutSpecialTform(node, obj, level, mirrored);
            if (special)
                level += 3;
            Indent(level);
            fprintf(mStream, _T("Shape {\n"));
        }
        
        BOOL multiMat = FALSE;
        BOOL isWire = FALSE, twoSided = FALSE;
        
        // Output the material
        if (isTriMesh && obj->IsRenderable())  // if not trimesh, needs no matl
            multiMat = OutputMaterial(node, isWire, twoSided, level+1, i);
        
        // First check for VRML primitives and other special objects
        if (VrmlOutSpecial(node, parent, obj, level, mirrored)) {
            if (isTriMesh && obj->IsRenderable()) {
                Indent(level);
                fprintf(mStream, _T("}\n"));
                if (special) {
                    level = old_level;
                    Indent(level);
                    fprintf(mStream, _T("] }\n"));
                }
            }
            continue;
        }
        
        // Otherwise output as a triangle mesh
        if (isTriMesh && obj->IsRenderable()) {
            ObjectBucket* ob = mObjTable.AddObject(obj);
            if (ob->objectUsed && i == -1) {
                instance = TRUE;
                // We have an instance
                Indent(level);
                fprintf(mStream, _T("geometry USE %s-FACES\n"),
                        ob->instName.data());
            } else {
                ob->objectUsed = TRUE;
                ob->instName = mNodes.GetNodeName(node);
                instance = FALSE;
                TriObject *tri =
                    (TriObject *)obj->ConvertToType(mStart, triObjectClassID);
                
                if (mPolygonType && !ObjIsAnimated(obj))
                     OutputPolygonObject(node, tri, multiMat, isWire,
                                         twoSided, level+1, i, mirrored);
				else OutputTriObject(node, tri, multiMat, isWire, twoSided,
                                     level+1, i, mirrored);

#ifndef FUNNY_TEST
                if(obj != (Object *)tri)
                    tri->DeleteThis();
#endif
            }
            Indent(level);
            fprintf(mStream, _T("}\n"));
        }
    }

    // Check for animated object, and generate CordinateInterpolator
    if (mCoordInterp && isTriMesh && ObjIsAnimated(obj) && !instance)
        VrmlOutCoordinateInterpolator(node, obj, level, mirrored);
}

TCHAR*
VRML2Export::VrmlParent(INode* node)
{
    static TCHAR buf[256];
    /* test
    Object *obj = node->EvalWorldState(mStart).obj;
    Class_ID id = obj->ClassID();
    while (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        node = node->GetParentNode();
        obj = node->EvalWorldState(mStart).obj;
        if (!obj)
            return NULL;  // Unattached
        id = obj->ClassID();
    }
    */
    assert (node);
    _tcscpy(buf, mNodes.GetNodeName(node));
    return buf;
}

BOOL
VRML2Export::IsAimTarget(INode* node)
{
    INode* lookAt = node->GetLookatNode();
    if (!lookAt)
        return FALSE;
    Object* lookAtObj = lookAt->EvalWorldState(mStart).obj;
    Class_ID id = lookAtObj->ClassID();
    // Only generate aim targets for targetted spot lights and cameras
    if (id != Class_ID(SPOT_LIGHT_CLASS_ID, 0) &&
        id != Class_ID(LOOKAT_CAM_CLASS_ID, 0))
        return FALSE;
    return TRUE;
}
// Write out the node header for a Mr. Blue object
/* test
void
VRML2Export::VrmlAnchorHeader(INode* node, MrBlueObject* obj,
                              VRBL_TriggerType trigType, BOOL fromParent,
                              int level)
{
    TSTR desc;
    VRBL_Action action = obj->GetAction();
    TCHAR* vrmlObjName = NULL;
    vrmlObjName = VrmlParent(node);
    if (!vrmlObjName)
        return;

    if (action == HyperLinkJump || action == MrBlueMessage ||
        action == SetViewpoint) {
        switch (trigType) {
        case MouseClick:
            fprintf(mStream, _T("Anchor {\n"));
            break;
        case DistProximity:
            break;
        case BoundingBox:
            break;
        case LineOfSight:
            break;
        default:
            assert(FALSE);
        }

        Indent(level+1);
        TSTR camera;
        TCHAR *name = _T("url");

        switch (action) {
        case MrBlueMessage:
            fprintf(mStream, _T("%s \"signal:\"\n"), name);
            break;
        case HyperLinkJump:
            camera = obj->GetCamera();
            if (camera.Length() == 0)
                fprintf(mStream, _T("%s \"%s\"\n"), name, obj->GetURL());
            else
                fprintf(mStream, _T("%s \"%s#%s\"\n"), name, obj->GetURL(),
                        VRMLName(camera.data()));
            if (trigType == MouseClick) {
                desc = obj->GetDesc();
                if (desc.Length() > 0) {
                    Indent(level+1);
                    fprintf(mStream,
                            _T("description \"%s\"\n"), obj->GetDesc());
                }
            }
            break;
        case SetViewpoint:
            if (obj->GetVptCamera())
                camera = obj->GetVptCamera()->GetName();
            else
                camera = _T("");
            fprintf(mStream, _T("%s \"#%s\"\n"), name,
                    VRMLName(camera.data()));
            if (trigType == MouseClick) {
                desc = obj->GetVptDesc();
                if (desc.Length() > 0) {
                    Indent(level+1);
                    fprintf(mStream, _T("description \"%s\"\n"), desc);
                }
            }
            break;
        default:
            assert(FALSE);
        }
        switch (trigType) {
        case MouseClick:
            fprintf(mStream, _T("children [\n"));
            break;
        }
    } else {
        switch (trigType) {
        case MouseClick:
            fprintf(mStream, _T("DEF %s-SENSOR TouchSensor {}\n"), vrmlObjName);
            break;
        case DistProximity:
            break;
        case BoundingBox:
            break;
        case LineOfSight:
            break;
        default:
            assert(FALSE);
        }
        Indent(level+1);
        TSTR camera;
        TCHAR *name = _T("url");

        switch (action) {
        case MrBlueMessage:
            fprintf(mStream, _T("%s \"signal:\"\n"), name);
            break;
        case HyperLinkJump:
            camera = obj->GetCamera();
            if (camera.Length() == 0)
                fprintf(mStream, _T("%s \"%s\"\n"), name, obj->GetURL());
            else
                fprintf(mStream, _T("%s \"%s#%s\"\n"), name, obj->GetURL(),
                        camera.data());
            if (trigType == MouseClick) {
                desc = obj->GetDesc();
                if (desc.Length() > 0) {
                    Indent(level+1);
                    fprintf(mStream,
                            _T("description \"%s\"\n"), obj->GetDesc());
                }
            }
            break;
        case SetViewpoint:
            camera = obj->GetVptCamera()->GetName();
            fprintf(mStream, _T("%s \"#%s\"\n"), name, camera.data());
            if (trigType == MouseClick) {
                desc = obj->GetVptDesc();
                if (desc.Length() > 0) {
                    Indent(level+1);
                    fprintf(mStream, _T("description \"%s\"\n"), desc);
                }
            }
            break;
        case Animate: {
            // Output the objects to animate
            int size = obj->GetAnimObjects()->Count();
            for(int i=0; i < size; i++) {
                MrBlueAnimObj* animObj = (*obj->GetAnimObjects())[i];
                Object *o = animObj->node->EvalWorldState(mStart).obj;
                if (!o)
                    break;
                assert(vrmlObjName);
                if (IsAimTarget(animObj->node))
                    break;
                INode* top;
                if (o->ClassID() == TimeSensorClassID)
                    top = animObj->node;
                else
                    top = GetTopLevelParent(animObj->node);
                ObjectBucket* ob =
                    mObjTable.AddObject(top->EvalWorldState(mStart).obj);
                AddAnimRoute(vrmlObjName, ob->name.data(), node, top);
                AddCameraAnimRoutes(vrmlObjName, node, top);
            }
            break; }
         default:
            assert(FALSE);
        }
    }
}
*/

void
VRML2Export::AddCameraAnimRoutes(TCHAR* vrmlObjName, INode* fromNode,
                                 INode* top)
{
    for(int i = 0; i < top->NumberOfChildren(); i++) {
        INode *child = top->GetChildNode(i);
        Object* obj = child->EvalWorldState(mStart).obj;
        if (!obj)
            continue;
        SClass_ID sid = obj->SuperClassID();
        if (sid == CAMERA_CLASS_ID)
            AddAnimRoute(vrmlObjName, mNodes.GetNodeName(child),
                fromNode, child);
        AddCameraAnimRoutes(vrmlObjName, fromNode, child);
    }
}

void
VRML2Export::AddAnimRoute(TCHAR* from, TCHAR* to, INode* fromNode,
                          INode* toNode  )
{
    TCHAR fromStr[MAX_PATH];
    if (!from || *from == '\0') {
        _tcscpy(fromStr, mNodes.GetNodeName(fromNode));
        from = fromStr;
    }
    if (!to || *to == '\0')
        to = mNodes.GetNodeName(toNode);
    AnimRoute* ar = new AnimRoute(from, to, fromNode, toNode);
    mAnimRoutes.Append(1, ar);
}

int
VRML2Export::NodeNeedsTimeSensor(INode* node)
{
    BOOL isCamera = IsCamera(node);
	BOOL isAudio = IsAudio(node);
    BOOL isAnim = (isAudio ||
					(!isCamera && node->GetParentNode()->IsRootNode() &&
                        ChildIsAnimated(node)) ||
                    (isCamera && (IsEverAnimated(node) ||
                        IsEverAnimated(node->GetTarget()))));
    if (!isAnim)
        return 0;
    if (node->GetNodeLong() & (RUN_BY_PROX_SENSOR | RUN_BY_TOUCH_SENSOR))
        return 1;
    if (node->GetNodeLong() & RUN_BY_TIME_SENSOR)
        return 0;
    return -1;
}

void
VRML2Export::WriteAnimRoutes()
{
    int i;
    int ts;
    TCHAR from[MAX_PATH], to[MAX_PATH];
    for(i = 0; i < mAnimRoutes.Count(); i++) {
        INode* toNode = mAnimRoutes[i].mToNode;
        TCHAR *toName = mNodes.GetNodeName(toNode);
        Object* toObj = toNode->EvalWorldState(mStart).obj;
        Object* fromObj = mAnimRoutes[i].mFromNode->
            EvalWorldState(mStart).obj;
        BOOL isCamera = IsCamera(toNode);
        ts = NodeNeedsTimeSensor(toNode);
        if (ts != 0 || toObj->ClassID() == TimeSensorClassID) {
            if (toObj->ClassID() == AudioClipClassID)
                sprintf(to, _T("%s.startTime"), toName);
            else
                sprintf(to, _T("%s-TIMER.startTime"), toName);
            
            if (fromObj->ClassID() == ProxSensorClassID)
                sprintf(from, _T("%s.enterTime"), mAnimRoutes[i].mFromName);
            else
                sprintf(from, _T("%s-SENSOR.touchTime"), mAnimRoutes[i].mFromName);
            fprintf(mStream, _T("ROUTE %s TO %s\n"), from, to);
        }
    }
}

// Write out the header for a single Mr. Blue node
/* test
BOOL
VRML2Export::VrmlOutMrBlue(INode* node, INode* parent, MrBlueObject* obj,
                          int* level, BOOL fromParent)
{
    BOOL hadHeader = FALSE;
    TCHAR* name;
    if (fromParent)
        name = mNodes.GetNodeName(parent);
    else
        name = mNodes.GetNodeName(node);

    if (obj->GetMouseEnabled()) {
        MrBlueObject* mbo = (MrBlueObject*) obj;
        Indent(*level);
        VrmlAnchorHeader(node, obj, MouseClick, fromParent, *level);
        (*level)++;
        hadHeader = TRUE;
    }

    if (mType != Export_VRBL)
        goto end;

    if (obj->GetProxDistEnabled()) {
        Indent(*level);
        if (!hadHeader)
            fprintf(mStream, _T("DEF %s "), name);
        VrmlAnchorHeader(node, obj, DistProximity, fromParent, *level);
        Indent(*level+1);
        fprintf(mStream, _T("distance %s\n"), floatVal(obj->GetProxDist()));
        if (!fromParent) {
            // Generate proximity point for top-level objects.
            Indent(*level+1);
            fprintf(mStream, _T("point 0 0 0 \n"));
        }
        (*level)++;
        hadHeader = TRUE;
    }

    if (obj->GetBBoxEnabled() && !fromParent) {
        if (!fromParent)
        Indent(*level);
        if (!hadHeader)
            fprintf(mStream, _T("DEF %s "), name);
        VrmlAnchorHeader(node, obj, BoundingBox, fromParent, *level);
        Indent(*level+1);
        
        float x = obj->GetBBoxX()/2.0f,
            y = obj->GetBBoxY()/2.0f,
            z = obj->GetBBoxZ()/2.0f;
        Point3 p0 = Point3(-x, -y, -z), p1 = Point3(x, y, z);
        fprintf(mStream, _T("point [ %s, "), point(p0));
        fprintf(mStream, _T(" %s ]\n"), point(p1));
        (*level)++;
        hadHeader = TRUE;
    }
    
    if (obj->GetLosEnabled()) {
        if (obj->GetLosType() == CanSee) {
            Indent(*level);
            if (!hadHeader)
                fprintf(mStream, _T("DEF %s "), name);
            VrmlAnchorHeader(node, obj, LineOfSight, fromParent, *level);
            Indent(*level+1);
            fprintf(mStream, _T("distance %s\n"),
                    floatVal(GetLosProxDist(node, mStart)));
            Indent(*level+1);
            fprintf(mStream, _T("angle %s\n"),
                    floatVal(DegToRad(obj->GetLosVptAngle())));
        }
        else {
            Indent(*level);
            if (!hadHeader)
                fprintf(mStream, _T("DEF %s "), name);
            VrmlAnchorHeader(node, obj, LineOfSight, fromParent, *level);
            Indent(*level+1);
            fprintf(mStream, _T("distance %s\n"),
                    floatVal(GetLosProxDist(node, mStart)));
            Indent(*level+1);
            fprintf(mStream, _T("sightAngle %s\n"),
                    floatVal(DegToRad(obj->GetLosVptAngle())));
            Point3 p = GetLosVector(node, mStart);
            Indent(*level+1);
            fprintf(mStream, _T("vector %s\n"), normPoint(p));
            Indent(*level+1);
            fprintf(mStream, _T("vectorAngle %s\n"),
                    floatVal(DegToRad(obj->GetLosObjAngle())));
        }
        (*level)++;
    }

  end:
    // Close off the nodes if this is a stand-alone helper
    if (!fromParent)
        EndMrBlueNode(node, *level, FALSE);

    return TRUE;
}
*/

/*
// Start the headers for Mr. Blue nodes attached to the given node,
// returning the new indentation level
int
VRML2Export::StartMrBlueHelpers(INode* node, int level)
{
    // Check for Mr Blue helper at child nodes
    for(int i=0; i<node->NumberOfChildren(); i++) {
        INode* childNode = node->GetChildNode(i);
        Object *obj = childNode->EvalWorldState(mStart).obj;
        Class_ID id = obj->ClassID();
        if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
            MrBlueObject *mbo = (MrBlueObject*) obj;
            if ((mbo->GetAction() == HyperLinkJump ||
                 mbo->GetAction() == SetViewpoint) &&
                mbo->GetMouseEnabled())
                VrmlOutMrBlue(childNode, node, mbo, &level, TRUE);
        }
    }
    return level;
}
*/

// Write out the node closer for a Mr. Blue node
/* test
void
VRML2Export::EndMrBlueNode(INode* childNode, int& level, BOOL fromParent)
{
    Object *obj = childNode->EvalWorldState(mStart).obj;
    Class_ID id = obj->ClassID();
    if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        MrBlueObject* mbo = (MrBlueObject*) obj;
        if (mbo->GetMouseEnabled()) {
            if (mbo->GetAction() == HyperLinkJump ||
                mbo->GetAction() == SetViewpoint) {
                if (!fromParent)
                    return;
                Indent(level);
                fprintf(mStream, _T("]\n"));
                Indent(--level);
                fprintf(mStream, _T("}\n"));
            }
        }
        // FIXME take care of these
        if (mbo->GetProxDistEnabled()) {
        }
        if (mbo->GetBBoxEnabled()) {
        }
        if (mbo->GetLosEnabled()) {
        }
    }
}
*/

// Write out the node closers for all the Mr. Blue headers
/* test
void
VRML2Export::EndMrBlueHelpers(INode* node, int level)
{
    // Check for Mr Blue helper at child nodes
    for(int i=0; i<node->NumberOfChildren(); i++) {
        EndMrBlueNode(node->GetChildNode(i), level, TRUE);
    }
}
*/

void
VRML2Export::InitInterpolators(INode* node)
{
#ifdef _LEC_
    if (mFlipBook)
        return;
#endif
    mInterpRoutes.SetCount(0);
    int sensors = node->GetNodeLong() & RUN_BY_ANY_SENSOR;
    if (sensors == RUN_BY_TIME_SENSOR)
        mTimer = (const char *)NULL;
    else
        mTimer = TSTR(mNodes.GetNodeName(node)) + TSTR(_T("-TIMER"));
}

void
VRML2Export::AddInterpolator(TCHAR* interp, int type, TCHAR* name)
{
    InterpRoute* r = new InterpRoute(interp, type, name);
    mInterpRoutes.Append(1, r);
}

void
VRML2Export::WriteInterpolatorRoutes(int level, BOOL isCamera)
{
#ifdef _LEC_
    if (mFlipBook)
        return;
#endif
    int i;
    for(i = 0; i < mInterpRoutes.Count(); i++) {
        Indent(level);
        if (mInterpRoutes[i].mType == KEY_TIMER)
            fprintf(mStream,
                    _T("ROUTE %s-TIMER.fraction_changed TO %s.set_fraction\n"),
                    (char *)mInterpRoutes[i].mNode, (char *)mInterpRoutes[i].mInterp);
        else if (mInterpRoutes[i].mType == KEY_TIMER_SCRIPT) {
            fprintf(mStream,
                    _T("ROUTE %s-TIMER.fraction_changed TO %s-SCRIPT.fractionIn\n"),
                    (char *)mInterpRoutes[i].mNode, (char *)mInterpRoutes[i].mNode);
            fprintf(mStream,
                    _T("ROUTE %s-SCRIPT.fractionOut TO %s.set_fraction\n"),
                    (char *)mInterpRoutes[i].mNode, (char *)mInterpRoutes[i].mInterp);
        } else if (!mTimer.isNull())
            fprintf(mStream, _T("ROUTE %s.fraction_changed TO %s.set_fraction\n"),
                    (char *)mTimer, (char *)mInterpRoutes[i].mInterp);
        Indent(level);
        TCHAR* setType = NULL;
        switch (mInterpRoutes[i].mType) {
        case KEY_POS:
            if (isCamera)
                setType = _T("set_position");
            else
                setType = _T("set_translation");
            break;
        case KEY_ROT:
            if (isCamera)
                setType = _T("set_orientation");
            else
                setType = _T("set_rotation");
            break;
        case KEY_SCL:
            setType = _T("set_scale");
            break;
        case KEY_SCL_ORI:
            setType = _T("set_scaleOrientation");
            break;
        case KEY_COORD:
            setType = _T("set_point");
            break;
        case KEY_COLOR:
            setType = _T("set_color");
            break;
        }
        if (mInterpRoutes[i].mType != KEY_TIMER &&
            mInterpRoutes[i].mType != KEY_TIMER_SCRIPT) {
            assert(setType);
            if (isCamera)
                fprintf(mStream, _T("ROUTE %s.value_changed TO %s.%s\n"),
                        (char *)mInterpRoutes[i].mInterp, (char *)mInterpRoutes[i].mNode,
                        setType);
            else if (mInterpRoutes[i].mType == KEY_COLOR)
                fprintf(mStream, _T("ROUTE %s.value_changed TO %s-LIGHT.%s\n"),
                        (char *)mInterpRoutes[i].mInterp, (char *)mInterpRoutes[i].mNode,
                        setType);
            else if (mInterpRoutes[i].mType == KEY_COORD)
                fprintf(mStream,_T("ROUTE %s.value_changed TO %s-COORD.%s\n"),
                        (char *)mInterpRoutes[i].mInterp, (char *)mInterpRoutes[i].mNode,
                        setType);
            else
                fprintf(mStream, _T("ROUTE %s.value_changed TO %s.%s\n"),
                        (char *)mInterpRoutes[i].mInterp, (char *)mInterpRoutes[i].mNode,
                        setType);
        }
    }
}

inline BOOL
ApproxEqual(float a, float b, float eps)
{
    float d = (float) fabs(a-b);
    return d < eps;
}

int
reducePoint3Keys(Tab<TimeValue>& times, Tab<Point3>& points, float eps)
{
    if (times.Count() < 3)
        return times.Count();

    BOOL *used = new BOOL[times.Count()];
    int i;
    for(i = 0; i < times.Count(); i++)
        used[i] = TRUE;

    // The two lines are represented as p0 + v * s and q0 + w * t.
    Point3 p0, q0;  
    for(i = 1; i < times.Count(); i++) {
        p0 = points[i];
        q0 = points[i-1];
        if (ApproxEqual(p0.x, q0.x, eps) && 
            ApproxEqual(p0.y, q0.y, eps) && 
            ApproxEqual(p0.z, q0.z, eps)) 
            used[i] = FALSE;
        else {
            used[i-1] = TRUE;
        }
    }

    int j = 0;
    for(i = 0; i<times.Count(); i++)
        if (used[i])
            j++;
    if (j == 1) {
        delete[] used;
        return 0;
    }
    j = 0;
    for(i = 0; i < times.Count(); i++) {
        if (used[i]) {
            times[j] = times[i];
            points[j] = points[i];
            j++;
        }
    }
    times.SetCount(j);
    points.SetCount(j);
    delete[] used;
    if (j == 1)
        return 0;
    if (j == 2) {
        p0 = points[0];
        q0 = points[1];
        if (ApproxEqual(p0.x, q0.x, eps) && 
            ApproxEqual(p0.y, q0.y, eps) && 
            ApproxEqual(p0.z, q0.z, eps)) 
            return 0;
    }
    return j;
}

int
reduceAngAxisKeys(Tab<TimeValue>& times, Tab<AngAxis>& points, float eps)
{
    if (times.Count() < 3)
        return times.Count();

    BOOL *used = new BOOL[times.Count()];
    int i;
    for(i = 0; i < times.Count(); i++)
        used[i] = TRUE;

    // The two lines are represented as p0 + v * s and q0 + w * t.
    AngAxis p0, q0;  
    for(i = 1; i < times.Count(); i++) {
        p0 = points[i];
        q0 = points[i-1];
        if (ApproxEqual(p0.axis.x, q0.axis.x, eps) && 
            ApproxEqual(p0.axis.y, q0.axis.y, eps) && 
            ApproxEqual(p0.axis.z, q0.axis.z, eps) && 
            ApproxEqual(p0.angle, q0.angle, eps)) 
            used[i] = FALSE;
        else {
            used[i-1] = TRUE;
        }
    }

    int j = 0;
    for(i = 0; i<times.Count(); i++)
        if (used[i])
            j++;
    if (j == 1) {
        delete[] used;
        return 0;
    }
    j = 0;
    for(i = 0; i < times.Count(); i++) {
        if (used[i]) {
            times[j] = times[i];
            points[j] = points[i];
            j++;
        }
    }
    times.SetCount(j);
    points.SetCount(j);
    delete[] used;
    if (j == 1)
        return 0;
    if (j == 2) {
        p0 = points[0];
        q0 = points[1];
        if (ApproxEqual(p0.axis.x, q0.axis.x, eps) && 
            ApproxEqual(p0.axis.y, q0.axis.y, eps) && 
            ApproxEqual(p0.axis.z, q0.axis.z, eps) && 
            ApproxEqual(p0.angle, q0.angle, eps)) 
            return 0;
    }
    return j;
}

int
reduceScaleValueKeys(Tab<TimeValue>& times, Tab<ScaleValue>& svs, float eps)
{
    if (times.Count() < 3)
        return times.Count();

    BOOL *used = new BOOL[times.Count()];
    BOOL alliso = (ApproxEqual(svs[0].s.x, svs[0].s.y, eps) &&
                   ApproxEqual(svs[0].s.x, svs[0].s.z, eps));
    int i;
    for (i = 0; i < times.Count(); i++)
        used[i] = TRUE;

    Point3 s0, t0;
    AngAxis p0, q0;
    for (i = 1; i < times.Count(); i++) {
        s0 = svs[i].s;
        t0 = svs[i-1].s;
        if (ApproxEqual(s0.x, t0.x, eps) &&
            ApproxEqual(s0.y, t0.y, eps) &&
            ApproxEqual(s0.z, t0.z, eps)) {
            AngAxisFromQa(svs[i].q, &p0.angle, p0.axis);
            AngAxisFromQa(svs[i-1].q, &q0.angle, q0.axis);
            if (ApproxEqual(p0.axis.x, q0.axis.x, eps) && 
                ApproxEqual(p0.axis.y, q0.axis.y, eps) && 
                ApproxEqual(p0.axis.z, q0.axis.z, eps) && 
                ApproxEqual(p0.angle, q0.angle, eps)) 
                used[i] = FALSE;
            else
                used[i-1] = TRUE;
        }
        else {
            used[i-1] = TRUE;
            alliso = FALSE;
        }
    }

    if (alliso) {       // scale always isotropic and constant
        delete [] used;
        return 0;
    }

    int j = 0;
    for (i = 0; i < times.Count(); i++)
        if (used[i])
            j++;
    if (j == 1) {
        delete [] used;
        return 0;
    }
    j = 0;
    for (i = 0; i < times.Count(); i++) {
        if (used[i]) {
            times[j] = times[i];
            svs[j] = svs[i];
            j++;
        }
    }
    times.SetCount(j);
    svs.SetCount(j);
    delete [] used;
    if (j == 1)
        return 0;
    if (j == 2) {
        s0 = svs[0].s;
        t0 = svs[1].s;
        AngAxisFromQa(svs[0].q, &p0.angle, p0.axis);
        AngAxisFromQa(svs[1].q, &q0.angle, q0.axis);
        if (ApproxEqual(s0.x, t0.x, eps) && 
            ApproxEqual(s0.y, t0.y, eps) && 
            ApproxEqual(s0.z, t0.z, eps) && 
            ApproxEqual(p0.axis.x, q0.axis.x, eps) && 
            ApproxEqual(p0.axis.y, q0.axis.y, eps) && 
            ApproxEqual(p0.axis.z, q0.axis.z, eps) && 
            ApproxEqual(p0.angle, q0.angle, eps)) 
            return 0;
    }
    return j;
}

// Write out all the keyframe data for the given controller
void
VRML2Export::WriteControllerData(INode* node,
                                 Tab<TimeValue>& posTimes,
                                 Tab<Point3>& posKeys,
                                 Tab<TimeValue>& rotTimes,
                                 Tab<AngAxis>& rotKeys,
                                 Tab<TimeValue>& sclTimes,
                                 Tab<ScaleValue>& sclKeys,
                                 int type, int level)
{
    AngAxis rval;
    Point3 p, s;
    Quat q;
    int i, width;
    TimeValue t;
    TCHAR name[128];
    Tab<TimeValue>& timeVals = posTimes;
    int newKeys;
    float eps;

    while (type) {

        // Set up
        switch (type) {
        case KEY_POS:
            eps = float(1.0e-5);
            newKeys = reducePoint3Keys(posTimes, posKeys, eps);
            if (newKeys == 0)
                return;
            timeVals = posTimes;
            sprintf(name, _T("%s-POS-INTERP"), mNodes.GetNodeName(node));
            Indent(level);
            fprintf(mStream, _T("DEF %s PositionInterpolator {\n"), name);
            break;
        case KEY_ROT:
            eps = float(1.0e-5);
            newKeys = reduceAngAxisKeys(rotTimes, rotKeys, eps);
            if (newKeys == 0)
                return;
            timeVals = rotTimes;
            sprintf(name, _T("%s-ROT-INTERP"), mNodes.GetNodeName(node));
            Indent(level);
            fprintf(mStream, _T("DEF %s OrientationInterpolator {\n"), name);
            break;
        case KEY_SCL:
            eps = float(1.0e-5);
            newKeys = reduceScaleValueKeys(sclTimes, sclKeys, eps);
            if (newKeys == 0)
                return;
            timeVals = sclTimes;
            sprintf(name, _T("%s-SCALE-INTERP"), mNodes.GetNodeName(node));
            Indent(level);
            fprintf(mStream, _T("DEF %s PositionInterpolator {\n"), name);
            break;
        case KEY_SCL_ORI:
            timeVals = sclTimes;
            sprintf(name, _T("%s-SCALE-ORI-INTERP"), mNodes.GetNodeName(node));
            Indent(level);
            fprintf(mStream, _T("DEF %s OrientationInterpolator {\n"), name);
            break;
        case KEY_COLOR:
            eps = float(1.0e-5);
            newKeys = reducePoint3Keys(posTimes, posKeys, eps);
            if (newKeys == 0)
                return;
            timeVals = posTimes;
            sprintf(name, _T("%s-COLOR-INTERP"), mNodes.GetNodeName(node));
            Indent(level);
            fprintf(mStream, _T("DEF %s ColorInterpolator {\n"), name);
            break;
        default: return;
        }

        AddInterpolator(name, type, mNodes.GetNodeName(node));
        // Now check to see if a TimeSensor references this node
        INodeList* l;
        for(l = mTimerList; l; l = l->GetNext()) {
            TimeSensorObject* tso = (TimeSensorObject*)
                l->GetNode()->EvalWorldState(mStart).obj;
            for(int j = 0; j < tso->TimeSensorObjects.Count(); j++) {
                INode* anim = tso->TimeSensorObjects[j]->node;
             // skip invalid nodes (ex. user create the list then delete the node from the scene.)
                if (anim && NodeIsChildOf(node, anim)) {
                    TSTR oTimer = mTimer;
                    TCHAR timer[MAX_PATH];
                    sprintf(timer, _T("%s"),mNodes.GetNodeName(l->GetNode()));
                    if (tso->needsScript)
                        AddInterpolator(name, KEY_TIMER_SCRIPT, timer);
                    else
                        AddInterpolator(name, KEY_TIMER, timer);
                    break;
                }
            }
        }
        
    
        // Output the key times
        mCycleInterval = (mIp->GetAnimRange().End() - mStart) /
            ((float) GetTicksPerFrame() * GetFrameRate());
        Indent(level+1);
        fprintf(mStream, _T("key ["));
        width = mIndent ? level * 2 : 0;
        for (i = 0; i < timeVals.Count(); i++) {
            t = timeVals[i] - mStart;
            if (t < 0)
                continue;
            width += fprintf(mStream, _T("%s, "),
                             floatVal(t / ((float) GetTicksPerFrame()
                                           * GetFrameRate() * mCycleInterval)));
            if (width > 60) {
                fprintf(mStream, _T("\n"));
                Indent(level+3);
                width = mIndent ? level * 2 : 0;
            }
        }
        fprintf(mStream, _T("]\n"));
        Indent(level+1);
        fprintf(mStream, _T("keyValue ["));

        width = mIndent ? level * 2 : 0;
        for (i=0; i < timeVals.Count(); i++) {
            t = timeVals[i];
            if (t < mStart)
                continue;

            // Write values
            switch (type) {
            case KEY_POS:
                mHadAnim = TRUE;
                p = posKeys[i];
                width += fprintf(mStream, _T("%s, "), point(p));
                break;
            
            case KEY_COLOR:
                mHadAnim = TRUE;
                p = posKeys[i];
                width += fprintf(mStream, _T("%s, "), color(p));
                break;
            
            case KEY_ROT:
                mHadAnim = TRUE;
                rval = rotKeys[i];
                width += fprintf(mStream, _T("%s, "),
                                 axisPoint(rval.axis, -rval.angle));
                break;
            case KEY_SCL:
                mHadAnim = TRUE;
                s = sclKeys[i].s;
                width += fprintf(mStream, _T("%s, "), scalePoint(s));
                break;
            case KEY_SCL_ORI:
                mHadAnim = TRUE;
                q = sclKeys[i].q;
                AngAxisFromQa(q, &rval.angle, rval.axis);
                width += fprintf(mStream, _T("%s, "),
                                 axisPoint(rval.axis, -rval.angle));
                break;
            
            }
            if (width > 50) {
                fprintf(mStream, _T("\n"));
                Indent(level+2);
                width = mIndent ? level * 2 : 0;
            }
        }
            
    //    Indent(level);
        fprintf(mStream, _T("] },\n"));

        type = (type == KEY_SCL ? KEY_SCL_ORI : 0);
    }               // while (type)
    return;
}

void
VRML2Export::WriteAllControllerData(INode* node, int flags, int level,
                                    Control* lc)
{
//TCHAR *name = node->GetName();    // for debugging
    float eps = float(1.0e-5);
    int i;
    int scalinc = 0;
    TimeValue t, prevT;
    TimeValue end = mIp->GetAnimRange().End();
    int frames;
    Point3 p, axis;
    ScaleValue s;
    Quat q;
    Quat oldu(0.0, 0.0, 0.0, 1.0);
    Matrix3 tm, ip;
    float ang;
    BOOL isCamera = IsCamera(node);
    int sampleRate;

    if (mTformSample)
        sampleRate = GetTicksPerFrame();
    else
        sampleRate = TIME_TICKSPERSEC / mTformSampleRate;
    frames = (end - mStart)/sampleRate + 1;
        
    int realEnd = end;
    if (((end - mStart) % sampleRate) != 0) {
        end += sampleRate;
        frames++;
    }
    
    
    // Tables of keyframe values
    Tab<Point3>     posKeys;
    Tab<TimeValue>  posTimes;
    Tab<ScaleValue> scaleKeys;
    Tab<TimeValue>  scaleTimes;
    Tab<AngAxis>    rotKeys;
    Tab<TimeValue>  rotTimes;

    // Set up 'k' to point at the right derived class
    if (flags & KEY_POS) {
        posKeys.SetCount(frames);
        posTimes.SetCount(frames);
    }
    if (flags & KEY_ROT) {
        rotKeys.SetCount(frames);
        rotTimes.SetCount(frames);
    }
    if (flags & KEY_SCL) {
        scaleKeys.SetCount(frames);
        scaleTimes.SetCount(frames);
    }
    if (flags & KEY_COLOR) {
        posKeys.SetCount(frames);
        posTimes.SetCount(frames);
    }

    for(i = 0, t = mStart; i < frames; i++, t += sampleRate) {
        if (t > realEnd)
            t = realEnd;
        if (flags & KEY_COLOR) {
            lc->GetValue(t, &posKeys[i], FOREVER);
            posTimes[i] = t;
            continue;
        }
        // otherwise we are sampling tform controller data

        AffineParts parts;
        if (!isCamera) {
            tm = GetLocalTM(node, t);
        } else {
            // We have a camera
            tm = node->GetObjTMAfterWSM(t);
        }
#ifdef DDECOMP
        d_decomp_affine(tm, &parts);
#else
        decomp_affine(tm, &parts);      // parts is parts
#endif

        if (flags & KEY_SCL) {
            s = ScaleValue(parts.k, parts.u);
            if (parts.f < 0.0f)
                s.s = - s.s;
#define AVOID_NEG_SCALE
#ifdef AVOID_NEG_SCALE
            if (s.s.x <= 0.0f && s.s.y <= 0.0f && s.s.z <= 0.0f) {
                s.s = - s.s;
                s.q = Conjugate(s.q);
            }
#endif
            // The following unholy kludge deals with the surprising fact
            // that, as a TM changes gradually, decomp_affine() may introduce
            // a sudden flip of sign in U at the same time as a jump in the
            // scale orientation axis.
            if (parts.u.x * oldu.x < -eps || parts.u.y * oldu.y < -eps ||
                        parts.u.z * oldu.z < -eps) {
                AffineParts pts;
                Matrix3 mat;
                TimeValue lowt, hight, midt;
                ScaleValue sv;
                int ct = scaleTimes.Count();

                for (hight = t, lowt = prevT;
                     hight - lowt > 1;        // 1/4800 sec.
                     ) {
                    midt = (hight + lowt) / 2;
                    if (!isCamera)
                        mat = GetLocalTM(node, midt);
                    else
                        mat = node->GetObjTMAfterWSM(midt);
#ifdef DDECOMP
                    d_decomp_affine(mat, &pts);
#else
                    decomp_affine(mat, &pts);
#endif
                    if (pts.u.x * oldu.x < -eps ||
                        pts.u.y * oldu.y < -eps ||
                        pts.u.z * oldu.z < -eps) 
                        hight = midt;
                    else
                        lowt = midt;
                }
                if (lowt > prevT) {
                    if (!isCamera)
                        mat = GetLocalTM(node, lowt);
                    else
                        mat = node->GetObjTMAfterWSM(lowt);
#ifdef DDECOMP
                    d_decomp_affine(mat, &pts);
#else
                    decomp_affine(mat, &pts);
#endif
                    sv = ScaleValue(pts.k, pts.u);
                    if (pts.f < 0.0f)
                        sv.s = - sv.s;
#ifdef AVOID_NEG_SCALE
                    if (sv.s.x <= 0.0f && sv.s.y <= 0.0f && sv.s.z <= 0.0f) {
                        sv.s = - sv.s;
                        sv.q = Conjugate(sv.q);
                    }
#endif
                    ct++;
                    scaleTimes.SetCount(ct);
                    scaleKeys.SetCount(ct);
                    scaleTimes[i + scalinc] = midt;
                    scaleKeys[i + scalinc] = sv;
                    scalinc++;
                }
                if (hight < t) {
                    if (!isCamera)
                        mat = GetLocalTM(node, hight);
                    else
                        mat = node->GetObjTMAfterWSM(hight);
#ifdef DDECOMP
                    d_decomp_affine(mat, &pts);
#else
                    decomp_affine(mat, &pts);
#endif
                    sv = ScaleValue(pts.k, pts.u);
                    if (pts.f < 0.0f)
                        sv.s = - sv.s;
#ifdef AVOID_NEG_SCALE
                    if (sv.s.x <= 0.0f && sv.s.y <= 0.0f && sv.s.z <= 0.0f) {
                        sv.s = - sv.s;
                        sv.q = Conjugate(sv.q);
                    }
#endif
                    ct++;
                    scaleTimes.SetCount(ct);
                    scaleKeys.SetCount(ct);
                    scaleTimes[i + scalinc] = midt;
                    scaleKeys[i + scalinc] = sv;
                    scalinc++;
                }
            }
            if (parts.u.x != 0.0f)
                oldu.x = parts.u.x;
            if (parts.u.y != 0.0f)
                oldu.y = parts.u.y;
            if (parts.u.z != 0.0f)
                oldu.z = parts.u.z;

            scaleTimes[i + scalinc] = t;
            scaleKeys[i + scalinc]  = s;
        }
            
        if (flags & KEY_POS) {
            p = parts.t;
            posTimes[i] = t;
            posKeys[i]  = p;
        }
            
        if (flags & KEY_ROT) {
            q = parts.q;
            if (isCamera && !mZUp) {
                // Now rotate around the X Axis PI/2
                Matrix3 rot = RotateXMatrix(PI/2);
                Quat qRot(rot);
                AngAxisFromQa(q/qRot, &ang, axis);
            } else
                AngAxisFromQa(q, &ang, axis);
            rotTimes[i] = t;
            rotKeys[i] = AngAxis(axis, ang);
        }
        prevT = t;
    }
    if (flags & KEY_POS) {
        WriteControllerData(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_POS, level);
    }
    if (flags & KEY_ROT) {
        WriteControllerData(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_ROT, level);
    }
    if (flags & KEY_SCL && !isCamera) {
        WriteControllerData(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_SCL, level);
    }
    if (flags & KEY_COLOR) {
        WriteControllerData(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_COLOR, level);
    }
}
    
void
VRML2Export::WriteVisibilityData(INode *node, int level) {
    int i;
    TimeValue t;
    int frames = mIp->GetAnimRange().End()/GetTicksPerFrame();
    BOOL lastVis = TRUE, vis;

    // Now generate the Hide keys
    for(i = 0, t = mStart; i <= frames; i++, t += GetTicksPerFrame()) {
	vis = node->GetVisibility(t) <= 0.0f ? FALSE : TRUE;
        if (vis != lastVis) {
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("HideKey_ktx_com {\n"));
            if (mGenFields) {
                Indent(level+1);
                fprintf(mStream, _T("fields [ SFLong frame] \n"));
            }
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), i);
            Indent(level);
            fprintf(mStream, _T("}\n"));
        }
        lastVis = vis;
    }    
}

BOOL
VRML2Export::IsLight(INode* node)
{
    Object* obj = node->EvalWorldState(mStart).obj;
    if (!obj)
        return FALSE;

    SClass_ID sid = obj->SuperClassID();
    return sid == LIGHT_CLASS_ID;
}

BOOL
VRML2Export::IsCamera(INode* node)
{
    Object* obj = node->EvalWorldState(mStart).obj;
    if (!obj)
        return FALSE;

    SClass_ID sid = obj->SuperClassID();
    return sid == CAMERA_CLASS_ID;
}

BOOL
VRML2Export::IsAudio(INode* node)
{
    Object* obj = node->EvalWorldState(mStart).obj;
    if (!obj)
        return FALSE;

    Class_ID cid = obj->ClassID();
    return cid == AudioClipClassID;
}

Control *
VRML2Export::GetLightColorControl(INode* node)
{
    if (!IsLight(node))
        return NULL;
    Object* obj = node->EvalWorldState(mStart).obj;
    IParamBlock *pblock = (IParamBlock *) obj->SubAnim(0);
    Control* cont = pblock->GetController(0);  // I know color is index 0!
    return cont;
}

#define NeedsKeys(nkeys) ((nkeys) > 1 || (nkeys) == NOT_KEYFRAMEABLE)

// Write out keyframe data, if it exists
void
VRML2Export::VrmlOutControllers(INode* node, int level)
{

#ifdef _LEC_
    if (mFlipBook)
        return;
#endif
    Control *pc, *rc, *sc, *lc;
    int npk = 0, nrk = 0, nsk = 0, nvk = 0, nlk = 0;

    int flags = 0;
    BOOL isCamera = IsCamera(node);
    Object *obj = node->EvalWorldState(mStart).obj;
    int ts = NodeNeedsTimeSensor(node);

    if (ts != 0) {
        mCycleInterval = (mIp->GetAnimRange().End() - mStart) /
            ((float) GetTicksPerFrame()* GetFrameRate());
        Indent(level);
        fprintf(mStream,
         _T("DEF %s-TIMER TimeSensor { loop %s cycleInterval %s },\n"),
                mNodes.GetNodeName(node),
                (ts < 0) ? _T("TRUE") : _T("FALSE"),
                floatVal(mCycleInterval));
    }

    lc = GetLightColorControl(node);
    if (lc) nlk = lc->NumKeys();
    if (NeedsKeys(nlk))
        WriteAllControllerData(node, KEY_COLOR, level, lc);

    Class_ID id = node->GetTMController()->ClassID();

    if (!node->IsAnimated() && id == Class_ID(PRS_CONTROL_CLASS_ID, 0) &&
            !isCamera && !IsLight(node))
        return;

#ifdef _DEBUG
    int inhf = node->GetTMController()->GetInheritanceFlags();
    int inhb = node->GetTMController()->InheritsParentTransform();
#endif
    
    if (!isCamera && id != Class_ID(PRS_CONTROL_CLASS_ID, 0))
        flags = KEY_POS | KEY_ROT | KEY_SCL;
    else if (isCamera && (IsEverAnimated(node) ||
                          IsEverAnimated(node->GetTarget())))
        flags = KEY_POS | KEY_ROT;
    else {
        pc = node->GetTMController()->GetPositionController();
        if (pc) npk = pc->NumKeys();
        rc = node->GetTMController()->GetRotationController();
        if (rc) nrk = rc->NumKeys();
        sc = node->GetTMController()->GetScaleController();
        if (sc) nsk = sc->NumKeys();
        if (NeedsKeys(npk) || NeedsKeys(nrk) || NeedsKeys(nsk))
            flags = KEY_POS | KEY_ROT | KEY_SCL;
    }
    if (flags)
        WriteAllControllerData(node, flags, level, NULL);
#if 0
    Control* vc = node->GetVisController();
    if (vc) nvk = vc->NumKeys();
    if (NeedsKeys(nvk))
        WriteVisibilityData(node, level);
#endif
}

void
VRML2Export::VrmlOutTopLevelCamera(int level, INode* node, BOOL topLevel)
{
    if (!topLevel && node == mCamera)
        return;
        
    CameraObject* cam = (CameraObject*) node->EvalWorldState(mStart).obj;
    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    Point3 p, s, axis;
    Quat q;
    float ang;

    AffineParts parts;
    decomp_affine(tm, &parts);
    p = parts.t;
    q = parts.q;
    if (!mZUp) {
        // Now rotate around the X Axis PI/2
        Matrix3 rot = RotateXMatrix(PI/2);
        Quat qRot(rot);
        AngAxisFromQa(q/qRot, &ang, axis);
    } else
        AngAxisFromQa(q, &ang, axis);

    // compute camera transform
    ViewParams vp;
    CameraState cs;
    Interval iv;
    cam->EvalCameraState(0, iv, &cs);
    vp.fov = (float)(2.0 * atan(tan(cs.fov / 2.0) / INTENDED_ASPECT_RATIO));

    Indent(level);
    fprintf(mStream, _T("DEF %s Viewpoint {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("position %s\n"), point(p));
    Indent(level+1);
    fprintf(mStream, _T("orientation %s\n"), axisPoint(axis, -ang));
    Indent(level+1);
    fprintf(mStream, _T("fieldOfView %s\n"), floatVal(vp.fov));
    Indent(level + 1);
    fprintf(mStream, _T("description \"%s\"\n"), mNodes.GetNodeName(node));
    Indent(level);
    fprintf(mStream, _T("}\n"));

    // Write out any animation data
    InitInterpolators(node);
    VrmlOutControllers(node, 0);
    WriteInterpolatorRoutes(level, TRUE);
}

// In navinfo.cpp
extern TCHAR* navTypes[];

void
VRML2Export::VrmlOutTopLevelNavInfo(int level, INode* node, BOOL topLevel)
{
    if (!topLevel && node == mNavInfo)
        return;

    NavInfoObject* ni = (NavInfoObject*) node->EvalWorldState(mStart).obj;
    int type, headlight;
    float visLimit, speed, collision, terrain, step;
    ni->pblock->GetValue(PB_TYPE, mIp->GetTime(), type, FOREVER);
    ni->pblock->GetValue(PB_HEADLIGHT, mIp->GetTime(), headlight, FOREVER);
    ni->pblock->GetValue(PB_VIS_LIMIT, mIp->GetTime(), visLimit, FOREVER);
    ni->pblock->GetValue(PB_SPEED, mIp->GetTime(), speed, FOREVER);
    ni->pblock->GetValue(PB_COLLISION, mIp->GetTime(), collision, FOREVER);
    ni->pblock->GetValue(PB_TERRAIN, mIp->GetTime(), terrain, FOREVER);
    ni->pblock->GetValue(PB_STEP, mIp->GetTime(), step, FOREVER);
    Indent(level);
    fprintf(mStream, _T("DEF %s NavigationInfo {\n"),mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("avatarSize [%s, "), floatVal(collision));
    fprintf(mStream, _T("%s, "), floatVal(terrain));
    fprintf(mStream, _T("%s]\n"), floatVal(step));
    Indent(level+1);
    fprintf(mStream, _T("headlight %s\n"),
            headlight ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    fprintf(mStream, _T("speed %s\n"), floatVal(speed));
    Indent(level+1);
    if (type < 0 || type > 3)
        type = 0;
    fprintf(mStream, _T("type \"%s\"\n"), navTypes[type]);
    Indent(level+1);
    fprintf(mStream, _T("visibilityLimit %s\n"), floatVal(visLimit));
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

void
VRML2Export::VrmlOutTopLevelBackground(int level, INode* node, BOOL topLevel)
{
    if (!topLevel && node == mBackground)
        return;

    BackgroundObject* bg = (BackgroundObject*)
        node->EvalWorldState(mStart).obj;
    int numColors, i;
    Point3 col[3];
    float angle2, angle3;

    bg->pblock->GetValue(PB_SKY_NUM_COLORS, mIp->GetTime(), numColors,
                         FOREVER);
    bg->pblock->GetValue(PB_SKY_COLOR1, mIp->GetTime(), col[0], FOREVER);
    bg->pblock->GetValue(PB_SKY_COLOR2, mIp->GetTime(), col[1], FOREVER);
    bg->pblock->GetValue(PB_SKY_COLOR3, mIp->GetTime(), col[2], FOREVER);
    bg->pblock->GetValue(PB_SKY_COLOR2_ANGLE, mIp->GetTime(), angle2,
                         FOREVER);
    bg->pblock->GetValue(PB_SKY_COLOR3_ANGLE, mIp->GetTime(), angle3,
                         FOREVER);

    Indent(level);
    fprintf(mStream, _T("DEF %s Background {\n"),mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("skyColor ["));
    for(i = 0; i < numColors + 1; i++)
        fprintf(mStream, _T("%s, "), color(col[i]));
    fprintf(mStream, _T("]\n"));
    
    if (numColors > 0) {
        Indent(level+1);
        fprintf(mStream, _T("skyAngle ["));
        fprintf(mStream, _T("%s, "), floatVal(angle2));
        if (numColors > 1)
            fprintf(mStream, _T("%s, "), floatVal(angle3));
        fprintf(mStream, _T("]\n"));
    }

    bg->pblock->GetValue(PB_GROUND_NUM_COLORS, mIp->GetTime(), numColors,
                         FOREVER);
    bg->pblock->GetValue(PB_GROUND_COLOR1, mIp->GetTime(), col[0], FOREVER);
    bg->pblock->GetValue(PB_GROUND_COLOR2, mIp->GetTime(), col[1], FOREVER);
    bg->pblock->GetValue(PB_GROUND_COLOR3, mIp->GetTime(), col[2], FOREVER);
    bg->pblock->GetValue(PB_GROUND_COLOR2_ANGLE, mIp->GetTime(), angle2,
                         FOREVER);
    bg->pblock->GetValue(PB_GROUND_COLOR3_ANGLE, mIp->GetTime(), angle3,
                         FOREVER);

    Indent(level+1);
    fprintf(mStream, _T("groundColor ["));
    for(i = 0; i < numColors + 1; i++)
        fprintf(mStream, _T("%s, "), color(col[i]));
    fprintf(mStream, _T("]\n"));
    
    if (numColors > 0) {
        Indent(level+1);
        fprintf(mStream, _T("groundAngle ["));
        fprintf(mStream, _T("%s, "), floatVal(angle2));
        if (numColors > 1)
            fprintf(mStream, _T("%s, "), floatVal(angle3));
        fprintf(mStream, _T("]\n"));
    }

    TSTR url;
    if (bg->back.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->back);
        fprintf(mStream, _T("backUrl \"%s\"\n"), url.data());
    }
    if (bg->bottom.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->bottom);
        fprintf(mStream, _T("bottomUrl \"%s\"\n"), url.data());
    }
    if (bg->front.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->front);
        fprintf(mStream, _T("frontUrl \"%s\"\n"), url.data());
    }
    if (bg->left.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->left);
        fprintf(mStream, _T("leftUrl \"%s\"\n"), url.data());
    }
    if (bg->right.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->right);
        fprintf(mStream, _T("rightUrl \"%s\"\n"), url.data());
    }
    if (bg->top.Length() > 0) {
        Indent(level+1);
        url = PrefixUrl(bg->top);
        fprintf(mStream, _T("topUrl \"%s\"\n"), url.data());
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

void
VRML2Export::VrmlOutTopLevelFog(int level, INode* node, BOOL topLevel)
{
    if (!topLevel && node == mFog)
        return;

    FogObject* fog = (FogObject*) node->EvalWorldState(mStart).obj;
    Point3 p;
    float visLimit;
    int type;
    fog->pblock->GetValue(PB_COLOR, mIp->GetTime(), p, FOREVER);
    fog->pblock->GetValue(PB_TYPE, mIp->GetTime(), type, FOREVER);
    fog->pblock->GetValue(PB_VIS_LIMIT, mIp->GetTime(), visLimit, FOREVER);
    Indent(level);
    fprintf(mStream, _T("DEF %s Fog {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("color %s\n"), color(p));
    Indent(level+1);
    fprintf(mStream, _T("fogType \"%s\"\n"), type == 0 ? _T("LINEAR") :
            _T("EXPONENTIAL"));
    Indent(level+1);
    fprintf(mStream, _T("visibilityRange %s\n"), floatVal(visLimit));
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

void
VRML2Export::VrmlOutInitializeAudioClip(int level, INode* node)
{
    AudioClipObject* ac = (AudioClipObject*) node->EvalWorldState(mStart).obj;
    if (ac)
        ac->written = 0;
}

void
VRML2Export::VrmlOutAudioClip(int level, INode* node)
{
    float pitch;
    int loop, start;
    AudioClipObject* ac = (AudioClipObject*) node->EvalWorldState(mStart).obj;
    if (ac->written) {
        Indent(level);
        fprintf(mStream, _T("USE %s\n"), mNodes.GetNodeName(node));
        return;
    }
    ac->pblock->GetValue(PB_AC_PITCH, mIp->GetTime(), pitch, FOREVER);
    ac->pblock->GetValue(PB_AC_LOOP, mIp->GetTime(), loop, FOREVER);
    ac->pblock->GetValue(PB_AC_START, mIp->GetTime(), start, FOREVER);

    Indent(level);
    fprintf(mStream, _T("DEF %s AudioClip {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("description \"%s\"\n"), ac->desc.data());
    Indent(level+1);
    fprintf(mStream, _T("url \"%s\"\n"), ac->url.data());
    Indent(level+1);
    fprintf(mStream, _T("pitch %s\n"), floatVal(pitch));
    Indent(level+1);
    fprintf(mStream, _T("loop %s\n"), loop ? _T("TRUE") : _T("FALSE"));
    Indent(level+1);
    if (start)
        fprintf(mStream, _T("startTime 1\n"));
    else
        fprintf(mStream, _T("stopTime 1\n"));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    ac->written = TRUE;
}

// From dllmain.cpp
extern HINSTANCE hInstance;

void
VRML2Export::VrmlOutFileInfo()
{
    char filename[MAX_PATH];
    DWORD size, dummy;
    float vernum = 2.0f;
    float betanum = 0.0f;

    GetModuleFileName(hInstance, filename, MAX_PATH);
    size = GetFileVersionInfoSize(filename, &dummy);
    if (size) {
        char *buf = (char *)malloc(size);
        GetFileVersionInfo(filename, NULL, size, buf);
        VS_FIXEDFILEINFO *qbuf;
        UINT len;
        if (VerQueryValue(buf, "\\", (void **)&qbuf, &len)) {
            // got the version information
            DWORD ms = qbuf->dwProductVersionMS;
            DWORD ls = qbuf->dwProductVersionLS;
            vernum = HIWORD(ms) + (LOWORD(ms) / 100.0f);
            betanum = HIWORD(ls) + (LOWORD(ls) / 100.0f);
        }
        free(buf);
    }
    
    fprintf(mStream, _T("# Produced by 3D Studio MAX VRML97 exporter, Version %.5g, Revision %.5g\n"),
        vernum, betanum);
    
    
    time_t ltime;
    time( &ltime );
    char * time = ctime(&ltime);
    // strip the CR
    time[strlen(time)-1] = '\0';
    TCHAR* fn = mIp->GetCurFileName();
    if (fn && _tcslen(fn) > 0) {
        fprintf(mStream, _T("# MAX File: %s, Date: %s\n\n"), fn, time);
    } else {
        fprintf(mStream, _T("# Date: %s\n\n"), time);
    }
}

void
VRML2Export::VrmlOutWorldInfo()
{
    if (mTitle.Length() == 0 && mInfo.Length() == 0)
        return;

    fprintf(mStream, _T("WorldInfo {\n"));
    if (mTitle.Length() != 0) {
        Indent(1);
        fprintf(mStream, _T("title \"%s\"\n"), mTitle.data());
    }
    if (mInfo.Length() != 0) {
        Indent(1);
        fprintf(mStream, _T("info \"%s\"\n"), mInfo.data());
    }
    fprintf(mStream, _T("}\n"));
}

int
VRML2Export::StartAnchor(INode* node, int& level)
{
    SensorBucket *sb = mSensorTable.FindSensor(node);
    if (!sb)
        return 0;
    INode *sensor;
    INodeList *l;
    int numAnchors = 0;
    for(l = sb->mSensors; l; l = l->GetNext()) {
        sensor = l->GetNode();
        Object *obj = sensor->EvalWorldState(mStart).obj;
        assert(obj);
        if (obj->ClassID() == AnchorClassID) {
            numAnchors++;
            AnchorObject* ao = (AnchorObject*)
                sensor->EvalWorldState(mStart).obj;
            Indent(level);
            fprintf(mStream, _T("Anchor {\n"));
            level++;
            Indent(level);
            fprintf(mStream, _T("description \"%s\"\n"), ao->description.data());
            int type;
            ao->pblock->GetValue(PB_AN_TYPE, mStart, type, FOREVER);
            if (type == 0) {
                Indent(level);
                fprintf(mStream, _T("parameter \"%s\"\n"), ao->parameter.data());
                Indent(level);
                fprintf(mStream, _T("url \"%s\"\n"), ao->URL.data());
            } else {
                if (ao->cameraObject) {
                    Indent(level);
                    fprintf(mStream, _T("url \"#%s\"\n"),
                            VRMLName(ao->cameraObject->GetName()));
                }
            }
            Indent(level);
            fprintf(mStream, _T("children [\n"));
            level++;
        }
    }
    return numAnchors;
}

// Recursively count a node and all its children
static int
CountNodes(INode *node)
{
    int total, kids, i;
    
    if (node == NULL)
        return 0;
    total = 1;
    kids = node->NumberOfChildren();
    for (i = 0; i < kids; i++)
        total += CountNodes(node->GetChildNode(i));
    return total;
}

// Output a single node as VRML and recursively output the children of
// the node.
void
VRML2Export::VrmlOutNode(INode* node, INode* parent, int level, BOOL isLOD,
                         BOOL lastChild, BOOL mirrored) {

 // Don't gen code for LOD references, only LOD nodes
    if (!isLOD && ObjectIsLODRef(node)) return;
    
    if (mEnableProgressBar) SendMessage(hWndPDlg, 666, 0,
                                        (LPARAM) mNodes.GetNodeName(node));
    
    Object* obj         = node->EvalWorldState(mStart).obj;
    BOOL    outputName  = TRUE;
    int     numChildren = node->NumberOfChildren();
    BOOL    isVrml      = isVrmlObject(node, obj, parent);
    BOOL    numAnchors  = 0;
    BOOL    written     = FALSE;
    BOOL    mirror      = FALSE;
    int     cnt;

 
    if (node->IsRootNode()) {
        VrmlOutWorldInfo();
     // Compute the world bounding box and a list of timesensors
        ScanSceneGraph1();

        if (mCamera)
            VrmlOutTopLevelCamera(level+ 2, mCamera, TRUE);
        if (mNavInfo)
            VrmlOutTopLevelNavInfo(level+ 2, mNavInfo, TRUE);
        if (mBackground)
            VrmlOutTopLevelBackground(level+ 2, mBackground, TRUE);
        if (mFog)
            VrmlOutTopLevelFog(level+ 2, mFog, TRUE);

     // Make a list of al the LOD objects and texture maps in the scene.
     // Also output top-level objects
        ScanSceneGraph2();

        if (mHasLights && !mHasNavInfo) {
            fprintf(mStream, _T("NavigationInfo { headlight FALSE }\n"));
        }
    }

 // give third party dlls a chance to write the node
    if (!node->IsRootNode()) {
        written = FALSE;
        for (cnt = 0; cnt < mCallbacks->GetPreNodeCount(); cnt++) {
            DllPreNode preNode = mCallbacks->GetPreNode(cnt);
            PreNodeParam params;
            params.version  = 0;
            params.indent   = level;
            params.fName    = mFilename;
            params.i        = mIp;
            params.node     = node;

            if (mStream)
                fclose(mStream), mStream = NULL;
            written = (*(preNode))(&params);
            if (written)
                break; // only the first one gets to write the node
        }
        if (!mStream)
            mStream = _tfopen(mFilename, _T("a"));
    }

 // Anchors need to come first, even though they are child nodes
    if (!node->IsRootNode() && !written) {
        /* test
        int newLevel = StartMrBlueHelpers(node, level);
        level = newLevel;
        */
        numAnchors = StartAnchor(node, level);
     // Initialize set of timers/interpolator per top-level node
        if ( node->GetParentNode()->IsRootNode())
            InitInterpolators(node);
    }

    if (isVrml && !written) {
        StartNode(node, level, outputName);
        if (!IsLODObject(obj))
            mirror = OutputNodeTransform(node, level+1, mirrored);

     // Output the data for the object at this node
        Indent(level+1);
        fprintf(mStream, _T("children [\n"));
        if (!IsLODObject(obj)) {
         // If the node has a controller, output the data
            VrmlOutControllers(node, level+1);
        }
    }
    if ((isVrml && (mExportHidden || !node->IsHidden()) && !written) ||
        IsAnimTrigger(obj)) {
        VrmlOutObject(node, parent, obj, level+2, mirrored ^ mirror);
    }
    
    if (mEnableProgressBar) SendMessage(hWndPB, PBM_STEPIT, 0, 0);

    // Now output the children
    if (!(written & WroteNodeChildren)) {
        for(int i = 0; i < numChildren; i++) {
            VrmlOutNode(node->GetChildNode(i), node, level+2, FALSE,
                i == numChildren - 1, mirrored ^ mirror);
        }
    }

 // need to get a valid obj ptr VrmlOutNode (VrmlOutCoordinateInterpolator)
 // causes the obj ptr (cache) to be invalid
    obj = node->EvalWorldState(mStart).obj;

    if (obj && (obj->ClassID() == BillboardClassID) && (numChildren > 0) && !written) {
        Indent(level+1);
        fprintf(mStream, _T("] }\n"));
    }

    if (!node->IsRootNode() && isVrml && !written) {
        OutputTouchSensors(node, level);
        Indent(level+1);
        fprintf(mStream, _T("]\n"));
    }

    if (!node->IsRootNode() && !written) {
        if (node->GetParentNode()->IsRootNode())
            WriteInterpolatorRoutes(level, FALSE);  // must be in place of field
    }
    if (isVrml && !node->IsRootNode() && !written)
        EndNode(node, obj, level, lastChild);
 
 // give third party dlls a chance to finish up the node
    if (!node->IsRootNode()) {
        for (cnt = 0; cnt < mCallbacks->GetPostNodeCount(); cnt++) {
            DllPostNode postNode = mCallbacks->GetPostNode(cnt);
            PostNodeParam params;
            params.version  = 0;
            params.indent   = level;
            params.fName    = mFilename;
            params.i        = mIp;
            params.node     = node;

            if (mStream)
                fclose(mStream), mStream = NULL;

            (*(postNode))(&params);
        }
        if (!mStream)
            mStream = _tfopen(mFilename, _T("a"));
    }
    
    // End the anchors if needed
    if (!node->IsRootNode() && !written) {
        /* test
        EndMrBlueHelpers(node, level);
        */
        for (; numAnchors > 0; numAnchors--) {
            Indent(level);
            fprintf(mStream, _T("] }\n"));
            level--;
        }
//        if (node->GetParentNode()->IsRootNode())
//            WriteInterpolatorRoutes(level, FALSE);
    }
}

void
VRML2Export::OutputTouchSensors(INode* node, int level)
{
    SensorBucket *sb = mSensorTable.FindSensor(node);
    if (!sb)
        return;
    INode *sensor;
    INodeList *l;
    for(l = sb->mSensors; l; l = l->GetNext()) {
        sensor = l->GetNode();
        Object *obj = sensor->EvalWorldState(mStart).obj;
        assert(obj);
        if (obj->ClassID() == TouchSensorClassID)
            VrmlOutTouchSensor(sensor, level);
    }
}

// Traverse the scene graph looking for LOD nodes and texture maps.
// Mark nodes affected by sensors (time, touch, proximity).
void
VRML2Export::TraverseNode(INode* node)
{
    if (!node) return;
    Object* obj = node->EvalWorldState(mStart).obj;
    Class_ID id;
    
    if (obj) {
        id = obj->ClassID();
        if (id == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2))
            mLodList = mLodList->AddNode(node);
        
        if (IsLight(node)) {
            mHasLights = TRUE;
            if (!IsEverAnimated(node) && !IsEverAnimated(node->GetTarget())) {
                OutputTopLevelLight(node, (LightObject*) obj);
            }
        }
        if ((id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
             id == Class_ID(LOOKAT_CAM_CLASS_ID, 0)))
            VrmlOutTopLevelCamera(0, node, FALSE);
        
        if (id == NavInfoClassID) {
            mHasNavInfo = TRUE;
            VrmlOutTopLevelNavInfo(0, node, FALSE);
        }
        
        if (id == BackgroundClassID)
            VrmlOutTopLevelBackground(0, node, FALSE);
        
        if (id == FogClassID)
            VrmlOutTopLevelFog(0, node, FALSE);
        
        if (id == AudioClipClassID)
            VrmlOutInitializeAudioClip(0, node);
        
        if (id == TouchSensorClassID) {
            TouchSensorObject *ts = (TouchSensorObject*) obj;
            if (ts->triggerObject) {
                mSensorTable.AddSensor(ts->triggerObject, node);
            }
            int ct;
            INode *nd;
            for (ct = ts->objects.Count() - 1; ct >= 0; ct--) {
                nd = ts->objects[ct]->node;
                nd->SetNodeLong(nd->GetNodeLong() | RUN_BY_TOUCH_SENSOR);
            }
        }
        if (id == ProxSensorClassID) {
            ProxSensorObject *ps = (ProxSensorObject*) obj;
            int ct;
            INode *nd;
            for (ct = ps->objects.Count() - 1; ct >= 0; ct--) {
                nd = ps->objects[ct]->node;
                nd->SetNodeLong(nd->GetNodeLong() | RUN_BY_PROX_SENSOR);
            }
        }
        if (id == TimeSensorClassID) {
            TimeSensorObject *ts = (TimeSensorObject*) obj;
            int ct;
            INode *nd;
            for (ct = ts->TimeSensorObjects.Count() - 1; ct >= 0; ct--) {
                nd = ts->TimeSensorObjects[ct]->node;
                nd->SetNodeLong(nd->GetNodeLong() | RUN_BY_TIME_SENSOR);
            }
        }
        if (id == AnchorClassID) {
            AnchorObject *ao = (AnchorObject*) obj;
            if (ao->triggerObject) {
                mSensorTable.AddSensor(ao->triggerObject, node);
            }
        }
        ObjectBucket* ob = mObjTable.AddObject(obj);
        if (!ob->hasName) {
            ob->name = mNodes.GetNodeName(node);
            ob->hasName = TRUE;
        }
        if (!ob->hasInstName && !ObjIsPrim(node, obj)) {
            ob->instName = mNodes.GetNodeName(node);
            ob->hasInstName = TRUE;
        }

    }

    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        TraverseNode(node->GetChildNode(i));
}

void
VRML2Export::ComputeWorldBoundBox(INode* node, ViewExp* vpt)
{
    if (!node) return;
    Object* obj = node->EvalWorldState(mStart).obj;
    Class_ID id;

    node->SetNodeLong(0);
    if (obj) {
        id = obj->ClassID();
        if (id == TimeSensorClassID) {
            VrmlOutTimeSensor(node, (TimeSensorObject*) obj, 0);
            mTimerList = mTimerList->AddNode(node);
        }
        Box3 bb;
        obj->GetWorldBoundBox(mStart, node, vpt, bb);
        mBoundBox += bb;
    }

    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        ComputeWorldBoundBox(node->GetChildNode(i), vpt);
}

// Compute the world bounding box and a list of timesensors;
// also initialize each INode's nodeLong data
void
VRML2Export::ScanSceneGraph1()
{
    ViewExp *vpt = mIp->GetViewport(NULL);
    INode* node = mIp->GetRootNode();
    ComputeWorldBoundBox(node, vpt);
}

// Make a list of al the LOD objects and texture maps in the scene.
// Also output top-level objects
void
VRML2Export::ScanSceneGraph2()
{
    INode* node = mIp->GetRootNode();
    TraverseNode(node);
}

// Return TRUE iff the node is referenced by the LOD node.
static BOOL
ObjectIsReferenced(INode* lodNode, INode* node)
{
    Object* obj = lodNode->GetObjectRef();
    int numRefs = obj->NumRefs();

    for(int i=0; i < numRefs; i++)
        if (node == (INode*) obj->GetReference(i))
            return TRUE;

    return FALSE;
}

// Return TRUE iff the node is referenced by ANY LOD node.
BOOL 
VRML2Export::ObjectIsLODRef(INode* node)
{
    INodeList* l = mLodList;

    for(; l; l = l->GetNext())
        if (ObjectIsReferenced(l->GetNode(), node))
            return TRUE;

    return FALSE;
}


extern HINSTANCE hInstance;

static BOOL CALLBACK
ProgressDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    switch (msg) {
    case WM_INITDIALOG:
        CenterWindow(hDlg, GetParent(hDlg));
        Static_SetText(GetDlgItem(hDlg, IDC_PROGRESS_NNAME), " ");
        return TRUE;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDCANCEL:
            DestroyWindow(hDlg);
            hDlg = NULL;
            return TRUE;
        case IDOK:
            DestroyWindow(hDlg);
            hDlg = NULL;
            return TRUE;
        }
        return FALSE;
    case 666:
        Static_SetText(GetDlgItem(hDlg, IDC_PROGRESS_NNAME), (TCHAR *) lParam);
        return TRUE;
    }
    return FALSE;
}

// Export the current scene as VRML
#ifdef _LEC_
int
VRML2Export::DoFBExport(const TCHAR *filename, Interface *i, VRBLExport* exp,
                        int frame, TimeValue time)
{
    mIp = i;
    mStart = time;
    mCoordInterp = FALSE;

    mGenNormals      = exp->GetGenNormals();
    mIndent          = exp->GetIndent();
    mType            = exp->GetExportType();
    mUsePrefix       = exp->GetUsePrefix();
    mUrlPrefix       = exp->GetUrlPrefix();
    mCamera          = exp->GetCamera();
    mZUp             = exp->GetZUp();
    mDigits          = exp->GetDigits();
    mFlipBook        = exp->GetFlipBook();
    mCoordSample     = exp->GetCoordSample();
    mCoordSampleRate = exp->GetCoordSampleRate();
    mNavInfo         = exp->GetNavInfo();
    mBackground      = exp->GetBackground();
    mFog             = exp->GetFog();
    mTitle           = exp->GetTitle();
    mInfo            = exp->GetInfo();
    mExportHidden    = exp->GetExportHidden();
    mPrimitives      = exp->GetPrimitives();
    mPolygonType     = exp->GetPolygonType();
    mEnableProgressBar    = exp->GetEnableProgressBar();
    mPreLight        = exp->GetPreLight();
    mCPVSource       = exp->GetCPVSource();
    mCallbacks       = exp->GetCallbacks();  //FIXME add callback support

    char buf[16];
    sprintf(buf, "%d", frame);
    CStr wName(filename);
    int extLoc;
    extLoc = wName.last('.');
    if (extLoc != -1)
        wName.remove(extLoc);
    wName.Append(buf);
    wName.Append(".wrl");

 // write out the file
    WorkFile theFile(wName.data(), _T("w"));
    mStream = theFile.MStream();
    if (!mStream) {
        TCHAR msg[MAX_PATH];
        TCHAR title[MAX_PATH];
        LoadString(hInstance, IDS_OPEN_FAILED, msg, MAX_PATH);
        LoadString(hInstance, IDS_VRML_EXPORT, title, MAX_PATH);
        MessageBox(GetActiveWindow(), msg, title, MB_OK);
        return TRUE;
    }
    HCURSOR busy = LoadCursor(NULL, IDC_WAIT);
    HCURSOR normal = LoadCursor(NULL, IDC_ARROW);
    SetCursor(busy);

 // Write out the VRML header
    fprintf(mStream, _T("#VRML V2.0 utf8\n\n"));

    VrmlOutFileInfo();

 // give third party dlls a chance to write scene
    int cnt;
    for (cnt = 0; cnt < mCallbacks->GetPreSceneCount(); cnt++) {
        DllPreScene preScene = mCallbacks->GetPreScene(cnt);
        PreSceneParam params;
        params.version = 0;
        params.fName   = mFilename;
        params.i       = mIp;
        if (mStream)
            fclose(mStream), mStream = NULL;
        if ((*(preScene))(&params)) {  //third party wrote the scene
            mStream = _tfopen(mFilename, _T("a"));
            return TRUE;
        }
    }
    if (!mStream)
        mStream = _tfopen(mFilename, _T("a"));
        
 // generate the hash table of unique node names
    GenerateUniqueNodeNames(mIp->GetRootNode());

    if (mEnableProgressBar) {
        RECT rcClient;  // client area of parent window 
        int cyVScroll;  // height of a scroll bar arrow 
        hWndPDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_PROGRESSDLG),
                        GetActiveWindow(), ProgressDlgProc);
        GetClientRect(hWndPDlg, &rcClient); 
        cyVScroll = GetSystemMetrics(SM_CYVSCROLL); 
        ShowWindow(hWndPDlg, SW_SHOW);
        hWndPB = CreateWindow(PROGRESS_CLASS, (LPSTR) NULL, 
                    WS_CHILD | WS_VISIBLE, rcClient.left, 
                    rcClient.bottom - cyVScroll, 
                    rcClient.right, cyVScroll, 
                    hWndPDlg, (HMENU) 0, hInstance, NULL); 
     // Set the range and increment of the progress bar. 
        SendMessage(hWndPB, PBM_SETRANGE, 0, MAKELPARAM(0,
            CountNodes(mIp->GetRootNode()) + 1));
        SendMessage(hWndPB, PBM_SETSTEP, (WPARAM) 1, 0); 
    }

 // Write out the scene graph
    VrmlOutNode(mIp->GetRootNode(), NULL, -2, FALSE, TRUE, FALSE);

    WriteAnimRoutes();
    delete mLodList;
    delete mTimerList;
    SetCursor(normal);
    if (hWndPB) {
        DestroyWindow(hWndPB);
        hWndPB = NULL;
    }
    if (hWndPDlg) {
        DestroyWindow(hWndPDlg);
        hWndPDlg = NULL;
    }

    if(theFile.Close())
        return 0;
    
    return 1;
}
#endif

// Export the current scene as VRML
int
VRML2Export::DoExport(const TCHAR* filename, Interface* i, VRBLExport* exp)
{
    mIp = i;
    mStart = mIp->GetAnimRange().Start();

    mGenNormals      = exp->GetGenNormals();
    mIndent          = exp->GetIndent();
    mType            = exp->GetExportType();
    mUsePrefix       = exp->GetUsePrefix();
    mUrlPrefix       = exp->GetUrlPrefix();
    mCamera          = exp->GetCamera();
    mZUp             = exp->GetZUp();
    mDigits          = exp->GetDigits();
    mCoordInterp     = exp->GetCoordInterp();
    mTformSample     = exp->GetTformSample();
    mTformSampleRate = exp->GetTformSampleRate();
    mCoordSample     = exp->GetCoordSample();
    mCoordSampleRate = exp->GetCoordSampleRate();
    mNavInfo         = exp->GetNavInfo();
    mBackground      = exp->GetBackground();
    mFog             = exp->GetFog();
    mTitle           = exp->GetTitle();
    mInfo            = exp->GetInfo();
    mExportHidden    = exp->GetExportHidden();
    mPrimitives      = exp->GetPrimitives();
    mPolygonType     = exp->GetPolygonType();
    mEnableProgressBar    = exp->GetEnableProgressBar();
    mPreLight        = exp->GetPreLight();
    mCPVSource       = exp->GetCPVSource();
	mCallbacks       = exp->GetCallbacks();
    mFilename        = (TCHAR*) filename;
    
    WorkFile theFile(mFilename, _T("w"));
    mStream = theFile.MStream();

    if (!mStream) {
        TCHAR msg[MAX_PATH];
        TCHAR title[MAX_PATH];
        LoadString(hInstance, IDS_OPEN_FAILED, msg, MAX_PATH);
        LoadString(hInstance, IDS_VRML_EXPORT, title, MAX_PATH);
        MessageBox(GetActiveWindow(), msg, title, MB_OK);
        return TRUE;
    }

    HCURSOR busy = LoadCursor(NULL, IDC_WAIT);
    HCURSOR normal = LoadCursor(NULL, IDC_ARROW);
    SetCursor(busy);

 // Write out the VRML header and file info
    fprintf(mStream, _T("#VRML V2.0 utf8\n\n"));
    VrmlOutFileInfo();

 // generate the hash table of unique node names
    GenerateUniqueNodeNames(mIp->GetRootNode());

    if (mEnableProgressBar) {
        RECT rcClient;  // client area of parent window 
        int cyVScroll;  // height of a scroll bar arrow 
        hWndPDlg = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_PROGRESSDLG),
                    GetActiveWindow(), ProgressDlgProc);
        GetClientRect(hWndPDlg, &rcClient); 
        cyVScroll = GetSystemMetrics(SM_CYVSCROLL); 
        ShowWindow(hWndPDlg, SW_SHOW);
     // InitCommonControls(); 
        hWndPB = CreateWindow(PROGRESS_CLASS, (LPSTR) NULL, 
            WS_CHILD | WS_VISIBLE, rcClient.left, 
            rcClient.bottom - cyVScroll, 
            rcClient.right, cyVScroll, 
            hWndPDlg, (HMENU) 0, hInstance, NULL); 
    // Set the range and increment of the progress bar. 
        SendMessage(hWndPB, PBM_SETRANGE, 0, MAKELPARAM(0,
            CountNodes(mIp->GetRootNode()) + 1));
        SendMessage(hWndPB, PBM_SETSTEP, (WPARAM) 1, 0); 
    }
 
 // give third party dlls a chance to write before the scene was written
    BOOL written = FALSE;
    int cnt;
    for (cnt = 0; cnt < mCallbacks->GetPreSceneCount(); cnt++) {
        DllPreScene preScene = mCallbacks->GetPreScene(cnt);
        PreSceneParam params;
        params.version = 0;
        params.fName   = mFilename;
        params.i       = mIp;
        if (mStream)
            fclose(mStream), mStream = NULL;
        written = (*(preScene))(&params);   //third party wrote the scene
        if (written)
            break; // first come first served
    }
    if (!mStream)
        mStream = _tfopen(mFilename, _T("a"));
     
 // Write out the scene graph
    if (!written) {
        VrmlOutNode(mIp->GetRootNode(), NULL, -2, FALSE, TRUE, FALSE);
        WriteAnimRoutes();
        delete mLodList;
        delete mTimerList;
    }

 // give third party dlls a chance to write after the scene was written
    for (cnt = 0; cnt < mCallbacks->GetPostSceneCount(); cnt++) {
        DllPostScene postScene = mCallbacks->GetPostScene(cnt);
        PostSceneParam params;
        params.version = 0;
        params.fName   = mFilename;
        params.i       = mIp;
        if (mStream)
            fclose(mStream), mStream = NULL;
        (*(postScene))(&params);
    }
    if (!mStream)
        mStream = _tfopen(mFilename, _T("a"));
    
    SetCursor(normal);
    if (hWndPB) {
        DestroyWindow(hWndPB);
        hWndPB = NULL;
    }
    if (hWndPDlg) {
        DestroyWindow(hWndPDlg);
        hWndPDlg = NULL;
    }

    if(theFile.Close())
        return 0;

    return 1;
}


VRML2Export::VRML2Export() 
{
    mGenNormals         = FALSE;
    mHadAnim            = FALSE;
    mLodList            = NULL;
    mTimerList          = NULL;
    mTformSample        = TRUE;
    mTformSampleRate    = 10;
    mCoordSample        = FALSE;
    mCoordSampleRate    = 3;
    mHasLights          = FALSE;
    mHasNavInfo         = FALSE;
    mFlipBook           = FALSE;
}

VRML2Export::~VRML2Export() {
}

// Traverse the scene graph generating Unique Node Names
void 
VRML2Export::GenerateUniqueNodeNames(INode* node)
{
	if (!node) return;

	NodeList* nList = mNodes.AddNode(node);
	if (!nList->hasName) {
	 // take mangled name and get a unique name
		nList->name    = mNodes.AddName(VRMLName(node->GetName()));
		nList->hasName = TRUE;
	}
    
    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        GenerateUniqueNodeNames(node->GetChildNode(i));

}

static DWORD HashCode(DWORD o, int size)
{
    DWORD code = (DWORD) o;
    return (code >> 2) % size;
}

// Object Hash table stuff

ObjectBucket*
ObjectHashTable::AddObject(Object* o)
{
    DWORD hashCode = HashCode((DWORD) o, OBJECT_HASH_TABLE_SIZE);
    ObjectBucket *ob;
    
    for(ob = mTable[hashCode]; ob; ob = ob->next) {
        if (ob->obj == o) {
            return ob;
        }
    }
    ob = new ObjectBucket(o);
    ob->next = mTable[hashCode];
    mTable[hashCode] = ob;
    return ob;
}

void 
SensorHashTable::AddSensor(INode* node, INode* sensor)
{
    DWORD hashCode = HashCode((DWORD) node, SENSOR_HASH_TABLE_SIZE);
    SensorBucket *sb;
    
    for(sb = mTable[hashCode]; sb; sb = sb->mNext) {
        if (sb->mNode == node) {
            sb->mSensors = sb->mSensors->AddNode(sensor);
            return;
        }
    }
    sb = new SensorBucket(node);
    sb->mSensors = sb->mSensors->AddNode(sensor);
    sb->mNext = mTable[hashCode];
    mTable[hashCode] = sb;
}


SensorBucket* 
SensorHashTable::FindSensor(INode* node)
{
    DWORD hashCode = HashCode((DWORD) node, SENSOR_HASH_TABLE_SIZE);
    SensorBucket *sb;
    
    for(sb = mTable[hashCode]; sb; sb = sb->mNext) {
        if (sb->mNode == node) {
            return sb;
        }
    }
    return NULL;
}

// Output any grid helpers
/*
void
VRML2Export::VrmlOutGridHelpers(INode* node)
{
    if (!node) return;

    Object*  obj = node->EvalWorldState(mStart).obj;
    Class_ID id;

    if (obj) {
        id = obj->ClassID();
        if (id == Class_ID(GRIDHELP_CLASS_ID, 0)) {
            float len;
            float width;
            float grid;
            Matrix3 tm;

            len   = ((GridHelpObject*)obj)->GetLength(mStart);
            width = ((GridHelpObject*)obj)->GetWidth(mStart);
            grid  = ((GridHelpObject*)obj)->GetGrid(mStart);
            // tm    = ((GridHelpObject*)obj)->myTM; //private member
            
            int pCnt;
            pCnt = obj->NumPoints();
            for (int i = 0; i < pCnt; i++) {
                Point3 pt;
                pt = obj->GetPoint(i);
            }
        }
    }

    int n = node->NumberOfChildren();
    for (int i = 0; i < n; i++) {
        VrmlOutGridHelpers(node->GetChildNode(i));
    }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrml.h ===
/**********************************************************************
 *<
	FILE: vrml.h

	DESCRIPTION:  Basic includes for modules in vrmlexp

	CREATED BY: greg finch

	HISTORY: created 9, May 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __VRML__H__
#define __VRML__H__

#include <stdio.h>
#include "max.h"
#include "resource.h"
#include "iparamm.h"
#include "bmmlib.h"
#include "utilapi.h"
#include "decomp.h"

//#define DDECOMP
#ifdef DDECOMP
#include "cdecomp.h"
#endif

TCHAR *GetString(int id);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrml2.h ===
/**********************************************************************
 *<
	FILE: vrml2.h

	DESCRIPTION:  VRML 2.0 file export class defs

	CREATED BY: Scott Morrison

	HISTORY: created June, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#define RUN_BY_PROX_SENSOR 1
#define RUN_BY_TIME_SENSOR 2
#define RUN_BY_TOUCH_SENSOR 4
#define RUN_BY_ANY_SENSOR 7

struct AnimRoute {
    AnimRoute() { mToNode = NULL; }
    AnimRoute(TCHAR* from, TCHAR* to, INode* fromNode, INode* node)
    {
        mFromName = from;
        mToName   = to;
        mToNode   = node;
        mFromNode = fromNode;
    }
    TSTR        mFromName;      // route nodes from animate trigger
    TSTR        mToName;        // route anim trigger to
    INode*      mToNode;        // INode for route to
    INode*      mFromNode;      // INode for route from
};

struct InterpRoute {
    InterpRoute() {mType = 0;}
    InterpRoute(TCHAR* interp, int type, TCHAR* node)
    {
        mInterp = interp;
        mType = type;
        mNode = node;
    }

    TSTR mInterp;
    int  mType;
    TSTR mNode;
};

// Object hash table for instancing

struct ObjectBucket {
    ObjectBucket(Object* o)
    {
        obj = o;
        objectUsed = FALSE;
        hasName = FALSE;
        hasInstName = FALSE;
        next = NULL;
    }
    ~ObjectBucket() {delete next;}
    Object *obj;
    BOOL    objectUsed;
    BOOL    hasName;
    BOOL    hasInstName;
    TSTR    name;
    TSTR    instName;
    ObjectBucket *next;
};

#define OBJECT_HASH_TABLE_SIZE 1001

class ObjectHashTable {
  public:

    ObjectHashTable() {
        mTable.SetCount(OBJECT_HASH_TABLE_SIZE);
        for(int i = 0; i < OBJECT_HASH_TABLE_SIZE; i++)
            mTable[i] = NULL;
    }
    ~ObjectHashTable() {
        for(int i = 0; i < OBJECT_HASH_TABLE_SIZE; i++)
            delete mTable[i];
    }
        

    ObjectBucket* AddObject(Object* obj);

  private:

    Tab<ObjectBucket*> mTable;
};

struct SensorBucket {
    SensorBucket(INode * node)
    {
        mNode = node;
        mSensors = NULL;
        mNext = NULL;
    }
    ~SensorBucket()
    {
        delete mSensors;
    }
    INode* mNode;
    INodeList* mSensors;
    SensorBucket* mNext;
};

#define SENSOR_HASH_TABLE_SIZE 97

class SensorHashTable {
  public:

    SensorHashTable() {
        mTable.SetCount(SENSOR_HASH_TABLE_SIZE);
        for(int i = 0; i < SENSOR_HASH_TABLE_SIZE; i++)
            mTable[i] = NULL;
    }
    ~SensorHashTable() {
        for(int i = 0; i < SENSOR_HASH_TABLE_SIZE; i++)
            delete mTable[i];
    }
        

    void AddSensor(INode* node, INode* sensor);
    SensorBucket* FindSensor(INode* node);

  private:

    Tab<SensorBucket*> mTable;
};


class VRML2Export {
public:
    VRML2Export();
    ~VRML2Export();
    
    int   DoExport(const TCHAR *name, Interface *i, VRBLExport* exp);
#ifdef _LEC_
    int   DoFBExport(const TCHAR *name, Interface *i, VRBLExport* exp, int frame, TimeValue time);
#endif

    inline BOOL GetGenNormals() { return mGenNormals; }
    inline void SetGenNormals(BOOL gen) { mGenNormals = gen; }
    inline BOOL GetIndent() { return mIndent; }
    inline void SetIndent(BOOL in) { mIndent = in; }
    inline ExportType GetExportType() { return mType; }
    inline void SetExportType(ExportType t) { mType = t; }
    inline Interface* GetIP() { return mIp;}
    inline INode* GetCamera() { return mCamera; }
    inline void SetCamera(INode* cam) { mCamera = cam; }
    inline void SetUsePrefix(BOOL u) { mUsePrefix = u; }
    inline BOOL GetUsePrefix() { return mUsePrefix; }
    inline void SetUrlPrefix(TSTR& s) { mUrlPrefix = s; }
    inline TSTR& GetUrlPrefix() {return mUrlPrefix; }
    inline void SetFields(BOOL f) { mGenFields = f; }
    inline BOOL GetFields() { return mGenFields; }
    inline BOOL IsVRML2() { return TRUE; }
    inline BOOL GetZUp() { return mZUp; }
    inline void SetZUp(BOOL zup) {mZUp = zup; }
    inline int GetDigits() { return mDigits; }
    inline void SetDigits(int n) { mDigits = n; }
    inline BOOL GetCoordInterp() { return mCoordInterp; }
#ifdef _LEC_
    inline BOOL GetFlipBook() { return mFlipBook; }
#endif
    inline void SetCoordInterp(BOOL ci) { mZUp = ci; }
    inline BOOL GetPreLight() { return mPreLight; }
    inline void SetPreLight(BOOL i) { mPreLight = i; }
//    inline void SetPolygonType(int type)    { mPolygonType = type; }

    inline BOOL GetTformSample() { return mTformSample; }
    inline void SetTformSample(BOOL b) { mTformSample = b; }
    inline int GetTformSampleRate() { return mTformSampleRate; }
    inline void SetTformSampleRate(int rate) { mTformSampleRate = rate; }

    inline BOOL GetCoordSample() { return mCoordSample; }
    inline void SetCoordSample(BOOL b) { mCoordSample = b; }
    inline int GetCoordSampleRate() { return mCoordSampleRate; }
    inline void SetCoordSampleRate(int rate) { mCoordSampleRate = rate; }
    inline TSTR& GetInfo() { return mInfo; }
    inline void SetInfo (TCHAR* info) { mInfo = info; }
    inline TSTR& GetTitle() { return mInfo; }
    inline void SetTitle (TCHAR* title) { mTitle = title; }
    inline BOOL GetExportHidden() { return mExportHidden; }
    inline void SetExportHidden(BOOL eh) { mExportHidden = eh; }
    
    Interface* mIp;         // MAX interface pointer

private:
    TCHAR* point(Point3& p);
    TCHAR* scalePoint(Point3& p);
    TCHAR* normPoint(Point3& p);
    TCHAR* axisPoint(Point3& p, float ang);
    TCHAR* texture(UVVert& uv);
    TCHAR* color(Color& c);
    TCHAR* color(Point3& c);
    TCHAR* floatVal(float f);

    // VRML Output routines
    void Indent(int level);
    int  MaybeNewLine(int width, int level);
    void StartNode(INode* node, int level, BOOL outputName);
    void EndNode(INode* node, Object* obj, int level, BOOL lastChild);
    BOOL IsBBoxTrigger(INode* node);
    BOOL OutputNodeTransform(INode* node, int level, BOOL mirrored);
    void OutputMultiMtl(Mtl* mtl, int level);
    BOOL OutputMaterial(INode* node, BOOL& isWire, BOOL& twoSided, int level,
                        int textureNum);
    BOOL HasTexture(INode *node, BOOL& isWire);
    TSTR PrefixUrl(TSTR& fileName);
    TextureDesc* GetMtlTex(Mtl* mtl, BOOL &isWire);
    TextureDesc*GetMatTex(INode* node, BOOL& isWire);
    void OutputNormalIndices(Mesh& mesh, NormalTable* normTab, int level);
    NormalTable* OutputNormals(Mesh& mesh, int level);
    void OutputTriObject(INode* node, TriObject* obj, BOOL multiMat,
                         BOOL isWire, BOOL twoSided, int level,
                         int textureNum, BOOL pMirror);
    void OutputPolygonObject(INode* node, TriObject* obj, BOOL multiMat,
             BOOL isWire, BOOL twoSided, int level, int textureNum,
             BOOL pMirror);
    BOOL isVrmlObject(INode * node, Object *obj, INode* parent);
    BOOL ChildIsAnimated(INode* node);
    BOOL ObjIsAnimated(Object *obj);
    BOOL ObjIsPrim(INode* node, Object* obj);
    void VrmlOutObject(INode* node, INode* parent, Object* obj, int level,
                       BOOL mirrored);
    BOOL VrmlOutSphereTest(INode * node, Object *obj);
    BOOL VrmlOutSphere(INode * node, Object *obj, int level);
    BOOL VrmlOutCylinder(INode* node, Object *obj, int level);
    BOOL VrmlOutCone(INode* node, Object *obj, int level);
    BOOL VrmlOutCube(INode* node, Object *obj, int level);
    BOOL VrmlOutCamera(INode* node, Object* obj, int level);
    BOOL VrmlOutSound(INode* node, SoundObject* obj, int level);
    BOOL VrmlOutTouchSensor(INode* node, int level);
    BOOL VrmlOutProxSensor(INode* node, ProxSensorObject* obj, int level);
    BOOL VrmlOutBillboard(INode* node, Object* obj, int level);
    void VrmlOutTimeSensor(INode* node, TimeSensorObject* obj, int level);
    //void VrmlAnchorHeader(INode* node, MrBlueObject* obj,
    //                      VRBL_TriggerType type, BOOL fromParent, int level);
    //BOOL VrmlOutMrBlue(INode* node, INode* parent, MrBlueObject* obj,
    //                   int* level, BOOL fromParent);
    BOOL VrmlOutInline(VRMLInsObject* obj, int level);
    BOOL VrmlOutLOD(INode* node, LODObject* obj, int level, BOOL mirrored);
    void VrmlOutCoordinateInterpolator(INode* node, Object *obj, int level,
                                       BOOL pMirror);
    BOOL VrmlOutCylinderTest(INode* node, Object *obj);
    BOOL VrmlOutCylinderTform(INode* node, Object *obj, int level,
                              BOOL mirrored);
    BOOL VrmlOutConeTest(INode* node, Object *obj);
    BOOL VrmlOutConeTform(INode* node, Object *obj, int level, BOOL mirrored);
    BOOL VrmlOutCubeTest(INode* node, Object *obj);
    BOOL VrmlOutCubeTform(INode* node, Object *obj, int level, BOOL mirrored);
    BOOL VrmlOutSpecialTform(INode* node, Object* obj, int level,
                             BOOL mirrored);
    BOOL VrmlOutSpecial(INode* node, INode* parent, Object* obj, int level,
                        BOOL mirrored);
    //int StartMrBlueHelpers(INode* node, int level);
    //void EndMrBlueNode(INode* childNode, int& level, BOOL fromParent);
    //void EndMrBlueHelpers(INode* node, int level);
    BOOL VrmlOutPointLight(INode* node, LightObject* light, int level);
    BOOL VrmlOutDirectLight(INode* node, LightObject* light, int level);
    BOOL VrmlOutSpotLight(INode* node, LightObject* light, int level);
    BOOL VrmlOutTopPointLight(INode* node, LightObject* light);
    BOOL VrmlOutTopDirectLight(INode* node, LightObject* light);
    BOOL VrmlOutTopSpotLight(INode* node, LightObject* light);
    void OutputTopLevelLight(INode* node, LightObject *light);
    void WriteControllerData(INode* node,
                             Tab<TimeValue>& posTimes, Tab<Point3>& posKeys,
                             Tab<TimeValue>& rotTimes, Tab<AngAxis>& rotKeys,
                             Tab<TimeValue>& sclTImes, Tab<ScaleValue>& sclKeys,
                             int type, int level);
    void WriteAllControllerData(INode* node, int type, int level,
                                Control* lc);

    void WriteVisibilityData(INode* node, int level);
    BOOL IsLight(INode* node);
    BOOL IsCamera(INode* node);
	BOOL IsAudio(INode* node);
    Control* GetLightColorControl(INode* node);
    void VrmlOutControllers(INode* node, int level);
    void ScanSceneGraph1();
    void ScanSceneGraph2();
    void ComputeWorldBoundBox(INode* node, ViewExp* vpt);
    void OutputTouchSensors(INode* node, int level);
    void TraverseNode(INode* node);
    BOOL ObjectIsLODRef(INode* node);
    void VrmlOutTopLevelCamera(int level, INode* node, BOOL topLevel);
    void VrmlOutTopLevelNavInfo(int level, INode* node, BOOL topLevel);
    void VrmlOutTopLevelBackground(int level, INode* node, BOOL topLevel);
    void VrmlOutTopLevelFog(int level, INode* node, BOOL topLevel);
    void VrmlOutInitializeAudioClip(int level, INode* node);
    void VrmlOutAudioClip(int level, INode* node);
    void VrmlOutFileInfo();
    void VrmlOutWorldInfo();
    void VrmlOutGridHelpers(INode*);

    int  StartAnchor(INode* node, int& level);
    void VrmlOutNode(INode* node, INode* parent, int level, BOOL isLOD,
                     BOOL lastChild, BOOL mirrored);
    void InitInterpolators(INode* node);
    void AddInterpolator(TCHAR* interp, int type, TCHAR *name);
    void WriteInterpolatorRoutes(int level, BOOL isCamera);
    void AddCameraAnimRoutes(TCHAR* vrmlObjName, INode* fromNode, INode* top);
    void AddAnimRoute(TCHAR* from, TCHAR* to, INode* fromNode, INode* node);
    int  NodeNeedsTimeSensor(INode* node);
    void WriteAnimRoutes();
    TCHAR* VrmlParent(INode* node);
    BOOL IsAimTarget(INode* node);
    void GenerateUniqueNodeNames(INode* node);

    FILE*          mStream;     // The file mStream to write
    TCHAR*         mFilename;   // The export .WRL filename
    BOOL           mGenNormals; // Generate normals in the VRML file
    BOOL           mIndent;     // Should we indent?
    INodeList*     mLodList;    // List of LOD objects in the scene
    INodeList*     mTimerList;  // List of TimeSensor Nodes in the scene
    ExportType     mType;       // Language to export (VRML, VRML, ...)
    INode*         mCamera;     // Initial camera;
    INode*         mNavInfo;    // Initial Navigation Info;
    INode*         mBackground; // Initial Background node
    INode*         mFog;        // Initial Fog node
    BOOL           mUsePrefix;  // Use URL Prefix
    TSTR           mUrlPrefix;  // The URL prefix
    BOOL           mGenFields;  // Generate "fields" statements
    BOOL           mHadAnim;    // File has animation data
    TimeValue      mStart;      // First frame of the animation
    TSTR           mTimer;      // Name of active TimeSensor
    Tab<TSTR>      mInterps;    // Interpolators that need ROUTE statements
    Tab<int>       mInterpTypes;// Type of interpolator nodes
    Tab<TSTR>      mInterpNodes;// Nodes for interpolators
    float          mCycleInterval; // Length of animation in seconds
    Tab<InterpRoute> mInterpRoutes; // Routes for Intpolator nodes
    Tab<AnimRoute> mAnimRoutes;  // route nodes from anim
    BOOL           mZUp;        // Z axis if true, Y axis otherwise
    int            mDigits;     // Digits of precision on output
    BOOL           mCoordInterp;// Generate coordinate interpolators
#ifdef _LEC_
    BOOL           mFlipBook;   // Generate one VRML file per frame (LEC request)
#endif
    BOOL           mTformSample;// TRUE for once per frame
    int            mTformSampleRate; // Custom sample rate
    BOOL           mCoordSample; // TRUE for once per frame
    int            mCoordSampleRate; // Custom sample rate
    ObjectHashTable mObjTable;    // Hash table of all objects in the scene
    SensorHashTable mSensorTable; // Hash table of all TouchSensor and Anchors
    Box3           mBoundBox;     // Bounding box for the whole scene
    TSTR           mTitle;        // Title of world
    TSTR           mInfo;         // Info for world
    BOOL           mExportHidden; // Export hidden objects
    BOOL           mPrimitives;   // Create VRML primitves
    BOOL           mHasLights;    // TRUE iff scene has lights
    BOOL           mHasNavInfo;   // TRUE iff scene has NavigationInfo
    int             mPolygonType;   // 0 triangles, 1 quads, 2 ngons
    NodeTable       mNodes;         // hash table of all nodes name in the scene
    BOOL            mEnableProgressBar;      // this is used by the progress bar
    BOOL            mPreLight;      // should we calculate the color per vertex
    BOOL            mCPVSource;     // 1 if MAX's; 0 if should we need to calculate the color per vertex
    CallbackTable*  mCallbacks;     // export callback methods
};

float GetLosProxDist(INode* node, TimeValue t);
Point3 GetLosVector(INode* node, TimeValue t);

int reduceAngAxisKeys(Tab<TimeValue>& times, Tab<AngAxis>& points, float eps);
int reducePoint3Keys(Tab<TimeValue>& times, Tab<Point3>& points, float eps);
int reduceScaleValueKeys(Tab<TimeValue>& times, Tab<ScaleValue>& points,
                         float eps);
void CommaScan(TCHAR* buf);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrmlpch.cpp ===
/**********************************************************************
 *<
	FILE: vrmlpch.cpp

	DESCRIPTION:  for precompiled headers

	CREATED BY: greg finch

	HISTORY: created 9 May, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#include "vrml.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\touchob.cpp ===
mesh.setNumVerts(85);
    mesh.setNumFaces(159);
    mesh.setVert(0, size * Point3(-0.707107,0.707107,0.000000));
    mesh.setVert(1, size * Point3(0.000000,0.707107,0.000000));
    mesh.setVert(2, size * Point3(0.707107,0.707107,0.000000));
    mesh.setVert(3, size * Point3(-0.707107,-0.707107,0.000000));
    mesh.setVert(4, size * Point3(0.000000,-0.707107,0.000000));
    mesh.setVert(5, size * Point3(0.707107,-0.707107,0.000000));
    mesh.setVert(6, size * Point3(0.707107,-0.000000,0.000000));
    mesh.setVert(7, size * Point3(0.000000,0.000000,-0.669280));
    mesh.setVert(8, size * Point3(-0.707107,-0.000000,0.000000));
    mesh.setVert(9, size * Point3(0.000000,-0.000000,0.669281));
    mesh.setVert(10, size * Point3(0.458419,0.170696,-0.178401));
    mesh.setVert(11, size * Point3(0.457170,0.170696,0.049288));
    mesh.setVert(12, size * Point3(0.340297,0.170696,0.049288));
    mesh.setVert(13, size * Point3(0.168722,0.170696,0.163928));
    mesh.setVert(14, size * Point3(0.061433,0.170696,0.193161));
    mesh.setVert(15, size * Point3(0.039684,0.170696,0.187494));
    mesh.setVert(16, size * Point3(0.020348,0.170696,0.177591));
    mesh.setVert(17, size * Point3(0.003928,0.170696,0.163536));
    mesh.setVert(18, size * Point3(-0.009074,0.170696,0.145410));
    mesh.setVert(19, size * Point3(-0.018155,0.170696,0.123299));
    mesh.setVert(20, size * Point3(0.078938,0.170696,0.125184));
    mesh.setVert(21, size * Point3(0.079553,0.170696,0.099434));
    mesh.setVert(22, size * Point3(-0.452307,0.170696,0.041320));
    mesh.setVert(23, size * Point3(-0.449560,0.170696,0.034797));
    mesh.setVert(24, size * Point3(-0.445339,0.170696,0.027461));
    mesh.setVert(25, size * Point3(-0.439934,0.170696,0.020036));
    mesh.setVert(26, size * Point3(-0.433637,0.170696,0.013248));
    mesh.setVert(27, size * Point3(-0.426741,0.170696,0.007822));
    mesh.setVert(28, size * Point3(-0.109661,0.170696,-0.011939));
    mesh.setVert(29, size * Point3(-0.119484,0.170696,-0.022339));
    mesh.setVert(30, size * Point3(-0.127714,0.170696,-0.032878));
    mesh.setVert(31, size * Point3(-0.133821,0.170696,-0.043604));
    mesh.setVert(32, size * Point3(-0.137273,0.170696,-0.054562));
    mesh.setVert(33, size * Point3(-0.137540,0.170696,-0.065799));
    mesh.setVert(34, size * Point3(-0.129585,0.170696,-0.079652));
    mesh.setVert(35, size * Point3(-0.117114,0.170696,-0.090437));
    mesh.setVert(36, size * Point3(-0.024433,0.170696,-0.129752));
    mesh.setVert(37, size * Point3(-0.051952,0.170696,-0.183703));
    mesh.setVert(38, size * Point3(-0.050445,0.170696,-0.197161));
    mesh.setVert(39, size * Point3(-0.043905,0.170696,-0.210602));
    mesh.setVert(40, size * Point3(0.064145,0.170696,-0.208957));
    mesh.setVert(41, size * Point3(0.032648,0.170696,-0.259994));
    mesh.setVert(42, size * Point3(0.031362,0.170696,-0.271953));
    mesh.setVert(43, size * Point3(0.034467,0.170696,-0.283379));
    mesh.setVert(44, size * Point3(0.042843,0.170696,-0.294164));
    mesh.setVert(45, size * Point3(0.061914,0.170696,-0.301936));
    mesh.setVert(46, size * Point3(0.247312,0.170696,-0.295252));
    mesh.setVert(47, size * Point3(0.373608,0.170696,-0.178401));
    mesh.setVert(48, size * Point3(0.458419,-0.120691,-0.178401));
    mesh.setVert(49, size * Point3(0.457170,-0.120691,0.049288));
    mesh.setVert(50, size * Point3(0.340297,-0.120691,0.049288));
    mesh.setVert(51, size * Point3(0.168722,-0.120691,0.163928));
    mesh.setVert(52, size * Point3(0.061433,-0.120691,0.193161));
    mesh.setVert(53, size * Point3(0.039684,-0.120691,0.187494));
    mesh.setVert(54, size * Point3(0.020348,-0.120691,0.177591));
    mesh.setVert(55, size * Point3(0.003928,-0.120691,0.163536));
    mesh.setVert(56, size * Point3(-0.009074,-0.120691,0.145410));
    mesh.setVert(57, size * Point3(-0.018155,-0.120691,0.123299));
    mesh.setVert(58, size * Point3(0.078938,-0.120691,0.125184));
    mesh.setVert(59, size * Point3(0.079553,-0.120691,0.099434));
    mesh.setVert(60, size * Point3(-0.452307,-0.120691,0.041320));
    mesh.setVert(61, size * Point3(-0.449560,-0.120691,0.034797));
    mesh.setVert(62, size * Point3(-0.445339,-0.120691,0.027461));
    mesh.setVert(63, size * Point3(-0.439934,-0.120691,0.020036));
    mesh.setVert(64, size * Point3(-0.433637,-0.120691,0.013248));
    mesh.setVert(65, size * Point3(-0.426741,-0.120691,0.007822));
    mesh.setVert(66, size * Point3(-0.109661,-0.120691,-0.011939));
    mesh.setVert(67, size * Point3(-0.119484,-0.120691,-0.022339));
    mesh.setVert(68, size * Point3(-0.127714,-0.120691,-0.032878));
    mesh.setVert(69, size * Point3(-0.133821,-0.120691,-0.043604));
    mesh.setVert(70, size * Point3(-0.137273,-0.120691,-0.054562));
    mesh.setVert(71, size * Point3(-0.137540,-0.120691,-0.065799));
    mesh.setVert(72, size * Point3(-0.129585,-0.120691,-0.079652));
    mesh.setVert(73, size * Point3(-0.037121,-0.120691,-0.113132));
    mesh.setVert(74, size * Point3(-0.013359,-0.120691,-0.116250));
    mesh.setVert(75, size * Point3(-0.051952,-0.120691,-0.183703));
    mesh.setVert(76, size * Point3(-0.050445,-0.120691,-0.197161));
    mesh.setVert(77, size * Point3(-0.043905,-0.120691,-0.210602));
    mesh.setVert(78, size * Point3(0.064145,-0.120691,-0.208957));
    mesh.setVert(79, size * Point3(0.031362,-0.120691,-0.271953));
    mesh.setVert(80, size * Point3(0.034467,-0.120691,-0.283379));
    mesh.setVert(81, size * Point3(0.042843,-0.120691,-0.294164));
    mesh.setVert(82, size * Point3(0.061914,-0.120691,-0.301936));
    mesh.setVert(83, size * Point3(0.247312,-0.120691,-0.295252));
    mesh.setVert(84, size * Point3(0.373608,-0.120691,-0.178401));
    mesh.faces[0].setVerts(7,8,1);
    mesh.faces[0].setEdgeVisFlags(1,1,1);
    mesh.faces[0].setSmGroup(20);
    mesh.faces[1].setVerts(7,6,4);
    mesh.faces[1].setEdgeVisFlags(1,1,1);
    mesh.faces[1].setSmGroup(20);
    mesh.faces[2].setVerts(4,8,7);
    mesh.faces[2].setEdgeVisFlags(1,1,1);
    mesh.faces[2].setSmGroup(0);
    mesh.faces[3].setVerts(6,7,4);
    mesh.faces[3].setEdgeVisFlags(1,1,1);
    mesh.faces[3].setSmGroup(0);
    mesh.faces[4].setVerts(7,1,6);
    mesh.faces[4].setEdgeVisFlags(1,1,1);
    mesh.faces[4].setSmGroup(0);
    mesh.faces[5].setVerts(8,7,1);
    mesh.faces[5].setEdgeVisFlags(1,1,1);
    mesh.faces[5].setSmGroup(0);
    mesh.faces[6].setVerts(8,9,1);
    mesh.faces[6].setEdgeVisFlags(1,1,0);
    mesh.faces[6].setSmGroup(20);
    mesh.faces[7].setVerts(6,9,4);
    mesh.faces[7].setEdgeVisFlags(1,1,0);
    mesh.faces[7].setSmGroup(20);
    mesh.faces[8].setVerts(8,4,9);
    mesh.faces[8].setEdgeVisFlags(1,1,1);
    mesh.faces[8].setSmGroup(0);
    mesh.faces[9].setVerts(6,9,4);
    mesh.faces[9].setEdgeVisFlags(1,1,1);
    mesh.faces[9].setSmGroup(0);
    mesh.faces[10].setVerts(1,9,6);
    mesh.faces[10].setEdgeVisFlags(1,1,1);
    mesh.faces[10].setSmGroup(0);
    mesh.faces[11].setVerts(8,9,1);
    mesh.faces[11].setEdgeVisFlags(1,1,1);
    mesh.faces[11].setSmGroup(0);
    mesh.faces[12].setVerts(8,1,9);
    mesh.faces[12].setEdgeVisFlags(1,1,1);
    mesh.faces[12].setSmGroup(0);
    mesh.faces[13].setVerts(10,11,49);
    mesh.faces[13].setEdgeVisFlags(1,1,0);
    mesh.faces[13].setSmGroup(2);
    mesh.faces[14].setVerts(10,49,48);
    mesh.faces[14].setEdgeVisFlags(0,1,1);
    mesh.faces[14].setSmGroup(2);
    mesh.faces[15].setVerts(11,12,50);
    mesh.faces[15].setEdgeVisFlags(1,1,0);
    mesh.faces[15].setSmGroup(4);
    mesh.faces[16].setVerts(11,50,49);
    mesh.faces[16].setEdgeVisFlags(0,1,1);
    mesh.faces[16].setSmGroup(4);
    mesh.faces[17].setVerts(12,13,51);
    mesh.faces[17].setEdgeVisFlags(1,1,0);
    mesh.faces[17].setSmGroup(2);
    mesh.faces[18].setVerts(12,51,50);
    mesh.faces[18].setEdgeVisFlags(0,1,1);
    mesh.faces[18].setSmGroup(2);
    mesh.faces[19].setVerts(13,14,52);
    mesh.faces[19].setEdgeVisFlags(1,1,0);
    mesh.faces[19].setSmGroup(2);
    mesh.faces[20].setVerts(13,52,51);
    mesh.faces[20].setEdgeVisFlags(0,1,1);
    mesh.faces[20].setSmGroup(2);
    mesh.faces[21].setVerts(14,15,53);
    mesh.faces[21].setEdgeVisFlags(1,1,0);
    mesh.faces[21].setSmGroup(2);
    mesh.faces[22].setVerts(14,53,52);
    mesh.faces[22].setEdgeVisFlags(0,1,1);
    mesh.faces[22].setSmGroup(2);
    mesh.faces[23].setVerts(15,16,54);
    mesh.faces[23].setEdgeVisFlags(1,1,0);
    mesh.faces[23].setSmGroup(2);
    mesh.faces[24].setVerts(15,54,53);
    mesh.faces[24].setEdgeVisFlags(0,1,1);
    mesh.faces[24].setSmGroup(2);
    mesh.faces[25].setVerts(16,17,55);
    mesh.faces[25].setEdgeVisFlags(1,1,0);
    mesh.faces[25].setSmGroup(2);
    mesh.faces[26].setVerts(16,55,54);
    mesh.faces[26].setEdgeVisFlags(0,1,1);
    mesh.faces[26].setSmGroup(2);
    mesh.faces[27].setVerts(17,18,56);
    mesh.faces[27].setEdgeVisFlags(1,1,0);
    mesh.faces[27].setSmGroup(2);
    mesh.faces[28].setVerts(17,56,55);
    mesh.faces[28].setEdgeVisFlags(0,1,1);
    mesh.faces[28].setSmGroup(2);
    mesh.faces[29].setVerts(18,19,57);
    mesh.faces[29].setEdgeVisFlags(1,1,0);
    mesh.faces[29].setSmGroup(2);
    mesh.faces[30].setVerts(18,57,56);
    mesh.faces[30].setEdgeVisFlags(0,1,1);
    mesh.faces[30].setSmGroup(2);
    mesh.faces[31].setVerts(19,20,58);
    mesh.faces[31].setEdgeVisFlags(1,1,0);
    mesh.faces[31].setSmGroup(4);
    mesh.faces[32].setVerts(19,58,57);
    mesh.faces[32].setEdgeVisFlags(0,1,1);
    mesh.faces[32].setSmGroup(4);
    mesh.faces[33].setVerts(20,21,59);
    mesh.faces[33].setEdgeVisFlags(1,1,0);
    mesh.faces[33].setSmGroup(2);
    mesh.faces[34].setVerts(20,59,58);
    mesh.faces[34].setEdgeVisFlags(0,1,1);
    mesh.faces[34].setSmGroup(2);
    mesh.faces[35].setVerts(21,22,60);
    mesh.faces[35].setEdgeVisFlags(1,1,0);
    mesh.faces[35].setSmGroup(4);
    mesh.faces[36].setVerts(21,60,59);
    mesh.faces[36].setEdgeVisFlags(0,1,1);
    mesh.faces[36].setSmGroup(4);
    mesh.faces[37].setVerts(22,23,61);
    mesh.faces[37].setEdgeVisFlags(1,1,0);
    mesh.faces[37].setSmGroup(4);
    mesh.faces[38].setVerts(22,61,60);
    mesh.faces[38].setEdgeVisFlags(0,1,1);
    mesh.faces[38].setSmGroup(4);
    mesh.faces[39].setVerts(23,24,62);
    mesh.faces[39].setEdgeVisFlags(1,1,0);
    mesh.faces[39].setSmGroup(4);
    mesh.faces[40].setVerts(23,62,61);
    mesh.faces[40].setEdgeVisFlags(0,1,1);
    mesh.faces[40].setSmGroup(4);
    mesh.faces[41].setVerts(24,25,63);
    mesh.faces[41].setEdgeVisFlags(1,1,0);
    mesh.faces[41].setSmGroup(4);
    mesh.faces[42].setVerts(24,63,62);
    mesh.faces[42].setEdgeVisFlags(0,1,1);
    mesh.faces[42].setSmGroup(4);
    mesh.faces[43].setVerts(25,26,64);
    mesh.faces[43].setEdgeVisFlags(1,1,0);
    mesh.faces[43].setSmGroup(4);
    mesh.faces[44].setVerts(25,64,63);
    mesh.faces[44].setEdgeVisFlags(0,1,1);
    mesh.faces[44].setSmGroup(4);
    mesh.faces[45].setVerts(26,27,65);
    mesh.faces[45].setEdgeVisFlags(1,1,0);
    mesh.faces[45].setSmGroup(4);
    mesh.faces[46].setVerts(26,65,64);
    mesh.faces[46].setEdgeVisFlags(0,1,1);
    mesh.faces[46].setSmGroup(4);
    mesh.faces[47].setVerts(27,28,66);
    mesh.faces[47].setEdgeVisFlags(1,1,0);
    mesh.faces[47].setSmGroup(4);
    mesh.faces[48].setVerts(27,66,65);
    mesh.faces[48].setEdgeVisFlags(0,1,1);
    mesh.faces[48].setSmGroup(4);
    mesh.faces[49].setVerts(28,29,67);
    mesh.faces[49].setEdgeVisFlags(1,1,0);
    mesh.faces[49].setSmGroup(2);
    mesh.faces[50].setVerts(28,67,66);
    mesh.faces[50].setEdgeVisFlags(0,1,1);
    mesh.faces[50].setSmGroup(2);
    mesh.faces[51].setVerts(29,30,68);
    mesh.faces[51].setEdgeVisFlags(1,1,0);
    mesh.faces[51].setSmGroup(2);
    mesh.faces[52].setVerts(29,68,67);
    mesh.faces[52].setEdgeVisFlags(0,1,1);
    mesh.faces[52].setSmGroup(2);
    mesh.faces[53].setVerts(30,31,69);
    mesh.faces[53].setEdgeVisFlags(1,1,0);
    mesh.faces[53].setSmGroup(2);
    mesh.faces[54].setVerts(30,69,68);
    mesh.faces[54].setEdgeVisFlags(0,1,1);
    mesh.faces[54].setSmGroup(2);
    mesh.faces[55].setVerts(31,32,70);
    mesh.faces[55].setEdgeVisFlags(1,1,0);
    mesh.faces[55].setSmGroup(2);
    mesh.faces[56].setVerts(31,70,69);
    mesh.faces[56].setEdgeVisFlags(0,1,1);
    mesh.faces[56].setSmGroup(2);
    mesh.faces[57].setVerts(32,33,71);
    mesh.faces[57].setEdgeVisFlags(1,1,0);
    mesh.faces[57].setSmGroup(2);
    mesh.faces[58].setVerts(32,71,70);
    mesh.faces[58].setEdgeVisFlags(0,1,1);
    mesh.faces[58].setSmGroup(2);
    mesh.faces[59].setVerts(33,34,72);
    mesh.faces[59].setEdgeVisFlags(1,1,0);
    mesh.faces[59].setSmGroup(4);
    mesh.faces[60].setVerts(33,72,71);
    mesh.faces[60].setEdgeVisFlags(0,1,1);
    mesh.faces[60].setSmGroup(4);
    mesh.faces[61].setVerts(34,35,72);
    mesh.faces[61].setEdgeVisFlags(1,1,0);
    mesh.faces[61].setSmGroup(4);
    mesh.faces[62].setVerts(35,36,73);
    mesh.faces[62].setEdgeVisFlags(1,1,0);
    mesh.faces[62].setSmGroup(4);
    mesh.faces[63].setVerts(35,73,72);
    mesh.faces[63].setEdgeVisFlags(0,1,1);
    mesh.faces[63].setSmGroup(4);
    mesh.faces[64].setVerts(36,74,73);
    mesh.faces[64].setEdgeVisFlags(0,1,1);
    mesh.faces[64].setSmGroup(4);
    mesh.faces[65].setVerts(36,37,75);
    mesh.faces[65].setEdgeVisFlags(1,1,0);
    mesh.faces[65].setSmGroup(2);
    mesh.faces[66].setVerts(36,75,74);
    mesh.faces[66].setEdgeVisFlags(0,1,1);
    mesh.faces[66].setSmGroup(2);
    mesh.faces[67].setVerts(37,38,76);
    mesh.faces[67].setEdgeVisFlags(1,1,0);
    mesh.faces[67].setSmGroup(2);
    mesh.faces[68].setVerts(37,76,75);
    mesh.faces[68].setEdgeVisFlags(0,1,1);
    mesh.faces[68].setSmGroup(2);
    mesh.faces[69].setVerts(38,39,77);
    mesh.faces[69].setEdgeVisFlags(1,1,0);
    mesh.faces[69].setSmGroup(2);
    mesh.faces[70].setVerts(38,77,76);
    mesh.faces[70].setEdgeVisFlags(0,1,1);
    mesh.faces[70].setSmGroup(2);
    mesh.faces[71].setVerts(39,40,78);
    mesh.faces[71].setEdgeVisFlags(1,1,0);
    mesh.faces[71].setSmGroup(4);
    mesh.faces[72].setVerts(39,78,77);
    mesh.faces[72].setEdgeVisFlags(0,1,1);
    mesh.faces[72].setSmGroup(4);
    mesh.faces[73].setVerts(40,41,78);
    mesh.faces[73].setEdgeVisFlags(1,1,0);
    mesh.faces[73].setSmGroup(2);
    mesh.faces[74].setVerts(41,79,78);
    mesh.faces[74].setEdgeVisFlags(0,1,1);
    mesh.faces[74].setSmGroup(2);
    mesh.faces[75].setVerts(41,42,79);
    mesh.faces[75].setEdgeVisFlags(1,1,0);
    mesh.faces[75].setSmGroup(2);
    mesh.faces[76].setVerts(42,43,80);
    mesh.faces[76].setEdgeVisFlags(1,1,0);
    mesh.faces[76].setSmGroup(2);
    mesh.faces[77].setVerts(42,80,79);
    mesh.faces[77].setEdgeVisFlags(0,1,1);
    mesh.faces[77].setSmGroup(2);
    mesh.faces[78].setVerts(43,44,81);
    mesh.faces[78].setEdgeVisFlags(1,1,0);
    mesh.faces[78].setSmGroup(2);
    mesh.faces[79].setVerts(43,81,80);
    mesh.faces[79].setEdgeVisFlags(0,1,1);
    mesh.faces[79].setSmGroup(2);
    mesh.faces[80].setVerts(44,45,82);
    mesh.faces[80].setEdgeVisFlags(1,1,0);
    mesh.faces[80].setSmGroup(2);
    mesh.faces[81].setVerts(44,82,81);
    mesh.faces[81].setEdgeVisFlags(0,1,1);
    mesh.faces[81].setSmGroup(2);
    mesh.faces[82].setVerts(45,46,83);
    mesh.faces[82].setEdgeVisFlags(1,1,0);
    mesh.faces[82].setSmGroup(2);
    mesh.faces[83].setVerts(45,83,82);
    mesh.faces[83].setEdgeVisFlags(0,1,1);
    mesh.faces[83].setSmGroup(2);
    mesh.faces[84].setVerts(46,47,84);
    mesh.faces[84].setEdgeVisFlags(1,1,0);
    mesh.faces[84].setSmGroup(4);
    mesh.faces[85].setVerts(46,84,83);
    mesh.faces[85].setEdgeVisFlags(0,1,1);
    mesh.faces[85].setSmGroup(4);
    mesh.faces[86].setVerts(47,10,48);
    mesh.faces[86].setEdgeVisFlags(1,1,0);
    mesh.faces[86].setSmGroup(2);
    mesh.faces[87].setVerts(47,48,84);
    mesh.faces[87].setEdgeVisFlags(0,1,1);
    mesh.faces[87].setSmGroup(2);
    mesh.faces[88].setVerts(18,20,19);
    mesh.faces[88].setEdgeVisFlags(0,1,1);
    mesh.faces[88].setSmGroup(10);
    mesh.faces[89].setVerts(17,20,18);
    mesh.faces[89].setEdgeVisFlags(0,0,1);
    mesh.faces[89].setSmGroup(10);
    mesh.faces[90].setVerts(16,20,17);
    mesh.faces[90].setEdgeVisFlags(0,0,1);
    mesh.faces[90].setSmGroup(10);
    mesh.faces[91].setVerts(15,20,16);
    mesh.faces[91].setEdgeVisFlags(0,0,1);
    mesh.faces[91].setSmGroup(10);
    mesh.faces[92].setVerts(14,20,15);
    mesh.faces[92].setEdgeVisFlags(0,0,1);
    mesh.faces[92].setSmGroup(10);
    mesh.faces[93].setVerts(13,20,14);
    mesh.faces[93].setEdgeVisFlags(0,0,1);
    mesh.faces[93].setSmGroup(10);
    mesh.faces[94].setVerts(10,12,11);
    mesh.faces[94].setEdgeVisFlags(0,0,1);
    mesh.faces[94].setSmGroup(10);
    mesh.faces[95].setVerts(13,21,20);
    mesh.faces[95].setEdgeVisFlags(0,1,0);
    mesh.faces[95].setSmGroup(10);
    mesh.faces[96].setVerts(47,12,10);
    mesh.faces[96].setEdgeVisFlags(0,0,0);
    mesh.faces[96].setSmGroup(10);
    mesh.faces[97].setVerts(46,12,47);
    mesh.faces[97].setEdgeVisFlags(0,0,1);
    mesh.faces[97].setSmGroup(10);
    mesh.faces[98].setVerts(46,13,12);
    mesh.faces[98].setEdgeVisFlags(0,1,0);
    mesh.faces[98].setSmGroup(10);
    mesh.faces[99].setVerts(46,21,13);
    mesh.faces[99].setEdgeVisFlags(0,0,0);
    mesh.faces[99].setSmGroup(10);
    mesh.faces[100].setVerts(45,21,46);
    mesh.faces[100].setEdgeVisFlags(0,0,1);
    mesh.faces[100].setSmGroup(10);
    mesh.faces[101].setVerts(32,34,33);
    mesh.faces[101].setEdgeVisFlags(0,1,1);
    mesh.faces[101].setSmGroup(10);
    mesh.faces[102].setVerts(31,34,32);
    mesh.faces[102].setEdgeVisFlags(0,0,1);
    mesh.faces[102].setSmGroup(10);
    mesh.faces[103].setVerts(31,35,34);
    mesh.faces[103].setEdgeVisFlags(0,1,0);
    mesh.faces[103].setSmGroup(10);
    mesh.faces[104].setVerts(30,35,31);
    mesh.faces[104].setEdgeVisFlags(0,0,1);
    mesh.faces[104].setSmGroup(10);
    mesh.faces[105].setVerts(29,35,30);
    mesh.faces[105].setEdgeVisFlags(0,0,1);
    mesh.faces[105].setSmGroup(10);
    mesh.faces[106].setVerts(29,36,35);
    mesh.faces[106].setEdgeVisFlags(0,1,0);
    mesh.faces[106].setSmGroup(10);
    mesh.faces[107].setVerts(28,36,29);
    mesh.faces[107].setEdgeVisFlags(0,0,1);
    mesh.faces[107].setSmGroup(10);
    mesh.faces[108].setVerts(21,23,22);
    mesh.faces[108].setEdgeVisFlags(0,1,0);
    mesh.faces[108].setSmGroup(10);
    mesh.faces[109].setVerts(21,24,23);
    mesh.faces[109].setEdgeVisFlags(0,1,0);
    mesh.faces[109].setSmGroup(10);
    mesh.faces[110].setVerts(21,25,24);
    mesh.faces[110].setEdgeVisFlags(0,1,0);
    mesh.faces[110].setSmGroup(10);
    mesh.faces[111].setVerts(21,26,25);
    mesh.faces[111].setEdgeVisFlags(0,1,0);
    mesh.faces[111].setSmGroup(10);
    mesh.faces[112].setVerts(21,27,26);
    mesh.faces[112].setEdgeVisFlags(0,1,0);
    mesh.faces[112].setSmGroup(10);
    mesh.faces[113].setVerts(21,28,27);
    mesh.faces[113].setEdgeVisFlags(0,1,0);
    mesh.faces[113].setSmGroup(10);
    mesh.faces[114].setVerts(21,36,28);
    mesh.faces[114].setEdgeVisFlags(0,0,0);
    mesh.faces[114].setSmGroup(10);
    mesh.faces[115].setVerts(43,45,44);
    mesh.faces[115].setEdgeVisFlags(0,1,1);
    mesh.faces[115].setSmGroup(10);
    mesh.faces[116].setVerts(42,45,43);
    mesh.faces[116].setEdgeVisFlags(0,0,1);
    mesh.faces[116].setSmGroup(10);
    mesh.faces[117].setVerts(41,45,42);
    mesh.faces[117].setEdgeVisFlags(0,0,1);
    mesh.faces[117].setSmGroup(10);
    mesh.faces[118].setVerts(40,45,41);
    mesh.faces[118].setEdgeVisFlags(0,0,1);
    mesh.faces[118].setSmGroup(10);
    mesh.faces[119].setVerts(40,21,45);
    mesh.faces[119].setEdgeVisFlags(0,0,0);
    mesh.faces[119].setSmGroup(10);
    mesh.faces[120].setVerts(40,36,21);
    mesh.faces[120].setEdgeVisFlags(0,0,0);
    mesh.faces[120].setSmGroup(10);
    mesh.faces[121].setVerts(40,37,36);
    mesh.faces[121].setEdgeVisFlags(0,1,0);
    mesh.faces[121].setSmGroup(10);
    mesh.faces[122].setVerts(39,37,40);
    mesh.faces[122].setEdgeVisFlags(0,0,1);
    mesh.faces[122].setSmGroup(10);
    mesh.faces[123].setVerts(39,38,37);
    mesh.faces[123].setEdgeVisFlags(0,1,0);
    mesh.faces[123].setSmGroup(10);
    mesh.faces[124].setVerts(56,57,58);
    mesh.faces[124].setEdgeVisFlags(1,1,0);
    mesh.faces[124].setSmGroup(10);
    mesh.faces[125].setVerts(55,56,58);
    mesh.faces[125].setEdgeVisFlags(1,0,0);
    mesh.faces[125].setSmGroup(10);
    mesh.faces[126].setVerts(54,55,58);
    mesh.faces[126].setEdgeVisFlags(1,0,0);
    mesh.faces[126].setSmGroup(10);
    mesh.faces[127].setVerts(53,54,58);
    mesh.faces[127].setEdgeVisFlags(1,0,0);
    mesh.faces[127].setSmGroup(10);
    mesh.faces[128].setVerts(52,53,58);
    mesh.faces[128].setEdgeVisFlags(1,0,0);
    mesh.faces[128].setSmGroup(10);
    mesh.faces[129].setVerts(51,52,58);
    mesh.faces[129].setEdgeVisFlags(1,0,0);
    mesh.faces[129].setSmGroup(10);
    mesh.faces[130].setVerts(48,49,50);
    mesh.faces[130].setEdgeVisFlags(1,0,0);
    mesh.faces[130].setSmGroup(10);
    mesh.faces[131].setVerts(51,58,59);
    mesh.faces[131].setEdgeVisFlags(0,1,0);
    mesh.faces[131].setSmGroup(10);
    mesh.faces[132].setVerts(84,48,50);
    mesh.faces[132].setEdgeVisFlags(0,0,0);
    mesh.faces[132].setSmGroup(10);
    mesh.faces[133].setVerts(83,84,50);
    mesh.faces[133].setEdgeVisFlags(1,0,0);
    mesh.faces[133].setSmGroup(10);
    mesh.faces[134].setVerts(83,50,51);
    mesh.faces[134].setEdgeVisFlags(0,1,0);
    mesh.faces[134].setSmGroup(10);
    mesh.faces[135].setVerts(83,51,59);
    mesh.faces[135].setEdgeVisFlags(0,0,0);
    mesh.faces[135].setSmGroup(10);
    mesh.faces[136].setVerts(82,83,59);
    mesh.faces[136].setEdgeVisFlags(1,0,0);
    mesh.faces[136].setSmGroup(10);
    mesh.faces[137].setVerts(70,71,72);
    mesh.faces[137].setEdgeVisFlags(1,1,0);
    mesh.faces[137].setSmGroup(10);
    mesh.faces[138].setVerts(69,70,72);
    mesh.faces[138].setEdgeVisFlags(1,0,0);
    mesh.faces[138].setSmGroup(10);
    mesh.faces[139].setVerts(68,69,72);
    mesh.faces[139].setEdgeVisFlags(1,0,0);
    mesh.faces[139].setSmGroup(10);
    mesh.faces[140].setVerts(67,68,72);
    mesh.faces[140].setEdgeVisFlags(1,0,0);
    mesh.faces[140].setSmGroup(10);
    mesh.faces[141].setVerts(67,72,73);
    mesh.faces[141].setEdgeVisFlags(0,1,0);
    mesh.faces[141].setSmGroup(10);
    mesh.faces[142].setVerts(66,67,73);
    mesh.faces[142].setEdgeVisFlags(1,0,0);
    mesh.faces[142].setSmGroup(10);
    mesh.faces[143].setVerts(66,73,74);
    mesh.faces[143].setEdgeVisFlags(0,1,0);
    mesh.faces[143].setSmGroup(10);
    mesh.faces[144].setVerts(59,60,61);
    mesh.faces[144].setEdgeVisFlags(0,1,0);
    mesh.faces[144].setSmGroup(10);
    mesh.faces[145].setVerts(59,61,62);
    mesh.faces[145].setEdgeVisFlags(0,1,0);
    mesh.faces[145].setSmGroup(10);
    mesh.faces[146].setVerts(59,62,63);
    mesh.faces[146].setEdgeVisFlags(0,1,0);
    mesh.faces[146].setSmGroup(10);
    mesh.faces[147].setVerts(59,63,64);
    mesh.faces[147].setEdgeVisFlags(0,1,0);
    mesh.faces[147].setSmGroup(10);
    mesh.faces[148].setVerts(59,64,65);
    mesh.faces[148].setEdgeVisFlags(0,1,0);
    mesh.faces[148].setSmGroup(10);
    mesh.faces[149].setVerts(59,65,66);
    mesh.faces[149].setEdgeVisFlags(0,1,0);
    mesh.faces[149].setSmGroup(10);
    mesh.faces[150].setVerts(59,66,74);
    mesh.faces[150].setEdgeVisFlags(0,0,0);
    mesh.faces[150].setSmGroup(10);
    mesh.faces[151].setVerts(80,81,82);
    mesh.faces[151].setEdgeVisFlags(1,1,0);
    mesh.faces[151].setSmGroup(10);
    mesh.faces[152].setVerts(79,80,82);
    mesh.faces[152].setEdgeVisFlags(1,0,0);
    mesh.faces[152].setSmGroup(10);
    mesh.faces[153].setVerts(78,79,82);
    mesh.faces[153].setEdgeVisFlags(1,0,0);
    mesh.faces[153].setSmGroup(10);
    mesh.faces[154].setVerts(78,82,59);
    mesh.faces[154].setEdgeVisFlags(0,0,0);
    mesh.faces[154].setSmGroup(10);
    mesh.faces[155].setVerts(78,59,74);
    mesh.faces[155].setEdgeVisFlags(0,0,0);
    mesh.faces[155].setSmGroup(10);
    mesh.faces[156].setVerts(78,74,75);
    mesh.faces[156].setEdgeVisFlags(0,1,0);
    mesh.faces[156].setSmGroup(10);
    mesh.faces[157].setVerts(77,78,75);
    mesh.faces[157].setEdgeVisFlags(1,0,0);
    mesh.faces[157].setSmGroup(10);
    mesh.faces[158].setVerts(77,75,76);
    mesh.faces[158].setEdgeVisFlags(0,1,0);
    mesh.faces[158].setSmGroup(10);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrmlexp.h ===
/**********************************************************************
 *<
	FILE: vrmlexp.h

	DESCRIPTION:  VRML.WRL file export class defs

	CREATED BY: Scott Morrison

	HISTORY: created 15 February, 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

// these are used for the type of output polygon
#define OUTPUT_TRIANGLES        0
#define OUTPUT_QUADS            1
#define OUTPUT_NGONS            2
#define OUTPUT_VISIBLE_EDGES    3

// Animation key types
#define KEY_FLOAT	 (1<<0)
#define KEY_POS		 (1<<1)
#define KEY_ROT		 (1<<2)
#define KEY_SCL		 (1<<3)
#define KEY_COLOR	 (1<<4)
#define KEY_COORD	 (1<<5)
#define KEY_TIMER	 (1<<6)
#define KEY_TIMER_SCRIPT (1<<7)
#define KEY_SCL_ORI  (1<<8)


#define VRBL_EXPORT_CLASS_ID 0xACAD8213

// Enum indicating the type of export we are performing
//------------------------------------------------------

enum ExportType {
    Export_VRBL,
    Export_VRML_1_0,
    Export_VRML_2_0
};

class TextureDesc {
public:
    TextureDesc(BitmapTex* t, TSTR& s, TSTR& u)
        { tex = t; name = s; url = u; }
    BitmapTex* tex;
    TSTR       name;
    TSTR       url;
};

class NormalTable;

// Node Name hash table for making name unique

struct NodeList {
    NodeList(INode* n)	{ node = n; hasName = FALSE; next = NULL; }
    ~NodeList()			{ delete next; }
    INode*		node;
    BOOL		hasName;
    TSTR		name;
    NodeList*	next;
};

struct NameList {
    NameList(TCHAR* n)	{ name = n; next = NULL; }
    ~NameList()			{ delete next; }
    TSTR       name;
    NameList*  next;
};

#define NODE_HASH_TABLE_SIZE 1001

class NodeTable {
public:
    NodeTable() {
		mTable.SetCount(NODE_HASH_TABLE_SIZE);
        for (int i = 0; i < NODE_HASH_TABLE_SIZE; i++) mTable[i] = NULL;
		mNames.SetCount(NODE_HASH_TABLE_SIZE);
        for (i = 0; i < NODE_HASH_TABLE_SIZE; i++) mNames[i] = NULL;
    }
    
	~NodeTable() {
		int cnt = mNames.Count();
        for (int i = 0; i < NODE_HASH_TABLE_SIZE; i++) delete mTable[i];
		for (i = 0; i < cnt; i++) delete mNames[i];
    }
    
	NodeList*	AddNode(INode* node);
	TCHAR*		GetNodeName(INode* node);
	TCHAR*	    AddName(TCHAR* name);

private:
    Tab<NodeList*> mTable;
	Tab<NameList*> mNames;
};

class VRBLExport : public SceneExport {
public:
    VRBLExport();
    ~VRBLExport();
    
    int		  ExtCount();     
    const TCHAR * Ext(int n);			
    const TCHAR * LongDesc();			
    const TCHAR * ShortDesc();			
    const TCHAR * AuthorName();			
    const TCHAR * CopyrightMessage();		
    const TCHAR * OtherMessage1();		
    const TCHAR * OtherMessage2();		
    unsigned int  Version();			
    void	  ShowAbout(HWND hWnd);	
    int           DoExport(const TCHAR *name,ExpInterface *ei,Interface *i, BOOL suppressPrompts=FALSE, DWORD options=0);

    inline BOOL GetGenNormals() { return mGenNormals; }
    inline void SetGenNormals(BOOL gen) { mGenNormals = gen; }
    inline BOOL GetIndent() { return mIndent; }
    inline void SetIndent(BOOL in) { mIndent = in; }
    inline ExportType GetExportType() { return mType; }
    inline void SetExportType(ExportType t) { mType = t; }
    inline Interface* GetIP() { return mIp;}
    inline INode* GetCamera() { return mCamera; }
    inline INode* GetNavInfo() { return mNavInfo; }
    inline INode* GetBackground() { return mBackground; }
    inline INode* GetFog() { return mFog; }
    inline void SetCamera(INode* cam) { mCamera = cam; }
    inline void SetNavInfo(INode* ni) { mNavInfo = ni; }
    inline void SetBackground(INode* ni) { mBackground = ni; }
    inline void SetFog(INode* ni) { mFog = ni; }
    inline void SetUsePrefix(BOOL u) { mUsePrefix = u; }
    inline BOOL GetUsePrefix() { return mUsePrefix; }
    inline void SetUrlPrefix(TSTR& s) { mUrlPrefix = s; }
    inline TSTR& GetUrlPrefix() {return mUrlPrefix; }
    inline void SetFields(BOOL f) { mGenFields = f; }
    inline BOOL GetFields() { return mGenFields; }
    void GetCameras(INode *inode, Tab<INode*> *camList,
                    Tab<INode*> *navInfoList, Tab<INode*> *backgrounds,
                    Tab<INode*> *fogs);
    inline BOOL IsVRML2() { return mType == Export_VRML_2_0; }
    inline BOOL GetZUp() { return mZUp; }
    inline void SetZUp(BOOL zup) { mZUp = zup; }
    inline int GetDigits() { return mDigits; }
    inline void SetDigits(int n) { mDigits = n; }
    inline BOOL GetCoordInterp() { return mCoordInterp; }
    inline void SetCoordInterp(BOOL ci) { mCoordInterp = ci; }
#ifdef _LEC_
    inline BOOL GetFlipBook() { return mFlipBook; }
    inline void SetFlipBook(BOOL ci) { mFlipBook = ci; }
#endif

    inline BOOL GetTformSample() { return mTformSample; }
    inline void SetTformSample(BOOL b) { mTformSample = b; }
    inline int GetTformSampleRate() { return mTformSampleRate; }
    inline void SetTformSampleRate(int rate) { mTformSampleRate = rate; }

    inline BOOL GetCoordSample() { return mCoordSample; }
    inline void SetCoordSample(BOOL b) { mCoordSample = b; }
    inline int GetCoordSampleRate() { return mCoordSampleRate; }
    inline void SetCoordSampleRate(int rate) { mCoordSampleRate = rate; }

    inline BOOL GetFlipbookSample() { return mFlipbookSample; }
    inline void SetFlipbookSample(BOOL b) { mFlipbookSample = b; }
    inline int GetFlipbookSampleRate() { return mFlipbookSampleRate; }
    inline void SetFlipbookSampleRate(int rate) { mFlipbookSampleRate = rate; }

    inline TSTR& GetInfo() { return mInfo; }
    inline void SetInfo (TCHAR* info) { mInfo = info; }
    inline TSTR& GetTitle() { return mTitle; }
    inline void SetTitle (TCHAR* title) { mTitle = title; }
    inline BOOL GetExportHidden() { return mExportHidden; }
    inline void SetExportHidden(BOOL eh) { mExportHidden = eh; }

    inline BOOL GetEnableProgressBar() { return mEnableProgressBar; }
    inline void SetEnableProgressBar(BOOL epb) { mEnableProgressBar = epb; }

    inline BOOL GetPrimitives() { return mPrimitives; }
    inline void SetPrimitives(BOOL eh) { mPrimitives = eh; }

    inline int  GetPolygonType() { return mPolygonType; }
    inline void SetPolygonType(int type) { mPolygonType = type; }

    inline int  GetPreLight() { return mPreLight; }
    inline void SetPreLight(int i) { mPreLight = i; }

    inline int  GetCPVSource() { return mCPVSource; }
    inline void SetCPVSource(int i) { mCPVSource = i; }

    CallbackTable*  GetCallbacks() { return &mCallbacks; }

    Interface* mIp;         // MAX interface pointer

    // UI controls
    static ISpinnerControl* tformSpin;
    static ISpinnerControl* coordSpin;
    static ISpinnerControl* flipbookSpin;

private:
    TCHAR* point(Point3& p);
    TCHAR* scalePoint(Point3& p);
    TCHAR* normPoint(Point3& p);
    TCHAR* axisPoint(Point3& p, float ang);
    TCHAR* texture(UVVert& uv);
    TCHAR* color(Color& c);
    TCHAR* color(Point3& c);
    TCHAR* floatVal(float f);
    
    void initializeDefaults();
    // VRBL Output routines
    void Indent(int level);
    void StartNode(INode* node, Object* obj, int level, BOOL outputName);
    void EndNode(INode* node, int level, BOOL lastChild);
    //BOOL IsBBoxTrigger(INode* node);
    void OutputNodeTransform(INode* node, int level);
    void OutputMultiMtl(Mtl* mtl, int level);
    void OutputNoTexture(int level);
    BOOL OutputMaterial(INode* node, BOOL& twoSided, int level);
    BOOL HasTexture(INode *node);
    TextureDesc*GetMatTex(INode* node);
    void OutputNormalIndices(Mesh& mesh, NormalTable* normTab, int level);
    NormalTable* OutputNormals(Mesh& mesh, int level);
    void OutputTriObject(INode* node, TriObject* obj, BOOL multiMat,
                         BOOL twoSided, int level);
    BOOL isVrblObject(INode * node, Object *obj, INode* parent);
    void VrblOutObject(INode* node, INode* parent, Object* obj, int level);
    BOOL VrblOutSphere(INode * node, Object *obj, int level);
    BOOL VrblOutCylinder(INode* node, Object *obj, int level);
    BOOL VrblOutCone(INode* node, Object *obj, int level);
    BOOL VrblOutCube(INode* node, Object *obj, int level);
    BOOL VrblOutCamera(INode* node, Object* obj, int level);
    //void VrblAnchorHeader(MrBlueObject* obj, VRBL_TriggerType type,
    //                      BOOL fromParent, int level);
    //BOOL VrblOutMrBlue(INode* node, INode* parent, MrBlueObject* obj,
    //                   int* level, BOOL fromParent);
    BOOL VrblOutInline(VRMLInsObject* obj, int level);
    BOOL VrblOutLOD(INode* node, LODObject* obj, int level);
    //BOOL IsAimTarget(INode* node);
    BOOL VrblOutTarget(INode* node, int level);
    BOOL VrblOutSpecial(INode* node, INode* parent, Object* obj, int level);
    //int StartMrBlueHelpers(INode* node, int level);
    //void EndMrBlueNode(INode* childNode, int& level);
    //void EndMrBlueHelpers(INode* node, int level);
    BOOL VrblOutPointLight(INode* node, LightObject* light, int level);
    BOOL VrblOutDirectLight(INode* node, LightObject* light, int level);
    BOOL VrblOutSpotLight(INode* node, LightObject* light, int level);
    BOOL VrblOutTopPointLight(INode* node, LightObject* light);
    BOOL VrblOutTopDirectLight(INode* node, LightObject* light);
    BOOL VrblOutTopSpotLight(INode* node, LightObject* light);
    void OutputTopLevelLight(INode* node, LightObject *light);
    BOOL WriteTCBKeys(INode* node, Control *cont, int type, int level);
    void WriteLinearKeys(INode* node,
                         Tab<TimeValue>& posTimes,
                         Tab<Point3>& posKeys,
                         Tab<TimeValue>& rotTimes,
                         Tab<AngAxis>& rotKeys,
                         Tab<TimeValue>& sclTimes,
                         Tab<Point3>& sclKeys,
                         int type, int level);
    int WriteAllControllerData(INode* node, int flags, int level, Control *lc);
    void WritePositionKey0(INode* node, TimeValue t, int level, BOOL force);
    void WriteRotationKey0(INode* node, TimeValue t, int level, BOOL force);
    void WriteScaleKey0(INode* node, TimeValue t, int level, BOOL force);

    void WriteVisibilityData(INode* node, int level);
    BOOL IsLight(INode* node);
    Control* GetLightColorControl(INode* node);
    void VrblOutControllers(INode* node, int level);
    void VrblOutAnimationFrames();
    void ScanSceneGraph();
    void ComputeWorldBoundBox(INode* node, ViewExp* vpt);
    void TraverseNode(INode* node);
    BOOL ObjectIsLODRef(INode* node);
    void VrmlOutTopLevelCamera(int level, INode* node, BOOL topLevel);
    void VrblOutFileInfo();
    void VrblOutNode(INode* node, INode* parent, int level, BOOL isLOD,
                     BOOL lastChild);
	void GenerateUniqueNodeNames(INode* node);
    BOOL VRBLExport::IsMirror(INode* node);
    BOOL GetCallbackMethods();

    FILE*      mStream;     // The file mStream to write
    BOOL       mGenNormals; // Generate normals in the VRML file
    BOOL       mIndent;     // Should we indent?
    INodeList* mLodList;    // List of LOD objects in the scene
    ExportType mType;       // Language to export (VRML, VRBL, ...)
    INode*     mCamera;     // Initial camera;
    INode*     mNavInfo;    // Initial NavigationInfo
    INode*     mBackground; // Initial Background node
    INode*     mFog;        // Initial Fog node
    BOOL       mUsePrefix;  // Use URL Prefix
    TSTR       mUrlPrefix;  // The URL prefix
    BOOL       mGenFields;  // Generate "fields" statements
    BOOL       mHadAnim;    // File has animation data
    TimeValue  mStart;      // First frame of the animation
    BOOL       mZUp;        // Z axis if true, Y axis otherwise
    int        mDigits;     // Digits of precision on output
    BOOL       mCoordInterp;// Generate coordinate interpolators
#ifdef _LEC_
    BOOL       mFlipBook;   // Generate multiple file one file per frame (LEC request)
#endif
    BOOL       mTformSample;// TRUE for once per frame, FALSE for cusom rate
    int        mTformSampleRate; // Custom sample rate
    BOOL       mCoordSample;// TRUE for once per frame, FALSE for cusom rate
    int        mCoordSampleRate; // Custom sample rate
    BOOL       mFlipbookSample;     // TRUE for once per frame, FALSE for cusom rate
    int        mFlipbookSampleRate; // Custom sample rate
    Box3       mBoundBox;   // Bounding box for the whole scene
    TSTR       mTitle;      // Title of world
    TSTR       mInfo;       // Info for world
    BOOL       mExportHidden; // Export hidden objects
    BOOL       mEnableProgressBar;  // Enable export progress bar
    BOOL       mPrimitives;   // Create VRML primitves
    int         mPolygonType;   // 0 triangle, 1 QUADS, 2 NGONS
    BOOL       mPreLight;       // should we calculate the color per vertex
    BOOL       mCPVSource;  // 1 if MAX; 0 if we should calculate the color per vertex
	NodeTable	mNodes;		// hash table of all nodes' name in the scene
    CallbackTable   mCallbacks; // callback methods
};

// Handy file class

class WorkFile {
private:
    FILE *mStream;
	
public:
    WorkFile(const TCHAR *filename,const TCHAR *mode)
        { mStream = NULL; Open(filename, mode); };
    ~WorkFile()
        { Close(); };
    FILE *MStream()
        { return mStream; };
    int	Close()
        { int result=0;
          if(mStream) result=fclose(mStream);
          mStream = NULL;
          return result; }
    void	Open(const TCHAR *filename,const TCHAR *mode)
        { Close(); mStream = _tfopen(filename,mode); }
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrmlexp.cpp ===
/**********************************************************************
 *<
	FILE: vrmlexp.cpp

	DESCRIPTION:  VRML/VRBL .WRL file export module

	CREATED BY: Scott Morrison

	HISTORY: created 15 February, 1996

 *>	Copyright (c) 1996, 1997 All Rights Reserved.
 **********************************************************************/

#include <time.h>
#include "vrml.h"
#include "simpobj.h"
#include "istdplug.h"
#include "inline.h"
#include "lod.h"
#include "inlist.h"
#include "notetrck.h"
#include "bookmark.h"
#include "stdmat.h"
#include "normtab.h"
#include "vrml_api.h"
#include "vrmlexp.h"
#include "appd.h"
#include "timer.h"
#include "navinfo.h"
#include "backgrnd.h"
#include "fog.h"
#include "sound.h"
#include "touch.h"
#include "prox.h"
#include "vrml2.h"
#include "helpsys.h"

extern TCHAR *GetString(int id);

// Returns TRUE if an object or one of its ancestors in animated
static BOOL IsEverAnimated(INode* node);

// Round numbers near zero to zero.  This help reduce VRML file size.
inline float
round(float f)
{
    // This is used often, so we avoid calling fabs
    if (f < 0.0f) {
        if (f > -1.0e-5)
            return 0.0f;
        return f;
    }
    if (f < 1.0e-5)
        return 0.0f;
    return f;
}

// Function for writing values into a string for output.  
// These functions take care of rounding values near zero, and flipping
// Y and Z for VRML output.

// Format a 3D coordinate value.
TCHAR*
VRBLExport::point(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y));
    CommaScan(buf);
    return buf;
}

TCHAR*
VRBLExport::color(Color& c)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    sprintf(buf, format, round(c.r), round(c.g), round(c.b));
    CommaScan(buf);
    return buf;
}

TCHAR*
VRBLExport::color(Point3& c)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    sprintf(buf, format, round(c.x), round(c.y), round(c.z));
    CommaScan(buf);
    return buf;
}


TCHAR*
VRBLExport::floatVal(float f)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg"), mDigits);
    sprintf(buf, format, round(f));
    CommaScan(buf);
    return buf;
}


TCHAR*
VRBLExport::texture(UVVert& uv)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    sprintf(buf, format, round(uv.x), round(uv.y));
    CommaScan(buf);
    return buf;
}

// Format a scale value
TCHAR*
VRBLExport::scalePoint(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round( p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round( p.z), round(p.y));
    CommaScan(buf);
    return buf;
}

// Format a normal vector
TCHAR*
VRBLExport::normPoint(Point3& p)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg"), mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y));
    CommaScan(buf);
    return buf;
}

// Format an axis value
TCHAR*
VRBLExport::axisPoint(Point3& p, float angle)
{
    static TCHAR buf[50];
    TCHAR format[20];
    sprintf(format, _T("%%.%dg %%.%dg %%.%dg %%.%dg"),
            mDigits, mDigits, mDigits, mDigits);
    if (mZUp)
        sprintf(buf, format, round(p.x), round(p.y), round(p.z),
                round(angle));
    else
        sprintf(buf, format, round(p.x), round(p.z), round(-p.y),
                round(angle));
    CommaScan(buf);
    return buf;
}

// Get the tranform matrix that take a point from its local coordinate
// system to it's parent's coordinate system
static Matrix3
GetLocalTM(INode* node, TimeValue t)
{
    Matrix3 tm;
    tm = node->GetObjTMAfterWSM(t);
    if (!node->GetParentNode()->IsRootNode()) {
        Matrix3 ip = Inverse(node->GetParentNode()->GetObjTMAfterWSM(t));
        tm = tm * ip;
    }
    return tm;
}

class VRBLClassDesc:public ClassDesc {
public:
    int    IsPublic()                   { return TRUE; }
    void*  Create(BOOL loading = FALSE) { return new VRBLExport; }
    const  TCHAR* ClassName()           {return _T(GetString(IDS_VRML_EXPORT_CLASS));}
    SClass_ID	 SuperClassID()         { return SCENE_EXPORT_CLASS_ID; }
    Class_ID	 ClassID()    { return Class_ID(VRBL_EXPORT_CLASS_ID,0); }
    const TCHAR* Category()   { return GetString(IDS_TH_SCENEEXPORT); }
};

static VRBLClassDesc VRBLDesc;

ClassDesc* GetVRBLDesc() { return &VRBLDesc; }

////////////////////////////////////////////////////////////////////////
// VRBL Export implementation
////////////////////////////////////////////////////////////////////////

// Indent to the given level.
void 
VRBLExport::Indent(int level)
{
    if (!mIndent) return;
    assert(level >= 0);
    for(; level; level--)
        fprintf(mStream, _T("  "));
}
    
// Translates name (if necessary) to VRML compliant name.
// Returns name in static buffer, so calling a second time trashes
// the previous contents.
#define CTL_CHARS      31
static TCHAR * VRMLName(TCHAR *name)
{
    static char buffer[256];
    TCHAR* cPtr;
    int firstCharacter = 1;

    _tcscpy(buffer, name);
    cPtr = buffer;
    while(*cPtr) {
        if( *cPtr <= CTL_CHARS ||
            *cPtr == ' ' ||
            *cPtr == '\''||
            *cPtr == '"' ||
            *cPtr == '\\'||
            *cPtr == '{' ||
            *cPtr == '}' ||
            *cPtr == ',' ||            
            *cPtr == '.' ||
            *cPtr == '[' ||
            *cPtr == ']' ||
            *cPtr == '.' ||
            *cPtr == '#' ||
            *cPtr >= 127 ||
            (firstCharacter && (*cPtr >= '0' && *cPtr <= '9'))) *cPtr = '_';
        firstCharacter = 0;
        cPtr++;
    }
    
    return buffer;
}

// Return true if it has a mirror transform
BOOL
VRBLExport::IsMirror(INode* node)
{
    Matrix3 tm = GetLocalTM(node, mStart);
    AffineParts parts;
    decomp_affine(tm, &parts);

    return parts.f < 0.0f;
}

// Write beginning of the Separator node.
void
VRBLExport::StartNode(INode* node, Object* obj, int level, BOOL outputName)
{
    if (node->IsRootNode()) {
        fprintf(mStream, _T("Separator {\n"));
        return;
    }
    Indent(level);
    if (obj->SuperClassID() == CAMERA_CLASS_ID ||
        obj->SuperClassID() == LIGHT_CLASS_ID  || !outputName) {
     // Lights and cameras need different top-level names for triggers
        fprintf(mStream, _T("DEF %s_TopLevel Separator {\n"), mNodes.GetNodeName(node));
    } else {
        fprintf(mStream, _T("DEF %s Separator {\n"), mNodes.GetNodeName(node));
        if (IsMirror(node)) {
            Indent(level+1);
            fprintf(mStream, _T("ShapeHints {\n"));
            Indent(level+2);
            fprintf(mStream, _T("vertexOrdering CLOCKWISE\n"));
            Indent(level+1);
            fprintf(mStream, _T("}\n"));
        }
    }

    if (!obj)
        return;

    // Put note tracks as info nodes
    int numNotes = node->NumNoteTracks();
    for(int i=0; i < numNotes; i++) {
        DefNoteTrack *nt = (DefNoteTrack*) node->GetNoteTrack(i);
        for (int j = 0; j < nt->keys.Count(); j++) {
            NoteKey* nk = nt->keys[j];
            TSTR note = nk->note;
            if (note.Length() > 0) {
                Indent(level+1);
                fprintf(mStream, _T("Info { string \"frame %d: %s\" }\n"),
                        nk->time/GetTicksPerFrame(), note.data());
            }
        }
    }
}

// Write end of the separator node.
void
VRBLExport::EndNode(INode *node, int level, BOOL lastChild)
{
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

// Write out the transform from the local coordinate system to the
// parent coordinate system
void
VRBLExport::OutputNodeTransform(INode* node, int level)
{
    // Root node is always identity
    if (node->IsRootNode())
        return;

    Matrix3 tm = GetLocalTM(node, mStart);
    int i, j;
    Point3 p;

    // Check for scale and rotation part of matrix being identity.
    BOOL isIdentity = TRUE;
    for (i=0; i<3; i++) {
        for (j=0; j<3; j++) {
            if (i==j) {
                if (tm.GetRow(i)[j] != 1.0f) {
                    isIdentity = FALSE;
                    goto done;
                }
            } else if (fabs(tm.GetRow(i)[j]) > 1.0e-05) {
                isIdentity = FALSE;
                goto done;
            }
        }
    }

  done:
    if (isIdentity) {
        p = tm.GetTrans();
        Indent(level);
        fprintf(mStream, _T("Translation { translation %s }\n"), point(p));
    } else {
        // If not identity, decompose matrix into scale, rotation and
        // translation components.
        Point3 s, axis;
        Quat q;
        float ang;

        AffineParts parts;
        decomp_affine(tm, &parts);
        p = parts.t;
        q = parts.q;
        AngAxisFromQ(q, &ang, axis);
        Indent(level);
        fprintf(mStream, _T("Translation { translation %s }\n"), point(p));
        if (ang != 0.0f && ang != -0.0f) {
            Indent(level);
            // VRML angle convention is opposite of MAX convention,
            // so we negate the angle.
            fprintf(mStream, _T("Rotation { rotation %s }\n"),
                    axisPoint(axis, -ang));
        }
        ScaleValue sv(parts.k, parts.u);
        s = sv.s;
        if (parts.f < 0.0f)
            s = - s;
        if (s.x != 1.0f || s.y != 1.0f || s.z != 1.0f) {
            Indent(level);
            fprintf(mStream, _T("Scale { scaleFactor %s }\n"), scalePoint(s));
        }
    }
}

// Initialize the normal table
NormalTable::NormalTable()
{
    tab.SetCount(NORM_TABLE_SIZE);
    for(int i = 0; i < NORM_TABLE_SIZE; i++)
        tab[i] = NULL;
}

NormalTable::~NormalTable()
{
    // Delete the buckets in the normal table hash table.
    for(int i = 0; i < NORM_TABLE_SIZE; i++)
        delete tab[i];
}

// Add a normal to the hash table
void
NormalTable::AddNormal(Point3& norm)
{
    // Truncate normals to a value that brings close normals into
    // the same bucket.
    Point3 n = NormalizeNorm(norm);
    DWORD code = HashCode(n);
    NormalDesc* nd;
    for(nd = tab[code]; nd; nd = nd->next) {
        if (nd->n == n)  // Equality OK because of normalization procedure.
            return;
    }
    NormalDesc* newNorm = new NormalDesc(norm);
    newNorm->next = tab[code];
    tab[code] = newNorm;
}

// Get the index of a normal in the IndexedFaceSet
int
NormalTable::GetIndex(Point3& norm)
{
    Point3 n = NormalizeNorm(norm);
    DWORD code = HashCode(n);
    NormalDesc* nd;
    for(nd = tab[code]; nd; nd = nd->next) {
        if (nd->n == n)
            return nd->index;
    }
    return -1;
}


// Produce a hash code for a normal
DWORD
NormalTable::HashCode(Point3& norm)
{
    union {
        float p[3];
        DWORD i[3];
    } u;
    u.p[0] = norm.x; u.p[1] = norm.y; u.p[2] = norm.z;
    return ((u.i[0] >> 8) + (u.i[1] >> 16) + u.i[2]) % NORM_TABLE_SIZE;
}

// Print the hash table statistics for the normal table
void
NormalTable::PrintStats(FILE* mStream)
{
    int slots = 0;
    int buckets = 0;
    int i;
    NormalDesc* nd;

    for(i = 0; i < NORM_TABLE_SIZE; i++) {
        if (tab[i]) {
            slots++;
            for(nd = tab[i]; nd; nd = nd->next)
                buckets++;
        }
    }
    fprintf(mStream,_T("# slots = %d, buckets = %d, avg. chain length = %.5g\n"),
            slots, buckets, ((double) buckets / (double) slots));
            
}

// Returns true IFF the mesh is all in the same smoothing group
static BOOL
MeshIsAllOneSmoothingGroup(Mesh& mesh)
{
    int numfaces = mesh.getNumFaces();
    unsigned int sg;
    int i;

    for(i = 0; i < numfaces; i++) {
        if (i == 0) {
            sg = mesh.faces[i].getSmGroup();
            if (sg == 0)        // Smoothing group of 0 means faceted
                return FALSE;
        }
        else {
            if (sg != mesh.faces[i].getSmGroup())
                return FALSE;
        }
    }
    return TRUE;
}

// Write out the indices of the normals for the IndexedFaceSet
void
VRBLExport::OutputNormalIndices(Mesh& mesh, NormalTable* normTab, int level)
{
    Point3 n;
    int numfaces = mesh.getNumFaces();
    int i, j, v, norCnt;

    Indent(level);
    
    fprintf(mStream, _T("normalIndex [\n"));
    for (i = 0; i < numfaces; i++) {
        int smGroup = mesh.faces[i].getSmGroup();
        Indent(level+1);
        for(v = 0; v < 3; v++) {
            int cv = mesh.faces[i].v[v];
            RVertex * rv = mesh.getRVertPtr(cv);
            if (rv->rFlags & SPECIFIED_NORMAL) {
                n = rv->rn.getNormal();
                continue;
            }
            else if((norCnt = (int)(rv->rFlags & NORCT_MASK)) && smGroup) {
                if (norCnt == 1)
                    n = rv->rn.getNormal();
                else for(j = 0; j < norCnt; j++) {
                    if (rv->ern[j].getSmGroup() & smGroup) {
                        n = rv->ern[j].getNormal();
                        break;
                    }
                }
            } else
                n = mesh.getFaceNormal(i);
            int index = normTab->GetIndex(n);
            assert (index != -1);
            fprintf(mStream, _T("%d, "), index);
        }
        fprintf(mStream, _T("-1,\n"));
    }
    Indent(level);
    fprintf(mStream, _T("]\n"));
}

// Create the hash table of normals for the given mesh, and
// write out the normal values.
NormalTable*
VRBLExport::OutputNormals(Mesh& mesh, int level)
{
    int i, j, norCnt;
    int numverts = mesh.getNumVerts();
    int numfaces = mesh.getNumFaces();
    NormalTable* normTab;


    mesh.buildRenderNormals();

    if (MeshIsAllOneSmoothingGroup(mesh)) {
        // No need for normals when whole object is smooth.
        // VRML Browsers compute normals automatically in this case.
        return NULL;
    }

    normTab = new NormalTable();

    // Otherwise we have several smoothing groups
    for(int index = 0; index < numfaces; index++) {
        int smGroup = mesh.faces[index].getSmGroup();
        for(i = 0; i < 3; i++) {
            // Now get the normal for each vertex of the face
            // Given the smoothing group
            int cv = mesh.faces[index].v[i];
            RVertex * rv = mesh.getRVertPtr(cv);
            if (rv->rFlags & SPECIFIED_NORMAL) {
                normTab->AddNormal(rv->rn.getNormal());
            }
            else if((norCnt = (int)(rv->rFlags & NORCT_MASK)) && smGroup) {
                if (norCnt == 1)        // 1 normal, stored in rn
                    normTab->AddNormal(rv->rn.getNormal());
                else for(j = 0; j < norCnt; j++) {
                    // More than one normal, stored in ern.
                    normTab->AddNormal(rv->ern[j].getNormal());
                }
            } else
                normTab->AddNormal(mesh.getFaceNormal(index));
        }
    }

    // Now write out the table
    index = 0;
    NormalDesc* nd;
    Indent(level);
    fprintf(mStream, _T("Normal { vector [\n"));
       
    for(i = 0; i < NORM_TABLE_SIZE; i++) {
        for(nd = normTab->Get(i); nd; nd = nd->next) {
            nd->index = index++;
            Indent(level+1);
            Point3 p = nd->n/NUM_NORMS;
            fprintf(mStream, _T("%s,\n"), normPoint(p));
        }
    }
    Indent(level);
    fprintf(mStream, _T("] }\n"));

    Indent(level);
    fprintf(mStream, _T("NormalBinding { value PER_VERTEX_INDEXED }\n"));
    
#ifdef DEBUG_NORM_HASH
    normTab->PrintStats(mStream);
#endif

    return normTab;
}

// Write out the data for a single triangle mesh
void
VRBLExport::OutputTriObject(INode* node, TriObject* obj, BOOL isMulti,
                            BOOL twoSided, int level)
{
    assert(obj);
    Mesh &mesh = obj->GetMesh();
    int numverts = mesh.getNumVerts();
    int numtverts = mesh.getNumTVerts();
    int numfaces = mesh.getNumFaces();
    int i;
    NormalTable* normTab = NULL;
    TextureDesc* td = GetMatTex(node);

    if (numfaces == 0) {
        delete td;
        return;
    }

   if (isMulti) {
        Indent(level);
        fprintf(mStream, _T("MaterialBinding { value PER_FACE_INDEXED }\n"));
    }

    // Output the vertices
    Indent(level);
    fprintf(mStream, _T("Coordinate3 { point [\n"));
        
    for(i = 0; i < numverts; i++) {
        Point3 p = mesh.verts[i];
        Indent(level+1);
        fprintf(mStream, _T("%s"), point(p));
        if (i == numverts-1) {
            fprintf(mStream, _T("]\n"));
            Indent(level);
            fprintf(mStream, _T("}\n"));
        }
        else
            fprintf(mStream, _T(",\n"));
    }

    // Output the normals
    if (mGenNormals) {
        normTab = OutputNormals(mesh, level);
    }

    // Output Texture coordinates
    if (numtverts > 0 && td) {
        Indent(level);
        fprintf(mStream, _T("TextureCoordinate2 { point [\n"));

        for(i = 0; i < numtverts; i++) {
            UVVert p = mesh.getTVert(i);
            Indent(level+1);
            fprintf(mStream, _T("%s"), texture(p));
            if (i == numtverts-1) {
                fprintf(mStream, _T("]\n"));
                Indent(level);
                fprintf(mStream, _T("}\n"));
            }
            else
                fprintf(mStream, _T(",\n"));
        }
    }

    if (twoSided) {
        Indent(level);
        fprintf(mStream, _T("ShapeHints {\n"));
        Indent(level+1);
        fprintf(mStream, _T("shapeType UNKNOWN_SHAPE_TYPE\n"));
        Indent(level);
        fprintf(mStream, _T("}\n"));
    }
    // Output the triangles
    Indent(level);
    fprintf(mStream, _T("IndexedFaceSet { coordIndex [\n"));
    for(i = 0; i < numfaces; i++) {
        if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
            Indent(level+1);
            fprintf(mStream, _T("%d, %d, %d, -1"), mesh.faces[i].v[0],
                    mesh.faces[i].v[1], mesh.faces[i].v[2]);
            if (i != numfaces-1)
                fprintf(mStream, _T(", \n"));
        }
    }
    fprintf(mStream, _T("]\n"));

    // Output the texture coordinate indices
    if (numtverts > 0 && td) {
        Indent(level);
        fprintf(mStream, _T("textureCoordIndex [\n"));
        for(i = 0; i < numfaces; i++) {
            if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
                Indent(level+1);
                fprintf(mStream, _T("%d, %d, %d, -1"), mesh.tvFace[i].t[0],
                        mesh.tvFace[i].t[1], mesh.tvFace[i].t[2]);
            if (i != numfaces-1)
                fprintf(mStream, _T(", \n"));
            }
        }
        fprintf(mStream, _T("]\n"));
    }

    // Output the material indices
    if (isMulti) {
        Indent(level);
        fprintf(mStream, _T("materialIndex [\n"));
        for(i = 0; i < numfaces; i++) {
            if (!(mesh.faces[i].flags & FACE_HIDDEN)) {
                Indent(level+1);
                fprintf(mStream, _T("%d"), mesh.faces[i].getMatID());
                if (i != numfaces-1)
                    fprintf(mStream, _T(", \n"));
            }
        }
        fprintf(mStream, _T("]\n"));
    }

    // Output the normal indices
    if (mGenNormals && normTab) {
        OutputNormalIndices(mesh, normTab, level);
        delete normTab;
    }
        
    Indent(level);
    fprintf(mStream, _T("}\n"));
    delete td;
}

// Returns TRUE iff the node has an attached standard material with
// a texture map on the diffuse color
BOOL
VRBLExport::HasTexture(INode* node)
{
    TextureDesc* td = GetMatTex(node);
    if (!td)
        return FALSE;
    delete td;
    return TRUE;
}

// Get the name of the texture file of the texure on the diffuse
// color of the material attached to the given node.
TextureDesc*
VRBLExport::GetMatTex(INode* node)
{
    Mtl* mtl = node->GetMtl();
    if (!mtl)
        return NULL;

    // We only handle standard materials.
    if (mtl->ClassID() != Class_ID(DMTL_CLASS_ID, 0))
        return NULL;

    StdMat* sm = (StdMat*) mtl;
    // Check for texture map
    Texmap* tm = (BitmapTex*) sm->GetSubTexmap(ID_DI);
    if (!tm)
        return NULL;

    // We only handle bitmap textures in VRML
    if (tm->ClassID() != Class_ID(BMTEX_CLASS_ID, 0))
        return NULL;
    BitmapTex* bm = (BitmapTex*) tm;

    TSTR bitmapFile;
    TSTR fileName;

    bitmapFile = bm->GetMapName();
    if (bitmapFile.data() == NULL)
        return NULL;
    int l = strlen(bitmapFile)-1;
    if (l < 0)
        return NULL;

    // Split the name up
    TSTR path;
    SplitPathFile(bitmapFile, &path, &fileName);

    TSTR url;
    if (mUsePrefix && mUrlPrefix.Length() > 0) {
        if (mUrlPrefix[mUrlPrefix.Length() - 1] != '/') {
            TSTR slash = "/";
            url = mUrlPrefix + slash + fileName;
        } else
            url = mUrlPrefix + fileName;
    }
    else
        url = fileName;
    TextureDesc* td = new TextureDesc(bm, fileName, url);
    return td;
}

// Write out the colors for a multi/sub-object material
void
VRBLExport::OutputMultiMtl(Mtl* mtl, int level)
{
    int i;
    Mtl* sub;
    Color c;
    float f;

    Indent(level);
    fprintf(mStream, _T("Material {\n"));
    int num = mtl->NumSubMtls();

    Indent(level+1);
    fprintf(mStream, _T("ambientColor [ "));
    for(i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        // Some slots might be empty!
        if (!sub)
            continue;
        c = sub->GetAmbient(mStart);
        if (i == num - 1)
            fprintf(mStream, _T("%s "), color(c));
        else
            fprintf(mStream, _T("%s, "), color(c));
    }
    fprintf(mStream, _T("]\n"));
    Indent(level+1);
    fprintf(mStream, _T("diffuseColor [ "));
    for(i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        if (!sub)
            continue;
        c = sub->GetDiffuse(mStart);
        if (i == num - 1)
            fprintf(mStream, _T("%s "), color(c));
        else
            fprintf(mStream, _T("%s, "), color(c));
    }
    fprintf(mStream, _T("]\n"));
        
    Indent(level+1);
    fprintf(mStream, _T("specularColor [ "));
    for(i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        if (!sub)
            continue;
        c = sub->GetSpecular(mStart);
        if (i == num - 1)
            fprintf(mStream, _T("%s "), color(c));
        else
            fprintf(mStream, _T("%s, "), color(c));
    }
    fprintf(mStream, _T("]\n"));
    
    Indent(level+1);
    fprintf(mStream, _T("shininess [ "));
    for(i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        if (!sub)
            continue;
        f = sub->GetShininess(mStart);
        if (i == num - 1)
            fprintf(mStream, _T("%s "), floatVal(f));
        else
            fprintf(mStream, _T("%s, "), floatVal(f));
    }
    fprintf(mStream, _T("]\n"));
        
    Indent(level+1);
    fprintf(mStream, _T("emissiveColor [ "));
    for(i = 0; i < num; i++) {
        sub = mtl->GetSubMtl(i);
        if (!sub)
            continue;
        c = sub->GetDiffuse(mStart);
        float si;
        if (sub->ClassID() == Class_ID(DMTL_CLASS_ID, 0)) {
            StdMat* stdMtl = (StdMat *) sub;
            si = stdMtl->GetSelfIllum(mStart);
        }
        else
            si = 0.0f;
        Point3 p = si * Point3(c.r, c.g, c.b);
        if (i == num - 1)
            fprintf(mStream, _T("%s "), color(p));
        else
            fprintf(mStream, _T("%s, "), color(p));
    }
    fprintf(mStream, _T("]\n"));
        
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

void
VRBLExport::OutputNoTexture(int level)
{
    Indent(level);
    fprintf(mStream, _T("Texture2 {}\n"));
}

// Output the matrial definition for a node.
BOOL
VRBLExport::OutputMaterial(INode* node, BOOL& twoSided, int level)
{
    Mtl* mtl = node->GetMtl();
    twoSided = FALSE;

    // If no material is assigned, use the wire color
    if (!mtl || (mtl->ClassID() != Class_ID(DMTL_CLASS_ID, 0) &&
                 !mtl->IsMultiMtl())) {
        Color col(node->GetWireColor());
        Indent(level);
        fprintf(mStream, _T("Material {\n"));
        Indent(level+1);
        fprintf(mStream, _T("diffuseColor %s\n"), color(col));
        Indent(level+1);
        fprintf(mStream, _T("specularColor .9 .9 .9\n"));
        Indent(level);
        fprintf(mStream, _T("}\n"));
        OutputNoTexture(level);
        return FALSE;
    }

    if (mtl->IsMultiMtl()) {
        OutputMultiMtl(mtl, level);
        OutputNoTexture(level);
        return TRUE;
    }

    StdMat* sm = (StdMat*) mtl;
    twoSided = sm->GetTwoSided();
    Interval i = FOREVER;
    sm->Update(0, i);
    Indent(level);
    fprintf(mStream, _T("Material {\n"));
    Color c;

    Indent(level+1);
    c = sm->GetAmbient(mStart);
    fprintf(mStream, _T("ambientColor %s\n"), color(c));
    Indent(level+1);
    c = sm->GetDiffuse(mStart);
    fprintf(mStream, _T("diffuseColor %s\n"), color(c));
    Indent(level+1);
    c = sm->GetSpecular(mStart);
    fprintf(mStream, _T("specularColor %s\n"), color(c));
    Indent(level+1);
    fprintf(mStream, _T("shininess %s\n"),
            floatVal(sm->GetShininess(mStart)));
    Indent(level+1);
    fprintf(mStream, _T("transparency %s\n"),
            floatVal(1.0f - sm->GetOpacity(mStart)));
    float si = sm->GetSelfIllum(mStart);
    if (si > 0.0f) {
        Indent(level+1);
        c = sm->GetDiffuse(mStart);
        Point3 p = si * Point3(c.r, c.g, c.b);
        fprintf(mStream, _T("emissiveColor %s\n"), color(p));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));


    TextureDesc* td = GetMatTex(node);
    if (!td) {
        OutputNoTexture(level);
        return FALSE;
    }

    Indent(level);
    fprintf(mStream, _T("Texture2 {\n"));
    Indent(level+1);
    fprintf(mStream, _T("filename \"%s\"\n"), td->url);
    Indent(level);
    fprintf(mStream, _T("}\n"));

    BitmapTex* bm = td->tex;
    delete td;

    StdUVGen* uvGen = bm->GetUVGen();
    if (!uvGen) {
        return FALSE;
    }

    // Get the UV offset and scale value for Texture2Transform
    float uOff = uvGen->GetUOffs(mStart);
    float vOff = uvGen->GetVOffs(mStart);
    float uScl = uvGen->GetUScl(mStart);
    float vScl = uvGen->GetVScl(mStart);
    float ang =  uvGen->GetAng(mStart);

    if (uOff == 0.0f && vOff == 0.0f && uScl == 1.0f && vScl == 1.0f &&
        ang == 0.0f) {
        return FALSE;
    }

    Indent(level);
    fprintf(mStream, _T("Texture2Transform {\n"));
    if (uOff != 0.0f || vOff != 0.0f) {
        Indent(level+1);
        UVVert p = UVVert(uOff, vOff, 0.0f);
        fprintf(mStream, _T("translation %s\n"), texture(p));
    }
    if (ang != 0.0f) {
        Indent(level+1);
        fprintf(mStream, _T("rotation %s\n"), floatVal(ang));
    }
    if (uScl != 1.0f || vScl != 1.0f) {
        Indent(level+1);
        UVVert p = UVVert(uScl, vScl, 0.0f);
        fprintf(mStream, _T("scaleFactor %s\n"), texture(p));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));

    return FALSE;
}

// Create a VRMNL primitive sphere, if appropriate.  
// Returns TRUE if a primitive is created
BOOL
VRBLExport::VrblOutSphere(INode * node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius, hemi;
    int basePivot, genUV, smooth;
    BOOL td = HasTexture(node);

    // Reject "base pivot" mapped, non-smoothed and hemisphere spheres
    so->pblock->GetValue(SPHERE_RECENTER, mStart, basePivot, FOREVER);
    so->pblock->GetValue(SPHERE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(SPHERE_HEMI, mStart, hemi, FOREVER);
    so->pblock->GetValue(SPHERE_SMOOTH, mStart, smooth, FOREVER);
    if (!smooth || basePivot || (genUV && td) || hemi > 0.0f)
        return FALSE;

    so->pblock->GetValue(SPHERE_RADIUS, mStart, radius, FOREVER);
    
    Indent(level);

    fprintf(mStream, _T("Sphere { radius %s }\n"), floatVal(radius));
 
    return TRUE;
}

// Create a VRMNL primitive cylinder, if appropriate.  
// Returns TRUE if a primitive is created
BOOL
VRBLExport::VrblOutCylinder(INode* node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius, height;
    int sliceOn, genUV, smooth;
    BOOL td = HasTexture(node);

    // Reject sliced, non-smooth and mapped cylinders
    so->pblock->GetValue(CYLINDER_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CYLINDER_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CYLINDER_SMOOTH, mStart, smooth, FOREVER);
    if (sliceOn || (genUV && td) || !smooth)
        return FALSE;

    so->pblock->GetValue(CYLINDER_RADIUS, mStart, radius, FOREVER);
    so->pblock->GetValue(CYLINDER_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    fprintf(mStream, _T("Separator {\n"));
    Indent(level+1);
    if (mZUp) {
        fprintf(mStream, _T("Rotation { rotation 1 0 0 %s }\n"),
                floatVal(float(PI/2.0)));
        Indent(level+1);
        fprintf(mStream, _T("Translation { translation 0 %s 0 }\n"),
                floatVal(float(height/2.0)));
    } else {
        Point3 p = Point3(0.0f, 0.0f, height/2.0f);
        fprintf(mStream, _T("Translation { translation %s }\n"), point(p));
    }
    Indent(level+1);
    fprintf(mStream, _T("Cylinder { radius %s "), floatVal(radius));
    fprintf(mStream, _T("height %s }\n"), floatVal(float(fabs(height))));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    
    return TRUE;
}

// Create a VRMNL primitive cone, if appropriate.  
// Returns TRUE if a primitive is created
BOOL
VRBLExport::VrblOutCone(INode* node, Object *obj, int level)
{
    SimpleObject* so = (SimpleObject*) obj;
    float radius1, radius2, height;
    int sliceOn, genUV, smooth;
    BOOL td = HasTexture(node);

    // Reject sliced, non-smooth and mappeded cones
    so->pblock->GetValue(CONE_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(CONE_SLICEON, mStart, sliceOn, FOREVER);
    so->pblock->GetValue(CONE_SMOOTH, mStart, smooth, FOREVER);
    so->pblock->GetValue(CONE_RADIUS2, mStart, radius2, FOREVER);
    if (sliceOn || (genUV &&td) || !smooth || radius2 > 0.0f)
        return FALSE;

    so->pblock->GetValue(CONE_RADIUS1, mStart, radius1, FOREVER);
    so->pblock->GetValue(CONE_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    
    fprintf(mStream, _T("Separator {\n"));
    Indent(level+1);
    if (mZUp) {
        if (height > 0.0f)
            fprintf(mStream, _T("Rotation { rotation 1 0 0 %s }\n"),
                    floatVal(float(PI/2.0)));
        else
            fprintf(mStream, _T("Rotation { rotation 1 0 0 %s }\n"),
                    floatVal(float(-PI/2.0)));
        Indent(level+1);
        fprintf(mStream, _T("Translation { translation 0 %s 0 }\n"),
                floatVal(float(fabs(height)/2.0)));
    } else {
        Point3 p = Point3(0.0f, 0.0f, (float)fabs(height)/2.0f);
        fprintf(mStream, _T("Translation { translation %s }\n"), point(p));
    }
    Indent(level+1);

    fprintf(mStream, _T("Cone { bottomRadius %s "), floatVal(radius1));
    fprintf(mStream, _T("height %s }\n"), floatVal(float(fabs(height))));
    
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Create a VRMNL primitive cube, if appropriate.  
// Returns TRUE if a primitive is created
BOOL
VRBLExport::VrblOutCube(INode* node, Object *obj, int level)
{
    Mtl* mtl = node->GetMtl();
    // Multi materials need meshes
    if (mtl && mtl->IsMultiMtl())
        return FALSE;

    SimpleObject* so = (SimpleObject*) obj;
    float length, width, height;
    BOOL td = HasTexture(node);

    int genUV, lsegs, wsegs, hsegs;
    so->pblock->GetValue(BOXOBJ_GENUVS, mStart, genUV, FOREVER);
    so->pblock->GetValue(BOXOBJ_LSEGS,  mStart, lsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_WSEGS,  mStart, hsegs, FOREVER);
    so->pblock->GetValue(BOXOBJ_HSEGS,  mStart, wsegs, FOREVER);
    if ((genUV && td) || lsegs > 1 || hsegs > 1 || wsegs > 1)
        return FALSE;

    so->pblock->GetValue(BOXOBJ_LENGTH, mStart, length, FOREVER);
    so->pblock->GetValue(BOXOBJ_WIDTH, mStart,  width,  FOREVER);
    so->pblock->GetValue(BOXOBJ_HEIGHT, mStart, height, FOREVER);
    Indent(level);
    fprintf(mStream, _T("Separator {\n"));
    Indent(level+1);
    Point3 p = Point3(0.0f,0.0f,height/2.0f);
    // VRML cubes grow from the middle, MAX grows from z=0
    fprintf(mStream, _T("Translation { translation %s }\n"), point(p));
    Indent(level+1);

    if (mZUp) {
        fprintf(mStream, _T("Cube { width %s "),
                floatVal(float(fabs(width))));
        fprintf(mStream, _T("height %s "),
                floatVal(float(fabs(length))));
        fprintf(mStream, _T(" depth %s }\n"),
                floatVal(float(fabs(height))));
    } else {
        fprintf(mStream, _T("Cube { width %s "),
                floatVal(float(fabs(width))));
        fprintf(mStream, _T("height %s "),
                floatVal(float(fabs(height))));
        fprintf(mStream, _T(" depth %s }\n"),
                floatVal(float(fabs(length))));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));
    
    return TRUE;
}

// Output a perspective camera
BOOL
VRBLExport::VrblOutCamera(INode* node, Object* obj, int level)
{
    // compute camera transform
    ViewParams vp;
    CameraState cs;
    Interval iv;
    CameraObject *cam = (CameraObject *)obj;
    cam->EvalCameraState(0, iv, &cs);
    vp.fov = cs.fov / 1.3333f;

    Indent(level);
    fprintf(mStream, _T("DEF %s_Animated PerspectiveCamera {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("position 0 0 0\n"));
    Indent(level+1);
    fprintf(mStream, _T("heightAngle %s\n"), floatVal(vp.fov));
    if (!mZUp) {
        Indent(level+1);
        fprintf(mStream, _T("orientation 1 0 0 %s\n"),
                floatVal(float(-PI/2.0)));
    }
    Indent(level);
    fprintf(mStream, _T("}\n"));

    return TRUE;
}

// Output an omni light
BOOL
VRBLExport::VrblOutPointLight(INode* node, LightObject* light, int level)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(level);
    fprintf(mStream, _T("DEF %s PointLight {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(level+1);
    fprintf(mStream, _T("location 0 0 0\n"));

    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Output a directional light
BOOL
VRBLExport::VrblOutDirectLight(INode* node, LightObject* light, int level)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(level);
    fprintf(mStream, _T("DEF %s DirectionalLight {\n"),  mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);

    fprintf(mStream, _T("color %s\n"), color(col));

    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Output a Spot Light
BOOL
VRBLExport::VrblOutSpotLight(INode* node, LightObject* light, int level)
{
    LightState ls;
    Interval iv = FOREVER;

    Point3 dir(0,0,-1);
    light->EvalLightState(mStart, iv, &ls);
    Indent(level);
    fprintf(mStream, _T("DEF %s SpotLight {\n"),  mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart,FOREVER)));
    Indent(level+1);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(level+1);
    fprintf(mStream, _T("location 0 0 0\n"));
    Indent(level+1);
    fprintf(mStream, _T("direction %s\n"), normPoint(dir));
    Indent(level+1);
    fprintf(mStream, _T("cutOffAngle %s\n"),
            floatVal(DegToRad(ls.fallsize)));
    Indent(level+1);
    fprintf(mStream, _T("dropOffRate %s\n"),
            floatVal(1.0f - ls.hotsize/ls.fallsize));
    Indent(level+1);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Output an omni light at the top-level Separator
BOOL
VRBLExport::VrblOutTopPointLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(1);
    fprintf(mStream, _T("DEF %s PointLight {\n"),  mNodes.GetNodeName(node));
    Indent(2);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(2);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(2);
    Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
    fprintf(mStream, _T("location %s\n"), point(p));

    Indent(2);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(1);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Output a directional light at the top-level Separator
BOOL
VRBLExport::VrblOutTopDirectLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);

    Indent(1);
    fprintf(mStream, _T("DEF %s DirectionalLight {\n"),  mNodes.GetNodeName(node));
    Indent(2);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart, FOREVER)));
    Indent(2);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Point3 p = Point3(0,0,-1);

    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    Point3 trans, s;
    Quat q;
    AffineParts parts;
    decomp_affine(tm, &parts);
    q = parts.q;
    Matrix3 rot;
    q.MakeMatrix(rot);
    p = p * rot;
    
    Indent(2);
    fprintf(mStream, _T("direction %s\n"), normPoint(p));
    Indent(2);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(1);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Output a spot light at the top-level Separator
BOOL
VRBLExport::VrblOutTopSpotLight(INode* node, LightObject* light)
{
    LightState ls;
    Interval iv = FOREVER;

    light->EvalLightState(mStart, iv, &ls);
    Indent(1);
    fprintf(mStream, _T("DEF %s SpotLight {\n"),  mNodes.GetNodeName(node));
    Indent(2);
    fprintf(mStream, _T("intensity %s\n"),
            floatVal(light->GetIntensity(mStart,FOREVER)));
    Indent(2);
    Point3 col = light->GetRGBColor(mStart, FOREVER);
    fprintf(mStream, _T("color %s\n"), color(col));
    Indent(2);
    Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
    fprintf(mStream, _T("location %s\n"), point(p));

    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    p = Point3(0,0,-1);
    Point3 trans, s;
    Quat q;
    AffineParts parts;
    decomp_affine(tm, &parts);
    q = parts.q;
    Matrix3 rot;
    q.MakeMatrix(rot);
    p = p * rot;

    Indent(2);
    fprintf(mStream, _T("direction %s\n"), normPoint(p));
    Indent(2);
    fprintf(mStream, _T("cutOffAngle %s\n"),
            floatVal( DegToRad(ls.fallsize)));
    Indent(2);
    fprintf(mStream, _T("dropOffRate %s\n"),
            floatVal(1.0f - ls.hotsize/ls.fallsize));
    Indent(2);
    fprintf(mStream, _T("on %s\n"), ls.on ? _T("TRUE") : _T("FALSE"));
    Indent(1);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Create a light at the top-level of the file
void
VRBLExport::OutputTopLevelLight(INode* node, LightObject *light)
{
    Class_ID id = light->ClassID();
    if (id == Class_ID(OMNI_LIGHT_CLASS_ID, 0))
        VrblOutTopPointLight(node, light);
    else if (id == Class_ID(DIR_LIGHT_CLASS_ID, 0))
        VrblOutTopDirectLight(node, light);
    else if (id == Class_ID(SPOT_LIGHT_CLASS_ID, 0) ||
             id == Class_ID(FSPOT_LIGHT_CLASS_ID, 0))
        VrblOutTopSpotLight(node, light);
    
}

// Output a VRML Inline node.
BOOL
VRBLExport::VrblOutInline(VRMLInsObject* obj, int level)
{
    Indent(level);
    fprintf(mStream, _T("WWWInline {\n"));
    Indent(level+1);
    fprintf(mStream, _T("name %s\n"), obj->GetUrl().data());
    float size = obj->GetSize() * 2.0f;
    Indent(level+1);
    Point3 p = Point3(size, size, size);
    fprintf(mStream, _T("bboxSize %s\n"), scalePoint(p));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Distance comparison function for sorting LOD lists.
static int
DistComp(LODObj** obj1, LODObj** obj2)
{
    float diff = (*obj1)->dist - (*obj2)->dist;
    if (diff < 0.0f) return -1;
    if (diff > 0.0f) return 1;
    return 0;
}

// Create a level-of-detail object.
BOOL
VRBLExport::VrblOutLOD(INode *node, LODObject* obj, int level)
{
    int numLod = obj->NumRefs();
    Tab<LODObj*> lodObjects = obj->GetLODObjects();
    int i;

    if (numLod == 0)
        return TRUE;

    lodObjects.Sort((CompareFnc) DistComp);

    if (numLod > 1) {
        Indent(level);
        fprintf(mStream, _T("LOD {\n"));
        Indent(level+1);
        Point3 p = node->GetObjTMAfterWSM(mStart).GetTrans();
        fprintf(mStream, _T("center %s\n"), point(p));
        Indent(level+1);
        fprintf(mStream, _T("range [ "));
        for(i = 0; i < numLod-1; i++) {
            if (i < numLod-2)
                fprintf(mStream, _T("%s, "), floatVal(lodObjects[i]->dist));
            else
                fprintf(mStream, _T("%s ]\n"), floatVal(lodObjects[i]->dist));
        }
    }

    for(i = 0; i < numLod; i++) {
        INode *node = lodObjects[i]->node;
        INode *parent = node->GetParentNode();
        VrblOutNode(node, parent, level+1, TRUE, FALSE);
    }

    if (numLod > 1) {
        Indent(level);
        fprintf(mStream, _T("}\n"));
    }

    return TRUE;
}

// Output an AimTarget.
BOOL
VRBLExport::VrblOutTarget(INode* node, int level)
{
    INode* lookAt = node->GetLookatNode();
    if (!lookAt)
        return TRUE;
    Object* lookAtObj = lookAt->EvalWorldState(mStart).obj;
    Class_ID id = lookAtObj->ClassID();
    // Only generate aim targets for targetted spot lights and cameras
    if (id != Class_ID(SPOT_LIGHT_CLASS_ID, 0) &&
        id != Class_ID(LOOKAT_CAM_CLASS_ID, 0))
        return TRUE;
    Indent(level);
    fprintf(mStream, _T("AimTarget_ktx_com {\n"));
    if (mGenFields) {
        Indent(level+1);
        fprintf(mStream, _T("fields [ SFString aimer ]\n"));
    }
    Indent(level+1);
	if ( (id == Class_ID(LOOKAT_CAM_CLASS_ID, 0)) && IsEverAnimated(lookAt))
		fprintf(mStream, _T("aimer \"%s_Animated\"\n"), mNodes.GetNodeName(lookAt));
	else
		fprintf(mStream, _T("aimer \"%s\"\n"), mNodes.GetNodeName(lookAt));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    return TRUE;
}

// Write out the VRML for nodes we know about, including VRML helper nodes, 
// lights, cameras and VRML primitives
BOOL
VRBLExport::VrblOutSpecial(INode* node, INode* parent,
                             Object* obj, int level)
{
    Class_ID id = obj->ClassID();

    /*
    if (id == Class_ID(MR_BLUE_CLASS_ID1, MR_BLUE_CLASS_ID2)) {
        level++;
        VrblOutMrBlue(node, parent, (MrBlueObject*) obj,
                      &level, FALSE);
    }
    */

    if (id == Class_ID(OMNI_LIGHT_CLASS_ID, 0))
        return VrblOutPointLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(DIR_LIGHT_CLASS_ID, 0))
        return VrblOutDirectLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(SPOT_LIGHT_CLASS_ID, 0) ||
        id == Class_ID(FSPOT_LIGHT_CLASS_ID, 0))
        return VrblOutSpotLight(node, (LightObject*) obj, level+1);

    if (id == Class_ID(VRML_INS_CLASS_ID1, VRML_INS_CLASS_ID2))
        return VrblOutInline((VRMLInsObject*) obj, level+1);

    if (id == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2))
        return VrblOutLOD(node, (LODObject*) obj, level+1);

    if (id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
        id == Class_ID(LOOKAT_CAM_CLASS_ID, 0))
        return VrblOutCamera(node, obj, level+1);

    if (id == Class_ID(TARGET_CLASS_ID, 0))
        return VrblOutTarget(node, level+1);

    // If object has modifiers or WSMs attached, do not output as
    // a primitive
    SClass_ID sid = node->GetObjectRef()->SuperClassID();
    if (sid == WSM_DERIVOB_CLASS_ID ||
        sid == DERIVOB_CLASS_ID)
        return FALSE;

    if (!mPrimitives)
        return FALSE;

    // Otherwise look for the primitives we know about
    if (id == Class_ID(SPHERE_CLASS_ID, 0))
        return VrblOutSphere(node, obj, level+1);

    if (id == Class_ID(CYLINDER_CLASS_ID, 0))
        return VrblOutCylinder(node, obj, level+1);

    if (id == Class_ID(CONE_CLASS_ID, 0))
        return VrblOutCone(node, obj, level+1);

    if (id == Class_ID(BOXOBJ_CLASS_ID, 0))
        return VrblOutCube(node, obj, level+1);

    return FALSE;
        
}

static BOOL
IsLODObject(Object* obj)
{
    return obj->ClassID() == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2);
}

// Returns TRUE iff an object or one of its ancestors in animated
static BOOL
IsEverAnimated(INode* node)
{
 // need to sample transform
    Class_ID id = node->EvalWorldState(0).obj->ClassID();
    if (id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
        id == Class_ID(LOOKAT_CAM_CLASS_ID, 0)) return TRUE;

    for (; !node->IsRootNode(); node = node->GetParentNode())
        if (node->IsAnimated())
            return TRUE;
    return FALSE;
}

// Returns TRUE for object that we want a VRML node to occur
// in the file.  
BOOL
VRBLExport::isVrblObject(INode * node, Object *obj, INode* parent)
{
    if (!obj)
        return FALSE;

    Class_ID id = obj->ClassID();
    // Mr Blue nodes only 1st class if stand-alone

    // only animated light come out in scene graph
    if (IsLight(node) ||
        (id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
         id == Class_ID(LOOKAT_CAM_CLASS_ID, 0)))
        return IsEverAnimated(node);

    return (obj->IsRenderable() ||
            id == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2) ||
            node->NumberOfChildren() > 0 //||
            ) &&
            (mExportHidden || !node->IsHidden());        
}

// Write the VRML for a single object.
void
VRBLExport::VrblOutObject(INode* node, INode* parent, Object* obj, int level)
{
    BOOL isTriMesh = obj->CanConvertToType(triObjectClassID);
        
    BOOL multiMat = FALSE, twoSided = FALSE;
    // Output the material
    if (obj->IsRenderable())
        multiMat = OutputMaterial(node, twoSided, level+1);

    // First check for VRML primitives and other special objects
    if (VrblOutSpecial(node, parent, obj, level)) {
        return;
    }

    // Otherwise output as a triangle mesh
    if (isTriMesh) {
        TriObject *tri = (TriObject *)obj->ConvertToType(0, triObjectClassID);
        OutputTriObject(node, tri, multiMat, twoSided, level+1);
        if(obj != (Object *)tri)
            tri->DeleteThis();
    }
}

// Get the distance to the line of sight target
float 
GetLosProxDist(INode* node, TimeValue t)
{
    Point3 p0 = node->GetObjTMAfterWSM(t).GetTrans();
    Matrix3 tmat;
    node->GetTargetTM(t,tmat);
    Point3 p1 = tmat.GetTrans();
    return Length(p1-p0);
}

// Get the vector to the line of sight target
Point3
GetLosVector(INode* node, TimeValue t)
{
    Point3 p0 = node->GetObjTMAfterWSM(t).GetTrans();
    Matrix3 tmat;
    node->GetTargetTM(t,tmat);
    Point3 p1 = tmat.GetTrans();
    return p1-p0;
}

// Return TRUE iff the controller is a TCB controller
static BOOL 
IsTCBControl(Control *cont)
{
    return ( cont && (
        cont->ClassID()==Class_ID(TCBINTERP_FLOAT_CLASS_ID,0)    ||
        cont->ClassID()==Class_ID(TCBINTERP_POSITION_CLASS_ID,0) ||
        cont->ClassID()==Class_ID(TCBINTERP_ROTATION_CLASS_ID,0) ||
        cont->ClassID()==Class_ID(TCBINTERP_POINT3_CLASS_ID,0)   ||
        cont->ClassID()==Class_ID(TCBINTERP_SCALE_CLASS_ID,0)));
}

// Return TRUE iff the keys are different in any way.
static BOOL
TCBIsDifferent(ITCBKey *k, ITCBKey* oldK)
{
    return k->tens    != oldK->tens   ||
           k->cont    != oldK->cont   ||
           k->bias    != oldK->bias   ||
           k->easeIn  != oldK->easeIn ||
           k->easeOut != oldK->easeOut;
}

// returns TRUE iff the position keys are exactly the same
static BOOL
PosKeysSame(ITCBPoint3Key& k1, ITCBPoint3Key& k2)
{
    if (TCBIsDifferent(&k1, &k2))
        return FALSE;
    return k1.val == k2.val;
}

// returns TRUE iff the rotation keys are exactly the same
static BOOL
RotKeysSame(ITCBRotKey& k1, ITCBRotKey& k2)
{
    if (TCBIsDifferent(&k1, &k2))
        return FALSE;
    return k1.val.axis == k2.val.axis && k1.val.angle == k2.val.angle;
}

// returns TRUE iff the scale keys are exactly the same
static BOOL
ScaleKeysSame(ITCBScaleKey& k1, ITCBScaleKey& k2)
{
    if (TCBIsDifferent(&k1, &k2))
        return FALSE;
    return k1.val.s == k2.val.s;
}

// Write out all the keyframe data for the TCB given controller
BOOL
VRBLExport::WriteTCBKeys(INode* node, Control *cont,
                         int type, int level)
{
    ITCBFloatKey fkey, ofkey;
    ITCBPoint3Key pkey, opkey;
    ITCBRotKey rkey, orkey;
    ITCBScaleKey skey, oskey;
    ITCBKey *k, *oldK;	
    int num = cont->NumKeys();
    Point3 pval;
    Quat q, qLast = IdentQuat();
    AngAxis rval;
    ScaleValue sval;
    Interval valid;
    Point3 p, po;

    // Get the keyframe interface
    IKeyControl *ikeys = GetKeyControlInterface(cont);
    
    // Gotta have some keys
    if (num == NOT_KEYFRAMEABLE || num == 0 || !ikeys) {
        return FALSE;
    }
    
    // Set up 'k' to point at the right derived class
    switch (type) {
    case KEY_FLOAT: k = &fkey; oldK = &ofkey; break;
    case KEY_POS:   k = &pkey; oldK = &opkey; break;
    case KEY_ROT:   k = &rkey; oldK = &orkey; break;
    case KEY_SCL:   k = &skey; oldK = &oskey; break;
    case KEY_COLOR: k = &pkey; oldK = &opkey; break;
    default: return FALSE;
    }
    
    for (int i=0; i<ikeys->GetNumKeys(); i++) {
        ikeys->GetKey(i,k);
        if (k->time < mStart)
            continue;

        if (i == 0 || TCBIsDifferent(k, oldK)) {
            Indent(level);
            fprintf(mStream, _T("AnimationStyle_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream, _T("fields [ SFBool loop, SFBitMask splineUse, SFFloat tension, SFFloat continuity, SFFloat bias, SFFloat easeTo, SFFloat easeFrom, SFVec3f pivotOffset ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("splineUse ("));
            
            // Write flags
            BOOL hadOne = FALSE;
            if (k->tens   != 0.0f) {
                fprintf(mStream, _T("TENSION"));
                hadOne = TRUE;
            }
            if (k->cont   != 0.0f) {
                if (hadOne)
                    fprintf(mStream, _T(" | "));
                fprintf(mStream, _T("CONTINUITY"));
                hadOne = TRUE;
            }
            if (k->bias   != 0.0f) {
                if (hadOne)
                    fprintf(mStream, _T(" | "));
                fprintf(mStream, _T("BIAS"));
                hadOne = TRUE;
            }
            if (k->easeIn != 0.0f) {
                if (hadOne)
                    fprintf(mStream, _T(" | "));
                fprintf(mStream, _T("EASE_TO"));
                hadOne = TRUE;
            }
            if (k->easeOut!= 0.0f) {
                if (hadOne)
                    fprintf(mStream, _T(" | "));
                fprintf(mStream, _T("EASE_FROM"));
                hadOne = TRUE;
            }
            fprintf(mStream, _T(")\n"));
            
            // Write TCB and ease
            if (k->tens   != 0.0f) {
                Indent(level+1);
                fprintf(mStream, _T("tension %s\n"), floatVal(k->tens));
            }
            if (k->cont   != 0.0f) {
                Indent(level+1);
                fprintf(mStream, _T("continuity %s\n"), floatVal(k->cont));
            }
            if (k->bias   != 0.0f) {
                Indent(level+1);
                fprintf(mStream, _T("bias %s\n"), floatVal(k->bias));
            }
            if (k->easeIn != 0.0f) {
                Indent(level+1);
                fprintf(mStream, _T("easeTo %s\n"), floatVal(k->easeIn));
            }
            if (k->easeOut!= 0.0f) {
                Indent(level+1);
                fprintf(mStream, _T("easeFrom %s\n"), floatVal(k->easeOut));
            }

	        // get the pivot offset and remove the rotational component
	        Matrix3 m = Matrix3(TRUE);
	        Quat q = node->GetObjOffsetRot();
	        q.MakeMatrix(m);
            p = -node->GetObjOffsetPos();
	        m = Inverse(m);
	        po = VectorTransform(m, p);
            
            Indent(level+1);
            if (type != KEY_POS) fprintf(mStream, _T("pivotOffset %s\n"), point(po));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            
        }
        // Write values
        switch (type) {
        case KEY_FLOAT: 
            assert(FALSE);
            break;
            
        case KEY_SCL: {
            if (i == 0 && (k->time - mStart) != 0) {
                WriteScaleKey0(node, mStart, level, TRUE);
                WriteScaleKey0(node,
                               k->time-GetTicksPerFrame(), level, TRUE);
            }
            Matrix3 tm = GetLocalTM(node, mStart);
            AffineParts parts;
            decomp_affine(tm, &parts);
            ScaleValue sv(parts.k, parts.u);
            Point3 s = sv.s;
            if (parts.f < 0.0f) s = - s;
            else s = skey.val.s;
            if (i != 0 && ScaleKeysSame(skey, oskey))
                continue;
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("ScaleKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFVec3f scale ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), (k->time - mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("scale %s\n"), scalePoint(s));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            memcpy(oldK, k, sizeof(skey));
            break; }
            
        case KEY_COLOR:
            if (i == 0 && k->time != 0) {
                WritePositionKey0(node, mStart, level, TRUE);
                WritePositionKey0(node,
                                  k->time-GetTicksPerFrame(), level,TRUE);
            }
            if (i != 0 && PosKeysSame(pkey, opkey))
                continue;
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("ColorKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFColor color ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), (k->time - mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("color %s\n"), color(pkey.val));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            memcpy(oldK, k, sizeof(pkey));
            break;

        case KEY_POS:
            if (i == 0 && (k->time - mStart) != 0) {
                WritePositionKey0(node, mStart, level, TRUE);
                WritePositionKey0(node,
                                  k->time-GetTicksPerFrame(), level,TRUE);
            }
            if (i != 0 && PosKeysSame(pkey, opkey))
                continue;
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("PositionKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFVec3f translation ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), (k->time - mStart)/GetTicksPerFrame());
	        p = pkey.val;
            Indent(level+1);
            fprintf(mStream, _T("translation %s\n"), point(p));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            memcpy(oldK, k, sizeof(pkey));
            break;
            
        case KEY_ROT: {
            // Note rotation keys are cummulative unlike other keys.
            if (i == 0 && (k->time - mStart) != 0) {
                WriteRotationKey0(node, mStart, level, TRUE);
                WriteRotationKey0(node,
                                  k->time-GetTicksPerFrame(), level,TRUE);
            }
            Matrix3 tm = GetLocalTM(node, k->time);
            Point3 axis;
            Quat q;
            float ang;
            
            AffineParts parts;
            decomp_affine(tm, &parts);
            q = parts.q;
            AngAxisFromQ(q/qLast, &ang, axis);
	        // this removes rotational direction errors when rotating PI
	        // and reduces negative rotational errors
	        if (!round(axis.x + rkey.val.axis.x) &&
	    	    !round(axis.y + rkey.val.axis.y) &&
	    	    !round(axis.z + rkey.val.axis.z)) {
                    ang = rkey.val.angle;
                    axis = rkey.val.axis;
	        }

            // this removes errors if q = (0 0 0 0) for rkey (1 0 0 360)
            if (axis.x == 0.0 &&
                axis.y == 0.0 &&
                axis.z == 0.0 &&
                ang    == 0.0) {
                ang =  rkey.val.angle;
                axis = rkey.val.axis;
            }

            if (i !=0 && ang == 0.0f)
                continue;
            qLast = q;
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("RotationKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFRotation rotation ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), (k->time - mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("rotation %s\n"),
                    axisPoint(axis, ang));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            memcpy(oldK, k, sizeof(rkey));
            break; }
        }
    }
    return TRUE;
}

// Write out all the keyframe data for an arbitrary PRS controller
void
VRBLExport::WriteLinearKeys(INode* node,
                             Tab<TimeValue>& posTimes,
                             Tab<Point3>& posKeys,
                             Tab<TimeValue>& rotTimes,
                             Tab<AngAxis>& rotKeys,
                             Tab<TimeValue>& sclTimes,
                             Tab<Point3>& sclKeys,
                             int type, int level)
{
    AngAxis rval;
    Point3 p, po, s;
    int i;
    TimeValue t;
    Tab<TimeValue>& timeVals = posTimes;

    // Set up 'k' to point at the right derived class
    switch (type) {
    case KEY_POS:
    case KEY_COLOR:
        timeVals = posTimes;
        break;
    case KEY_ROT:
        timeVals = rotTimes;
        break;
    case KEY_SCL:
        timeVals = sclTimes;
        break;
    default: return;
    }

    Indent(level);
    fprintf(mStream, _T("AnimationStyle_ktx_com {\n"));
    Indent(level+1);
    if (mGenFields)
        fprintf(mStream, _T("fields [ SFVec3f pivotOffset ]\n"));
    Indent(level+1);
    // get the pivot offset and remove rotational component
    Matrix3 m = Matrix3(TRUE);
    Quat q = node->GetObjOffsetRot();
    q.MakeMatrix(m);
    p = -node->GetObjOffsetPos();
    m = Inverse(m);
    po = VectorTransform(m, p);

    Indent(level+1);
    if (type != KEY_POS) fprintf(mStream, _T("pivotOffset %s\n"), point(po));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    
    for (i=0; i < timeVals.Count(); i++) {
        t = timeVals[i];
        if (t < mStart)
            continue;

        // Write values
        switch (type) {
        case KEY_POS:
            mHadAnim = TRUE;
            p = posKeys[i];
            Indent(level);
            fprintf(mStream, _T("PositionKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFVec3f translation ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"),
                    (timeVals[i]-mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("translation %s\n"), point(p));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            break;
            
        case KEY_ROT:
            mHadAnim = TRUE;
            rval = rotKeys[i];
            if (rval.angle == 0.0f ||
                fabs(rval.angle - 2.0*PI) < 1.0e-5)
                break;
            Indent(level);
            fprintf(mStream, _T("RotationKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFRotation rotation ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"),
                    (timeVals[i]-mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("rotation %s\n"),
                    axisPoint(rval.axis, rval.angle));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            break;
        case KEY_SCL:
            mHadAnim = TRUE;
            s = sclKeys[i];
            Indent(level);
            fprintf(mStream, _T("ScaleKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFVec3f scale ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"),
                    (timeVals[i]-mStart)/GetTicksPerFrame());
            Indent(level+1);
            fprintf(mStream, _T("scale %s\n"), scalePoint(s));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            break;
            
        case KEY_COLOR:
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("ColorKey_ktx_com {\n"));
            Indent(level+1);
            if (mGenFields)
                fprintf(mStream,
                        _T("fields [ SFLong frame, SFColor color ]\n"));
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"),
                    (timeVals[i]-mStart)/GetTicksPerFrame());
            Indent(level+1);
            p = posKeys[i];
            fprintf(mStream, _T("color %s\n"), color(p));
            Indent(level);
            fprintf(mStream, _T("}\n"));
            break;

        }
    }
            
    return;
}

int
VRBLExport::WriteAllControllerData(INode* node, int flags, int level,
                                   Control* lc)
{
    int i;
    TimeValue t;
    TimeValue end = mIp->GetAnimRange().End();
    int frames = (end - mStart)/GetTicksPerFrame();
    Point3 p, axis, s;
    Quat q, qLast = IdentQuat();
    Matrix3 tm, ip;
    int retVal = 0;

    // Tables of keyframe values
    Tab<Point3>    posKeys;
    Tab<TimeValue> posTimes;
    Tab<Point3>    scaleKeys;
    Tab<TimeValue> scaleTimes;
    Tab<AngAxis>   rotKeys;
    Tab<TimeValue> rotTimes;
    BOOL keys;

    // Set up 'k' to point at the right derived class
    if (flags & KEY_POS) {
        Control* pc = node->GetTMController()->GetPositionController();
        if (IsTCBControl(pc)) {
            keys = WriteTCBKeys(node, pc, KEY_POS, level);
            flags &= ~KEY_POS;
            if (keys)
                retVal |= KEY_POS;
        } else {
            posKeys.SetCount(frames+1);
            posTimes.SetCount(frames+1);
        }
    }
    if (flags & KEY_COLOR) {
        posKeys.SetCount(frames+1);
        posTimes.SetCount(frames+1);
    }
    if (flags & KEY_ROT) {
        Control* rc = node->GetTMController()->GetRotationController();
        // disabling writing tcb rotation keys because position controller
        // like path controller also change rotation so you have a tcbrotation controller
        // with no keys.
        if (IsTCBControl(rc) && rc->NumKeys() && FALSE) {
            keys = WriteTCBKeys(node, rc, KEY_ROT, level);
            flags &= ~KEY_ROT;
            if (keys)
                retVal |= KEY_ROT;
        } else {
            rotKeys.SetCount(frames+1);
            rotTimes.SetCount(frames+1);
        }
    }
    if (flags & KEY_SCL) {
        Control* sc = node->GetTMController()->GetScaleController();
        if (IsTCBControl(sc)) {
            keys = WriteTCBKeys(node, sc, KEY_SCL, level);
            flags &= ~KEY_SCL;
            if (keys)
                retVal |= KEY_SCL;
        } else {
            scaleKeys.SetCount(frames+1);
            scaleTimes.SetCount(frames+1);
        }
    }

    if (!flags)
        return retVal;

    // Sample the controller at every frame
    for(i = 0, t = mStart; i <= frames; i++, t += GetTicksPerFrame()) {
        if (flags & KEY_COLOR) {
            lc->GetValue(t, &posKeys[i], FOREVER);
            posTimes[i] = t;
            continue;
        }
        tm = GetLocalTM(node, t);
        AffineParts parts;
        decomp_affine(tm, &parts);
        if (flags & KEY_SCL) {
            s = ScaleValue(parts.k, parts.u).s;
            if (parts.f < 0.0f)
                s = - s;
            scaleTimes[i] = t;
            scaleKeys[i]  = s;
        }
            
        if (flags & KEY_POS) {
            p = parts.t;
            posTimes[i] = t;
            posKeys[i]  = p;
        }
            
        if (flags & KEY_ROT) {
            q = parts.q;
            rotTimes[i] = t;
            rotKeys[i] = AngAxis(q/qLast);
            qLast = q;
        }
    }

    int newKeys;
    float eps;
    if (flags & KEY_POS) {
        eps = float(1.0e-5);
        newKeys = reducePoint3Keys(posTimes, posKeys, eps);
        if (newKeys != 0) {
            retVal |= KEY_POS;
            WriteLinearKeys(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_POS, level);
        }
    }
    if (flags & KEY_ROT) {
        eps = float(1.0e-5);
        newKeys = reduceAngAxisKeys(rotTimes, rotKeys, eps);
        if (newKeys != 0) {
            retVal |= KEY_ROT;
            WriteLinearKeys(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_ROT, level);
        }
    }
    if (flags & KEY_SCL) {
        eps = float(1.0e-5);
        newKeys = reducePoint3Keys(scaleTimes, scaleKeys, eps);
        if (newKeys != 0) {
            retVal |= KEY_SCL;
            WriteLinearKeys(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_SCL, level);
        }
    }
    if (flags & KEY_COLOR) {
        eps = float(1.0e-5);
        newKeys = reducePoint3Keys(posTimes, posKeys, eps);
        if (newKeys != 0) {
            retVal |= KEY_SCL;
            WriteLinearKeys(node,
                            posTimes,   posKeys,
                            rotTimes,   rotKeys,
                            scaleTimes, scaleKeys,
                            KEY_COLOR, level);
        }
    }
    return retVal;
}

// Write out the initial position key, relative to the parent.
void
VRBLExport::WritePositionKey0(INode* node, TimeValue t, int level, BOOL force)
{
    Matrix3 tm = GetLocalTM(node, mStart);
    Point3 p = tm.GetTrans();

    // Don't need a key for identity translate
    if (!force && (p.x == 0.0f && p.y == 0.0f && p.z == 0.0f))
        return;

    mHadAnim = TRUE;
    Indent(level);
    fprintf(mStream, _T("PositionKey_ktx_com {\n"));
    Indent(level+1);
    if (mGenFields)
        fprintf(mStream, _T("fields [ SFLong frame, SFVec3f translation ]\n"));
    Indent(level+1);
    fprintf(mStream, _T("frame %d\n"), (t-mStart)/GetTicksPerFrame());
    Indent(level+1);
    fprintf(mStream, _T("translation %s\n"), point(p));
    Indent(level);
    fprintf(mStream, _T("}\n"));
    
}

// Write out the initial rotation key, relative to the parent.
void
VRBLExport::WriteRotationKey0(INode* node, TimeValue t, int level, BOOL force)
{
    Matrix3 tm = GetLocalTM(node, mStart);
    Point3 p, s, axis;
    Quat q;
    float ang;

    AffineParts parts;
    decomp_affine(tm, &parts);
    p = parts.t;
    q = parts.q;
    AngAxisFromQ(q, &ang, axis);

    // Dont't need a ket for identity rotate
    if (!force && ang == 0.0f)
        return;

    mHadAnim = TRUE;
    Indent(level);
    fprintf(mStream, _T("RotationKey_ktx_com {\n"));
    Indent(level+1);
    if (mGenFields)
        fprintf(mStream,
                _T("fields [ SFLong frame, SFRotation rotation ]\n"));
    Indent(level+1);
    fprintf(mStream, _T("frame %d\n"), (t-mStart)/GetTicksPerFrame());
    Indent(level+1);
    fprintf(mStream, _T("rotation %s\n"), axisPoint(axis, ang));
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

// Write out the initial scale key, relative to the parent.
void
VRBLExport::WriteScaleKey0(INode* node, TimeValue t, int level, BOOL force)
{ 
    Matrix3 tm = GetLocalTM(node, mStart);
    AffineParts parts;
    decomp_affine(tm, &parts);
    ScaleValue sv(parts.k, parts.u);
    Point3 s = sv.s;
    if (parts.f < 0.0f)
        s = - s;

    // Don't need a key for identity scale
    if (!force && (s.x == 1.0f && s.y == 1.0f && s.z == 1.0f))
        return;

    mHadAnim = TRUE;
    Indent(level);
    fprintf(mStream, _T("ScaleKey_ktx_com {\n"));
    Indent(level+1);
    if (mGenFields)
        fprintf(mStream, _T("fields [ SFLong frame, SFVec3f scale ]\n"));
    Indent(level+1);
    fprintf(mStream, _T("frame %d\n"), (t-mStart)/GetTicksPerFrame());
    Indent(level+1);
    fprintf(mStream, _T("scale %s\n"), scalePoint(s));
    Indent(level);
    fprintf(mStream, _T("}\n"));
}

void
VRBLExport::WriteVisibilityData(INode *node, int level) {
    int i;
    TimeValue t;
    int frames = mIp->GetAnimRange().End()/GetTicksPerFrame();
    BOOL lastVis = TRUE, vis;

    // Now generate the Hide keys
    for(i = 0, t = mStart; i <= frames; i++, t += GetTicksPerFrame()) {
	vis = node->GetVisibility(t) <= 0.0f ? FALSE : TRUE;
        if (vis != lastVis) {
            mHadAnim = TRUE;
            Indent(level);
            fprintf(mStream, _T("HideKey_ktx_com {\n"));
            if (mGenFields) {
                Indent(level+1);
                fprintf(mStream, _T("fields [ SFLong frame] \n"));
            }
            Indent(level+1);
            fprintf(mStream, _T("frame %d\n"), i);
            Indent(level);
            fprintf(mStream, _T("}\n"));
        }
        lastVis = vis;
    }    
}

BOOL
VRBLExport::IsLight(INode* node)
{
    Object* obj = node->EvalWorldState(mStart).obj;
    if (!obj)
        return FALSE;

    SClass_ID sid = obj->SuperClassID();
    return sid == LIGHT_CLASS_ID;
}

Control *
VRBLExport::GetLightColorControl(INode* node)
{
    if (!IsLight(node))
        return NULL;
    Object* obj = node->EvalWorldState(mStart).obj;
    IParamBlock *pblock = (IParamBlock *) obj->SubAnim(0);
    Control* cont = pblock->GetController(0);  // I know color is index 0!
    return cont;
}

#define NeedsKeys(nkeys) ((nkeys) > 0 || (nkeys) == NOT_KEYFRAMEABLE)

// Write out all PRS keyframe data, if it exists
void
VRBLExport::VrblOutControllers(INode* node, int level)
{
    Control *pc, *rc, *sc, *vc, *lc;
    int npk = 0, nrk = 0, nsk = 0, nvk = 0, nlk = 0;

    if (mType != Export_VRBL)
        return;

    pc = node->GetTMController()->GetPositionController();
    if (pc) npk = pc->NumKeys();
    rc = node->GetTMController()->GetRotationController();
    if (rc) nrk = rc->NumKeys();
    sc = node->GetTMController()->GetScaleController();
    if (sc) nsk = sc->NumKeys();
    vc = node->GetVisController();
    if (vc) nvk = vc->NumKeys();
    lc = GetLightColorControl(node);
    if (lc) nlk = lc->NumKeys();
    if (NeedsKeys(nlk))
        WriteAllControllerData(node, KEY_COLOR, level, lc);

    Class_ID id = node->GetTMController()->ClassID();
    int flags = 0;

    if (id != Class_ID(PRS_CONTROL_CLASS_ID, 0))
        flags = KEY_POS | KEY_ROT | KEY_SCL;
     else {
         pc = node->GetTMController()->GetPositionController();
         if (pc) npk = pc->NumKeys();
         rc = node->GetTMController()->GetRotationController();
         if (rc) nrk = rc->NumKeys();
         sc = node->GetTMController()->GetScaleController();
         if (sc) nsk = sc->NumKeys();
         if (NeedsKeys(npk))
             flags |= KEY_POS | KEY_ROT;  // pos controllers can affect rot
         if (NeedsKeys(nrk))
             flags |= KEY_ROT;
         if (NeedsKeys(nsk))
             flags |=  KEY_SCL;
     }
    if (flags) {
        int newFlags = WriteAllControllerData(node, flags, level, NULL);
        if (!(newFlags & KEY_POS))
            WritePositionKey0(node, mStart, level, FALSE);
        if (!(newFlags & KEY_ROT))
            WriteRotationKey0(node, mStart, level, FALSE);
        if (!(newFlags & KEY_SCL))
            WriteScaleKey0(node, mStart, level, FALSE);
    }
    if (NeedsKeys(nvk))
        WriteVisibilityData(node, level);
#if 0
    // FIXME add this back!
    if (NeedsKeys(nlk))
        WriteControllerData(node, lc, KEY_COLOR, level);
#endif
}

// Output a camera at the top level of the file
void
VRBLExport::VrmlOutTopLevelCamera(int level, INode* node, BOOL topLevel)
{
    if (!topLevel && node == mCamera)
        return;
        
    CameraObject* cam = (CameraObject*) node->EvalWorldState(mStart).obj;
    Matrix3 tm = node->GetObjTMAfterWSM(mStart);
    Point3 p, s, axis;
    Quat q;
    float ang;

    AffineParts parts;
    decomp_affine(tm, &parts);
    p = parts.t;
    q = parts.q;
    if (!mZUp) {
        // Now rotate around the X Axis PI/2
        Matrix3 rot = RotateXMatrix(PI/2);
        Quat qRot(rot);
		if (qRot == q) {
			axis.x = axis.z = 0.0f;
			axis.y = 1.0f;
			ang = 0.0f;
		} else AngAxisFromQ(q/qRot, &ang, axis);
	} else
        AngAxisFromQ(q, &ang, axis);

    ViewParams vp;
    CameraState cs;
    Interval iv;
    cam->EvalCameraState(0, iv, &cs);
    vp.fov = cs.fov / 1.3333f;

    Indent(level);
    fprintf(mStream, _T("DEF %s PerspectiveCamera {\n"), mNodes.GetNodeName(node));
    Indent(level+1);
    fprintf(mStream, _T("position %s\n"), point(p));
    Indent(level+1);
    fprintf(mStream, _T("orientation %s\n"), axisPoint(axis, -ang));
    Indent(level+1);
    fprintf(mStream, _T("heightAngle %s\n"), floatVal(vp.fov));
    Indent(level);
    fprintf(mStream, _T("}\n"));

}

// From dllmain.cpp
extern HINSTANCE hInstance;

// Write out some comments at the top of the file.
void
VRBLExport::VrblOutFileInfo()
{
    char filename[MAX_PATH];
    DWORD size, dummy;
    float vernum = 1.0f;
    float betanum = 0.0f;

    GetModuleFileName(hInstance, filename, MAX_PATH);
    size = GetFileVersionInfoSize(filename, &dummy);
    if (size) {
        char *buf = (char *)malloc(size);
        GetFileVersionInfo(filename, NULL, size, buf);
        VS_FIXEDFILEINFO *qbuf;
        UINT len;
        if (VerQueryValue(buf, "\\", (void **)&qbuf, &len)) {
            // got the version information
            DWORD ms = qbuf->dwProductVersionMS;
            DWORD ls = qbuf->dwProductVersionLS;
            vernum = HIWORD(ms) + (LOWORD(ms) / 100.0f);
            betanum = HIWORD(ls) + (LOWORD(ls) / 100.0f);
        }
        free(buf);
    }
    Indent(1);
    fprintf(mStream, _T("Info { string \"Produced by 3D Studio MAX VRML 1.0/2.0 exporter, Version %.5g, Revision %.5g\" }\n"), vernum, betanum);
    
    
    time_t ltime;
    time( &ltime );
    char * time = ctime(&ltime);
    // strip the CR
    time[strlen(time)-1] = '\0';
    TCHAR* fn = mIp->GetCurFileName();
    if (fn && _tcslen(fn) > 0) {
        Indent(1);
        fprintf(mStream, _T("Info { string \"MAX File: %s, Date: %s\" }\n"), fn, time);
    } else {
        Indent(1);
        fprintf(mStream, _T("Info { string \"Date: %s\" }\n"), time);
    }
    Indent(1);
    fprintf(mStream, _T("ShapeHints {\n"));
    Indent(2);
    fprintf(mStream, _T("shapeType SOLID\n"));
    Indent(2);
    fprintf(mStream, _T("vertexOrdering COUNTERCLOCKWISE\n"));
    Indent(2);
    fprintf(mStream, _T("faceType CONVEX\n"));
    Indent(1);
    fprintf(mStream, _T("}\n"));
}

// Output a single node as VRML and recursively output the children of
// the node.
void
VRBLExport::VrblOutNode(INode* node, INode* parent, int level, BOOL isLOD,
                        BOOL lastChild)
{
    // Don't gen code for LOD references, only LOD nodes
    if (!isLOD && ObjectIsLODRef(node))
        return;

    Object *obj = node->EvalWorldState(mStart).obj;
    BOOL outputName = TRUE;
    int numChildren = node->NumberOfChildren();
    BOOL isVrml = isVrblObject(node, obj, parent);

    if (node->IsRootNode() || (obj && isVrml)) {
        StartNode(node, obj, level, outputName);
        if (node->IsRootNode()) {
            VrblOutFileInfo();
            // Collect a list of all LOD nodes and textures for later use.
            if (mCamera)
                VrmlOutTopLevelCamera(level+ 1, mCamera, TRUE);
            ScanSceneGraph();
        }
    }

    if (obj && isVrml) {
        if (!IsLODObject(obj)) {
            OutputNodeTransform(node, level+1);
            
            // If the node has a controller, output the data
            VrblOutControllers(node, level+1);
        }
        // Output the data for the object at this node
        VrblOutObject(node, parent, obj, level);
    }

    // Now output the children
    for(int i=0; i < numChildren; i++) {
        VrblOutNode(node->GetChildNode(i), node, level+1,
                    FALSE, i == numChildren - 1);
    }
    
    if (node->IsRootNode() || (obj && (isVrblObject(node, obj, parent)))) {
        if (node->IsRootNode())
            VrblOutAnimationFrames();
        EndNode(node, level, lastChild);
    }
}

// Write the "AnimationFrames" VRBL node
void
VRBLExport::VrblOutAnimationFrames()
{
    if (mType == Export_VRBL && mHadAnim) {
        Indent(1);
        fprintf(mStream, _T("AnimationFrames_ktx_com {\n"));
        Indent(2);
        if (mGenFields)
            fprintf(mStream, _T("fields [ SFLong length, SFLong segmentStart, SFLong segmentEnd, SFLong current, SFFloat rate ]\n"));
        Indent(2);
        int frames = (mIp->GetAnimRange().End()-mIp->GetAnimRange().Start())/
                      GetTicksPerFrame() + 1;
        fprintf(mStream, _T("length %d\n"), frames);
        Indent(2);
        fprintf(mStream, _T("rate %d\n"), GetFrameRate());
        Indent(1);
        fprintf(mStream, _T("}\n"));
    }
}


// Traverse the scene graph looking for LOD nodes.
void
VRBLExport::TraverseNode(INode* node)
{
    if (!node) return;
    Object* obj = node->EvalWorldState(mStart).obj;

    if (obj && obj->ClassID() == Class_ID(LOD_CLASS_ID1, LOD_CLASS_ID2))
        mLodList = mLodList->AddNode(node);

    if (IsLight(node) && !IsEverAnimated(node)) {
        OutputTopLevelLight(node, (LightObject*) obj);
    }

    if (obj) {
        Class_ID id = obj->ClassID();
        if ((id == Class_ID(SIMPLE_CAM_CLASS_ID, 0) ||
             id == Class_ID(LOOKAT_CAM_CLASS_ID, 0)) && !IsEverAnimated(node))
            VrmlOutTopLevelCamera(1, node, FALSE);
    }

    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        TraverseNode(node->GetChildNode(i));
}

void
VRBLExport::ComputeWorldBoundBox(INode* node, ViewExp* vpt)
{
    if (!node) return;
    Object* obj = node->EvalWorldState(mStart).obj;
    Class_ID id;

    if (obj) {
        Box3 bb;
        obj->GetWorldBoundBox(mStart, node, vpt, bb);
        mBoundBox += bb;
    }

    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        ComputeWorldBoundBox(node->GetChildNode(i), vpt);
}

// Make a list of al the LOD objects in the scene.
void
VRBLExport::ScanSceneGraph()
{
//    ViewExp *vpt = mIp->GetViewport(NULL);
    INode* node = mIp->GetRootNode();
//    ComputeWorldBoundBox(node, vpt);
    TraverseNode(node);
}

// Return TRUE iff the node is referenced by the LOD node.
static BOOL
ObjectIsReferenced(INode* lodNode, INode* node)
{
    Object* obj = lodNode->GetObjectRef();
    int numRefs = obj->NumRefs();

    for(int i=0; i < numRefs; i++)
        if (node == (INode*) obj->GetReference(i))
            return TRUE;

    return FALSE;
}

// Return TRUE iff the node is referenced by ANY LOD node.
BOOL 
VRBLExport::ObjectIsLODRef(INode* node)
{
    INodeList* l = mLodList;

    for(; l; l = l->GetNext())
        if (ObjectIsReferenced(l->GetNode(), node))
            return TRUE;

    return FALSE;
}


// Dialog procedures

// Collect up a table with pointers to all the camera nodes in it
void
VRBLExport::GetCameras(INode *inode, Tab<INode*> *camList,
                       Tab<INode*> *navInfoList,
                       Tab<INode*> *backgrounds,
                       Tab<INode*> *fogs)
{
    const ObjectState& os = inode->EvalWorldState(mStart);
    Object* ob = os.obj;
    if (ob != NULL) {
        if (ob->SuperClassID() == CAMERA_CLASS_ID)
            camList->Append(1, &inode);

        if (ob->ClassID() == NavInfoClassID)
            navInfoList->Append(1, &inode);

        if (ob->ClassID() == BackgroundClassID)
            backgrounds->Append(1, &inode);

        if (ob->ClassID() == FogClassID)
            fogs->Append(1, &inode);
    }
    int count = inode->NumberOfChildren();
    for (int i = 0; i < count; i++)
        GetCameras(inode->GetChildNode( i), camList, navInfoList,
                   backgrounds, fogs);
}

// Get a chunk of app data off the sound object
void
GetAppData(Interface * ip, int id, TCHAR* def, TCHAR* val, int len)
{
    SoundObj *node = ip->GetSoundObject();
    AppDataChunk *ad = node->GetAppDataChunk(Class_ID(VRBL_EXPORT_CLASS_ID,0),
                                             SCENE_EXPORT_CLASS_ID, id);
    if (!ad)
        _tcscpy(val, def);
    else
        _tcscpy(val, (TCHAR*) ad->data);
}

// Write a chunk of app data on the sound object
void
WriteAppData(Interface* ip, int id, TCHAR* val)
{
    SoundObj *node = ip->GetSoundObject();
    node->RemoveAppDataChunk(Class_ID(VRBL_EXPORT_CLASS_ID,0),
                             SCENE_EXPORT_CLASS_ID, id);
    TCHAR* buf = (TCHAR*) malloc(_tcslen(val)+1);
    _tcscpy(buf, val);
    node->AddAppDataChunk(Class_ID(VRBL_EXPORT_CLASS_ID,0),
                          SCENE_EXPORT_CLASS_ID, id,
                          _tcslen(val)+1, buf);
    SetSaveRequiredFlag(TRUE);
}

extern HINSTANCE hInstance;

ISpinnerControl* VRBLExport::tformSpin = NULL;
ISpinnerControl* VRBLExport::coordSpin = NULL;
ISpinnerControl* VRBLExport::flipbookSpin = NULL;


static BOOL CALLBACK
SampleRatesDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    TCHAR text[MAX_PATH];
    VRBLExport *exp;
    if (msg == WM_INITDIALOG) {
        SetWindowLong(hDlg, GWL_USERDATA, lParam);
    }
    exp = (VRBLExport *)GetWindowLong(hDlg, GWL_USERDATA);
    switch (msg) {
    case WM_INITDIALOG: {
        CenterWindow(hDlg, GetParent(hDlg));
     // transform sample rate
        GetAppData(exp->mIp, TFORM_SAMPLE_ID, _T("custom"), text, MAX_PATH);
        BOOL once = _tcscmp(text, _T("once")) == 0;
        CheckDlgButton(hDlg, IDC_TFORM_ONCE, once);
        CheckDlgButton(hDlg, IDC_TFORM_CUSTOM, !once);
        EnableWindow(GetDlgItem(hDlg, IDC_TFORM_EDIT), !once);
        EnableWindow(GetDlgItem(hDlg, IDC_TFORM_SPIN), !once);
        
        GetAppData(exp->mIp, TFORM_SAMPLE_RATE_ID, _T("10"), text, MAX_PATH);
        int sampleRate = atoi(text);

        exp->tformSpin = GetISpinner(GetDlgItem(hDlg, IDC_TFORM_SPIN));
        exp->tformSpin->SetLimits(1, 100);
        exp->tformSpin->SetValue(sampleRate, FALSE);
        exp->tformSpin->SetAutoScale();
        exp->tformSpin->LinkToEdit(GetDlgItem(hDlg, IDC_TFORM_EDIT), EDITTYPE_INT);

     // coordinate interpolator sample rate
        GetAppData(exp->mIp, COORD_SAMPLE_ID, _T("custom"), text, MAX_PATH);
        once = _tcscmp(text, _T("once")) == 0;
        CheckDlgButton(hDlg, IDC_COORD_ONCE, once);
        CheckDlgButton(hDlg, IDC_COORD_CUSTOM, !once);
        EnableWindow(GetDlgItem(hDlg, IDC_COORD_EDIT), !once);
        EnableWindow(GetDlgItem(hDlg, IDC_COORD_SPIN), !once);
        
        GetAppData(exp->mIp, COORD_SAMPLE_RATE_ID, _T("3"), text, MAX_PATH);
        sampleRate = atoi(text);

        exp->coordSpin = GetISpinner(GetDlgItem(hDlg, IDC_COORD_SPIN));
        exp->coordSpin->SetLimits(1, 100);
        exp->coordSpin->SetValue(sampleRate, FALSE);
        exp->coordSpin->SetAutoScale();
        exp->coordSpin->LinkToEdit(GetDlgItem(hDlg, IDC_COORD_EDIT), EDITTYPE_INT);

     // flipbook sample rate
        GetAppData(exp->mIp, FLIPBOOK_SAMPLE_ID, _T("custom"), text, MAX_PATH);
        once = _tcscmp(text, _T("once")) == 0;
        CheckDlgButton(hDlg, IDC_FLIPBOOK_ONCE, once);
        CheckDlgButton(hDlg, IDC_FLIPBOOK_CUSTOM, !once);
        EnableWindow(GetDlgItem(hDlg, IDC_FLIPBOOK_EDIT), !once);
        EnableWindow(GetDlgItem(hDlg, IDC_FLIPBOOK_SPIN), !once);
        
        GetAppData(exp->mIp, FLIPBOOK_SAMPLE_RATE_ID, _T("10"), text, MAX_PATH);
        sampleRate = atoi(text);

        exp->flipbookSpin = GetISpinner(GetDlgItem(hDlg, IDC_FLIPBOOK_SPIN));
        exp->flipbookSpin->SetLimits(1, 100);
        exp->flipbookSpin->SetValue(sampleRate, FALSE);
        exp->flipbookSpin->SetAutoScale();
        exp->flipbookSpin->LinkToEdit(GetDlgItem(hDlg, IDC_FLIPBOOK_EDIT), EDITTYPE_INT);

        return TRUE;
    }
    case WM_DESTROY:
        ReleaseISpinner(exp->tformSpin);
        ReleaseISpinner(exp->coordSpin);
        ReleaseISpinner(exp->flipbookSpin);
        break;
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDC_TFORM_ONCE:
            exp->tformSpin->Disable();
            return TRUE;
        case IDC_TFORM_CUSTOM:
            exp->tformSpin->Enable();
            return TRUE;
        case IDC_COORD_ONCE:
            exp->coordSpin->Disable();
            return TRUE;
        case IDC_COORD_CUSTOM:
            exp->coordSpin->Enable();
            return TRUE;
        case IDC_FLIPBOOK_ONCE:
            exp->flipbookSpin->Disable();
            return TRUE;
        case IDC_FLIPBOOK_CUSTOM:
            exp->flipbookSpin->Enable();
            return TRUE;
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return TRUE;
            break;
        case IDOK: {
            BOOL once = IsDlgButtonChecked(hDlg, IDC_TFORM_ONCE);
            exp->SetTformSample(once);
            TCHAR* val = once ? _T("once") : _T("custom");
            WriteAppData(exp->mIp, TFORM_SAMPLE_ID, val);
            int rate = exp->tformSpin->GetIVal();
            exp->SetTformSampleRate(rate);
            sprintf(text, _T("%d"), rate);
            WriteAppData(exp->mIp, TFORM_SAMPLE_RATE_ID, text);

            once = IsDlgButtonChecked(hDlg, IDC_COORD_ONCE);
            exp->SetCoordSample(once);
            val = once ? _T("once") : _T("custom");
            WriteAppData(exp->mIp, COORD_SAMPLE_ID, val);
            rate = exp->coordSpin->GetIVal();
            exp->SetCoordSampleRate(rate);
            sprintf(text, _T("%d"), rate);
            WriteAppData(exp->mIp, COORD_SAMPLE_RATE_ID, text);
            
            once = IsDlgButtonChecked(hDlg, IDC_FLIPBOOK_ONCE);
            exp->SetFlipbookSample(once);
            val = once ? _T("once") : _T("custom");
            WriteAppData(exp->mIp, FLIPBOOK_SAMPLE_ID, val);
            rate = exp->flipbookSpin->GetIVal();
            exp->SetFlipbookSampleRate(rate);
            sprintf(text, _T("%d"), rate);
            WriteAppData(exp->mIp, FLIPBOOK_SAMPLE_RATE_ID, text);

            EndDialog(hDlg, TRUE);
            return TRUE;
        }
        }
    }
    return FALSE;
}

static BOOL CALLBACK
WorldInfoDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    TCHAR text[MAX_PATH];
    VRBLExport *exp;
    if (msg == WM_INITDIALOG) {
        SetWindowLong(hDlg, GWL_USERDATA, lParam);
    }
    exp = (VRBLExport *)GetWindowLong(hDlg, GWL_USERDATA);
    switch (msg) {
    case WM_INITDIALOG: {
        CenterWindow(hDlg, GetParent(hDlg));
        GetAppData(exp->mIp, TITLE_ID, _T(""), text, MAX_PATH);
        Edit_SetText(GetDlgItem(hDlg, IDC_TITLE), text);
        GetAppData(exp->mIp, INFO_ID, _T(""), text, MAX_PATH);
        Edit_SetText(GetDlgItem(hDlg, IDC_INFO), text);
        return TRUE;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            return TRUE;
        case IDOK:
            Edit_GetText(GetDlgItem(hDlg, IDC_TITLE), text, MAX_PATH);
            WriteAppData(exp->mIp, TITLE_ID, text);
            Edit_GetText(GetDlgItem(hDlg, IDC_INFO), text, MAX_PATH);
            WriteAppData(exp->mIp, INFO_ID, text);
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}

static BOOL CALLBACK
AboutDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    switch (msg) {
    case WM_INITDIALOG: {
        CenterWindow(hDlg, GetParent(hDlg));
        return TRUE;
    }
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDOK:
            EndDialog(hDlg, TRUE);
            return TRUE;
        }
    }
    return FALSE;
}

// Dialog procedure for the export dialog.
static BOOL CALLBACK
VrblExportDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam) 
{
    TCHAR text[MAX_PATH];
    VRBLExport *exp;
    ExportType type;
    if (msg == WM_INITDIALOG) {
        SetWindowLong(hDlg, GWL_USERDATA, lParam);
    }
    exp = (VRBLExport *)GetWindowLong(hDlg, GWL_USERDATA);
    switch (msg) {
    case WM_INITDIALOG: {
        SetWindowContextHelpId(hDlg, idh_vrmlexp_export);
        CenterWindow(hDlg, GetParent(hDlg));
        GetAppData(exp->mIp, NORMALS_ID, _T("no"), text, MAX_PATH);
        BOOL gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_GENNORMALS, gen);
        GetAppData(exp->mIp, INDENT_ID, _T("yes"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_INDENT, gen);
        GetAppData(exp->mIp, FIELDS_ID, _T("yes"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        //CheckDlgButton(hDlg, IDC_GEN_FIELDS, gen);
        GetAppData(exp->mIp, UPDIR_ID, _T("Y"), text, MAX_PATH);
        gen = _tcscmp(text, "Z") == 0;
        //CheckDlgButton(hDlg, IDC_Z_UP, gen);
        //CheckDlgButton(hDlg, IDC_Y_UP, !gen);
        GetAppData(exp->mIp, COORD_INTERP_ID, _T("no"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_COORD_INTERP, gen);
        GetAppData(exp->mIp, EXPORT_HIDDEN_ID, _T("no"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_EXPORT_HIDDEN, gen);
        GetAppData(exp->mIp, ENABLE_PROGRESS_BAR_ID, _T("yes"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_ENABLE_PROGRESS_BAR, gen);

        GetAppData(exp->mIp, PRIMITIVES_ID, _T("yes"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_PRIM, gen);

        GetAppData(exp->mIp, EXPORT_PRE_LIGHT_ID, _T("no"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_COLOR_PER_VERTEX, gen);
        EnableWindow(GetDlgItem(hDlg, IDC_CPV_CALC), gen);
        EnableWindow(GetDlgItem(hDlg, IDC_CPV_MAX),  gen);

        GetAppData(exp->mIp, CPV_SOURCE_ID, _T("max"), text, MAX_PATH);
        gen = _tcscmp(text, "max") == 0;
        CheckDlgButton(hDlg, IDC_CPV_MAX, gen);
        CheckDlgButton(hDlg, IDC_CPV_CALC, !gen);

#ifdef _LEC_
        GetAppData(exp->mIp, FLIP_BOOK_ID, _T("no"), text, MAX_PATH);
        gen = _tcscmp(text, "yes") == 0;
        CheckDlgButton(hDlg, IDC_FLIP_BOOK, gen);
#endif

        // Time to make a list of all the camera's in the scene
        Tab<INode*> cameras, navInfos, backgrounds, fogs;
        exp->GetCameras(exp->GetIP()->GetRootNode(), &cameras, &navInfos,
                        &backgrounds, &fogs);
        int c = cameras.Count();
        for (int i = 0; i < c; i++) {
            // add the name to the list
            TSTR name = cameras[i]->GetName();
            int ind = SendMessage(GetDlgItem(hDlg,IDC_CAMERA_COMBO),
                                  CB_ADDSTRING, 0, (LPARAM)name.data());
            SendMessage(GetDlgItem(hDlg,IDC_CAMERA_COMBO), CB_SETITEMDATA,
                        ind, (LPARAM)cameras[i]);
            
        }
        if (c > 0) {
            TSTR name;
            GetAppData(exp->mIp, CAMERA_ID, _T(""), text, MAX_PATH);
            if (_tcslen(text) == 0)
                name = cameras[0]->GetName();
            else
                name = text;
            // try to set the current selecttion to the current camera
            SendMessage(GetDlgItem(hDlg,IDC_CAMERA_COMBO), CB_SELECTSTRING,
                        0, (LPARAM)name.data());
        }

        c = navInfos.Count();
        for (i = 0; i < c; i++) {
            // add the name to the list
            TSTR name = navInfos[i]->GetName();
            int ind = SendMessage(GetDlgItem(hDlg,IDC_NAV_INFO_COMBO),
                                  CB_ADDSTRING, 0, (LPARAM)name.data());
            SendMessage(GetDlgItem(hDlg,IDC_NAV_INFO_COMBO), CB_SETITEMDATA,
                        ind, (LPARAM)navInfos[i]);
            
        }
        if (c > 0) {
            TSTR name;
            GetAppData(exp->mIp, NAV_INFO_ID, _T(""), text, MAX_PATH);
            if (_tcslen(text) == 0)
                name = navInfos[0]->GetName();
            else
                name = text;
            // try to set the current selecttion to the current camera
            SendMessage(GetDlgItem(hDlg,IDC_NAV_INFO_COMBO), CB_SELECTSTRING,
                        0, (LPARAM)name.data());
        }

        c = backgrounds.Count();
        for (i = 0; i < c; i++) {
            // add the name to the list
            TSTR name = backgrounds[i]->GetName();
            int ind = SendMessage(GetDlgItem(hDlg,IDC_BACKGROUND_COMBO),
                                  CB_ADDSTRING, 0, (LPARAM)name.data());
            SendMessage(GetDlgItem(hDlg,IDC_BACKGROUND_COMBO), CB_SETITEMDATA,
                        ind, (LPARAM)backgrounds[i]);
            
        }
        if (c > 0) {
            TSTR name;
            GetAppData(exp->mIp, BACKGROUND_ID, _T(""), text, MAX_PATH);
            if (_tcslen(text) == 0)
                name = backgrounds[0]->GetName();
            else
                name = text;
            // try to set the current selecttion to the current camera
            SendMessage(GetDlgItem(hDlg,IDC_BACKGROUND_COMBO),
                        CB_SELECTSTRING, 0, (LPARAM)name.data());
        }

        c = fogs.Count();
        for (i = 0; i < c; i++) {
            // add the name to the list
            TSTR name = fogs[i]->GetName();
            int ind = SendMessage(GetDlgItem(hDlg,IDC_FOG_COMBO),
                                  CB_ADDSTRING, 0, (LPARAM)name.data());
            SendMessage(GetDlgItem(hDlg,IDC_FOG_COMBO), CB_SETITEMDATA,
                        ind, (LPARAM)fogs[i]);
            
        }
        if (c > 0) {
            TSTR name;
            GetAppData(exp->mIp, FOG_ID, _T(""), text, MAX_PATH);
            if (_tcslen(text) == 0)
                name = fogs[0]->GetName();
            else
                name = text;
            // try to set the current selecttion to the current camera
            SendMessage(GetDlgItem(hDlg,IDC_FOG_COMBO),
                        CB_SELECTSTRING, 0, (LPARAM)name.data());
        }

        GetAppData(exp->mIp, OUTPUT_LANG_ID, _T("VRML97"), text, MAX_PATH);
        type = Export_VRML_2_0;

#ifdef _LEC_
        EnableWindow(GetDlgItem(hDlg, IDC_FLIP_BOOK),   TRUE);
#else
        EnableWindow(GetDlgItem(hDlg, IDC_FLIP_BOOK),   FALSE);
#endif
        //ComboBox_SelectString(cb, 0, text);
        GetAppData(exp->mIp, USE_PREFIX_ID, _T("yes"), text, MAX_PATH);
        CheckDlgButton(hDlg, IDC_USE_PREFIX, _tcscmp(text, _T("yes")) == 0);
        GetAppData(exp->mIp, URL_PREFIX_ID, _T("../maps"), text, MAX_PATH);
        Edit_SetText(GetDlgItem(hDlg, IDC_URL_PREFIX), text);
        HWND cb = GetDlgItem(hDlg,IDC_DIGITS);
        ComboBox_AddString(cb, _T("3"));
        ComboBox_AddString(cb, _T("4"));
        ComboBox_AddString(cb, _T("5"));
        ComboBox_AddString(cb, _T("6"));
        GetAppData(exp->mIp, DIGITS_ID, _T("4"), text, MAX_PATH);
        ComboBox_SelectString(cb, 0, text);

        cb = GetDlgItem(hDlg, IDC_POLYGON_TYPE);
        ComboBox_AddString(cb, _T(GetString(IDS_OUT_TRIANGLES)));
#if TRUE   // outputing higher order polygons
        ComboBox_AddString(cb, _T(GetString(IDS_OUT_QUADS)));
        ComboBox_AddString(cb, _T(GetString(IDS_OUT_NGONS)));
        ComboBox_AddString(cb, _T(GetString(IDS_OUT_VIS_EDGES)));
#endif
        GetAppData(exp->mIp, POLYGON_TYPE_ID, _T(GetString(IDS_OUT_TRIANGLES)), text, MAX_PATH);
        ComboBox_SelectString(cb, 0, text);

     // make sure the appropriate things are enabled
        /* this is not always appropriate
        BOOL checked = IsDlgButtonChecked(hDlg, IDC_PRIM);
        EnableWindow(GetDlgItem(hDlg, IDC_COLOR_PER_VERTEX), !checked);
        if (checked) CheckDlgButton(hDlg, IDC_COLOR_PER_VERTEX, FALSE);
        BOOL cpvChecked = IsDlgButtonChecked(hDlg, IDC_COLOR_PER_VERTEX);
        EnableWindow(GetDlgItem(hDlg, IDC_CPV_CALC), cpvChecked);
        EnableWindow(GetDlgItem(hDlg, IDC_CPV_MAX),  cpvChecked);
        EnableWindow(GetDlgItem(hDlg, IDC_GENNORMALS), !checked);
        if (checked) CheckDlgButton(hDlg, IDC_GENNORMALS, FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_COORD_INTERP), !checked);
        if (checked) CheckDlgButton(hDlg, IDC_COORD_INTERP, FALSE);
        */

        return TRUE; }
    case WM_COMMAND:
        switch(LOWORD(wParam)) {
        case IDC_EXP_HELP: {
            TCHAR* helpDir = exp->mIp->GetDir(APP_HELP_DIR);
            TCHAR helpFile[MAX_PATH];
            _tcscpy(helpFile, helpDir);
            _tcscat(helpFile, _T("\\vrmlout.hlp"));
            WinHelp(hDlg, helpFile, HELP_CONTENTS, NULL);
            break; }
            /*
        case IDC_PRIM: {
            BOOL checked = IsDlgButtonChecked(hDlg, IDC_PRIM);

            EnableWindow(GetDlgItem(hDlg, IDC_COLOR_PER_VERTEX), !checked);
            if (checked) CheckDlgButton(hDlg, IDC_COLOR_PER_VERTEX, FALSE);
            BOOL cpvChecked = IsDlgButtonChecked(hDlg, IDC_COLOR_PER_VERTEX);
            EnableWindow(GetDlgItem(hDlg, IDC_CPV_CALC), cpvChecked);
            EnableWindow(GetDlgItem(hDlg, IDC_CPV_MAX),  cpvChecked);

            EnableWindow(GetDlgItem(hDlg, IDC_GENNORMALS), !checked);
            if (checked) CheckDlgButton(hDlg, IDC_GENNORMALS, FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_COORD_INTERP), !checked);
            if (checked) CheckDlgButton(hDlg, IDC_COORD_INTERP, FALSE);

            break;
            }
            */
        case IDC_COLOR_PER_VERTEX: {
            BOOL checked = IsDlgButtonChecked(hDlg, IDC_COLOR_PER_VERTEX);
            EnableWindow(GetDlgItem(hDlg, IDC_CPV_CALC), checked);
            EnableWindow(GetDlgItem(hDlg, IDC_CPV_MAX),  checked);
            break;
            }
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;
        case IDOK: {
            exp->SetGenNormals(IsDlgButtonChecked(hDlg, IDC_GENNORMALS));
            WriteAppData(exp->mIp, NORMALS_ID, exp->GetGenNormals() ?
                         _T("yes"): _T("no"));
            
            exp->SetIndent(IsDlgButtonChecked(hDlg, IDC_INDENT));
            WriteAppData(exp->mIp, INDENT_ID, exp->GetIndent() ? _T("yes"):
                         _T("no"));
#if 0            
            exp->SetZUp(IsDlgButtonChecked(hDlg, IDC_Z_UP));
#else
            exp->SetZUp(FALSE);
#endif
            WriteAppData(exp->mIp, UPDIR_ID, exp->GetZUp() ? _T("Z"):
                         _T("Y"));

            exp->SetCoordInterp(IsDlgButtonChecked(hDlg, IDC_COORD_INTERP));
            WriteAppData(exp->mIp, COORD_INTERP_ID, exp->GetCoordInterp() ?
                         _T("yes"): _T("no"));
#ifdef _LEC_
            exp->SetFlipBook(IsDlgButtonChecked(hDlg, IDC_FLIP_BOOK));
            WriteAppData(exp->mIp, FLIP_BOOK_ID, exp->GetFlipBook() ? _T("yes"): _T("no"));
#endif

            exp->SetExportHidden(IsDlgButtonChecked(hDlg, IDC_EXPORT_HIDDEN));
            WriteAppData(exp->mIp, EXPORT_HIDDEN_ID, exp->GetExportHidden() ?
                         _T("yes"): _T("no"));

            exp->SetEnableProgressBar(IsDlgButtonChecked(hDlg, IDC_ENABLE_PROGRESS_BAR));
            WriteAppData(exp->mIp, ENABLE_PROGRESS_BAR_ID, exp->GetEnableProgressBar() ?
                         _T("yes"): _T("no"));

            exp->SetPrimitives(IsDlgButtonChecked(hDlg, IDC_PRIM));
            WriteAppData(exp->mIp, PRIMITIVES_ID, exp->GetPrimitives() ?
                         _T("yes"): _T("no"));

            int index = SendMessage(GetDlgItem(hDlg,IDC_CAMERA_COMBO),
                                    CB_GETCURSEL, 0, 0);
            if (index != CB_ERR) {
                exp->SetCamera((INode *)
                               SendMessage(GetDlgItem(hDlg, IDC_CAMERA_COMBO),
                                           CB_GETITEMDATA, (WPARAM)index,
                                           0));
                ComboBox_GetText(GetDlgItem(hDlg, IDC_CAMERA_COMBO),
                                 text, MAX_PATH);
                WriteAppData(exp->mIp, CAMERA_ID, text);
            } else
                exp->SetCamera(NULL);

            index = SendMessage(GetDlgItem(hDlg,IDC_NAV_INFO_COMBO),
                                CB_GETCURSEL, 0, 0);
            if (index != CB_ERR) {
                exp->SetNavInfo((INode *)
                      SendMessage(GetDlgItem(hDlg, IDC_NAV_INFO_COMBO),
                                  CB_GETITEMDATA, (WPARAM)index,
                                  0));
                ComboBox_GetText(GetDlgItem(hDlg, IDC_NAV_INFO_COMBO),
                                 text, MAX_PATH);
                WriteAppData(exp->mIp, NAV_INFO_ID, text);
            } else
                exp->SetNavInfo(NULL);

            index = SendMessage(GetDlgItem(hDlg,IDC_BACKGROUND_COMBO),
                                CB_GETCURSEL, 0, 0);
            if (index != CB_ERR) {
                exp->SetBackground((INode *)
                      SendMessage(GetDlgItem(hDlg, IDC_BACKGROUND_COMBO),
                                  CB_GETITEMDATA, (WPARAM)index,
                                  0));
                ComboBox_GetText(GetDlgItem(hDlg, IDC_BACKGROUND_COMBO),
                                 text, MAX_PATH);
                WriteAppData(exp->mIp, BACKGROUND_ID, text);
            } else
                exp->SetBackground(NULL);

            index = SendMessage(GetDlgItem(hDlg,IDC_FOG_COMBO),
                                CB_GETCURSEL, 0, 0);
            if (index != CB_ERR) {
                exp->SetFog((INode *)
                      SendMessage(GetDlgItem(hDlg, IDC_FOG_COMBO),
                                  CB_GETITEMDATA, (WPARAM)index,
                                  0));
                ComboBox_GetText(GetDlgItem(hDlg, IDC_FOG_COMBO),
                                 text, MAX_PATH);
                WriteAppData(exp->mIp, FOG_ID, text);
            } else
                exp->SetFog(NULL);

            WriteAppData(exp->mIp, OUTPUT_LANG_ID, "VRML97");
            exp->SetExportType(Export_VRML_2_0);

            ComboBox_GetText(GetDlgItem(hDlg, IDC_POLYGON_TYPE), text, MAX_PATH);
            WriteAppData(exp->mIp, POLYGON_TYPE_ID, text);
            if (_tcscmp(text, _T("Visible Edges")) == 0)
                exp->SetPolygonType(OUTPUT_VISIBLE_EDGES);
            else if (_tcscmp(text, _T("Ngons")) == 0)
                exp->SetPolygonType(OUTPUT_NGONS);
            else if (_tcscmp(text, _T("Quads")) == 0)
                exp->SetPolygonType(OUTPUT_QUADS);
            else
                exp->SetPolygonType(OUTPUT_TRIANGLES);

            exp->SetPreLight(IsDlgButtonChecked(hDlg, IDC_COLOR_PER_VERTEX));
            WriteAppData(exp->mIp, EXPORT_PRE_LIGHT_ID, exp->GetPreLight() ?
                         _T("yes"): _T("no"));

            exp->SetCPVSource(IsDlgButtonChecked(hDlg, IDC_CPV_MAX));
            WriteAppData(exp->mIp, CPV_SOURCE_ID, exp->GetCPVSource() ?
                         _T("max"): _T("calc"));

            exp->SetUsePrefix(IsDlgButtonChecked(hDlg, IDC_USE_PREFIX));
            WriteAppData(exp->mIp, USE_PREFIX_ID, exp->GetUsePrefix()
                         ? _T("yes") : _T("no"));
            Edit_GetText(GetDlgItem(hDlg, IDC_URL_PREFIX), text, MAX_PATH);
            TSTR prefix = text;
            exp->SetUrlPrefix(prefix);
            WriteAppData(exp->mIp, URL_PREFIX_ID, exp->GetUrlPrefix());
            ComboBox_GetText(GetDlgItem(hDlg, IDC_DIGITS), text, MAX_PATH);
            exp->SetDigits(atoi(text));
            WriteAppData(exp->mIp, DIGITS_ID, text);

            GetAppData(exp->mIp, TFORM_SAMPLE_ID, _T("custom"), text,
                       MAX_PATH);
            BOOL once = _tcscmp(text, _T("once")) == 0;
            exp->SetTformSample(once);
            GetAppData(exp->mIp, TFORM_SAMPLE_RATE_ID, _T("10"), text,
                       MAX_PATH);
            int sampleRate = atoi(text);
            exp->SetTformSampleRate(sampleRate);

            GetAppData(exp->mIp, COORD_SAMPLE_ID, _T("custom"), text,
                       MAX_PATH);
            once = _tcscmp(text, _T("once")) == 0;
            exp->SetCoordSample(once);
            GetAppData(exp->mIp, COORD_SAMPLE_RATE_ID, _T("3"), text,
                       MAX_PATH);
            sampleRate = atoi(text);
            exp->SetCoordSampleRate(sampleRate);

            GetAppData(exp->mIp, FLIPBOOK_SAMPLE_ID, _T("custom"), text,
                       MAX_PATH);
            once = _tcscmp(text, _T("once")) == 0;
            exp->SetFlipbookSample(once);
            GetAppData(exp->mIp, FLIPBOOK_SAMPLE_RATE_ID, _T("10"), text,
                       MAX_PATH);
            sampleRate = atoi(text);
            exp->SetFlipbookSampleRate(sampleRate);

            GetAppData(exp->mIp, TITLE_ID, _T(""), text, MAX_PATH);
            exp->SetTitle(text);
            GetAppData(exp->mIp, INFO_ID, _T(""), text, MAX_PATH);
            exp->SetInfo(text);
            EndDialog(hDlg, TRUE);
            break; }
        case IDC_SAMPLE_RATES:
            DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_SAMPLE_RATES), 
                           GetActiveWindow(), SampleRatesDlgProc,
                           (LPARAM) exp);
            break;
        case IDC_WORLD_INFO:
            DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_WORLD_INFO), 
                           GetActiveWindow(), WorldInfoDlgProc,
                           (LPARAM) exp);
            break;
        }
        break;
    case WM_SYSCOMMAND:
        if ((wParam & 0xfff0) == SC_CONTEXTHELP)
            Help(HELP_CONTEXT, idh_3dsexp_export);
        break;
    }
    return FALSE;
}

// Export the current scene as VRML
int
VRBLExport::DoExport(const TCHAR *filename, ExpInterface *ei, Interface *i, BOOL suppressPrompts, DWORD options) 
{
    mIp = i;
    mStart = mIp->GetAnimRange().Start();
    
    if (suppressPrompts)
        initializeDefaults();
    else if (!DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_VRBLEXP), 
                        GetActiveWindow(), VrblExportDlgProc,
                        (LPARAM) this))
        return TRUE;
	
    if (IsVRML2()) {
     // generate the callback table of third party dlls
        mCallbacks.GetCallbackMethods(i);

#ifdef _LEC_
        if (this->GetFlipBook()) {
            int sampleRate;
            int end;
            int lastFrame;
            int numFrames;
            int extLoc;

            if (this->GetFlipbookSample())
                sampleRate = GetTicksPerFrame();
            else
                sampleRate = TIME_TICKSPERSEC / this->GetFlipbookSampleRate();

            mStart      = i->GetAnimRange().Start();
            lastFrame   = end = i->GetAnimRange().End();
            numFrames   = (end - mStart) / sampleRate + 1;

            if (((end - mStart) % sampleRate) != 0) {
                end += sampleRate;
                numFrames++;
            }

            CStr rfName(filename);
            extLoc = rfName.last('.');
            if (extLoc != -1)
                rfName.remove(extLoc);
            rfName.Append(".txt");
            FILE* fio = _tfopen(rfName.data(), "w");
            fprintf(fio, "%s\n", filename);
            fprintf(fio, "Start Time (sec.):\t%d.0\n", mStart/TIME_TICKSPERSEC);
            fprintf(fio, "End Time (sec.):\t%d.0\n", end/TIME_TICKSPERSEC);
            fprintf(fio, "Number of Frames:\t%d\n", numFrames);
            if (fio) {
                fclose(fio);
                fio = NULL;
            }

            for (int frame = 0; frame < numFrames; frame++, mStart += sampleRate) {
                if (mStart > lastFrame)
                    break;
                VRML2Export vrml2;
                int val = vrml2.DoFBExport(filename, i, this, frame, mStart);
                if (!val) return val;
            }
            return TRUE;
        }
#endif
        VRML2Export vrml2;
        int val = vrml2.DoExport(filename, i, this);
        return val;
    }

    return 1;	
}

void
VRBLExport::initializeDefaults() {
    TCHAR text[MAX_PATH];

    GetAppData(mIp, NORMALS_ID, _T("no"), text, MAX_PATH);
    BOOL gen = _tcscmp(text, "yes") == 0;
    SetGenNormals(gen);
    GetAppData(mIp, INDENT_ID, _T("yes"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetIndent(gen);
    SetZUp(FALSE);
    GetAppData(mIp, COORD_INTERP_ID, _T("no"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetCoordInterp(gen);
    GetAppData(mIp, EXPORT_HIDDEN_ID, _T("no"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetExportHidden(gen);
    GetAppData(mIp, ENABLE_PROGRESS_BAR_ID, _T("yes"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetEnableProgressBar(gen);

    GetAppData(mIp, PRIMITIVES_ID, _T("yes"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetPrimitives(gen);

    GetAppData(mIp, EXPORT_PRE_LIGHT_ID, _T("no"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetPreLight(gen);
    GetAppData(mIp, CPV_SOURCE_ID, _T("max"), text, MAX_PATH);
    gen = _tcscmp(text, "max") == 0;
    SetCPVSource(gen);

#ifdef _LEC_
    GetAppData(mIp, FLIP_BOOK_ID, _T("no"), text, MAX_PATH);
    gen = _tcscmp(text, "yes") == 0;
    SetFlipBook(gen);
#endif
    GetAppData(mIp, USE_PREFIX_ID, _T("yes"), text, MAX_PATH);
    SetUsePrefix(_tcscmp(text, _T("yes")) == 0);
    GetAppData(mIp, URL_PREFIX_ID, _T("../maps"), text, MAX_PATH);
    TSTR prefix = text;
    SetUrlPrefix(prefix);
    GetAppData(mIp, DIGITS_ID, _T("4"), text, MAX_PATH);
    SetDigits(atoi(text));

    GetAppData(mIp, POLYGON_TYPE_ID, _T("Triangles"), text, MAX_PATH);
    if (_tcscmp(text, _T("Visible Edges")) == 0)
        SetPolygonType(OUTPUT_VISIBLE_EDGES);
    else if (_tcscmp(text, _T("Ngons")) == 0)
        SetPolygonType(OUTPUT_NGONS);
    else if (_tcscmp(text, _T("Quads")) == 0)
        SetPolygonType(OUTPUT_QUADS);
    else
        SetPolygonType(OUTPUT_TRIANGLES);

    Tab<INode*> cameras, navInfos, backgrounds, fogs;
    GetCameras(GetIP()->GetRootNode(), &cameras, &navInfos,
                    &backgrounds, &fogs);
    int c = cameras.Count();
    int ci;
    INode *inode = NULL;
    if (c > 0) {
        TSTR name;
        GetAppData(mIp, CAMERA_ID, _T(""), text, MAX_PATH);
        if (_tcslen(text) == 0)
            inode = cameras[0];
        else {
            name = text;
            for (ci = 0; ci < c; ci++)
                if (_tcscmp(cameras[ci]->GetName(), name) == 0) {
                    inode = cameras[ci];
                    break;
                }
        }
    }
    SetCamera(inode);

    c = navInfos.Count();
    inode = NULL;
    if (c > 0) {
        TSTR name;
        GetAppData(mIp, NAV_INFO_ID, _T(""), text, MAX_PATH);
        if (_tcslen(text) == 0)
            inode = navInfos[0];
        else {
            name = text;
            for (ci = 0; ci < c; ci++)
                if (_tcscmp(navInfos[ci]->GetName(), name) == 0) {
                    inode = navInfos[ci];
                    break;
                }
        }
    }
    SetNavInfo(inode);

    c = backgrounds.Count();
    inode = NULL;
    if (c > 0) {
        TSTR name;
        GetAppData(mIp, BACKGROUND_ID, _T(""), text, MAX_PATH);
        if (_tcslen(text) == 0)
            inode = backgrounds[0];
        else {
            name = text;
            for (ci = 0; ci < c; ci++)
                if (_tcscmp(backgrounds[ci]->GetName(), name) == 0) {
                    inode = backgrounds[ci];
                    break;
                }
        }
    }
    SetBackground(inode);

    c = fogs.Count();
    inode = NULL;
    if (c > 0) {
        TSTR name;
        GetAppData(mIp, FOG_ID, _T(""), text, MAX_PATH);
        if (_tcslen(text) == 0)
            inode = fogs[0];
        else {
            name = text;
            for (ci = 0; ci < c; ci++)
                if (_tcscmp(fogs[ci]->GetName(), name) == 0) {
                    inode = fogs[ci];
                    break;
                }
        }
    }
    SetFog(inode);

    GetAppData(mIp, TFORM_SAMPLE_ID, _T("custom"), text, MAX_PATH);
    BOOL once = _tcscmp(text, _T("once")) == 0;
    SetTformSample(once);
    GetAppData(mIp, TFORM_SAMPLE_RATE_ID, _T("10"), text, MAX_PATH);
    SetTformSampleRate(atoi(text));

    GetAppData(mIp, COORD_SAMPLE_ID, _T("custom"), text, MAX_PATH);
    once = _tcscmp(text, _T("once")) == 0;
    SetCoordSample(once);
    GetAppData(mIp, COORD_SAMPLE_RATE_ID, _T("3"), text, MAX_PATH);
    SetCoordSampleRate(atoi(text));

    GetAppData(mIp, FLIPBOOK_SAMPLE_ID, _T("custom"), text, MAX_PATH);
    once = _tcscmp(text, _T("once")) == 0;
    SetFlipbookSample(once);        
    GetAppData(mIp, FLIPBOOK_SAMPLE_RATE_ID, _T("10"), text, MAX_PATH);
    SetFlipbookSampleRate(atoi(text));

    GetAppData(mIp, TITLE_ID, _T(""), text, MAX_PATH);
    SetTitle(text);
    GetAppData(mIp, INFO_ID, _T(""), text, MAX_PATH);
    SetInfo(text);

    SetExportType(Export_VRML_2_0);
}


VRBLExport::VRBLExport() 
{
    mGenNormals         = FALSE;
    mHadAnim            = FALSE;
    mLodList            = NULL;
    mTformSample        = FALSE;
    mTformSampleRate    = 10;
    mCoordSample        = FALSE;
    mCoordSampleRate    = 3;
    mFlipbookSample     = FALSE;
    mFlipbookSampleRate = 10;
}

VRBLExport::~VRBLExport() {
}

// Number of file extensions supported by the exporter
int
VRBLExport::ExtCount() {
    return 1;
}

// The exension supported
const TCHAR *
VRBLExport::Ext(int n) {
    switch(n) {
    case 0:
        return _T("WRL");
    }
    return _T("");
}

const TCHAR *
VRBLExport::LongDesc() {
    return _T("Autodesk VRBL");
}
	
const TCHAR *
VRBLExport::ShortDesc() {
    return _T("VRML97");
}

const TCHAR *
VRBLExport::AuthorName() {
    return _T("greg finch");
}

const TCHAR *
VRBLExport::CopyrightMessage() {
    return _T("Copyright 1997, Autodesk, Inc.");
}

const TCHAR *
VRBLExport::OtherMessage1() {
    return _T("");
}

const TCHAR *
VRBLExport::OtherMessage2() {
    return _T("");
}

unsigned int
VRBLExport::Version() {
    return 100;
}

void
VRBLExport::ShowAbout(HWND hWnd) {
}

static DWORD HashNode(DWORD o, int size)
{
    DWORD code = (DWORD) o;
    return (code >> 2) % size;
}

// form the hash value for string s
static unsigned HashName(TCHAR* s, int size)
{
	unsigned hashVal;
	for (hashVal = 0; *s; s++)
		hashVal = *s + 31 * hashVal;
    return hashVal % size;
}

// Node Hash table lookup
NodeList* NodeTable::AddNode(INode* node)
{
    DWORD hash = HashNode((DWORD) node, NODE_HASH_TABLE_SIZE);
    NodeList* nList;
    
    for(nList = mTable[hash]; nList; nList = nList->next) {
        if (nList->node == node) {
            return nList;
        }
    }
    nList = new NodeList(node);
    nList->next = mTable[hash];
    mTable[hash] = nList;
    return nList;
}

// Node Name lookup
TCHAR* NodeTable::GetNodeName(INode* node)
{
    DWORD hash = HashNode((DWORD) node, NODE_HASH_TABLE_SIZE);
    NodeList* nList;
    
    for(nList = mTable[hash]; nList; nList = nList->next) {
        if (nList->node == node) {
            if (nList->hasName) return nList->name;
			else return NULL;	// if it wasn't created
        }
    }
    return NULL;	// if for some unknown reason we dont find it
}

// Node unique name list lookup
TCHAR* NodeTable::AddName(TCHAR* name)
{
	unsigned  hashVal = HashName(name, NODE_HASH_TABLE_SIZE);
	NameList* nList;
	TCHAR     buf[256];
	TCHAR*    matchStr;
	int		  matchVal;

	for (nList = mNames[hashVal]; nList; nList = nList->next) {
		if (nList->name && !strcmp(name, nList->name)) { // found a match
		 // checkout name for "_0xxx" that is our tag
			matchStr = strrchr(name, '_');
			if (matchStr) {		// possible additional duplicate names
				if (matchStr[1] == '0') {		// assume additional duplicate names
					matchVal = atoi(matchStr + 1);	// get number
					strncpy(buf, name, strlen(name) - strlen(matchStr)); // first part
					buf[strlen(name) - strlen(matchStr)] = '\0';	// terminate
					//sprintf(newName.name, "%s_0%d", buf, matchVal+1);	// add one
                    TSTR newName(buf);
                    sprintf(buf, "_0%d", matchVal+1);   // add one
                    newName.Append(TSTR(buf));
					return AddName(newName.data()); // check for unique new name
				}
			}
			//sprintf(newName.name, "%s_0", name);	// first duplicate name
            TSTR newName(name);
            newName.Append(TSTR("_0"));
			return AddName(newName.data()); // check for unique new name
		}
	}
	nList = new NameList(name);
	nList->next = mNames[hashVal];
	mNames[hashVal] = nList;
	return nList->name;
}

// Traverse the scene graph generating Unique Node Names
void 
VRBLExport::GenerateUniqueNodeNames(INode* node)
{
	if (!node) return;

	NodeList* nList = mNodes.AddNode(node);
	if (!nList->hasName) {
	 // take mangled name and get a unique name
		nList->name    = mNodes.AddName(VRMLName(node->GetName()));
		nList->hasName = TRUE;
	}
    
    int n = node->NumberOfChildren();
    for(int i = 0; i < n; i++)
        GenerateUniqueNodeNames(node->GetChildNode(i));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Wavectrl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wavectrl.rc
//
#define IDD_WAVEPARAMS                  101
#define IDB_WAVE_BUTTONS                102
#define IDB_WAVE_MASKBUTTONS            103
#define IDD_ABOUT                       103
#define IDD_WAVEPARAMS2                 104
#define IDD_ABOUT2                      105
#define IDC_ABOUT                       1000
#define IDC_WAVELIST                    1001
#define IDC_APPEND                      1002
#define IDC_CENTERED                    1003
#define IDC_POSITIVE                    1004
#define IDC_NEGATIVE                    1005
#define IDC_MANUAL                      1006
#define IDC_REMOVE                      1007
#define IDC_MOVEUP                      1008
#define IDC_MOVEDOWN                    1009
#define IDC_WAVENAME                    1010
#define IDC_ADDFUNC                     1012
#define IDC_MULT                        1013
#define IDC_INSERT                      1014
#define IDC_THIS                        1015
#define IDC_THISOUT                     1016
#define IDC_FINALOUT                    1017
#define IDC_DISABLE                     1018
#define IDC_CLAMPABOVE                  1019
#define IDC_CLAMPBELOW                  1020
#define IDC_HIVALUE                     1021
#define IDC_LOVALUE                     1022
#define IDC_WAVE_AMPLITUDE              1153
#define IDC_WAVE_AMPLITUDESPIN          1154
#define IDC_WAVE_PERIOD                 1157
#define IDC_WAVE_PERIODSPIN             1158
#define IDC_WAVE_DUTY                   1159
#define IDC_WAVE_DUTYSPIN               1160
#define IDC_WAVE_PHASE                  1161
#define IDC_WAVE_PHASESPIN              1162
#define IDC_WAVE_BIAS                   1163
#define IDC_WAVE_BIASSPIN               1164
#define IDC_LOCOLOR                     1166
#define IDC_INVERTED                    1213
#define IDC_FLIPPED                     1214
#define IDC_WAVE_GRAPH                  1215
#define IDC_SINE                        1216
#define IDC_SQUARE                      1217
#define IDC_TRIANGLE                    1218
#define IDC_SAWTOOTH                    1219
#define IDC_HALFSINE                    1220
#define IDS_TH_SIMPWAVEFLOAT            30538
#define IDS_TH_COMPWAVEFLOAT            30539
#define IDS_TH_WAVEFLOAT                30539
#define IDS_TH_SIMPWAVECONTROLTITLE     30655
#define IDS_TH_SINE                     30656
#define IDS_TH_SQUARE                   30657
#define IDS_TH_TRIANGLE                 30658
#define IDS_TH_SAWTOOTH                 30659
#define IDS_TH_HALFSINE                 30660
#define IDS_TH_COMPWAVECONTROLTITLE     30661
#define IDS_TH_WAVECONTROLTITLE         30661
#define IDS_TH_LIBDESCRIPTION           30662

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Wavectrl\wavectrl.h ===
/**********************************************************************
 *<
	FILE: wavectrl.h

	DESCRIPTION:

	CREATED BY: Tom Hudson

	HISTORY:

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __WAVECTRL__H
#define __WAVECTRL__H

#include "Max.h"
#include "resource.h"

extern ClassDesc* GetFloatWaveDesc();

TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Wavectrl\wavectrl.cpp ===
/**********************************************************************
 *<
	FILE: wavectrl.cpp

	DESCRIPTION:   Generic waveform controller

	CREATED BY: Tom Hudson

	HISTORY: created 25 Sept. 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#include "wavectrl.h"

HINSTANCE hInstance;
int controlsInit = FALSE;

/** public functions **/
BOOL WINAPI DllMain(HINSTANCE hinstDLL,ULONG fdwReason,LPVOID lpvReserved) {
	hInstance = hinstDLL;

 	if ( !controlsInit ) {
		controlsInit = TRUE;
		
		// jaguar controls
		InitCustomControls(hInstance);

#ifdef OLD3DCONTROLS
		// initialize 3D controls
		Ctl3dRegister(hinstDLL);
		Ctl3dAutoSubclass(hinstDLL);
#endif
		
		// initialize Chicago controls
		InitCommonControls();
		}

	switch(fdwReason) {
		case DLL_PROCESS_ATTACH:
			break;
		case DLL_THREAD_ATTACH:
			break;
		case DLL_THREAD_DETACH:
			break;
		case DLL_PROCESS_DETACH:
			break;
		}
	return(TRUE);
	}


//------------------------------------------------------
// This is the interface to Jaguar:
//------------------------------------------------------

__declspec( dllexport ) const TCHAR *
LibDescription() { return GetString(IDS_TH_LIBDESCRIPTION); }

/// MUST CHANGE THIS NUMBER WHEN ADD NEW CLASS
__declspec( dllexport ) int LibNumberClasses() { return 1; }

__declspec( dllexport ) ClassDesc*
LibClassDesc(int i) {
	switch(i) {
		case 0: return GetFloatWaveDesc();
		default: return 0;
		}
	}


// Return version so can detect obsolete DLLs
__declspec( dllexport ) ULONG 
LibVersion() { return VERSION_3DSMAX; }

TCHAR *GetString(int id)
{
	static TCHAR buf[256];

	if(hInstance)
		return LoadString(hInstance, id, buf, sizeof(buf)) ? buf : NULL;
	return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Wavectrl\simpwave.cpp ===
/**********************************************************************
 *<
	FILE: simpwave.cpp

	DESCRIPTION: A simple waveform controller

	CREATED BY: Tom Hudson

	HISTORY: created 25 Sept. 1996

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/
#include "wavectrl.h"
#include "units.h"

#define FLOATWAVE_CONTROL_CNAME	GetString(IDS_TH_WAVEFLOAT)
#define FLOATWAVE_CONTROL_CLASS_ID	0x930Abc78

#define TYPE_SQUARE 0
#define TYPE_SINE 1
#define TYPE_SAWTOOTH 2
#define TYPE_TRIANGLE 3
#define TYPE_HALFSINE 4

#define BIAS_CENTERED 0
#define BIAS_POSITIVE 1
#define BIAS_NEGATIVE 2
#define BIAS_MANUAL 3

#define EFFECT_ADD 0
#define EFFECT_MULTIPLY 1
#define EFFECT_CLAMP_ABOVE 2
#define EFFECT_CLAMP_BELOW 3

#define DISP_THIS 0		// Display this curve only
#define DISP_THISOUT 1	// Display output from this wave w/previous
#define DISP_FINALOUT 2	// Display final output of all waves combined

// Optional index parameters for GetValue
#define GETVAL_ALL -1

class BaseWaveControl : public StdControl {
	public:
		int waves;		// Number of waveforms making us up
		int index;		// Index of currently-displayed waveform
		TSTR *name;
		float *period;
		float *duty;	// Square waves only
		float *amplitude;
		float *phase;
		float *bias;
		int *type;
		int *biasType;
		int *effect;
		BOOL *inverted;
		BOOL *flipped;
		BOOL *enabled;
		int display;
		Interval range;

		BaseWaveControl();
		BaseWaveControl& operator=(const BaseWaveControl& from);
		float WaveAtTime(TimeValue t,int ix);	// -1 = all
		float GetValue(float where, int ix);	// -1 = all

		virtual int Elems()=0;

		// Animatable methods		
		void DeleteThis() {delete this;}		
		int IsKeyable() {return 0;}		
		BOOL IsAnimated() {return TRUE;}

		void EditTrackParams(
			TimeValue t,
			ParamDimensionBase *dim,
			TCHAR *pname,
			HWND hParent,
			IObjParam *ip,
			DWORD flags);
		
		int TrackParamsType() {return TRACKPARAMS_WHOLE;}

		// Reference methods
		RefResult NotifyRefChanged(Interval, RefTargetHandle, PartID&, RefMessage) {return REF_SUCCEED;}

		IOResult Save(ISave *isave);
		IOResult Load(ILoad *iload);

		// Control methods				
		void Copy(Control *from) {}
		BOOL IsLeaf() {return TRUE;}
		void CommitValue(TimeValue t) {}
		void RestoreValue(TimeValue t) {}		
		
		void HoldRange();
		Interval GetTimeRange(DWORD flags) {return range;}
		void EditTimeRange(Interval range,DWORD flags);
		void MapKeys(TimeMap *map,DWORD flags );

		// Waveform slot management...
		void Insert(int ix);
		void Append();
		void Delete(int ix);
		void Move(int ix,int direction);

		// Info calls
		void GetRange(float *low, float *high, int ix);
		void GetDisplayRanges(float *lo, float *hi);
	};

//---------------------------------------------------------------------------

class FloatWaveControl : public BaseWaveControl {
	public:
		int Elems() {return 1;}

		Class_ID ClassID() { return Class_ID(FLOATWAVE_CONTROL_CLASS_ID,0); }  
		SClass_ID SuperClassID() { return CTRL_FLOAT_CLASS_ID; } 
		void GetClassName(TSTR& s) {s = FLOATWAVE_CONTROL_CNAME;}

		// Control methods
		RefTargetHandle Clone(RemapDir& remap);

		// StdControl methods
		void GetValueLocalTime(TimeValue t, void *val, Interval &valid, GetSetMethod method=CTRL_ABSOLUTE);
		void SetValueLocalTime(TimeValue t, void *val, int commit, GetSetMethod method) {}		
		void Extrapolate(Interval range,TimeValue t,void *val,Interval &valid,int type);		
		void *CreateTempValue() {return new float;}
		void DeleteTempValue(void *val) {delete (float*)val;}
		void ApplyValue(void *val, void *delta) {*((float*)val) += *((float*)delta);}
		void MultiplyValue(void *val, float m) {*((float*)val) *= m;}
	};


class FloatWaveClassDesc:public ClassDesc {
	public:
	int 			IsPublic() { return 1; }
	void *			Create(BOOL loading) { return new FloatWaveControl(); }
	const TCHAR *	ClassName() { return FLOATWAVE_CONTROL_CNAME; }
	SClass_ID		SuperClassID() { return CTRL_FLOAT_CLASS_ID; }
	Class_ID		ClassID() { return Class_ID(FLOATWAVE_CONTROL_CLASS_ID,0); }
	const TCHAR* 	Category() { return _T("");  }
	};
static FloatWaveClassDesc floatWaveCD;
ClassDesc* GetFloatWaveDesc() {return &floatWaveCD;}

//-----------------------------------------------------------------

class RangeRestore : public RestoreObj {
	public:
		BaseWaveControl *cont;
		Interval ur, rr;
		RangeRestore(BaseWaveControl *c) 
			{
			cont = c;
			ur   = cont->range;
			}   		
		void Restore(int isUndo) 
			{
			rr = cont->range;
			cont->range = ur;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}
		void Redo()
			{
			cont->range = rr;
			cont->NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
			}		
		void EndHold() 
			{ 
			cont->ClearAFlag(A_HELD);
			}
		TSTR Description() { return TSTR(_T("Wave control range")); }
	};


//-----------------------------------------------------------------
//
// UI

#define STEPSIZE			2
#define GRAPH_TIMESCALE		20

static void SetBiasRadio(HWND hWnd, int type) {
	CheckDlgButton(hWnd, IDC_CENTERED, type == BIAS_CENTERED);
	CheckDlgButton(hWnd, IDC_POSITIVE, type == BIAS_POSITIVE);
	CheckDlgButton(hWnd, IDC_NEGATIVE, type == BIAS_NEGATIVE);
	CheckDlgButton(hWnd, IDC_MANUAL, type == BIAS_MANUAL);
	}

static void SetEffectRadio(HWND hWnd, int effect) {
	CheckDlgButton(hWnd, IDC_ADDFUNC, effect == EFFECT_ADD);
	CheckDlgButton(hWnd, IDC_MULT, effect == EFFECT_MULTIPLY);
	CheckDlgButton(hWnd, IDC_CLAMPABOVE, effect == EFFECT_CLAMP_ABOVE);
	CheckDlgButton(hWnd, IDC_CLAMPBELOW, effect == EFFECT_CLAMP_BELOW);
	}

static void SetDisplayRadio(HWND hWnd, int display) {
	CheckDlgButton(hWnd, IDC_THIS, display == DISP_THIS);
	CheckDlgButton(hWnd, IDC_THISOUT, display == DISP_THISOUT);
	CheckDlgButton(hWnd, IDC_FINALOUT, display == DISP_FINALOUT);
	}

static HIMAGELIST hWaveButtons = NULL;

class DeleteWaveButtonResources {
	public:
		~DeleteWaveButtonResources() {
			ImageList_Destroy(hWaveButtons);
			}
	};
static DeleteWaveButtonResources	theWBDelete;

static void LoadWaveButtonResources()
	{
	static BOOL loaded=FALSE;
	if (loaded) return;
	loaded = TRUE;	
	HBITMAP hBitmap, hMask;

	InitCustomControls(hInstance);
	hWaveButtons = ImageList_Create(16, 16, TRUE, 6, 0);
	hBitmap = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_WAVE_BUTTONS));
	hMask   = LoadBitmap(hInstance,MAKEINTRESOURCE(IDB_WAVE_MASKBUTTONS));
	ImageList_Add(hWaveButtons,hBitmap,hMask);
	DeleteObject(hBitmap);
	DeleteObject(hMask);
	}

static BOOL CALLBACK AboutDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{	
	switch (msg) {
		case WM_INITDIALOG:			
			CenterWindow(hWnd, GetParent(hWnd));
			break;
			
		case WM_CLOSE:
			EndDialog(hWnd,0);			
			break;

		case WM_COMMAND:
			switch (LOWORD(wParam)) {
				case IDOK:
					EndDialog(hWnd,0);
					break;
				}
			break;

		default:
			return FALSE;
		}
	return TRUE;
	}

//-----------------------------------------------------------------
//
// UI

static LRESULT CALLBACK WaveGraphWinProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

static void InitWaveGraph(HINSTANCE hInst)
	{
	static BOOL init = FALSE;
	if (init) return;
	else init = TRUE;

	WNDCLASS wc;
	wc.style         = 0;
    wc.hInstance     = hInst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.lpfnWndProc   = WaveGraphWinProc;
    wc.lpszClassName = _T("WaveGraph");
		
	RegisterClass(&wc);	
	}


#define STEPSIZE			2
#define GRAPH_TIMESCALE		20

static void DrawWaveGraph(BaseWaveControl *cont,HWND hWnd,HDC hdc)
	{
	Rect rect, orect;
	GetClientRect(hWnd,&rect);
	orect = rect;
	float fy;
	int mid = rect.h()/2;
	rect.top    += 5;
	rect.bottom -= 5;
	TimeValue end = rect.right * GRAPH_TIMESCALE;
	float bottomValue, topValue;

	switch(cont->display) {
		case DISP_THIS: {
			int index = cont->index;
			// Autoscale the graph...
			// Width is 2x period
			float viewWidth = 2.0f;
			float leftValue = 0.0f;
			float rightValue = 2.0f;
			// Establish bottom value
			cont->GetRange(&bottomValue, &topValue, index);
			// Height is 1.2x range
			float viewHeight = (topValue - bottomValue);
			float viewVScale = viewHeight / (float)rect.h();
			float viewHScale = viewWidth / (float)rect.w();

			// Draw zero line
			SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
			int zeroPos = rect.bottom - (int)(-bottomValue / viewVScale);
			MoveToEx(hdc,0,zeroPos,NULL);
			LineTo(hdc,rect.right,zeroPos);

			DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));

			for (int x = 0; x < rect.right + STEPSIZE; x += STEPSIZE) {
				float sample = (float)x * viewHScale;
				fy = (cont->GetValue(sample, index) - bottomValue) / viewVScale;
				if (!x) {
					MoveToEx(hdc,0,rect.bottom - int(fy),NULL);
				} else {
					LineTo(hdc,x,rect.bottom - int(fy));
					}
				}
			}
			break;
		case DISP_THISOUT: {
			float maxPeriod = -9999.0f;
			int index = cont->index;
			for(int ix = 0; ix <= index; ++ix) {
				if(cont->period[ix] > maxPeriod)
					maxPeriod = cont->period[ix];
				}
			// Autoscale the graph...
			cont->GetDisplayRanges(&bottomValue, &topValue);
			// Width is 2x period
			float viewWidth = 2.0f;
			float leftValue = 0.0f;
			float rightValue = 2.0f;
			// Height is 1.2x amplitude
			float viewHeight = (topValue - bottomValue);
			float viewVScale = viewHeight / (float)rect.h();
			float viewHScale = viewWidth / (float)rect.w();

			// Draw zero line
			SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
			int zeroPos = rect.bottom - (int)(-bottomValue / viewVScale);
			MoveToEx(hdc,0,zeroPos,NULL);
			LineTo(hdc,rect.right,zeroPos);

			DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));

			for (int x = 0; x < rect.right + STEPSIZE; x += STEPSIZE) {
				float yValue = 0.0f;
				for(ix = 0; ix <= index; ++ix) {
					float sample = (float)x * viewHScale * (maxPeriod / cont->period[ix]);
					fy = cont->GetValue(sample, ix);
					switch(cont->effect[ix]) {
						case EFFECT_ADD:
							yValue += fy;
							break;
						case EFFECT_MULTIPLY:
							yValue *= fy;
							break;
						case EFFECT_CLAMP_ABOVE:
							if(yValue < fy)
								yValue = fy;
							break;
						case EFFECT_CLAMP_BELOW:
							if(yValue > fy)
								yValue = fy;
							break;
						}
					}
				yValue = (yValue - bottomValue) / viewVScale;
				if (!x) {
					MoveToEx(hdc,0,rect.bottom - int(yValue),NULL);
				} else {
					LineTo(hdc,x,rect.bottom - int(yValue));
					}
				}
			}
			break;
		case DISP_FINALOUT: {
			float maxPeriod = -9999.0f;
			int index = cont->index;
			for(int ix = 0; ix < cont->waves; ++ix) {
				if(cont->period[ix] > maxPeriod)
					maxPeriod = cont->period[ix];
				}
			// Autoscale the graph...
			cont->GetDisplayRanges(&bottomValue, &topValue);
			// Width is 2x period
			float viewWidth = 2.0f;
			float leftValue = 0.0f;
			float rightValue = 2.0f;
			// Height is 1.2x amplitude
			float viewHeight = (topValue - bottomValue);
			float viewVScale = viewHeight / (float)rect.h();
			float viewHScale = viewWidth / (float)rect.w();

			// Draw zero line
			SelectObject(hdc,CreatePen(PS_DOT,0,GetSysColor(COLOR_BTNFACE)));
			int zeroPos = rect.bottom - (int)(-bottomValue / viewVScale);
			MoveToEx(hdc,0,zeroPos,NULL);
			LineTo(hdc,rect.right,zeroPos);

			DeleteObject(SelectObject(hdc,GetStockObject(BLACK_PEN)));

			for (int x = 0; x < rect.right + STEPSIZE; x += STEPSIZE) {
				float yValue = 0.0f;
				for(ix = 0; ix < cont->waves; ++ix) {
					float sample = (float)x * viewHScale * (maxPeriod / cont->period[ix]);
					fy = cont->GetValue(sample, ix);
					switch(cont->effect[ix]) {
						case EFFECT_ADD:
							yValue += fy;
							break;
						case EFFECT_MULTIPLY:
							yValue *= fy;
							break;
						case EFFECT_CLAMP_ABOVE:
							if(yValue < fy)
								yValue = fy;
							break;
						case EFFECT_CLAMP_BELOW:
							if(yValue > fy)
								yValue = fy;
							break;
						}
					}
				yValue = (yValue - bottomValue) / viewVScale;
				if (!x) {
					MoveToEx(hdc,0,rect.bottom - int(yValue),NULL);
				} else {
					LineTo(hdc,x,rect.bottom - int(yValue));
					}
				}
			}
			break;
		}
	WhiteRect3D(hdc,orect,TRUE);
	}

static LRESULT CALLBACK WaveGraphWinProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	BaseWaveControl *cont = (BaseWaveControl*)GetWindowLong(hWnd,GWL_USERDATA);
	if (!cont) return DefWindowProc(hWnd,msg,wParam,lParam);

	switch (msg) {		
		case WM_PAINT: {
			PAINTSTRUCT ps;
			HDC hdc = BeginPaint(hWnd,&ps);
			DrawWaveGraph(cont,hWnd,hdc);
			EndPaint(hWnd,&ps);
			break;
			}

		default:
			return DefWindowProc(hWnd,msg,wParam,lParam);
		}
	
	return 0;
	}

//--------------------------------------------------------------

static BOOL CALLBACK WaveDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

#define WAVEDLG_CLASS_ID	0x8234Fc4e

class WaveCtrlWindow {
	public:
		HWND hWnd;
		HWND hParent;
		Control *cont;
		WaveCtrlWindow() {assert(0);}
		WaveCtrlWindow(HWND hWnd,HWND hParent,Control *cont)
			{this->hWnd=hWnd; this->hParent=hParent; this->cont=cont;}
	};
static Tab<WaveCtrlWindow> waveCtrlWindows;

static void RegisterWaveCtrlWindow(HWND hWnd, HWND hParent, Control *cont)
	{
	WaveCtrlWindow rec(hWnd,hParent,cont);
	waveCtrlWindows.Append(1,&rec);
	}

static void UnRegisterWaveCtrlWindow(HWND hWnd)
	{	
	for (int i=0; i<waveCtrlWindows.Count(); i++) {
		if (hWnd==waveCtrlWindows[i].hWnd) {
			waveCtrlWindows.Delete(i,1);
			return;
			}
		}	
	}

static HWND FindOpenWaveCtrlWindow(HWND hParent,Control *cont)
	{	
	for (int i=0; i<waveCtrlWindows.Count(); i++) {
		if (hParent == waveCtrlWindows[i].hParent &&
			cont    == waveCtrlWindows[i].cont) {
			return waveCtrlWindows[i].hWnd;
			}
		}
	return NULL;
	}

class WaveDlg : public ReferenceMaker {
	public:
		BaseWaveControl *cont;	
		ParamDimensionBase *dim;
		IObjParam *ip;
		HWND hWnd;
		BOOL valid;
		ISpinnerControl *iPeriod, *iDuty, *iAmplitude, *iPhase, *iBias;

		WaveDlg(
			BaseWaveControl *cont,
			ParamDimensionBase *dim,
			TCHAR *pname,
			IObjParam *ip,
			HWND hParent);
		~WaveDlg();

		Class_ID ClassID() {return Class_ID(WAVEDLG_CLASS_ID,0);}
		SClass_ID SuperClassID() {return REF_MAKER_CLASS_ID;}

		void MaybeCloseWindow();

		void Invalidate();
		void Update();
		void SetupUI(HWND hWnd);
		void Change(BOOL redraw=FALSE);
		void WMCommand(int id, int notify, HWND hCtrl);
		void SpinnerChange(int id,BOOL drag);
		void SpinnerStart(int id);
		void SpinnerEnd(int id,BOOL cancel);

		RefResult NotifyRefChanged(Interval changeInt, RefTargetHandle hTarget, 
	         PartID& partID,  RefMessage message);
		int NumRefs() {return 1;}
		RefTargetHandle GetReference(int i) {return cont;}
		void SetReference(int i, RefTargetHandle rtarg) {cont=(BaseWaveControl*)rtarg;}
	};


WaveDlg::WaveDlg(
		BaseWaveControl *cont,
		ParamDimensionBase *dim,
		TCHAR *pname,
		IObjParam *ip,
		HWND hParent)
	{
	InitWaveGraph(hInstance);
	this->cont = cont;
	this->ip   = ip;
	this->dim  = dim;
	valid = FALSE;
	MakeRefByID(FOREVER,0,cont);
	hWnd = CreateDialogParam(
		hInstance,
		MAKEINTRESOURCE(IDD_WAVEPARAMS),
		hParent,
		WaveDlgProc,
		(LPARAM)this);	
	TSTR title = TSTR(GetString(IDS_TH_WAVECONTROLTITLE)) + TSTR(pname);
	SetWindowText(hWnd,title);
	}

WaveDlg::~WaveDlg()
	{
	UnRegisterWaveCtrlWindow(hWnd);
	DeleteAllRefsFromMe();
	ReleaseISpinner(iPeriod);
	ReleaseISpinner(iDuty);
	ReleaseISpinner(iAmplitude);
	ReleaseISpinner(iPhase);
	ReleaseISpinner(iBias);
	}

void WaveDlg::Invalidate()
	{
	valid = FALSE;
	Rect rect(IPoint2(0,0),IPoint2(10,10));
	InvalidateRect(hWnd,&rect,FALSE);	
	}

// strip off all but one trailing zero --DS
static void RemoveTrailingZeros(char* buf) {
	int n = strlen(buf);
	for (int i=0; i<n; i++) {
		if (buf[i] == '.' || buf[i] == ',') {
			for (int j = n-1; j>i+1; j--) {
				if (buf[j]=='0') 
					buf[j] = 0;
				else 
					break;
				}
			break;
			}
		}
	}

void WaveDlg::Update()
	{
	ICustButton *but;
	if (!valid && hWnd) {
		int index = cont->index;
		SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_RESETCONTENT, 0, 0);
		for(int i = 0; i < cont->waves; ++i)
			SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_ADDSTRING, 0, (LPARAM)cont->name[i].data());
		SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_SETCURSEL, cont->index, 0);
		SendMessage(GetDlgItem(hWnd,IDC_WAVENAME), WM_SETTEXT, 0, (LPARAM)cont->name[index].data());
		iPeriod->SetValue(cont->period[index],FALSE);
		iDuty->SetValue(cont->duty[index],FALSE);
		if(cont->type[index] == TYPE_SQUARE)
			iDuty->Enable();
		else 
			iDuty->Disable();
		iAmplitude->SetValue(dim->Convert(cont->amplitude[index]),FALSE);
		iPhase->SetValue(cont->phase[index],FALSE);
		iBias->SetValue(dim->Convert(cont->bias[index]),FALSE);
		but = GetICustButton(GetDlgItem(hWnd, IDC_SQUARE));
		but->SetCheck((cont->type[index] == TYPE_SQUARE) ? TRUE : FALSE);
		ReleaseICustButton(but);
		but = GetICustButton(GetDlgItem(hWnd, IDC_SINE));
		but->SetCheck((cont->type[index] == TYPE_SINE) ? TRUE : FALSE);
		ReleaseICustButton(but);
		but = GetICustButton(GetDlgItem(hWnd, IDC_TRIANGLE));
		but->SetCheck((cont->type[index] == TYPE_TRIANGLE) ? TRUE : FALSE);
		ReleaseICustButton(but);
		but = GetICustButton(GetDlgItem(hWnd, IDC_SAWTOOTH));
		but->SetCheck((cont->type[index] == TYPE_SAWTOOTH) ? TRUE : FALSE);
		ReleaseICustButton(but);
		but = GetICustButton(GetDlgItem(hWnd, IDC_HALFSINE));
		but->SetCheck((cont->type[index] == TYPE_HALFSINE) ? TRUE : FALSE);
		ReleaseICustButton(but);
		CheckDlgButton(hWnd,IDC_INVERTED,cont->inverted[index]);
		CheckDlgButton(hWnd,IDC_FLIPPED,cont->flipped[index]);
		CheckDlgButton(hWnd,IDC_DISABLE,cont->enabled[index] ? FALSE : TRUE);
		SetBiasRadio(hWnd, cont->biasType[index]);
		SetEffectRadio(hWnd, cont->effect[index]);
		SetDisplayRadio(hWnd, cont->display);

		EnableWindow(GetDlgItem(hWnd,IDC_REMOVE), (cont->waves > 1) ? TRUE : FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_MOVEUP), (index > 0) ? TRUE : FALSE);
		EnableWindow(GetDlgItem(hWnd,IDC_MOVEDOWN), (index < (cont->waves - 1)) ? TRUE : FALSE);

		float lorange, hirange;
		cont->GetDisplayRanges(&lorange, &hirange);
		char buf[256];
		sprintf(buf,"%.2f",lorange);
		RemoveTrailingZeros(buf);
		SetDlgItemText(hWnd, IDC_LOVALUE, buf);
		sprintf(buf,"%.2f",hirange);
		RemoveTrailingZeros(buf);
		SetDlgItemText(hWnd, IDC_HIVALUE, buf);

		valid = TRUE;
		}
	}

void WaveDlg::SetupUI(HWND hWnd)
	{
	ICustButton *but;	
	this->hWnd = hWnd;

	iPeriod = GetISpinner(GetDlgItem(hWnd,IDC_WAVE_PERIODSPIN));
	iPeriod->SetLimits(0.01f,9999999.0f,FALSE);
	iPeriod->SetScale(0.1f);
	iPeriod->LinkToEdit(GetDlgItem(hWnd,IDC_WAVE_PERIOD),EDITTYPE_FLOAT);	

	iDuty = GetISpinner(GetDlgItem(hWnd,IDC_WAVE_DUTYSPIN));
	iDuty->SetLimits(0,100,FALSE);
	iDuty->SetScale(0.1f);
	iDuty->LinkToEdit(GetDlgItem(hWnd,IDC_WAVE_DUTY),EDITTYPE_FLOAT);	

	iAmplitude = GetISpinner(GetDlgItem(hWnd,IDC_WAVE_AMPLITUDESPIN));
	iAmplitude->SetLimits(0,9999999,FALSE);
	iAmplitude->SetScale(0.1f);
	iAmplitude->LinkToEdit(GetDlgItem(hWnd,IDC_WAVE_AMPLITUDE),EDITTYPE_FLOAT);	

	iPhase = GetISpinner(GetDlgItem(hWnd,IDC_WAVE_PHASESPIN));
	iPhase->SetLimits(0,1,FALSE);
	iPhase->SetScale(0.01f);
	iPhase->LinkToEdit(GetDlgItem(hWnd,IDC_WAVE_PHASE),EDITTYPE_FLOAT);	
	
	iBias = GetISpinner(GetDlgItem(hWnd,IDC_WAVE_BIASSPIN));
	iBias->SetLimits(-9999999,9999999,FALSE);
	iBias->SetScale(0.1f);
	iBias->LinkToEdit(GetDlgItem(hWnd,IDC_WAVE_BIAS),EDITTYPE_FLOAT);	
	
	LoadWaveButtonResources();
	but = GetICustButton(GetDlgItem(hWnd,IDC_SQUARE));
	but->SetType(CBT_CHECK);
	but->SetImage( hWaveButtons, 0,0,0,0, 16, 16);
	but->SetTooltip(TRUE, GetString(IDS_TH_SQUARE));
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hWnd,IDC_SINE));
	but->SetType(CBT_CHECK);
	but->SetImage( hWaveButtons, 1,1,1,1, 16, 16);
	but->SetTooltip(TRUE, GetString(IDS_TH_SINE));
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hWnd,IDC_TRIANGLE));
	but->SetType(CBT_CHECK);
	but->SetImage( hWaveButtons, 2,2,2,2, 16, 16);
	but->SetTooltip(TRUE, GetString(IDS_TH_TRIANGLE));
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hWnd,IDC_SAWTOOTH));
	but->SetType(CBT_CHECK);
	but->SetImage( hWaveButtons, 3,3,3,3, 16, 16);
	but->SetTooltip(TRUE, GetString(IDS_TH_SAWTOOTH));
	ReleaseICustButton(but);
	but = GetICustButton(GetDlgItem(hWnd,IDC_HALFSINE));
	but->SetType(CBT_CHECK);
	but->SetImage( hWaveButtons, 4,4,4,4, 16, 16);
	but->SetTooltip(TRUE, GetString(IDS_TH_HALFSINE));
	ReleaseICustButton(but);

	SetWindowLong(GetDlgItem(hWnd,IDC_WAVE_GRAPH),GWL_USERDATA,(LONG)cont);
	valid = FALSE;
	Update();
	}

void WaveDlg::WMCommand(int id, int notify, HWND hCtrl)
	{
	int index = cont->index;
	TCHAR buf[256];
	switch (id) {
		case IDC_WAVELIST:
			switch(notify) {
				case LBN_SELCHANGE: {
					int newIndex = SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_GETCURSEL, 0, 0);
					cont->index = newIndex;
					Change(TRUE);
					}
					break;					
				}
			break;
		case IDC_WAVENAME:
			switch(notify) {
				case EN_SETFOCUS:
					DisableAccelerators();
					break;
				case EN_KILLFOCUS:
					EnableAccelerators();
					GetDlgItemText(hWnd, IDC_WAVENAME, buf, 256);
					cont->name[index] = buf;
					Change(TRUE);
					break;
				case EN_CHANGE:
					GetDlgItemText(hWnd, IDC_WAVENAME, buf, 256);
					cont->name[index] = buf;
					SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_DELETESTRING, index, 0);
					SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_INSERTSTRING, index, (LPARAM)cont->name[index].data());
					SendMessage(GetDlgItem(hWnd,IDC_WAVELIST), LB_SETCURSEL, index, 0);
					break;
				}					
			break;
		case IDC_SQUARE:
			cont->type[index] = TYPE_SQUARE;
			Change(TRUE);
			break;
		case IDC_SINE:
			cont->type[index] = TYPE_SINE;
			Change(TRUE);
			break;
		case IDC_TRIANGLE:
			cont->type[index] = TYPE_TRIANGLE;
			Change(TRUE);
			break;
		case IDC_SAWTOOTH:
			cont->type[index] = TYPE_SAWTOOTH;
			Change(TRUE);
			break;
		case IDC_HALFSINE:
			cont->type[index] = TYPE_HALFSINE;
			Change(TRUE);
			break;
		case IDC_CENTERED:
			cont->biasType[index] = BIAS_CENTERED;
			Change(TRUE);
			break;
		case IDC_POSITIVE:
			cont->biasType[index] = BIAS_POSITIVE;
			Change(TRUE);
			break;
		case IDC_NEGATIVE:
			cont->biasType[index] = BIAS_NEGATIVE;
			Change(TRUE);
			break;
		case IDC_MANUAL:
			cont->biasType[index] = BIAS_MANUAL;
			Change(TRUE);
			break;
		case IDC_INVERTED:
			cont->inverted[index] = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;
		case IDC_FLIPPED:
			cont->flipped[index] = IsDlgButtonChecked(hWnd,id);
			Change(TRUE);
			break;
		case IDC_DISABLE:
			cont->enabled[index] = IsDlgButtonChecked(hWnd,id) ? FALSE : TRUE;
			Change(TRUE);
			break;
		case IDC_ADDFUNC:
			cont->effect[index] = EFFECT_ADD;
			Change(TRUE);
			break;
		case IDC_MULT:
			cont->effect[index] = EFFECT_MULTIPLY;
			Change(TRUE);
			break;
		case IDC_CLAMPABOVE:
			cont->effect[index] = EFFECT_CLAMP_ABOVE;
			Change(TRUE);
			break;
		case IDC_CLAMPBELOW:
			cont->effect[index] = EFFECT_CLAMP_BELOW;
			Change(TRUE);
			break;
		case IDC_THIS:
			cont->display = DISP_THIS;
			Change(TRUE);
			break;
		case IDC_THISOUT:
			cont->display = DISP_THISOUT;
			Change(TRUE);
			break;
		case IDC_FINALOUT:
			cont->display = DISP_FINALOUT;
			Change(TRUE);
			break;
		case IDC_APPEND:
			cont->Append();
			Change(TRUE);
			break;
		case IDC_INSERT:
			cont->Insert(index);
			Change(TRUE);
			break;
		case IDC_REMOVE:
			cont->Delete(index);
			Change(TRUE);
			break;
		case IDC_MOVEUP:
			cont->Move(index, -1);
			Change(TRUE);
			break;
		case IDC_MOVEDOWN:
			cont->Move(index, 1);
			Change(TRUE);
			break;
		case IDC_ABOUT:
			DialogBox(
				hInstance,
				MAKEINTRESOURCE(IDD_ABOUT),
				hWnd,
				AboutDlgProc);	
			break;
		}
	}

void WaveDlg::SpinnerChange(int id,BOOL drag)
	{
	int index = cont->index;
	switch (id) {
		case IDC_WAVE_PERIODSPIN:
			cont->period[index] = iPeriod->GetFVal();
			Change(1);
			break;

		case IDC_WAVE_DUTYSPIN:
			cont->duty[index] = iDuty->GetFVal();
			Change(1);
			break;

		case IDC_WAVE_AMPLITUDESPIN:
			cont->amplitude[index] = dim->UnConvert(iAmplitude->GetFVal());
			Change(1);
			break;

		case IDC_WAVE_PHASESPIN:
			cont->phase[index] = iPhase->GetFVal();
			Change(1);
			break;

		case IDC_WAVE_BIASSPIN:
			cont->bias[index] = dim->UnConvert(iBias->GetFVal());
			Change(1);
			break;
		}
	}

void WaveDlg::SpinnerStart(int id)
	{
	}

void WaveDlg::SpinnerEnd(int id,BOOL cancel)
	{
	ip->RedrawViews(ip->GetTime());
	}

void WaveDlg::Change(BOOL redraw)
	{
	InvalidateRect(GetDlgItem(hWnd,IDC_WAVE_GRAPH),NULL,TRUE);
	cont->NotifyDependents(FOREVER,PART_ALL,REFMSG_CHANGE);
	UpdateWindow(GetDlgItem(hWnd,IDC_WAVE_GRAPH));
	UpdateWindow(GetParent(hWnd));	
	if (redraw) ip->RedrawViews(ip->GetTime());
	}


class CheckForNonWaveDlg : public DependentEnumProc {
	public:		
		BOOL non;
		ReferenceMaker *me;
		CheckForNonWaveDlg(ReferenceMaker *m) {non = FALSE;me = m;}
		int proc(ReferenceMaker *rmaker) {
			if (rmaker==me) return 0;
			if (rmaker->SuperClassID()!=REF_MAKER_CLASS_ID &&
				rmaker->ClassID()!=Class_ID(WAVEDLG_CLASS_ID,0)) {
				non = TRUE;
				return 1;
				}
			return 0;
			}
	};

void WaveDlg::MaybeCloseWindow()
	{
	CheckForNonWaveDlg check(cont);
	cont->EnumDependents(&check);
	if (!check.non) {
		PostMessage(hWnd,WM_CLOSE,0,0);
		}
	}

RefResult WaveDlg::NotifyRefChanged(
		Interval changeInt, 
		RefTargetHandle hTarget, 
     	PartID& partID,  
     	RefMessage message)
	{
	switch (message) {
		case REFMSG_CHANGE:
			Invalidate();			
			break;
		
		case REFMSG_REF_DELETED:
			MaybeCloseWindow();
			break;
		}
	return REF_SUCCEED;
	}


static BOOL CALLBACK WaveDlgProc(
		HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
	{
	WaveDlg *dlg = (WaveDlg*)GetWindowLong(hWnd,GWL_USERDATA);

	switch (msg) {
		case WM_INITDIALOG:
			dlg = (WaveDlg*)lParam;
			SetWindowLong(hWnd,GWL_USERDATA,lParam);
			dlg->SetupUI(hWnd);
			break;

		case CC_SPINNER_BUTTONDOWN:
			dlg->SpinnerStart(LOWORD(wParam));
			break;

		case CC_SPINNER_CHANGE:
			dlg->SpinnerChange(LOWORD(wParam),HIWORD(wParam));
			break;

		case CC_SPINNER_BUTTONUP:
			dlg->SpinnerEnd(LOWORD(wParam),!HIWORD(wParam));
			break;

		case WM_COMMAND:
			dlg->WMCommand(LOWORD(wParam),HIWORD(wParam),(HWND)lParam);						
			break;

		case WM_PAINT:
			dlg->Update();
			return 0;			
		
		case WM_CLOSE:
			DestroyWindow(hWnd);			
			break;

		case WM_DESTROY:						
			delete dlg;
			break;
		
		default:
			return FALSE;
		}
	return TRUE;
	}

void BaseWaveControl::EditTrackParams(
		TimeValue t,
		ParamDimensionBase *dim,
		TCHAR *pname,
		HWND hParent,
		IObjParam *ip,
		DWORD flags)
	{
	HWND hCur = FindOpenWaveCtrlWindow(hParent,this);
	if (hCur) {
		SetForegroundWindow(hCur);
		return;
		}
	WaveDlg *dlg = new WaveDlg(this,dim,pname,ip,hParent);
	RegisterWaveCtrlWindow(dlg->hWnd,hParent,this);
	}

//--------------------------------------------------------------------------------------

BaseWaveControl::BaseWaveControl() 
	{
	waves = 0;
	Insert(0);	// Create our initial slot
	index = 0;

	display = DISP_THIS;
	range     = Interval(GetAnimStart(),GetAnimEnd());
	} 

BaseWaveControl& BaseWaveControl::operator=(const BaseWaveControl& from)
	{
	// Flush any old data
	while(waves)
		Delete(waves-1);
	// Make space for new data
	while(waves < from.waves)
		Insert(0);
	index = from.index;
	for(int i = 0; i < waves; ++i) {	
		name[i]      = from.name[i];
		period[i]    = from.period[i];
		duty[i]      = from.duty[i];
		amplitude[i] = from.amplitude[i];
		phase[i]     = from.phase[i];
		bias[i]      = from.bias[i];
		type[i]      = from.type[i];
		biasType[i]  = from.biasType[i];
		effect[i]    = from.effect[i];
		inverted[i]  = from.inverted[i];
		flipped[i]   = from.flipped[i];	
		enabled[i]   = from.enabled[i];	
		}
	display = from.display;
	range     = from.range;
	return *this;
	}

float BaseWaveControl::GetValue(float where, int ix) {
	float baseValue = 0.0f;
	if(ix < 0) {
		for(int i = 0; i < waves; ++i) {
			if(enabled[i]) {
				float tValue = GetValue(where, i);
				switch(effect[i]) {
					case EFFECT_ADD:
						baseValue += tValue;
						break;
					case EFFECT_MULTIPLY:
						baseValue *= tValue;
						break;
					case EFFECT_CLAMP_ABOVE:
						if(baseValue < tValue)
							baseValue = tValue;
						break;
					case EFFECT_CLAMP_BELOW:
						if(baseValue > tValue)
							baseValue = tValue;
						break;
					}
				}
			}
		}
	else {
		if(!enabled[ix]) {
			switch(effect[ix]) {
				case EFFECT_ADD:
					return 0.0f;
				case EFFECT_MULTIPLY:
					return 1.0f;
				case EFFECT_CLAMP_ABOVE:
					return -9999999.0f;
				case EFFECT_CLAMP_BELOW:
					return 9999999.0f;
				}
			}
		where = (float)fmod(where + phase[ix], 1.0f);
		if(flipped[ix])
			where = 1.0f - where;
		switch(type[ix]) {
			case TYPE_SQUARE:
				baseValue = (where < (duty[ix] / 100.0f)) ? amplitude[ix] : -amplitude[ix];
				break;
			case TYPE_SINE:
				baseValue = (float)sin(where * 2.0f * PI) * amplitude[ix];
				break;
			case TYPE_SAWTOOTH:
				baseValue = -amplitude[ix] + (amplitude[ix] * 2.0f * where);
				break;
			case TYPE_TRIANGLE:
				baseValue = (where < 0.5f) ? (-amplitude[ix] + (amplitude[ix] * 4.0f * where)) :
					(amplitude[ix] - (amplitude[ix] * 4.0f * (where - 0.5f)));
				break;
			case TYPE_HALFSINE:
				baseValue = -amplitude[ix] + (float)sin(where * PI) * amplitude[ix] * 2.0f;
				break;
			default:
				assert(0);
				baseValue = 0.0f;
				break;
			}

		if(inverted[ix])
			baseValue = -baseValue;

		switch(biasType[ix]) {
			case BIAS_CENTERED:
				break;
			case BIAS_POSITIVE:
				baseValue += amplitude[ix];
				break;
			case BIAS_NEGATIVE:
				baseValue -= amplitude[ix];
				break;
			case BIAS_MANUAL:
				baseValue += bias[ix];
				break;
			default:
				assert(0);
				break;
			}
		}

	return baseValue;
	}

float BaseWaveControl::WaveAtTime(TimeValue t,int ix)
	{
	if(ix < 0) {
		float theValue = 0.0f;
		for(int i = 0; i < waves; ++i) {
			if(enabled[i]) {
				float tValue = GetValue((float)fmod((float)t / 160.0f, period[i]) / period[i], i);
				switch(effect[i]) {
					case EFFECT_ADD:
						theValue += tValue;
						break;
					case EFFECT_MULTIPLY:
						theValue *= tValue;
						break;
					case EFFECT_CLAMP_ABOVE:
						if(theValue < tValue)
							theValue = tValue;
						break;
					case EFFECT_CLAMP_BELOW:
						if(theValue > tValue)
							theValue = tValue;
						break;
					}
				}
			}
		return theValue;
		}
	else {
		// Convert time to frame number and then mod it with our period
		return GetValue((float)fmod((float)t / 160.0f, period[ix]) / period[ix], ix);
		}
	}

void BaseWaveControl::HoldRange()
	{
	if (theHold.Holding() && !TestAFlag(A_HELD)) {
		SetAFlag(A_HELD);
		theHold.Put(new RangeRestore(this));
		}
	}

void BaseWaveControl::EditTimeRange(Interval range,DWORD flags)
	{
	if (!(flags&EDITRANGE_LINKTOKEYS)) {
		HoldRange();
		this->range = range;
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

void BaseWaveControl::MapKeys(TimeMap *map,DWORD flags)
	{
	if (flags&TRACK_MAPRANGE) {
		HoldRange();
		TimeValue t0 = map->map(range.Start());
		TimeValue t1 = map->map(range.End());
		range.Set(t0,t1);
		NotifyDependents(FOREVER, PART_ALL, REFMSG_CHANGE);
		}
	}

void BaseWaveControl::Insert(int ix) {
	int newWaves = waves + 1;
	TSTR *newName = new TSTR [newWaves];
	float *newPeriod = new float[newWaves];
	float *newDuty = new float[newWaves];
	float *newAmplitude = new float[newWaves];
	float *newPhase = new float[newWaves];
	float *newBias = new float[newWaves];
	int *newType = new int[newWaves];
	int *newBiasType = new int[newWaves];
	int *newEffect = new int[newWaves];
	int *newInverted = new BOOL[newWaves];
	int *newFlipped = new BOOL[newWaves];
	int *newEnabled = new BOOL[newWaves];
	// Pop the old ones into the new slots
	int d = 0;
	for(int s = 0; s < ix; ++s,++d) {
		newName[d] = name[s];
		newPeriod[d] = period[s];
		newDuty[d] = duty[s];
		newAmplitude[d] = amplitude[s];
		newPhase[d] = phase[s];
		newBias[d] = bias[s];
		newType[d] = type[s];
		newBiasType[d] = biasType[s];
		newEffect[d] = effect[s];
		newInverted[d] = inverted[s];
		newFlipped[d] = flipped[s];
		newEnabled[d] = enabled[s];
		}
	// Load the new slot with default waveform
	newName[d] = TSTR("Waveform");
	newPeriod[d]    = 10.0f;
	newDuty[d]      = 50.0f;
	newAmplitude[d] = 100.0f;
	newPhase[d]     = 0.0f;
	newBias[d]      = 0.0f;
	newType[d]      = TYPE_SINE;
	newBiasType[d]  = BIAS_CENTERED;
	newEffect[d]    = EFFECT_ADD;
	newInverted[d]  = FALSE;
	newFlipped[d]   = FALSE;
	newEnabled[d]   = TRUE;
	d++;
	// Copy the following slots
	for(s = ix; s < waves; ++s,++d) {
		newName[d] = name[s];
		newPeriod[d] = period[s];
		newDuty[d] = duty[s];
		newAmplitude[d] = amplitude[s];
		newPhase[d] = phase[s];
		newBias[d] = bias[s];
		newType[d] = type[s];
		newBiasType[d] = biasType[s];
		newEffect[d] = effect[s];
		newInverted[d] = inverted[s];
		newFlipped[d] = flipped[s];
		newEnabled[d] = enabled[s];
		}
	if(waves) {
		delete [] name;
		delete [] period;
		delete [] duty;
		delete [] amplitude;
		delete [] phase;
		delete [] bias;
		delete [] type;
		delete [] biasType;
		delete [] effect;
		delete [] inverted;
		delete [] flipped;
		delete [] enabled;
		}
	name = newName;
	period = newPeriod;
	duty = newDuty;
	amplitude = newAmplitude;
	phase = newPhase;
	bias = newBias;
	type = newType;
	biasType = newBiasType;
	effect = newEffect;
	inverted = newInverted;
	flipped = newFlipped;
	enabled = newEnabled;
	waves = newWaves;
	index = ix;
	}

void BaseWaveControl::Append() {
	int newWaves = waves + 1;
	TSTR *newName = new TSTR [newWaves];
	float *newPeriod = new float[newWaves];
	float *newDuty = new float[newWaves];
	float *newAmplitude = new float[newWaves];
	float *newPhase = new float[newWaves];
	float *newBias = new float[newWaves];
	int *newType = new int[newWaves];
	int *newBiasType = new int[newWaves];
	int *newEffect = new int[newWaves];
	int *newInverted = new BOOL[newWaves];
	int *newFlipped = new BOOL[newWaves];
	int *newEnabled = new BOOL[newWaves];
	// Pop the old ones into the new slots
	int d = 0;
	for(int s = 0; s < waves; ++s,++d) {
		newName[d] = name[s];
		newPeriod[d] = period[s];
		newDuty[d] = duty[s];
		newAmplitude[d] = amplitude[s];
		newPhase[d] = phase[s];
		newBias[d] = bias[s];
		newType[d] = type[s];
		newBiasType[d] = biasType[s];
		newEffect[d] = effect[s];
		newInverted[d] = inverted[s];
		newFlipped[d] = flipped[s];
		newEnabled[d] = enabled[s];
		}
	// Load the new slot with default waveform
	newName[d] = TSTR("Waveform");
	newPeriod[d]    = 10.0f;
	newDuty[d]      = 50.0f;
	newAmplitude[d] = 100.0f;
	newPhase[d]     = 0.0f;
	newBias[d]      = 0.0f;
	newType[d]      = TYPE_SINE;
	newBiasType[d]  = BIAS_CENTERED;
	newEffect[d]    = EFFECT_ADD;
	newInverted[d]  = FALSE;
	newFlipped[d]   = FALSE;
	newEnabled[d]   = TRUE;
	if(waves) {
		delete [] name;
		delete [] period;
		delete [] duty;
		delete [] amplitude;
		delete [] phase;
		delete [] bias;
		delete [] type;
		delete [] biasType;
		delete [] effect;
		delete [] inverted;
		delete [] flipped;
		delete [] enabled;
		}
	name = newName;
	period = newPeriod;
	duty = newDuty;
	amplitude = newAmplitude;
	phase = newPhase;
	bias = newBias;
	type = newType;
	biasType = newBiasType;
	effect = newEffect;
	inverted = newInverted;
	flipped = newFlipped;
	enabled = newEnabled;
	waves = newWaves;
	index = waves - 1;
	}

void BaseWaveControl::Delete(int ix) {
	assert(ix >= 0 && ix < waves);
	int newWaves = waves - 1;
	TSTR *newName = NULL;
	float *newPeriod = NULL;
	float *newDuty = NULL;
	float *newAmplitude = NULL;
	float *newPhase = NULL;
	float *newBias = NULL;
	int *newType = NULL;
	int *newBiasType = NULL;
	int *newEffect = NULL;
	int *newInverted = NULL;
	int *newFlipped = NULL;
	int *newEnabled = NULL;
	if(newWaves) {
		newName = new TSTR [newWaves];
		newPeriod = new float[newWaves];
		newDuty = new float[newWaves];
		newAmplitude = new float[newWaves];
		newPhase = new float[newWaves];
		newBias = new float[newWaves];
		newType = new int[newWaves];
		newBiasType = new int[newWaves];
		newEffect = new int[newWaves];
		newInverted = new BOOL[newWaves];
		newFlipped = new BOOL[newWaves];
		newEnabled = new BOOL[newWaves];
		// Pop the old ones into the new slots
		int d = 0;
		for(int s = 0; s < waves; ++s) {
			if(s != ix) {
				newName[d] = name[s];
				newPeriod[d] = period[s];
				newDuty[d] = duty[s];
				newAmplitude[d] = amplitude[s];
				newPhase[d] = phase[s];
				newBias[d] = bias[s];
				newType[d] = type[s];
				newBiasType[d] = biasType[s];
				newEffect[d] = effect[s];
				newInverted[d] = inverted[s];
				newFlipped[d] = flipped[s];
				newEnabled[d] = enabled[s];
				d++;
				}
			}
		}
	delete [] name;
	delete [] period;
	delete [] duty;
	delete [] amplitude;
	delete [] phase;
	delete [] bias;
	delete [] type;
	delete [] biasType;
	delete [] effect;
	delete [] inverted;
	delete [] flipped;
	delete [] enabled;
	name = newName;
	period = newPeriod;
	duty = newDuty;
	amplitude = newAmplitude;
	phase = newPhase;
	bias = newBias;
	type = newType;
	biasType = newBiasType;
	effect = newEffect;
	inverted = newInverted;
	flipped = newFlipped;
	enabled = newEnabled;
	waves = newWaves;
	if(index >= waves)
		index = waves - 1;
	}

void BaseWaveControl::Move(int ix,int direction) {
	int dest = ix + direction;
	TSTR holdName = name[dest];
	float holdPeriod = period[dest];
	float holdDuty = duty[dest];
	float holdAmplitude = amplitude[dest];
	float holdPhase = phase[dest];
	float holdBias = bias[dest];
	int holdType = type[dest];
	int holdBiasType = biasType[dest];
	int holdEffect = effect[dest];
	int holdInverted = inverted[dest];
	int holdFlipped = flipped[dest];
	int holdEnabled = enabled[dest];

	name[dest] = name[ix];
	period[dest] = period[ix];
	duty[dest] = duty[ix];
	amplitude[dest] = amplitude[ix];
	phase[dest] = phase[ix];
	bias[dest] = bias[ix];
	type[dest] = type[ix];
	biasType[dest] = biasType[ix];
	effect[dest] = effect[ix];
	inverted[dest] = inverted[ix];
	flipped[dest] = flipped[ix];
	enabled[dest] = enabled[ix];

	name[ix] = holdName;
	period[ix] = holdPeriod;
	duty[ix] = holdDuty;
	amplitude[ix] = holdAmplitude;
	phase[ix] = holdPhase;
	bias[ix] = holdBias;
	type[ix] = holdType;
	biasType[ix] = holdBiasType;
	effect[ix] = holdEffect;
	inverted[ix] = holdInverted;
	flipped[ix] = holdFlipped;
	enabled[ix] = holdEnabled;

	index = dest;
	}

static float highestOf(float a, float b, float c, float d) {
	float maxab = (a > b) ? a : b;
	float maxcd = (c > d) ? c : d;
	return (maxab > maxcd) ? maxab : maxcd;
	}

static float lowestOf(float a, float b, float c, float d) {
	float minab = (a < b) ? a : b;
	float mincd = (c < d) ? c : d;
	return (minab < mincd) ? minab : mincd;
	}

void BaseWaveControl::GetRange(float *low, float *high, int index) {
	assert(index >= 0 && index < waves);
	switch(biasType[index]) {
		case BIAS_CENTERED:
			if(low)
				*low = -amplitude[index];
			if(high)
				*high = amplitude[index];
			break;
		case BIAS_POSITIVE:
			if(low)
				*low = 0.0f;
			if(high)
				*high = 2.0f * amplitude[index];
			break;
		case BIAS_NEGATIVE:
			if(low)
				*low = -2.0f * amplitude[index];
			if(high)
				*high = 0.0f;
			break;
		case BIAS_MANUAL:
		default:
			if(low)
				*low = -amplitude[index] + bias[index];
			if(high)
				*high = amplitude[index] + bias[index];
			break;
		}
	}

void BaseWaveControl::GetDisplayRanges(float *lo, float *hi) {
	int i;
	float low = 0.0f, high = 0.0f;
	switch(display) {
		case DISP_THIS:
			GetRange(lo, hi, index);
			return;
		case DISP_THISOUT:
			for(i = 0; i <= index; ++i) {
				float l,h;
				if(enabled[i]) {
					GetRange(&l, &h, i);
					switch(effect[i]) {
						case EFFECT_ADD:
							high += h;
							low += l;
							break;
						case EFFECT_MULTIPLY: {
							float hh = high * h;
							float hl = high * l;
							float ll = low * l;
							float lh = low * h;
							high = highestOf(hh, hl, ll, lh);
							low = lowestOf(hh, hl, ll, lh);
							}
							break;
						case EFFECT_CLAMP_ABOVE:
							if(low < l)
								low = l;
							if(high < l)
								high = l;
							break;
						case EFFECT_CLAMP_BELOW:
							if(low > h)
								low = h;
							if(high > h)
								high = h;
							break;
						}
					}
				}
			break;
		case DISP_FINALOUT:
			for(i = 0; i < waves; ++i) {
				float l,h;
				if(enabled[i]) {
					GetRange(&l, &h, i);
					switch(effect[i]) {
						case EFFECT_ADD:
							high += h;
							low += l;
							break;
						case EFFECT_MULTIPLY: {
							float hh = high * h;
							float hl = high * l;
							float ll = low * l;
							float lh = low * h;
							high = highestOf(hh, hl, ll, lh);
							low = lowestOf(hh, hl, ll, lh);
							}
							break;
						case EFFECT_CLAMP_ABOVE:
							if(low < l)
								low = l;
							if(high < l)
								high = l;
							break;
						case EFFECT_CLAMP_BELOW:
							if(low > h)
								low = h;
							if(high > h)
								high = h;
							break;
						}
					}
				}
			break;
		}
	*lo = low;
	*hi = high;
	}

#define WC_WAVES_CHUNK		0x0100
#define WC_INDEX_CHUNK		0x0110
#define WC_NAME_CHUNK		0x0120
#define WC_PERIOD_CHUNK		0x0130
#define WC_DUTY_CHUNK		0x0135
#define WC_AMPLITUDE_CHUNK	0x0140
#define WC_PHASE_CHUNK		0x0150
#define WC_BIAS_CHUNK		0x0160
#define WC_TYPE_CHUNK		0x0170
#define WC_BIASTYPE_CHUNK	0x0180
#define WC_EFFECT_CHUNK		0x0190
#define WC_INVERTED_CHUNK	0x01A0
#define WC_FLIPPED_CHUNK	0x01B0
#define WC_ENABLED_CHUNK	0x01B5
#define WC_DISPLAY_CHUNK	0x01C0
#define WC_RANGE_CHUNK		0x01D0
#define WC_WAVE_ENTRY0		0x1000
#define WC_WAVE_ENTRYN		0x1FFF

IOResult BaseWaveControl::Save(ISave *isave)
	{		
	ULONG nb;	
	int i;

	isave->BeginChunk(WC_WAVES_CHUNK);
	isave->Write(&waves,sizeof(waves),&nb);
	isave->EndChunk();
	
	isave->BeginChunk(WC_INDEX_CHUNK);
	isave->Write(&index,sizeof(index),&nb);
	isave->EndChunk();
	
	for(i = 0; i < waves; ++i) {
		isave->BeginChunk(WC_WAVE_ENTRY0 + i);

		isave->BeginChunk(WC_NAME_CHUNK);
		isave->WriteCString(name[i]);
		isave->EndChunk();

		isave->BeginChunk(WC_PERIOD_CHUNK);
		isave->Write(&period[i],sizeof(float),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_DUTY_CHUNK);
		isave->Write(&duty[i],sizeof(float),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_AMPLITUDE_CHUNK);
		isave->Write(&amplitude[i],sizeof(float),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_PHASE_CHUNK);
		isave->Write(&phase[i],sizeof(float),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_BIAS_CHUNK);
		isave->Write(&bias[i],sizeof(float),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_TYPE_CHUNK);
		isave->Write(&type[i],sizeof(int),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_BIASTYPE_CHUNK);
		isave->Write(&biasType[i],sizeof(int),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_EFFECT_CHUNK);
		isave->Write(&effect[i],sizeof(int),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_INVERTED_CHUNK);
		isave->Write(&inverted[i],sizeof(BOOL),&nb);
		isave->EndChunk();
	
		isave->BeginChunk(WC_FLIPPED_CHUNK);
		isave->Write(&flipped[i],sizeof(BOOL),&nb);
		isave->EndChunk();

		isave->BeginChunk(WC_ENABLED_CHUNK);
		isave->Write(&enabled[i],sizeof(BOOL),&nb);
		isave->EndChunk();

		isave->EndChunk();
		}

	isave->BeginChunk(WC_DISPLAY_CHUNK);
	isave->Write(&display,sizeof(int),&nb);
	isave->EndChunk();

	isave->BeginChunk(WC_RANGE_CHUNK);
	isave->Write(&range,sizeof(range),&nb);
	isave->EndChunk();
	
	return IO_OK;
	}

IOResult BaseWaveControl::Load(ILoad *iload)
	{
	ULONG nb;
	int id, i;
	TCHAR *cp;
	IOResult res = IO_OK;
	while (IO_OK==(res=iload->OpenChunk())) {
		switch (id = iload->CurChunkID()) {
			case WC_WAVES_CHUNK: {
				int newWaves;
				while(waves)
					Delete(waves-1);
				res=iload->Read(&newWaves,sizeof(int),&nb);
				assert(newWaves);
				while(waves < newWaves)
					Insert(0);
				}
				break;

			case WC_INDEX_CHUNK:
				res=iload->Read(&index,sizeof(index),&nb);
				break;

			case WC_DISPLAY_CHUNK:
				res=iload->Read(&display,sizeof(int),&nb);
				break;
			case WC_RANGE_CHUNK:
				res=iload->Read(&range,sizeof(range),&nb);
				break;
			}
		if(id >= WC_WAVE_ENTRY0 && id <= WC_WAVE_ENTRYN) {
			i = id - WC_WAVE_ENTRY0;
			assert(i < waves);
			while (IO_OK == iload->OpenChunk()) {
				switch (iload->CurChunkID()) {
				case WC_NAME_CHUNK:
					iload->ReadCStringChunk(&cp);
					name[i] = cp;
					break;

				case WC_PERIOD_CHUNK:
					res=iload->Read(&period[i],sizeof(float),&nb);
					break;

				case WC_DUTY_CHUNK:
					res=iload->Read(&duty[i],sizeof(float),&nb);
					break;

				case WC_AMPLITUDE_CHUNK:
					res=iload->Read(&amplitude[i],sizeof(float),&nb);
					break;

				case WC_PHASE_CHUNK:
					res=iload->Read(&phase[i],sizeof(float),&nb);
					break;
				case WC_BIAS_CHUNK:
					res=iload->Read(&bias[i],sizeof(float),&nb);
					break;
				case WC_TYPE_CHUNK:
					res=iload->Read(&type[i],sizeof(int),&nb);
					break;
				case WC_BIASTYPE_CHUNK:
					res=iload->Read(&biasType[i],sizeof(int),&nb);
					break;
				case WC_EFFECT_CHUNK:
					res=iload->Read(&effect[i],sizeof(int),&nb);
					break;
				case WC_INVERTED_CHUNK:
					res=iload->Read(&inverted[i],sizeof(BOOL),&nb);
					break;
				case WC_FLIPPED_CHUNK:
					res=iload->Read(&flipped[i],sizeof(BOOL),&nb);
					break;
				case WC_ENABLED_CHUNK:
					res=iload->Read(&enabled[i],sizeof(int),&nb);
					break;
				}	
				iload->CloseChunk();
			}
		}

		iload->CloseChunk();
		if (res!=IO_OK)  return res;
		}
	return IO_OK;
	}


//--------------------------------------------------------------------

RefTargetHandle FloatWaveControl::Clone(RemapDir& remap)
	{
	// make a new controller and give it our param values.
	FloatWaveControl *cont = new FloatWaveControl;
	*cont = *this;	
	return cont;
	}

void FloatWaveControl::GetValueLocalTime(
		TimeValue t, void *val, Interval &valid, GetSetMethod method)
	{
	// This controller is always changing.
	valid.SetInstant(t);
	
	*((float*)val) = WaveAtTime(t,-1);
	}

void FloatWaveControl::Extrapolate(
		Interval range,TimeValue t,void *val,Interval &valid,int type)
	{
	float val0, val1, val2, res;
	switch (type) {
		case ORT_LINEAR:			
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				GetValueLocalTime(range.Start()+1,&val1,valid);
				res = LinearExtrapolate(range.Start(),t,val0,val1,val0);				
			} else {
				GetValueLocalTime(range.End()-1,&val0,valid);
				GetValueLocalTime(range.End(),&val1,valid);
				res = LinearExtrapolate(range.End(),t,val0,val1,val1);
				}
			break;

		case ORT_IDENTITY:
			if (t<range.Start()) {
				GetValueLocalTime(range.Start(),&val0,valid);
				res = IdentityExtrapolate(range.Start(),t,val0);
			} else {
				GetValueLocalTime(range.End(),&val0,valid);
				res = IdentityExtrapolate(range.End(),t,val0);
				}
			break;

		case ORT_RELATIVE_REPEAT:
			GetValueLocalTime(range.Start(),&val0,valid);
			GetValueLocalTime(range.End(),&val1,valid);
			GetValueLocalTime(CycleTime(range,t),&val2,valid);
			res = RepeatExtrapolate(range,t,val0,val1,val2);			
			break;
		}
	valid.Set(t,t);
	*((float*)val) = res;
	}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\Wavectrl\simpwave.h ===
/**********************************************************************
 *<
	FILE: wavectrl.h

	DESCRIPTION:

	CREATED BY: Tom Hudson

	HISTORY:

 *>	Copyright (c) 1996, All Rights Reserved.
 **********************************************************************/

#ifndef __WAVECTRL__H
#define __WAVECTRL__H

#include "Max.h"
#include "resource.h"

extern ClassDesc* GetFloatWaveDesc();

TCHAR *GetString(int id);
extern HINSTANCE hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrml_api.h ===
/**********************************************************************
 *<
	FILE: vrml_api.h

	DESCRIPTION:  simple interface into the vrml exporter

	CREATED BY: greg finch

	HISTORY: created 1 may, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/

#ifndef __VRML_API__H__
#define __VRML_API__H__

struct PreSceneParam {
    int   version;      // just in case we rev. this thing
    int   indent;       // indent level
    Interface*  i;      // MAX's interface pointer
    TCHAR*      fName;  // the name of the output file
};

struct PostSceneParam {
    int   version;      // just in case we rev. this thing
    int   indent;       // indent level
    Interface*  i;      // MAX's interface pointer
    TCHAR*      fName;  // the name of the output file
};

struct PreNodeParam {
    int   version;      // just in case we rev. this thing
    int   indent;       // indent level
    Interface*  i;      // MAX's interface pointer
    TCHAR*      fName;  // the name of the output file
    INode*      node;   // the node
};

struct PostNodeParam {
    int   version;      // just in case we rev. this thing
    int   indent;       // indent level
    Interface*  i;      // MAX's interface pointer
    TCHAR*      fName;  // the name of the output file
    INode*      node;   // the node
};

typedef int  (FAR WINAPI *DllPreScene)(PreSceneParam* p);
typedef void (FAR WINAPI *DllPostScene)(PostSceneParam* p);
typedef int  (FAR WINAPI *DllPostNode)(PostNodeParam* p);
typedef int  (FAR WINAPI *DllPreNode)(PreNodeParam* p);

// Export Callback Support
#define PreSceneCallback    (1<<0)
#define PostSceneCallback   (1<<1)
#define PreNodeCallback     (1<<2)
#define PostNodeCallback    (1<<3)

#define WroteNodeFailed     0
#define WroteNode           (1<<0)
#define WroteNodeChildren   (1<<1)

class CallbackTable {
  public:
    CallbackTable();
    ~CallbackTable();
    
    int     GetKeyCount();
    TCHAR*  GetKey(int i);

    int     GetDllCount();
    TCHAR*  GetDll(int i);

    int         GetDLLHandleCount();
    HMODULE     GetDLLHandle(int i);

    int         GetPreSceneCount();
    DllPreScene GetPreScene(int i);

    int          GetPostSceneCount();
    DllPostScene GetPostScene(int i);

    int         GetPreNodeCount();
    DllPreNode  GetPreNode(int i);

    int         GetPostNodeCount();
    DllPostNode GetPostNode(int i);

    BOOL    GetCallbackMethods(Interface* ip);

  private:
    int     AddKey(TCHAR* s);
    int     AddDll(TCHAR* s);
    int     AddDLLHandle(HMODULE h);
    int     AddPreScene(DllPreScene p);    
    int     AddPostScene(DllPostScene p);
    int     AddPreNode(DllPreNode p);
    int     AddPostNode(DllPostNode p);

    Tab<HMODULE>        mHLibInst;
    Tab<TCHAR*>         mDllKeys;
    Tab<TCHAR*>         mDlls;
    Tab<DllPreScene>    mPreScene;
    Tab<DllPostScene>   mPostScene;
    Tab<DllPreNode>     mPreNode;
    Tab<DllPostNode>    mPostNode;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\aniso.h ===
DWORD dwAnisoVertexShader[] = {
	0x000a2078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x00ac861b, 0x0836186c, 0x21200ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2f300ff8,
	0x00000000, 0x014000ff, 0x27fe486c, 0x21400ff8,
	0x00000000, 0x008de01b, 0x35fe886c, 0x3070f818,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e801
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\maxsdk\SAMPLES\vrmlexp\vrml_api.cpp ===
/**********************************************************************
 *<
	FILE: vrml_api.cpp

	DESCRIPTION:  simple interface into the vrml exporter

	CREATED BY: greg finch

	HISTORY: created 1 may, 1997

 *>	Copyright (c) 1997, All Rights Reserved.
 **********************************************************************/
#include "vrml.h"
#include "vrml_api.h"

CallbackTable::~CallbackTable() {
    mDllKeys.Delete(0, mDllKeys.Count());
    mDllKeys.Shrink();
    mDlls.Delete(0, mDlls.Count());
    mDlls.Shrink();
    mPreScene.Delete(0, mPreScene.Count());
    mPreScene.Shrink();
    mPostScene.Delete(0, mPostScene.Count());
    mPostScene.Shrink();
    mPreNode.Delete(0, mPreNode.Count());
    mPreNode.Shrink();
    mPostNode.Delete(0, mPostNode.Count());
    mPostNode.Shrink();

    for (int i = 0; i < mHLibInst.Count(); i++) {
        FreeLibrary((HMODULE) mHLibInst[i]);
        mHLibInst[i] = NULL;
    }
    mHLibInst.Delete(0, mHLibInst.Count());
    mHLibInst.Shrink();
}

CallbackTable::CallbackTable() { }

int
CallbackTable::AddKey(TCHAR* s) {
    return mDllKeys.Insert(mDllKeys.Count(), 1, &s);
}

int
CallbackTable::GetKeyCount() {
    return mDllKeys.Count();
}

TCHAR*
CallbackTable::GetKey(int i) {
    return mDllKeys[i];
}

int
CallbackTable::AddDll(TCHAR* s) {
    return mDlls.Insert(mDlls.Count(), 1, &s);
}

int
CallbackTable::GetDllCount() {
    return mDlls.Count();
}

TCHAR*
CallbackTable::GetDll(int i) {
    return mDlls[i];
}

int
CallbackTable::AddPreScene(DllPreScene p) {
    return mPreScene.Insert(mPreScene.Count(), 1, &p);
}

int
CallbackTable::GetPreSceneCount() {
    return mPreScene.Count();
}

DllPreScene
CallbackTable::GetPreScene(int i) {
    return mPreScene[i];
}

int
CallbackTable::AddPostScene(DllPostScene p) {
    return mPostScene.Insert(mPostScene.Count(), 1, &p);
}

int
CallbackTable::GetPostSceneCount() {
    return mPostScene.Count();
}

DllPostScene
CallbackTable::GetPostScene(int i) {
    return mPostScene[i];
}


int
CallbackTable::AddPreNode(DllPreNode p) {
    return mPreNode.Insert(mPreNode.Count(), 1, &p);
}

int
CallbackTable::GetPreNodeCount() {
    return mPreNode.Count();
}

DllPreNode
CallbackTable::GetPreNode(int i) {
    return mPreNode[i];
}

int
CallbackTable::AddPostNode(DllPostNode p) {
    return mPostNode.Insert(mPostNode.Count(), 1, &p);
}

int
CallbackTable::GetPostNodeCount() {
    return mPostNode.Count();
}

DllPostNode
CallbackTable::GetPostNode(int i) {
    return mPostNode[i];
}

int
CallbackTable::AddDLLHandle(HMODULE h) {
    return mHLibInst.Insert(mHLibInst.Count(), 1, &h);
}

int
CallbackTable::GetDLLHandleCount() {
    return mHLibInst.Count();
}

HMODULE
CallbackTable::GetDLLHandle(int i) {
    return mHLibInst[i];
}

BOOL
CallbackTable::GetCallbackMethods(Interface* ip) {
    int i;
    LPCTSTR     lpSection = "Dlls";
    LPCTSTR     lpKey = NULL;
    LPCTSTR     lpDefault = "none";
    TCHAR       lpBuf[MAX_PATH];
    DWORD       nSize = sizeof(lpBuf);
    
    TCHAR*      maxPlugCfgPath = ip->GetDir(APP_PLUGCFG_DIR);
    TCHAR       lpINIFileName[MAX_PATH];
    sprintf(lpINIFileName, _T("%s\\%s"), maxPlugCfgPath, "vrmlexp.ini"); 

 // see if the INI files exists.
    WIN32_FIND_DATA file;
    HANDLE          findhandle = FindFirstFile(lpINIFileName, &file);
    FindClose(findhandle);
    if (findhandle == INVALID_HANDLE_VALUE) {
        /*  if the .ini file is missing assume they aren't using the API
        TSTR buf = "couldn't find INI file";
	    MessageBox(GetActiveWindow(), buf, " ", MB_OK|MB_TASKMODAL);
        */
        return FALSE;
    }

 // get dllKeys
    GetPrivateProfileString(lpSection, lpKey, lpDefault, (LPTSTR) lpBuf, nSize, (LPCTSTR) lpINIFileName);
    TCHAR* tmpPtr = lpBuf;
    while (tmpPtr[0] != '\0') {
        TCHAR* dllKey = (TCHAR*) malloc(strlen(tmpPtr) * sizeof(TCHAR));
        strcpy(dllKey, tmpPtr);
        AddKey(dllKey);
        tmpPtr = strchr(tmpPtr, '\0') + 1;
    }

 // check validity of INI file
    if (!lstrcmp(lpBuf, "none")) {
        TSTR buf = "couldn't find [dlls] section in INI file";
	    MessageBox(GetActiveWindow(), buf, " ", MB_OK|MB_TASKMODAL);
        return FALSE;
    }

 // get dlls
    for (i = 0; i < GetKeyCount(); i++) {
        GetPrivateProfileString(lpSection, GetKey(i), lpDefault, (LPTSTR) lpBuf, nSize, lpINIFileName);
        TCHAR* dllPtr = (TCHAR*) malloc(strlen(lpBuf) * sizeof(TCHAR));
        strcpy(dllPtr, lpBuf);
        AddDll(dllPtr);
    }

 // load the dlls
    for (i = GetDllCount(); i--; ) {
        HINSTANCE   libInst = (HINSTANCE) LoadLibraryEx(GetDll(i), NULL, 0);
	    if (libInst)
	    {
            AddDLLHandle(libInst);
            FARPROC lpCallbackType   = NULL;
            FARPROC lpProc      = NULL;
            TCHAR   lpStr[64];
            int     CallbackType;

            lpCallbackType = GetProcAddress((HMODULE) libInst, (LPCSTR) "ExportLibSupport"); 
            if (lpCallbackType) {
    		    CallbackType = (*(lpCallbackType))();
            }

         // Export Lib support for pre-scene export
            if (PreSceneCallback & CallbackType) {
                strcpy(lpStr, "PreSceneExport");
                DllPreScene lpProc = (DllPreScene) GetProcAddress((HMODULE) libInst, (LPCSTR) lpStr);
                if(!lpProc) {
                   TCHAR buf[256];
                    sprintf(buf, "method %s not implimented", lpStr);
	                MessageBox(GetActiveWindow(), buf, "Export Lib", MB_OK|MB_TASKMODAL);
                }
                AddPreScene(lpProc);
            }

         // Export Lib support for post-scene export
            if (PostSceneCallback & CallbackType) {
                strcpy(lpStr, "PostSceneExport");
                DllPostScene lpProc = (DllPostScene) GetProcAddress((HMODULE) libInst, (LPCSTR) lpStr);
                if(!lpProc) {
                   TCHAR buf[256];
                    sprintf(buf, "method %s not implimented", lpStr);
	                MessageBox(GetActiveWindow(), buf, "Export Lib", MB_OK|MB_TASKMODAL);
                }
                AddPostScene(lpProc);
            }

         // Export Lib support for pre-node export
            if (PreNodeCallback & CallbackType) {
                strcpy(lpStr, "PreNodeExport");
                DllPreNode lpProc = (DllPreNode) GetProcAddress((HMODULE) libInst, (LPCSTR) lpStr);
                if(!lpProc) {
                   TCHAR buf[256];
                    sprintf(buf, "method %s not implimented", lpStr);
	                MessageBox(GetActiveWindow(), buf, "Export Lib", MB_OK|MB_TASKMODAL);
                }
                AddPreNode(lpProc);
            }

         // Export Lib support for post-node export
            if (PostNodeCallback & CallbackType) {
                strcpy(lpStr, "PostNodeExport");
                DllPostNode lpProc = (DllPostNode) GetProcAddress((HMODULE) libInst, (LPCSTR) lpStr);
                if(!lpProc) {
                   TCHAR buf[256];
                    sprintf(buf, "method %s not implimented", lpStr);
	                MessageBox(GetActiveWindow(), buf, "Export Lib", MB_OK|MB_TASKMODAL);
                }
                AddPostNode(lpProc);
            }
        } else {
            TCHAR buf[256];
            sprintf(buf, "Lib [%s] Load Failed", GetDll(i));
	        MessageBox(GetActiveWindow(), buf, "Export Lib", MB_OK|MB_TASKMODAL);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\wmaenc\wmfencode.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmfencode.h

Abstract:

    API's for light WMF SDK Encoder.

Revision History:


*************************************************************************/


#ifndef _WMF_ENCODE_H_
#define _WMF_ENCODE_H_

#ifdef __cplusplus
extern "C" {  // only need to export C interface if
              // used by C++ source code
#endif

#include "wmf_types.h"
typedef void* HWMFENCODER;


/*********  Video coding mode  *********/

typedef enum tagVideoCodingMode_WMF
{
    WMF_OnePass_CBR = 0,
    WMF_TwoPass_CBR, // not supported now
    WMF_OnePass_VBR,
    WMF_TwoPass_VBR
} VideoCodingMode_WMF;

/*****************************************/


/*************  Statistics  *************/

typedef struct strCodingStats_WMF
{
// video
    U32_WMF    dwVideoFourCC;
    Double_WMF dbVideoTotalNumBytes;
    Double_WMF dbVideoAverageBitrate;
    U32_WMF    dwVideoNumTotalFrame;
    U32_WMF    dwVideoNumCodedFrame;
    Double_WMF dbVideoAverageFrameRate;
    U32_WMF    dwVideoBufferDelay;
    U32_WMF    dwVideoKeyFrameDistance;
// audio
    Double_WMF dbAudioTotalNumBytes;
    U32_WMF    dwAudioPayloadSize;
    U32_WMF    dwAudioAverageBitrate;
    U32_WMF    dwAudioSamplingRate;
    U32_WMF    dwAudioChannelNum;

// overall
    U32_WMF    dwMinRateGivenBufferSize;
    U32_WMF    dwMinBufferSizeGivenAvgRate;
    Double_WMF dbTotalNumBytes;
    U32_WMF    dwPacketSize;
    U32_WMF    dwPaddingBytes;
} CodingStats_WMF;

/*****************************************/

/******  Video pre-processing types  *****/

typedef enum tagVideoPreProcessType_WMF
{
    WMF_NoPreProcess = 0,
    WMF_PreserveSize, // (e.g., 640x480x30fps interlaced to 640x480x30fps progressive)
    WMF_HalfSize, // (e.g., 640x480x30fps interlaced to 320x240x30fps progressive)
    WMF_HalfSizeAndDoubleFrameRate, // (e.g., 640x480x30fps interlaced to 320x240x60fps progressive)
    WMF_VerticalHalfSizeAndDoubleFrameRate, // (e.g., 320x480x30fps interlaced to 320x240x60fps progressive)
    WMF_InverseTelecine // (e.g., 640x480x30fps telecined to 640x480x24fps progressive)
} VideoPreProcessType_WMF;

/*****************************************/



/*********  Return status code  *********/
#ifndef EXTERN_C
#ifdef __cplusplus
#define EXTERN_C extern "C"
#else 
#define EXTERN_C extern 
#endif
#endif

typedef enum tagWMFEncodeStatus
{
    WMF_Succeeded = 0,
    WMF_Failed,
    WMF_BadMemory,
    WMF_InValidArguments,
    WMF_EncPacketsDone,
    WMF_BadOutputFile,

    WMA_Failed,
    WMA_BadMemory,
    WMA_EncodeFailed,
    WMA_UnSupportedInputFormat,
    WMA_UnSupportedCompressedFormat,
    WMA_InValidArguments,
    WMA_BadSource,

    WMV_Failed,
    WMV_BadMemory,
    WMV_EncodeFailed,
    WMV_UnSupportedInputFormat,
    WMV_UnSupportedCompressedFormat,
    WMV_InValidArguments,
    WMV_BadSource,
    WMV_BadFileWrite

} tWMFEncodeStatus;

/*****************************************/


/*********  Encoding profiles  ***********/

typedef enum tagWMFEncodeProfile
{
    Profile_AudioVideo_Modem_28K = 0, // 20K actual bitrate
    Profile_AudioVideo_Modem_56K, // 32K actual bitrate
    Profile_AudioVideo_LAN_100K,
    Profile_AudioVideo_LAN_256K, // 225K 
    Profile_AudioVideo_LANDSL_384K, // 350K
    Profile_AudioVideo_LANDSL_768K, // 450K
    Profile_AudioVideo_NearBroadCast_700K,
    Profile_AudioVideo_NearBroadCast_1400K,
    Profile_AudioVideo_Broadband_PAL_384K, // 350K
    Profile_AudioVideo_NearBroadCast_PAL_700K,
    Profile_AudioVideo_LAN_100K_2Pass, // 100K
    Profile_AudioVideo_LANDSL_384K_2Pass, // 350K
    Profile_AudioVideo_FilmVBR_600K, // 600K
    Profile_AudioVideo_FilmVBR_Quality97,
    Profile_AudioOnly_FMRadioMono_28K, // for 288 modem
    Profile_AudioOnly_FMRadioStereo_28K, // for 288 modem
    Profile_AudioOnly_Modem_56K, // for 56K modem
    Profile_AudioOnly_NearCDQuality_48K,
    Profile_AudioOnly_CDQuality_64K,
    Profile_AudioOnly_CDAudiophileQuality_96K,
    Profile_AudioOnly_CDAudiophileQuality_128K,
    Profile_VideoOnly_Modem_28K, // 20K
    Profile_VideoOnly_Modem_56K, // 32K actual bitrate
    Profile_Total_Numbers
} WMFEncodeProfile;

/*****************************************/

/*********  Profile parameter details  *********/

typedef struct tpProfileParameters_WMF
{
    I32_WMF dwAudioBitRate;
    U32_WMF nDstChannels; 
    U32_WMF nDstSamplesPerSec;
#if defined (ENABLE_WMAV3)
    U32_WMF nDstChannelMask;
    U32_WMF nAudioBitstreamVersion;
#endif // ENABLE_WMAV3

    I32_WMF dwVideoBitRate;
    Double_WMF dbDstFrameRate;
    U32_WMF uiPictureQuality;
    U32_WMF uiDelayBuffer;
    U32_WMF biDstWidth; 
    U32_WMF biDstHeight; 
    U32_WMF biDstCompression; 
    U32_WMF uiKeyFrameDistance;
    VideoCodingMode_WMF tVideoCodingMode;
    VideoPreProcessType_WMF tVideoPreProcMode;
} ProfileParameters_WMF;

/*****************************************/

/***************************  Call back functions  *******************************/

/*
 *        WMFCBGetAudioData
 *        ===============
 *
 * Description
 * -----------
 * Call back funtion from the SDK to get the requested audio data from the app.
 * The app is responsible for implementing this funtion. SDK calls this funtion to get the audio data while encoding.
 *
 * Arguments
 * ---------
 *
 *   ppbAudioDataBuffer     The memory buffer that the app should write the audio data to. The app can change the pointer if necessary.
 *   nInputBufferLen        Length  of the buffer space (in bytes).
 *   iSampleOffset          Offset (from the beginning, in number of samples) that the requested audio data starts.
 *   iNumSamplesWanted      Number of audio samples requested to be filled in pbAudioDataBuffer.
 *
 * Return Value
 * ------------
 *   Int                    Number of samples returned from app.
 *
 */

EXTERN_C I32_WMF WMFCBGetAudioData (U8_WMF **pbAudioDataBuffer, U32_WMF nInputBufferLen, I64_WMF iSampleOffset, I32_WMF iNumSamplesWanted);


/*
 *        WMFCBGetVideoData
 *        ===============
 *
 * Description
 * -----------
 * Call back funtion from the SDK to get the requested video data from the app.
 * The app is responsible for implementing this funtion. SDK calls this funtion to get the video data while encoding.
 *
 * Arguments
 * ---------
 *
 *   ppbVideoDataBuffer     The memory buffer that the app should write the video data to. The app can change the pointer if necessary.
 *   nInputBufferLen        Length  of the buffer space (in bytes).
 *   i64DesiredTS           Desired Time Stamp
 *   pi64TimeStamp          Time Stamp of the return frame
 *
 * Return Value
 * ------------
 *   Int                    Number of number of bytes returned from app.
 *
 */

EXTERN_C I32_WMF WMFCBGetVideoData (U8_WMF **ppbVideoDataBuffer, U32_WMF nInputBufferLen, I64_WMF i64DesiredTS, I64_WMF *pi64TimeStamp);


/*********************************************************************************/

/***************************  FUNCTIONS  *******************************/

/*
 *        WMFGetRecommendedVideoFrameRate
 *        ===============================
 *
 * Description
 * -----------
 * Get a recommended frame rate (frames per second) from the SDK. This is an OPTIONAL funtion call.
 * This function is expected to be called before WMFCreateEncoderUsingCustom of WMFCreateEncoderUsingProfile.
 *
 * Arguments
 * ---------
 *
 *   piRecommendedFPS       Pointer to the value recommended (set) by SDK.
 *   dwVideoBitRate         Bitrate for video to be encoded.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMV_InValidArguments   Bad argument passed in (bitrate out of range).
 *
 */

tWMFEncodeStatus WMFGetRecommendedVideoFrameRate (I32_WMF *piRecommendedFPS, I32_WMF dwVideoBitRate);


/***************************  FUNCTIONS  *******************************/

/*
 *        WMFGetProfileDetails
 *        ====================
 *
 * Description
 * -----------
 * Get the parameter details for a profile.
 *
 * Arguments
 * ---------
 *
 *   tProfile               Profile number.
 *   ptProfilePara          Profile structure to be filled in.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMV_InValidArguments   Bad argument passed in (bitrate out of range).
 *
 */

tWMFEncodeStatus WMFGetProfileDetails (WMFEncodeProfile tProfile, ProfileParameters_WMF *ptProfilePara);

/*
 *        WMFIsThereAudioStream
 *        =====================
 *
 * Description
 * -----------
 * Return the property of the encoder event. Return if the event contains an audio stream.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   bIsThereAudio          Pointer to the value set by SDK.
 *                          * TRUE: There is an audio stream.
 *                          * FALSE: There is no audio stream.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMF_BadMemory          hWMFEnc is bad.
 *
 */

tWMFEncodeStatus WMFIsThereAudioStream (Bool_WMF *bIsThereAudio, HWMFENCODER hWMFEnc);

/*
 *        WMFIsThereVideoStream
 *        =====================
 *
 * Description
 * -----------
 * Return the property of the encoder event. Return if the event contains a video stream.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   bIsThereVideo          Pointer to the value set by SDK.
 *                          * TRUE: There is a video stream.
 *                          * FALSE: There is no video stream.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Funtion succeeds.
 *   WMF_BadMemory          hWMFEnc is bad.
 *
 */

tWMFEncodeStatus WMFIsThereVideoStream (Bool_WMF *bIsThereVideo, HWMFENCODER hWMFEnc);

/*
 *        WMFCreateEncoderUsingCustom
 *        ===========================
 *
 * Description
 * -----------
 * Create the WMF encoder using the specified custom settings for audio and video.
 *
 * Arguments
 * ---------
 *
 *   ptStatus               Pointer to the status of encoder creation.  It can be one of the value in tagWMFEncodeStatus.
 *   pchOutFilename         Pointer to the name of the encoded ASF file.
 *
 *********  The following are the audio properties.
 *
 *   dwAudioBitRate         Bitrate for the audio (in bits per second).
 *                          * The SDK enumerates this rate and pick the closest one in the list.
 *                          * Value 0 is for video only (no audio) ASF file. The properties (arguments) for audio will be ignored.
 *   nSrcChannels           Number of channels in the source file (valid number: 1 or 2).
 *   nSrcSamplesPerSec      Sampling rate in the source file.  The SDK enumerates this rate and pick the closest one in the list.
 *   wSrcBitsPerSample      Bits per PCM sample (resolution) in the source file.  The SDK only accepts 16-bit input.
 *   nSrcDataLen            Data length (in bytes) of the source audio file.
 *   puiAudioSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode audio. 
 *                          The app is recommended to use this value to allocate a memory space for audio source data.
 *   nDstChannels           Number of channels for the encoded (destination) output (valid number: 1 or 2).
 *   nDstSamplesPerSec      Sampling rate for the encoded output.  The SDK enumerates this rate and pick the closest one in the list.
 *   pdwActualAudioBitrate
 *   pnActualDstChannels
 *   pnActualDstSamplesPerSec
 *
 *********  The following are the video properties.
 *
 *   dwVideoBitRate         Bitrate for the video (in bits per second).
 *                          * Value 0 is for audio only (no vidio) ASF file.
 *                          * dwAudioBitRate and dwVideoBitRate can't be zero at the same time.
 *   dbSrcFrameRate         Frame rate of the source video.
 *   biSrcWidth             Width of the source bitmap.
 *   biSrcHeight            Height of the source bitmap.
 *   prctClipRegion         The region (Rect) to be encoded in each frame. It is ignored if the region is not valid or biggeer than the original.
 *   biSrcBitCount          Bits per pixel of the source bitmap.
 *   biSrcCompression       The pixel (color) format of the source bitmap.  The SDK accepts the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_I420		        
 *                          * FOURCC_IYUV		        
 *                          * FOURCC_YV12		        
 *                          * FOURCC_YUY2		        
 *                          * FOURCC_UYVY		        
 *                          * FOURCC_YVYU		        
 *                          * FOURCC_YVU9
 *                          * FOURCC_BI_RGB   	    
 *                          * FOURCC_BI_BITFIELDS	    
 *   qwDuration             Encoding Duration in ms  .
 *   nColor                 Number of colors in palette, Used for 8 bits case only.
 *   pbColors               Pointer to the start of Palette. Used for 8 bits case only. 			
 *   puiVideoSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode video. 
 *                          The app is recommended to use this value to allocate a memory space for video source data.
 *   dbDstFrameRate         Encoded (output) frame rate. It is recommended to call WMFGetRecommendedVideoFrameRate to get a proper rate.
 *   biDstWidth             Width of the encoded bitmap.
 *   biDstHeight            Height of the encoded bitmap.
 *   biDstCompression       Compression type of the encoded video.  The SDK encoded to one of the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_WMV1   	    
 *                          * FOURCC_WMV2   	    
 *   uiPictureQuality       The degree of smoothness/picture quality of the encoded video. This is a tradeoff between the individual image frame and number of encoded frames.
 *                          The valid range of uiSmoothness is 0 to 100, 0 being the smoothest. 0 is recommended for most of the cases unless image quality is specifically emphasized.
 *   uiKeyFrameDistance     The maximum key frame distance of the encoded video.  The unit is in seconds.
 *                          Note that this is the maximum distance since the encoder might decide to add key frames anytime.
 *                          But it is guaranteed that there must be a key frame in 8s.
 *   uiDelayBuffer          The delay/buffer time of the video.  The unit is in milliseconds.
 *                          This determines the pre-roll time when playing back the file in an ASF player.

 *
 * Return Value
 * ------------
 *   HWMFENCODER            Handle to the encoder. NULL if anything goes wrong during the creation.
 *
 */


HWMFENCODER WMFCreateEncoderUsingCustom (
        tWMFEncodeStatus*      ptStatus,
        I8_WMF                 *pchOutFilename,
// audio properties
        I32_WMF                dwAudioBitRate,
        U32_WMF                nSrcChannels,
        U32_WMF                nSrcSamplesPerSec,  
        U32_WMF                wSrcBitsPerSample,  
        U64_WMF                nSrcDataLen,
        U32_WMF*               puiAudioSrcSizeNeeded,
        U32_WMF                nDstChannels,
        U32_WMF                nDstSamplesPerSec,  
        U32_WMF*               pdwActualAudioBitrate,
        U32_WMF*               pnActualDstChannels,
        U32_WMF*               pnActualDstSamplesPerSec,
#if defined (ENABLE_WMAV3)
        U32_WMF                nSrcValidBitsPerSample,
        U32_WMF                nSrcChannelMask,
        U32_WMF                nDstChannelMask,
		U32_WMF                nAudioBitstreamVersion,
#endif // ENABLE_WMAV3
// video properties
    // source/input
        Double_WMF             dbSrcFrameRate,
        U32_WMF                biSrcWidth,
        U32_WMF                biSrcHeight,
        Rect_WMF               *prctClipRegion,
        U32_WMF                biSrcBitCount,
        U32_WMF                biSrcCompression,
        U64_WMF                qwDuration,
        U32_WMF                nColors,
        U8_WMF                 *pbColors,
        U32_WMF                *puiVideoSrcSizeNeeded,
        VideoPreProcessType_WMF tVideoProcess,
    // destination (output)
        Double_WMF             dbDstFrameRate,
        U32_WMF                biDstWidth,
        U32_WMF                biDstHeight,
        U32_WMF                biDstCompression,

        VideoCodingMode_WMF    tVideoCodingMode, // VBR, CBR, etc.
        I32_WMF                dwVideoBitRate, // in bits per second
        U32_WMF                uiPictureQuality, // 0 to 100, 0 being the smoothest
        U32_WMF                uiKeyFrameDistance, // in seconds
        U32_WMF                uiDelayBuffer, // in milliseconds
        I8_WMF *             chModifiedFileName

        // source is interlaced
//        U32_WMF                biDeInterlace // DeInterlace

);


/*
 *        WMFCreateEncoderUsingProfile
 *        ============================
 *
 * Description
 * -----------
 * Create the WMF encoder using one of the profiles specified in tagWMFEncodeProfile.
 *
 * Arguments
 * ---------
 *
 *   ptStatus               Pointer to the status of encoder creation.  It can be one of the value in tagWMFEncodeStatus.
 *   pchOutFilename         Pointer to the name of the encoded ASF file.
 *   tProfile               One of the encoding profile specified in tagWMFEncodeProfile
 *
 *********  The following are the audio properties.
 *
 *   nSrcChannels           Number of channels in the source file (valid number: 1 or 2).
 *   nSrcSamplesPerSec      Sampling rate in the source file.  The SDK enumerates this rate and pick the closest one in the list.
 *   wSrcBitsPerSample      Bits per PCM sample (resolution) in the source file.  The SDK only accepts 16-bit input.
 *   nSrcDataLen            Data length (in bytes) of the source audio file.
 *   puiAudioSrcSizeNeeded  Pointer to the value (in bytes) that SDK sets for the app for the source size needed to encode audio.
 *
 *********  The following are the video properties.
 *
 *   dbSrcFrameRate         Frame rate of the source video.
 *   biSrcWidth             Width of the source bitmap.
 *   biSrcHeight            Height of the source bitmap.
 *   prctClipRegion         The region (Rect) to be encoded in each frame. It is ignored if the region is not valid or biggeer than the original.
 *   biSrcBitCount          Bits per pixel of the source bitmap.
 *   biSrcCompression       The pixel (color) format of the source bitmap.  The SDK accepts the following types (in preference order). (See definitions above for the types.)
 *                          * FOURCC_I420		        
 *                          * FOURCC_IYUV		        
 *                          * FOURCC_YV12		        
 *                          * FOURCC_YUY2		        
 *                          * FOURCC_UYVY		        
 *                          * FOURCC_YVYU		        
 *                          * FOURCC_YVU9
 *                          * FOURCC_BI_RGB   	    
 *                          * FOURCC_BI_BITFIELDS	    
 *   qwDuration             Encoding Duration in ms  .
 *   puiVideoSrcSizeNeeded  Pointer to the value that SDK returns to app for the source size needed to encode video. 
 *                          The app is recommended to use this value to allocate a memory space for video source data.
 *
 *
 * Return Value
 * ------------
 *   HWMFENCODER            Handle to the encoder. NULL if anything goes wrong during the creation.
 *
 */

HWMFENCODER WMFCreateEncoderUsingProfile (
        tWMFEncodeStatus     *ptStatus,
        I8_WMF               *pchOutFilename,
        WMFEncodeProfile     tProfile,

// audio input source properties
        U32_WMF              nSrcChannels,
        U32_WMF              nSrcSamplesPerSec,  
        U32_WMF              wSrcBitsPerSample,  
        U64_WMF              nSrcDataLen,
        U32_WMF              *puiAudioSrcSizeNeeded,
#if defined (ENABLE_WMAV3)
        U32_WMF              nSrcValidBitsPerSample,
        U32_WMF              nSrcChannelMask,
#endif // ENABlE_WMAV3

// video properties
        Double_WMF           dbSrcFrameRate,
        U32_WMF              biSrcWidth,
        U32_WMF              biSrcHeight,
        Rect_WMF             *prctClipRegion,
        U32_WMF              biSrcBitCount,
        U32_WMF              biSrcCompression,
        U64_WMF              qwDuration,
        U32_WMF              nColors,
        U8_WMF               *pbColors,
        U32_WMF              *puiVideoSrcSizeNeeded,
        VideoPreProcessType_WMF VideoProcess,
        I8_WMF *             chModifiedFileName

);

/*
 *        WMFPutContentDescriptions
 *        =========================
 *
 * Description
 * -----------
 * Put content descriptions in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   pchTitle               Title info.
 *   nLengthTitle           Length of title info.
 *   pchAuthor              Author info,
 *   nLengthAuthor          Length of author info.
 *   pchDescription         Description info,
 *   nLengthDescription     Length of Description info.
 *   pchCopyrigtht          Copyrigtht info,
 *   nLengthCopyrigtht      Length of Copyrigtht info.
 *   pchRating              Rating info,
 *   nLengthRating          Length of Rating info.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_Failed            Function fails.
 *
 */

tWMFEncodeStatus WMFPutContentDescriptions (
        HWMFENCODER hWMFEnc, 
//        const WMFContentDescription* pContentDesc
        const U16Char_WMF *pchTitle, U32_WMF nLengthTitle,
        const U16Char_WMF *pchAuthor, U32_WMF nLengthAuthor,
        const U16Char_WMF *pchDescription, U32_WMF nLengthDescription,
        const U16Char_WMF *pchCopyrigtht, U32_WMF nLengthCopyrigtht,
        const U16Char_WMF *pchRating, U32_WMF nLengthRating
);

/*            WMFPutScriptCommands
 * Description
 * -----------
 * Put script commands in the encoded ASF file
 * arguments:
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   nCommands              number of commands
 *   nTypes                 number of types of commands, such as URL
 *   ppTypeNames            type names
 *   CommandEntry           command entries

 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArgument    Function fails due to invalid arguments
 */

tWMFEncodeStatus WMFPutScriptCommands (				  
        HWMFENCODER         hWMFEnc,
        U16_WMF             nCommands,
        U16_WMF             nTypes,
        U16Char_WMF         **ppTypeNames,
        const CommandEntry  *pCommands
);

/*
 *        WMFPutExtendedContentDesc
 *        =========================
 *
 * Description
 * -----------
 * Put extended content descriptions in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   nDescriptors           number of descriptors
 *   pDescriptors           pointer to the descriptor structure

 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArguments   Invalid arguments
 *   WMF_BadMemory          memory allocation problem
 */

tWMFEncodeStatus WMFPutExtendedContentDesc(
        HWMFENCODER         hWMFEnc,
        U16_WMF             nDescriptors,
        ECD_DESCRIPTOR      *pDescriptors
);

/*
 *        WMFPutMarkers
 *        =============
 *
 * Description
 * -----------
 * Put Markers in the encoded ASF file (in overhead).
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                    Handle of the encoder created in WMFCreateEncoder.
 *   wNumMarkers                number of MarkerEntry
 *   WORD  wNameLen             length of marker object name in wchar unit includeing terminating zero  
 *   const wchar *pchMarkerName pointer to the name of this Marker object
 *   pMarkers                   pointer to the MarkerEntry structure
 *                              For MarkerEntry,  You just need to fill in the following fields
 *      m_qtime                 Presentation time (Unit 1/10000000 sec)
 *      m_dwDescLen             Length of Description name in wchar unit includeing terminating zero
 *      m_pwDescName            Description name
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Function succeeds.
 *   WMF_InValidArguments   Invalid arguments
 *   WMF_BadMemory          memory allocation problem
 */

tWMFEncodeStatus WMFPutMarkers(
    HWMFENCODER hWMFEnc, 
    U32_WMF dwNumMarkers,  
    U16_WMF  wNameLen,
    const U16Char_WMF *pchMarkerName,
    MarkerEntry *pMarkers
);

/*
 *        WMFEncode
 *        =========
 *
 * Description
 * -----------
 * Encode the input audio and video data to ASF file using the specified settings in WMFCreateEncoderUsingCustom.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   pbAudioBuffer          Pointer to the memory allocated by the app to hold the audio data to be encoded.
 *                          The SDK has a call back function to the app to request to fill in this memory with audio data to be encoded.
 *   pnAudioBufferSize      Size (in bytes) of the pbAudioBuffer.
 *   pbVideoBuffer          Pointer to the memory allocated by the app to hold the video data to be encoded.
 *                          The SDK has a call back function to the app to request to fill in this memory with video data to be encoded.
 *   pnVideoBufferSize      Size (in bytes) of the pbVideoBuffer.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Encode succeeds.
 *   
 *   WMA_Failed             Audio fails.
 *   WMA_BadMemory          Audio part has bad memory.
 *   WMA_EncodeFailed       Audio encode fails.
 *   WMA_InValidArguments   Audio part has invalid arguments.
 *   WMA_BadSource          Audio source data is bad.

 *   WMV_Failed             Video fails.
 *   WMV_BadMemory          Video part has bad memory.
 *   WMV_EncodeFailed       Video encode fails.
 *   WMV_InValidArguments   Video part has invalid arguments.
 *   WMV_BadSource          Video source data is bad.
 *
 */

tWMFEncodeStatus WMFEncode (
    HWMFENCODER hWMFEnc, 
    U8_WMF* pbAudioBuffer, U32_WMF pnAudioBufferSize, 
    U8_WMF* pbVideoBuffer, U32_WMF pnVideoBufferSize
);


/*
 *        WMFClose
 *        ========
 *
 * Description
 * -----------
 * Close the encoder.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Close succeeds.
 *   WMF_BadMemory          Memory is bad.
 *
 */

tWMFEncodeStatus WMFClose (HWMFENCODER hWMFEnc);

/*
 *        WMFGetStats
 *        ===========
 *
 * Description
 * -----------
 * Get the Eencoding Status.
 *
 * Arguments
 * ---------
 *
 *   hWMFEnc                Handle of the encoder created in WMFCreateEncoder.
 *   pCodingStats           Pointer to a CodingStats_WMF to hold the status
 *
 * Return Value
 * ------------
 *   WMF_Succeeded          Succeeds.
 *   WMF_Failed             Fail.
 *
 */

tWMFEncodeStatus WMFGetStats (HWMFENCODER hWMFEnc, CodingStats_WMF* pCodingStats);

#ifdef __cplusplus
}
#endif

#endif // _WMF_ENCODE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\wrl2xm\wrl2xm.cpp ===
// wrl2xm.cpp : Defines the entry point for the console application.
//

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,

    D3DPT_FORCE_DWORD           = 0x7fffffff
} D3DPRIMITIVETYPE;


#define D3DFVF_XYZ              0x002
#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_TEX1             0x100


typedef DWORD D3DCOLOR;

#define D3DCOLOR_ARGB(a,r,g,b) \
    ((D3DCOLOR)((((a)&0xff)<<24)|(((r)&0xff)<<16)|(((g)&0xff)<<8)|((b)&0xff)))

#define D3DCOLOR_RGBA(r,g,b,a) D3DCOLOR_ARGB(a,r,g,b)

#define D3DCOLOR_COLORVALUE(r,g,b,a) \
    D3DCOLOR_RGBA((DWORD)((r)*255.f),(DWORD)((g)*255.f),(DWORD)((b)*255.f),(DWORD)((a)*255.f))


enum FIELDTYPE
{
	MFColor,
	MFFloat,
	MFInt32,
	MFNode,
	MFRotation,
	MFString,
	MFTime,
	MFVec2f,
	MFVec3f,
	SFBool,
	SFColor,
	SFFloat,
	SFImage,
	SFInt32,
	SFNode,
	SFRotation,
	SFString,
	SFTime,
	SFVec2f,
	SFVec3f
};

struct FieldDesc
{
	char* m_szFieldID;
	FIELDTYPE m_type;
};

#define FIELDDESC(foo, type, name, def) { #name, type },
#define START_FIELDS(name) FieldDesc name##Fields [] = {
#define END_FIELDS() };

struct NodeDesc
{
	char* m_szNodeTypeID;
	int m_nFieldCount;
	FieldDesc* m_rgfields;
};

#define NODEDESC(name) { #name, sizeof (name##Fields) / sizeof (FieldDesc), name##Fields },


void LegalizeFileName(char* szDest, const char* szSrc)
{
	for (;;)
	{
		if (*szSrc == '/' || *szSrc == '>' || *szSrc == '<' || *szSrc == '|' || *szSrc == '+')
			*szDest = '_';
		else
			*szDest = *szSrc;

		if (*szSrc == 0)
			return;

		szDest += 1;
		szSrc += 1;
	}
}

class CVrmlNode;

struct CNodeValue
{
};

struct CNodeValueArray : public CNodeValue
{
	CNodeValueArray()
	{
		m_nAlloc = 0;
		m_nCount = 0;
		m_values = NULL;
	}

	~CNodeValueArray()
	{
	}

	void Add(CNodeValue* pNewValue)
	{
		if (m_nCount + 1 > m_nAlloc)
		{
			m_nAlloc += 1024;
			CNodeValue** values = new CNodeValue* [m_nAlloc];
			CopyMemory(values, m_values, sizeof (CNodeValue*) * m_nCount);
			delete [] m_values;
			m_values = values;
		}

		m_values[m_nCount] = pNewValue;
		m_nCount += 1;
	}

	int m_nAlloc;
	int m_nCount;
	CNodeValue** m_values;
};

struct VSFBool : public CNodeValue
{
	bool m_value;
};

struct VSFColor : public CNodeValue
{
	float m_red, m_green, m_blue;
};

struct VSFFloat : public CNodeValue
{
	float m_value;
};

struct VSFImage : public CNodeValue
{
};

struct VSFInt32 : public CNodeValue
{
	int m_value;
};

struct VSFNode : public CNodeValue
{
	VSFNode()
	{
		m_bUSE = false;
		m_value = NULL;
	}

	bool m_bUSE;
	CVrmlNode* m_value;
};

struct VSFRotation : public CNodeValue
{
	float m_x, m_y, m_z, m_angle;
};

struct VSFString : public CNodeValue
{
	VSFString()
	{
		m_value = NULL;
	}

	~VSFString()
	{
		delete m_value;
	}

	char* m_value;
};

struct VSFTime : public CNodeValue
{
	float m_value;
};

struct VSFVec2f : public CNodeValue
{
	float m_value [2];
};

struct VSFVec3f : public CNodeValue
{
	float m_value [3];
};






class CVrmlNode
{
public:
	CVrmlNode(NodeDesc* pNodeDesc, const char* szNameID);
	~CVrmlNode();

	NodeDesc* m_pNodeDesc;
	char* m_szNameID;
	CNodeValue** m_rgpNodeValues;

	int FindField(const char* szFieldID);
	CNodeValue* GetValue(const char* szFieldID);

	inline CNodeValueArray* GetArray(const char* szFieldID) { return (CNodeValueArray*)GetValue(szFieldID); }
	inline VSFBool* GetSFBool(const char* szFieldID) { return (VSFBool*)GetValue(szFieldID); }
	inline VSFColor* GetSFColor(const char* szFieldID) { return (VSFColor*)GetValue(szFieldID); }
	inline VSFFloat* GetSFFloat(const char* szFieldID) { return (VSFFloat*)GetValue(szFieldID); }
	inline VSFImage* GetSFImage(const char* szFieldID) { return (VSFImage*)GetValue(szFieldID); }
	inline VSFInt32* GetSFInt32(const char* szFieldID) { return (VSFInt32*)GetValue(szFieldID); }
	inline VSFNode* GetSFNode(const char* szFieldID) { return (VSFNode*)GetValue(szFieldID); }
	inline VSFRotation* GetSFRotation(const char* szFieldID) { return (VSFRotation*)GetValue(szFieldID); }
	inline VSFString* GetSFString(const char* szFieldID) { return (VSFString*)GetValue(szFieldID); }
	inline VSFTime* GetSFTime(const char* szFieldID) { return (VSFTime*)GetValue(szFieldID); }
	inline VSFVec2f* GetSFVec2f(const char* szFieldID) { return (VSFVec2f*)GetValue(szFieldID); }
	inline VSFVec3f* GetSFVec3f(const char* szFieldID) { return (VSFVec3f*)GetValue(szFieldID); }
};

CVrmlNode::CVrmlNode(NodeDesc* pNodeDesc, const char* szNameID)
{
	if (szNameID == NULL || szNameID[0] == '\0')
	{
		m_szNameID = NULL;
	}
	else
	{
		m_szNameID = new char [strlen(szNameID) + 1];
		strcpy(m_szNameID, szNameID);
	}

	m_pNodeDesc = pNodeDesc;
	m_rgpNodeValues = new CNodeValue* [m_pNodeDesc->m_nFieldCount];
	for (int i = 0; i < m_pNodeDesc->m_nFieldCount; i += 1)
		m_rgpNodeValues[i] = NULL;
}

CVrmlNode::~CVrmlNode()
{
	for (int i = 0; i < m_pNodeDesc->m_nFieldCount; i += 1)
		delete m_rgpNodeValues[i];
	delete [] m_rgpNodeValues;
	delete [] m_szNameID;
}

int CVrmlNode::FindField(const char* szFieldID)
{
	for (int i = 0; i < m_pNodeDesc->m_nFieldCount; i += 1)
	{
		if (strcmp(m_pNodeDesc->m_rgfields[i].m_szFieldID, szFieldID) == 0)
			return i;
	}

	return -1;
}


CNodeValue* CVrmlNode::GetValue(const char* szFieldID)
{
	int nValue = FindField(szFieldID);
	if (nValue == -1)
		return NULL;

	return m_rgpNodeValues[nValue];
}


CNodeValueArray rootNodes;
CNodeValueArray defNodes;



START_FIELDS(Anchor)
	FIELDDESC(eventIn, MFNode, addChildren, NULL)
	FIELDDESC(eventIn, MFNode, removeChildren, NULL)
	FIELDDESC(exposedField, MFNode, children, "[]")
	FIELDDESC(exposedField, SFString, description, "")
	FIELDDESC(exposedField, MFString, parameter, "[]")
	FIELDDESC(exposedField, MFString, url, "[]")
	FIELDDESC(field, SFVec3f, bboxCenter, "0 0 0 # (-inf,inf)")
	FIELDDESC(field, SFVec3f, bboxSize, "-1 -1 -1 # (0,inf) or -1,-1,-1")
END_FIELDS()

START_FIELDS(Appearance)
	FIELDDESC(exposedField, SFNode, material, "NULL")
	FIELDDESC(exposedField, SFNode, texture, "NULL")
	FIELDDESC(exposedField, SFNode, textureTransform, "NULL")
END_FIELDS()

START_FIELDS(AudioClip)
	FIELDDESC(exposedField,   SFString, description,      "")
	FIELDDESC(exposedField,   SFBool,   loop,             "FALSE")
	FIELDDESC(exposedField,   SFFloat,  pitch,            "1.0        # (0,inf)")
	FIELDDESC(exposedField,   SFTime,   startTime,        "0          # (-,inf)")
	FIELDDESC(exposedField,   SFTime,   stopTime,         "0          # (-,inf)")
	FIELDDESC(exposedField,   MFString, url,              "[]")
	FIELDDESC(eventOut,       SFTime,   duration_changed, NULL)
	FIELDDESC(eventOut,       SFBool,   isActive,         NULL)
END_FIELDS()

/*
START_FIELDS(Background)
END_FIELDS()

START_FIELDS(Billboard)
END_FIELDS()

START_FIELDS(Box)
END_FIELDS()

START_FIELDS(Collision)
END_FIELDS()
*/

START_FIELDS(Color)
	FIELDDESC(exposedField, MFColor, color,  "[]         # [0,1]")
END_FIELDS()

/*
START_FIELDS(ColorInterpolator)
END_FIELDS()

START_FIELDS(Cone)
END_FIELDS()
*/

START_FIELDS(Coordinate)
	FIELDDESC(exposedField, MFVec3f, point,  "[]      # (-,inf)")
END_FIELDS()

/*
START_FIELDS(CoordinateInterpolator)
END_FIELDS()

START_FIELDS(Cylinder)
END_FIELDS()

START_FIELDS(CylinderSensor)
END_FIELDS()

START_FIELDS(DirectionalLight)
END_FIELDS()

START_FIELDS(ElevationGrid)
END_FIELDS()

START_FIELDS(Extrusion)
END_FIELDS()

START_FIELDS(Fog)
END_FIELDS()

START_FIELDS(FontStyle)
END_FIELDS()
*/

START_FIELDS(Group)
	FIELDDESC(eventIn,      MFNode,  addChildren,   NULL)
	FIELDDESC(eventIn,      MFNode,  removeChildren,NULL)
	FIELDDESC(exposedField, MFNode,  children,      "[]")
	FIELDDESC(field,        SFVec3f, bboxCenter,    "0 0 0     # (-,inf)")
	FIELDDESC(field,        SFVec3f, bboxSize,      "-1 -1 -1  # (0,) or -1,-1,-1")
END_FIELDS()

START_FIELDS(ImageTexture)
	FIELDDESC(exposedField, MFString, url,     "[]")
	FIELDDESC(field,        SFBool,   repeatS, "TRUE")
	FIELDDESC(field,        SFBool,   repeatT, "TRUE")
END_FIELDS()

START_FIELDS(IndexedFaceSet)
	FIELDDESC(eventIn,       MFInt32, set_colorIndex,    NULL)
	FIELDDESC(eventIn,       MFInt32, set_coordIndex,    NULL)
	FIELDDESC(eventIn,       MFInt32, set_normalIndex,   NULL)
	FIELDDESC(eventIn,       MFInt32, set_texCoordIndex, NULL)
	FIELDDESC(exposedField,  SFNode,  color,             "NULL")
	FIELDDESC(exposedField,  SFNode,  coord,             "NULL")
	FIELDDESC(exposedField,  SFNode,  normal,            "NULL")
	FIELDDESC(exposedField,  SFNode,  texCoord,          "NULL")
	FIELDDESC(field,         SFBool,  ccw,               "TRUE")
	FIELDDESC(field,         MFInt32, colorIndex,        "[]        # [-1,inf)")
	FIELDDESC(field,         SFBool,  colorPerVertex,    "TRUE")
	FIELDDESC(field,         SFBool,  convex,            "TRUE")
	FIELDDESC(field,         MFInt32, coordIndex,        "[]        # [-1,inf)")
	FIELDDESC(field,         SFFloat, creaseAngle,       "0         # [0,inf)")
	FIELDDESC(field,         MFInt32, normalIndex,       "[]        # [-1,inf)")
	FIELDDESC(field,         SFBool,  normalPerVertex,   "TRUE")
	FIELDDESC(field,         SFBool,  solid,             "TRUE")
	FIELDDESC(field,         MFInt32, texCoordIndex,     "[]        # [-1,inf)")
END_FIELDS()

START_FIELDS(IndexedLineSet)
	FIELDDESC(eventIn,       MFInt32, set_colorIndex,    NULL)
	FIELDDESC(eventIn,       MFInt32, set_coordIndex,    NULL)
	FIELDDESC(exposedField,  SFNode,  color,             "NULL")
	FIELDDESC(exposedField,  SFNode,  coord,             "NULL")
	FIELDDESC(field,         MFInt32, colorIndex,        "[]     # [-1,inf)")
	FIELDDESC(field,         SFBool,  colorPerVertex,    "TRUE")
	FIELDDESC(field,         MFInt32, coordIndex,        "[]     # [-1,inf)")
END_FIELDS()

/*
START_FIELDS(Inline)
END_FIELDS()

START_FIELDS(LOD)
END_FIELDS()
*/

START_FIELDS(Material)
	FIELDDESC(exposedField, SFFloat, ambientIntensity,  "0.2         # [0,1]")
	FIELDDESC(exposedField, SFColor, diffuseColor,      "0.8 0.8 0.8 # [0,1]")
	FIELDDESC(exposedField, SFColor, emissiveColor,     "0 0 0       # [0,1]")
	FIELDDESC(exposedField, SFFloat, shininess,         "0.2         # [0,1]")
	FIELDDESC(exposedField, SFColor, specularColor,     "0 0 0       # [0,1]")
	FIELDDESC(exposedField, SFFloat, transparency,      "0           # [0,1]")
END_FIELDS()

START_FIELDS(MaxMaterial) // extension
	FIELDDESC(exposedField, SFString, name,             "")
END_FIELDS()

/*
START_FIELDS(MovieTexture)
END_FIELDS()

START_FIELDS(NavigationInfo)
END_FIELDS()
*/

START_FIELDS(Normal)
	FIELDDESC(exposedField, MFVec3f, vector,  "[]   # (-,inf)")
END_FIELDS()

/*
START_FIELDS(NormalInterpolator)
END_FIELDS()
*/

START_FIELDS(OrientationInterpolator)
	FIELDDESC(eventIn,      SFFloat,    set_fraction,  NULL)
	FIELDDESC(exposedField, MFFloat,    key,           "[]    # (-inf,inf)")
	FIELDDESC(exposedField, MFRotation, keyValue,      "[]    # [-1,1],(-inf,inf)")
	FIELDDESC(eventOut,     SFRotation, value_changed, NULL)
END_FIELDS()

/*
START_FIELDS(PixelTexture)
END_FIELDS()

START_FIELDS(PlaneSensor)
END_FIELDS()

START_FIELDS(PointLight)
END_FIELDS()

START_FIELDS(PointSet)
END_FIELDS()
*/

START_FIELDS(PositionInterpolator)
	FIELDDESC(eventIn,      SFFloat, set_fraction,  NULL)
	FIELDDESC(exposedField, MFFloat, key,           "[]    # (-inf,inf)")
	FIELDDESC(exposedField, MFVec3f, keyValue,      "[]    # (-inf,inf)")
	FIELDDESC(eventOut,     SFVec3f, value_changed, NULL)
END_FIELDS()

/*
START_FIELDS(ProximitySensor)
END_FIELDS()

START_FIELDS(ScalarInterpolator)
END_FIELDS()

START_FIELDS(Script)
END_FIELDS()
*/

START_FIELDS(Shape)
	FIELDDESC(exposedField, SFNode, appearance, "NULL")
	FIELDDESC(exposedField, SFNode, geometry,   "NULL")
END_FIELDS()

START_FIELDS(Sound)
	FIELDDESC(exposedField, SFVec3f,  direction,     "0 0 1   # (-inf,inf)")
	FIELDDESC(exposedField, SFFloat,  intensity,     "1       # [0,1]")
	FIELDDESC(exposedField, SFVec3f,  location,      "0 0 0   # (-inf,inf)")
	FIELDDESC(exposedField, SFFloat,  maxBack,       "10      # [0,inf)")
	FIELDDESC(exposedField, SFFloat,  maxFront,      "10      # [0,inf)")
	FIELDDESC(exposedField, SFFloat,  minBack,       "1       # [0,inf)")
	FIELDDESC(exposedField, SFFloat,  minFront,      "1       # [0,inf)")
	FIELDDESC(exposedField, SFFloat,  priority,      "0       # [0,1]")
	FIELDDESC(exposedField, SFNode,   source,        "NULL")
	FIELDDESC(field,        SFBool,   spatialize,    "TRUE")
END_FIELDS()

START_FIELDS(Sphere)
	FIELDDESC(field, SFFloat, radius,  "1    # (0,inf)")
END_FIELDS()

/*
START_FIELDS(SphereSensor)
END_FIELDS()

START_FIELDS(SpotLight)
END_FIELDS()

START_FIELDS(Switch)
END_FIELDS()

START_FIELDS(Text)
END_FIELDS()
*/

START_FIELDS(TextureCoordinate)
	FIELDDESC(exposedField, MFVec2f, point,  "[]      # (-inf,inf)")
END_FIELDS()

START_FIELDS(TextureTransform)
	FIELDDESC(exposedField, SFVec2f, center,      "0 0     # (-inf,inf)")
	FIELDDESC(exposedField, SFFloat, rotation,    "0       # (-inf,inf)")
	FIELDDESC(exposedField, SFVec2f, scale,       "1 1     # (-inf,inf)")
	FIELDDESC(exposedField, SFVec2f, translation, "0 0     # (-inf,inf)")
END_FIELDS()

START_FIELDS(TimeSensor)
	FIELDDESC(exposedField, SFTime,   cycleInterval, "1       # (0,inf)")
	FIELDDESC(exposedField, SFBool,   enabled,       "TRUE")
	FIELDDESC(exposedField, SFBool,   loop,          "FALSE")
	FIELDDESC(exposedField, SFTime,   startTime,     "0       # (-inf,inf)")
	FIELDDESC(exposedField, SFTime,   stopTime,      "0       # (-inf,inf)")
	FIELDDESC(eventOut,     SFTime,   cycleTime,     NULL)
	FIELDDESC(eventOut,     SFFloat,  fraction_changed,      "# [0, 1]")
	FIELDDESC(eventOut,     SFBool,   isActive,       NULL)
	FIELDDESC(eventOut,     SFTime,   time,           NULL)
END_FIELDS()

/*
START_FIELDS(TouchSensor)
END_FIELDS()
*/

START_FIELDS(Transform)
	FIELDDESC(eventIn,      MFNode,      addChildren,      NULL)
	FIELDDESC(eventIn,      MFNode,      removeChildren,   NULL)
	FIELDDESC(exposedField, SFVec3f,     center,           "0 0 0    # (-inf,inf)")
	FIELDDESC(exposedField, MFNode,      children,         "[]")
	FIELDDESC(exposedField, SFRotation,  rotation,         "0 0 1 0  # [-1,1],(-inf,inf)")
	FIELDDESC(exposedField, SFVec3f,     scale,            "1 1 1    # (0,inf)")
	FIELDDESC(exposedField, SFRotation,  scaleOrientation, "0 0 1 0  # [-1,1],(-inf,inf)")
	FIELDDESC(exposedField, SFVec3f,     translation,      "0 0 0    # (-inf,inf)")
	FIELDDESC(field,        SFVec3f,     bboxCenter,       "0 0 0    # (-inf,inf)")
	FIELDDESC(field,        SFVec3f,     bboxSize,         "-1 -1 -1 # (0,inf) or -1,-1,-1")
END_FIELDS()

START_FIELDS(Viewpoint)
	FIELDDESC(eventIn,      SFBool,     set_bind,       NULL)
	FIELDDESC(exposedField, SFFloat,    fieldOfView,    "0.785398  # (0,inf)")
	FIELDDESC(exposedField, SFBool,     jump,           "TRUE")
	FIELDDESC(exposedField, SFRotation, orientation,    "0 0 1 0   # [-1,1],(-inf,inf)")
	FIELDDESC(exposedField, SFVec3f,    position,       "0 0 10    # (-inf,inf)")
	FIELDDESC(field,        SFString,   description,    "")
	FIELDDESC(eventOut,     SFTime,     bindTime,       NULL)
	FIELDDESC(eventOut,     SFBool,     isBound,        NULL)
END_FIELDS()

/*
START_FIELDS(VisibilitySensor)
END_FIELDS()

START_FIELDS(WorldInfo)
END_FIELDS()
*/

NodeDesc rgnodes [] =
{
	NODEDESC(Anchor)
	NODEDESC(Appearance)
	NODEDESC(AudioClip)
/*
	NODEDESC(Background)
	NODEDESC(Billboard)
	NODEDESC(Box)
	NODEDESC(Collision)
*/
	NODEDESC(Color)
/*
	NODEDESC(ColorInterpolator)
	NODEDESC(Cone)
*/
	NODEDESC(Coordinate)
/*
	NODEDESC(CoordinateInterpolator)
	NODEDESC(Cylinder)
	NODEDESC(CylinderSensor)
	NODEDESC(DirectionalLight)
	NODEDESC(ElevationGrid)
	NODEDESC(Extrusion)
	NODEDESC(Fog)
	NODEDESC(FontStyle)
*/
	NODEDESC(Group)
	NODEDESC(ImageTexture)
	NODEDESC(IndexedFaceSet)
	NODEDESC(IndexedLineSet)
/*
	NODEDESC(Inline)
	NODEDESC(LOD)
*/
	NODEDESC(Material)
	NODEDESC(MaxMaterial) // extension
/*
	NODEDESC(MovieTexture)
	NODEDESC(NavigationInfo)
*/
	NODEDESC(Normal)
/*
	NODEDESC(NormalInterpolator)
*/
	NODEDESC(OrientationInterpolator)
/*
	NODEDESC(PixelTexture)
	NODEDESC(PlaneSensor)
	NODEDESC(PointLight)
	NODEDESC(PointSet)
*/
	NODEDESC(PositionInterpolator)
/*
	NODEDESC(ProximitySensor)
	NODEDESC(ScalarInterpolator)
	NODEDESC(Script)
*/
	NODEDESC(Shape)
/*
	NODEDESC(Sound)
*/
	NODEDESC(Sphere)
/*
	NODEDESC(SphereSensor)
	NODEDESC(SpotLight)
	NODEDESC(Switch)
	NODEDESC(Text)
*/
	NODEDESC(TextureCoordinate)
	NODEDESC(TextureTransform)
	NODEDESC(TimeSensor)
/*
	NODEDESC(TouchSensor)
*/
	NODEDESC(Transform)
	NODEDESC(Viewpoint)
/*
	NODEDESC(VisibilitySensor)
	NODEDESC(WorldInfo)
*/
};


FILE* pFile;
int nLine;
char szLine [256];
const char* pchLine;
char szToken [256];

bool FetchLine()
{
	if (fgets(szLine, sizeof (szLine), pFile) == NULL)
		return false;
/*
	char* pchEnd = strchr(szLine, '#');
	if (pchEnd != NULL)
		*pchEnd = 0;
*/
	pchLine = szLine;
	nLine += 1;

//	fprintf(stderr, "%d: %s", nLine, szLine);

	return true;
}

inline bool IsWhite(char ch)
{
	return (ch == ' ' || ch == '\t' || ch == ',' || ch == '\r' || ch == '\n');
}

const char* SkipWhite(const char* pch)
{
	while (IsWhite(*pch))
		pch += 1;

	return pch;
}

char PeekChar()
{
	pchLine = SkipWhite(pchLine);

	while (*pchLine == '\0' || *pchLine == '#')
	{
		if (!FetchLine())
			return 0;

		pchLine = SkipWhite(szLine);
	}

	return *pchLine;
}

inline bool IsTerminal(char ch)
{
	return /*ch == '.' || */ch == '{' || ch == '}' || ch == '[' || ch == ']';
}

bool Token()
{
	switch (PeekChar())
	{
	case '\0':
		return false;

//	case '.':
	case '{':
	case '}':
	case '[':
	case ']':
		szToken[0] = *pchLine++;
		szToken[1] = '\0';
		return true;

	case '"':
		{
			pchLine += 1;
			char* pchToken = szToken;
			while (*pchLine != '"')
			{
				if (*pchLine == '\0' && !FetchLine())
					break;

				if (*pchLine == '\\')
					pchLine += 1;
				*pchToken++ = *pchLine++;
			}
			*pchToken = '\0';
			pchLine += 1;
		}
		return true;
	}

	char* pchToken = szToken;
	while (!IsWhite(*pchLine) && !IsTerminal(*pchLine))
		*pchToken++ = *pchLine++;
	*pchToken = '\0';

	return true;
}

CNodeValue* ParseNode();

CNodeValue* ParseMF(CNodeValue*(*ParseSF)())
{
	CNodeValueArray* pValueArray = new CNodeValueArray;

	if (PeekChar() == '[')
	{
		Token();

		while (PeekChar() != ']')
		{
			CNodeValue* pValue = ParseSF();
			pValueArray->Add(pValue);
		}

		Token();
	}
	else
	{
		CNodeValue* pValue = ParseSF();
		pValueArray->Add(pValue);
	}

	return pValueArray;
}

CNodeValue* ParseSFFloat()
{
	Token();

	VSFFloat* pValue = new VSFFloat;

	if (sscanf(szToken, "%f", &pValue->m_value) != 1)
	{
		fprintf(stderr, "%d: invalid SFFloat value '%s'\n", nLine, szToken);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseSFInt32()
{
	Token();

	VSFInt32* pValue = new VSFInt32;

	if (sscanf(szToken, "%d", &pValue->m_value) != 1)
	{
		fprintf(stderr, "%d: invalid SFInt32 value '%s'\n", nLine, szToken);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseSFBool()
{
	Token();

	VSFBool* pValue = new VSFBool;

	if (strcmp(szToken, "TRUE") == 0)
	{
		pValue->m_value = true;
	}
	else if (strcmp(szToken, "FALSE") == 0)
	{
		pValue->m_value = false;
	}
	else
	{
		fprintf(stderr, "%d: invalid SFBool value '%s'\n", nLine, szToken);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseSFVec3f()
{
	char szVec3f [256];

	Token();
	strcpy(szVec3f, szToken);
	strcat(szVec3f, " ");

	Token();
	strcat(szVec3f, szToken);
	strcat(szVec3f, " ");

	Token();
	strcat(szVec3f, szToken);

	VSFVec3f* pValue = new VSFVec3f;

	if (sscanf(szVec3f, "%f %f %f", &pValue->m_value[0], &pValue->m_value[1], &pValue->m_value[2]) != 3)
	{
		fprintf(stderr, "%d: invalid SFVec3f value '%s'\n", nLine, szVec3f);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseSFColor()
{
	char szColor [256];

	Token();
	strcpy(szColor, szToken);
	strcat(szColor, " ");

	Token();
	strcat(szColor, szToken);
	strcat(szColor, " ");

	Token();
	strcat(szColor, szToken);

	VSFColor* pValue = new VSFColor;

	if (sscanf(szColor, "%f %f %f", &pValue->m_red, &pValue->m_green, &pValue->m_blue) != 3)
	{
		fprintf(stderr, "%d: invalid SFColor value '%s'\n", nLine, szColor);
		exit(1);
	}

	return pValue;
}

CNodeValue*  ParseMFColor()
{
	return ParseMF(ParseSFColor);
}

CNodeValue*  ParseSFRotation()
{
	char szRotation [256];

	Token();
	strcpy(szRotation, szToken);
	strcat(szRotation, " ");

	Token();
	strcat(szRotation, szToken);
	strcat(szRotation, " ");

	Token();
	strcat(szRotation, szToken);
	strcat(szRotation, " ");

	Token();
	strcat(szRotation, szToken);

	VSFRotation* pValue = new VSFRotation;

	if (sscanf(szRotation, "%f %f %f %f", &pValue->m_x, &pValue->m_y, &pValue->m_z, &pValue->m_angle) != 4)
	{
		fprintf(stderr, "%d: invalid SFRotation value '%s'\n", nLine, szRotation);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseMFRotation()
{
	return ParseMF(ParseSFRotation);
}

CNodeValue* ParseSFString()
{
	Token();

	VSFString* pValue = new VSFString;
	pValue->m_value = new char [strlen(szToken) + 1];
	strcpy(pValue->m_value, szToken);

	return pValue;
}

CNodeValue* ParseMFString()
{
	return ParseMF(ParseSFString);
}

CNodeValue* ParseSFTime()
{
	Token();

	VSFTime* pValue = new VSFTime;

	if (sscanf(szToken, "%f", &pValue->m_value) != 1)
	{
		fprintf(stderr, "%d: invalid SFTime value '%s'\n", nLine, szToken);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseMFTime()
{
	return ParseMF(ParseSFTime);
}

CNodeValue* ParseSFVec2f()
{
	char szVec2f [256];

	Token();
	strcpy(szVec2f, szToken);
	strcat(szVec2f, " ");

	Token();
	strcat(szVec2f, szToken);

	VSFVec2f* pValue = new VSFVec2f;

	if (sscanf(szVec2f, "%f %f", &pValue->m_value[0], &pValue->m_value[1]) != 2)
	{
		fprintf(stderr, "%d: invalid SFVec2f value '%s'\n", nLine, szVec2f);
		exit(1);
	}

	return pValue;
}

CNodeValue* ParseMFVec2f()
{
	return ParseMF(ParseSFVec2f);
}

CNodeValue* ParseSFImage()
{
	// TODO
	return NULL;
}



CNodeValue* ParseMFNode()
{
	return ParseMF(ParseNode);
}

CNodeValue* ParseMFVec3f()
{
	return ParseMF(ParseSFVec3f);
}

CNodeValue* ParseMFFloat()
{
	return ParseMF(ParseSFFloat);
}

CNodeValue* ParseMFInt32()
{
	return ParseMF(ParseSFInt32);
}



void ParseField(CVrmlNode* pNode, const char* szFieldID)
{
	NodeDesc* pNodeDesc = pNode->m_pNodeDesc;

	for (int i = 0; strcmp(szFieldID, pNodeDesc->m_rgfields[i].m_szFieldID) != 0; i += 1)
	{
		if (i >= pNodeDesc->m_nFieldCount - 1)
		{
			fprintf(stderr, "(%d): Unknown field ID: %s\n", nLine, szFieldID);
			exit(1);
		}
	}

	CNodeValue* pValue = NULL;

	switch (pNodeDesc->m_rgfields[i].m_type)
	{
	case MFColor:
		pValue = ParseMFColor();
		break;

	case MFFloat:
		pValue = ParseMFFloat();
		break;

	case MFInt32:
		pValue = ParseMFInt32();
		break;

	case MFNode:
		pValue = ParseMFNode();
		break;

	case MFRotation:
		pValue = ParseMFRotation();
		break;

	case MFString:
		pValue = ParseMFString();
		break;

	case MFTime:
		pValue = ParseMFTime();
		break;

	case MFVec2f:
		pValue = ParseMFVec2f();
		break;

	case MFVec3f:
		pValue = ParseMFVec3f();
		break;

	case SFBool:
		pValue = ParseSFBool();
		break;

	case SFColor:
		pValue = ParseSFColor();
		break;

	case SFFloat:
		pValue = ParseSFFloat();
		break;

	case SFImage:
		pValue = ParseSFImage();
		break;

	case SFInt32:
		pValue = ParseSFInt32();
		break;

	case SFNode:
		pValue = ParseNode();
		break;

	case SFRotation:
		pValue = ParseSFRotation();
		break;

	case SFString:
		pValue = ParseSFString();
		break;

	case SFTime:
		pValue = ParseSFTime();
		break;

	case SFVec2f:
		pValue = ParseSFVec2f();
		break;

	case SFVec3f:
		pValue = ParseSFVec3f();
		break;
	}

	pNode->m_rgpNodeValues[i] = pValue;
}

void ParseRoute()
{
	Token(); // nodeNameID.eventOutID

	Token(); // TO
	if (strcmp(szToken, "TO") != 0)
	{
		fprintf(stderr, "%d: expected 'TO'\n", nLine);
		exit(1);
	}

	Token(); // nodeNameID.eventInID
}

CNodeValue* ParseNode()
{
	char szNodeNameID [64];
	szNodeNameID[0] = 0;

	if (!Token())
		return NULL;

	if (strcmp(szToken, "ROUTE") == 0)
	{
		ParseRoute();
		return NULL;
	}

	if (strcmp(szToken, "USE") == 0)
	{
		Token();

		for (int i = defNodes.m_nCount - 1; i >= 0; i -= 1)
		{
			CVrmlNode* pVrmlNode = ((VSFNode*)defNodes.m_values[i])->m_value;

			if (strcmp(pVrmlNode->m_szNameID, szToken) == 0)
			{
				VSFNode* pSFNode = new VSFNode;
				pSFNode->m_value = pVrmlNode;
				pSFNode->m_bUSE = true;
				return pSFNode;
			}
		}

		fprintf(stderr, "%d: undefined USE node '%s'\n", nLine, szToken);
		return NULL;
	}

	if (strcmp(szToken, "DEF") == 0)
	{
		Token();
		strcpy(szNodeNameID, szToken);
		Token();
	}

	char szNodeTypeID [64];
	strcpy(szNodeTypeID, szToken);

	for (int i = 0; strcmp(szNodeTypeID, rgnodes[i].m_szNodeTypeID) != 0; i += 1)
	{
		if (i == sizeof (rgnodes) / sizeof (rgnodes[0]) - 1)
		{
			fprintf(stderr, "%d: unknown node type '%s'\n", nLine, szNodeTypeID);
			exit(1);
		}
	}

	CVrmlNode* pNode = new CVrmlNode(&rgnodes[i], szNodeNameID);

	if (PeekChar() == '{')
	{
		// Node Body
		Token();

		while (PeekChar() != '}')
		{
			Token();

			if (strcmp(szToken, "ROUTE") == 0)
			{
				ParseRoute();
			}
			else
			{
				char szFieldID [64];
				strcpy(szFieldID, szToken);

				ParseField(pNode, szFieldID);
			}
		}

		Token();
	}

	VSFNode* pValue = new VSFNode;
	pValue->m_value = pNode;

	if (pNode->m_szNameID != NULL)
		defNodes.Add(pValue);

	return pValue;
}

void ProcessFile(const char* szFileName)
{
	fprintf(stderr, "Converting %s...\n", szFileName);

	pFile = fopen(szFileName, "r");
	if (pFile == NULL)
	{
		fprintf(stderr, "Cannot open %s\n", szFileName);
		return;
	}

	pchLine = szLine;
	while (PeekChar() != 0)
	{
		CNodeValue* pValue = ParseNode();
		if (pValue != NULL)
			rootNodes.Add(pValue);
	}

	fclose(pFile);
}


////////////////////////////////////////////////////////////////////////////

int nTab = 0;

void Tabs()
{
	for (int i = 0; i < nTab; i += 1)
		printf("    ");
}

void DumpNode(VSFNode* pNode);

void DumpValue(FIELDTYPE type, CNodeValue* pValue)
{
	FIELDTYPE arrayType;

	switch (type)
	{
	case SFBool:
		{
			VSFBool* pNode = (VSFBool*)pValue;
			printf("%s\n", pNode->m_value ? "TRUE" : "FALSE");
		}
		break;

	case SFTime:
	case SFFloat:
		{
			VSFFloat* pNode = (VSFFloat*)pValue;
			printf("%f\n", pNode->m_value);
		}
		break;

	case SFInt32:
		{
			VSFInt32* pNode = (VSFInt32*)pValue;
			printf("%d\n", pNode->m_value);
		}
		break;

	case SFVec2f:
		{
			VSFVec2f* pNode = (VSFVec2f*)pValue;
			printf("%f %f\n", pNode->m_value[0], pNode->m_value[1]);
		}
		break;

	case SFColor:
	case SFVec3f:
		{
			VSFVec3f* pNode = (VSFVec3f*)pValue;
			printf("%f %f %f\n", pNode->m_value[0], pNode->m_value[1], pNode->m_value[2]);
		}
		break;

	case SFRotation:
		{
			VSFRotation* pNode = (VSFRotation*)pValue;
			printf("%f %f %f %f\n", pNode->m_x, pNode->m_y, pNode->m_z, pNode->m_angle);
		}
		break;

	case SFString:
		{
			VSFString* pNode = (VSFString*)pValue;
			printf("\"%s\"\n", pNode->m_value); // REVIEW: Need to escape quotes and back-slashes
		}
		break;

	case SFImage:
		break;

	case MFColor:
		arrayType = SFColor;
		goto LArray;

	case MFFloat:
		arrayType = SFFloat;
		goto LArray;

	case MFInt32:
		arrayType = SFInt32;
		goto LArray;

	case MFRotation:
		arrayType = SFRotation;
		goto LArray;

	case MFString:
		arrayType = SFString;
		goto LArray;

	case MFTime:
		arrayType = SFTime;
		goto LArray;

	case MFVec2f:
		arrayType = SFVec2f;
		goto LArray;

	case MFVec3f:
		arrayType = SFVec3f;
		goto LArray;

LArray:
		{
			CNodeValueArray* pValueArray = (CNodeValueArray*)pValue;

			if (pValueArray->m_nCount == 0)
			{
				printf("[]\n");
			}
			else if (pValueArray->m_nCount == 1)
			{
				// No brackets around single items!
				DumpValue(arrayType, pValueArray->m_values[0]);
			}
			else
			{
				printf("\n");
				Tabs();
				printf("[\n");
				nTab += 1;

				for (int i = 0; i < pValueArray->m_nCount; i += 1)
				{
					Tabs();
					printf("/* %d */ ", i);
					DumpValue(arrayType, pValueArray->m_values[i]);
	//				if (i < pValueArray->m_nCount - 1)
	//					printf(",\n");
				}

				nTab -= 1;
				Tabs();
				printf("]\n");
			}
		}
		break;

	case SFNode:
		DumpNode((VSFNode*)pValue);
		break;

	case MFNode:
		{
			printf("\n");
			Tabs();
			printf("[\n");
			nTab += 1;

			CNodeValueArray* pValueArray = (CNodeValueArray*)pValue;
			for (int i = 0; i < pValueArray->m_nCount; i += 1)
			{
				Tabs();
				DumpNode((VSFNode*)pValueArray->m_values[i]);
			}

			nTab -= 1;
			Tabs();
			printf("]\n");
		}
		break;

	default:
		printf("\n");
		break;
	}
}

void DumpNode(VSFNode* pSFNode)
{
	CVrmlNode* pVrmlNode = pSFNode->m_value;

	if (pSFNode->m_bUSE)
	{
		printf("USE %s\n", pVrmlNode->m_szNameID);
		return;
	}

	if (pVrmlNode->m_szNameID != NULL)
		printf("DEF %s ", pVrmlNode->m_szNameID);

	if (pVrmlNode->m_pNodeDesc->m_rgfields == IndexedFaceSetFields)
	{
		if (pVrmlNode->m_szNameID != NULL)
		{
			char szBuf [MAX_PATH];
			LegalizeFileName(szBuf, pVrmlNode->m_szNameID);
			printf("Mesh { url \"%s.xm\" }\n", szBuf);
			return;
		}
	}

	printf("%s\n", pVrmlNode->m_pNodeDesc->m_szNodeTypeID);

	Tabs();
	printf("{\n");

	nTab += 1;

	for (int i = 0; i < pVrmlNode->m_pNodeDesc->m_nFieldCount; i += 1)
	{
		if (pVrmlNode->m_rgpNodeValues[i] != NULL)
		{
			Tabs();
			printf("%s ", pVrmlNode->m_pNodeDesc->m_rgfields[i].m_szFieldID);
			DumpValue(pVrmlNode->m_pNodeDesc->m_rgfields[i].m_type, pVrmlNode->m_rgpNodeValues[i]);
		}
	}

	nTab -= 1;

	Tabs();
	printf("}\n");
}

void DumpNodes()
{
	for (int i = 0; i < rootNodes.m_nCount; i += 1)
		DumpNode((VSFNode*)rootNodes.m_values[i]);
}


////////////////////////////////////////////////////////////////////////////

void ConvertMesh(CVrmlNode* pNode)
{
	VSFNode* coord = pNode->GetSFNode("coord");
	CNodeValueArray* coordIndex = pNode->GetArray("coordIndex");
	VSFNode* normal = pNode->GetSFNode("normal");
	CNodeValueArray* normalIndex = pNode->GetArray("normalIndex");
	VSFNode* color = pNode->GetSFNode("color");
	CNodeValueArray* colorIndex = pNode->GetArray("colorIndex");
	VSFNode* texCoord = pNode->GetSFNode("texCoord");
	CNodeValueArray* texCoordIndex = pNode->GetArray("texCoordIndex");

	int nVertexStride = 0;
	DWORD fvf = 0;
	if (coord != NULL && coordIndex != NULL)
	{
		fvf |= D3DFVF_XYZ;
		nVertexStride += sizeof (float) * 3;
	}

	if (normal != NULL && normalIndex != NULL)
	{
		fvf |= D3DFVF_NORMAL;
		nVertexStride += sizeof (float) * 3;
	}

	if (color != NULL && colorIndex != NULL)
	{
		fvf |= D3DFVF_DIFFUSE;
		nVertexStride += sizeof (DWORD);
	}

	if (texCoord != NULL && texCoordIndex != NULL)
	{
		fvf |= D3DFVF_TEX1;
		nVertexStride += sizeof (float) * 2;
	}

	if (fvf == 0)
	{
		fprintf(stderr, "WARNING: skipping empty mesh '%s'\n", pNode->m_szNameID);
		return;
	}

	CNodeValueArray* coordPoint = coord->m_value->GetArray("point");
	if (coordPoint == NULL)
	{
		fprintf(stderr, "WARNING: skipping mesh with no Coordinate '%s'\n", pNode->m_szNameID);
		return;
	}

	CNodeValueArray* normalVector = NULL;
	if (normal != NULL)
		normalVector = normal->m_value->GetArray("vector");

	CNodeValueArray* colorColor = NULL;
	if (color != NULL)
		colorColor = color->m_value->GetArray("color");

	CNodeValueArray* texCoordPoint = NULL;
	if (texCoord != NULL)
		texCoordPoint = texCoord->m_value->GetArray("point");


	int nVertexCount = coordPoint->m_nCount;

	if (nVertexCount > 65535)
	{
		fprintf(stderr, "ERRR: mesh has too many vertices '%s'\n", pNode->m_szNameID);
		return;
	}

	int nTriangles = (coordIndex->m_nCount + 1) / 4;

	// Build an interleaved vertex buffer
	BYTE* pVertexBuffer = new BYTE [nVertexStride * (nTriangles * 3)];
	int nDestVertex = 0;
	for (int i = 0; i < coordIndex->m_nCount; i += 1)
	{
		int nVertexIndex = ((VSFInt32*)coordIndex->m_values[i])->m_value;
		if (nVertexIndex == -1)
			continue;

		BYTE* pbVert = pVertexBuffer + nVertexStride * nDestVertex;
		nDestVertex += 1;

		VSFVec3f* pVec3 = (VSFVec3f*)coordPoint->m_values[nVertexIndex];
		CopyMemory(pbVert, pVec3->m_value, sizeof (float) * 3);
		pbVert += sizeof (float) * 3;

		if (normalVector != NULL)
		{
			int nNormalIndex = ((VSFInt32*)normalIndex->m_values[i])->m_value;
			CopyMemory(pbVert, (VSFVec3f*)normalVector->m_values[nNormalIndex], sizeof (float) * 3);
			pbVert += sizeof (float) * 3;
		}

		if (colorColor != NULL)
		{
			int nColorIndex = ((VSFInt32*)colorIndex->m_values[i])->m_value;
			VSFColor* pColor = (VSFColor*)colorColor->m_values[nColorIndex];
			*(D3DCOLOR*)pbVert = D3DCOLOR_COLORVALUE(pColor->m_red, pColor->m_green, pColor->m_blue, 1.0f);
			pbVert += sizeof (DWORD);
		}

		if (texCoordPoint != NULL)
		{
			int nTexCoordIndex = ((VSFInt32*)texCoordIndex->m_values[i])->m_value;
			VSFVec2f* pVec2f = (VSFVec2f*)texCoordPoint->m_values[nTexCoordIndex];
			float vec [2];
			vec[0] = pVec2f->m_value[0];
			vec[1] = 1.0f - pVec2f->m_value[1];
			CopyMemory(pbVert, vec, sizeof (float) * 2);
			pbVert += sizeof (float) * 2;
		}
	}

	nVertexCount = nDestVertex;

	bool ccw = pNode->GetSFBool("ccw")->m_value;

	WORD* pIndexBuffer = new WORD [nTriangles * 3];
	for (i = 0; i < nTriangles; i += 1)
	{
		if (ccw)
		{
			pIndexBuffer[i * 3 + 0] = (WORD)i * 3 + 2;
			pIndexBuffer[i * 3 + 1] = (WORD)i * 3 + 1;
			pIndexBuffer[i * 3 + 2] = (WORD)i * 3 + 0;
		}
		else
		{
			pIndexBuffer[i * 3 + 0] = (WORD)i * 3 + 0;
			pIndexBuffer[i * 3 + 1] = (WORD)i * 3 + 1;
			pIndexBuffer[i * 3 + 2] = (WORD)i * 3 + 2;
		}
	}

	// TODO: Optimize buffer by removing duplicate vertices and combining indices...

/*
	// Build an interleaved vertex buffer
	BYTE* pVertexBuffer = new BYTE [nVertexStride * nVertexCount];
	for (int i = 0; i < coordIndex->m_nCount; i += 1)
	{
		int nVertexIndex = ((VSFInt32*)coordIndex->m_values[i])->m_value;
		if (nVertexIndex == -1)
			continue;

		BYTE* pbVert = pVertexBuffer + nVertexStride * nVertexIndex;

		VSFVec3f* pVec3 = (VSFVec3f*)coordPoint->m_values[nVertexIndex];
		CopyMemory(pbVert, pVec3->m_value, sizeof (float) * 3);
		pbVert += sizeof (float) * 3;

		if (normalVector != NULL)
		{
			int nNormalIndex = ((VSFInt32*)normalIndex->m_values[i])->m_value;
			CopyMemory(pbVert, (VSFVec3f*)normalVector->m_values[nNormalIndex], sizeof (float) * 3);
			pbVert += sizeof (float) * 3;
		}

		if (colorColor != NULL)
		{
			int nColorIndex = ((VSFInt32*)colorIndex->m_values[i])->m_value;
			VSFColor* pColor = (VSFColor*)colorColor->m_values[nColorIndex];
			*(D3DCOLOR*)pbVert = D3DCOLOR_COLORVALUE(pColor->m_red, pColor->m_green, pColor->m_blue, 1.0f);
			pbVert += sizeof (DWORD);
		}

		if (texCoordPoint != NULL)
		{
			int nTexCoordIndex = ((VSFInt32*)texCoordIndex->m_values[i])->m_value;
			VSFVec2f* pVec2f = (VSFVec2f*)texCoordPoint->m_values[nTexCoordIndex];
			float vec [2];
			vec[0] = pVec2f->m_value[0];
			vec[1] = 1.0f - pVec2f->m_value[1];
			CopyMemory(pbVert, vec, sizeof (float) * 2);
			pbVert += sizeof (float) * 2;
		}
	}

	int nTriangles = (coordIndex->m_nCount + 1) / 4;
	WORD* pIndexBuffer = new WORD [nTriangles * 3];
	for (i = 0; i < nTriangles; i += 1)
	{
		int n1 = ((VSFInt32*)coordIndex->m_values[i * 4 + 0])->m_value;
		int n2 = ((VSFInt32*)coordIndex->m_values[i * 4 + 1])->m_value;
		int n3 = ((VSFInt32*)coordIndex->m_values[i * 4 + 2])->m_value;
		int n4 = (i * 4 + 3 < coordIndex->m_nCount) ? ((VSFInt32*)coordIndex->m_values[i * 4 + 3])->m_value : -1;

		if (n1 == -1 || n2 == -1 || n3 == -1 || n4 != -1)
		{
			fprintf(stderr, "ERROR: mesh is not triangulated '%s'\n", pNode->m_szNameID);
			delete [] pIndexBuffer;
			delete [] pVertexBuffer;
			return;
		}

		if ((unsigned)n1 > 65535 || (unsigned)n2 > 65535 || (unsigned)n3 > 65535)
		{
			fprintf(stderr, "ERROR: mesh has out of range index '%s'\n", pNode->m_szNameID);
			delete [] pIndexBuffer;
			delete [] pVertexBuffer;
			return;
		}

		pIndexBuffer[i * 3 + 0] = (WORD)n1;
		pIndexBuffer[i * 3 + 1] = (WORD)n2;
		pIndexBuffer[i * 3 + 2] = (WORD)n3;
	}
*/

	D3DPRIMITIVETYPE m_primitiveType = D3DPT_TRIANGLELIST;
	int m_nFaceCount = nTriangles;
	DWORD m_fvf = fvf;
	int m_nVertexStride = nVertexStride;
	int m_nVertexCount = nVertexCount;
	int m_nIndexCount = nTriangles * 3;
	BYTE* m_pVertexBuffer = pVertexBuffer;
	WORD* m_pIndexBuffer = pIndexBuffer;

	// BLOCK: Write the file...
	{
		char szFileName [MAX_PATH];
		LegalizeFileName(szFileName, pNode->m_szNameID);
		strcat(szFileName, ".xm");

		HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			fprintf(stderr, "ERROR: cannot create file '%s'\n", szFileName);
//			exit(1);
		}
		else
		{
			DWORD dwValue, dwWritten;

			dwValue = (DWORD)m_primitiveType;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			dwValue = (DWORD)m_nFaceCount;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			dwValue = (DWORD)m_fvf;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			dwValue = (DWORD)m_nVertexStride;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			dwValue = (DWORD)m_nVertexCount;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			dwValue = (DWORD)m_nIndexCount;
			WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

			WriteFile(hFile, m_pVertexBuffer, m_nVertexCount * m_nVertexStride, &dwWritten, NULL);

			WriteFile(hFile, m_pIndexBuffer, m_nIndexCount * sizeof (WORD), &dwWritten, NULL);

			CloseHandle(hFile);
		}
	}

	delete [] pIndexBuffer;
	delete [] pVertexBuffer;
}

void SaveMeshes()
{
	// Looking at defNodes since we need named nodes to get file names...
	for (int i = 0; i < defNodes.m_nCount; i += 1)
	{
		CVrmlNode* pNode = ((VSFNode*)defNodes.m_values[i])->m_value;

		if (pNode->m_pNodeDesc->m_rgfields == IndexedFaceSetFields)
		{
			fprintf(stderr, "saving mesh %s\n", pNode->m_szNameID);
			ConvertMesh(pNode);
		}
	}
}

////////////////////////////////////////////////////////////////////////////

bool bDumpNodes = false;

float force_floating_point;

int __cdecl main(int argc, char* argv[])
{
	force_floating_point = sinf(1.0f);

	bool bNeedHelp = true;

	for (int i = 1; i < argc; i += 1)
	{
		const char* sz = argv[i];

		if (sz[0] == '-' || sz[0] == '/')
		{
			sz += 1;
			while (*sz != '\0')
			{
				switch (*sz++)
				{
				case '?':
					goto LNeedHelp;

				case 'd':
				case 'D':
					bDumpNodes = true;
					break;
				}
			}
		}
		else
		{
			bNeedHelp = false;
			ProcessFile(sz);
		}
	}

	if (bNeedHelp)
	{
LNeedHelp:
		fprintf(stderr, "This program converts a VRML97 file to XDash style 3D mesh files.\n");
		fprintf(stderr, "Usage:\n\twrl2xm <file.wml>\n");
		exit(1);
	}

	if (bDumpNodes)
		DumpNodes();

	SaveMeshes();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\activefile.h ===
#pragma once

class CActiveFile
{
public:
	CActiveFile();
	~CActiveFile();

	void Reset();

	bool Fetch(const TCHAR* szURL, bool bSearchAppDir = false, bool bTry = false);
	bool Update();

	const TCHAR* GetURL() const { return m_szURL; }
	DWORD GetContentLength() const { return m_cbContent; }
	const BYTE* GetContent() const { return m_pbContent; }

	BYTE* DetachContent();


	// File-Like Read Functions...

	inline void Rewind()
	{
		Seek(0);
	}

	inline void Seek(int nNewBytePos)
	{
		ASSERT(nNewBytePos >= 0 && (DWORD)nNewBytePos <= m_cbContent);
		m_dwReadPos = nNewBytePos;
	}

	inline void Skip(int nSkipBytes)
	{
		ASSERT((int)m_dwReadPos + nSkipBytes >= 0 && (DWORD)(m_dwReadPos + nSkipBytes) <= m_cbContent);
		m_dwReadPos += nSkipBytes;
	}

	inline int Tell()
	{
		return (int)m_dwReadPos;
	}

	inline bool Read(void* pv, int cb)
	{
		ASSERT(cb >= 0);

		if (m_dwReadPos + (DWORD)cb > m_cbContent)
			return false;

		CopyMemory(pv, m_pbContent + m_dwReadPos, cb);
		m_dwReadPos += cb;

		return true;
	}

	DWORD m_dwReadPos;


#ifdef _UNICODE
	bool IsUnicode();
	void MakeUnicode();
#endif

protected:
	bool FetchFile(bool bTry = false);

	TCHAR* m_szURL;
	BYTE* m_pbContent;
	DWORD m_cbContent;
	FILETIME m_modifiedTime;

	bool m_bInXIP;

	float m_updatePeriod;
	XTIME m_nextUpdateTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\activefile.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "ActiveFile.h"
#include "xip.h"

#ifdef _DEBUG
extern void DumpHex(const BYTE* pbData, int cbData, int cbMax = 0);
#endif

CActiveFile::CActiveFile()
{
	m_szURL = NULL;
	m_pbContent = NULL;
	m_cbContent = 0;
	ZeroMemory(&m_modifiedTime, sizeof (m_modifiedTime));
	m_dwReadPos = 0;
	m_bInXIP = false;

	m_updatePeriod = 5.0f;
	m_nextUpdateTime = 0.0f;
}

CActiveFile::~CActiveFile()
{
	Reset();
}

void CActiveFile::Reset()
{
	delete [] m_szURL;

	XAppFreeMemory(m_pbContent);

	m_szURL = NULL;
	m_pbContent = NULL;
	m_cbContent = 0;
	ZeroMemory(&m_modifiedTime, sizeof (m_modifiedTime));
}

BYTE* CActiveFile::DetachContent()
{
	BYTE* pbContent = m_pbContent;
	m_pbContent = NULL;
	return pbContent;
}

bool CActiveFile::Fetch(const TCHAR* szURL, bool bSearchAppDir/*=false*/, bool bTry/*=false*/)
{
	Reset();

	m_szURL = new TCHAR [_tcslen(szURL) + 1];
	_tcscpy(m_szURL, szURL);

	if (m_szURL[0] == '\0')
	{
		return true;
	}

	else if (_tcsnicmp(m_szURL, _T("string:"), 7) == 0)
	{
		szURL += 7; // skip 'string:'

		m_cbContent = _tcslen(szURL) * sizeof (TCHAR);
		m_pbContent = (BYTE*)XAppAllocMemory(m_cbContent + sizeof (TCHAR));
		_tcscpy((TCHAR*)m_pbContent, szURL);
	}
	else // file system
	{
		if (!((szURL[0] == '\\' && szURL[1] == '\\') || (szURL[0] != 0 && szURL[1] == ':')))
		{
			// Make it absolute...
			TCHAR szBuf [MAX_PATH];
			MakeAbsoluteURL(szBuf, szURL);

			if (FindInXIPAndDetach(szBuf, m_pbContent, m_cbContent))
			{
				m_bInXIP = true;
				return true;
			}

			if (bSearchAppDir && !DoesFileExist(szBuf))
			{
				TRACE(_T("File not found: %s\n"), szBuf);
				_tcscpy(szBuf, theApp.m_szAppDir);
				_tcscat(szBuf, szURL);
				TRACE(_T("\ttrying %s instead...\n"), szBuf);
			}

			delete [] m_szURL;
			m_szURL = new TCHAR [_tcslen(szBuf) + 1];
			_tcscpy(m_szURL, szBuf);
		}

		if (FindInXIPAndDetach(m_szURL, m_pbContent, m_cbContent))
		{
			m_bInXIP = true;
			return true;
		}
		
		if (!FetchFile(bTry))
			return false;
	}

	return true;
}

bool CActiveFile::FetchFile(bool bTry/*=false*/)
{
	BYTE* pbContent;
	DWORD cbContent;
    MEMORYSTATUS stat;

	HANDLE hFile;

	if ((hFile = XAppCreateFile(m_szURL, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)) == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001CActiveFile::FetchFile (%s) failed %d\n"), m_szURL, GetLastError());
		return false;
	}

	cbContent = GetFileSize(hFile, NULL);

    if (bTry)
    {
        GlobalMemoryStatus(&stat);
        if (stat.dwAvailPhys < (cbContent + 1024*1024))
        {
            return false;
        }
    }

    pbContent = (BYTE*)XAppAllocMemory(cbContent + sizeof (TCHAR));
    ReadFile(hFile, pbContent, cbContent, &cbContent, NULL);

	pbContent[cbContent] = 0;
#ifdef _UNICODE
	pbContent[cbContent + 1] = 0;
#endif

	if (!GetFileTime(hFile, NULL, NULL, &m_modifiedTime))
    {
        CloseHandle(hFile);
        XAppFreeMemory(m_pbContent);
        return false;
    }

	CloseHandle(hFile);

	XAppFreeMemory(m_pbContent);

	m_pbContent = pbContent;
	m_cbContent = cbContent;
	m_bInXIP = false;

//#ifdef _DEBUG
//	TRACE(_T("File: %d bytes\n"), m_cbContent);
//	DumpHex(m_pbContent, m_cbContent);
//#endif

	return true;
}

bool CActiveFile::Update()
{
	if (m_bInXIP)
		return false;

	if (m_szURL == NULL || m_szURL[0] == '\0')
		return false;

	if (m_updatePeriod == 0.0f || XAppGetNow() < m_nextUpdateTime)
		return false;

	m_nextUpdateTime = XAppGetNow() + m_updatePeriod + rnd(1.0f);

	if (_tcsnicmp(m_szURL, _T("string:"), 7) == 0)
		return false;

	// BLOCK: Check files...
	{
		HANDLE hFile;
		if ((hFile = XAppCreateFile(m_szURL, 0, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
		{
			FILETIME ft;
			VERIFY(GetFileTime(hFile, NULL, NULL, &ft));
			CloseHandle(hFile);

			if (ft.dwHighDateTime > m_modifiedTime.dwHighDateTime || ft.dwLowDateTime > m_modifiedTime.dwLowDateTime)
			{
				TRACE(_T("File has changed...\n"));
				m_modifiedTime = ft;
				return FetchFile();
			}
		}
		else
		{
			TRACE(_T("Check file time failed (%s)!\n"), m_szURL);
		}
	}

	return false;
}

#ifdef _UNICODE
bool CActiveFile::IsUnicode()
{
	return (m_pbContent != NULL && m_cbContent > 2 && m_pbContent[0] == 0xff && m_pbContent[1] == 0xfe);
}

void CActiveFile::MakeUnicode()
{
	if (IsUnicode())
	{
		// NOTE: Once this happens, IsUnicode will return false!
		MoveMemory(m_pbContent, m_pbContent + 2, m_cbContent);
		return;
	}

	TCHAR* wsz = (TCHAR*)XAppAllocMemory((m_cbContent + 1) * 2);
	Unicode(wsz, (const char*)m_pbContent, m_cbContent);
	wsz[m_cbContent] = 0;
	XAppFreeMemory(m_pbContent);
	m_pbContent = (BYTE*)wsz;
	m_cbContent = (m_cbContent + 1) * 2;
	m_bInXIP = false;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\ArrayProps.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"

////////////////////////////////////////////////////////////////////////////

CIntArray::CIntArray()
{
	m_nAlloc = 0;
	m_nSize = 0;
	m_value = NULL;
}

CIntArray::~CIntArray()
{
	delete [] m_value;
}

void CIntArray::SetSize(int nSize)
{
	if (nSize > m_nAlloc)
	{
		int* newValue = new int [nSize];

		if (m_value != NULL)
		{
			CopyMemory(newValue, m_value, sizeof (int) * m_nSize);
			delete [] m_value;
		}

		m_value = newValue;
		m_nAlloc = nSize;
	}

	m_nSize = nSize;
}

////////////////////////////////////////////////////////////////////////////

CNumArray::CNumArray()
{
	m_nAlloc = 0;
	m_nSize = 0;
	m_value = NULL;
}

CNumArray::~CNumArray()
{
	delete [] m_value;
}

void CNumArray::SetSize(int nSize)
{
	if (nSize > m_nAlloc)
	{
		float* newValue = new float [nSize];

		if (m_value != NULL)
		{
			CopyMemory(newValue, m_value, sizeof (float) * m_nSize);
			delete [] m_value;
		}

		m_value = newValue;
		m_nAlloc = nSize;
	}

	m_nSize = nSize;
}

////////////////////////////////////////////////////////////////////////////

CVec2Array::CVec2Array()
{
	m_nAlloc = 0;
	m_nSize = 0;
	m_value = NULL;
}

CVec2Array::~CVec2Array()
{
	delete [] m_value;
}

void CVec2Array::SetSize(int nSize)
{
	if (nSize > m_nAlloc)
	{
		D3DXVECTOR2* newValue = new D3DXVECTOR2 [nSize];

		if (m_value != NULL)
		{
			CopyMemory(newValue, m_value, sizeof (D3DXVECTOR2) * m_nSize);
			delete [] m_value;
		}

		m_value = newValue;
		m_nAlloc = nSize;
	}

	m_nSize = nSize;
}

////////////////////////////////////////////////////////////////////////////

CVec3Array::CVec3Array()
{
	m_nAlloc = 0;
	m_nSize = 0;
	m_value = NULL;
}

CVec3Array::~CVec3Array()
{
	delete [] m_value;
}

void CVec3Array::SetSize(int nSize)
{
	if (nSize > m_nAlloc)
	{
		D3DXVECTOR3* newValue = new D3DXVECTOR3 [nSize];

		if (m_value != NULL)
		{
			CopyMemory(newValue, m_value, sizeof (D3DXVECTOR3) * m_nSize);
			delete [] m_value;
		}

		m_value = newValue;
		m_nAlloc = nSize;
	}

	m_nSize = nSize;
}

////////////////////////////////////////////////////////////////////////////

CVec4Array::CVec4Array()
{
	m_nAlloc = 0;
	m_nSize = 0;
	m_value = NULL;
}

CVec4Array::~CVec4Array()
{
	delete [] m_value;
}

void CVec4Array::SetSize(int nSize)
{
	if (nSize > m_nAlloc)
	{
		D3DXVECTOR4* newValue = new D3DXVECTOR4 [nSize];

		if (m_value != NULL)
		{
			CopyMemory(newValue, m_value, sizeof (D3DXVECTOR4) * m_nSize);
			delete [] m_value;
		}

		m_value = newValue;
		m_nAlloc = nSize;
	}

	m_nSize = nSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Array.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"

extern CObject** g_rgParam;
extern int g_nParam;
extern CObject* Dereference(CObject* pObject);


class CArrayObject : public CObject
{
	DECLARE_NODE(CArrayObject, CObject)
public:
	CArrayObject();
	CArrayObject(int nLength);
	~CArrayObject();

	CStrObject* ToStr();
	CObject* Dot(CObject* pObject);

	CObject* concat(CObject* pArray2);
	CStrObject* join(const TCHAR* szSeparator);
	CObject* reverse();
	CObject* slice(CObject** rgparam, int nParam/*int nStart, int nEnd*/);
	CObject* sort();

protected:
	friend class CArrayElementReference;

	void Grow(int nNewLength);

	int m_nLength;
	int m_nAlloc;
	CObject** m_object;

	DECLARE_NODE_FUNCTIONS()

private:
    // Need this to prevent the compiler from using default copy ctor
    CArrayObject(const CArrayObject&);
    CArrayObject& operator=(const CArrayObject& rhs);
};

class CArrayElementReference : public CObject
{
public:
	CArrayElementReference(CArrayObject* pArray, int nIndex);
	~CArrayElementReference();

	void Assign(CObject* pObject);
	CObject* Deref();

	CArrayObject* m_pArray;
	int m_nIndex;
};

CArrayElementReference::CArrayElementReference(CArrayObject* pArray, int nIndex)
{
	ASSERT(pArray != NULL);
	m_pArray = pArray;
	m_pArray->AddRef();
	m_nIndex = nIndex;
}

CArrayElementReference::~CArrayElementReference()
{
	m_pArray->Release();
}


void CArrayElementReference::Assign(CObject* pObject)
{
	if (m_nIndex >= m_pArray->m_nLength)
		m_pArray->Grow(m_nIndex + 1);

	CObject* pOldObject = m_pArray->m_object[m_nIndex];
	if (pOldObject != NULL)
		pOldObject->Release();

	pObject->AddRef();
	m_pArray->m_object[m_nIndex] = pObject;
}

CObject* CArrayElementReference::Deref()
{
	if (m_nIndex < 0 || m_nIndex >= m_pArray->m_nLength)
	{
		g_pRunner->Error(_T("Array reference out of bounds"));
		return NULL;
	}

	CObject* pObject = m_pArray->m_object[m_nIndex];
	if (pObject != NULL)
		pObject->AddRef();
	Release();
	return pObject;
}


IMPLEMENT_NODE("Array", CArrayObject, CObject)

START_NODE_FUN(CArrayObject, CObject)
	NODE_FUN_OO(concat)
	NODE_FUN_SS(join)
	NODE_FUN_OV(reverse)
	NODE_FUN(slice)
	NODE_FUN_OV(sort)
END_NODE_FUN()


CArrayObject::CArrayObject()
{
	m_obj = objArray;

	int nLength = 0;

	if (g_nParam == 1)
	{
		g_rgParam[0] = Dereference(g_rgParam[0]);
		CNumObject* pNum = g_rgParam[0]->ToNum();
		nLength = (int)pNum->m_nValue;
		pNum->Release();
	}
	else if (g_nParam > 1)
	{
		nLength = g_nParam;
	}

	if (nLength == 0)
	{
		m_nLength = 0;
		m_nAlloc = 0;
		m_object = NULL;
	}
	else
	{
		m_nLength = nLength;
		m_nAlloc = nLength;
		m_object = new CObject* [nLength];
		ZeroMemory(m_object, nLength * sizeof (CObject*));
	}

	if (g_nParam > 1)
	{
		for (int i = 0; i < g_nParam; i += 1)
		{
			if (g_rgParam[i] != NULL)
				g_rgParam[i]->AddRef();
			m_object[i] = g_rgParam[i];
		}
	}
}

CArrayObject::CArrayObject(int nLength)
{
	m_nLength = nLength;
	m_nAlloc = nLength;

	if (nLength == 0)
	{
		m_object = NULL;
	}
	else
	{
		m_object = new CObject* [nLength];
		ZeroMemory(m_object, nLength * sizeof (CObject*));
	}
}

CArrayObject::~CArrayObject()
{
	for (int i = 0; i < m_nLength; i += 1)
	{
		if (m_object[i] != NULL)
			m_object[i]->Release();
	}

	delete [] m_object;
}

void CArrayObject::Grow(int nNewLength)
{
	if (nNewLength <= m_nLength)
		return;

	if (nNewLength > m_nAlloc)
	{
		int nNewAlloc = nNewLength + 16;
		CObject** object = new CObject* [nNewAlloc];
		CopyMemory(object, m_object, m_nLength * sizeof (CObject*));
		delete [] m_object;
		m_object = object;
		m_nAlloc = nNewAlloc;
	}

	ZeroMemory(m_object + m_nLength, (nNewLength - m_nLength) * sizeof (CObject*));
	m_nLength = nNewLength;
}

CStrObject* CArrayObject::ToStr()
{
	CStrObject* pStr = join(_T(","));
	return pStr;
}

CObject* CArrayObject::Dot(CObject* pObject)
{
	if (pObject->m_obj == objVariable)
	{
		if (_tcscmp(((CVarObject*)pObject)->m_sz, _T("length")) == 0)
		{
			return new CNumObject((float)m_nLength);
		}
	}
	else if (pObject->m_obj == objNumber)
	{
		int nIndex = (int)((CNumObject*)pObject)->m_nValue;
		return new CArrayElementReference(this, nIndex);
	}

	return CObject::Dot(pObject);
}

CObject* CArrayObject::concat(CObject* pObject)
{
	if (pObject->m_obj != objArray)
	{
		g_pRunner->Error(_T("object is not an array"));
		return NULL;
	}

	CArrayObject* pArray2 = (CArrayObject*)pObject;

	CArrayObject* pNewArray = new CArrayObject(m_nLength + pArray2->m_nLength);

	for (int i = 0; i < m_nLength; i += 1)
	{
		CObject* pObject = m_object[i];
		if (pObject != NULL)
			pObject->AddRef();
		pNewArray->m_object[i] = pObject;
	}

	for (i = 0; i < pArray2->m_nLength; i += 1)
	{
		CObject* pObject = pArray2->m_object[i];
		if (pObject != NULL)
			pObject->AddRef();
		pNewArray->m_object[m_nLength + i] = pObject;
	}

	return pNewArray;
}

CStrObject* CArrayObject::join(const TCHAR* szSeperator)
{
	CStrObject* pNewString = new CStrObject;

	for (int i = 0; i < m_nLength; i += 1)
	{
		CObject* pObject = m_object[i];
		if (pObject != NULL)
		{
			CStrObject* pStr = pObject->ToStr();
			pNewString->Append(pStr->GetSz());
			pStr->Release();
		}
		else
		{
			pNewString->Append(_T("[null]"));
		}

		if (i != m_nLength - 1)
			pNewString->Append(szSeperator);
	}


	return pNewString;
}

CObject* CArrayObject::reverse()
{
	CArrayObject* pNewArray = new CArrayObject(m_nLength);

	for (int i = 0; i < m_nLength; i += 1)
	{
		CObject* pObject = m_object[i];
		if (pObject != NULL)
			pObject->AddRef();
		pNewArray->m_object[m_nLength - i - 1] = pObject;
	}

	return pNewArray;
}

CObject* CArrayObject::slice(CObject** rgparam, int nParam/*int nStart, int nEnd*/)
{
	int nStart = 0;
	int nEnd = -1;

	if (nParam < 1 || nParam > 2)
	{
		g_pRunner->Error(_T("invalid number of parameters"));
		return NULL;
	}

	nStart = (int)rgparam[0]->Deref()->ToNum()->m_nValue;
	if (nParam == 2)
		nEnd = (int)rgparam[1]->Deref()->ToNum()->m_nValue;

	if (nEnd < 0)
		nEnd = m_nLength + 1 + nEnd;

	int nLength = nEnd - nStart;
	if (nLength < 0)
		nLength = 0;

	CArrayObject* pNewArray = new CArrayObject(nLength);

	for (int i = 0; i < nLength; i += 1)
	{
		CObject* pObject = m_object[nStart + i];
		if (pObject != NULL)
			pObject->AddRef();
		pNewArray->m_object[i] = pObject;
	}

	return pNewArray;
}

static int __cdecl SortCompare(const void *elem1, const void *elem2)
{
	CObject* pObj1 = *(CObject**)elem1;
	CObject* pObj2 = *(CObject**)elem2;

	if (pObj1 == NULL)
	{
		if (pObj2 == NULL)
			return 0;

		return -1;
	}

	if (pObj2 == NULL)
		return 1;

	CStrObject* pStr1 = pObj1->ToStr();
	CStrObject* pStr2 = pObj2->ToStr();

	int nRet = _tcscmp(pStr1->GetSz(), pStr2->GetSz());

	pStr1->Release();
	pStr2->Release();

	return nRet;
}

CObject* CArrayObject::sort()
{
	CArrayObject* pNewArray = new CArrayObject(m_nLength);

	for (int i = 0; i < m_nLength; i += 1)
	{
		CObject* pObject = m_object[i];
		if (pObject != NULL)
			pObject->AddRef();
		pNewArray->m_object[i] = pObject;
	}

	qsort(pNewArray->m_object, pNewArray->m_nLength, sizeof (CObject*), SortCompare);

	return pNewArray;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\wmaenc\wmf_types.h ===
/*************************************************************************

Copyright (C) Microsoft Corporation, 2000

Module Name:

    wmfencode.h

Abstract:

    API's for light WMF SDK Encoder.

Revision History:


*************************************************************************/

#ifndef _WMF_TYPES_H_
#define _WMF_TYPES_H_

/*********  Basic type Definitions  *************/

#ifndef WMF_TYPE_DEFINED
#define WMF_TYPE_DEFINED

typedef void Void_WMF;
typedef long I32_WMF;
typedef unsigned long U32_WMF;
typedef short I16_WMF;
typedef unsigned short U16_WMF;
#if defined(_Embedded_x86)
typedef unsigned short U16Char_WMF;
#elif defined(macintosh)
typedef wchar_t U16Char_WMF;
#else
typedef unsigned short U16Char_WMF;
#endif
typedef char I8_WMF;
typedef unsigned char U8_WMF;
typedef long Bool_WMF;
typedef double Double_WMF;
typedef float Float_WMF;
typedef struct tQWORD_WMF
{
    U32_WMF   dwLo;
    U32_WMF   dwHi;

}   QWORD_WMF;

#ifdef macintosh
typedef unsigned long long QWORD;
#endif

#ifdef _XBOX
typedef unsigned __int64    U64_WMF;
typedef __int64    I64_WMF;
#elif defined(macintosh) || defined(_Embedded_x86)
typedef unsigned long long  U64_WMF;
typedef long long  I64_WMF;
#elif defined(HITACHI)
typedef struct tU64_WMF
{
    U32_WMF   dwLo;
    U32_WMF   dwHi;
}   U64_WMF;
typedef struct tI64_WMF
{
    I32_WMF   dwLo;
    I32_WMF   dwHi;
}   I64_WMF;
#else
typedef unsigned __int64    U64_WMF;
typedef __int64    I64_WMF;
#endif

typedef struct tRect_WMF
{
    I32_WMF iLeft;
    I32_WMF iTop;
    I32_WMF iRight;
    I32_WMF iBottom;
}   Rect_WMF;

#define TRUE_WMF    1
#define FALSE_WMF   0
#define NULL_WMF   0
typedef void * HWMFFILE;

#endif // WMF_TYPE_DEFINED


/************************************************/


// GUID definiton

#ifndef MAKEFOURCC_WMF
#define MAKEFOURCC_WMF(ch0, ch1, ch2, ch3) \
        ((U32_WMF)(U8_WMF)(ch0) | ((U32_WMF)(U8_WMF)(ch1) << 8) |   \
        ((U32_WMF)(U8_WMF)(ch2) << 16) | ((U32_WMF)(U8_WMF)(ch3) << 24 ))

#define mmioFOURCC_WMF(ch0, ch1, ch2, ch3)  MAKEFOURCC_WMF(ch0, ch1, ch2, ch3)
#endif


/******* video output type guids, in preference order  *****/

#define FOURCC_WMV2     mmioFOURCC_WMF('W','M','V','2')
#define FOURCC_WMV1     mmioFOURCC_WMF('W','M','V','1')
#define FOURCC_M4S2     mmioFOURCC_WMF('M','4','S','2')
#define FOURCC_MP43     mmioFOURCC_WMF('M','P','4','3')
#define FOURCC_mp43     mmioFOURCC_WMF('m','m','4','3')
#define FOURCC_MP4S     mmioFOURCC_WMF('M','P','4','S')
#define FOURCC_mp4s     mmioFOURCC_WMF('m','p','4','s')
#define FOURCC_MP42     mmioFOURCC_WMF('M','P','4','2')
#define FOURCC_mp42     mmioFOURCC_WMF('m','m','4','2')
#define FOURCC_MSS1     mmioFOURCC_WMF('M','S','S','1')
#define FOURCC_MSS2     mmioFOURCC_WMF('M','S','S','2')

/***********************************************************/


/******* video intput type guids, in preference order  *****/

#define FOURCC_I420		        0x30323449
#define FOURCC_IYUV		        0x56555949
#define FOURCC_YV12		        0x32315659
#define FOURCC_YUY2		        0x32595559
#define FOURCC_UYVY		        0x59565955
#define FOURCC_YVYU		        0x55595659
#define FOURCC_YVU9		        0x39555659
#define FOURCC_BI_RGB   	    0x00000000
#define FOURCC_BI_BITFIELDS	    0x00000003
#define FOURCC_BI_RLE8   	    0x00000001
#define FOURCC_BI_RLE4   	    0x00000002

/***********************************************************/

/******* Audio format tags  *****/

#define WAVE_FORMAT_PCM_WMF     0x0001
#define WAVE_FORMAT_WMA1_WMF    0x0160
#define WAVE_FORMAT_WMA2_WMF    0x0161
#define WAVE_FORMAT_WMA3_WMF    0x0162

/***********************************************************/


typedef struct tagWMFContentDescription
{
    /* *_len: as [in], they specify how large the corresponding
     *        buffers below are.
     *        as [out], they specify how large the returned
     *        buffers actually are.
     */

    U16_WMF uiTitle_len;
    U16_WMF uiAuthor_len;
    U16_WMF uiCopyright_len;
    U16_WMF uiDescription_len;   /* rarely used */
    U16_WMF uiRating_len;        /* rarely used */

    /* these are two-byte strings
     *   for ASCII-type character set, to convert these
     *   into a single-byte characters, simply skip
     *   over every other bytes.
     */

    U16Char_WMF *pchTitle;
    U16Char_WMF *pchAuthor;
    U16Char_WMF *pchCopyright;
    U16Char_WMF *pchDescription;
    U16Char_WMF *pchRating;

} WMFContentDescription;

/******************************************************************
**   Extended content description types:
**   ECD_STRING -- wchar string
**   ECD_BINARY -- binary (byte) data
**   ECD_BOOL   -- BOOL (int) data
**   ECD_WORD  -- contains one word,
**   ECD_DWORD  -- contains one dword,
**   ECD_QWORD  -- contains one qword,
*******************************************************************/

enum {
    ECD_STRING = 0,
    ECD_BINARY = 1,
    ECD_BOOL = 2,
    ECD_DWORD = 3,
    ECD_QWORD = 4,
    ECD_WORD = 5
};

#pragma pack (1)
typedef struct _CommandEntry {
    U32_WMF         time;
    U16_WMF         type;
    U16Char_WMF     *param;
} CommandEntry;


typedef struct _ECD_DESCRIPTOR {
    U16_WMF         cbName;
    U16Char_WMF     *pwszName;
    U16_WMF         data_type;
    U16_WMF         cbValue;
    union {
        U16Char_WMF *pwszString;
        U8_WMF *pbBinary;
        Bool_WMF *pfBool;
        U32_WMF *pdwDword;
        U64_WMF *pqwQword;
        U16_WMF  *pwWord;
    } uValue;
} ECD_DESCRIPTOR;

typedef struct _MarkerEntry {
    U64_WMF     m_qOffset;
    U64_WMF     m_qtime;
    U16_WMF     m_wEntryLen;
    U32_WMF     m_dwSendTime;
    U32_WMF     m_dwFlags;
    U32_WMF     m_dwDescLen;
    U16Char_WMF *m_pwDescName;
} MarkerEntry;

typedef struct tIndexEntries
{
	U32_WMF	dwPacket;
	U16_WMF	wSpan;
} INDEXENTRIES;


typedef struct tIndexInfo
{
	U16_WMF	nStreamId;
    U32_WMF   time_deltaMs;
    U32_WMF   max_packets;
    U32_WMF   num_entries;
    INDEXENTRIES *pIndexEntries;
} INDEXINFO;



#pragma pack ()



#pragma pack (1)
#pragma pack ()
#endif // _WMF_TYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Audio.cpp ===
#include "std.h"

#include "xapp.h"
#include "Node.h"
#include "Lerper.h"
#include "FileUtil.h"
#include "AudioPump.h"
#include "Audio.h"
#include "Runner.h"
#include "xcdplay.h"

#if defined(XBOX) && defined(DBG)
// #define DETECT_MEMORY_LEAKS
extern "C" void StartLeakTest();
extern "C" void EndLeakTest();
#else
#endif

bool g_bRemoveVoice = false; // REVIEW: Clean this up!
extern bool g_bLevelTransition;

IMPLEMENT_NODE("AudioClip", CAudioClip, CTimeDepNode)

START_NODE_PROPS(CAudioClip, CTimeDepNode)
//	NODE_PROP(pt_string, CAudioClip, description)
//	NODE_PROP(pt_number, CAudioClip, pitch)
	NODE_PROP(pt_number, CAudioClip, volume)
	NODE_PROP(pt_number, CAudioClip, pan)
	NODE_PROP(pt_number, CAudioClip, frequency)
	NODE_PROP(pt_number, CAudioClip, fade)
	NODE_PROP(pt_string, CAudioClip, url)
	NODE_PROP(pt_integer, CAudioClip, transportMode)
	NODE_PROP(pt_boolean, CAudioClip, removeVoice)
	NODE_PROP(pt_boolean, CAudioClip, sendProgress)
	NODE_PROP(pt_boolean, CAudioClip, pause_on_moving)
	NODE_PROP(pt_number, CAudioClip, progress)
END_NODE_PROPS()

START_NODE_FUN(CAudioClip, CTimeDepNode)
	NODE_FUN_VV(Play)
	NODE_FUN_VV(Stop)
	NODE_FUN_VV(Pause)
	NODE_FUN_IV(getMinutes)
	NODE_FUN_IV(getSeconds)
	NODE_FUN_VV(PlayOrPause)
END_NODE_FUN()

CAudioClip::CAudioClip() :
//	m_description(NULL),
//	m_pitch(1.0f),
	m_fade(0.0f),
	m_volume(1.0f),
	m_pan(0.0f),
	m_frequency(0.0f),
	m_url(NULL),
	m_transportMode(TRANSPORT_STOP),
	m_removeVoice(false),
    m_sendProgress(false),
    m_pause_on_moving(false),
    m_bUnpauseNeeded(false),
	m_progress(0)
{
	m_bDirty = true;
//	m_nMinutesLast = 0;
//	m_nSecondsLast = 0;
	m_lastTransportMode = -1;
	m_lastVolume = 1.0f;
	m_lastPan = 0.0f;
	m_lastFrequency = 0.0f;

	m_pSound = NULL;
	m_visible = false;
}

CAudioClip::~CAudioClip()
{
	Cleanup();

	delete [] m_url;
//	delete [] m_description;
}

bool CAudioClip::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_volume))
	{
		if (m_fade != 0.0f)
		{
			float volume = *(float*)pvValue;
			CLerper::RemoveObject(this);
			new CLerper(this, &m_volume, volume, m_fade);
			return false;
		}
	}
	if ((int)pprd->pbOffset == offsetof(m_pan))
	{
		if (m_fade != 0.0f)
		{
			float pan = *(float*)pvValue;
			CLerper::RemoveObject(this);
			new CLerper(this, &m_pan, pan, m_fade);
			return false;
		}
	}
	else if ((int)pprd->pbOffset == offsetof(m_url))
	{
		m_bDirty = true;
	}
	else if ((int)pprd->pbOffset == offsetof(m_isActive))
	{
		m_isActive = *(bool*)pvValue;
		OnIsActiveChanged();
	}

	return true;
}

void CAudioClip::OnIsActiveChanged()
{
	if (m_bDirty)
		Init();

	if (m_isActive)
		Play();
	else
		Stop();
}


void CAudioClip::Cleanup()
{
	Stop();

	delete m_pSound;
	m_pSound = NULL;
	m_lastVolume = 1.0f;
	m_lastPan = 0.0f;
	m_lastFrequency = 0.0f;
#ifdef DETECT_MEMORY_LEAKS
    EndLeakTest();
#endif
}

void CAudioClip::Init()
{
	ASSERT(m_bDirty);

	// Out with the old...
	Cleanup();
	m_bDirty = false;

	if (m_url == NULL || m_url[0] == 0)
		return;

	// In with the new...
	if (_tcsnicmp(m_url, _T("cd:"), 3) == 0)
	{
		int nTrack = _ttoi(m_url + 3); // 0=nothing; >0 is track number to play

		if (nTrack > 0)
		{
#ifdef DETECT_MEMORY_LEAKS
            StartLeakTest();
#endif
			XCDPlayer* pPlayer = new XCDPlayer;
			m_pSound = pPlayer;
			if (!pPlayer->Initialize(nTrack - 1, &m_format.wfx))
			{
				delete pPlayer;
				m_pSound = NULL;
			}
		}
	}
	else if (_tcsnicmp(m_url, _T("st:"), 3) == 0)
	{
		DWORD dwSongID = _tcstoul(m_url + 3, NULL, 0); // SongID

		CWMAPump* pSound = new CWMAPump;
		m_pSound = pSound;
		if (!pSound->Initialize(dwSongID, &m_format.wfx))
		{
			delete m_pSound;
			m_pSound = NULL;
		}
	}
	else
	{
		const TCHAR* pch = _tcsrchr(m_url, '.');
		if (pch != NULL)
		{
			if (_tcsicmp(pch + 1, _T("wav")) == 0)
			{
				OpenWaveFile();
			}
			else if (_tcsicmp(pch + 1, _T("wma")) == 0)
			{
				CWMAPump* pSound = new CWMAPump;
				m_pSound = pSound;
				if (!pSound->Initialize(m_url, NULL, &m_format.wfx))
				{
					delete m_pSound;
					m_pSound = NULL;
				}
			}
			else
			{
				TRACE(_T("Invalid AudioClip url: %s\n"), m_url);
			}
		}
	}
}

struct WAVFILE1
{
	BYTE riff [4];
	DWORD dwSize;
	BYTE wave [4];
	BYTE fmt [4];
	DWORD dwFormatSize;
};

struct WAVFILE2
{
	BYTE data [4];
	DWORD dwDataSize;
};

typedef struct
{
    FOURCC  fccChunkId;
    DWORD   dwDataSize;
} RIFFHEADER, *LPRIFFHEADER;

#ifndef FOURCC_RIFF
#define FOURCC_RIFF 'FFIR'
#endif // FOURCC_RIFF

#ifndef FOURCC_WAVE
#define FOURCC_WAVE 'EVAW'
#endif // FOURCC_WAVE

#ifndef FOURCC_FORMAT
#define FOURCC_FORMAT ' tmf'
#endif // FOURCC_FORMAT

#ifndef FOURCC_DATA
#define FOURCC_DATA 'atad'
#endif // FOURCC_DATA

bool CAudioClip::OpenWaveFile()
{
	TCHAR szBuf [MAX_PATH];
	FindFilePath(szBuf, m_url);
	HANDLE hFile = XAppCreateFile(szBuf, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("\001Cannot open wave file: %s\n"), m_url);
		return false;
	}

	DWORD dwRead;
	WAVFILE1 header;
    RIFFHEADER RiffHeader;

	if (!ReadFile(hFile, &header, sizeof (header), &dwRead, NULL) || dwRead != sizeof (header))
	{
		TRACE(_T("\001%s is not a valid wave file...\n"), m_url);
		CloseHandle(hFile);
		return false;
	}

	if (header.riff[0] != 'R' || header.riff[1] != 'I' || header.riff[2] != 'F' || header.riff[3] != 'F' ||
		header.wave[0] != 'W' || header.wave[1] != 'A' || header.wave[2] != 'V' || header.wave[3] != 'E' ||
		header.fmt[0] != 'f' || header.fmt[1] != 'm' || header.fmt[2] != 't' || header.fmt[3] != ' ')
	{
		TRACE(_T("\001%s is not a valid wave file (bad header chunk)\n"), m_url);
		CloseHandle(hFile);
		return false;
	}

	DWORD dwFormatSize = header.dwFormatSize;
	ZeroMemory(&m_format, sizeof(m_format));

	if (dwFormatSize > sizeof(m_format))
    {
		dwFormatSize = sizeof(m_format);
    }

	if (!ReadFile(hFile, &m_format, dwFormatSize, &dwRead, NULL) || dwRead != dwFormatSize)
	{
		TRACE(_T("\001%s is not a valid wave file (bad format chunk)\n"), m_url);
		CloseHandle(hFile);
		return false;
	}

    if (header.dwFormatSize != dwFormatSize)
    {
        SetFilePointer(hFile, header.dwFormatSize - dwFormatSize, 0, FILE_CURRENT);
    }

    BOOL b;
    DWORD dwDataSize = 0;

    ASSERT(m_format.wfx.wFormatTag == WAVE_FORMAT_PCM || m_format.wfx.wFormatTag == WAVE_FORMAT_XBOX_ADPCM);

	do
	{
        b = ReadFile(hFile, &RiffHeader, sizeof(RiffHeader), &dwRead, NULL);
        if (b)
        {
            if (RiffHeader.fccChunkId == FOURCC_DATA)
            {
                dwDataSize = RiffHeader.dwDataSize;
                break;
            }

            b = SetFilePointer(hFile, RiffHeader.dwDataSize, 0, FILE_CURRENT);
        }
	}
	while (b);

    if (!b || dwDataSize == 0)
    {
        TRACE(_T("\001%s is not a valid wave file (bad data chunk)\n"), m_url);
        CloseHandle(hFile);
        return false;
    }

	ASSERT(m_pSound == NULL);
	if (dwDataSize > 65536)
	{
		CFilePump* pSound = new CFilePump;
		m_pSound = pSound;
		if (!pSound->Initialize(hFile, dwDataSize, &m_format.wfx))
		{
			TRACE(_T("Could not initialize CFilePump for %s\n"), m_url);
			CloseHandle(hFile);
			delete pSound;
			m_pSound = NULL;
			return false;
		}

		// NOTE: File will be closed by CFilePump when it's done...
	}
	else
	{
		m_pSound = new CAudioBuf;
		if (!m_pSound->Initialize(&m_format.wfx, dwDataSize))
		{
			TRACE(_T("Could not initialize CAudioBuf for %s\n"), m_url);
			CloseHandle(hFile);
			delete m_pSound;
			m_pSound = NULL;
			return false;
		}

		void* pvBuffer = m_pSound->Lock();
		bool bError = !ReadFile(hFile, pvBuffer, dwDataSize, &dwRead, NULL) || dwRead != dwDataSize;
		m_pSound->Unlock(pvBuffer);

		CloseHandle(hFile);

		if (bError)
		{
			TRACE(_T("\001%s is not a valid wave file...\n"), m_url);
			delete m_pSound;
			m_pSound = NULL;

			return false;
		}
	}

	return true;
}

void CAudioClip::Advance(float nSeconds)
{
    if (m_bDirty)
        Init();

    // Pause this audio clip if we are in the middle of level transition
    if (m_pause_on_moving && m_pSound && m_volume != 0.0f)
    {
        if (g_bLevelTransition)
        {
            if (!m_pSound->IsPaused())
            {
                m_pSound->Pause(true);
                m_bUnpauseNeeded = true;
            }
            return;
        }

        if (!g_bLevelTransition && m_bUnpauseNeeded)
        {
            if (m_pSound->IsPaused())
            {
                m_pSound->Pause(false);
            }

            m_bUnpauseNeeded = false;
        }
    }

	CTimeDepNode::Advance(nSeconds);

	g_bRemoveVoice = m_removeVoice; // REVIEW: Clean this up!

	if (m_pSound == NULL)
	{
		m_isActive = false;
		m_transportMode = TRANSPORT_STOP;
	}
	else if (m_isActive)
	{
		if (m_volume != m_lastVolume)
		{
			if (m_lastVolume == 0.0f && m_transportMode == TRANSPORT_PAUSE)
			{
				TRACE(_T("Un-Pausing %s due to non-zero volume...\n"), m_url);
				Pause();
			}

			m_lastVolume = m_volume;

			m_pSound->SetAttenuation((1.0f - m_volume) * 100.0f);

			if (m_volume == 0.0f && m_transportMode == TRANSPORT_PLAY)
			{
				TRACE(_T("Pausing %s due to zero volume...\n"), m_url);
				Pause();
			}
		}

		if (m_pan != m_lastPan)
		{
			m_lastPan = m_pan;

			m_pSound->SetPan(m_pan);
		}

		if (m_frequency != m_lastFrequency)
		{
			m_lastFrequency = m_frequency;

			m_pSound->SetFrequency(m_frequency);
		}

		// BLOCK: Check progress...
        if (m_sendProgress)
		{
			// OPTIMIZATION: Might want to make this optional...
			float progress = 0.0f;

			float nLength = m_pSound->GetPlaybackLength();
			if (nLength != 0.0f)
				progress = m_pSound->GetPlaybackTime() / nLength;

			if (progress != m_progress)
			{
				m_progress = progress;
				CallFunction(this, _T("OnProgressChanged"));
			}
		}

		if (m_pSound->IsPaused())
		{
			m_transportMode = TRANSPORT_PAUSE;
		}
		else if (m_pSound->IsPlaying())
		{
			m_transportMode = TRANSPORT_PLAY;
		}
		else
		{
			if (m_loop && m_isActive)
			{
				// Restart the sound...
				// REVIEW: This really shouldn't happen as the CAudioBuf object
				// should handle looping itself (to avoid pops)...
				ASSERT(FALSE);
//				TRACE(_T("looping %s\n"), m_url);
//				m_pSound->Play(m_loop);
//				m_transportMode = TRANSPORT_PLAY;
			}
			else
			{
				if (m_transportMode == TRANSPORT_PLAY)
				{
					m_transportMode = TRANSPORT_STOP;
					m_isActive = false;

					CallFunction(this, _T("OnEndOfAudio"));
				}
			}
		}
	}

	if (m_transportMode != m_lastTransportMode)
	{
		m_lastTransportMode = m_transportMode;
		CallFunction(this, _T("OnTransportModeChanged"));
	}
}

void CAudioClip::PlayOrPause()
{
	switch (m_transportMode)
	{
	case TRANSPORT_PLAY:
	case TRANSPORT_PAUSE:
		Pause();
		break;

	default:
		Play();
		break;
	}
}

void CAudioClip::Play()
{
	if (m_bDirty)
		Init();

//	if (m_transportMode == TRANSPORT_PLAY)
//		return;

	if (m_pSound != NULL)
	{
		m_pSound->SetAttenuation((1.0f - m_volume) * 100.0f);
		m_pSound->SetPan(m_pan);
		m_pSound->SetFrequency(m_frequency);

		if (m_pSound->Play(m_loop))
		{
			m_transportMode = TRANSPORT_PLAY;
			m_isActive = true;
		}
        else TRACE(_T("Play failed!\n"));
	}

}

void CAudioClip::Stop()
{
	if (m_transportMode == TRANSPORT_STOP)
		return;

	m_transportMode = TRANSPORT_STOP;

	if (m_pSound != NULL)
		m_pSound->Stop();

	delete m_pSound;
	m_pSound = NULL;

	m_isActive = false;
	m_bDirty = true; // so audio buffer is re-created and will start over
}

void CAudioClip::Pause()
{
	if (m_bDirty)
		Init();

	if (m_transportMode == TRANSPORT_PAUSE)
	{
		m_transportMode = TRANSPORT_PLAY;

		if (m_pSound != NULL)
			m_pSound->Pause(false);
	}
	else
	{
		m_transportMode = TRANSPORT_PAUSE;

		if (m_pSound != NULL)
			m_pSound->Pause(true);
	}
}

int CAudioClip::getMinutes()
{
	if (m_bDirty)
		Init();

	if (m_pSound == NULL)
		return 0;

	return (int)m_pSound->GetPlaybackTime() / 60;
}

int CAudioClip::getSeconds()
{
	if (m_bDirty)
		Init();

	if (m_pSound == NULL)
		return 0;

	return (int)m_pSound->GetPlaybackTime() % 60;
}


void* CAudioClip::GetSampleBuffer()
{
	if (m_pSound == NULL)
		return NULL;

	return m_pSound->GetSampleBuffer();
}

int CAudioClip::GetSampleBufferSize()
{
	if (m_pSound == NULL)
		return 0;

	return m_pSound->GetSampleBufferSize();
}

////////////////////////////////////////////////////////////////////////////

class CPeriodicAudioGroup : public CGroup
{
	DECLARE_NODE(CPeriodicAudioGroup, CGroup)
public:
	CPeriodicAudioGroup();
	
	void Advance(float nSeconds);

	bool m_isActive;
    bool m_pause_on_moving;
	float m_period;
	float m_periodNoise;

	XTIME m_timeOfNextEvent;
	int m_nNextClip;
    CAudioClip* m_pClip;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("PeriodicAudioGroup", CPeriodicAudioGroup, CGroup)

START_NODE_PROPS(CPeriodicAudioGroup, CGroup)
	NODE_PROP(pt_boolean, CPeriodicAudioGroup, isActive)
	NODE_PROP(pt_number, CPeriodicAudioGroup, period)
	NODE_PROP(pt_number, CPeriodicAudioGroup, periodNoise)
END_NODE_PROPS()


CPeriodicAudioGroup::CPeriodicAudioGroup() :
	m_isActive(false),
    m_pause_on_moving(true),
	m_period(10.0f),
	m_periodNoise(0.0f)
{
	m_visible = false;

	m_timeOfNextEvent = 0.0f;
	m_nNextClip = -1;
    m_pClip = NULL;
}

void CPeriodicAudioGroup::Advance(float nSeconds)
{
	CGroup::Advance(nSeconds);

    // Stop this background audio group if we are in the middle of level transition
    if (m_pause_on_moving && g_bLevelTransition)
    {
        if (m_pClip && m_pClip->IsKindOf(NODE_CLASS(CAudioClip)))
        {
            m_pClip->Stop();
        }

        return;
    }

	if (!m_isActive)
	{
		m_timeOfNextEvent = 0.0f;
		return;
	}

	int nChildCount = m_children.GetLength();
	if (nChildCount == 0)
		return;

	if (m_nNextClip < 0)
		m_nNextClip = rand() % nChildCount;

	if (m_timeOfNextEvent == 0.0f)
	{
		m_timeOfNextEvent = XAppGetNow() + m_period + rnd(m_periodNoise);
		TRACE(_T("Next clip will play in %0.2f seconds...\n"), m_timeOfNextEvent - XAppGetNow());
		return;
	}
	
	if (XAppGetNow() > m_timeOfNextEvent)
	{
		m_timeOfNextEvent = 0.0f;

		if (m_nNextClip >= nChildCount)
			m_nNextClip = 0;

		m_pClip = (CAudioClip*)m_children.GetNode(m_nNextClip);
		m_nNextClip += 1;

		if (!m_pClip->IsKindOf(NODE_CLASS(CAudioClip)))
		{
			TRACE(_T("CPeriodicAudioGroup: child %d is not an AudioClip!\n"), m_nNextClip-1);
			return;
		}

		TRACE(_T("CPeriodicAudioGroup: playing clip %d (%s)\n"), m_nNextClip-1, m_pClip->m_url);
		m_pClip->Play();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\background.h ===
class CBackground : public CNode
{
	DECLARE_NODE(CBackground, CNode)
public:
	CBackground();
	~CBackground();

	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	void Bind();
	void RenderBackdrop();

	CNode* m_backdrop;
	D3DXVECTOR3 m_skyColor;
	bool m_isBound;

	LPDIRECT3DVERTEXBUFFER8 m_pVB;

	DECLARE_NODE_PROPS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\AudioPump.cpp ===
#include "std.h"
#include "xapp.h"
#include "AudioPump.h"

LPDIRECTSOUNDBUFFER XAppCreateSoundBuffer(WAVEFORMATEX* pwfx, int nByteCount, DWORD dwFlags);
void XAppSetSoundBufferNotify(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, int nPositionCount, DSBPOSITIONNOTIFY* positions);
void XAppSetSoundBufferData(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, UINT nByteOffset, UINT nByteCount, const void* pvData);

////////////////////////////////////////////////////////////////////////////

CAudioBuf::CAudioBuf()
{
	m_pDSBuffer = NULL;
	m_bPaused = false;
	m_bLoop = false;
	m_nBufferBytes = 0;
}

CAudioBuf::~CAudioBuf()
{
	if (m_pDSBuffer != NULL)
	{
		m_pDSBuffer->Stop();
		m_pDSBuffer->Release();
	}
}

bool CAudioBuf::Initialize(WAVEFORMATEX* pWaveFormat, int nBufferBytes, const void* pvSamples/*=NULL*/)
{
	m_nBufferBytes = nBufferBytes;
	m_nBytesPerSecond = pWaveFormat->nAvgBytesPerSec;
	m_pDSBuffer = XAppCreateSoundBuffer(pWaveFormat, nBufferBytes, DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY);

	if (m_pDSBuffer == NULL)
		return false;

	if (pvSamples != NULL)
		XAppSetSoundBufferData(m_pDSBuffer, 0, nBufferBytes, pvSamples);

	return true;
}

void* CAudioBuf::Lock()
{
	LPVOID pvBuffer;
	DWORD dwBufferLength;

	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->Lock(0, m_nBufferBytes, &pvBuffer, &dwBufferLength, NULL, NULL, 0L));
	ASSERT(dwBufferLength == (DWORD)m_nBufferBytes);
	return pvBuffer;
}

void CAudioBuf::Unlock(void* pvBuffer)
{
	VERIFYHR(m_pDSBuffer->Unlock(pvBuffer, m_nBufferBytes, NULL, 0));
}

bool CAudioBuf::Play(bool bLoop/*=false*/)
{
	m_bPaused = false;
	m_bLoop = bLoop;

	if (m_pDSBuffer == NULL)
		return false;

	VERIFYHR(m_pDSBuffer->SetCurrentPosition(0));
	VERIFYHR(m_pDSBuffer->Play(0, 0, m_bLoop ? DSBPLAY_LOOPING : 0));

	return true;
}

void CAudioBuf::Stop()
{
	if (m_pDSBuffer != NULL)
    {
		VERIFYHR(m_pDSBuffer->Stop());
    }
}

void CAudioBuf::Pause(bool bPause)
{
	if (m_pDSBuffer == NULL)
		return;

	if (bPause)
	{
		m_bPaused = true;
		VERIFYHR(m_pDSBuffer->Stop());
	}
	else
	{
		m_bPaused = false;
		VERIFYHR(m_pDSBuffer->Play(0, 0, m_bLoop ? DSBPLAY_LOOPING : 0));
	}
}

bool CAudioBuf::IsPlaying()
{
	if (m_pDSBuffer == NULL)
		return false;

	DWORD dwStatus;
	VERIFYHR(m_pDSBuffer->GetStatus(&dwStatus));
	return (dwStatus & DSBSTATUS_PLAYING) != 0;
}

void CAudioBuf::SetAttenuation(float nAttenuation)
{
	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->SetVolume(-(int)(nAttenuation * 100.0f)));
}

void CAudioBuf::SetPan(float nPan)
{
	ASSERT(m_pDSBuffer != NULL);

#ifndef _XBOX
	VERIFYHR(m_pDSBuffer->SetPan((int)(nPan * 100.0f)));
#endif
}

void CAudioBuf::SetFrequency(float nFrequency)
{
	ASSERT(m_pDSBuffer != NULL);

	VERIFYHR(m_pDSBuffer->SetFrequency(nFrequency == 0.0f ? DSBFREQUENCY_ORIGINAL : (DWORD)nFrequency));
}

float CAudioBuf::GetPlaybackTime()
{
	if (m_pDSBuffer == NULL)
		return 0.0f;

	DWORD dwPlayCursor;
	VERIFYHR(m_pDSBuffer->GetCurrentPosition(&dwPlayCursor, NULL));

	return (float)dwPlayCursor / m_nBytesPerSecond;
}

float CAudioBuf::GetPlaybackLength()
{
	return (float)m_nBufferBytes / m_nBytesPerSecond;
}

void* CAudioBuf::GetSampleBuffer()
{
	return NULL;
}

DWORD CAudioBuf::GetSampleBufferSize()
{
	return 0;
}

////////////////////////////////////////////////////////////////////////////

CAudioPump::CAudioPump()
{
	m_hPlayThread = NULL;
	m_hTerminate = NULL;
    m_hMutex = NULL;
	m_nBufferBytes = 0;
	m_nCompletedBuffers = 0;
    m_dwPrevCursor = 0;
    m_nFilledBuffers = 0;
    m_nPumpState = PUMPSTATE_STOPPED;

    m_ahNotify = NULL;
    m_nSegmentsPerBuffer = 0;
    m_pfBufferFilled = 0;
}

CAudioPump::~CAudioPump()
{
	if (m_hTerminate != NULL)
		SetEvent(m_hTerminate);

	if (m_hPlayThread != NULL)
	{
		WaitForSingleObject(m_hPlayThread, INFINITE);
		CloseHandle(m_hPlayThread);
	}
	
	if (m_hTerminate != NULL)
		CloseHandle(m_hTerminate);

	if (m_hMutex != NULL)
		CloseHandle(m_hMutex);

	if (m_pDSBuffer != NULL)
	{
		m_pDSBuffer->Stop();
		m_pDSBuffer->Release();
		m_pDSBuffer = NULL;
	}

    if(m_ahNotify){
	    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
        {
            if (m_ahNotify[i])
                CloseHandle(m_ahNotify[i]);
        }
        delete [] m_ahNotify;
    }
    if(m_pfBufferFilled){
        delete [] m_pfBufferFilled;
    }
}

DWORD CALLBACK CAudioPump::StartThread(LPVOID pvContext)
{
	CAudioPump *pThis = (CAudioPump*)pvContext;
	return pThis->ThreadProc();
}

DWORD CAudioPump::ThreadProc()
{
    const HANDLE ahMutex[] = { m_hTerminate, m_hMutex };
    HANDLE* ahNotify = new HANDLE[1 + m_nSegmentsPerBuffer];
    if(!ahNotify){
        return -1;
    }
    int nBuffer;
    bool fMutex = false;
    DWORD dwWaitObj;

    ahNotify[0] = m_hTerminate;

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        ahNotify[i + 1] = m_ahNotify[i];
    }

	for (;;)
	{
		if (fMutex)
        {
            ReleaseMutex(m_hMutex);
            fMutex = false;
        }

        dwWaitObj = WaitForMultipleObjects(1 + m_nSegmentsPerBuffer, ahNotify, FALSE, INFINITE);
		if (dwWaitObj == WAIT_OBJECT_0)
        {
            break;
        }

        dwWaitObj = WaitForMultipleObjects(2, ahMutex, FALSE, INFINITE);
		if (dwWaitObj == WAIT_OBJECT_0)
        {
			break;
        }

        fMutex = true;

        if (m_nPumpState == PUMPSTATE_STOPPED)
        {
            continue;
        }

        if (m_nPumpState == PUMPSTATE_BUFFERING)
        {
            FillBuffer(m_nFilledBuffers);
            continue;
        }

        if ((m_nPumpState == PUMPSTATE_STOPPING) && (m_nFilledBuffers <= 0))
        {
            Stop();
            continue;
        }

        for (int i = 0; i < m_nSegmentsPerBuffer; i++)
        {
            if (WAIT_OBJECT_0 == WaitForSingleObject(m_ahNotify[i], 0))
            {
                nBuffer = i;

                break;
            }
        }

        if (i >= m_nSegmentsPerBuffer)
        {
            continue;
        }

        // We start the ball rolling by signaled all events. This
        // wakes us enough times that we can fill up all our buffers.
        // But, a side effect is that we get a bunch of false
        // signals. When we are playing very short audio clips, there may
        // actually be more false signals than there is data to play.
        // To keep this case from confusing us, we need to keep track
        // of which buffers actually have data in them.
        //
        // The m_pfBufferFilled array keeps track of which buffers are
        // actually  filled. This allows us to distinguish the initial
        // false signals from the normal signals.

        if(m_pfBufferFilled[nBuffer]){
            m_pfBufferFilled[nBuffer] = false;
            m_nFilledBuffers--;
        }

		FillBuffer(nBuffer);
	}

    Stop();

    if (fMutex)
    {
        ReleaseMutex(m_hMutex);
    }

    if(ahNotify){
        delete [] ahNotify;
    }

	return 0;
}

bool CAudioPump::Initialize(DWORD dwStackSize, WAVEFORMATEX* pWaveFormat, int nBufferBytes, int nSegmentsPerBuffer, int nPrebufferSegments)
{
	m_nBytesPerSecond = pWaveFormat->nAvgBytesPerSec;
	m_nBufferBytes = nBufferBytes;

    m_nSegmentsPerBuffer = nSegmentsPerBuffer;
    m_nPrebufferSegments = nPrebufferSegments;

    VERIFY((m_nPrebufferSegments <= m_nSegmentsPerBuffer));

    m_ahNotify = new HANDLE[m_nSegmentsPerBuffer];
    if(m_ahNotify == NULL){
        return false;
    }

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        m_ahNotify[i] = NULL;
    }

	VERIFY((m_hTerminate = CreateEvent(NULL, FALSE, FALSE, NULL)) != NULL);
    VERIFY((m_hMutex = CreateMutex(NULL, FALSE, NULL)) != NULL);

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
	    VERIFY((m_ahNotify[i] = CreateEvent(NULL, TRUE, FALSE, NULL)) != NULL);
    }

    m_pfBufferFilled = new bool[m_nSegmentsPerBuffer];
    if(!m_pfBufferFilled){
        return false;
    }

	DWORD dwThreadId;
	VERIFY((m_hPlayThread = CreateThread(NULL, dwStackSize, StartThread, this, 0, &dwThreadId)) != NULL);

	m_pDSBuffer = XAppCreateSoundBuffer(pWaveFormat, m_nSegmentsPerBuffer * m_nBufferBytes, DSBCAPS_CTRLPOSITIONNOTIFY | DSBCAPS_CTRLVOLUME | DSBCAPS_CTRLFREQUENCY);
	
    if (m_pDSBuffer == NULL)
		return false;

	// BLOCK: Set notification positions
	{
		DSBPOSITIONNOTIFY* dsbpn = new DSBPOSITIONNOTIFY[m_nSegmentsPerBuffer];
        if(dsbpn == NULL){
            return false;
        }

        for (i = 0; i < m_nSegmentsPerBuffer; i++)
        {
		    dsbpn[i].dwOffset = m_nBufferBytes * (i + 1) - pWaveFormat->nBlockAlign;
		    dsbpn[i].hEventNotify = m_ahNotify[i];
        }

		XAppSetSoundBufferNotify(m_pDSBuffer, m_nSegmentsPerBuffer, dsbpn);
        delete [] dsbpn;
	}

	return true;
}

bool CAudioPump::Play(bool bLoop/*=false*/)
{
    m_bLoop = bLoop;

	if (m_pDSBuffer == NULL)
		return false;

    WaitForSingleObject(m_hMutex, INFINITE);

    Stop();

    m_nPumpState = PUMPSTATE_BUFFERING;

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        SetEvent(m_ahNotify[i]);
        m_pfBufferFilled[i] = false;
    }

	for (int i = 0; i < m_nPrebufferSegments; i++)
    {
        FillBuffer(i);
    }

	VERIFYHR(m_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING));

    ReleaseMutex(m_hMutex);

	return true;
}

void CAudioPump::Stop()
{
	if (m_pDSBuffer == NULL)
		return;

    WaitForSingleObject(m_hMutex, INFINITE);

	VERIFYHR(m_pDSBuffer->Stop());
	VERIFYHR(m_pDSBuffer->SetCurrentPosition(0));

    DirectSoundDoWork();

    for (int i = 0; i < m_nSegmentsPerBuffer; i++)
    {
        ResetEvent(m_ahNotify[i]);
    }

	m_nCompletedBuffers = 0;
    m_nFilledBuffers = 0;
    m_nPumpState = PUMPSTATE_STOPPED;

    ReleaseMutex(m_hMutex);
}

void CAudioPump::Pause(bool bPause)
{
	if (m_pDSBuffer == NULL)
		return;

    WaitForSingleObject(m_hMutex, INFINITE);

	if (bPause)
	{
		m_bPaused = true;
		VERIFYHR(m_pDSBuffer->Stop());
	}
	else
	{
		m_bPaused = false;
		VERIFYHR(m_pDSBuffer->Play(0, 0, DSBPLAY_LOOPING));
	}

    ReleaseMutex(m_hMutex);
}

bool CAudioPump::IsPlaying()
{
	return (PUMPSTATE_STOPPED != m_nPumpState);
}

bool CAudioPump::FillBuffer(int nBuffer)
{
	int nBytes;

    ASSERT(m_pDSBuffer != NULL);

	LPVOID pvBuffer;
	DWORD dwBufferLength;

    WaitForSingleObject(m_hMutex, INFINITE);

    ResetEvent(m_ahNotify[nBuffer]);

	VERIFYHR(m_pDSBuffer->Lock(nBuffer * m_nBufferBytes, m_nBufferBytes, &pvBuffer, &dwBufferLength, NULL, NULL, 0L));
	ASSERT(dwBufferLength == (DWORD)m_nBufferBytes);

	if (PUMPSTATE_STOPPING == m_nPumpState)
    {
        nBytes = 0;
    }
    else
    {
        nBytes = GetData((BYTE*)pvBuffer, m_nBufferBytes);
    }

	if (nBytes < m_nBufferBytes)
    {
        m_nPumpState = PUMPSTATE_STOPPING;

        if (nBytes > 0)
        {
		    ZeroMemory(((BYTE*)pvBuffer) + nBytes, m_nBufferBytes - nBytes);
        }
        else
        {
		    ZeroMemory(pvBuffer, m_nBufferBytes);
        }
    }

	VERIFYHR(m_pDSBuffer->Unlock(pvBuffer, dwBufferLength, NULL, 0));

    if (nBytes > 0)
    {
        m_pfBufferFilled[nBuffer] = true;
        m_nFilledBuffers++;

        if (PUMPSTATE_BUFFERING == m_nPumpState)
        {
            if(m_nFilledBuffers >= m_nSegmentsPerBuffer)
            {
                m_nPumpState = PUMPSTATE_RUNNING;
            }
        }
    }

    ReleaseMutex(m_hMutex);

	return nBytes > 0;
}

float CAudioPump::GetPlaybackTime()
{
	if (m_pDSBuffer == NULL)
		return 0.0f;

	DWORD dwPlayCursor;
	VERIFYHR(m_pDSBuffer->GetCurrentPosition(&dwPlayCursor, NULL));

    if( dwPlayCursor < m_dwPrevCursor )
    {
        m_nCompletedBuffers++;
    }

    m_dwPrevCursor = dwPlayCursor;

    return (float)(m_nCompletedBuffers * ( m_nBufferBytes * m_nSegmentsPerBuffer ) + dwPlayCursor) / m_nBytesPerSecond;
}

float CAudioPump::GetPlaybackLength()
{
	return 0.0f;
}

////////////////////////////////////////////////////////////////////////////

CFilePump::CFilePump()
{
	m_pvBuffer = NULL;
	m_hFile = INVALID_HANDLE_VALUE;
	m_dwStartPos = 0;
    m_dwBufferSize = 0;
}

CFilePump::~CFilePump()
{
	if (m_hFile != INVALID_HANDLE_VALUE)
		CloseHandle(m_hFile);
}

bool CFilePump::Initialize(HANDLE hFile, int nFileBytes, WAVEFORMATEX* pFormat)
{
    m_dwBufferSize = (0x2000/pFormat->nBlockAlign) * pFormat->nBlockAlign;

	if (!CAudioPump::Initialize(8192, pFormat, m_dwBufferSize))
		return false;

	m_hFile = hFile;
	m_nPlaybackLength = (float)nFileBytes / m_nBytesPerSecond;
	m_dwStartPos = SetFilePointer(m_hFile, 0, NULL, FILE_CURRENT);

	return true;
}

void CFilePump::Stop()
{
	if (m_hFile == INVALID_HANDLE_VALUE)
		return;

	CAudioPump::Stop();

	SetFilePointer(m_hFile, m_dwStartPos, NULL, FILE_BEGIN);
}

float CFilePump::GetPlaybackLength()
{
	return m_nPlaybackLength;
}

void* CFilePump::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD CFilePump::GetSampleBufferSize()
{
	return m_dwBufferSize;
}

int CFilePump::GetData(BYTE* pbBuffer, int cbBuffer)
{
	DWORD dwRead;

	if (!ReadFile(m_hFile, pbBuffer, cbBuffer, &dwRead, NULL))
	{
		TRACE(_T("CFilePump::GetData ReadFile failed (%d)\n"), GetLastError());
		return -1;
	}

	if (m_bLoop && dwRead != (DWORD)cbBuffer)
	{
//		TRACE(_T("AutoLooping CFilePump...\n"));

		SetFilePointer(m_hFile, m_dwStartPos, NULL, FILE_BEGIN);

		DWORD dwRead2;
		if (!ReadFile(m_hFile, pbBuffer + dwRead, cbBuffer - dwRead, &dwRead2, NULL))
		{
			TRACE(_T("CFilePump::GetData ReadFile failed (%d)\n"), GetLastError());
			return -1;
		}

		dwRead += dwRead2;
	}

	m_pvBuffer = pbBuffer;

	return (int)dwRead;
}

////////////////////////////////////////////////////////////////////////////

const DWORD WMA_SEGMENTS_PER_BUFFER=4;

const DWORD WMASTRM_LOOKAHEAD_SIZE = 0x8000 * WMA_SEGMENTS_PER_BUFFER;
const DWORD WMASTRM_SOURCE_PACKET_BYTES = 0x8000;

CWMAPump::CWMAPump()
: m_nPlaybackLengthInSeconds( 0 ),
m_pSourceFilter( NULL ),
m_pvBuffer( NULL ),
m_hFile( INVALID_HANDLE_VALUE )
{
}

CWMAPump::~CWMAPump()
{
	if (m_pSourceFilter != NULL)
	{
        SignalObjectAndWait(m_hTerminate, m_hPlayThread, INFINITE, FALSE);
		m_pSourceFilter->Release();
		m_pSourceFilter = NULL;
	}

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;
	}
}

bool CWMAPump::Initialize(DWORD dwSongID, WAVEFORMATEX* pFormat)
{
    HANDLE hFile = XOpenSoundtrackSong(dwSongID, FALSE);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        TRACE(_T("Cannot open song 0x%08x\n"), dwSongID);
        return false;
    }

    // HACK: There is no way to use a SongID to get the Length of the Song
    // You must know the "index" within the SoundTrack of the song in order to get it's info
    // Because of this, we will loop on all the Songs in the current Soundtrack until we find
    // the correct one, and then store it's Length
    unsigned int uiSongIndex = 0;
    DWORD dwReturnedSongID;
    DWORD dwReturnedSongLength;

    while( TRUE )// Since we are using a SongID that is valid, this should be ok
    {
        if( !XGetSoundtrackSongInfo( DWORD HIWORD( dwSongID),
                                     uiSongIndex,
                                     &dwReturnedSongID,
                                     &dwReturnedSongLength,
                                     NULL,
                                     0 ) )
        {
            break;  // If this call fails, we should break out of our loop.
        }

        // Check to see if we found the song we are looking for
        if( dwSongID == dwReturnedSongID )
        {
            m_nPlaybackLengthInSeconds = (float)dwReturnedSongLength / 1000.0f;

            break;  // Since we found our song, we can stop searching
        };

        uiSongIndex++;
    }

    return Initialize(NULL, hFile, pFormat);
}

bool CWMAPump::Initialize(const TCHAR* szFileName, HANDLE hFile, WAVEFORMATEX* pFormat)
{
	ASSERT(szFileName == NULL || hFile == NULL);
	ASSERT(szFileName != NULL || hFile != NULL);

	ASSERT(m_hFile == INVALID_HANDLE_VALUE);

	if (szFileName == NULL)
		m_hFile = hFile;

	char szBuf [MAX_PATH];
	if (szFileName != NULL)
		Ansi(szBuf, szFileName, MAX_PATH);

	HRESULT hr = WmaCreateDecoder(szBuf, hFile, FALSE, WMASTRM_LOOKAHEAD_SIZE, m_nSegmentsPerBuffer, 0, pFormat, &m_pSourceFilter);
	if (hr != S_OK)
	{
#ifdef _DEBUG
		LogComError(hr, "WmaCreateDecoder");
#endif
		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;

		return false;
	}

	if (!CAudioPump::Initialize(0, pFormat, WMASTRM_SOURCE_PACKET_BYTES, WMA_SEGMENTS_PER_BUFFER))
	{
		m_pSourceFilter->Release();
		m_pSourceFilter = NULL;

		CloseHandle(m_hFile);
		m_hFile = INVALID_HANDLE_VALUE;

		return false;
	}

    m_pDSBuffer->SetHeadroom(0);

	return true;
}

int CWMAPump::GetData(BYTE* pbBuffer, int cbBuffer)
{
	ASSERT(cbBuffer == WMASTRM_SOURCE_PACKET_BYTES);

    DWORD dwSourceUsed;
    XMEDIAPACKET xmp;
    ZeroMemory(&xmp, sizeof(xmp));
    xmp.pvBuffer = pbBuffer;
    xmp.dwMaxSize = cbBuffer;
    xmp.pdwCompletedSize = &dwSourceUsed;

    HRESULT hr = m_pSourceFilter->Process(NULL, &xmp);
    if (FAILED(hr))
	{
		TRACE(_T("\001m_pSourceFilter->Process() failed!\n"));
        return -1;
	}

    if (dwSourceUsed < xmp.dwMaxSize)
	{
		TRACE(_T("WMA PLAYBACK IS DONE!\n"));

        // Call Flush so that the position is reset to begining
        m_pSourceFilter->Flush();
		return 0;
	}

	m_pvBuffer = pbBuffer;

	return WMASTRM_SOURCE_PACKET_BYTES;
}

float CWMAPump::GetPlaybackLength()
{
    return m_nPlaybackLengthInSeconds;
}

void* CWMAPump::GetSampleBuffer()
{
	return m_pvBuffer;
}

DWORD CWMAPump::GetSampleBufferSize()
{
	return WMASTRM_SOURCE_PACKET_BYTES;
}

void CWMAPump::Stop()
{
    CAudioPump::Stop();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Audio.h ===
#define TRANSPORT_STOP	0
#define TRANSPORT_PLAY	1
#define TRANSPORT_PAUSE	2

class CAudioBuf;

class CAudioClip : public CTimeDepNode
{
	DECLARE_NODE(CAudioClip, CTimeDepNode)
public:
	CAudioClip();
	~CAudioClip();

//	TCHAR* m_description;
//	float m_pitch;
	TCHAR* m_url;

	float m_fade;
	float m_volume;
	float m_pan;
	float m_frequency;

    bool m_sendProgress;
    bool m_pause_on_moving;
	float m_progress;
	bool m_removeVoice;
	int m_transportMode;
	int m_lastTransportMode;

	void Play();
	void Pause();
	void PlayOrPause();
	void Stop();

	int getMinutes();
	int getSeconds();

	void* GetSampleBuffer();
	int GetSampleBufferSize();

protected:
	bool m_bDirty;
    bool m_bUnpauseNeeded;
	float m_lastVolume;
	float m_lastPan;
	float m_lastFrequency;

	CAudioBuf* m_pSound;

	void Init();
	void Cleanup();

	bool OpenWaveFile();

	XBOXADPCMWAVEFORMAT m_format;

	void Advance(float nSeconds);
	void OnIsActiveChanged();
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

//	int m_nMinutesLast;
//	int m_nSecondsLast;

	DECLARE_NODE_PROPS()
	DECLARE_NODE_FUNCTIONS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Background.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"
#include "Background.h"

extern D3DXMATRIX g_matIdentity;
extern D3DXMATRIX g_matPosition;
extern D3DXMATRIX g_matView;


IMPLEMENT_NODE("Background", CBackground, CNode)

START_NODE_PROPS(CBackground, CNode)
	NODE_PROP(pt_vec3, CBackground, skyColor)
	NODE_PROP(pt_node, CBackground, backdrop)
	NODE_PROP(pt_boolean, CBackground, isBound)
END_NODE_PROPS()


CBackground::CBackground() :
	m_skyColor(0.0f, 0.0f, 0.0f),
	m_backdrop(NULL),
	m_isBound(false)
{
	m_pVB = NULL;

	if (theApp.m_pBackground == NULL)
		Bind();
}

CBackground::~CBackground()
{
	if (m_pVB != NULL)
		m_pVB->Release();

	if (m_backdrop != NULL)
		m_backdrop->Release();

	if (theApp.m_pBackground == this)
		theApp.m_pBackground = NULL;
}

void CBackground::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_backdrop != NULL)
		m_backdrop->Advance(nSeconds);

	if (m_pVB == NULL)
	{
		VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(D3DVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_VERTEX, D3DPOOL_MANAGED, &m_pVB));

		D3DVERTEX* verts;
		VERIFYHR(m_pVB->Lock(0, 4 * sizeof (D3DVERTEX), (BYTE**)&verts, 0));

		verts[0].dvX = (float)theApp.m_nViewWidth / 2.0f;
		verts[0].dvY = -(float)theApp.m_nViewHeight / 2.0f;
		verts[0].dvZ = -10000.0f;
		verts[0].dvNX = (float)theApp.m_nViewWidth / 2.0f;
		verts[0].dvNY = -(float)theApp.m_nViewHeight / 2.0f;
		verts[0].dvNZ = 1.0f;
		verts[0].dvTU = 1.0f;
		verts[0].dvTV = 1.0f;

		verts[1].dvX = -(float)theApp.m_nViewWidth / 2.0f;
		verts[1].dvY = -(float)theApp.m_nViewHeight / 2.0f;
		verts[1].dvZ = -10000.0f;
		verts[1].dvNX = (float)theApp.m_nViewWidth / 2.0f;
		verts[1].dvNY = (float)theApp.m_nViewHeight / 2.0f;
		verts[1].dvNZ = 1.0f;
		verts[1].dvTU = 0.0f;
		verts[1].dvTV = 1.0f;

		verts[2].dvX = (float)theApp.m_nViewWidth / 2.0f;
		verts[2].dvY = (float)theApp.m_nViewHeight / 2.0f;
		verts[2].dvZ = -10000.0f;
		verts[2].dvNX = (float)theApp.m_nViewWidth / 2.0f;
		verts[2].dvNY = (float)theApp.m_nViewHeight / 2.0f;
		verts[2].dvNZ = 1.0f;
		verts[2].dvTU = 1.0f;
		verts[2].dvTV = 0.0f;

		verts[3].dvX = -(float)theApp.m_nViewWidth / 2.0f;
		verts[3].dvY = (float)theApp.m_nViewHeight / 2.0f;
		verts[3].dvZ = -10000.0f;
		verts[3].dvNX = -(float)theApp.m_nViewWidth / 2.0f;
		verts[3].dvNY = (float)theApp.m_nViewHeight / 2.0f;
		verts[3].dvNZ = 1.0f;
		verts[3].dvTU = 0.0f;
		verts[3].dvTV = 0.0f;

		VERIFYHR(m_pVB->Unlock());
	}
}

/*
void CBackground::Render()
{
	if (m_skyColor.x == 0 && m_skyColor.y == 0 && m_skyColor.z == 0)
		return;

	return;

	if (m_rgvert == NULL)
	{
		static float angles [] = { 0.1f, 0.3f, 0.6f, 1.0f , D3DX_PI / 2.0f};
		static D3DCOLOR colors [] = 
		{
			D3DRGB(0, 0, 0),
			D3DRGB(0.3f, 0.1f, 0),
			D3DRGB(0.4f, 0.15f, 0),
			D3DRGB(0.6f, 0.25f, 0),
			D3DRGB(1.0f, 0.5f, 0),
			D3DRGB(1.0f, 0, 0)
		};

		CreateBackgroundSphere(true, 5, angles, 6, colors);
	}

	XAppPushWorld();

	D3DXVECTOR3 pos = theCamera.m_position;

	XAppIdentityWorld();
	XAppMultWorld(&g_matView);
	XAppUpdateWorld();

	XAppSetTexture(0, NULL);

	DWORD dwOldLighting;
	XAppGetRenderState(D3DRS_LIGHTING, &dwOldLighting);
	XAppSetRenderState(D3DRS_LIGHTING, false);

	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	XAppGetD3DDev()->SetVertexShader(D3DFVF_VERTEX);
	HRESULT hr = XAppGetD3DDev()->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_nIndices, m_nIndices * 3, m_rgindices, D3DFMT_INDEX16, m_rgvert, sizeof (m_rgvert[0]));
	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	
	XAppSetRenderState(D3DRS_LIGHTING, dwOldLighting);

	XAppPopWorld();
}
*/

/*
void CBackground::CreateBackgroundSphere(bool bSky, int n2, const float* angles, int nColors, D3DCOLOR* colors)
{
	int i, j;

	float r = 20.0f;
	int n1 = 12;

	if (n1 <= 0)
		n1 = 12;

	if (n2 <= 0)
		n2 = n1 / 2;

	n1 += 1;
	n2 += 1;

	// Create vertices...

	m_nVerts = n1 * n2;
	m_rgvert = new D3DLVERTEX [m_nVerts];

	float du = (2.0f * D3DX_PI) / (float) (n1 - 1);
	float dv = D3DX_PI / (float) (n2 - 1);

	float dpu = 1.0f / (float) (n1 - 1);
	float dpv = 1.0f / (float) (n2 - 1);

	float c0 = -D3DX_PI * 0.5;

	for (i = 0; i < n1; i++)
	{
		int offset = i * n2;

		float u = c0 +  du * i;
		float cosu = cosf(u);
		float sinu = sinf(u);

		float pu = 1.0f - ((float) (i) * dpu);

		for (j = 0; j < n2; j++)
		{
			float v;

			if (j == 0)
				v = 0; 
			else
				v = angles[j - 1];

			if (!bSky)
				v = D3DX_PI - v;

			float cosv = cosf(v);
			float sinv = sinf(v);

			m_rgvert[offset + j].dvX = r * cosu * sinv;
			m_rgvert[offset + j].dvY = r * sinu * sinv;
			m_rgvert[offset + j].dvZ = r * cosv;

			m_rgvert[offset + j].dcColor = colors[min(nColors - 1, j)];
		}
	}


	// Create faces...

	m_nIndices = (n1 - 1) * (n2 - 1) * 3 * 2;
	m_rgindices = new WORD [m_nIndices];
	WORD* pw = m_rgindices;

	for (i = 0; i < (n1 - 1); i++)
	{
		int voffset = i * n2;

		for (j = 0; j < (n2 - 1); j++)
		{
			if (bSky)
			{
				*pw++ = voffset + (j + 1);
				*pw++ = voffset + n2 + (j + 1);
				*pw++ = voffset + j + n2;

				*pw++ = voffset + (j + 1);
				*pw++ = voffset + j + n2;
				*pw++ = voffset + j;
			}
			else
			{
				*pw++ = voffset + (j + 1);
				*pw++ = voffset + j;
				*pw++ = voffset + j + n2;

				*pw++ = voffset + (j + 1);
				*pw++ = voffset + j + n2;
				*pw++ = voffset + n2 + (j + 1);
			}
		}
	}
}
*/

void CBackground::RenderBackdrop()
{
	ASSERT(m_backdrop != NULL);

	LPDIRECT3DTEXTURE8 pTexture = m_backdrop->GetTextureSurface();
	if (pTexture == NULL)
		return;

	XAppSetTexture(0, pTexture);
	XAppSetTexture(1, NULL);

	D3DXMATRIX matProjection, matProjectionSave, matWorldSave, matViewSave;

	XAppGetTransform(D3DTS_PROJECTION, &matProjectionSave);
	XAppGetTransform(D3DTS_WORLD, &matWorldSave);
	XAppGetTransform(D3DTS_VIEW, &matViewSave);

	D3DXMatrixOrthoLH(&matProjection, theApp.m_nViewWidth, theApp.m_nViewHeight, -10000.0f, 10000.0f);
	XAppSetTransform(D3DTS_PROJECTION, &matProjection);
	XAppSetTransform(D3DTS_WORLD, &g_matIdentity);
	XAppSetTransform(D3DTS_VIEW, &g_matIdentity);

	DWORD dwLighting, dwAlphaBlendEnable, dwCullMode, dwZWriteEnable;
	XAppGetRenderState(D3DRS_LIGHTING, &dwLighting);
	XAppGetRenderState(D3DRS_ALPHABLENDENABLE, &dwAlphaBlendEnable);
	XAppGetRenderState(D3DRS_CULLMODE, &dwCullMode);
	XAppGetRenderState(D3DRS_ZWRITEENABLE, &dwZWriteEnable);

	XAppSetRenderState(D3DRS_LIGHTING, FALSE);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
	XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
	XAppSetRenderState(D3DRS_ZWRITEENABLE, FALSE);

	XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
	XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	XAppSetTextureStageState(0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE);
	XAppSetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);

		VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (D3DVERTEX)));
		VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_VERTEX));
		VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

	XAppSetRenderState(D3DRS_LIGHTING, dwLighting);
	XAppSetRenderState(D3DRS_ALPHABLENDENABLE, dwAlphaBlendEnable);
	XAppSetRenderState(D3DRS_CULLMODE, dwCullMode);
	XAppSetRenderState(D3DRS_ZWRITEENABLE, dwZWriteEnable);

	XAppSetTransform(D3DTS_PROJECTION, &matProjectionSave);
	XAppSetTransform(D3DTS_WORLD, &matWorldSave);
	XAppSetTransform(D3DTS_VIEW, &matViewSave);
}

void CBackground::Bind()
{
	if (theApp.m_pBackground != NULL)
		theApp.m_pBackground->m_isBound = false;

	theApp.m_pBackground = this;
	m_isBound = true;
}

bool CBackground::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_isBound))
	{
		if (*(bool*)pvValue)
			Bind();
	}

	return true;
}




/*
D3DXQUATERNION backgroundRotation(0, 0, 1.0f, 0);

void CBackground::UpdateBackgroundCamera(Vector axis,float angle)
{
	// realign current transformation of background node with new camera 
	if (backgroundRotation != NULL)
	{
		if (thirdPersonView)
		{
			// need physical camera rotation
			ConvertCameraToOrientation(physicalCamera->position, physicalCamera->target, physicalCamera->up,axis, angle);
		}

		backgroundRotation = D3DXQUATERNION(axis.x, axis.y, axis.z, -angle);

		GCamera *theCamera = &m_camera;
		GCamera *c = GetPhysicalCamera();

		// take view angle constant 
		float field = 2.0;
		float targetDistance = field / (2.0f * tanf(c->GetFovY() * 0.5f));
		D3DXVECTOR3 dir(0.0f, 0.0f, -1.0f);

		theCamera->position = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
		theCamera->height = field;
		theCamera->width = field;
		theCamera->target = theCamera->position + targetDistance * dir;
		theCamera->SetAspect(c->aspect);
		theCamera->SetFieldPixel(renderState.renderSizex, renderState.renderSizey);
	}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\AudioPump.h ===
#pragma once

#define _D3DTYPES_H_
#include <dsound.h>

// Static audio buffer for sound effects...
class CAudioBuf
{
public:
	CAudioBuf();
	virtual ~CAudioBuf();

	bool Initialize(WAVEFORMATEX* pWaveFormat, int nBufferBytes, const void* pvSamples = NULL);
	void* Lock();
	void Unlock(void* pvBuffer);

	virtual bool Play(bool bLoop = false);
	virtual void Stop();
	virtual float GetPlaybackTime();
	virtual float GetPlaybackLength(); // NOTE: will return 0 if unknown!
	virtual bool IsPlaying();

	virtual void Pause(bool bPause);
	inline bool IsPaused() const { return m_bPaused; }

	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

	void SetAttenuation(float nAttenuation); // 0..100 dB
	void SetPan(float nPan); // -100..100 dB
	void SetFrequency(float nFrequency); // 0 (normal), or 100..100,000

protected:
	bool m_bLoop;
	bool m_bPaused;
	int m_nBufferBytes;
	int m_nBytesPerSecond;
	LPDIRECTSOUNDBUFFER m_pDSBuffer;
};


// Double-buffered Audio Buffer for streaming...
class CAudioPump : public CAudioBuf
{
public:
	CAudioPump();
	~CAudioPump();

	bool Initialize(DWORD dwStackSize, WAVEFORMATEX* pWaveFormat, int nBufferBytes, int nSegmentsPerBuffer = 4, int nPrebufferSegments = 1);

	virtual bool Play(bool bLoop = false);
	virtual void Stop();
	virtual bool IsPlaying();
	virtual float GetPlaybackTime();
	virtual void Pause(bool bPause);
	virtual float GetPlaybackLength(); // NOTE: will return 0 if unknown!

protected:
	enum
    {
        PUMPSTATE_STOPPED,
        PUMPSTATE_BUFFERING,
        PUMPSTATE_RUNNING,
        PUMPSTATE_STOPPING,
    };

    static DWORD CALLBACK StartThread(LPVOID pvContext);
	DWORD ThreadProc();

	HANDLE m_hPlayThread;
	HANDLE m_hTerminate;
	HANDLE m_hRun;
	HANDLE* m_ahNotify; // m_nSegmentsPerBuffer events
    HANDLE m_hMutex;

    DWORD m_dwPrevCursor;
	int m_nCompletedBuffers;
    int m_nFilledBuffers;
    bool* m_pfBufferFilled; // m_nSegmentsPerBuffer bools
    int m_nPumpState;

    int m_nSegmentsPerBuffer;
    int m_nPrebufferSegments;

	bool FillBuffer(int nBuffer);
	virtual int GetData(BYTE* pbBuffer, int cbBuffer) = 0;
};


// Audio Buffer for streaming large files...
class CFilePump : public CAudioPump
{
public:
	CFilePump();
	~CFilePump();

	bool Initialize(HANDLE hFile, int nFileBytes, WAVEFORMATEX* pFormat);
	virtual void Stop();

	virtual float GetPlaybackLength();

	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

protected:
	virtual int GetData(BYTE* pbBuffer, int cbBuffer);
	HANDLE m_hFile;
	void* m_pvBuffer;
	float m_nPlaybackLength;
	DWORD m_dwStartPos;
    DWORD m_dwBufferSize;
};

#ifdef _XBOX

// WMA decoding Audio Buffer for soundtracks...
class CWMAPump : public CAudioPump
{
public:
	CWMAPump();
	~CWMAPump();

	bool Initialize(const TCHAR* szFileName, HANDLE hFile, WAVEFORMATEX* pFormat);
	bool Initialize(DWORD dwSongID, WAVEFORMATEX* pFormat);

	virtual float GetPlaybackLength();

	virtual void* GetSampleBuffer();
	virtual DWORD GetSampleBufferSize();

    virtual void Stop();

protected:
	virtual int GetData(BYTE* pbBuffer, int cbBuffer);
	HANDLE m_hFile;
	XFileMediaObject* m_pSourceFilter;
	void* m_pvBuffer;
	float m_nPlaybackLengthInSeconds;	// Used to store the length of the WMA song from the Database
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Camera.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"
#include "Shape.h"
#include "Interpolator.h"

extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matPosition;

IMPLEMENT_NODE("Camera", CCamera, CNode)

START_NODE_PROPS(CCamera, CNode)
	NODE_PROP(pt_string, CCamera, mode)
	NODE_PROP(pt_node, CCamera, lookat)
END_NODE_PROPS()

CCamera theCamera;

CCamera::CCamera()
{
	Reset();
	m_mode = NULL;

#ifdef COOL_XDASH
	m_bNoisy = true;
#else
	m_bNoisy = false;
#endif
}

CCamera::~CCamera()
{
	delete [] m_mode;
}

void CCamera::Reset()
{
	m_nDeltaTime = 0.0f;
	m_position.x = 0.0f;
	m_position.y = 0.0f;
	m_position.z = 20.0f;

	D3DXQuaternionIdentity(&m_orientation);
}

void CCamera::UpdateViewMatrix()
{
	D3DXVECTOR3 position = m_position;
	D3DXQUATERNION orientation = m_orientation;

	if (m_bNoisy)
	{
		float t = (float) (XAppGetNow() / 4.0f);
		float x = sinf(t * D3DX_PI / 2.0f);
		float y = sinf(t * D3DX_PI);

		// Plus or minus 1 degree...
		x *= D3DX_PI / 180.0f;
		y *= D3DX_PI / 180.0f;

		D3DXQUATERNION q;
		D3DXQuaternionRotationYawPitchRoll(&q, x, y, 0.0f);
		D3DXQuaternionMultiply(&orientation, &q, &orientation);
	}

	m_actualPosition = position;
	D3DXMatrixAffineTransformation(&g_matPosition, 1.0f, NULL, &orientation, &position);
	D3DXMatrixInverse(&g_matView, NULL, &g_matPosition);
	g_matView._31 = -g_matView._31;
	g_matView._32 = -g_matView._32;
	g_matView._33 = -g_matView._33;
	g_matView._34 = -g_matView._34;
	XAppSetTransform(D3DTS_VIEW, &g_matView);
}

void CCamera::Set(const D3DXVECTOR3* pPosition, const D3DXQUATERNION* pOrientation, float nSeconds/*=0.0f*/)
{
//	TRACE(_T("CCamera::Set(%f,%f,%f)\n"), pPosition->x, pPosition->y, pPosition->z);

	m_newPosition = *pPosition;
	m_newOrientation = *pOrientation;

	m_oldPosition = m_position;
	m_oldOrientation = m_orientation;

	m_nStartTime = theApp.m_now;
	m_nDeltaTime = nSeconds;

	if (m_nDeltaTime <= 0.0f)
	{
		m_position = m_newPosition;
		m_orientation = m_newOrientation;
	}
}

void CCamera::Advance(float nSeconds)
{
	if (m_nDeltaTime > 0.0f)
	{
		float f = (float) (theApp.m_now - m_nStartTime) / m_nDeltaTime;
		if (f >= 1.0f)
		{
			m_nDeltaTime = 0.0f;
			f = 1.0f;
		}

		D3DXVec3Lerp(&m_position, &m_oldPosition, &m_newPosition, f);
		D3DXQuaternionSlerp(&m_orientation, &m_oldOrientation, &m_newOrientation, f);

//		TRACE(_T("CCamera::Advance(%f,%f,%f)\n"), m_position.x, m_position.y, m_position.z);
#ifndef _XBOX
		if (theApp.m_pNavigator != NULL)
		{
			theApp.m_pNavigator->m_position = m_position;
			theApp.m_pNavigator->m_orientation = m_orientation;
		}
#endif
	}
#ifndef _XBOX
	else if (theApp.m_pNavigator != NULL)
	{
		if (m_lookat != NULL && m_lookat->GetNodeClass() == NODE_CLASS(CShape))
		{
			m_position = theApp.m_pNavigator->m_position;
			D3DXVECTOR3 lookat = ((CShape*)m_lookat)->m_position;
			AdvanceWatch(nSeconds, lookat);
		}
		else
		{
			int nMode = 0;

			if (m_mode != NULL)
			{
				switch (m_mode[0])
				{
				case 'w':
					nMode = 1;
					break;

				case 'c':
					nMode = 2;
					break;
				}
			}

			switch (nMode)
			{
			case 0: // "inside looking forward" mode
				m_position = theApp.m_pNavigator->m_position;
				m_orientation = theApp.m_pNavigator->m_orientation;
				break;

			case 1: // "stationary watch cam" mode
				{
					bool bSlerp = true;
					D3DXVECTOR3 newPosition(m_position.x, m_position.y, m_position.z);

					float a = newPosition.x - theApp.m_pNavigator->m_position.x;
					float b = newPosition.z - theApp.m_pNavigator->m_position.z;
					float dist = sqrtf(a * a + b * b);
					if (dist > 50.0f)
					{
						float yaw = D3DX_PI / 2 - theApp.m_pNavigator->m_yaw;
						newPosition = theApp.m_pNavigator->m_position;
						dist = 5.0f + rnd(10.0f);
						newPosition.x -= cosf(yaw) * dist;
						newPosition.z -= sinf(yaw) * dist;

						yaw = theApp.m_pNavigator->m_yaw;
						dist = rnd(20.0f) - 10.0f;
						newPosition.x += cosf(yaw) * dist;
						newPosition.z += sinf(yaw) * dist;

						float groundHeight = 0.0f;
						if (theApp.m_pGround != NULL)
							groundHeight = theApp.m_pGround->GetGroundHeight(newPosition.x, newPosition.z);

						float y = groundHeight;
						float height = 2.0f + rnd(20.0f); // TODO: make this adjustable... (height of camera above the ground)

						newPosition.y = y + height;
						bSlerp = false;
					}

					D3DXMATRIX mat;
					D3DXVECTOR3 up(0.0f, 1.0f, 0.0f);
					D3DXMatrixLookAtLH(&mat, &newPosition, &theApp.m_pNavigator->m_position, &up);
					D3DXMatrixInverse(&mat, NULL, &mat);
					D3DXQUATERNION newOrientation;
					D3DXQuaternionRotationMatrix(&newOrientation, &mat);

	//				D3DXVec3Lerp(&m_position, &m_position, &newPosition, 0.05f);
					m_position = newPosition;
					if (bSlerp)
						D3DXQuaternionSlerp(&m_orientation, &m_orientation, &newOrientation, 0.1f);
					else
						m_orientation = newOrientation;
				}
				break;

			case 2: // "chase cam" mode
				AdvanceChase(nSeconds, theApp.m_pNavigator->m_position, theApp.m_pNavigator->m_yaw);
				break;
			}
		}
	}
#endif

	UpdateViewMatrix();
}


#ifndef _XBOX
void CCamera::AdvanceChase(float nSeconds, const D3DXVECTOR3& chasePosition, float yaw)
{
	D3DXVECTOR3 newPosition;

	float x = chasePosition.x;
	float y = chasePosition.y;
	float z = chasePosition.z;
	
	yaw = D3DX_PI / 2 - yaw;

	float dist = 5.0f;

	newPosition.x = x + cosf(yaw) * dist;
	newPosition.z = z + sinf(yaw) * dist;

	float groundHeight = 0.0f;
	if (theApp.m_pGround != NULL)
		groundHeight = theApp.m_pGround->GetGroundHeight(newPosition.x, newPosition.z);

	float height = 1.0f;

	if (y < groundHeight)
		y = groundHeight;

	newPosition.y = y + height;

	float h = sqrtf((chasePosition.x - newPosition.x) * (chasePosition.x - newPosition.x) +
		(chasePosition.z - newPosition.z) * (chasePosition.z - newPosition.z));
	float pitch = atan2f(chasePosition.y - newPosition.y, h);

	D3DXQUATERNION newOrientation;
	D3DXQuaternionRotationYawPitchRoll(&newOrientation, yaw, pitch, 0.0f);

	D3DXVec3Lerp(&m_position, &m_position, &newPosition, 0.25f);
	D3DXQuaternionSlerp(&m_orientation, &m_orientation, &newOrientation, 0.25f);
}

void CCamera::AdvanceWatch(float nSeconds, const D3DXVECTOR3& watchPosition)
{
	D3DXMATRIX mat;
	D3DXVECTOR3 up(0.0f, -1.0f, 0.0f);
	D3DXMatrixLookAtLH(&mat, &m_position, &watchPosition, &up);
	D3DXMatrixInverse(&mat, NULL, &mat);
	D3DXQUATERNION newOrientation;
	D3DXQuaternionRotationMatrix(&newOrientation, &mat);

	D3DXQuaternionSlerp(&m_orientation, &m_orientation, &newOrientation, 0.1f);
}
#endif


////////////////////////////////////////////////////////////////////////////

IMPLEMENT_NODE("CameraPath", CCameraPath, CNode)

START_NODE_PROPS(CCameraPath, CNode)
	NODE_PROP(pt_boolean, CCameraPath, isActive)
	NODE_PROP(pt_boolean, CCameraPath, backward)
	NODE_PROP(pt_number, CCameraPath, interval)
	NODE_PROP(pt_node, CCameraPath, position)
	NODE_PROP(pt_node, CCameraPath, orientation)
END_NODE_PROPS()

CCameraPath::CCameraPath() :
	m_isActive(false),
	m_backward(false),
	m_interval(1.0f),
	m_position(NULL),
	m_orientation(NULL)
{
}

CCameraPath::~CCameraPath()
{
	if (m_position != NULL)
		m_position->Release();

	if (m_orientation != NULL)
		m_orientation = NULL;
}

void CCameraPath::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (!m_isActive)
		return;

	float t = (float) (XAppGetNow() - m_startTime) / m_interval;
	if (t >= 1.0f)
	{
		t = 1.0f;
		m_isActive = false;

		TRACE(_T("End of camera path\n"));
	}

	if (m_backward)
		t = 1.0f - t;

	D3DXVECTOR3 position = theCamera.m_position;
	D3DXQUATERNION orientation = theCamera.m_orientation;

	if (m_position != NULL)
	{
		position = ((CPositionInterpolator*)m_position)->Interpolate(t);
		position.z = -position.z;
	}

	if (m_orientation != NULL)
		orientation = ((COrientationInterpolator*)m_orientation)->Interpolate(t);
	
	theCamera.Set(&position, &orientation);

#ifndef _XBOX
	if (theApp.m_pNavigator != NULL)
	{
		theApp.m_pNavigator->m_position = position;
		theApp.m_pNavigator->m_orientation = orientation;
	}
#endif
}

bool CCameraPath::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_isActive))
		m_startTime = XAppGetNow();

	return true;
}

void CCameraPath::Activate(bool bBackwards)
{
	m_isActive = true;
	m_startTime = XAppGetNow();
	m_backward = bBackwards;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\AudioVisualizer.cpp ===
#include "std.h"

#include "xapp.h"
#include "Node.h"
#include "Audio.h"
#include "surfx.h"
#include "fft.h"

class CAudioVisualizer : public CNode
{
	DECLARE_NODE(CAudioVisualizer, CNode)
public:
	CAudioVisualizer();
	~CAudioVisualizer();

//	int m_size;
	TCHAR* m_type; // line, spiner, circle
	TCHAR* m_channel; // left, center, right
	CNode* m_source;
	float m_scale;
	float m_offset;

protected:
	short* GetMonoPCM();
	void UpdateSpectrum();

	void RenderDynamicTexture(CSurfx* pSurfx);
	void Advance(float nSeconds);
	void CalcSpectrum(short* pcm, short* fft);

	void RenderEffect1(CSurfx* pSurfx);
	void RenderEffect2(CSurfx* pSurfx);

	// the last n stereo samples
	short m_pcmLeft [256];
	short m_pcmRight [256];

	// these are calculated from m_left and m_right as requested...
	short m_fftLeft [128];
	short m_fftRight [128];
	bool m_bFFTValid;
	short m_pcmMono [256];
	bool m_bMonoValid;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("AudioVisualizer", CAudioVisualizer, CNode)

START_NODE_PROPS(CAudioVisualizer, CNode)
	NODE_PROP(pt_number, CAudioVisualizer, scale)
	NODE_PROP(pt_number, CAudioVisualizer, offset)
	NODE_PROP(pt_string, CAudioVisualizer, type)
	NODE_PROP(pt_string, CAudioVisualizer, channel)
	NODE_PROP(pt_node, CAudioVisualizer, source)
END_NODE_PROPS()


CAudioVisualizer::CAudioVisualizer() :
	m_type(NULL),
	m_source(NULL),
	m_scale(1.0f),
	m_offset(0.0f),
	m_channel(NULL)
{
}

CAudioVisualizer::~CAudioVisualizer()
{
	delete [] m_type;
	delete [] m_channel;

	if (m_source != NULL)
		m_source->Release();
}

void CAudioVisualizer::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_source != NULL)
		m_source->Advance(nSeconds);
}


short* CAudioVisualizer::GetMonoPCM()
{
	if (!m_bMonoValid)
	{
		for (int i = 0; i < 256; i += 1)
		{
			m_pcmMono[i] = (short)(((int)m_pcmLeft[i] + (int)m_pcmRight[i]) / 2);
		}

		m_bMonoValid = true;
	}

	return m_pcmMono;
}

void CAudioVisualizer::CalcSpectrum(short* pcm, short* fft)
{
	static fft_state *state = NULL;
	float buf [FFT_BUFFER_SIZE / 2 + 1];
	
	if (!state)
		state = fft_init();

	fft_perform(pcm, buf, state);
	
	// BLOCK: Scale the fft data
	{
//		float scale = 8.0f;
		for (int i = 0; i < FFT_BUFFER_SIZE / 2 + 1; i += 1)
		{
//			buf[i] = logf(sqrtf(buf[i]) / FFT_BUFFER_SIZE) * scale;
			buf[i] = sqrtf(buf[i]) / FFT_BUFFER_SIZE;
			fft[i] = (short)buf[i];
		}
	}
/*
	// BLOCK: Move to byte sized buffer...
	{
		for (int i = 0; i < 128; i++)
		{
			short n = (short)buf[i + 1];

			if (n < 0)
				n = 0;
			else if (n > 255)
				n = 255;

			fft[i] = (BYTE)n;
		}
	}
*/
}

void CAudioVisualizer::UpdateSpectrum()
{
	if (m_bFFTValid)
		return;

	CalcSpectrum(m_pcmLeft, m_fftLeft);
	CalcSpectrum(m_pcmRight, m_fftRight);

	m_bFFTValid = true;
}


#define mag(s) ((float)samples[(int)(s * nSamples) * 2 + lrc] / 32767.0f)


void CAudioVisualizer::RenderDynamicTexture(CSurfx* pSurfx)
{
	CAudioClip* pAudioClip = (CAudioClip*)m_source;
	if (pAudioClip == NULL || pAudioClip->GetNodeClass() != NODE_CLASS(CAudioClip) || pAudioClip->m_transportMode != TRANSPORT_PLAY)
		return;

	short* samples = (short*)pAudioClip->GetSampleBuffer();
	if (samples == NULL)
		return;

	int nSamples = pAudioClip->GetSampleBufferSize() / 4;

	if (nSamples <= 0)
		return;

	// BLOCK: Setup our local buffers...
	{
		if (nSamples > 256)
			nSamples = 256;

		for (int i = 0; i < nSamples; i += 1)
		{
			m_pcmLeft[i] = samples[i * 2];
			m_pcmRight[i] = samples[i * 2 + 1];
		}

#ifdef _DEBUG
		if (i < 256)
			TRACE(_T("CAudioVisualizer:: fewer than 256 samples!\n"));
#endif

		for (; i < 256; i += 1)
		{
			m_pcmLeft[i] = 0;
			m_pcmRight[i] = 0;
		}

		m_bMonoValid = false;
		m_bFFTValid = false;
	}

	////////////////////////////////////////////////////////////////////////

	if (nSamples > pSurfx->m_nHeight)
		nSamples = pSurfx->m_nHeight;

	int lrc = 0;
	if (m_channel != NULL)
	{
		if (m_channel[0] == 'r' || m_channel[0] == 'R')
			lrc = 1;
	}

	int nType = 0;
	if (m_type != NULL)
	{
		switch (m_type[0])
		{
		case 's':
		case 'S':
			nType = 1; // spinner;
			break;

		case 'c':
		case 'C':
			nType = 2; // circle scope
			break;

		case 'a':
		case 'A':
			nType = 3; // spectrum analyzer
			break;
		}
	}

	float t = (float) XAppGetNow();

	switch (nType)
	{
	case 0:
		// Line Scope
		{
			int xCenter = pSurfx->m_nWidth / 2;
			int xp = xCenter;
			int yp = 0;

			for (int y = 0; y < nSamples; y += 1)
			{
				long s = (((long)samples[y * 2 + lrc]) * pSurfx->m_nWidth) >> 16;
				int x = xCenter + s;

				pSurfx->Line(xp, yp, x, y, 255);
				xp = x;
				yp = y;
			}
		}
		break;

	case 1: // Spinner Scope
		{
			int xCenter = pSurfx->m_nWidth / 2;
			int yCenter = pSurfx->m_nHeight / 2;

			float step = 1.0f / (float)pSurfx->m_nWidth;

			float firstX, firstY;
			float prevX, prevY;

			float A0 = 0.5f + rnd(0.2f); // rotation rate

			float B0 = cosf(t * 0.2f);
			float B1 = sinf(t * 0.2f);

			for (float s = 0.0f; s <= 1.0; s += step)
			{
				float C0 = mag(s) * m_scale + m_offset;// * 0.25f + 0.2f;
				float C1 = 2.1f * (s - 0.5f);

				float X0 = B0 * C1 + B1 * C0;
				float Y0 = -B0 * C0 + B1 * C1;

				float X1 = B0 * C1 - B1 * C0;
				float Y1 = B0 * C0 + B1 * C1;

				if (s == 0.0f)
				{
					firstX = X0;
					firstY = Y0;
				}
				else
				{
					pSurfx->Line(xCenter + (int)(prevX * xCenter), yCenter + (int)(prevY * yCenter),
						xCenter + (int)(X0 * xCenter), yCenter + (int)(Y0 * yCenter), 255);
				}

				prevX = X0;
				prevY = Y0;
			}

	//		pSurfx->Line(xCenter + (int)(prevX * xCenter), yCenter + (int)(prevY * yCenter),
	//			xCenter + (int)(firstX * xCenter), yCenter + (int)(firstY * yCenter), 255);
		}
		break;

#if 0
	case 2: // Circle Scope
		{
			int xCenter = pSurfx->m_nWidth / 2;
			int yCenter = pSurfx->m_nHeight / 2;

			float step = 1.0f / (float)pSurfx->m_nWidth;

			float firstX, firstY;
			float prevX, prevY;

			int i = 0;
			for (float s = 0.0f; s <= 1.0; s += step, i += 1)
			{
				float sample = (float)samples[i * 2 + lrc] / 32767.0f;

				float C0 = sample * m_scale + m_offset; // radius
				float C1 = s * D3DX_PI; // angle

				float X0 = C0 * sinf(C1);
				float Y0 = C0 * cosf(C1);

				int x = xCenter + (int)(X0 * xCenter);
				int y = yCenter + (int)(Y0 * yCenter);

#if 0
				if (x >= 0 && x < pSurfx->m_nWidth && y >= 0 && y < pSurfx->m_nHeight)
					*pSurfx->Pixel(x, y) = 255;
				x = xCenter - (int)(X0 * xCenter);
				if (x >= 0 && x < pSurfx->m_nWidth && y >= 0 && y < pSurfx->m_nHeight)
					*pSurfx->Pixel(x, y) = 255;
#else
				if (i == 0)
				{
					firstX = X0;
					firstY = Y0;
				}
				else
				{
					pSurfx->Line(xCenter + (int)(prevX * xCenter), yCenter + (int)(prevY * yCenter),
						xCenter + (int)(X0 * xCenter), yCenter + (int)(Y0 * yCenter), 255);
					pSurfx->Line(xCenter - (int)(prevX * xCenter), yCenter + (int)(prevY * yCenter),
						xCenter - (int)(X0 * xCenter), yCenter + (int)(Y0 * yCenter), 255);
				}

				prevX = X0;
				prevY = Y0;
#endif
			}

	//		pSurfx->Line(xCenter + (int)(prevX * xCenter), yCenter + (int)(prevY * yCenter),
	//			xCenter + (int)(firstX * xCenter), yCenter + (int)(firstY * yCenter), 255);
		}
		break;
#endif

	case 3: // spectrum analyzer
		{
			UpdateSpectrum();

			static int peak_buf [256];
			BYTE spectrum [256];

			for (int i = 0; i < 128; i += 1)
			{
				float n = logf(m_fftLeft[127 - i]) * 8.0f;
				if (n <= 0.0f)
					spectrum[i] = 0;
				else if (n >= 255.0f)
					spectrum[i] = 255;
				else
					spectrum[i] = (BYTE)n;
			}

			for (; i < 256; i += 1)
			{
				float n = logf(m_fftRight[i - 128]) * 8.0f;
				if (n <= 0.0f)
					spectrum[i] = 0;
				else if (n >= 255.0f)
					spectrum[i] = 255;
				else
					spectrum[i] = (BYTE)n;
			}


			for (i = 0; i < 256; i += 1)
			{
				if (peak_buf[i] > 2)
					peak_buf[i] -= 2;
				else
					peak_buf[i] = 0;

				int y = spectrum[i] * 2;
				if (peak_buf[i] < y)
					peak_buf[i] = y;
			}

			int nWidth = pSurfx->m_nWidth;
			for (int x = 0; x < nWidth; x += 1)
			{
				float nHeight = ((((float)spectrum[(x * 256) / nWidth])) * (float)pSurfx->m_nHeight) / 256.0f;
				ASSERT((int)nHeight <= pSurfx->m_nHeight);

				BYTE bColor = 255;
				for (int y = pSurfx->m_nHeight - (int)nHeight; y < pSurfx->m_nHeight; y += 1, bColor -= 1)
					*pSurfx->Pixel(x, y) = bColor;

				nHeight = (float)peak_buf[(x * 256) / nWidth];
				nHeight /= 2.0f;
				nHeight = (nHeight * (float)pSurfx->m_nHeight) / 256.0f;
				*pSurfx->Pixel(x, pSurfx->m_nHeight - (int)nHeight) = 255;
			}

			RenderEffect1(pSurfx);
			RenderEffect2(pSurfx);
		}
		break;
	}
}

#define BASS_EXT_MEMORY 10

struct bass_info {
	int max_recent;
	int max_old;
	int time_last_max;
	int min_recent;
	int min_old;
	int time_last_min;
	int activated;
} bass_info;


void CAudioVisualizer::RenderEffect1(CSurfx* pSurfx)
{
	static int t = 0;

	int bass = 0;
	const int step = 5;
	for (int i = 0; i < step; i += 1)
		bass += (m_fftLeft[i] >> 4) + (m_fftRight[i] >> 4);
	bass /= (step * 2);

	if (bass > bass_info.max_recent)
		bass_info.max_recent = bass;

	if (bass < bass_info.min_recent)
		bass_info.min_recent = bass;

	if (t - bass_info.time_last_max > BASS_EXT_MEMORY)
	{
		bass_info.max_old = bass_info.max_recent;
		bass_info.max_recent = 0;
		bass_info.time_last_max = t;
	}

	if (t - bass_info.time_last_min > BASS_EXT_MEMORY)
	{
		bass_info.min_old = bass_info.min_recent;
		bass_info.min_recent = 0;
		bass_info.time_last_min = t;
	}

	if (bass > (bass_info.max_old * 6 + bass_info.min_old * 4) / 10 && bass_info.activated == 0)
	{
//		TRACE(_T("BEAT!\n"));
		FillMemory(pSurfx->m_pels, pSurfx->m_nWidth * pSurfx->m_nHeight, 255);
		bass_info.activated = 1;
	}

	if (bass < (bass_info.max_old * 4 + bass_info.min_old * 6) / 10 && bass_info.activated == 1)
		bass_info.activated = 0;

	t += 1;
}

////////////////////////////////////////////////////////////////////////////


#define PI D3DX_PI

struct sincos {
	int i;
	float *f;
};
static struct sincos cosw = { 0, NULL };
static struct sincos sinw = { 0, NULL };

int spectral_amplitude = 50;
int spectral_shift = 30;
int mode_spectre = -1;
BYTE spectral_color = 128;

void SetPixel(CSurfx* pSurfx, int x, int y, BYTE color)
{
	if (x < 0 || y < 0 || x >= pSurfx->m_nWidth || y >= pSurfx->m_nHeight)
		return;
	*pSurfx->Pixel(x, y) = color;
}

void SetPixel2(CSurfx* pSurfx, int x, int y, BYTE color)
{
	SetPixel(pSurfx, x, y, color);
	SetPixel(pSurfx, x + 1, y, color);
	SetPixel(pSurfx, x + 1, y + 1, color);
	SetPixel(pSurfx, x, y + 1, color);
}

void CAudioVisualizer::RenderEffect2(CSurfx* pSurfx)
{
	int halfheight, halfwidth;
	float old_y1, old_y2;
	float y1 = (float)((((m_pcmLeft[0] + m_pcmRight[0]) >> 9) * spectral_amplitude * pSurfx->m_nHeight) >> 12);
	float y2 = (float)((((m_pcmLeft[0] + m_pcmRight[0]) >> 9) * spectral_amplitude * pSurfx->m_nHeight) >> 12);
	const int density_lines = 5;
	const int step = 4;
	const int shift = (spectral_shift * pSurfx->m_nHeight) >> 8;

	static XTIME timeToChange = 0.0f;
	if (mode_spectre < 0 || XAppGetNow() >= timeToChange)
	{
		mode_spectre += 1;
		timeToChange = XAppGetNow() + 3.0f + rnd(5.0f);
	}

	if ((UINT)mode_spectre > 4)
		mode_spectre = 0;

	if (cosw.i != pSurfx->m_nWidth || sinw.i != pSurfx->m_nWidth)
	{
		delete [] cosw.f;
		delete [] sinw.f;
		sinw.f = cosw.f = NULL;
		sinw.i = cosw.i = 0;
	}

	if (cosw.i == 0 || cosw.f == NULL)
	{
	 	const float halfPI  = (float)PI / 2;
		cosw.i = pSurfx->m_nWidth;
		cosw.f = new float [pSurfx->m_nWidth];
		for (int i = 0; i < pSurfx->m_nWidth; i += step)
			cosw.f[i] = cosf((float)i / pSurfx->m_nWidth * PI + halfPI);
	}

	if (sinw.i == 0 || sinw.f == NULL)
	{
	 	const float halfPI = (float)PI / 2;
		sinw.i = pSurfx->m_nWidth;
		sinw.f = new float [pSurfx->m_nWidth];
		for (int i = 0; i < pSurfx->m_nWidth; i += step)
			sinw.f[i] = sinf((float)i / pSurfx->m_nWidth * PI + halfPI);
	}

	if (mode_spectre == 3)
	{
		if (y1 < 0)
			y1 = 0;
		if (y2 < 0)
			y2 = 0;
	}
	
	halfheight = pSurfx->m_nHeight >> 1;
	halfwidth  = pSurfx->m_nWidth >> 1;

	for (int i = step; i < pSurfx->m_nWidth; i += step)
	{
		old_y1 = y1;
		old_y2 = y2;

		y1 = (float)(((m_pcmRight[(i << 8) / pSurfx->m_nWidth / density_lines] >> 8) * spectral_amplitude * pSurfx->m_nHeight) >> 12);
		y2 = (float)((( m_pcmLeft[(i << 8) / pSurfx->m_nWidth / density_lines] >> 8) * spectral_amplitude * pSurfx->m_nHeight) >> 12);

		switch (mode_spectre)
		{
		case 0:
			pSurfx->Line(i-step,(int)(halfheight+shift+old_y2),
			     i,(int)(halfheight+shift+y2),
			     spectral_color);
			break;

		case 1:
			pSurfx->Line(i-step,(int)(halfheight+shift+old_y1),
			     i,(int)(halfheight+shift+y1),
			     spectral_color);
			pSurfx->Line(i-step,(int)(halfheight-shift+old_y2),
			     i,(int)(halfheight-shift+y2),
			     spectral_color);
			break;

		case 2:
			pSurfx->Line(i-step,(int)(halfheight+shift+old_y1),
			     i,(int)(halfheight+shift+y1),
			     spectral_color);
			pSurfx->Line(i-step,(int)(halfheight-shift+old_y1),
			     i,(int)(halfheight-shift+y1),
			     spectral_color);
			pSurfx->Line((int)(halfwidth+shift+old_y2),i-step,
			     (int)(halfwidth+shift+y2),i,
			     spectral_color);
			pSurfx->Line((int)(halfwidth-shift+old_y2),i-step,
			     (int)(halfwidth-shift+y2),i,
			     spectral_color);	
			break;

		case 3:
			if (y1<0)
				y1=0;
			if (y2<0)
				y2=0;
			// FALL THROUGH

		case 4:
			pSurfx->Line(
				(int)(halfwidth  + cosw.f[i - step] * (shift + old_y1)),
				(int)(halfheight + sinw.f[i - step] * (shift + old_y1)),
				(int)(halfwidth  + cosw.f[i]        * (shift + y1)),
				(int)(halfheight + sinw.f[i]        * (shift + y1)),
				spectral_color);
			pSurfx->Line(
				(int)(halfwidth  - cosw.f[i - step] * (shift + old_y2)),
				(int)(halfheight + sinw.f[i - step] * (shift + old_y2)),
				(int)(halfwidth  - cosw.f[i]        * (shift + y2)),
				(int)(halfheight + sinw.f[i]        * (shift + y2)),
				spectral_color);			
			break;
		}
	}

	if (mode_spectre == 3 || mode_spectre == 4)
	{
		pSurfx->Line(
			(int)(halfwidth  + cosw.f[pSurfx->m_nWidth - step] * (shift+y1)),
			(int)(halfheight + sinw.f[pSurfx->m_nWidth - step] * (shift+y1)),
			(int)(halfwidth  - cosw.f[pSurfx->m_nWidth - step] * (shift+y2)),
			(int)(halfheight + sinw.f[pSurfx->m_nWidth - step] * (shift+y2)),
			spectral_color);
	}

#define curve_color 255
#define curve_amplitude 50
static int x_curve = 0;

	// BLOCK: Curve...
	{
		int i, j, k;
		float v, vr;
		float x, y;
		float amplitude = (float)curve_amplitude / 256;

		for (j = 0; j < 2; j += 1)
		{
			v = 80;
			vr = 0.001f;
			k = x_curve;
			for (i = 0; i < 64; i += 1)
			{
				x = cosf((float)(k) / (v + v * j * 1.34f)) * pSurfx->m_nHeight * amplitude;
				y = sinf((float)(k) / (1.756f * (v + v * j * 0.93f))) * pSurfx->m_nHeight * amplitude;
				SetPixel2(pSurfx, (int)(x * cosf((float)k * vr) + y * sinf((float)k * vr) + pSurfx->m_nWidth / 2), (int)(x * sinf((float)k * vr) - y * cosf((float)k * vr) + pSurfx->m_nHeight / 2), curve_color);
				k++;
			}
		}

		x_curve = k;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Camera.h ===
class CCamera : public CNode
{
	DECLARE_NODE(CCamera, CNode)
public:
	CCamera();
	~CCamera();

	char* m_mode;
	CNode* m_lookat;

	bool m_bNoisy;

	DECLARE_NODE_PROPS()


	void Reset();

	void Set(const D3DXVECTOR3* pPosition, const D3DXQUATERNION* pOrientation, float nSeconds = 0.0f);

//	void Move(const D3DXVECTOR3* delta);
//	void Rotate(float dx, float dy, const D3DXVECTOR3* center = NULL);
//	void Transform(const D3DXMATRIX* pM);

	void UpdateViewMatrix();

	void Advance(float nSeconds);
	void AdvanceChase(float nSeconds, const D3DXVECTOR3& chasePosition, float yaw);
	void AdvanceWatch(float nSeconds, const D3DXVECTOR3& watchPosition);

	D3DXVECTOR3 m_position;
	D3DXQUATERNION m_orientation;

	D3DXVECTOR3 m_oldPosition;
	D3DXQUATERNION m_oldOrientation;

	D3DXVECTOR3 m_newPosition;
	D3DXQUATERNION m_newOrientation;

	XTIME m_nStartTime;
	float m_nDeltaTime;

	D3DXVECTOR3 m_actualPosition;
};

class CCameraPath : public CNode
{
	DECLARE_NODE(CCameraPath, CNode)
public:
	CCameraPath();
	~CCameraPath();

	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	float m_interval;
	bool m_isActive;
	bool m_backward;
	CNode* m_position;
	CNode* m_orientation;

	void Activate(bool bBackwards);

protected:
	XTIME m_startTime;

	DECLARE_NODE_PROPS()
};

extern CCamera theCamera;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\cdplayer.h ===
#pragma once

#ifdef _WINDOWS
#include "ddk\devioctl.h"
#include "ddk\ntddcdrm.h"

#include <dbt.h>
#endif

#define _D3DTYPES_H_
#include <dsound.h>

#include "xcdplay.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\cdda.h ===
#pragma once
#include "ntiosvc.h"

#define CDDA_MAX_FRAMES_PER_READ 16
#define CDDA_BUFFER_SIZE (CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME)

class CCDDAStreamer
{
public:
	CCDDAStreamer(CNtIoctlCdromService* pDrive, DWORD dwRetries = 0);
	~CCDDAStreamer();

	int Read(void* pvBuffer, int nBytes);
	
	inline DWORD GetFrame() const
	{
		return m_dwCurFrame;
	}
	
	inline void SetFrame(DWORD dwFrame)
	{
		TRACE(_T("Reseting CDDAStreamer frame to %d\n"), dwFrame);
		m_dwCurFrame = dwFrame;
		m_ibChunk = 0;
	}

protected:
	int ReadFrames(void* pvBuffer, DWORD nFrameCount);

	BYTE *m_chunk;
	int m_ibChunk;

	CNtIoctlCdromService* m_pDrive;
    DWORD m_dwRetries;
	DWORD m_dwCurFrame;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\config.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"

#include "xlaunch.h"
#include "cryptkeys.h"
#include "av.h"
#include "timezone.h"
#include "locale.h"

//
// Cached "AV info" in Direct3D. This cache needs to be clear before wide screen mode
// could be turn on/off dynamically.
//

extern "C" { extern DWORD D3D__AvInfo; }

class CConfig : public CNode
{
	DECLARE_NODE(CConfig, CNode)
public:
	CConfig();
	~CConfig();

	int GetLanguage();
	void SetLanguage(int nLanguage);

	int GetGamePCFlags();
	void SetGamePCFlags(int nLanguage);

	int GetMoviePCFlags();
	void SetMoviePCFlags(int nLanguage);

	CStrObject* GetLaunchReason();
    DWORD GetTitleID();

    int GetLaunchContext();
	int GetLaunchParameter1();
	int GetLaunchParameter2();
    int CanDriveBeCleanup(int Drive);
    void BackToLauncher();
    void BackToLauncher2();

	CStrObject* GetAVPackType();
	CStrObject* GetAVRegion();
	CStrObject* GetGameRegion();

//	int GetWidescreen();
//	void SetWidescreen(int bWidescreen);

	// 0=fullscreen, 1=letterbox, 2=widescreen
	int GetVideoMode();
	void SetVideoMode(int nVideoMode);

	int Get480Support();
	void Set480Support(int b480Support);

	int Get720Support();
	void Set720Support(int b720Support);

	int Get1080Support();
	void Set1080Support(int b1080Support);

	int GetPAL60Support();
	void SetPAL60Support(int bPAL60Support);

	// 0=mono, 1=stereo, 2=Dolby Surround
	int GetAudioMode();
	void SetAudioMode(int nVideoMode);

	int GetDolbyDigitalSupport();
	void SetDolbyDigitalSupport(int bDolbyDigitalSupport);

	int GetDTSSupport();
	void SetDTSSupport(int bDTSSupport);

	int GetAutoOff();
	void SetAutoOff(int bAutoOff);

	void SetParentPassword(const TCHAR* szNewPassword);
	int CheckParentPassword(const TCHAR* szCheckPassword);

	int GetTimeZone();
	void SetTimeZone(int nTimeZone);

	int GetDSTAllowed();
	int GetDST();
	void SetDST(int bObserveDST);

    int ForceSetLanguage() { return CheckForcedSettings(XLD_SETTINGS_LANGUAGE); }
    int ForceSetTimeZone() { return CheckForcedSettings(XLD_SETTINGS_TIMEZONE); }
    int ForceSetClock() { return CheckForcedSettings(XLD_SETTINGS_CLOCK); }

    CStrObject* GetRecoveryKey();
	CStrObject* GetROMVersion();
    CStrObject* GetXdashVersion();

protected:
	DECLARE_NODE_FUNCTIONS()

private:
    int CheckForcedSettings(int flag) {
        return ((theApp.m_dwLaunchReason == XLD_LAUNCH_DASHBOARD_SETTINGS) &&
                (theApp.m_dwLaunchParameter1 & flag)) ? 1 : 0;
    }
};

IMPLEMENT_NODE("Config", CConfig, CNode)

START_NODE_FUN(CConfig, CNode)
	NODE_FUN_IV(GetLanguage)
	NODE_FUN_VI(SetLanguage)
	NODE_FUN_IV(GetGamePCFlags)
	NODE_FUN_VI(SetGamePCFlags)
	NODE_FUN_IV(GetMoviePCFlags)
	NODE_FUN_VI(SetMoviePCFlags)
	NODE_FUN_SV(GetLaunchReason)
    NODE_FUN_IV(GetLaunchContext)
	NODE_FUN_IV(GetLaunchParameter1)
	NODE_FUN_IV(GetLaunchParameter2)
    NODE_FUN_II(CanDriveBeCleanup)
    NODE_FUN_VV(BackToLauncher)
    NODE_FUN_VV(BackToLauncher2)
//	NODE_FUN_IV(GetWidescreen)
//	NODE_FUN_VI(SetWidescreen)
	NODE_FUN_IV(Get480Support)
	NODE_FUN_VI(Set480Support)
	NODE_FUN_IV(Get720Support)
	NODE_FUN_VI(Set720Support)
	NODE_FUN_IV(Get1080Support)
	NODE_FUN_VI(Set1080Support)
	NODE_FUN_IV(GetPAL60Support)
	NODE_FUN_VI(SetPAL60Support)
	NODE_FUN_SV(GetAVPackType)
	NODE_FUN_SV(GetAVRegion)
	NODE_FUN_SV(GetGameRegion)
	NODE_FUN_IV(GetAutoOff)
	NODE_FUN_VI(SetAutoOff)
	NODE_FUN_IV(GetVideoMode)
	NODE_FUN_VI(SetVideoMode)
	NODE_FUN_IV(GetAudioMode)
	NODE_FUN_VI(SetAudioMode)
	NODE_FUN_IV(GetDolbyDigitalSupport)
	NODE_FUN_VI(SetDolbyDigitalSupport)
	NODE_FUN_IV(GetDTSSupport)
	NODE_FUN_VI(SetDTSSupport)
	NODE_FUN_IS(CheckParentPassword)
	NODE_FUN_VS(SetParentPassword)
	NODE_FUN_IV(GetTimeZone)
	NODE_FUN_VI(SetTimeZone)
	NODE_FUN_IV(GetDSTAllowed)
	NODE_FUN_IV(GetDST)
	NODE_FUN_VI(SetDST)
	NODE_FUN_IV(ForceSetLanguage)
	NODE_FUN_IV(ForceSetTimeZone)
	NODE_FUN_IV(ForceSetClock)
    NODE_FUN_SV(GetRecoveryKey)
    NODE_FUN_SV(GetROMVersion)
    NODE_FUN_SV(GetXdashVersion)
END_NODE_FUN()

CConfig::CConfig()
{
}

CConfig::~CConfig()
{
}

int CConfig::GetLanguage()
{
	DWORD nLanguage, dwType;
	VERIFY(!XQueryValue(XC_LANGUAGE, &dwType, &nLanguage, 4, NULL));

    if (nLanguage == 0 || nLanguage > 6)
    {
        TRACE(_T("\001Invalid language, default to English\n"));
        nLanguage = 1;
    }

	return (int)nLanguage;
}

void CConfig::SetLanguage(int nLanguage)
{
	VERIFY(!XSetValue(XC_LANGUAGE, REG_DWORD, (DWORD*)&nLanguage, 4));
}

CStrObject* CConfig::GetAVPackType()
{
	DWORD dwAVPack = XGetAVPack();

	const TCHAR* szType = NULL;
	switch (dwAVPack)
	{
	case XC_AV_PACK_STANDARD:
		szType = _T("STANDARD");
		break;

	case XC_AV_PACK_SVIDEO:
		szType = _T("SVIDEO");
		break;

	case XC_AV_PACK_RFU:
		szType = _T("RFU");
		break;

	case XC_AV_PACK_SCART:
		szType = _T("SCART");
		break;

	case XC_AV_PACK_HDTV:
		szType = _T("HDTV");
		break;

	case XC_AV_PACK_VGA:
		szType = _T("VGA");
		break;
	}

	return new CStrObject(szType);
}

CStrObject* CConfig::GetAVRegion()
{
	DWORD dwVideoStd = XGetVideoStandard();

	const TCHAR* szRegion = NULL;
	switch (dwVideoStd)
	{
	case XC_VIDEO_STANDARD_NTSC_M:
		szRegion = _T("NTSC_M");
		break;

	case XC_VIDEO_STANDARD_NTSC_J:
		szRegion = _T("NTSC_J");
		break;

	case XC_VIDEO_STANDARD_PAL_I:
		szRegion = _T("PAL_I");
		break;

	case XC_VIDEO_STANDARD_PAL_M:
		szRegion = _T("PAL_M");
		break;
	}

	return new CStrObject(szRegion);
}

CStrObject* CConfig::GetGameRegion()
{
	const TCHAR* szRegion = NULL;

	switch (g_nCurRegion)
	{
	case XC_GAME_REGION_NA:
		szRegion = _T("NA");
		break;

	case XC_GAME_REGION_JAPAN:
		szRegion = _T("JAPAN");
		break;

	case XC_GAME_REGION_RESTOFWORLD:
		szRegion = _T("RESTOFWORLD");
		break;
	}

	return new CStrObject(szRegion);
}

/*
int CConfig::GetWidescreen()
{
#ifdef _XBOX
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (dwFlags & AV_FLAGS_WIDESCREEN) != 0;
#else
	return GetPrivateProfileInt(_T("Config"), _T("WIDESCREEN"), 0, _T("xdash.ini"));
#endif
}

void CConfig::SetWidescreen(int bWidescreen)
{
#ifdef _XBOX
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (bWidescreen)
		dwFlags |= AV_FLAGS_WIDESCREEN;
	else
		dwFlags &= ~AV_FLAGS_WIDESCREEN;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
#else
	WritePrivateProfileString(_T("Config"), _T("WIDESCREEN"), bWidescreen ? _T("1") : _T("0"), _T("xdash.ini"));
#endif

	theApp.m_bStretchWidescreen = bWidescreen ? true : false;
	theApp.m_bProjectionDirty = true;
}
*/

int CConfig::GetVideoMode()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if ((dwFlags & AV_FLAGS_LETTERBOX) != 0)
		return 1;

	if ((dwFlags & AV_FLAGS_WIDESCREEN) != 0)
		return 2;

	return 0;
}

void CConfig::SetVideoMode(int nVideoMode)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	dwFlags &= ~(AV_FLAGS_WIDESCREEN | AV_FLAGS_LETTERBOX);
	if (nVideoMode == 1)
		dwFlags |= AV_FLAGS_LETTERBOX;
	else if (nVideoMode == 2)
		dwFlags |= AV_FLAGS_WIDESCREEN;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));

    bool bWideScreen = nVideoMode == 2;

    if (theApp.m_bStretchWidescreen != bWideScreen)
    {
        if (bWideScreen)
        {
            theApp.m_pp.Flags |= D3DPRESENTFLAG_WIDESCREEN;
        }
        else
        {
            theApp.m_pp.Flags &= ~D3DPRESENTFLAG_WIDESCREEN;
        }

        theApp.m_bStretchWidescreen = bWideScreen;

        D3D__AvInfo = 0; // flush cached "AV info" in D3D
        XAppGetD3DDev()->Reset(&theApp.m_pp);
    }

	theApp.m_bProjectionDirty = true;
}

int CConfig::Get480Support()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (dwFlags & AV_FLAGS_HDTV_480p) != 0;
}

void CConfig::Set480Support(int b480Support)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (b480Support)
		dwFlags |= AV_FLAGS_HDTV_480p;
	else
		dwFlags &= ~AV_FLAGS_HDTV_480p;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));

#ifdef COOL_XDASH
    if (g_nDiscType == DISC_VIDEO && XGetAVPack() == XC_AV_PACK_HDTV)
#else
    if (g_nDiscType == DISC_VIDEO && XGetAVPack() == XC_AV_PACK_HDTV && (XBOX_480P_MACROVISION_ENABLED & XboxHardwareInfo->Flags))
#endif
    {
        bool bUpdate = false;

        if ((theApp.m_pp.Flags & D3DPRESENTFLAG_PROGRESSIVE) && !b480Support)
        {
            theApp.m_pp.Flags &= ~D3DPRESENTFLAG_PROGRESSIVE;
            theApp.m_pp.Flags |= D3DPRESENTFLAG_INTERLACED;
            bUpdate = true;
        }
        else if ((theApp.m_pp.Flags & D3DPRESENTFLAG_PROGRESSIVE) == 0 && b480Support)
        {
            theApp.m_pp.Flags |= D3DPRESENTFLAG_PROGRESSIVE;
            theApp.m_pp.Flags &= ~D3DPRESENTFLAG_INTERLACED;
            bUpdate = true;
        }

        if (bUpdate)
        {
            D3D__AvInfo = 0; // flush cached "AV info" in D3D
            XAppGetD3DDev()->Reset(&theApp.m_pp);
        }
    }
}

int CConfig::Get720Support()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (dwFlags & AV_FLAGS_HDTV_720p) != 0;
}

void CConfig::Set720Support(int b720Support)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (b720Support)
		dwFlags |= AV_FLAGS_HDTV_720p;
	else
		dwFlags &= ~AV_FLAGS_HDTV_720p;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::Get1080Support()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (dwFlags & AV_FLAGS_HDTV_1080i) != 0;
}

void CConfig::Set1080Support(int b1080Support)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (b1080Support)
		dwFlags |= AV_FLAGS_HDTV_1080i;
	else
		dwFlags &= ~AV_FLAGS_HDTV_1080i;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::GetPAL60Support()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (dwFlags & AV_FLAGS_60Hz) != 0;
}

void CConfig::SetPAL60Support(int bPAL60Support)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (bPAL60Support)
		dwFlags |= AV_FLAGS_60Hz;
	else
		dwFlags &= ~AV_FLAGS_60Hz;

	VERIFY(!XSetValue(XC_VIDEO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::GetAudioMode()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

    switch(DSSPEAKER_BASIC(dwFlags))
    {
        case DSSPEAKER_MONO:
            return 0;

        case DSSPEAKER_STEREO:
            return 1;

        default:
            return 2;
    }
}

void CConfig::SetAudioMode(int nAudioMode)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

    switch(nAudioMode)
    {
        case 0:
            dwFlags = DSSPEAKER_COMBINED(DSSPEAKER_MONO, dwFlags);
            break;

        case 1:
            dwFlags = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, dwFlags);
            break;

        case 2:
            dwFlags = DSSPEAKER_COMBINED(DSSPEAKER_SURROUND, dwFlags);
            break;
    }

	VERIFY(!XSetValue(XC_AUDIO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::GetDolbyDigitalSupport()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

	return (dwFlags & DSSPEAKER_ENABLE_AC3) != 0;
}

void CConfig::SetDolbyDigitalSupport(int bDolbyDigitalSupport)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (bDolbyDigitalSupport)
		dwFlags |= DSSPEAKER_ENABLE_AC3;
	else
		dwFlags &= ~DSSPEAKER_ENABLE_AC3;

	VERIFY(!XSetValue(XC_AUDIO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::GetDTSSupport()
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

	return (dwFlags & DSSPEAKER_ENABLE_DTS) != 0;
}

void CConfig::SetDTSSupport(int bDTSSupport)
{
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));

	if (bDTSSupport)
		dwFlags |= DSSPEAKER_ENABLE_DTS;
	else
		dwFlags &= ~DSSPEAKER_ENABLE_DTS;

	VERIFY(!XSetValue(XC_AUDIO_FLAGS, REG_DWORD, (DWORD*)&dwFlags, 4));
}

int CConfig::GetAutoOff()
{
	BOOL bAutoOff;
	XAutoPowerDownGet(&bAutoOff);
	return bAutoOff;
}

void CConfig::SetAutoOff(int bAutoOff)
{
	XAutoPowerDownSet(bAutoOff);
}

extern int GetTimeZoneIndex(const TIME_ZONE_INFORMATION* tzinfo);
extern bool GetTimeZoneInfo(int index, TIME_ZONE_INFORMATION* tzinfo);

int CConfig::GetTimeZone()
{
    TIME_ZONE_INFORMATION tzinfo;
    if ((XapipQueryTimeZoneInformation(&tzinfo, NULL) != ERROR_SUCCESS) ||
        (L'\0' == tzinfo.StandardName[0]))
    {
        //
        // No valid timezone info - return a reasonable default based on the
        // game region
        //

        switch (XGetGameRegion())
        {
            case XC_GAME_REGION_NA:
                //
                // Eastern
                //
                return NA_DEFAULT_TIMEZONE;

            case XC_GAME_REGION_JAPAN:
                //
                // Tokyo
                //
                return JAPAN_DEFAULT_TIMEZONE;

            default:
                //
                // London
                //
                return ROW_DEFAULT_TIMEZONE;
        }
    }

    int index = GetTimeZoneIndex(&tzinfo);
    return (index < 0) ? 0 : index;
}

void CConfig::SetTimeZone(int nTimeZone)
{
    TIME_ZONE_INFORMATION tzinfo;

    if (GetTimeZoneInfo(nTimeZone, &tzinfo)) {
        XapipSetTimeZoneInformation(&tzinfo);
    }
}

int CConfig::GetDSTAllowed()
{
    TIME_ZONE_INFORMATION tzinfo;

    if (XapipQueryTimeZoneInformation(&tzinfo, NULL) != ERROR_SUCCESS)
        return 0;

    //
    // If the wMonth fields are non-zero, that means that this timezone
    // has cutover date info which implies daylight savings time support
    //

    return (tzinfo.StandardDate.wMonth && tzinfo.DaylightDate.wMonth);
}

int CConfig::GetDST()
{
    TIME_ZONE_INFORMATION tzinfo;
    BOOL fUseDST;

    if (XapipQueryTimeZoneInformation(&tzinfo, &fUseDST) != ERROR_SUCCESS)
        return 0;

    //
    // If the wMonth fields are non-zero, that means that this timezone
    // has cutover date info which implies daylight savings time support
    //

    return (tzinfo.StandardDate.wMonth && tzinfo.DaylightDate.wMonth && fUseDST);
}

void CConfig::SetDST(int bObserveDST)
{
    ULONG type, size;
    DWORD flags;

#if DBG
    if (bObserveDST)
    {
        ASSERT(GetDSTAllowed());
    }
#endif // DBG

    if (XQueryValue(XC_MISC_FLAGS, &type, &flags, sizeof(flags), &size) == ERROR_SUCCESS) {
        if (bObserveDST)
            flags &= ~XC_MISC_FLAG_DONT_USE_DST;
        else
            flags |= XC_MISC_FLAG_DONT_USE_DST;

        XSetValue(XC_MISC_FLAGS, REG_DWORD, &flags, sizeof(flags));
    }
}

/*
int CConfig::GetAudioFlags()
{
#ifdef _XBOX
	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_AUDIO_FLAGS, &dwType, &dwFlags, 4, NULL));
	return (int)dwFlags;
#else
	return 0;
#endif
}

void CConfig::SetAudioFlags(int nFlags)
{
#ifdef _XBOX
	VERIFY(!XSetValue(XC_AUDIO_FLAGS, REG_DWORD, (DWORD*)&nFlags, 4));
#else
#endif
}
*/

static DWORD EncodePassword(const TCHAR* szPassword)
{
	DWORD dwPassword = 0;
	for (const TCHAR* pch = szPassword; *pch != 0; pch += 1)
	{
		dwPassword <<= 4;

		switch (*pch)
		{
		case 'u': // up
			dwPassword += 1;
			break;

		case 'd': // down
			dwPassword += 2;
			break;

		case 'l': // left
			dwPassword += 3;
			break;

		case 'r': // right
			dwPassword += 4;
			break;

		case 'a': // A
			dwPassword += 5;
			break;

		case 'b': // B
			dwPassword += 6;
			break;

		case 'x': // X
			dwPassword += 7;
			break;

		case 'y': // Y
			dwPassword += 8;
			break;

		case 'B': // black
			dwPassword += 9;
			break;

		case 'W': // white
			dwPassword += 10;
			break;

		case 'L': // L trigger
			dwPassword += 11;
			break;

		case 'R': // R trigger
			dwPassword += 12;
			break;

        default:
            ASSERT(FALSE);
		}
	}

	return dwPassword;
}

int CConfig::CheckParentPassword(const TCHAR* szCheckPassword)
{
	DWORD dwCheckPassword = EncodePassword(szCheckPassword);

	DWORD dwFlags, dwType;
	VERIFY(!XQueryValue(XC_PARENTAL_CONTROL_PASSWORD, &dwType, &dwFlags, 4, NULL));
	return dwFlags == dwCheckPassword;
}

void CConfig::SetParentPassword(const TCHAR* szNewPassword)
{
	DWORD dwPassword = EncodePassword(szNewPassword);
	VERIFY(!XSetValue(XC_PARENTAL_CONTROL_PASSWORD, REG_DWORD, &dwPassword, 4));
}

int CConfig::GetGamePCFlags()
{
	DWORD dwFlags=0, dwType;
	VERIFY(!XQueryValue(XC_PARENTAL_CONTROL_GAMES, &dwType, &dwFlags, 4, NULL));
    ASSERT(dwFlags <= 6);
	return (int)(6-dwFlags); // revert it since we store level backward in EEPROM
}

void CConfig::SetGamePCFlags(int nFlags)
{
    ASSERT(nFlags <= 6);
    nFlags = 6 - nFlags; // revert it since we store level backward in EEPROM
	VERIFY(!XSetValue(XC_PARENTAL_CONTROL_GAMES, REG_DWORD, (DWORD*)&nFlags, 4));
}

int CConfig::GetMoviePCFlags()
{
	DWORD dwFlags=0, dwType;
	VERIFY(!XQueryValue(XC_PARENTAL_CONTROL_MOVIES, &dwType, &dwFlags, 4, NULL));
    ASSERT(dwFlags <= 7);
	return (int)(7-dwFlags); // revert it since we store level backward in EEPROM
}

void CConfig::SetMoviePCFlags(int nFlags)
{
    ASSERT(nFlags <= 7);
    nFlags = 7 - nFlags; // revert it since we store level backward in EEPROM
	VERIFY(!XSetValue(XC_PARENTAL_CONTROL_MOVIES, REG_DWORD, (DWORD*)&nFlags, 4));
}

CStrObject* CConfig::GetLaunchReason()
{
	const TCHAR* sz = NULL;

	if (theApp.m_bHasLaunchData)
	{
		switch (theApp.m_dwLaunchReason)
		{
		case XLD_LAUNCH_DASHBOARD_ERROR:
			sz = _T("Error");
			break;

		case XLD_LAUNCH_DASHBOARD_MEMORY:
			sz = _T("Memory");
			break;

		case XLD_LAUNCH_DASHBOARD_SETTINGS:
			sz = _T("Settings");
			break;

		case XLD_LAUNCH_DASHBOARD_MUSIC:
			sz = _T("Music");
			break;
		}
	}

	return new CStrObject(sz);
}

int CConfig::GetLaunchContext()
{
    return theApp.m_bHasLaunchData ? theApp.m_dwLaunchContext : 0;
}

int CConfig::GetLaunchParameter1()
{
    return theApp.m_bHasLaunchData ? theApp.m_dwLaunchParameter1 : 0;
}

int CConfig::GetLaunchParameter2()
{
    return theApp.m_bHasLaunchData ? theApp.m_dwLaunchParameter2 : 0;
}

int CConfig::CanDriveBeCleanup(int Drive)
{
    switch (toupper(Drive))
    {
    case 'T':
    case 'U':
    case 'F':
    case 'G':
    case 'H':
    case 'I':
    case 'J':
    case 'K':
    case 'L':
    case 'M':
        return true;

    default:
        return false;
    }
}

DWORD CConfig::GetTitleID()
{
    return theApp.m_bHasLaunchData ? theApp.m_dwTitleID : 0;
}

void CConfig::BackToLauncher()
{
    XAppGetD3DDev()->PersistDisplay();

    if (CheckForcedSettings(XLD_SETTINGS_CLOCK|XLD_SETTINGS_TIMEZONE|XLD_SETTINGS_LANGUAGE)) {
        // Dashboard was launched by the kernel to update invalid settings
        HalReturnToFirmware(HalRebootRoutine);
    } else {
        LD_FROM_DASHBOARD fd;
        ZeroMemory(&fd, sizeof(fd));
        fd.dwContext = GetLaunchContext();
        XWriteTitleInfoAndReboot("default.xbe", "\\Device\\CdRom0", LDT_FROM_DASHBOARD, GetTitleID(), (PLAUNCH_DATA)&fd);
    }
}

void CConfig::BackToLauncher2()
{
    XAppGetD3DDev()->PersistDisplay();

    LD_FROM_DASHBOARD fd;
    ZeroMemory(&fd, sizeof(fd));
    fd.dwContext = 'CODA';
    XWriteTitleInfoAndReboot("settings_adoc.xip", "\\Device\\Harddisk0\\Partition2", LDT_FROM_DASHBOARD, 0xfffe0000, (PLAUNCH_DATA)&fd);
}

CStrObject* CConfig::GetRecoveryKey()
{
    CHAR RecoveryKey[RECOVERY_KEY_LEN];
    ComputeRecoveryKey((LPBYTE)XboxHDKey, RecoveryKey);
#ifdef _UNICODE
    TCHAR RecKey[RECOVERY_KEY_LEN];
    Unicode(RecKey, RecoveryKey, RECOVERY_KEY_LEN);
	return new CStrObject(RecKey);
#else  // _UNICODE
	return new CStrObject(RecoveryKey);
#endif // _UNICODE
}

CStrObject* CConfig::GetROMVersion()
{
    TCHAR RomVersion[64];
    _sntprintf(RomVersion, countof(RomVersion), _T("%d.%02d.%d.%02d"),
               XboxKrnlVersion->Major, XboxKrnlVersion->Minor,
               XboxKrnlVersion->Build, (XboxKrnlVersion->Qfe & 0x7FFF));
    return new CStrObject(RomVersion);
}

CStrObject* CConfig::GetXdashVersion()
{
    TCHAR XdashVersion[64];
    const USHORT XdashVerInfo[4] = { VER_PRODUCTVERSION };
    _sntprintf(XdashVersion, countof(XdashVersion), _T("%d.%02d.%d.%02d"),
               XdashVerInfo[0], XdashVerInfo[1], XdashVerInfo[2], XdashVerInfo[3]);
    return new CStrObject(XdashVersion);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Compiler.cpp ===
#include "std.h"
#include "xapp.h"
#include "Parser.h"
#include "Node.h"
#include "Runner.h"

#include "DefUse.h"

//#define LOCALTRACE TRACE
#define LOCALTRACE 1 ? (void)0 : ::Trace


////////////////////////////////////////////////////////////////////////////

CCompiler::CCompiler()
{
	m_nop = 0;
	m_opsSize = 0;
	m_ops = NULL;
	m_bError = false;
}

CCompiler::~CCompiler()
{
	delete [] m_ops;
}

void CCompiler::GrowTo(int nNewSize)
{
	int cb = ((nNewSize + 4095) & ~0xfff);
	BYTE* ops = new BYTE [cb];
	CopyMemory(ops, m_ops, m_nop);
	delete [] m_ops;
	m_ops = ops;
	m_opsSize = cb;
}

extern int g_nLine;
extern const TCHAR* g_szFileName;
extern bool g_bParseError;

void CCompiler::SyntaxError(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof (szBuffer), szMsg, args);

	TCHAR szMessage [1024];
	_stprintf(szMessage, _T("Syntax Error\n\nFile: %s\nLine: %d\n\n%s"), g_szFileName, g_nLine, szBuffer);

#ifdef _WINDOWS
	if (!m_bError)
		XAppMessageBox(szMessage); // Only one message box!
	
	Trace(_T("\001%s\n"), szMessage);
#else
	Trace(_T("\007%s\n"), szMessage);
#endif

	va_end(args);

	m_bError = true;
	g_bParseError = true;
}

CFunction* CCompiler::CreateFunction()
{
#pragma push_macro("new")
#undef new
	CFunction* pFunction = new(m_nop) CFunction;
#pragma pop_macro("new")
	pFunction->m_cbop = m_nop;
	CopyMemory(pFunction->m_rgop, m_ops, m_nop);

	return pFunction;
}


CFunctionCompiler::CFunctionCompiler()
{
	m_nFrameSize = 0;
	m_pBreak = NULL;
	m_nBreakables = 0;
	m_nopTopOfLoop = 0;
	m_bBehavior = false;
}



////////////////////////////////////////////////////////////////////////////


const TCHAR* CFunctionCompiler::ParseTerm(const TCHAR* pch)
{
	bool bNeg = false;
	bool bInvert = false;

	for (;;)
	{
		pch = SkipWhite(pch);

		if (*pch == '-')
			bNeg = !bNeg;
		else if (*pch == '+')
			; // just skip it
		else if (*pch == '~')
			bInvert = !bInvert;
		else
			break;

		pch += 1;
	}

//	// TODO: Deal with unary operators here...
//	if (*pch == '-' || *pch == '+' || *pch == '~')
//		SyntaxError("Can't handle unary operators yet!");

	if (bInvert)
		SyntaxError(_T("Sorry, the ~ operator has not been implemented yet!"));

	if (*pch == '(')
	{
		pch += 1;
		pch = ParseExpression(pch);
		pch = SkipWhite(pch);
		if (*pch != ')')
		{
			SyntaxError(_T("Missing ')'"));
			return pch;
		}

		pch += 1;
	}
	else
	{
		bool bQuoted = *pch == '"' || *pch == '\'';
		const TCHAR* pchToken;
		int cchToken;
		pch = Token(pch, pchToken, cchToken);

		if (cchToken == 0 && !bQuoted)
			return pch;

		if (bQuoted)
		{
			// string...
//			LOCALTRACE(_T("%d: opStr: %d \n"), m_nop, cchToken);

			Write(opStr);

			TCHAR rgchString [1024];
			int nStringLen = ExpandCString(rgchString, countof(rgchString), pchToken, cchToken);
			if (nStringLen < 0)
				return _T("");
			WriteString(rgchString, nStringLen);
		}
		else if (*pchToken == '.' || *pchToken == '-' || *pchToken >= '0' && *pchToken <= '9')
		{
			// number...
			TCHAR szBuf [256]; // copy the token because _tcstod stupidly copies the while string
			ASSERT(cchToken < countof(szBuf));
			CopyChars(szBuf, pchToken, cchToken);
			szBuf[cchToken] = 0;
			float n = (float)_tcstod(szBuf, NULL);
			if (bNeg)
			{
				bNeg = false;
				n = -n;
			}

//			LOCALTRACE(_T("%d: opNum: %f\n"), m_nop, n);
			Write(opNum);
			WriteNumber(n);
		}
		else if (cchToken == 4 && _tcsncmp(pchToken, _T("true"), 4) == 0)
		{
//			LOCALTRACE(_T("%d: opNum: 1.0\n"), m_nop);
			Write(opNum);
			WriteNumber(1.0f);
		}
		else if (cchToken == 5 && _tcsncmp(pchToken, _T("false"), 5) == 0)
		{
//			LOCALTRACE(_T("%d: opNum: 0.0\n"), m_nop);
			Write(opNum);
			WriteNumber(0.0f);
		}
		else if (cchToken == 4 && _tcsncmp(pchToken, _T("this"), 4) == 0)
		{
//			LOCALTRACE(_T("%d: opThis:\n"), m_nop);
			Write(opThis);
		}
		else if (cchToken == 4 && _tcsncmp(pchToken, _T("null"), 4) == 0)
		{
//			LOCALTRACE(_T("%d: opNull:\n"), m_nop);
			Write(opNull);
		}
		else if (cchToken == 3 && _tcsncmp(pchToken, _T("new"), 3) == 0)
		{
			pch = Token(pch, pchToken, cchToken);
			
#ifdef _DEBUG0
			{
				TCHAR chSav = pchToken[cchToken];
				((TCHAR*)pchToken)[cchToken] = '\0';
				LOCALTRACE(_T("new: %s\n"), pchToken);
				((TCHAR*)pchToken)[cchToken] = chSav;
			}
#endif

			int nParam = 0;

			pch = SkipWhite(pch);
			if (*pch == '(')
			{
				pch += 1;

				if (*pch == ')')
				{
					pch += 1;
				}
				else
				{
					for (;;)
					{
						pch = ParseExpression(pch);
						nParam += 1;

						pch = SkipWhite(pch);
						if (*pch == ')')
						{
							pch += 1;
							break;
						}

						if (*pch != ',')
						{
							SyntaxError(_T("Missing ','"));
							return pch;
						}

						pch += 1;
					}
				}
			}

//			LOCALTRACE(_T("%d: opNew:\n"), m_nop);
			Write(opNew);
			WriteInteger(nParam);
			WriteString(pchToken, cchToken);
		}
		else
		{
			// symbol...

			// Frame variables...

			// REVIEW: Should only so this if the last operator was not a dot!
			for (int i = 0; i < m_nFrameSize; i += 1)
			{
				if (cchToken == m_rgstLocal[i].cchName && _tcsncmp(pchToken, m_rgstLocal[i].pchName, cchToken) == 0)
				{
					// found a frame variable reference!
					Write(opLocal);
					WriteInteger(i);
					break;
				}
			}

			if (i == m_nFrameSize)
			{
				// Not a parameter, so assume late bound variable...
#ifdef _DEBUG0
				{
					TCHAR chSav = pchToken[cchToken];
					((TCHAR*)pchToken)[cchToken] = '\0';
					LOCALTRACE(_T("%d: opVar: %s\n"), m_nop, pchToken);
					((TCHAR*)pchToken)[cchToken] = chSav;
				}
#endif
				Write(opVar);
				WriteString(pchToken, cchToken);
			}
		}
	}

	if (bNeg)
		Write(opNeg);

	return pch;
}

static const DOPER rgdoper [] =
{
	{ '.',	0,		0,		1, opDot },

	{ '*',	0,		0,		2, opMul },
	{ '/',	0,		0,		2, opDiv },
//	{ '%',	0,		0,		5, opMod },

	{ '+',	0,		0,		3, opAdd },
	{ '-',	0,		0,		3, opSub },

	{ '<',	'<',	0,		4, opSHL },
//	{ '>',	'>',	'>',	4, opSHRU },
	{ '>',	'>',	0,		4, opSHR },

	{ '<',	'=',	0,		5, opLE },
	{ '>',	'=',	0,		5, opGE },
	{ '<',	0,		0,		5, opLT },
	{ '>',	0,		0,		5, opGT },

	{ '=',	'=',	0,		6, opEQ },
	{ '!',	'=',	0,		6, opNE },

  	{ '&',	0,		0,		7, opAnd },
  	{ '^',	0,		0,		8, opXor },
  	{ '|',	0,		0,		9, opOr },

//	{ '&',	'&',	0,		10, opLAnd }, // TODO: Need to implement this!
//	{ '|',	'|',	0,		11, opLOr }, // TODO: Need to implement this!

//	{ '?',	0,		0,		12, opQuest }, // TODO: Need to implement this!

	{ '=',	0,		0,		13, opAssign },
	{ '+',	'=',	0,		13, opAddAssign },
	{ '-',	'=',	0,		13, opSubAssign },
	{ '*',	'=',	0,		13, opMulAssign },
	{ '/',	'=',	0,		13, opDivAssign },
	{ '%',	'=',	0,		13, opModAssign },
//	{ '&',	'=',	0,		13, opAndAssign },
//	{ '|',	'=',	0,		13, opOrAssign },
//	{ '^',	'=',	0,		13, opXorAssign },
//	{ '<',	'<',	'=',	13, opSHLAssign },
//	{ '>',	'>',	'=',	13, opSHRAssign },
};

#define LAST_PRI	14

const TCHAR* CFunctionCompiler::ParseOperator(const TCHAR* pch, const DOPER*& pdoper)
{
	pdoper = NULL;

	pch = SkipWhite(pch);
	if (*pch == '\0')
		return pch;

	for (int nOper = 0; nOper < sizeof (rgdoper) / sizeof (DOPER); nOper += 1)
	{
		if (rgdoper[nOper].m_ch1 == *pch && (rgdoper[nOper].m_ch2 == 0 || rgdoper[nOper].m_ch2 == *(pch + 1)))
		{
			pch += 1;
			if (rgdoper[nOper].m_ch2 != 0)
				pch += 1;
			pdoper = &rgdoper[nOper];
			break;
		}
	}

	return pch;
}

const TCHAR* CFunctionCompiler::ParseArray(const TCHAR* pch)
{
	ASSERT(*pch == '[');
	pch += 1;

	pch = ParseExpression(pch);
	pch = SkipWhite(pch);

	if (*pch != ']')
	{
		SyntaxError(_T("Missing ']'"));
		return pch;
	}

	pch += 1;

//	LOCALTRACE(_T("%d: opArray:\n"), m_nop);
	Write(opArray);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseCall(const TCHAR* pch)
{
	// we have evaluated the reference to the function already and are looking at the '('

	int nArgs = 0;

	ASSERT(*pch == '(');
	pch += 1;

	pch = SkipWhite(pch);

	if (*pch == ')')
	{
		pch += 1;
	}
	else
	{
		for (;;)
		{
			pch = ParseExpression(pch);
			nArgs += 1;

			pch = SkipWhite(pch);

			if (*pch == ')')
			{
				pch += 1;
				break;
			}

			if (*pch != ',')
			{
				SyntaxError(_T("Missing ,"));
				return pch;
			}

			pch += 1;
		}
	}

	// we have now evaluated (nArgs) arguments

//	LOCALTRACE(_T("%d: opCall: nArgs=%d\n"), m_nop, nArgs);
	Write(opCall);
	Write((BYTE)nArgs);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseExp(const TCHAR* pch, int nPrio)
{
	if (nPrio == 0)
		return ParseTerm(pch);

	pch = ParseExp(pch, nPrio - 1);

	for (;;)
	{
		pch = SkipWhite(pch);

		if (nPrio == 1)
		{
			if (*pch == '(')
				pch = ParseCall(pch);
			else if (*pch == '[')
				pch = ParseArray(pch);
		}

		const TCHAR* pchOper = pch;
		const DOPER* pdoper;
		pch = ParseOperator(pch, pdoper);
		if (pdoper == NULL || pdoper->m_pri != nPrio)
			return pchOper;

		pch = ParseExp(pch, nPrio - 1);

//		LOCALTRACE(_T("%d: op %c%c\n"), m_nop, pdoper->m_ch1, pdoper->m_ch2 == 0 ? ' ' : pdoper->m_ch2);
		Write(pdoper->m_op);
	}
}

const TCHAR* CFunctionCompiler::ParseExpression(const TCHAR* pch)
{
	return ParseExp(pch, LAST_PRI);
}

const TCHAR* CFunctionCompiler::ParseIF(const TCHAR* pch)
{
	pch = SkipWhite(pch);
	if (*pch != '(')
	{
		SyntaxError(_T("expected '('"));
		return pch;
	}

	pch += 1;

	pch = ParseExpression(pch);

	pch = SkipWhite(pch);
	if (*pch != ')')
	{
		SyntaxError(_T("expected ')'"));
		return pch;
	}

	pch += 1;

//	LOCALTRACE(_T("%d opCond: \n"), m_nop);
	Write(opCond);
	UINT nop = GetAddress();
	WriteInteger(0);

	pch = ParseStatement(pch);

	// Check for else clause...

	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);

	if (cchToken == 4 && _tcsncmp(pchToken, _T("else"), cchToken) == 0)
	{
//		LOCALTRACE(_T("%d: opJump: \n"), m_nop);
		Write(opJump);
		UINT nopElse = GetAddress();
		WriteInteger(0);

		// fixup cond
		Fixup(nop, GetAddress());

		pch = ParseStatement(pch);

		// fixup jump
		Fixup(nopElse, GetAddress());
	}
	else
	{
		// Backup...
		pch = pchToken;

		// fixup cond
		Fixup(nop, GetAddress());
	}

	return pch;
}

const TCHAR* CFunctionCompiler::ParseWHILE(const TCHAR* pch)
{
	BREAK* pOldBreaks = m_pBreak;
	m_pBreak = NULL;
	m_nBreakables += 1;

	pch = SkipWhite(pch);
	if (*pch != '(')
	{
		SyntaxError(_T("expected '('"));
		return _T("");
	}

	pch += 1;

	int nopOldTopOfLoop = m_nopTopOfLoop;
	m_nopTopOfLoop = GetAddress();
	pch = ParseExpression(pch);

	pch = SkipWhite(pch);
	if (*pch != ')')
	{
		SyntaxError(_T("expected ')'"));
		return _T("");
	}

	pch += 1;

//	LOCALTRACE(_T("%d opCond: \n"), m_nop);
	Write(opCond);
	UINT nopFixup = GetAddress();
	WriteInteger(0);

	pch = ParseStatement(pch);

//	LOCALTRACE(_T("%d: opJump: \n"), m_nop);
	Write(opJump);
	WriteInteger(m_nopTopOfLoop);

	// Fixup jump out of loop
	Fixup(nopFixup, GetAddress());

	FixupBreaks();

	m_pBreak = pOldBreaks;
	m_nBreakables -= 1;
	m_nopTopOfLoop = nopOldTopOfLoop;

	return pch;
}

const TCHAR* CFunctionCompiler::ParseDO(const TCHAR* pch)
{
	BREAK* pOldBreaks = m_pBreak;
	m_pBreak = NULL;
	m_nBreakables += 1;

	pch += 1;

	int nopOldTopOfLoop = m_nopTopOfLoop;
	m_nopTopOfLoop = GetAddress();

	pch = ParseStatement(pch);

	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);
	if (cchToken != 5 || _tcsncmp(pchToken, _T("while"), 5) != 0)
	{
		SyntaxError(_T("expected 'while'"));
		return _T("");
	}

	pch = SkipWhite(pch);
	if (*pch != '(')
	{
		SyntaxError(_T("expected '('"));
		return _T("");
	}

	pch += 1;

	pch = ParseExpression(pch);

	pch = SkipWhite(pch);
	if (*pch != ')')
	{
		SyntaxError(_T("expected ')'"));
		return _T("");
	}

	pch += 1;

	pch = SkipWhite(pch);
	if (*pch != ';')
	{
		SyntaxError(_T("expected ';'"));
		return _T("");
	}

	pch += 1;

	// REVIEW: This is inefficient; should have opNotCond or something...
//	LOCALTRACE(_T("%d opCond: \n"), m_nop);
	Write(opCond);
	UINT nopFixup = GetAddress();
	WriteInteger(0);

//	LOCALTRACE(_T("%d: opJump: \n"), m_nop);
	Write(opJump);
	WriteInteger(m_nopTopOfLoop);

	// Fixup jump out of loop
	Fixup(nopFixup, GetAddress());

	FixupBreaks();

	m_pBreak = pOldBreaks;
	m_nBreakables -= 1;
	m_nopTopOfLoop = nopOldTopOfLoop;

	return pch;
}

const TCHAR* CFunctionCompiler::ParseFOR(const TCHAR* pch)
{
	BREAK* pOldBreaks = m_pBreak;
	m_pBreak = NULL;
	m_nBreakables += 1;

	pch = SkipWhite(pch);
	if (*pch != '(')
	{
		SyntaxError(_T("expected '('"));
		return _T("");
	}

	pch += 1;

	// Initial expression...
	const TCHAR* pchToken;
	int cchToken;
	Token(pch, pchToken, cchToken);
	if (cchToken == 3 && _tcsncmp(pchToken, _T("var"), cchToken) == 0)
	{
		pch += 3;
		pch = ParseLocalVar(pch);
	}
	else
	{
		pch = ParseExpression(pch);
		Write(opDrop);

		pch = SkipWhite(pch);
		if (*pch != ';')
		{
			SyntaxError(_T("expected ';'"));
			return _T("");
		}

		pch += 1;
	}



	// Condition...
	int nopOldTopOfLoop = m_nopTopOfLoop;
	m_nopTopOfLoop = GetAddress();
	pch = ParseExpression(pch);

	pch = SkipWhite(pch);
	if (*pch != ';')
	{
		SyntaxError(_T("expected ';'"));
		return _T("");
	}

	pch += 1;

	int nopExp3 = GetAddress();
	const TCHAR* pchExp3 = pch;
	pch = ParseExpression(pch);
	Write(opDrop);
	m_nop = nopExp3; // backup to start of expression

	pch = SkipWhite(pch);
	if (*pch != ')')
	{
		SyntaxError(_T("expected ')'"));
		return _T("");
	}

	pch += 1;



//	LOCALTRACE(_T("%d opCond: \n"), m_nop);
	Write(opCond);
	UINT nopFixup = GetAddress();
	WriteInteger(0);

	pch = ParseStatement(pch);

	// Generate code for the third expression...
	ParseExpression(pchExp3);
	Write(opDrop);

//	LOCALTRACE(_T("%d: opJump: \n"), m_nop);
	Write(opJump);
	WriteInteger(m_nopTopOfLoop);

	// Fixup jump out of loop
	Fixup(nopFixup, GetAddress());

	FixupBreaks();

	m_pBreak = pOldBreaks;
	m_nBreakables -= 1;
	m_nopTopOfLoop = nopOldTopOfLoop;

	return pch;
}


void CFunctionCompiler::FixupBreaks()
{
	for (BREAK* pBreak = m_pBreak; pBreak != NULL; )
	{
		BREAK* pNextBreak = pBreak->m_pNext;
		Fixup(pBreak->m_nop, GetAddress());
		delete pBreak;
		pBreak = pNextBreak;
	}
}

const TCHAR* CFunctionCompiler::ParseBREAK(const TCHAR* pch)
{
	pch = SkipWhite(pch);
	if (*pch != ';')
	{
		SyntaxError(_T("Missing ';'"));
		return _T("");
	}

	pch += 1;

	if (m_nBreakables == 0)
	{
		SyntaxError(_T("unexpected 'break'"));
		return _T("");
	}

	// Jump out of the loop or switch!
//	LOCALTRACE(_T("%d: opJump: \n"), m_nop);
	Write(opJump);
	BREAK* pBreak = new BREAK;
	pBreak->m_pNext = m_pBreak;
	m_pBreak = pBreak;
	pBreak->m_nop = GetAddress();
	WriteInteger(0);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseCONTINUE(const TCHAR* pch)
{
	pch = SkipWhite(pch);
	if (*pch != ';')
	{
		SyntaxError(_T("Missing ';'"));
		return _T("");
	}

	pch += 1;

	if (m_nBreakables == 0)
	{
		SyntaxError(_T("unexpected 'continue'"));
		return _T("");
	}

//	LOCALTRACE(_T("%d: opJump: \n"), m_nop);
	Write(opJump);
	WriteInteger(m_nopTopOfLoop);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseRETURN(const TCHAR* pch)
{
	pch = SkipWhite(pch);
	if (*pch == ';')
	{
		Write(opNull);
	}
	else
	{
		pch = ParseExpression(pch);

		pch = SkipWhite(pch);
		if (*pch != ';')
		{
			SyntaxError(_T("Missing ';'"));
			return _T("");
		}
	}

	pch += 1;

//	LOCALTRACE(_T("%d: opRet\n"), m_nop);
	Write(opRet);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseSLEEP(const TCHAR* pch)
{
	pch = SkipWhite(pch);
	if (*pch == ';')
	{
		Write(opNull);
	}
	else
	{
		pch = ParseExpression(pch);

		pch = SkipWhite(pch);
		if (*pch != ';')
		{
			SyntaxError(_T("Missing ';'"));
			return _T("");
		}
	}

	pch += 1;

//	LOCALTRACE(_T("%d: opSleep\n"), m_nop);
	Write(opSleep);

	return pch;
}

const TCHAR* CFunctionCompiler::ParseBlock(const TCHAR* pch)
{
	bool bBrace = (*pch == '{');
	if (bBrace)
		pch += 1;

	int nFrameSize = m_nFrameSize;

	Write(opFrame);
	UINT nopFrameFixup = GetAddress();
	WriteInteger(0);

	while (*pch != '\0' && (!bBrace || *pch != '}'))
		pch = ParseStatement(pch);

	if (bBrace)
	{
		if (*pch != '}')
		{
			SyntaxError(_T("expected '}'"));
			return pch;
		}

		pch += 1;
	}

	// Fixup frame...
//	LOCALTRACE(_T("Fixing frame for %d locals\n"), m_nFrameSize - nFrameSize);
	Fixup(nopFrameFixup, m_nFrameSize - nFrameSize);
	Write(opEndFrame);
	WriteInteger(m_nFrameSize - nFrameSize);

	m_nFrameSize = nFrameSize; // nuke the block locals...

	return pch;
}

const TCHAR* CFunctionCompiler::ParseStatement(const TCHAR* pch)
{
	pch = SkipWhite(pch);

	if (*pch == '}')
		return pch;

	if (*pch == '{')
	{
		return ParseBlock(pch);
	}

	const TCHAR* pchToken;
	int cchToken;
	pch = Token(pch, pchToken, cchToken);

//	LOCALTRACE(_T("%d: opStatement: line %d\n"), GetAddress(), g_nLine);
	Write(opStatement);
	WriteInteger(g_nLine);

	if (cchToken == 3 && _tcsncmp(pchToken, _T("var"), cchToken) == 0)
		return ParseLocalVar(pch);

	if (cchToken == 2 && _tcsncmp(pchToken, _T("if"), cchToken) == 0)
		return ParseIF(pch);

	if (cchToken == 5 && _tcsncmp(pchToken, _T("while"), cchToken) == 0)
		return ParseWHILE(pch);

	if (cchToken == 3 && _tcsncmp(pchToken, _T("for"), cchToken) == 0)
		return ParseFOR(pch);

	if (cchToken == 2 && _tcsncmp(pchToken, _T("do"), cchToken) == 0)
		return ParseDO(pch);

	if (cchToken == 5 && _tcsncmp(pchToken, _T("break"), cchToken) == 0)
		return ParseBREAK(pch);

	if (cchToken == 8 && _tcsncmp(pchToken, _T("continue"), cchToken) == 0)
		return ParseCONTINUE(pch);

	if (cchToken == 6 && _tcsncmp(pchToken, _T("return"), cchToken) == 0)
		return ParseRETURN(pch);

	if (m_bBehavior && cchToken == 5 && _tcsncmp(pchToken, _T("sleep"), cchToken) == 0)
		return ParseSLEEP(pch);

	// TODO: switch statements

	pch = ParseExpression(pchToken);
	Write(opDrop);

	if (*pch != 0)
	{
		if (*pch != ';')
		{
			SyntaxError(_T("expected ';'"));
			return _T("");
		}

		pch += 1;
	}

	return pch;
}


// Add local variables to the current function...
const TCHAR* CFunctionCompiler::ParseLocalVar(const TCHAR* pch)
{
	for (;;)
	{
		const TCHAR* pchToken;
		int cchToken;
		pch = Token(pch, pchToken, cchToken);

#ifdef _DEBUG0
		{
			TCHAR chSav = pchToken[cchToken];
			((TCHAR*)pchToken)[cchToken] = '\0';
			LOCALTRACE(_T("new member variable \"%s\"\n"), pchToken);
			((TCHAR*)pchToken)[cchToken] = chSav;
		}
#endif
		m_rgstLocal[m_nFrameSize].pchName = pchToken;
		m_rgstLocal[m_nFrameSize].cchName = (short)cchToken;
		m_nFrameSize += 1;

		pch = SkipWhite(pch);

		if (*pch == '=')
		{
			pch += 1;

//			LOCALTRACE(_T("%d: opLocal: %d\n"), m_nop, m_nFrameSize - 1);
			Write(opLocal);
			WriteInteger(m_nFrameSize - 1);

			pch = ParseExpression(pch);

//			LOCALTRACE(_T("%d: opAssign\n"), m_nop);
			Write(opAssign);
			Write(opDrop);

			pch = SkipWhite(pch);
		}

		if (*pch != ',')
			break;

		pch += 1;
	}

	if (*pch != ';')
		SyntaxError(_T("Expected a ';'"));
	else
		pch += 1;

	return pch;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\cdda.cpp ===
#include "std.h"
#include "xapp.h"
#include "cdda.h"

////////////////////////////////////////////////////////////////////////////

CCDDAStreamer::CCDDAStreamer(CNtIoctlCdromService* pDrive, DWORD dwRetries)
{
	ASSERT(pDrive != NULL);

	m_ibChunk = 0;
	m_pDrive = pDrive;
    m_dwRetries = dwRetries;
	m_dwCurFrame = 0;
    m_chunk = (BYTE *)XPhysicalAlloc(CDDA_BUFFER_SIZE, -1, 0, PAGE_READWRITE);
}

CCDDAStreamer::~CCDDAStreamer()
{
    if (m_chunk)
        XPhysicalFree(m_chunk);
}

int CCDDAStreamer::ReadFrames(void* pvBuffer, DWORD nFrameCount)
{

#ifdef _DEBUG

    const DWORD dwStartTime = GetTickCount();

#endif

    DWORD nTotalFrames = m_pDrive->GetTrackFrame(m_pDrive->GetTrackCount());
    nFrameCount = min(nFrameCount, nTotalFrames - m_dwCurFrame);
    ASSERT((int)nFrameCount > 0);

	HRESULT hr = m_pDrive->Read(m_dwCurFrame, nFrameCount, pvBuffer, m_dwRetries);
	if (FAILED(hr))
	{
        ZeroMemory(pvBuffer, nFrameCount * CDAUDIO_BYTES_PER_FRAME);
        if (hr != HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))
        {
            return -1;
        }
        else
        {
            // REVIEW: we probably hit end of the disc but need better way to detect this
            return 0;
        }
	}

#ifdef _DEBUG

    const DWORD dwEndTime = GetTickCount();

    if(dwEndTime - dwStartTime >= nFrameCount * 1000 / CDAUDIO_FRAMES_PER_SECOND)
    {
        TRACE(_T("\001CCDDAStreamer: read of frames %lu through %lu took longer than real-time (%lu ms)\n"), m_dwCurFrame, m_dwCurFrame + nFrameCount - 1, dwEndTime - dwStartTime);
    }

#endif

	m_dwCurFrame += nFrameCount;

	return nFrameCount * CDAUDIO_BYTES_PER_FRAME;
}

int CCDDAStreamer::Read(void* pvBuffer, int cbWanted)
{
    BYTE *pbBuffer = (BYTE *)pvBuffer;
    int cbRead;

    if (!m_chunk)
        return -1;

    if (m_ibChunk)
    {
        cbRead = min(cbWanted, CDDA_BUFFER_SIZE - m_ibChunk);

        CopyMemory(pbBuffer, m_chunk + m_ibChunk, cbRead);

        m_ibChunk += cbRead;
        m_ibChunk %= CDDA_BUFFER_SIZE;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while (cbWanted >= CDDA_MAX_FRAMES_PER_READ * CDAUDIO_BYTES_PER_FRAME)
    {
        cbRead = ReadFrames(pbBuffer, CDDA_MAX_FRAMES_PER_READ);
        if (cbRead <= 0)
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    while (cbWanted >= CDDA_BUFFER_SIZE)
    {
        cbRead = ReadFrames(pbBuffer, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME);
        if (cbRead <= 0)
            return cbRead;

        cbWanted -= cbRead;
        pbBuffer += cbRead;
    }

    if (cbWanted)
    {
        cbRead = ReadFrames(m_chunk, CDDA_BUFFER_SIZE / CDAUDIO_BYTES_PER_FRAME);
        if (cbRead <= 0)
            return cbRead;

        if (cbRead < CDDA_BUFFER_SIZE)
            ZeroMemory(m_chunk + cbRead, CDDA_BUFFER_SIZE - cbRead);

        m_ibChunk = cbWanted;
        cbRead = min(cbRead, cbWanted);

        CopyMemory(pbBuffer, m_chunk, cbRead);

        cbWanted -= cbRead;
        pbBuffer += cbRead;
	}

	return pbBuffer - (LPBYTE)pvBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\CopyDest.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "node.h"
#include "runner.h"
#include "TitleCollection.h"

extern const TCHAR* g_szCurTitleImage;

class CCopyDestination : public CNode
{
	DECLARE_NODE(CCopyDestination, CNode)
public:
	CCopyDestination();
	~CCopyDestination();

	void Render();
	void Advance(float nSeconds);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

	CNode* m_pod;
	CNode* m_podIcon;
	CNode* m_panelMU;
	CNode* m_panelMUHilite;
	CNode* m_panelText;
	CNode* m_panelTextHilite;
	CNode* m_console;
	CNode* m_memoryUnit;

	int m_curDevUnit;
	int m_selDevUnit;
	int m_sourceDevUnit;
	float m_spacing;
	bool m_isActive;
	int m_select;

	float m_nScroll;
	int m_nScrollTo;
	XTIME m_nScrollTime;

	void selectUp();
	void selectDown();

	int m_rgDevUnit [9];
	int m_nDevUnitCount;

	DECLARE_NODE_PROPS();
	DECLARE_NODE_FUNCTIONS();

protected:
	
	const TCHAR* GetTitleID2(int nTitle);
	CStrObject* GetTitleID(int nTitle);
};

IMPLEMENT_NODE("CopyDestination", CCopyDestination, CNode)

START_NODE_PROPS(CCopyDestination, CNode)
	NODE_PROP(pt_node, CCopyDestination, pod)
	NODE_PROP(pt_node, CCopyDestination, panelMU)
	NODE_PROP(pt_node, CCopyDestination, panelMUHilite)
	NODE_PROP(pt_node, CCopyDestination, panelText)
	NODE_PROP(pt_node, CCopyDestination, panelTextHilite)
	NODE_PROP(pt_node, CCopyDestination, console)
	NODE_PROP(pt_node, CCopyDestination, memoryUnit)
	NODE_PROP(pt_integer, CCopyDestination, curDevUnit)
	NODE_PROP(pt_integer, CCopyDestination, selDevUnit)
	NODE_PROP(pt_integer, CCopyDestination, sourceDevUnit)
	NODE_PROP(pt_number, CCopyDestination, spacing)
	NODE_PROP(pt_boolean, CCopyDestination, isActive)
	NODE_PROP(pt_integer, CCopyDestination, select)
END_NODE_PROPS()

START_NODE_FUN(CCopyDestination, CNode)
	NODE_FUN_VV(selectUp)
	NODE_FUN_VV(selectDown)
END_NODE_FUN()


CCopyDestination::CCopyDestination() :
	m_pod(NULL),
	m_panelMU(NULL),
	m_panelMUHilite(NULL),
	m_panelText(NULL),
	m_panelTextHilite(NULL),
	m_console(NULL),
	m_memoryUnit(NULL),
	m_curDevUnit(-1),
	m_selDevUnit(-1),
	m_sourceDevUnit(-1),
	m_spacing(0.4f),
	m_isActive(false),
	m_select(-1)
{
	m_nScroll = 0.0f;
	m_nScrollTo = 0;
	m_nScrollTime = 0.0f;
	m_nDevUnitCount = 0;
}

CCopyDestination::~CCopyDestination()
{
	if (m_pod != NULL)
		m_pod->Release();

	if (m_panelMU != NULL)
		m_panelMU->Release();

	if (m_panelMUHilite != NULL)
		m_panelMUHilite->Release();

	if (m_panelText != NULL)
		m_panelText->Release();

	if (m_panelTextHilite != NULL)
		m_panelTextHilite->Release();

	if (m_console != NULL)
		m_console->Release();

	if (m_memoryUnit != NULL)
		m_memoryUnit->Release();
}

void CCopyDestination::Render()
{
//	ASSERT(m_isActive); // you really should show an inactive copy dest object!

	if (m_pod == NULL)
		return;

	float y = m_nScroll;
	for (int i = 0; i < m_nDevUnitCount; i += 1)
	{
		D3DXMATRIX mat;
		D3DXMatrixTranslation(&mat, 0.0f, y, 0.0f);
		XAppPushWorld();
		XAppMultWorld(&mat);
		XAppUpdateWorld();
		m_pod->Render();
		
		// update the text rendered under each MU
		m_selDevUnit = m_rgDevUnit[i];
		CallFunction(this, _T("UpdateMemUnitText"));

		if (m_rgDevUnit[i] == m_curDevUnit)
		{
			if(m_selDevUnit == 8)
			{
				m_panelMUHilite->Render();
				m_panelTextHilite->Render();
				m_console->Render();
			}
			else
			{
				m_panelMUHilite->Render();
				m_panelTextHilite->Render();
				m_memoryUnit->Render();
			}
		}
		else
		{
			if(m_selDevUnit == 8)
			{
				m_panelMU->Render();
				m_panelText->Render();
				m_console->Render();
			}
			else
			{
				m_panelMU->Render();
				m_panelText->Render();
				m_memoryUnit->Render();
			}
		}

		// TODO: Work the text into here...

		XAppPopWorld();

		y -= m_spacing;
	}
}

void CCopyDestination::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);
    bool fCurDevUnitRemoved = false;

	if (!m_isActive)
		return;

	int nDevUnitIndex = -1;

	// Look for memory units...
	m_nDevUnitCount = 0;
	for (int i = 0; i < 9; i += 1)
	{
		int devUnit = (i == 0) ? 8/*Dev0*/ : (i - 1);

		// Ignore the source unit
		if (devUnit == m_sourceDevUnit)
			continue;

		// Ignore missing units
		if (devUnit != 8/*Dev0*/ && !g_titles[devUnit].IsValid())
        {
            if(devUnit == m_curDevUnit)
            {
                fCurDevUnitRemoved = true;
            }
			continue;
        }

		m_rgDevUnit[m_nDevUnitCount] = devUnit;

		if (devUnit == m_curDevUnit)
			nDevUnitIndex = m_nDevUnitCount;

		m_nDevUnitCount += 1;
	}

	// TODO: look for inserted units and auto-select them...

	if (nDevUnitIndex != -1 && m_select != nDevUnitIndex)
	{
		// The current unit switched positions; scroll immediately
		m_select = nDevUnitIndex;
		m_nScrollTo = m_select;
		m_nScroll = m_spacing * m_select;
	}

	if (m_select < 0)
		m_select = 0;
	if (m_select > m_nDevUnitCount - 1)
		m_select = m_nDevUnitCount - 1;

	if (m_nScrollTo != m_select)
	{
		m_nScrollTo = m_select;
		m_nScrollTime = XAppGetNow();
	}
	else if (m_nScrollTime != 0.0f)
	{
		float t = (float) (XAppGetNow() - m_nScrollTime) / 0.25f;
		if (t >= 1.0f)
		{
			m_nScrollTime = 0.0f;
			t = 1.0f;
		}

		float t1 = 1.0f - t;
		m_nScroll = t1 * m_nScroll + t * (m_spacing * m_nScrollTo);
	}

    int curDevUnit = -1;
	if (m_select != -1)
	    curDevUnit = m_rgDevUnit[m_select];
    
	if (curDevUnit != m_curDevUnit)
	{
        m_curDevUnit = curDevUnit;
        
        
        if(fCurDevUnitRemoved)
        {
            CallFunction(this, _T("OnDestinationUnitRemoved"));
        }
		CallFunction(this, _T("OnCurDevUnitChange"));
    }
}

bool CCopyDestination::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	return CNode::OnSetProperty(pprd, pvValue);
}

void CCopyDestination::selectUp()
{
	if (m_nDevUnitCount < 2)
		return;

	int nSel = m_select - 1;
	if (nSel >= 0 && nSel < m_nDevUnitCount)
	{
		m_select = nSel;
		m_curDevUnit = m_rgDevUnit[nSel];
		CallFunction(this, _T("OnCurDevUnitChange"));
	}
}

void CCopyDestination::selectDown()
{
	if (m_nDevUnitCount < 2)
		return;

	int nSel = m_select + 1;
	if (nSel >= 0 && nSel < m_nDevUnitCount)
	{
		m_select = nSel;
		m_curDevUnit = m_rgDevUnit[nSel];
		CallFunction(this, _T("OnCurDevUnitChange"));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Date.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Runner.h"
#include "Date.h"
#include "Locale.h"
#include <xconfig.h>

extern CObject** g_rgParam;
extern int g_nParam;
extern CRunner* g_pRunner;
extern CObject* Dereference(CObject* pObject);


IMPLEMENT_NODE("Date", CDateObject, CObject)

START_NODE_FUN(CDateObject, CObject)
	NODE_FUN_IV(getDate)
	NODE_FUN_IV(getDay)
	NODE_FUN_IV(getFullYear)
	NODE_FUN_IV(getHours)
	NODE_FUN_IV(getMilliseconds)
	NODE_FUN_IV(getMinutes)
	NODE_FUN_IV(getMonth)
	NODE_FUN_IV(getSeconds)
	NODE_FUN_IV(getUTCDate)
	NODE_FUN_IV(getUTCDay)
	NODE_FUN_IV(getUTCFullYear)
	NODE_FUN_IV(getUTCHours)
	NODE_FUN_IV(getUTCMilliseconds)
	NODE_FUN_IV(getUTCMinutes)
	NODE_FUN_IV(getUTCMonth)
	NODE_FUN_IV(getUTCSeconds)
	NODE_FUN_SV(toGMTString)
	NODE_FUN_SV(toLocaleString)
	NODE_FUN_SV(toUTCString)

	NODE_FUN_II(isLeapYear)
	NODE_FUN_III(getDaysInMonth)

	NODE_FUN_VV(SetSystemClock)
END_NODE_FUN()

int CDateObject::isLeapYear(int nYear)
{
    if (nYear % 100 == 0 && nYear % 400 != 0)
		return 0;

	if (nYear % 4 == 0)
		return 1;

	return 0;
}

int CDateObject::getDaysInMonth(int nMonth, int nYear)
{
	static short rgdays [] = { 31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

	if (nMonth != 2)
		return rgdays[nMonth - 1];

	return isLeapYear(nYear) ? 29 : 28;
}

CDateObject::CDateObject()
{
	SYSTEMTIME stime;

	if (g_nParam == 0)
	{
		GetSystemTime(&stime);
	}
	else if (g_nParam >= 3 && g_nParam <= 7)
	{
		ZeroMemory(&stime, sizeof (stime));

		for (int i = 0; i < g_nParam; i += 1)
			g_rgParam[i] = Dereference(g_rgParam[i]);

		CNumObject* pNum = g_rgParam[0]->ToNum();
		stime.wYear = (WORD)pNum->m_nValue;
		if (stime.wYear < 100)
			stime.wYear += 1900;
		pNum->Release();

		pNum = g_rgParam[1]->ToNum();
		stime.wMonth = (WORD)pNum->m_nValue + 1;
		pNum->Release();

		pNum = g_rgParam[2]->ToNum();
		stime.wDay = (WORD)pNum->m_nValue;
		pNum->Release();

		if (g_nParam > 3)
		{
			pNum = g_rgParam[3]->ToNum();
			stime.wHour = (WORD)pNum->m_nValue;
			pNum->Release();

			if (g_nParam > 4)
			{
				pNum = g_rgParam[4]->ToNum();
				stime.wMinute = (WORD)pNum->m_nValue;
				pNum->Release();

				if (g_nParam > 5)
				{
					pNum = g_rgParam[5]->ToNum();
					stime.wSecond = (WORD)pNum->m_nValue;
					pNum->Release();

					if (g_nParam > 6)
					{
						pNum = g_rgParam[6]->ToNum();
						stime.wMilliseconds = (WORD)pNum->m_nValue;
						pNum->Release();
					}
				}
			}
		}
	}
	else
	{
		g_pRunner->Error(_T("Wrong number of parameters to Date constructor\n"));
		return;
	}

	VERIFY(SystemTimeToFileTime(&stime, &m_time));
}


int CDateObject::getDate()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wDay;
}

int CDateObject::getDay()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wDayOfWeek;
}

int CDateObject::getFullYear()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wYear;
}

int CDateObject::getHours()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wHour;
}

int CDateObject::getMilliseconds()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wMilliseconds;
}

int CDateObject::getMinutes()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wMinute;
}

int CDateObject::getMonth()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wMonth - 1;
}

int CDateObject::getSeconds()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	return st.wSecond;
}

int CDateObject::getUTCDate()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wDay;
}

int CDateObject::getUTCDay()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wDayOfWeek;
}

int CDateObject::getUTCFullYear()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wYear;
}

int CDateObject::getUTCHours()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wHour;
}

int CDateObject::getUTCMilliseconds()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMilliseconds;
}

int CDateObject::getUTCMinutes()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMinute;
}

int CDateObject::getUTCMonth()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wMonth - 1;
}

int CDateObject::getUTCSeconds()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	return st.wSecond;
}

int CDateObject::getYear()
{
	int nYear = getFullYear();

	if (nYear >= 1900 && nYear < 2000)
		return nYear - 1900;

	return nYear;
}

const TCHAR* rgszMonth3 [] = { _T("Jan"), _T("Feb"), _T("Mar"), _T("Apr"), _T("May"), _T("Jun"), _T("Jul"), _T("Aug"), _T("Sep"), _T("Oct"), _T("Nov"), _T("Dec") };

CStrObject* CDateObject::toGMTString()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	TCHAR szBuf [32];
	_stprintf(szBuf, _T("%02d %s %d %02d:%02d:%02d GMT"), st.wDay, rgszMonth3[st.wMonth - 1], st.wYear, st.wHour, st.wMinute, st.wSecond);
	return new CStrObject(szBuf);
}

CStrObject* CDateObject::toLocaleString()
{
	FILETIME local;
	FileTimeToLocalFileTime(&m_time, &local);

	SYSTEMTIME st;
	FileTimeToSystemTime(&local, &st);

	TCHAR szBuf [32];
	FormatTime(szBuf, countof(szBuf), &st);
	return new CStrObject(szBuf);
}

CStrObject* CDateObject::toUTCString()
{
	SYSTEMTIME st;
	FileTimeToSystemTime(&m_time, &st);

	TCHAR szBuf [32];
	_stprintf(szBuf, _T("%02d %s %d %02d:%02d:%02d UTC"), st.wDay, rgszMonth3[st.wMonth - 1], st.wYear, st.wHour, st.wMinute, st.wSecond);
	return new CStrObject(szBuf);
}


void CDateObject::SetSystemClock()
{
	SYSTEMTIME stime;
	FileTimeToSystemTime(&m_time, &stime);

	TRACE(_T("Setting system clock to: %d/%d/%d %d:%02d:%02d:%03d\n"),
		stime.wMonth, stime.wDay, stime.wYear,
        stime.wHour, stime.wMinute, stime.wSecond, stime.wMilliseconds);

	VERIFY(XapiSetLocalTime(&stime));

    //
    // NOTE:
    //  If the current time is daylight saving time and
    //  the new time is in standard time, or vice versa,
    //  the result will be off by one hour (+/-).
    //
    //  If that's case, we need to set it again.
    //

    SYSTEMTIME newstime;
    FILETIME newftime;
    LONGLONG offset;

    GetLocalTime(&newstime);
    VERIFY(SystemTimeToFileTime(&newstime, &newftime));

    ASSERT(sizeof(FILETIME) == sizeof(LONGLONG));
    offset = *((LONGLONG*) &newftime) - *((LONGLONG*) &m_time);

    // if we're off by more than 1 minute, set it again
    if ((offset >= 0 ? offset : -offset) >= 600000000) {
        VERIFY(XapiSetLocalTime(&stime));
    }

    //
    // Check to see if this is the first time we're setting date/time
    // If so, remember the date/time information in the refurb sector as well.
    //
    XBOX_REFURB_INFO refurbInfo;
    NTSTATUS status;
    status = ExReadWriteRefurbInfo(&refurbInfo, sizeof(refurbInfo), FALSE);
    if (NT_SUCCESS(status) && refurbInfo.FirstSetTime.QuadPart == 0) {
        refurbInfo.FirstSetTime.LowPart = m_time.dwLowDateTime;
        refurbInfo.FirstSetTime.HighPart = m_time.dwHighDateTime;
        status = ExReadWriteRefurbInfo(&refurbInfo, sizeof(refurbInfo), TRUE);
    }
    ASSERT(NT_SUCCESS(status));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\CopyGames.h ===
#pragma once

class CGameCopier
{
public:
	CGameCopier();
	~CGameCopier();

	void SetSource(int nDevUnit);
	void SetDestination(int nDevUnit);
	void AddGame(const TCHAR* szTitleID, const TCHAR* szGameDir, FILETIME saveTime, int nBlocks);

	void Start();
	void Finish();

	float m_progress;
	bool m_error;
	bool m_done;

	bool DeleteDirectory(const TCHAR* szDir, bool RemoveSelf = true);

private:
	HANDLE m_hThread;
	int m_srcDevUnit;
	int m_destDevUnit;
	TCHAR* m_szSrcRoot;
	TCHAR* m_szDestRoot;
	struct CCopyGame* m_rgCopyGame;
	int m_nCopyGameCount;
	int m_nCopyGameAlloc;
	BYTE* m_buffer;
	bool m_bInternalError;
    bool m_bAlreadyExists;

	int m_nCopyGameCur;
	int m_nTotalBlocks;
	int m_nCopiedBlocks;

	DWORD ThreadProc();
	void CopyGame(int nCopyGame/*const TCHAR* szTitleID, const TCHAR* szGameDir*/);
	bool CreateDirectory(const TCHAR* szDir);
	bool CopyDirectory(const TCHAR* szSrcDir, const TCHAR* szDestDir);
	bool CopyFile(const TCHAR* szSrcFile, const TCHAR* szDestFile);
	bool DeleteFile(const TCHAR* szFile);
	void RemoveAll();

	static DWORD CALLBACK StartThread(LPVOID pvContext);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Class.cpp ===
#include "std.h"
#include "xapp.h"
#include "Parser.h"
#include "Node.h"
#include "Runner.h"
#include "ActiveFile.h"
#include "xip.h"
#include "DefUse.h"

extern bool g_bParseError;


CClass::CClass() : CNodeClass(_T("[class]"), 0, NULL, NULL, NULL)
{
    m_obj = objClass;
    m_szURL = NULL;
    m_nVarCount = 0; // TODO: This should start with the count from the base class!
    m_pConstructor = NULL;
}

CClass::~CClass()
{
    delete [] m_szURL;

    if (m_pConstructor != NULL)
        m_pConstructor->Release();
}

CNode* CClass::CreateNode()
{
    return new CInstance(this);
}

// REVIEW: These four functions should be moved to CClassCompiler or a new class or globals...

bool CClass::Load(const TCHAR* szURL)
{
    CDirPush dirPush(szURL);

    int cch = _tcslen(szURL) + 1;
    delete m_szURL;
    m_szURL = new TCHAR [cch];
    CopyChars(m_szURL, szURL, cch);

    if (!m_file.Fetch(szURL))
        return false;

#ifdef _UNICODE
    m_file.MakeUnicode();
#endif

    BYTE* pbContent = m_file.DetachContent();
    bool fParse = ParseFile(szURL, (const TCHAR*)pbContent);
    XAppFreeMemory(pbContent);
    if (!fParse)
        return false;

    return true;
}

bool CClass::LoadAbsURL(const TCHAR* szURL)
{
    ASSERT(szURL[0] && szURL[1] == ':');

    int cch = _tcslen(szURL) + 1;
    delete m_szURL;
    m_szURL = new TCHAR [cch];
    CopyChars(m_szURL, szURL, cch);

    if (!m_file.Fetch(szURL))
        return false;

#ifdef _UNICODE
    m_file.MakeUnicode();
#endif

    BYTE* pbContent = m_file.DetachContent();
    bool fParse = ParseFile(szURL, (const TCHAR*)pbContent);
    XAppFreeMemory(pbContent);
    if (!fParse)
        return false;

    return true;
}

bool CClass::ParseFile(const TCHAR* szFileName, const TCHAR* szFile)
{
    const TCHAR* pch = szFile;

    StartParse(pch, szFileName);

    pch = ParseClassBody(pch);

    if (*pch != '\0')
        SyntaxError(_T("Stuff past expected end of file!"));

    EndParse();

    return !g_bParseError;
}

const TCHAR* CClass::ParseClassBody(const TCHAR* pch)
{
    CClassCompiler constructor(this);
    pch = constructor.Compile(pch);
    m_pConstructor = constructor.CreateFunction();

    return pch;
}


////////////////////////////////////////////////////////////////////////////

CInstance::CInstance(CClass* pClass)
{
    m_obj = objInstance;
    m_pClass = pClass;
    m_pClass->AddRef();

    m_vars.SetLength(pClass->GetVariableCount());

#ifdef _DEBUG
//  int nStartTime = GetTickCount();
#endif

    Construct();

#ifdef _DEBUG
//  TRACE(_T("%s took %d mS to construct\n"), pClass->m_szURL, GetTickCount() - nStartTime);
#endif

    OnLoad();
}



extern CObject* CreateNewObject(const TCHAR* pchClassName, int cchClassName, CObject** rgparam = NULL, int nParam = 0);

inline int FetchInt(BYTE*& pop)
{
    int n;
    CopyMemory(&n, pop, sizeof (int));
    pop += sizeof (int);
    return n;
}

// This will construct the scene graph of a CInstance
BYTE* CInstance::Construct()
{
//  TRACE("Construct node 0x%08x\n", this);

    BYTE* pop = m_pClass->m_pConstructor->m_rgop;

    if (pop == NULL)
        return pop;

    int nNodeStack = 0;
    CNode* nodeStack [100];

    int nNodeArrayStack = 0;
    CNodeArray* nodeArrayStack [100];

    CNode* pNode = NULL;
    CNodeArray* pNodeArray = &m_children;

    int nDefNextNodeVar = -1;

    for (;;)
    {
        BYTE op = *pop++;
//      TRACE(_T("op: %d\n"), op);

        switch (op)
        {
        default:
            // Done constructing
            return pop - 1;

        case opNewNode:
            {
                int cch = FetchInt(pop);
                const TCHAR* pch = (const TCHAR*)pop;
                pop += cch * sizeof (TCHAR);

                nodeStack[nNodeStack] = pNode;
                nNodeStack += 1;

                pNode = (CNode*)CreateNewObject(pch, cch);
                pNode->m_pParent = this;
                pNodeArray->AddNode(pNode);

                if (nDefNextNodeVar != -1)
                {
//                  TRACE(_T("Set var %d to node 0x%08x\n"), nDefNextNodeVar, pNode);

                    pNode->AddRef();
                    m_vars.SetNode(nDefNextNodeVar, pNode);
                    nDefNextNodeVar = -1;
                }
            }
            break;

        case opNewNodeProp:
            {
                PRD prd;
                CopyMemory(&prd, pop, sizeof (PRD));
                pop += sizeof (PRD);

                if (*pop == opUseNode)
                {
                    pop += 1;

                    int nVar = FetchInt(pop);

                    CNode* pNodeT = m_vars.GetNode(nVar);
                    pNode->SetProperty(&prd, &pNodeT, sizeof (CNode*));
                    break;
                }

                if (*pop == opDefNode)
                {
                    pop += 1;

                    int nVar = FetchInt(pop);

                    nDefNextNodeVar = nVar;
                }

                ASSERT(*pop == opNewNode);
                pop += 1;

                int cch = FetchInt(pop);
                const TCHAR* pch = (const TCHAR*)pop;
                pop += cch * sizeof (TCHAR);

                nodeStack[nNodeStack] = pNode;
                nNodeStack += 1;

                pNode = (CNode*)CreateNewObject(pch, cch);
                pNode->m_pParent = this;
                nodeStack[nNodeStack - 1]->SetProperty(&prd, &pNode, sizeof (CNode*));

                // Adjust for reference added by SetProperty...
                ASSERT(pNode->m_nRefCount == 2);
                pNode->Release();

                if (nDefNextNodeVar != -1)
                {
//                  TRACE(_T("Set var %d to node 0x%08x\n"), nDefNextNodeVar, pNode);

                    pNode->AddRef();
                    m_vars.SetNode(nDefNextNodeVar, pNode);
                    nDefNextNodeVar = -1;
                }
            }
            break;

        case opDefNode:
            {
                int nVar = FetchInt(pop);

                nDefNextNodeVar = nVar;
            }
            break;

        case opUseNode:
            {
                int nVar = FetchInt(pop);

                CNode* pNode = m_vars.GetNode(nVar);
                pNode->AddRef();
                pNodeArray->AddNode(pNode);
            }
            break;

        case opEndNode:
            ASSERT(nNodeStack > 0);

            pNode->OnLoad();

            nNodeStack -= 1;
            pNode = nodeStack[nNodeStack];
            break;

        case opInitProp:
            {
                PRD prd;
                CopyMemory(&prd, pop, sizeof (PRD));
                pop += sizeof (PRD);

                int cbProp = FetchInt(pop);
                const void* pValue = pop;
                pop += cbProp;

                ASSERT(pNode != NULL);

                TCHAR szBuf [1024];
                const TCHAR* sz;
                if (prd.nType == pt_string)
                {
                    CopyChars(szBuf, pValue, cbProp);
                    szBuf[cbProp] = 0;
                    sz = szBuf;
                    pValue = &sz;
#ifdef _UNICODE
                    pop += cbProp;
#endif
                }

                pNode->SetProperty(&prd, pValue, cbProp);
            }
            break;

        case opInitArray:
            {
                int nProp = FetchInt(pop);

                nodeArrayStack[nNodeArrayStack] = pNodeArray;
                nNodeArrayStack += 1;

                pNodeArray = (CNodeArray*)((BYTE*)pNode + nProp);
            }
            break;

        case opEndArray:
            ASSERT(nNodeArrayStack > 0);

            nNodeArrayStack -= 1;
            pNodeArray = nodeArrayStack[nNodeArrayStack];
            break;

        case opFunction:
            {
                int cch = FetchInt(pop);
                const TCHAR* pch = (const TCHAR*)pop;
                pop += cch * sizeof (TCHAR);
                int nFunction = FetchInt(pop);

                CObject* pFun = m_pClass->m_instanceFunctions.GetNode(nFunction);
                pFun->AddRef();
                pNode->SetMember(pch, cch, pFun);
            }
            break;
        }
    }
}


CInstance::~CInstance()
{
    m_pClass->Release();
}

CNodeClass* CInstance::GetNodeClass() const
{
    return m_pClass;
}

CObject* CInstance::Dot(CObject* pObj)
{
    if (pObj->m_obj == objVariable)
    {
        CVarObject* pVar = (CVarObject*)pObj;

        if (m_pClass->m_members != NULL)
        {
            CObject* pLookup = m_pClass->m_members->Lookup(pVar->m_sz, pVar->m_nLength);
            if (pLookup != NULL)
            {
                if (pLookup->m_obj == objMember)
                {
                    // Found a member variable...
                    CMemberVarObject* pMemberVar = new CMemberVarObject(this, ((CMember*)pLookup)->m_nMember);
                    return pMemberVar;
                }

                if (pLookup->m_obj == objFunction)
                {
                    CMemberFunctionObject* pMember = new CMemberFunctionObject(this, (CFunction*)pLookup);
                    return pMember;
                }
            }
        }
    }

    return CNode::Dot(pObj);
}

void CInstance::Render()
{
    CGroup::Render();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\CopyGames.cpp ===
#include "std.h"
#include "XApp.h"
#include "Node.h"
#include "FileUtil.h"
#include "TitleCollection.h"
#include "CopyGames.h"

const TCHAR szTitleDataXBX [] = _T("TitleMeta.xbx");
const TCHAR szTitleImageXBX [] = _T("TitleImage.xbx");
const TCHAR szSaveDataXBX [] = _T("SaveMeta.xbx");
const TCHAR szSaveImageXBX [] = _T("SaveImage.xbx");


struct CCopyGame
{
	TCHAR* m_szTitleID;
	TCHAR* m_szGameDir;
	FILETIME m_time;
	bool m_bNeedToAdd;
};

CGameCopier::CGameCopier()
{
	m_hThread = NULL;
	m_progress = 0.0f;
	m_bInternalError = false;
    m_bAlreadyExists = false;
	m_error = false;
	m_done = false;
	m_nTotalBlocks = 0;
	m_nCopiedBlocks = 0;
	m_szDestRoot = NULL;
	m_szSrcRoot = NULL;
	m_rgCopyGame = NULL;
	m_nCopyGameAlloc = 0;
	m_nCopyGameCount = 0;
	m_buffer = NULL;
	m_srcDevUnit = -1;
	m_destDevUnit = -1;
}

CGameCopier::~CGameCopier()
{
#ifndef _XBOX
	if (m_hThread != NULL)
		TerminateThread(m_hThread, 0);
#endif

	RemoveAll();
}

void CGameCopier::RemoveAll()
{
	delete [] m_szDestRoot;
	m_szDestRoot = NULL;

	delete [] m_szSrcRoot;
	m_szSrcRoot = NULL;

	for (int i = 0; i < m_nCopyGameCount; i += 1)
	{
		delete [] m_rgCopyGame[i].m_szTitleID;
		delete [] m_rgCopyGame[i].m_szGameDir;
	}

	delete [] m_rgCopyGame;
	m_rgCopyGame = NULL;
	m_nCopyGameAlloc = 0;
	m_nCopyGameCount = 0;
	m_nTotalBlocks = 0;

	delete [] m_buffer;
	m_buffer = NULL;
}

void CGameCopier::Finish()
{
	for (int i = 0; i < m_nCopyGameCount; i += 1)
	{
		if (m_rgCopyGame[i].m_bNeedToAdd)
		{
            // Remove it if it already exists
            if (m_bAlreadyExists)
            {
                g_titles[m_destDevUnit].RemoveSavedGame(m_rgCopyGame[i].m_szTitleID, m_rgCopyGame[i].m_szGameDir);
            }

			g_titles[m_destDevUnit].AddSavedGame(m_rgCopyGame[i].m_szTitleID, m_rgCopyGame[i].m_szGameDir, m_rgCopyGame[i].m_time);
			m_rgCopyGame[i].m_bNeedToAdd = false;
		}
	}

	RemoveAll();
}

DWORD CALLBACK CGameCopier::StartThread(LPVOID pvContext)
{
	CGameCopier *pThis = (CGameCopier*)pvContext;
	return pThis->ThreadProc();
}

void CGameCopier::CopyGame(int nCopyGame/*const TCHAR* szTitleID, const TCHAR* szGameDir*/)
{
	const TCHAR* szTitleID = m_rgCopyGame[nCopyGame].m_szTitleID;
	const TCHAR* szGameDir = m_rgCopyGame[nCopyGame].m_szGameDir;

	TRACE(_T("CopyGame(%s, %s)\n"), szTitleID, szGameDir);
	ASSERT(!m_bInternalError);

	TCHAR szSrcPath [MAX_PATH];
	TCHAR szDestPath [MAX_PATH];
	bool bNewTitle = false;

	// BLOCK: Make sure the destination has the title directory
	{
		MakePath(szDestPath, m_szDestRoot, szTitleID);
		bNewTitle = CreateDirectory(szDestPath);
	}

	// BLOCK: Copy the title's titleimage.xbx file
	{
		MakePath(szDestPath, m_szDestRoot, szTitleID);
		MakePath(szDestPath, szDestPath, szTitleImageXBX);

		if (bNewTitle || GetFileSize(szDestPath) == 0)
		{
			MakePath(szSrcPath, m_szSrcRoot, szTitleID);
			MakePath(szSrcPath, szSrcPath, szTitleImageXBX);
		
			CopyFile(szSrcPath, szDestPath);
		}
	}

	// BLOCK: Copy the title's default save game image file
	{
		MakePath(szDestPath, m_szDestRoot, szTitleID);
		MakePath(szDestPath, szDestPath, szSaveImageXBX);

		MakePath(szSrcPath, m_szSrcRoot, szTitleID);
		MakePath(szSrcPath, szSrcPath, szSaveImageXBX);
		
		if (DoesFileExist(szSrcPath) && GetFileSize(szDestPath) == 0)
		{
			CopyFile(szSrcPath, szDestPath);
		}
	}

	// Reset this in case one of those less important files failed to copy...
	m_bInternalError = false;
    m_bAlreadyExists = false;

	// BLOCK: Create a saved game directory
	{
		MakePath(szDestPath, m_szDestRoot, szTitleID);
		MakePath(szDestPath, szDestPath, szGameDir);

		if (!CreateDirectory(szDestPath))
		{
            if (GetLastError() == ERROR_ALREADY_EXISTS)
            {
                m_bAlreadyExists = true;

                // Delete all files in this saved game
                DeleteDirectory(szDestPath, false);
            }
            else
            {
    			m_bInternalError = true;
    			return;
            }
		}

		TRACE(_T("Creating game in %s\n"), szDestPath);

		HANDLE hFile = XAppCreateFile(szDestPath, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			VERIFY(SetFileTime(hFile, &m_rgCopyGame[nCopyGame].m_time, &m_rgCopyGame[nCopyGame].m_time, &m_rgCopyGame[nCopyGame].m_time));
			VERIFY(CloseHandle(hFile));
		}
#ifdef _DEBUG
		else
		{
			TRACE(_T("Cannot open directory (%s) to set times (%d)\n"), szDestPath, GetLastError());
		}
#endif
	}

	MakePath(szSrcPath, m_szSrcRoot, szTitleID);
	MakePath(szSrcPath, szSrcPath, szGameDir);

	if (!CopyDirectory(szSrcPath, szDestPath))
	{
		TRACE(_T("\001The copy didn't complete; removing what we did copy...\n"));

		// The copy didn't complete; remove what we did copy...
		if (bNewTitle)
		{
			TRACE(_T("it was a new title; deleting: %s %s\n"), m_szDestRoot, szTitleID);
			MakePath(szDestPath, m_szDestRoot, szTitleID);
		}

		DeleteDirectory(szDestPath);
		return;
	}

	// BLOCK: Update the directory name
	{
		TCHAR* pch = _tcsrchr(szDestPath, '\\');
		ASSERT(pch != NULL);
		pch += 1;

		delete [] m_rgCopyGame[nCopyGame].m_szGameDir;
		m_rgCopyGame[nCopyGame].m_szGameDir = new TCHAR [_tcslen(pch) + 1];
		_tcscpy(m_rgCopyGame[nCopyGame].m_szGameDir, pch);
	}

	// BLOCK: Copy the title's meta.xbx file (last in case MU is pulled out causing an error we can't clean up)
	{
		MakePath(szDestPath, m_szDestRoot, szTitleID);
		MakePath(szDestPath, szDestPath, szTitleDataXBX);

		if (bNewTitle || GetFileSize(szDestPath) == 0)
		{
			MakePath(szSrcPath, m_szSrcRoot, szTitleID);
			MakePath(szSrcPath, szSrcPath, szTitleDataXBX);

			CopyFile(szSrcPath, szDestPath);
		}
	}
}

bool CGameCopier::CreateDirectory(const TCHAR* szDir)
{
	TRACE(_T("CreateDirectory(%s)\n"), szDir);

#ifdef _XBOX
	char szDir2 [MAX_PATH];
	Ansi(szDir2, szDir, MAX_PATH);
#else
#define szDir2 szDir
#endif

	return ::CreateDirectory(szDir2, NULL) != FALSE;
}

bool CGameCopier::CopyDirectory(const TCHAR* szSrcPath, const TCHAR* szDestPath)
{
	TRACE(_T("CopyDirectory(%s, %s)\n"), szSrcPath, szDestPath);

	CreateDirectory(szDestPath);

	TCHAR szBuf [MAX_PATH];
	MakePath(szBuf, szSrcPath, _T("*.*"));

	WIN32_FIND_DATA fd;
#ifdef _XBOX
	char szBufX [MAX_PATH];
	Ansi(szBufX, szBuf, MAX_PATH);
	HANDLE h = FindFirstFile(szBufX, &fd);
#else
	HANDLE h = FindFirstFile(szBuf, &fd);
#endif
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
#ifdef _XBOX
			TCHAR szFileName [MAX_PATH];
			Unicode(szFileName, fd.cFileName, MAX_PATH);
#else
			const TCHAR* szFileName = fd.cFileName;
#endif
			if (_tcscmp(szFileName, _T(".")) == 0 || _tcscmp(szFileName, _T("..")) == 0)
				continue;

			MakePath(szBuf, szSrcPath, szFileName);

			TCHAR szBuf2 [MAX_PATH];
			MakePath(szBuf2, szDestPath, szFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!CopyDirectory(szBuf, szBuf2))
				{
					TRACE(_T("CopyDirectory(%s, %s) failed\n"), szBuf, szBuf2);
					FindClose(h);
					m_bInternalError = true;
					return false;
				}
			}
			else
			{
				if (!CopyFile(szBuf, szBuf2))
				{
					TRACE(_T("CopyFile(%s, %s) failed\n"), szBuf, szBuf2);
					FindClose(h);
					m_bInternalError = true;
					return false;
				}
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

	return true;
}

bool CGameCopier::CopyFile(const TCHAR* szSrcFile, const TCHAR* szDestFile)
{
	TRACE(_T("CopyFile(%s, %s)\n"), szSrcFile, szDestFile);

	HANDLE hSrcFile = XAppCreateFile(szSrcFile, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	if (hSrcFile == INVALID_HANDLE_VALUE)
	{
		TRACE(_T("OpenFile(%s) failed\n"), szSrcFile);
		m_bInternalError = true;
		return false;
	}

	HANDLE hDestFile = XAppCreateFile(szDestFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hDestFile == INVALID_HANDLE_VALUE)
	{
		CloseHandle(hSrcFile);
		TRACE(_T("CreateFile(%s) failed\n"), szDestFile);
		m_bInternalError = true;
		return false;
	}

	for (;;)
	{
		DWORD dwRead, dwWrite;

		if (!ReadFile(hSrcFile, m_buffer, BLOCK_SIZE, &dwRead, NULL))
		{
			TRACE(_T("ReadFile(%s) failed (%d)\n"), szSrcFile, GetLastError());
			m_bInternalError = true;
			break;
		}

		if (dwRead == 0)
			break;

		if (!WriteFile(hDestFile, m_buffer, dwRead, &dwWrite, NULL))
		{
			TRACE(_T("WriteFile(%s) failed (%d)\n"), szDestFile, GetLastError());
			m_bInternalError = true;
			break;
		}

		m_nCopiedBlocks += 1;
		m_progress = (float)m_nCopiedBlocks / (float)m_nTotalBlocks;
		TRACE(_T("copy progress: %f block %d of %d\n"), m_progress, m_nCopiedBlocks, m_nTotalBlocks);
	}

	if (!m_bInternalError)
	{
		FILETIME create, access, write;
		GetFileTime(hSrcFile, &create, &access, &write);
		SetFileTime(hDestFile, &create, &access, &write);
	}

	CloseHandle(hSrcFile);

	if (!CloseHandle(hDestFile))
	{
		TRACE(_T("CloseHandle(%s) failed\n"), szDestFile);
		m_bInternalError = true;
	}

	return !m_bInternalError;
}

bool CGameCopier::DeleteFile(const TCHAR* szFile)
{
//	TRACE(_T("DeleteFile(%s)\n"), szFile);

#ifdef _XBOX
	char szFileA [MAX_PATH];
	Ansi(szFileA, szFile, MAX_PATH);
	SetFileAttributes(szFileA, FILE_ATTRIBUTE_NORMAL);
	return ::DeleteFile(szFileA) != FALSE;
#else
	SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
	return ::DeleteFile(szFile) != FALSE;
#endif
}

bool CGameCopier::DeleteDirectory(const TCHAR* szDir, bool RemoveSelf /*= true*/)
{
//	TRACE(_T("DeleteDirectory(%s)\n"), szDir);

	TCHAR szBuf [MAX_PATH];
	MakePath(szBuf, szDir, _T("*.*"));

	WIN32_FIND_DATA fd;
#ifdef _XBOX
	char szBufX [MAX_PATH];
	Ansi(szBufX, szBuf, MAX_PATH);
	HANDLE h = FindFirstFile(szBufX, &fd);
#else
	HANDLE h = FindFirstFile(szBuf, &fd);
#endif
	if (h != INVALID_HANDLE_VALUE)
	{
		do
		{
#ifdef _XBOX
			TCHAR szFileName [MAX_PATH];
			Unicode(szFileName, fd.cFileName, MAX_PATH);
#else
			const TCHAR* szFileName = fd.cFileName;
#endif

			if (_tcscmp(szFileName, _T(".")) == 0 || _tcscmp(szFileName, _T("..")) == 0)
				continue;

			MakePath(szBuf, szDir, szFileName);

			if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
			{
				if (!DeleteDirectory(szBuf))
				{
					FindClose(h);
					m_bInternalError = true;
					return false;
				}
			}
			else
			{
				if (!DeleteFile(szBuf))
				{
					FindClose(h);
					m_bInternalError = true;
					return false;
				}
			}
		}
		while (FindNextFile(h, &fd));
		FindClose(h);
	}

    if (!RemoveSelf)
    {
        return true;
    }

#ifdef _XBOX
	char szDirA [MAX_PATH];
	Ansi(szDirA, szDir, MAX_PATH);
	return ::RemoveDirectory(szDirA) != FALSE;
#else
	return ::RemoveDirectory(szDir) != FALSE;
#endif
}

DWORD CGameCopier::ThreadProc()
{
	ASSERT(m_buffer != NULL);

	while (m_nCopyGameCur < m_nCopyGameCount)
	{
		CopyGame(m_nCopyGameCur/*m_rgCopyGame[m_nCopyGameCur].m_szTitleID, m_rgCopyGame[m_nCopyGameCur].m_szGameDir*/);
		if (m_bInternalError)
			break;

		m_rgCopyGame[m_nCopyGameCur].m_bNeedToAdd = true;
		m_nCopyGameCur += 1;
	}

	m_done = true;

	delete [] m_buffer;
	m_buffer = NULL;

	m_hThread = NULL;
	m_error = m_bInternalError;

	TRACE(_T("CGameCopier::ThreadProc terminating; error=%d\n"), m_error);

	return 1;
}

void CGameCopier::SetSource(int nDevUnit)
{
	m_srcDevUnit = nDevUnit;

	const TCHAR* szRoot = g_titles[nDevUnit].GetUData();

	TRACE(_T("SetSource(%s)\n"), szRoot);
	delete [] m_szSrcRoot;
	m_szSrcRoot = new TCHAR [_tcslen(szRoot) + 1];
	_tcscpy(m_szSrcRoot, szRoot);

	ASSERT(m_nTotalBlocks == 0);
	ASSERT(m_nCopyGameCount == 0);
}

void CGameCopier::SetDestination(int nDevUnit)
{
	m_destDevUnit = nDevUnit;

	const TCHAR* szRoot = g_titles[nDevUnit].GetUData();

	TRACE(_T("SetDestination(%s)\n"), szRoot);
	delete [] m_szDestRoot;
	m_szDestRoot = new TCHAR [_tcslen(szRoot) + 1];
	_tcscpy(m_szDestRoot, szRoot);

	ASSERT(m_nTotalBlocks == 0);
	ASSERT(m_nCopyGameCount == 0);
}

void CGameCopier::AddGame(const TCHAR* szTitleID, const TCHAR* szGameDir, FILETIME saveTime, int nBlocks)
{
	TRACE(_T("CGameCopier::AddGame: %s %s %d blocks\n"), szTitleID, szGameDir, nBlocks);

	if (m_nCopyGameCount == m_nCopyGameAlloc)
	{
		m_nCopyGameAlloc += 10;
		CCopyGame* rgCopyGame = new CCopyGame [m_nCopyGameAlloc];
		CopyMemory(rgCopyGame, m_rgCopyGame, m_nCopyGameCount * sizeof (CCopyGame));
		delete [] m_rgCopyGame;
		m_rgCopyGame = rgCopyGame;
	}

	m_rgCopyGame[m_nCopyGameCount].m_szTitleID = new TCHAR [_tcslen(szTitleID) + 1];
	_tcscpy(m_rgCopyGame[m_nCopyGameCount].m_szTitleID, szTitleID);

	m_rgCopyGame[m_nCopyGameCount].m_szGameDir = new TCHAR [_tcslen(szGameDir) + 1];
	_tcscpy(m_rgCopyGame[m_nCopyGameCount].m_szGameDir, szGameDir);

	m_rgCopyGame[m_nCopyGameCount].m_time = saveTime;

	m_rgCopyGame[m_nCopyGameCount].m_bNeedToAdd = false;

	m_nCopyGameCount += 1;

	m_nTotalBlocks += nBlocks;
}

void CGameCopier::Start()
{
	ASSERT(m_srcDevUnit >= 0 && m_srcDevUnit <= 8);
	ASSERT(m_destDevUnit >= 0 && m_destDevUnit <= 8);
	ASSERT(m_srcDevUnit != m_destDevUnit);

	TRACE(_T("Start game copy: %d blocks\n"), m_nTotalBlocks);

	m_progress = 0.0f;
	m_bInternalError = false;
	m_error = false;
	m_done = false;
	m_nCopiedBlocks = 0;
	m_nCopyGameCur = 0;

	if (m_buffer == NULL)
		m_buffer = new BYTE [BLOCK_SIZE];

	m_hThread = CreateThread(NULL, 0, StartThread, this, 0, 0);

    if (m_hThread)
    {
        CloseHandle(m_hThread);
    }
    else
    {
        StartThread(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\debug.cpp ===
#include "std.h"
#include "XApp.h"
#include "Node.h"

#ifdef _DEBUG

bool g_bDumpMemState;
int g_nFrameCount;
long _dbgBreakAlloc = -1;

int __cdecl DebugAllocHook(int nAllocType, void *pvData, size_t nSize, int nBlockUse, long lRequest, const unsigned char* szFileName, int nLine)
{
	if (lRequest == _dbgBreakAlloc)
		_CrtDbgBreak();

	return TRUE;
}

const TCHAR* GetFacilityName(int nFacility)
{
	const TCHAR* szFacility;

	switch (nFacility)
	{
	default:
		szFacility = _T("Unknown Facility");
		break;

	case FACILITY_NULL:
		szFacility = _T("null");
		break;

	case FACILITY_RPC:
		szFacility = _T("RPC");
		break;

	case FACILITY_DISPATCH:
		szFacility = _T("Dispatch");
		break;

	case FACILITY_STORAGE:
		szFacility = _T("Storage");
		break;

	case FACILITY_ITF:
		szFacility = _T("ITF");
		break;

	case FACILITY_WIN32:
		szFacility = _T("Win32");
		break;

	case FACILITY_WINDOWS:
		szFacility = _T("Windows");
		break;

	case FACILITY_SSPI:
		szFacility = _T("SSPI");
		break;

	case FACILITY_CONTROL:
		szFacility = _T("Control");
		break;

	case FACILITY_CERT:
		szFacility = _T("Cert");
		break;

	case FACILITY_INTERNET:
		szFacility = _T("Internet");
		break;

	case FACILITY_MEDIASERVER:
		szFacility = _T("Media Server");
		break;

	case FACILITY_MSMQ:
		szFacility = _T("MSMQ");
		break;

	case FACILITY_SETUPAPI:
		szFacility = _T("Setup API");
		break;

	case 0x15: // _FACDPV
		szFacility = _T("DirectPlayVoice");
		break;

	case 0x876: // _FACDD, _FACD3D
		szFacility = _T("Direct3D");
		break;

	case 0x877: // _FACDP
		szFacility = _T("DirectPlay");
		break;

	case 0x878: // _FACDS
		szFacility = _T("DirectSound");
		break;
	}

	return szFacility;
}

void XAppGetErrorString(HRESULT hr, TCHAR* szErrorBuf, int cchErrorBuf)
{
	int nCode = HRESULT_CODE(hr);
	int nFacility = HRESULT_FACILITY(hr);

	const TCHAR* szFacility = GetFacilityName(nFacility);
	_tcsncpy(szErrorBuf, szFacility, cchErrorBuf);
	int cchFacility = _tcslen(szFacility);
	szErrorBuf += cchFacility;
	cchErrorBuf -= cchFacility;

	if (cchErrorBuf > 2)
	{
		*szErrorBuf++ = ':';
		*szErrorBuf++ = ' ';
		cchErrorBuf -= 2;
	}

#ifdef _LAN
	if (nFacility == FACILITY_INTERNET)
	{
		extern void GetInternetErrorString(int nCode, TCHAR* szBuf, int cchBuf);
		GetInternetErrorString(nCode, szErrorBuf, cchErrorBuf);
		return;
	}
#endif

	if (nFacility == FACILITY_WIN32)
	{
#ifndef _XBOX
		if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, nCode, 0, szErrorBuf, cchErrorBuf, NULL) == 0)
#endif
			_stprintf(szErrorBuf, _T("Lookup %d in winerror.h!"), nCode);
		return;
	}

	D3DXGetErrorString(hr, szErrorBuf, cchErrorBuf);
}

const TCHAR* XAppGetErrorString(HRESULT hr)
{
	static TCHAR szBuf [100];
	XAppGetErrorString(hr, szBuf, countof(szBuf));
	return szBuf;
}

void LogComError(HRESULT hr, const char* szFunc/*= NULL*/)
{
	TCHAR szError [100];
	XAppGetErrorString(hr, szError, countof(szError));

#ifdef _UNICODE
	TCHAR szFunction [100];
	Unicode(szFunction, szFunc, 100);

	Trace(_T("\001Error in function: %s\n\001%s\n"), szFunc == NULL ? _T("unknown") : szFunction, szError);
#else
	Trace(_T("\001Error in function: %s\n\001%s\n"), szFunc == NULL ? _T("unknown") : szFunc, szError);
#endif
}

void LogError(const char* szFunc)
{
	Trace(_T("\001Error in function: %s\n"), szFunc);
}

extern "C" bool AssertFailed(const TCHAR* szFile, int nLine, HRESULT hr)
{
	TCHAR szBuffer [256];

	if (hr == 0)
	{
		_stprintf(szBuffer, _T("Assertion failed in %s at line %d (last error code is 0x%x)."), szFile, nLine, GetLastError());
	}
	else
	{
		TCHAR szComError [100];
		XAppGetErrorString(hr, szComError, countof(szComError));
		_stprintf(szBuffer, _T("COM Failure in %s at line %d.\n\nFacility: %d %s\nCode %d (0x%04x)\n\n%s"),
			szFile, nLine, HRESULT_FACILITY(hr), GetFacilityName(HRESULT_FACILITY(hr)), HRESULT_CODE(hr), HRESULT_CODE(hr), szComError);
	}

#ifdef _XBOX
	Trace(_T("\001XApp: %s\n"), szBuffer);
	return true;
#else
	_tcscat(szBuffer, _T("\n\nDo you want to debug?"));
	return XAppMessageBox(szBuffer, MB_YESNO) == IDYES;
#endif
}

#ifdef _XBOX
bool bShowComments = false;
#endif

extern "C" void Trace(const TCHAR* szMsg, ...)
{
	va_list args;
	va_start(args, szMsg);

#ifdef _XBOX
	if (*szMsg > 0 && *szMsg < 8)
		szMsg += 1; // skip over message type (color) specifier
	else if (!bShowComments)
		return;
#endif

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, countof(szBuffer), szMsg, args);

	const TCHAR* szODS = szBuffer;
	OutputDebugString(szODS);

	va_end(args);
}

void Debug_Init()
{
	TRACE(_T("This is a debug version of XApp!\n"));

	_CrtSetAllocHook(DebugAllocHook);
}

void Debug_Exit()
{
	_CrtDumpMemoryLeaks();
}

void DumpHex(const BYTE* pbData, int cbData, int cbMax/*=0*/)
{
	TCHAR szBuf [256];
	TCHAR szBuf2 [32];

	bool bTruncated = false;
	if (cbMax != 0 && cbData > cbMax)
	{
		bTruncated = true;
		cbData = cbMax;
	}

	TCHAR* pch = szBuf;
	TCHAR* pch2 = szBuf2;
	for (int i = 0; i < cbData; i += 1)
	{
		BYTE b = *pbData++;

		pch += _stprintf(pch, _T("%02x "), b);

		if (b >= ' ' && b < 128)
			*pch2++ = b;
		else
			*pch2++ = '.';

		if ((i & 15) == 15 || i == cbData - 1)
		{
			*pch2 = '\0';
			Trace(_T("%-48s %s\n"), szBuf, szBuf2);
			pch = szBuf;
			pch2 = szBuf2;
		}
	}

	if (bTruncated)
		Trace(_T("...\n"));
}

void Debug_Frame()
{
	g_nFrameCount += 1;

	static XTIME nextHeapCheckTime;
	if (XAppGetNow() < nextHeapCheckTime)
		return;

	nextHeapCheckTime = XAppGetNow() + 5.0f; // every 5 seconds...


	// Check heap consistency...
	switch (_heapchk())
	{
	case _HEAPBADBEGIN:
		TRACE(_T("\001HEAPCHK: Initial header information is bad or cannot be found\n"));
		_CrtDbgBreak();
		break;

	case _HEAPBADNODE:
		TRACE(_T("\001HEAPCHK: Bad node has been found or heap is damaged\n"));
		_CrtDbgBreak();
		break;

	case _HEAPBADPTR:
		TRACE(_T("\001HEAPCHK: Pointer into heap is not valid\n"));
		_CrtDbgBreak();
		break;

	case _HEAPEMPTY:
		TRACE(_T("\001HEAPCHK: Heap has not been initialized\n"));
		_CrtDbgBreak();
		break;

	case _HEAPOK:
		break;
	}


#if 0
	// BLOCK: Compute and dump heap size...
	{
		DWORD dwTotalAlloc = 0;		
		_HEAPINFO hinfo;
		hinfo._pentry = NULL;
		while (_heapwalk(&hinfo) == _HEAPOK)
		{
			if (hinfo._useflag == _USEDENTRY)
				dwTotalAlloc += hinfo._size;
		}

		TRACE(_T("Heap size: %dKB (%d bytes)\n"), ((dwTotalAlloc + 1023) / 1024), dwTotalAlloc);
	}

	// BLOCK: Dump any leaked objects...
	{
		static _CrtMemState memState;

		if (g_bDumpMemState)
		{
			_CrtMemDumpAllObjectsSince(&memState);
			g_bDumpMemState = false;
		}

		_CrtMemCheckpoint(&memState);

#ifdef _XBOX
//		g_bDumpMemState = true;
#endif
	}
#endif
}


void DumpRegisteredClasses()
{
	TRACE(_T("Registered Classes:\n"));
	for (CNodeClass* pClass = CNodeClass::c_pFirstClass; pClass != NULL; pClass = pClass->m_pNextClass)
	{
		TRACE(_T("\t%s\n"), pClass->m_szClassName);
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Date.h ===
#pragma once

class CDateObject : public CObject
{
	DECLARE_NODE(CDateObject, CObject)
public:
	CDateObject();

	int getDate();
	int getDay();
	int getFullYear();
	int getHours();
	int getMilliseconds();
	int getMinutes();
	int getMonth();
	int getSeconds();
	int getUTCDate();
	int getUTCDay();
	int getUTCFullYear();
	int getUTCHours();
	int getUTCMilliseconds();
	int getUTCMinutes();
	int getUTCMonth();
	int getUTCSeconds();
	int getYear();

	int isLeapYear(int nYear);
	int getDaysInMonth(int nMonth, int nYear);

	void SetSystemClock();

	CStrObject* toGMTString();
	CStrObject* toLocaleString();
	CStrObject* toUTCString();

	FILETIME m_time; // 100-nanosecond intervals since January 1, 1601

	DECLARE_NODE_FUNCTIONS()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DefUse.cpp ===
#include "std.h"
#include "xapp.h"
#include "DefUse.h"
#include "Node.h"

CNameSpace::CNameSpace()
{
    m_pFirstDefine = NULL;
}

CNameSpace::~CNameSpace()
{
    CDefine* pNextDef;
    for (CDefine* pDef = m_pFirstDefine; pDef != NULL; pDef = pNextDef)
    {
        pDef->m_pNode->Release();
        pNextDef = pDef->m_pNext;
        delete pDef;
    }
}

bool CNameSpace::Define(const TCHAR* pchName, int cchName, CNode* pNode)
{
    if (Lookup(pchName, cchName) != NULL)
        return FALSE;

#pragma push_macro("new")
#undef new
    CDefine* pDefine = new(cchName) CDefine;
#pragma pop_macro("new")

    CopyChars(pDefine->m_szName, pchName, cchName);
    pDefine->m_szName[cchName] = '\0';

    pDefine->m_pNext = m_pFirstDefine;
    m_pFirstDefine = pDefine;

    pDefine->m_pNode = pNode;

    return true;
}

CDefine* CNameSpace::Add(const TCHAR* pchName, int cchName)
{
#pragma push_macro("new")
#undef new
    CDefine* pDefine = new(cchName) CDefine;
#pragma pop_macro("new")

    CopyChars(pDefine->m_szName, pchName, cchName);
    pDefine->m_szName[cchName] = '\0';

    pDefine->m_pNext = m_pFirstDefine;
    m_pFirstDefine = pDefine;

    pDefine->m_pNode = NULL;

    return pDefine;
}

CDefine* CNameSpace::Get(const TCHAR* pchName, int cchName)
{
    for (CDefine* pDefine = m_pFirstDefine; pDefine != NULL; pDefine = pDefine->m_pNext)
    {
        if ((int)_tcslen(pDefine->m_szName) == cchName && _tcsncmp(pchName, pDefine->m_szName, cchName) == 0)
            return pDefine;
    }

    return Add(pchName, cchName);
}

CNode* CNameSpace::Lookup(const TCHAR* pchName, int cchName)
{
    for (CDefine* pDefine = m_pFirstDefine; pDefine != NULL; pDefine = pDefine->m_pNext)
    {
        if ((int)_tcslen(pDefine->m_szName) == cchName && _tcsncmp(pchName, pDefine->m_szName, cchName) == 0)
            return pDefine->m_pNode;
    }

    return NULL;
}

CDefine* CNameSpace::Lookup(CNode* pNode)
{
    for (CDefine* pDefine = m_pFirstDefine; pDefine != NULL; pDefine = pDefine->m_pNext)
    {
        if (pNode == pDefine->m_pNode)
            return pDefine;
    }

    return NULL;
}

#ifdef _DEBUG
void CNameSpace::Dump() const
{
    for (CDefine* pDefine = m_pFirstDefine; pDefine != NULL; pDefine = pDefine->m_pNext)
        TRACE(_T("%s -> 0x%08x\n"), pDefine->m_szName, pDefine->m_pNode);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DefUse.h ===
#pragma once

class CNode;

struct CDefine
{
    CDefine* m_pNext;
    CNode* m_pNode;
    TCHAR m_szName[ANYSIZE_ARRAY];

#pragma push_macro("new")
#undef new
    void * operator new(size_t sz, int cchName)
    {
        return ::operator new(sz + cchName * sizeof(TCHAR));
    }
#pragma pop_macro("new")
};

struct CNameSpace
{
    CNameSpace();
    ~CNameSpace();

    bool Define(const TCHAR* pchName, int cchName, CNode* pNode);
    CNode* Lookup(const TCHAR* pchName, int cchName);
    CDefine* Lookup(CNode* pNode);
    CDefine* Get(const TCHAR* pchName, int cchName);
    CDefine* Add(const TCHAR* pchName, int cchName);

    CDefine* m_pFirstDefine;

#ifdef _DEBUG
    void Dump() const;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DeltaField.cpp ===
#include "std.h"
#include "xapp.h"
#include "surfx.h"





#define DEC_SIZE 5

DeltaField::DeltaField()
{
	mWidth = mHeight = 0;
	mCurrentY = -1;
	m_nStyle = 0;
}

DeltaFieldData::DeltaFieldData()
{
	mNegYExtents = 0;
	mField = NULL;
}

DeltaFieldData::~DeltaFieldData()
{
	delete [] mField;
}


DeltaFieldData* DeltaField::GetField()
{
	bool didCalc = false;

	if (mCurrentY >= 0)
	{
		while (!IsCalculated())
			CalcSome();

		return &mFieldData;
	}

	return NULL;
}


void DeltaField::Assign()
//bcvoid DeltaField::Assign(ArgList& inArgs, UtilStr& inName)
{
//bc	UtilStr fx, fy;

//bc	mName.Assign( inName );

	// Compile and link the temp exprs.  By spec, A-vars are evaluated now
//bc	mAVars.Compile( inArgs, 'A', mDict );
//bc	mAVars.Evaluate();		

//bc	mDVars.Compile( inArgs, 'D', mDict );

//bc	mAspect1to1	= inArgs.GetArg( 'Aspc' );
//bc	mPolar		= inArgs.ArgExists( 'srcR' );

	mAspect1to1 = true;
	mPolar = true;

	// Compile the 2D vector field that expresses the source point for a given point
/*bc
	if (mPolar)
	{
		inArgs.GetArg('srcR', fx);
		inArgs.GetArg('srcT', fy);
	}
	else
	{
		inArgs.GetArg('srcX', fx);
		inArgs.GetArg('srcY', fy);
	}

	mXField.Compile( fx, mDict );
	mYField.Compile( fy, mDict );

	mHasRTerm		= mXField.IsDependent( "R" )		|| mYField.IsDependent( "R" );
	mHasThetaTerm	= mXField.IsDependent( "THETA" )	|| mYField.IsDependent( "THETA" );
*/

	mHasRTerm = true;
	mHasThetaTerm = true;

	// Reset all computation of this delta field	
	SetSize(mWidth, mHeight, true);
}


void DeltaField::SetSize(long inWidth, long inHeight, bool inForceRegen)
{
	// Only resize if the new size is different...
	if (inWidth != mWidth || inHeight != mHeight || inForceRegen)
	{
		mWidth = inWidth;
		mHeight = inHeight;

		// Each pixel needs 3 bytes of info
//bc		mFieldData.mField = mTempMem.Dim( 3 * mWidth * mHeight + 64 );
		delete [] mFieldData.mField;
		mFieldData.mField = new char [3 * mWidth * mHeight + 64];

		mXScale = 2.0f / ((float)mWidth);
		mYScale = 2.0f / ((float)mHeight);

		// If we're to keep the xy aspect ratio to 1, change the dim that will get stretched
		if (mAspect1to1)
		{
			if (mYScale > mXScale)
				mXScale = mYScale;
			else
				mYScale = mXScale;
		}

		// Reset all computation of this delta field
		mCurrentY = 0;
		mNegYExtents = 0;

		// The current implementation of PixPort for Win32 flips all the Y Cords
		mYScale *= -1;
	}
}



#define __encode(x, y)	sx = x + 0x7E0;	/* 0b0111 1110 0000 */			\
						sy = y + 0x7E0; 								\
						*((unsigned long*)g) = (sx << 12) | (sy);		\
						g += 3;

int DeltaField::CalcSome()
{
	float xscale2, yscale2, r, fx, fy;
	long px, sx, sy, t;
	char* g;

	// Calc where we left off
	g = mFieldData.mField + 3 * mWidth * mCurrentY;

	// If we're computing the 1st or last row...
	if (mCurrentY == 0 || mCurrentY == mHeight - 1)
	{
		// Calc the mCurrentY row of the grad field
		for ( px = 0; px < mWidth; px++ )
		{
			__encode(0, 0)
		} 

		mCurrentY++; 
	}

	// If we're still have stuff left to compute...
	if (mCurrentY > 0 && mCurrentY < mHeight - 1)
	{
		// Calc the y we're currently at
		mY_Cord = 0.5f * mYScale * (mHeight - 2 * mCurrentY);


		// Save some cycles be pre-computing indep stuff
		xscale2 = ((float)(1 << DEC_SIZE)) / mXScale;
		yscale2 = ((float)(1 << DEC_SIZE)) / mYScale;

		// The first and last pixels stay the background color
		__encode(0, 0)

		// Calc the mCurrentY row of the grad field
		for (px = 1; px < mWidth - 1; px++)
		{
			mX_Cord = 0.5f * mXScale * (2 * px - mWidth);

			// Calculate R and THETA only if the field uses it (don't burn cycles on sqrt() and atan())
			if (mHasRTerm)
				mR_Cord = sqrtf(mX_Cord * mX_Cord + mY_Cord * mY_Cord);
			if (mHasThetaTerm)
				mT_Cord = atan2f(mY_Cord, mX_Cord);

			// Evaluate any temp variables
//bc			mDVars.Evaluate();	

			// Evaluate the source point for (mXCord, mYCord)
//bc			fx = mXField.Evaluate();
//bc			fy = mYField.Evaluate();

			GetXY(mR_Cord, mT_Cord, mX_Cord, mY_Cord, fx, fy, mPolar, px == 1 && mCurrentY == 1);

			if (mPolar)
			{
				r = fx;
				fx = r * cosf(fy);
				fy = r * sinf(fy);
			}

			sx = (long)(xscale2 * (fx - mX_Cord));
			sy = (long)(yscale2 * (mY_Cord - fy));

			// Clip the x source coordinate
			t = px + (sx >> DEC_SIZE);
			if (t >= mWidth - 1)
				sx = ((mWidth - 1 - px) << DEC_SIZE);
			else if (t < 0)
				sx = ((-px) << DEC_SIZE);

			// Clip the y source coordinate
			t = mCurrentY + (sy >> DEC_SIZE);
			if (t >= mHeight - 1)
				sy = ((mHeight - 1 - mCurrentY) << DEC_SIZE);
			else if (t < 0)
				sy = ((-mCurrentY) << DEC_SIZE);

			// This lets us know how 
			if (sy < mNegYExtents)
				mNegYExtents = sy;

			// Encode the gradient
			__encode(sx, sy)
		}

		// The first and last pixels stay the background color
		__encode(0, 0)

		// Signal the compution of the next row
		mCurrentY += 1;
	}

	if (IsCalculated())
	{
		// Tell PixPort how big the trailing buffer has to be
		mFieldData.mNegYExtents = 1 - ( mNegYExtents >> DEC_SIZE );
	}

	return mHeight - mCurrentY;
}


void DeltaField::GetXY(float r, float theta, float x, float y, float& X, float& Y, bool& bPolar, bool bInit)
{
	static float A0, A1, A2;
	bPolar = true;

	switch (m_nStyle)
	{
	default:
		m_nStyle = 0;
		// FALL THROUGH

	case 0: // Radial Breakaway
		X = r * (1.0f + 0.16f * atanf(0.55f - r));
		Y = theta - 0.01f;
		break;

	case 1: // Hip-no-therapy
		X = r * 0.87f;
		Y = theta - 0.075f;
		break;

	case 2: // Sunburst - Many
		if (bInit)
			A0 = trunc(8.0f * rnd(5.0f)) * 3.141592653f;
		X = ((1.0f + sinf(A0 * theta)) * 0.5f * 0.06f + 0.92f) * r;
		Y = theta;
		break;

	case 3: // Theta Divergence
		if (bInit)
		{
			A0 = 2.0f + rnd(16.0f);
			A1 = 0.01f + rnd(0.05f);
			A2 = 0.002f + rnd(0.006f);
		}

		X = pos(r - A2);
		Y = theta + A1 * sinf(A0 * r);
		break;

	case 4: // Turbo Flow Out
		X = 0.87f * r;
		Y = theta - 0.009f;
		break;

	case 5: // Turbo Flow Out - More
		X = 0.8f * r;
		Y = theta - 0.008f;
		break;

	case 6: // Boxilite
		if (bInit)
		{
			A0 = 2.0f + rnd(16.0f);
			A1 = 0.01f + rnd(0.05f);
		}

		X = x + A1 * sinf(A0 * y);
		Y = y + A1 * sinf(A0 * x);

		bPolar = false;
		break;

	case 7: // Collapse & Turn
		X = 1.01f * r;
		Y = theta + 0.021f;
		break;

	case 8: // Constant Out
		X = r - 0.01f;
		Y = theta;
		break;

	case 9: // Directrix Expand - X
		if (bInit)
		{
			A0 = rnd(0.0045f);
			A1 = 0.10f + rnd(0.06f);
			A2 = 0.003f + rnd(0.005f);
		}

		X = (0.99f - A1 * powf(fabsf(x), 1.3f)) * r - rnd(A0);
		Y = theta - A2;
		break;

	case 10: // Directrix Expand - Y
		if (bInit)
		{
			A0 = rnd(0.0045f); // noise offset
			A1 = 0.10f + rnd(0.06f); // scale of outflow
			A2 = 0.003f + rnd(0.006f); // rotation factor
		}

		X = (0.99f - A1 * powf(fabsf(y), 1.3f)) * r - rnd(A0);
		Y = theta + A2;
		break;

	case 11: // Equalateral Hyperbola
		X = r - 0.18f * x * y;
		Y = theta - 0.005f;
		break;

	case 12: // Expand & Turn
		X = 0.96f * r;
		Y = theta - 0.021f;
		break;

	case 13: // Gravity
		X = x + rnd(0.01f) - 0.005f;
		Y = y - rnd(0.01f) - 0.005f - (y - 1.3f) * 0.04f;
		bPolar = false;
		break;

	case 14: // In or Out, Inner Turn
		if (bInit)
			A0 = 0.95f + rnd(0.06f);

		X = r * A0;
		Y = theta - pos(1.0f - r) * 0.035f;
		break;

	case 15: // Left turn & Flow Out
		X = 0.94f * r;
		Y = theta - 0.007f;
		break;

	case 16: // Linear Spread
		X = 0.9f * x + rnd(0.008f) - 0.004f;
		Y = 0.9f * y + rnd(0.008f) - 0.004f;
		bPolar = false;
		break;

	case 17: // Noise Field
		X = x + 0.1f * (rnd(2.0f) - 1.0f);
		Y = y + 0.1f * (rnd(2.0f) - 1.0f);
		bPolar = false;
		break;

	case 18: // Right Turn
		X = r * 0.99f;
		Y = theta + 0.009f;
		break;

	case 19: // Scattered Flow Out
		X = (0.92f + rnd(0.05f)) * r;
		Y = theta + 0.003f;
		break;

	case 20: // Simple Sine-Sphere
		X = r + 0.04f * sinf(6.2831853f * r);
		Y = theta + 0.015f;
		break;

	case 21: // Sine Multi-Circ
		X = r * (0.87f + 0.05f * (1.0f + sinf(r * 15.0f)));
		Y = theta;
		break;

	case 22: // Sphere
		if (bInit)
		{
			A0 = rnd(0.1f); // osc magnitde
			A1 = 3.0f + rnd(7.0f); // osc freq
			A2 = 0.9f + rnd(0.3f); // Sphere radius
		}

		X = r * (1.0f + 0.13f * (r - A2));
		Y = theta + A0 * sinf(A1 * r);
		break;

	case 23: // Sunburst - Few
		if (bInit)
			A0 = trunc(1.0f + rnd(2.1f)) * 3.141592653f;

		X = ((1.0f + cosf(A0 * theta)) * 0.5f * 0.1f + 0.89f) * r;
		Y = theta + 0.005f;
		break;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DotField.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "surfx.h"


class CDotField : public CNode
{
	DECLARE_NODE(CDotField, CNode)
public:
	CDotField();
	~CDotField();

	float m_spacing;
	float m_hSpeed;
	float m_vSpeed;

	void Advance(float nSeconds);
	void RenderDynamicTexture(CSurfx* pSurfx);

protected:
	float m_xStart;
	float m_yStart;
	float m_xSpeed;
	float m_ySpeed;
	float m_newSpacing;
	float m_oldSpacing;

	XTIME m_nextChangeTime;
	XTIME m_lastChangeTime;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("DotField", CDotField, CNode)

START_NODE_PROPS(CDotField, CNode)
	NODE_PROP(pt_number, CDotField, spacing)
	NODE_PROP(pt_number, CDotField, hSpeed)
	NODE_PROP(pt_number, CDotField, vSpeed)
END_NODE_PROPS()

CDotField::CDotField() :
	m_spacing(8.0f),
	m_hSpeed(0.0f),
	m_vSpeed(0.0f)
{
	m_xStart = 0.0f;
	m_yStart = 0.0f;
	m_xSpeed = 0.0f;
	m_ySpeed = 0.0f;
	m_nextChangeTime = 0.0f;
	m_lastChangeTime = 0.0f;
}

CDotField::~CDotField()
{
}

void CDotField::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_hSpeed == 0.0f && m_vSpeed == 0.0f)
	{
		if (XAppGetNow() >= m_nextChangeTime)
		{
			m_xSpeed = (rnd(2.0f) - 1.0f) * m_spacing * 4.0f;
			m_ySpeed = (rnd(2.0f) - 1.0f) * m_spacing * 4.0f;
			m_newSpacing = 8.0f + rnd(24.0f);
			m_oldSpacing = m_spacing;

			m_lastChangeTime = XAppGetNow();
			m_nextChangeTime = XAppGetNow() + 10.0f + rnd(5.0f);

//			TRACE("DotField: change %f,%f\n", m_xSpeed, m_ySpeed);
		}
	}
	else
	{
		m_xSpeed = m_hSpeed;
		m_ySpeed = m_vSpeed;
	}

	if (m_lastChangeTime > 0.0f)
	{
		float r = (float) (XAppGetNow() - m_lastChangeTime);
		if (r < 1.0f)
			m_spacing = m_oldSpacing + (m_newSpacing - m_oldSpacing) * r;
		else
			m_lastChangeTime = 0.0f;
	}

	m_xStart = wrap(m_xStart + m_xSpeed * nSeconds / m_spacing);
	m_yStart = wrap(m_yStart + m_ySpeed * nSeconds / m_spacing);

//	TRACE("DotField: %f,%f  %f, %f\n", m_xSpeed, m_ySpeed, m_xStart, m_yStart);
}

void CDotField::RenderDynamicTexture(CSurfx* pSurfx)
{
	for (int y = (int)(m_yStart * m_spacing); y < pSurfx->m_nHeight; y += (int)m_spacing)
	{
		for (int x = (int)(m_xStart * m_spacing); x < pSurfx->m_nWidth; x += (int)m_spacing)
		{
			pSurfx->m_pels[x + y * pSurfx->m_nWidth] = 255;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\disc.cpp ===
#include "std.h"
#include "xapp.h"
#include "FileUtil.h"
#include "Node.h"
#include "ntiosvc.h"
#include "Runner.h"
#include "Sound.h"

int GetDiscType();

////////////////////////////////////////////////////////////////////////////

static const TCHAR* rgszDiscType [] =
{
    _T("none"),
    _T("unknown"),
    _T("Title"),
    _T("Audio"),
    _T("Video"),
};

int g_nDiscType;

void DiscDrive_Init()
{
    g_cdrom.Open(1);
    g_nDiscType = GetDiscType();
}

////////////////////////////////////////////////////////////////////////////

class CDiscDrive : public CNode
{
    DECLARE_NODE(CDiscDrive, CNode)
public:
    CDiscDrive();
    ~CDiscDrive();

    void Advance(float nSeconds);

    TCHAR* m_discType; // none, unknown, Audio, Video, Photo, Title

    // Audio CD (CDDA) Information...
    int getTrackCount();
    CStrObject* FormatTotalTime();
    CStrObject* FormatTrackTime(int nTrack);

    void LaunchDisc();

#ifdef _CD_INFO
    CStrObject* getArtist();
    CStrObject* getTitle();
    CStrObject* getTrackName(int nTrack);
#endif

    int m_nDiscType;
    bool m_locked;

    DECLARE_NODE_PROPS()
    DECLARE_NODE_FUNCTIONS()

    static CNodeArray c_drives;

private:
    ULONG m_trayState;
    bool m_bDeferNotification;
};

// Events:
//
//  OnDiscInserted
//  OnDiscRemoved

CNodeArray CDiscDrive::c_drives;

IMPLEMENT_NODE("DiscDrive", CDiscDrive, CNode)

START_NODE_PROPS(CDiscDrive, CNode)
    NODE_PROP(pt_string, CDiscDrive, discType)
    NODE_PROP(pt_boolean, CDiscDrive, locked)
END_NODE_PROPS()

START_NODE_FUN(CDiscDrive, CNode)
    NODE_FUN_IV(getTrackCount)
    NODE_FUN_SV(FormatTotalTime)
    NODE_FUN_SI(FormatTrackTime)
    NODE_FUN_VV(LaunchDisc)
#ifdef _CD_INFO
    NODE_FUN_SV(getArtist)
    NODE_FUN_SV(getTitle)
    NODE_FUN_SI(getTrackName)
#endif
END_NODE_FUN()

CDiscDrive::CDiscDrive() :
    m_locked(false),
    m_bDeferNotification(false)
{
    c_drives.AddNode(this);
    AddRef();

    //
    // Mark the disc type to DISC_NONE if it's not a DVD movie (bug 9014)
    // so that Advance will catch change notification and reboot to title.
    // For DVD movies, we have to mark as DISC_VIDEO because the way the
    // dash plays DVD is to reboot. If we let Advance to catch notification
    // the dash will end up reboot infinitely.
    //

    if (theApp.m_bHasLaunchData || g_nDiscType == DISC_VIDEO || g_nDiscType == DISC_BAD)
    {
        m_nDiscType = g_nDiscType;
        HalReadSMCTrayState(&m_trayState, 0);
    }
    else
    {
        m_nDiscType = DISC_NONE;
        m_trayState = SMC_TRAY_STATE_NO_MEDIA;
    }

    const TCHAR* szDiscType = rgszDiscType[m_nDiscType];

    m_discType = new TCHAR [_tcslen(szDiscType) + 1];
    _tcscpy(m_discType, szDiscType);

    TRACE(_T("CDiscDrive: %s\n"), szDiscType);
}

CDiscDrive::~CDiscDrive()
{
    c_drives.RemoveNode(this);
    if (c_drives.GetLength() == 0)
        c_drives.RemoveAll();

    delete [] m_discType;
}

void CDiscDrive::Advance(float nSeconds)
{
    // Check if we need to reboot
    if (m_bDeferNotification && !m_locked)
    {
        m_bDeferNotification = false;
        if (m_nDiscType != DISC_NONE)
            CallFunction(this, _T("OnDiscInserted"));
        else
            CallFunction(this, _T("OnDiscRemoved"));
    }

    static XTIME lastPoll = 0.0f;
    if (XAppGetNow() - lastPoll < 0.04f)
        return;
    lastPoll = XAppGetNow();

    // Poll state of the DVD tray by reading from SMC
    NTSTATUS Status;
    ULONG TrayState;

    Status = HalReadSMCTrayState(&TrayState, NULL);
    if (!NT_SUCCESS(Status)) return;

    if (TrayState == m_trayState) return;
    m_trayState = TrayState;

    // Reset screen saver if tray state changes
    ResetScreenSaver();

    g_nDiscType = GetDiscType();

    if (m_nDiscType != g_nDiscType)
    {
        TRACE(_T("\001Disc type: %s\n"), rgszDiscType[g_nDiscType]);
        m_nDiscType = g_nDiscType;

        delete [] m_discType;
        m_discType = new TCHAR [_tcslen(rgszDiscType[m_nDiscType]) + 1];
        _tcscpy(m_discType, rgszDiscType[m_nDiscType]);

        if (!m_locked)
        {
            if (m_nDiscType != DISC_NONE)
                CallFunction(this, _T("OnDiscInserted"));
            else
                CallFunction(this, _T("OnDiscRemoved"));
        }
        else
        {
            m_bDeferNotification = true;
        }
    }
}

int CDiscDrive::getTrackCount()
{
    if (g_nDiscType == DISC_AUDIO)
        return g_cdrom.GetTrackCount();

    return 0;
}

CStrObject* CDiscDrive::FormatTotalTime()
{
    int nMinutes, nSeconds;
    if (!g_cdrom.GetTotalLength(&nMinutes, &nSeconds, NULL))
        return new CStrObject; // empty string

    TCHAR szBuf [8];
    _stprintf(szBuf, _T("%02d:%02d"), nMinutes, nSeconds);
    return new CStrObject(szBuf);
}

CStrObject* CDiscDrive::FormatTrackTime(int nTrack)
{
    int nMinutes, nSeconds;
    if (!g_cdrom.GetTrackLength(nTrack, &nMinutes, &nSeconds, NULL))
        return new CStrObject; // empty string

    TCHAR szBuf [8];
    _stprintf(szBuf, _T("%02d:%02d"), nMinutes, nSeconds);
    return new CStrObject(szBuf);
}

void CDiscDrive::LaunchDisc()
{
    XAppGetD3DDev()->PersistDisplay();
    ASSERT(g_nDiscType != DISC_AUDIO);
    XLaunchNewImage(g_nDiscType == DISC_TITLE ? "d:\\default.xbe" : NULL, NULL);
}

#ifdef _CD_INFO

CStrObject* CDiscDrive::getArtist()
{
    const TCHAR* szArtist = g_cdrom.GetArtist();
    if (szArtist == NULL)
        szArtist = _T("");
    return new CStrObject(szArtist);
}

CStrObject* CDiscDrive::getTitle()
{
    const TCHAR* szTitle = g_cdrom.GetTitle();
    if (szTitle == NULL)
        szTitle = _T("");
    return new CStrObject(szTitle);
}

CStrObject* CDiscDrive::getTrackName(int nTrack)
{
    const TCHAR* szTrackName = g_cdrom.GetTrackName(nTrack);
    if (szTrackName == NULL)
        szTrackName = _T("");
    return new CStrObject(szTrackName);
}

#endif//_CD_INFO

struct DISCTYPECHECK
{
    TCHAR* szPath;
    TCHAR* szDiscType;
    int nDiscType;
};

static const DISCTYPECHECK rgddc [] =
{
    { _T("CDROM0:\\default.xbe"), _T("Title"), DISC_TITLE },
    { _T("CDROM0:\\video_ts\\video_ts.ifo"), _T("Video"), DISC_VIDEO },
    { _T("CDROM0:\\track01.cda"), _T("Audio"), DISC_AUDIO },
};

int GetDiscType()
{
    int nDiscType = DISC_BAD;
    bool bRetry = true;

    if (g_cdrom.IsOpen())
        g_cdrom.Close();

    OBJECT_STRING DeviceName;
    RtlInitObjectString(&DeviceName, "\\??\\CdRom0:");
    IoDismountVolumeByName(&DeviceName);

    NTSTATUS Status;
    ULONG TrayState;
    Status = HalReadSMCTrayState(&TrayState, NULL);
    if (NT_SUCCESS(Status) && TrayState != SMC_TRAY_STATE_MEDIA_DETECT)
    {
        if (TrayState == SMC_TRAY_STATE_NO_MEDIA)
        {
            HANDLE hDevice;

            // At this point, the drive has told the SMC that media could not be
            // detected.  To decide whether this means that the tray is empty
            // versus the tray have unrecognized media, we need to send an IOCTL
            // to the device.

            hDevice = CreateFileA("cdrom0:", GENERIC_READ, FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

            if (hDevice != NULL)
            {
                BOOL fReturn;
                DWORD cbReturned;

                fReturn = DeviceIoControl(hDevice, IOCTL_CDROM_CHECK_VERIFY,
                    NULL, 0, NULL, 0, &cbReturned, NULL);

                // If the device reports back that the unit is ready (which it
                // shouldn't since the SMC thinks the tray is empty) or if the
                // media is unrecognized, then the disc is bad.
                if (fReturn || (GetLastError() == ERROR_UNRECOGNIZED_MEDIA))
                {
                    CloseHandle(hDevice);
                    return DISC_BAD;
                }

                CloseHandle(hDevice);
            }
        }

        return DISC_NONE;
    }

    g_cdrom.Open(1);

    if (g_cdrom.IsOpen())
        return DISC_AUDIO;

    for (int i = 0; i < sizeof (rgddc) / sizeof (DISCTYPECHECK); )
    {
        if (DoesFileExist(rgddc[i].szPath))
        {
            nDiscType = rgddc[i].nDiscType;
            break;
        }

        DWORD dwError = GetLastError();

        if (dwError != ERROR_FILE_NOT_FOUND && dwError != ERROR_PATH_NOT_FOUND)
        {
            TRACE(_T("\001Error %d on %s\n"), dwError, rgddc[i].szPath);

            if (bRetry)
            {
                TRACE(_T("Retrying...\n"));
                bRetry = false;
                Sleep(100);
                continue;
            }
        }

        i += 1;
        bRetry = true;
    }

    return nDiscType;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\effect.h ===
DWORD dwEffectVertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2fa00ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11510ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x50610ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e700ff8,
	0x00000000, 0x0040001b, 0x25fec86c, 0x2e800ff8,
	0x00000000, 0x00a0001b, 0x7437086c, 0x21900ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0x97ff286c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0xa5ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DynTexture.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Texture.h"
#include "surfx.h"

class CPalette : public CNode
{
	DECLARE_NODE(CPalette, CNode)
public:
	CPalette();
	~CPalette();

	int m_type;
	float m_changePeriod;
	float m_changePeriodRandomness;
	float m_timeToBlend;

	void Advance(float nSeconds);

	const DWORD* GetPalette() { return m_palette; }

#ifdef _XBOX
	D3DPalette* m_pPalette;
#endif

protected:
	void Update();
	void RenderDynamicTexture(CSurfx* pSurfx);

	DWORD m_palette [256];
	int m_nBlendPalette;
	float m_nBlendPaletteAmount;
	XTIME m_nextPaletteChangeTime;
	XTIME m_startBlendTime;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("Palette", CPalette, CNode)

START_NODE_PROPS(CPalette, CNode)
	NODE_PROP(pt_integer, CPalette, type)
	NODE_PROP(pt_number, CPalette, changePeriod)
	NODE_PROP(pt_number, CPalette, changePeriodRandomness)
END_NODE_PROPS()


CPalette::CPalette() :
	m_changePeriod(0.0f),
	m_changePeriodRandomness(0.0f),
	m_timeToBlend(2.0f),
	m_type(0)
{
	m_nextPaletteChangeTime = 0.0f;
	m_nBlendPalette = -1;

#ifdef _XBOX
	m_pPalette = NULL;
#endif
}

CPalette::~CPalette()
{
#ifdef _XBOX
	if (m_pPalette != NULL)
		m_pPalette->Release();
#endif
}

void CPalette::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	XTIME now = XAppGetNow();

	if (m_changePeriod > 0.0f && now > m_nextPaletteChangeTime)
	{
		m_nextPaletteChangeTime = now + m_changePeriod + rnd(m_changePeriodRandomness);
		m_nBlendPalette = m_type;
		m_type += 1;
		m_nBlendPaletteAmount = 0.0f;
		m_startBlendTime = now;

//		TRACE(_T("Palette: change to %d\n"), m_type);
	}

	Update();

	if (m_nBlendPalette != -1)
	{
		m_nBlendPaletteAmount = (float) (now - m_startBlendTime) / m_timeToBlend;
		if (m_nBlendPaletteAmount >= 1.0f)
			m_nBlendPalette = -1;
	}
}

extern void HSV2RGB(float H, float S, float V, DWORD& outRGB);
extern void GetHSV(int nPalette, float i, float t, float& H, float& S, float& V);
extern int g_nPalette;

void CPalette::Update()
{
	XTIME now = XAppGetNow();
	float H, S, V, inc = 1.0f / 255.0f;
	float mIntensity = 0.0f;

	for (int i = 0; i < 256; i++, mIntensity += inc)
	{
		GetHSV(m_type, mIntensity, (float) now, H, S, V);
		m_type = g_nPalette;

		if (m_nBlendPalette != -1)
		{
			float H2, S2, V2;

			// This is the previous palette...
			GetHSV(m_nBlendPalette, mIntensity, (float) now, H2, S2, V2);

			H = m_nBlendPaletteAmount * H + (1.0f - m_nBlendPaletteAmount) * H2;
			S = m_nBlendPaletteAmount * S + (1.0f - m_nBlendPaletteAmount) * S2;
			V = m_nBlendPaletteAmount * V + (1.0f - m_nBlendPaletteAmount) * V2;
		}

		HSV2RGB(H, S, V, m_palette[i]);
	}

#ifdef _XBOX
	if (m_pPalette == NULL)
		VERIFYHR(XAppGetD3DDev()->CreatePalette(D3DPALETTE_256, &m_pPalette));

	D3DCOLOR* rgColor;
	VERIFYHR(m_pPalette->Lock(&rgColor, D3DLOCK_NOOVERWRITE));
	for (i = 0; i < 256; i += 1)
	{
		BYTE r = (BYTE)(m_palette[i] >> 16);
		BYTE g = (BYTE)(m_palette[i] >> 8);
		BYTE b = (BYTE)m_palette[i];
		rgColor[i] = D3DCOLOR_RGBA(r, g, b, 255);
	}

	VERIFYHR(m_pPalette->Unlock());
#endif
}

void CPalette::RenderDynamicTexture(CSurfx* pSurfx)
{
	for (int y = 0; y < pSurfx->m_nHeight; y += 1)
		FillMemory(pSurfx->m_pels + y * pSurfx->m_nWidth, pSurfx->m_nWidth, (BYTE)(y * 256 / pSurfx->m_nHeight));
}

////////////////////////////////////////////////////////////////////////////

class CDynamicTexture : public CTexture
{
	DECLARE_NODE(CDynamicTexture, CTexture)
public:
	CDynamicTexture();
	~CDynamicTexture();

	CNodeArray m_children;
	int m_size;
	bool m_erase;
	float m_fps;
	CNode* m_palette;

	virtual bool Create(int nWidth, int nHeight);

	void Advance(float nSeconds);
	LPDIRECT3DTEXTURE8 GetTextureSurface();

protected:
	void Update();

	CSurfx* m_pSurfx;
	XTIME m_lastUpdateTime;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("DynamicTexture", CDynamicTexture, CTexture)

START_NODE_PROPS(CDynamicTexture, CTexture)
	NODE_PROP(pt_children, CDynamicTexture, children)
	NODE_PROP(pt_integer, CDynamicTexture, size)
	NODE_PROP(pt_boolean, CDynamicTexture, erase)
	NODE_PROP(pt_number, CDynamicTexture, fps)
	NODE_PROP(pt_node, CDynamicTexture, palette)
END_NODE_PROPS()


CDynamicTexture::CDynamicTexture() :
	m_size(256),
	m_erase(true),
	m_fps(15.0f),
	m_palette(NULL)
{
	m_lastUpdateTime = 0.0f;
	m_pSurfx = NULL;

#ifdef _XBOX
	m_format = D3DFMT_P8;
#endif
}

CDynamicTexture::~CDynamicTexture()
{
	if (m_palette != NULL)
		m_palette->Release();

	delete m_pSurfx;
}

bool CDynamicTexture::Create(int nWidth, int nHeight)
{
    D3DLOCKED_RECT d3dlr;

	m_nImageWidth = 512;
	m_nImageHeight = 512;

	if (FAILED(D3DXCreateTexture(XAppGetD3DDev(), m_nImageWidth, m_nImageHeight, 1, 0, m_format, D3DPOOL_MANAGED, &m_pSurface)))
	{
		TRACE(_T("\001CreateTexture(%d,%d) failed!\n"), m_nImageWidth, m_nImageHeight);
		return false;
	}

    m_pSurface->LockRect(0, &d3dlr, NULL, 0);
    memset(d3dlr.pBits, 0, m_nImageWidth * m_nImageHeight);
    m_pSurface->UnlockRect(0);

	XAppGetTextureSize(m_pSurface, m_nImageWidth, m_nImageHeight);

	return true;
}

void CDynamicTexture::Advance(float nSeconds)
{
	CNode::Advance(nSeconds);

	if (m_palette != NULL)
		m_palette->Advance(nSeconds);

	int nChildCount = m_children.GetLength();
	for (int i = 0; i < nChildCount; i += 1)
	{
		CNode* pChildNode = m_children.GetNode(i);
		pChildNode->Advance(nSeconds);
	}
}

LPDIRECT3DTEXTURE8 CDynamicTexture::GetTextureSurface()
{
	if (XAppGetNow() > m_lastUpdateTime + (1.0f / m_fps))
	{
		m_lastUpdateTime = XAppGetNow();
		Update();
	}

#ifdef _XBOX
	if (m_palette != NULL && m_palette->IsKindOf(NODE_CLASS(CPalette)))
	{
		CPalette* pPalette = (CPalette*)m_palette;
		VERIFYHR(XAppGetD3DDev()->SetPalette(0, pPalette->m_pPalette));
	}
#endif

	return m_pSurface;
}

void CDynamicTexture::Update()
{
	if (m_pSurface == NULL && m_size > 0)
	{
		if (!Create(m_size, m_size))
			return;
	}

	if (m_pSurfx == NULL && m_size > 0)
	{
		m_pSurfx = new CSurfx(m_size, m_size);
	}

	if (m_pSurface == NULL || m_pSurfx == NULL || XAppGetNow() < m_lastUpdateTime)
		return;

	if (m_erase)
		ZeroMemory(m_pSurfx->m_pels, m_pSurfx->m_nWidth * m_pSurfx->m_nHeight);

	int nChildCount = m_children.GetLength();
	for (int i = 0; i < nChildCount; i += 1)
	{
		CNode* pChildNode = m_children.GetNode(i);
		pChildNode->RenderDynamicTexture(m_pSurfx);
	}

	// BLOCK: Copy the internal palettized pixmap to our surface...
	{
		const DWORD* rgpe = NULL;

		if (m_palette != NULL)
			rgpe = m_palette->GetPalette();

		DWORD rgpeDefault [256];
		if (rgpe == NULL)
		{
			rgpe = rgpeDefault;
			MakePalette(rgpeDefault);
		}

#ifdef _XBOX // Swizzle the image into the texture

#if 0

        RECT rect = {0, 0, m_size, m_size};
        POINT point = {0, 0};
		D3DLOCKED_RECT lr;
		VERIFYHR(m_pSurface->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));
		XGSwizzleRect(m_pSurfx->m_pels, m_size, &rect, lr.pBits, m_nImageWidth, m_nImageHeight, &point, 1);

		VERIFYHR(m_pSurface->UnlockRect(0));

#else

        Swizzler swz(m_nImageWidth, m_nImageHeight, 1);
        BYTE* pSrc = (BYTE*)m_pSurfx->m_pels;
        BYTE* pDst;
		D3DLOCKED_RECT lr;
		VERIFYHR(m_pSurface->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));
        pDst = (BYTE*)lr.pBits;
        for (int i = 0; i < m_size; i++, swz.IncV()) {
            for (int j = 0; j < m_size; j++, swz.IncU()) {
                pDst[swz.Get2D()] = pSrc[j];
            }
            pSrc += m_size;
            swz.AddU(swz.SwizzleU(m_nImageWidth - m_size));
        }
		VERIFYHR(m_pSurface->UnlockRect(0));

#endif

#else

		D3DLOCKED_RECT lr;
		VERIFYHR(m_pSurface->LockRect(0, &lr, NULL, D3DLOCK_DISCARD));
		DWORD* pDest = (DWORD*)lr.pBits;

		BYTE* pbSrc = (BYTE*)m_pSurfx->m_pels;
		int nPels = m_size * m_size;
		for (int i = 0; i < nPels; i += 1)
		{
			BYTE b = *pbSrc++;
			*pDest++ = 0xff000000 | rgpe[b];
		}
/*
		for (int y = 0; y < m_size; y += 1)
		{
			BYTE* pbDest = (BYTE*)ssd.lpSurface + y * ssd.lPitch;
			BYTE* pbSrc = (BYTE*)m_pSurfx->m_pels + y * m_pSurfx->m_nWidth;

			for (int x = 0; x < m_size; x += 1)
			{
				PALETTEENTRY& pe = rgpe[*pbSrc];
				*pbDest++ = pe.peBlue;
				*pbDest++ = pe.peGreen;
				*pbDest++ = pe.peRed;
				*pbDest++ = 255;
				pbSrc += 1;
			}
		}
*/

		VERIFYHR(m_pSurface->UnlockRect(0));
#endif
	}
}

////////////////////////////////////////////////////////////////////////////


class CImageFader : public CNode
{
	DECLARE_NODE(CImageFader, CNode)
public:
	CImageFader();
	~CImageFader();

	int m_type;
	float m_changePeriod;
	float m_changePeriodRandomness;

	void RenderDynamicTexture(CSurfx* pSurfx);
	bool OnSetProperty(const PRD* pprd, const void* pvValue);

protected:
	DeltaField* m_pDeltaField;
	DeltaField* m_pDeltaField2;
	XTIME m_nextChangeTime;

	DECLARE_NODE_PROPS()
};

IMPLEMENT_NODE("ImageFader", CImageFader, CNode)

START_NODE_PROPS(CImageFader, CNode)
	NODE_PROP(pt_integer, CImageFader, type)
	NODE_PROP(pt_number, CImageFader, changePeriod)
	NODE_PROP(pt_number, CImageFader, changePeriodRandomness)
END_NODE_PROPS()

CImageFader::CImageFader() :
	m_type(0),
	m_changePeriod(0.0f),
	m_changePeriodRandomness(0.0f)
{
	m_nextChangeTime = 0.0f;
	m_pDeltaField = NULL;
	m_pDeltaField2 = NULL;
}

CImageFader::~CImageFader()
{
	delete m_pDeltaField;
	delete m_pDeltaField2;
}

void CImageFader::RenderDynamicTexture(CSurfx* pSurfx)
{
	if (m_pDeltaField == NULL)
	{
		m_pDeltaField = new DeltaField;
		m_pDeltaField->m_nStyle = m_type;
		m_pDeltaField->Assign();
		m_pDeltaField->SetSize(pSurfx->m_nWidth, pSurfx->m_nHeight);

		m_nextChangeTime = XAppGetNow() + m_changePeriod + rnd(m_changePeriodRandomness);
	}
	else if (m_changePeriod > 0.0f && XAppGetNow() >= m_nextChangeTime)
	{
		m_nextChangeTime = XAppGetNow() + m_changePeriod;

		m_type += 1;

		delete m_pDeltaField;
		m_pDeltaField = m_pDeltaField2;
		m_pDeltaField2 = NULL;
	}

	if (m_pDeltaField2 == NULL)
	{
		m_pDeltaField2 = new DeltaField;
		m_pDeltaField2->m_nStyle = m_type + 1;
		m_pDeltaField2->Assign();
		m_pDeltaField2->SetSize(pSurfx->m_nWidth, pSurfx->m_nHeight);
	}

	if (m_pDeltaField->IsCalculating())
	{
		for (int i = 0; i < 10; i += 1)
			m_pDeltaField->CalcSome();
		m_type = m_pDeltaField->m_nStyle; // in case this got fixed up...
		return;
	}

	if (m_pDeltaField2->IsCalculating())
	{
		for (int i = 0; i < 5; i += 1)
		{
			if (m_pDeltaField2 != NULL)
				m_pDeltaField2->CalcSome();
		}
	}

	pSurfx->Fade(m_pDeltaField->GetField());
}

bool CImageFader::OnSetProperty(const PRD* pprd, const void* pvValue)
{
	if ((int)pprd->pbOffset == offsetof(m_type))
	{
		delete m_pDeltaField;
		m_pDeltaField = m_pDeltaField2;
		m_pDeltaField2 = NULL;
	}

	return true;
}


////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\effect3.h ===
DWORD dwEffect3VertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x02a00c1b, 0x3436686c, 0x2140f84c,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2fa00ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11510ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x50610ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e700ff8,
	0x00000000, 0x0040001b, 0x25fec86c, 0x2e800ff8,
	0x00000000, 0x00a0001b, 0x7437086c, 0x21900ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0x97ff286c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0xa5ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\effect4.h ===
DWORD dwEffect4VertexShader[] = {
	0x001d2078,
	0x00000000, 0x00f1001b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00f1201b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00f1401b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00f1601b, 0x0836186c, 0x21200ff8,
	0x00000000, 0x00b1061b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00b1261b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00b1461b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00f1801b, 0x2436186c, 0x20708800,
	0x00000000, 0x00f1a01b, 0x2436186c, 0x20704800,
	0x00000000, 0x00f1c01b, 0x2436186c, 0x20702800,
	0x00000000, 0x00f1e01b, 0x2436186c, 0x20701800,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x00b2261b, 0x0836186c, 0x21800ff8,
	0x00000000, 0x08a0001b, 0x24364bfd, 0x11610ff8,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2f900ff8,
	0x00000000, 0x0040001b, 0x35fe286c, 0x2e500ff8,
	0x00000000, 0x0940001b, 0x86370bfd, 0x91a10ff8,
	0x00000000, 0x008de01b, 0x95ff486c, 0x3070f818,
	0x00000000, 0x0040001b, 0x25fe286c, 0x2e700ff8,
	0x00000000, 0x00a0001b, 0x7436a86c, 0x21b00ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x006000ff, 0xb43613fe, 0xd1000ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x008000ff, 0x0434ac69, 0xde200ff8,
	0x00000000, 0x0072001a, 0x0c361068, 0x9e300ff8,
	0x00000000, 0x00a0001b, 0x3436686c, 0x21400ff8,
	0x00000000, 0x0800001b, 0x083613fd, 0x10110ff8,
	0x00000000, 0x005200ff, 0x15fe186c, 0x21500ff8,
	0x00000000, 0x0092001a, 0x25feabfc, 0x3070e849
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\DSound.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"

#ifndef DSMIXBIN_VALID
#define DSMIXBIN_VALID 0x7FFFFFFF
#endif

extern "C" extern DWORD g_dwDirectSoundOverrideSpeakerConfig;

#ifdef _WINDOWS
#pragma comment(lib, "dxguid.lib")
#define _D3DTYPES_H_
#pragma comment(lib, "dsound.lib")
#endif

#ifdef _XBOX
#include <initguid.h>
#endif

#include <dsound.h>

#include "Sound.h"

static bool DSound_Init();

//
// BUGBUG: copied from disc.cpp
//
#define DISC_VIDEO      4
extern int g_nDiscType;

LPDIRECTSOUND g_pDirectSound = NULL;
HANDLE g_hDirectSoundThread = NULL;

DWORD WINAPI DirectSoundThreadProc(LPVOID pvParameter)
{
    while(g_pDirectSound)
    {
        DirectSoundDoWork();
        Sleep(100);
    }

    return 0;
}

LPDIRECTSOUNDBUFFER XAppCreateSoundBuffer(WAVEFORMATEX* pwfx, int nByteCount, DWORD dwFlags)
{
	if (g_pDirectSound == NULL && !DSound_Init())
		return NULL;

	LPDIRECTSOUNDBUFFER lpDirectSoundBuffer = NULL;
	DSBUFFERDESC dsbd;
	ZeroMemory(&dsbd, sizeof (DSBUFFERDESC));
	dsbd.dwSize = sizeof (DSBUFFERDESC);

	dsbd.dwFlags = dwFlags;
#ifndef _XBOX
	dsbd.dwFlags |= DSBCAPS_GLOBALFOCUS;
#endif
	dsbd.dwBufferBytes = nByteCount;
	dsbd.lpwfxFormat = pwfx;

	HRESULT hr = g_pDirectSound->CreateSoundBuffer(&dsbd, &lpDirectSoundBuffer, NULL);

#ifdef _XBOX

    if(SUCCEEDED(hr))
    {
        lpDirectSoundBuffer->SetHeadroom(1200);
    }

#endif
	
	return lpDirectSoundBuffer;
}

void XAppSetSoundBufferData(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, UINT nByteOffset, UINT nByteCount, const void* pvData)
{
	LPVOID pbBuffer;
	DWORD dwBufferLength;

	ASSERT(pDirectSoundBuffer != NULL);

	VERIFYHR(pDirectSoundBuffer->Lock(nByteOffset, nByteCount, &pbBuffer, &dwBufferLength, NULL, NULL, 0L));

	CopyMemory(pbBuffer, pvData, nByteCount);

	VERIFYHR(pDirectSoundBuffer->Unlock(pbBuffer, dwBufferLength, NULL, 0));
}

void XAppSetSoundBufferNotify(LPDIRECTSOUNDBUFFER pDirectSoundBuffer, int nPositionCount, DSBPOSITIONNOTIFY* positions)
{
#ifdef _XBOX
	pDirectSoundBuffer->SetNotificationPositions(nPositionCount, positions);
#else
	LPDIRECTSOUNDNOTIFY pDSNotify;
	VERIFYHR(pDirectSoundBuffer->QueryInterface(IID_IDirectSoundNotify, (void**)&pDSNotify));
	VERIFYHR(pDSNotify->SetNotificationPositions(nPositionCount, positions));
	VERIFYHR(pDSNotify->Release());
#endif
}

static bool DSound_Init()
{
	HRESULT hr;

	TRACE(_T("Initializing DirectSound...\n"));
	ASSERT(g_pDirectSound == NULL);

	//
	// BUGBUG: remove this hack to prevent dsound from initializing when we're playing a DVD
	//
	if (DISC_VIDEO == g_nDiscType)
	{
		//LogComError(E_FAIL, "DSound_Init: Not initializing with DVD-Video disc in drive");
		return false;
	}

#ifdef _XBOX

    DWORD dwSpeakerConfig = XAudioGetSpeakerConfig();

    if(DSSPEAKER_MONO == DSSPEAKER_BASIC(dwSpeakerConfig))
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_MONO, 0);
    }
    else
    {
        g_dwDirectSoundOverrideSpeakerConfig = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, 0);
    }

#endif

	if (FAILED(hr = DirectSoundCreate(NULL, &g_pDirectSound, NULL)))
	{
		LogComError(hr, "DSound_Init: DirectSoundCreate");
		return false;
	}

    if (FAILED(hr = g_pDirectSound->SetMixBinHeadroom(DSMIXBIN_VALID, 0)))
    {
		LogComError(hr, "DSound_Init: SetMixBinHeadroom");
	}

#ifdef _XBOX

    DWORD dwThreadId;
    g_hDirectSoundThread = CreateThread(NULL, 0, DirectSoundThreadProc, NULL, 0, &dwThreadId);
    if (!g_hDirectSoundThread)
    {
		LogComError(hr, "DSound_Init: failed to create DirectSound worker thread");
		return false;
	}

#else

	ASSERT(theApp.m_hWnd != NULL);
	if (FAILED(hr = g_pDirectSound->SetCooperativeLevel(theApp.m_hWnd, DSSCL_PRIORITY)))
	{
		LogComError(hr, "DSound_Init: SetCooperativeLevel");
		// Not fatal!
	}

	DSBUFFERDESC dsbdesc;
	dsbdesc.dwSize = sizeof (dsbdesc);
	dsbdesc.dwFlags = DSBCAPS_PRIMARYBUFFER | DSBCAPS_GLOBALFOCUS;
	dsbdesc.dwBufferBytes = 0;
	dsbdesc.dwReserved = 0;
	dsbdesc.lpwfxFormat = NULL;
	dsbdesc.guid3DAlgorithm = GUID_NULL;

	LPDIRECTSOUNDBUFFER pDSBPrimary;
	if (FAILED(hr = g_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
	{
		TRACE(_T("\002CreateSoundBuffer with DSBCAPS_GLOBALFOCUS failed, trying without...\n"));
		dsbdesc.dwFlags &= ~DSBCAPS_GLOBALFOCUS;
		if (FAILED(hr = g_pDirectSound->CreateSoundBuffer(&dsbdesc, &pDSBPrimary, NULL)))
		{
			LogComError(hr, "DSound_Init: CreateSoundBuffer");
			return false;
		}
	}

	WAVEFORMATEX wfx;
	ZeroMemory(&wfx, sizeof(WAVEFORMATEX));
	wfx.wFormatTag = WAVE_FORMAT_PCM;
	wfx.nChannels = 2;
	wfx.nSamplesPerSec = 44100;
	wfx.wBitsPerSample = 16;
	wfx.nBlockAlign = wfx.wBitsPerSample / 8 * wfx.nChannels;
	wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;

	TRACE(_T("SetFormat..."));
	if (FAILED(hr = pDSBPrimary->SetFormat(&wfx)))
		LogComError(hr, "DSound_Init: SetFormat");

	pDSBPrimary->Release();
#endif

	return true;
}

void DSound_Exit()
{
	if (g_pDirectSound != NULL)
    {
		g_pDirectSound->Release();
        g_pDirectSound = NULL;
    }

    if (g_hDirectSoundThread != NULL)
    {
        CloseHandle(g_hDirectSoundThread);
    }
}

void DSound_Frame()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\effect2.h ===
DWORD dwEffect2VertexShader[] = {
	0x00152078,
	0x00000000, 0x00ec001b, 0x0836186c, 0x20708800,
	0x00000000, 0x00ed401b, 0x0836186c, 0x28200ff8,
	0x00000000, 0x00aca61b, 0x0836186c, 0x28300ff8,
	0x00000000, 0x00ec201b, 0x0836186c, 0x20704800,
	0x00000000, 0x00ed601b, 0x0836186c, 0x24200ff8,
	0x00000000, 0x00acc61b, 0x0836186c, 0x24300ff8,
	0x00000000, 0x00ec401b, 0x0836186c, 0x20702800,
	0x00000000, 0x00ed801b, 0x0836186c, 0x22200ff8,
	0x00000000, 0x00ace61b, 0x0836186c, 0x22300ff8,
	0x00000000, 0x00ec601b, 0x0836186c, 0x20701800,
	0x00000000, 0x02a00e18, 0x3430686c, 0x2140f84c,
	0x00000000, 0x002e001b, 0x0c36106c, 0x2fa00ff8,
	0x00000000, 0x08a00018, 0x24304bfd, 0x11510ff8,
	0x00000000, 0x0647401b, 0xc4361bff, 0x1078e800,
	0x00000000, 0x0800001b, 0x083613fd, 0x50610ff8,
	0x00000000, 0x00400018, 0x35fe286c, 0x2e700ff8,
	0x00000000, 0x00400018, 0x25fec86c, 0x2e800ff8,
	0x00000000, 0x00a00018, 0x7431086c, 0x21900ff8,
	0x00000000, 0x0087601b, 0xc400286c, 0x3070e800,
	0x00000000, 0x014000ff, 0x97ff286c, 0x21b00ff8,
	0x00000000, 0x008de01b, 0xa5ff686c, 0x3070f819
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\dvd2.cpp ===
/*
    Base DVD Functionality
    ----------------------
    0-9
    Return
    Repeat
    Repeat A-B
    Scan Forward/Backward
    Skip Forward/Backward
    Stop
    Play/Pause
    Left, Right, Up, Down
    Enter
    Menu
    Top Menu
    Step
    Audio
    Subtitle
    Angle

    Extra DVD Functionality
    -----------------------
    Play Backwards
    Play Fast/Slow
    Zoom/Pan
    Bookmarks

    Resume Function

      When you press stop, the player should remember where you were and
      resume from that position when you press play again. Pressing Stop
      twice clears the memory.

    Auto Stop

      When the player is left in Pause mode for five minutes, it will Stop.

    Screen Save

      Stop mode enables the screen saver; all other modes disable it.

    Step will auto pause.

    Fast Scanning

      The Scan buttons cycle between 2x, 4x, 8x, 16x, and 32x normal speed.

    Slow Motion Playback

      In Pause mode, the Forward and Reverse Scan buttons may be used to
      cycle between 1/2, 1/4, and 1/8 normal speed.

    Skipping

      The Back button moves to the start of a chapter. One more press moves
      to the start of the previous chapter.
*/

#include "std.h"

#include "xapp.h"
#include "Node.h"
#include "Date.h"
#include "Runner.h"
#include "Locale.h"

#define XDASH_COLORKEY  D3DCOLOR_XRGB(0, 0, 1)
#define MKLANG(c, d)    (((WORD)c << 8) | (WORD)d)

//#include "../../dvd/Apps/xbDVD/INC/dvdcpl32.h"
// dvdcpl32.h has a lot of extra stuff including a bunch of warnings and a
// few errors, so we use a modified local version here...
#include "Ravisent.h"
#include "dvdlib.h"

//#include "../../dvd/Apps/xbDVD/INC/dvdpld32.h"
// dvdpld32.h pulls in a lot of stuff and causes lots of warnings and errors,
// all we use is the definition of Error, so here it is...
typedef unsigned long Error;

#ifdef _DEBUG
extern void DumpHex(const BYTE* pbData, int cbData, int cbMax=0);
#endif

extern const TCHAR* LanguageNameFromCode(WORD code);

#ifdef _DEBUG
static void LogDvdError(const TCHAR* szFile, int nLine, Error error);
#define VERIFYDVD(f) do { Error errverify = (f); if (IS_GNERROR(errverify)) LogDvdError(_T(__FILE__), __LINE__, errverify); } while (0)
#else
#define VERIFYDVD(f) ((void)(f))
#endif

#ifdef _DEBUG
static const TCHAR* rgszDisplayPresentationMode [] =
{
    _T("DPM_4BY3"),
    _T("DPM_16BY9"),
    _T("DPM_LETTERBOXED"),
    _T("DPM_PANSCAN"),
    _T("DPM_NONE")
};
#endif

////////////////////////////////////////////////////////////////////////////

#define EVENTS_STORED 10

struct DVDEVENT
{
    DWORD event;
    DWORD info;
};


#define AB_DISABLED 0
#define AB_SETTING_B 1
#define AB_REPEATING 2

#define AUTOSTOP_TIMEOUT (5.0f * 60.0f)

//
// Minimum interval in milliseconds of a AB repeat video
//

#define MIN_REPEAT_AB_INTERVAL (1 * 1000)

//
// CDVDBookmark
// Useful wrapper to store the DVD frozen state used on DDP_Freeze, DDP_Defrost
//

class CDVDPlayer;

class CDVDBookmark
{
public:

    //
    // CDVDBookmark
    // constructor
    //
    CDVDBookmark()
    {
        //
        // Initially, when we will probe DDP_Freeze for the buffer size,
        // we can't pass NULL as the buffer (or so says the sample). Therefore
        // our initial buffer will be one byte long instead of NULL
        //
        m_pStateBuffer = m_rgOneByteBuffer;
        m_cbStateBuffer = sizeof(m_rgOneByteBuffer);
        m_bSet = false;
    }

    //
    // ~CDVDBookmark
    // destructor
    //
    ~CDVDBookmark()
    {
        if(m_pStateBuffer != m_rgOneByteBuffer)
        {
            delete [] m_pStateBuffer;
        }
    }

    //
    // IsSet
    // Returns if the bookmark is currently set or not
    //
    bool IsSet()
    {
        return m_bSet;
    }

    //
    // Reset
    // Mark bookmark as not set (or not valid)
    //
    void Reset()
    {
        m_bSet = false;
    }

    //
    // Alloc
    // Allocate/Expand buffer
    //
    bool Alloc(
        DWORD cbStateBufferSize
    )
    {
        bool bRet = true;

        m_bSet = false;

        //
        // Current buffer big enough?
        //

        if(m_cbStateBuffer < cbStateBufferSize)
        {
            //
            // Apparently not. Allocate new buffer
            //

            BYTE* pNewBuffer = new BYTE[cbStateBufferSize];

            if(pNewBuffer)
            {
                //
                // Success. Make it the new official buffer.
                //

                if(m_pStateBuffer != m_rgOneByteBuffer)
                {
                    delete [] m_pStateBuffer;
                }

                m_pStateBuffer = pNewBuffer;
                pNewBuffer = NULL;

                m_cbStateBuffer = cbStateBufferSize;
            }
            else
            {
                //
                // Out of memory
                //

                bRet = false;
            }
        }

        return bRet;
    }

    //
    // GetSize
    // Return current allocated size
    //
    DWORD GetSize()
    {
        return m_cbStateBuffer;
    }

    //
    // GetBuffer
    // Return pointer to allocated buffer
    //
    BYTE* GetBuffer()
    {
        return m_pStateBuffer;
    }

    //
    // Set
    // Mark the bookmark as set (or valid)
    //
    void Set()
    {
        m_bSet = true;
    }

    BYTE* m_pStateBuffer;
    BYTE m_rgOneByteBuffer[1];
    DWORD m_cbStateBuffer;
    bool m_bSet;
};


class CDVDPlayer : public CNode
{
    DECLARE_NODE(CDVDPlayer, CNode)
public:
    CDVDPlayer();
    ~CDVDPlayer();

    bool OnSetProperty(const PRD* pprd, const void* pvValue);

    void init();
    void cleanup();

    bool m_bStillOn;
    bool m_bMenuOn;
    bool m_autoStop;

    float m_speed;
    bool m_closedCaption;
    int m_subTitle;
    int m_title;
    int m_chapter;

    int m_hours;
    int m_minutes;
    int m_seconds;
    int m_frames;

    int m_videoModePreferrence; // 0=title default, 1=16x9, 2=4x3/panscan, 3=4x3/letterbox
    int m_parentalLevel; // 1=G, 3=PG, 4=PG13, 6=R, 7=NC17
    int m_audioStream;
    int m_angle;
    int m_angleCount;

    int m_videoWidth;
    int m_videoHeight;

    int m_left;
    int m_top;
    int m_width;
    int m_height;

    // Player State (updated by events)
    DVDPlayerMode m_playbackMode;
    DVDDomain m_domain;

    DVDAudioCodingMode m_audioFormat;
    int m_audioChannels;
    WORD m_audioLanguageCode;
    TCHAR* m_audioLanguage;
    TCHAR* m_subTitleLanguage;
    WORD m_subTitleLanguageCode;

    int m_scanSpeed;
    bool m_scanSlow;

    void goUp();
    void play();
    void stop();
    void pause();
    void playOrPause();

    void selectUp();
    void selectDown();
    void selectLeft();
    void selectRight();
    void activate();

    void nextAudioStream();
    void nextAngle();

    void startChapter();
    void nextChapter();
    void prevChapter();

    void frameAdvance();
    void frameReverse();

    void menu();
    void titleMenu();

    void nextSubtitle();

    void forwardScan();
    void backwardScan();
    void stopScan();

    void eject();

    void setScale(float nScale);
    void setZoomPos(float x, float y);

    void digit(int nDigit);

    int isPlaybackDomain();
    int isUOPValid(int nUOP);

    void abRepeat();
    int m_abRepeatState;
    int m_number;

    void refreshAudioSettings();

    void enableWideScreen();
    void disableWideScreen();

    void Advance(float nSeconds);
    void Render();

private:
    Error CheckUserOp(Error e);
    void UpdateZoom();
    void OnSubPictureStreamChange();
    Error SetBookmark(CDVDBookmark* pBookmark);
    Error GotoBookmark(CDVDBookmark* pBookmark);
//  void OnAudioStreamChange();

    bool m_bResetPosSize;
    XTIME m_timeToStop;

    XTIME m_numberTime;
    XTIME m_prevChapterTime;

    DVDLocation m_stopLocation;

    DVDLocation m_locationA;
    DVDLocation m_locationB;

    CDVDBookmark m_StopBookmark;
    CDVDBookmark m_LocationABookmark;

    // Player Library
    VDRHandle m_hvdr;
    UnitSet m_hUnitSet;
    DVDDiskPlayer m_hPlayer;

    // Event Queue
    static void __stdcall EventHandler(DWORD event, void* userData, DWORD info);
    void InstallEventHandlers();
    void RemoveEventHandlers();
    void ProcessEvents();
    bool GetNextEvent(DWORD& event, DWORD& info);
    DVDEVENT m_events [EVENTS_STORED];
    int m_eventRead;
    int m_eventWrite;
    CRITICAL_SECTION m_eventLock;

    // Zooming and Panning
    XTIME m_nZoomTime;
    float m_nScale;
    float m_nOffsetX;
    float m_nOffsetY;
    float m_nScaleStart;
    float m_nOffsetXStart;
    float m_nOffsetYStart;
    float m_nScaleSet;
    float m_nOffsetXSet;
    float m_nOffsetYSet;

    // Scanning
    bool m_bScanBackward;

    // Flag indicating that parental control is too low
    bool m_parentalTooLow;
    bool m_parentalPopup;

    LPDIRECT3DVERTEXBUFFER8 m_pVB;

    DECLARE_NODE_FUNCTIONS()

    DECLARE_NODE_PROPS()
};

CDVDPlayer* g_pDVDPlayer = NULL;

IMPLEMENT_NODE("DVDPlayer", CDVDPlayer, CNode)

START_NODE_PROPS(CDVDPlayer, CNode)
    NODE_PROP(pt_number, CDVDPlayer, speed)
    NODE_PROP(pt_integer, CDVDPlayer, title)
    NODE_PROP(pt_integer, CDVDPlayer, chapter)
    NODE_PROP(pt_integer, CDVDPlayer, hours)
    NODE_PROP(pt_integer, CDVDPlayer, minutes)
    NODE_PROP(pt_integer, CDVDPlayer, seconds)
    NODE_PROP(pt_integer, CDVDPlayer, frames)
    NODE_PROP(pt_integer, CDVDPlayer, videoModePreferrence)
    NODE_PROP(pt_integer, CDVDPlayer, parentalLevel)
    NODE_PROP(pt_integer, CDVDPlayer, audioStream)
    NODE_PROP(pt_integer, CDVDPlayer, left)
    NODE_PROP(pt_integer, CDVDPlayer, top)
    NODE_PROP(pt_integer, CDVDPlayer, width)
    NODE_PROP(pt_integer, CDVDPlayer, height)
    NODE_PROP(pt_boolean, CDVDPlayer, closedCaption)
    NODE_PROP(pt_integer, CDVDPlayer, subTitle)
    NODE_PROP(pt_integer, CDVDPlayer, domain)
    NODE_PROP(pt_integer, CDVDPlayer, angle)
    NODE_PROP(pt_integer, CDVDPlayer, angleCount)
    NODE_PROP(pt_integer, CDVDPlayer, playbackMode)
    NODE_PROP(pt_integer, CDVDPlayer, audioFormat)
    NODE_PROP(pt_integer, CDVDPlayer, audioChannels)
    NODE_PROP(pt_string, CDVDPlayer, audioLanguage)
    NODE_PROP(pt_string, CDVDPlayer, subTitleLanguage)
    NODE_PROP(pt_integer, CDVDPlayer, abRepeatState)
    NODE_PROP(pt_integer, CDVDPlayer, number)
    NODE_PROP(pt_integer, CDVDPlayer, scanSpeed)
    NODE_PROP(pt_boolean, CDVDPlayer, scanSlow)
    NODE_PROP(pt_boolean, CDVDPlayer, autoStop)
    NODE_PROP(pt_boolean, CDVDPlayer, bScanBackward)
END_NODE_PROPS()

START_NODE_FUN(CDVDPlayer, CNode)
    NODE_FUN_VV(init)
    NODE_FUN_VV(play)
    NODE_FUN_VV(stop)
    NODE_FUN_VV(goUp)
    NODE_FUN_VV(pause)
    NODE_FUN_VV(playOrPause)
    NODE_FUN_VV(selectUp)
    NODE_FUN_VV(selectDown)
    NODE_FUN_VV(selectRight)
    NODE_FUN_VV(selectLeft)
    NODE_FUN_VV(activate)
    NODE_FUN_VV(nextAudioStream)
    NODE_FUN_VV(nextAngle)
    NODE_FUN_VV(startChapter)
    NODE_FUN_VV(nextChapter)
    NODE_FUN_VV(prevChapter)
    NODE_FUN_VV(menu)
    NODE_FUN_VV(titleMenu)
    NODE_FUN_VV(nextSubtitle)
    NODE_FUN_VV(forwardScan)
    NODE_FUN_VV(backwardScan)
    NODE_FUN_VV(stopScan)
    NODE_FUN_VV(eject)
    NODE_FUN_VN(setScale)
    NODE_FUN_VNN(setZoomPos)
    NODE_FUN_VV(frameAdvance)
    NODE_FUN_VV(frameReverse)
    NODE_FUN_II(isUOPValid)
    NODE_FUN_VV(abRepeat)
    NODE_FUN_VI(digit)
    NODE_FUN_VV(refreshAudioSettings)
    NODE_FUN_IV(isPlaybackDomain)
    NODE_FUN_VV(enableWideScreen)
    NODE_FUN_VV(disableWideScreen)
END_NODE_FUN()

CDVDPlayer::CDVDPlayer() :
    m_autoStop(true),
    m_speed(1.0f),
    m_closedCaption(false),
    m_parentalTooLow(false),
    m_parentalPopup(false),
    m_subTitle(0),
    m_title(0),
    m_chapter(0),
    m_hours(0),
    m_minutes(0),
    m_seconds(0),
    m_frames(0),
    m_videoModePreferrence(0),
    m_parentalLevel(8),
    m_audioStream(0),
    m_angle(1),
    m_angleCount(1),
    m_left(0),
    m_top(0),
    m_width(0),
    m_height(0),
    m_videoWidth(0),
    m_videoHeight(0),
    m_audioFormat(DAM_AC3),
    m_audioChannels(0),
    m_audioLanguage(NULL),
    m_audioLanguageCode(0),
    m_subTitleLanguage(NULL),
    m_subTitleLanguageCode(0),
    m_abRepeatState(AB_DISABLED)
{
    m_hvdr = NULL;
    m_hUnitSet = NULL;
    m_hPlayer = NULL;
    m_playbackMode = DPM_STOPPED;
    m_domain = STOP_DOM;
    m_bResetPosSize = true;

    m_nScale = 1.0f;
    m_nOffsetX = 0.0f;
    m_nOffsetY = 0.0f;
    m_timeToStop = 0.0f;
    m_bScanBackward = false;
    m_scanSlow = false;
    m_scanSpeed = 1;

    m_pVB = NULL;
    m_nZoomTime = 0.0f;
    m_nScaleSet = 1.0f;
    m_nOffsetXSet = 0.0f;
    m_nOffsetYSet = 0.0f;

    m_number = 0;
    m_numberTime = 0.0f;
    m_prevChapterTime = 0.0f;

    ZeroMemory(&m_locationA, sizeof (m_locationA));
    ZeroMemory(&m_locationB, sizeof (m_locationB));

    ZeroMemory(&m_stopLocation, sizeof (m_stopLocation));
}

CDVDPlayer::~CDVDPlayer()
{
    delete [] m_audioLanguage;
    delete [] m_subTitleLanguage;

    cleanup();

    if (m_pVB != NULL)
        m_pVB->Release();
}

bool CDVDPlayer::OnSetProperty(const PRD* pprd, const void* pvValue)
{
    if (m_hPlayer != NULL)
    {
        if ((int)pprd->pbOffset == offsetof(m_videoModePreferrence))
        {
            int n = *(int*)pvValue;
            DisplayPresentationMode dpm = DPM_4BY3;
            switch (n)
            {
            case 0:
                dpm = DPM_PANSCAN;
                break;

            case 1:
                dpm = DPM_LETTERBOXED;
                break;

            case 2:
                dpm = DPM_16BY9;
                break;
            }

            DDP_SetDisplayMode(m_hPlayer, dpm);
        }
        else if ((int)pprd->pbOffset == offsetof(m_closedCaption))
        {
            BOOL b = *(bool*)pvValue ? TRUE : FALSE;
            VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_CC_ENABLE(b), TAGDONE);
        }
        else if ((int)pprd->pbOffset == offsetof(m_angle))
        {
            int n = *(int*)pvValue;
            if (IS_ERROR(DDP_AngleChange(m_hPlayer, (WORD)n)))
                return false;
        }
        else if ((int)pprd->pbOffset == offsetof(m_left) ||
            (int)pprd->pbOffset == offsetof(m_top) ||
            (int)pprd->pbOffset == offsetof(m_width) ||
            (int)pprd->pbOffset == offsetof(m_height))
        {
            m_bResetPosSize = true;
        }
        else if ((int)pprd->pbOffset == offsetof(m_speed))
        {
            float speed = *(float*)pvValue; // NOTE: Should be <= 2
            DDP_SetPlaybackSpeed(m_hPlayer, (int)(speed * 1000.0f));
        }
        else if ((int)pprd->pbOffset == offsetof(m_autoStop))
        {
            m_autoStop = *(bool*)pvValue ? true : false;

            // Refresh the auto stop timer
            if (m_autoStop && m_playbackMode == DPM_PAUSED)
                m_timeToStop = XAppGetNow() + AUTOSTOP_TIMEOUT;
        }
        else if ((int)pprd->pbOffset == offsetof(m_parentalLevel))
        {
            m_parentalLevel = *(int*)pvValue + 1; // offset by one since we start from zero
            return false;
        }
        else if ((int)pprd->pbOffset == offsetof(m_visible))
        {
            D3DDevice_SetFlickerFilter(*(bool*)pvValue ? 0 : 5);
        }

        // Update playback mode, changing some properties might have changed the playback mode
        m_playbackMode = DDP_GetPlayerMode(m_hPlayer);
    }

    return CNode::OnSetProperty(pprd, pvValue);
}

struct DVDVERTEX
{
    float x, y, z;
};

extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matProjection;
extern D3DXMATRIX g_matIdentity;

int DVDTime::Compare(const DVDTime u) const
{
    return stamp - u.stamp;
}


void CDVDPlayer::Render()
{
    if (m_videoWidth > 0 && m_videoHeight > 0)
    {
        if (m_pVB == NULL)
            VERIFYHR(XAppGetD3DDev()->CreateVertexBuffer(4 * sizeof(DVDVERTEX), D3DUSAGE_WRITEONLY, D3DFVF_XYZ, D3DPOOL_MANAGED, &m_pVB));

        int width = m_width == 0 ? m_videoWidth : m_width;
        int height = m_height == 0 ? m_videoHeight : (m_height - 1);

        DVDVERTEX* v;
        VERIFYHR(m_pVB->Lock(0, 4 * sizeof (DVDVERTEX), (BYTE**)&v, 0));
        v[0].x = m_left + width - theApp.m_nViewWidth / 2.0f;
        v[0].y = -(m_top + height - theApp.m_nViewHeight / 2.0f);
        v[0].z = 0.0f;
        v[1].x = m_left - theApp.m_nViewWidth / 2.0f;
        v[1].y = -(m_top + height - theApp.m_nViewHeight / 2.0f);
        v[1].z = 0.0f;
        v[2].x = m_left + width - theApp.m_nViewWidth / 2.0f;
        v[2].y = -(m_top - theApp.m_nViewHeight / 2.0f);
        v[2].z = 0.0f;
        v[3].x = m_left - theApp.m_nViewWidth / 2.0f;
        v[3].y = -(m_top - theApp.m_nViewHeight / 2.0f);
        v[3].z = 0.0f;
        VERIFYHR(m_pVB->Unlock());

        XAppSetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
        XAppSetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TFACTOR);
        XAppSetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_DISABLE);
        XAppSetRenderState(D3DRS_TEXTUREFACTOR, XDASH_COLORKEY);
        XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

        VERIFYHR(XAppGetD3DDev()->SetStreamSource(0, m_pVB, sizeof (DVDVERTEX)));
        VERIFYHR(XAppGetD3DDev()->SetVertexShader(D3DFVF_XYZ));
        VERIFYHR(XAppGetD3DDev()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2));

        XAppSetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
    }
}

void CDVDPlayer::Advance(float nSeconds)
{

    if (m_hPlayer != NULL)
    {
        ASSERT(m_hUnitSet != NULL);

        if (m_width <= 0 || m_height <= 0)
        {
            m_width = (int)theApp.m_nViewWidth;
            m_height = (int)theApp.m_nViewHeight;
        }

    //if (m_number != 0/* || m_numberTime > 0.0f*/)
    //  TRACE(_T("  %f: %d\n"), (XAppGetNow() - m_numberTime), m_number);

        if (m_numberTime > 0.0f && (XAppGetNow() - m_numberTime) >= 5.0f)
        {
            TRACE(_T("Auto activate number...\n"));
            activate();
        }

        if (m_timeToStop != 0.0f && XAppGetNow() >= m_timeToStop && m_autoStop)
        {
            if (m_playbackMode == DPM_PAUSED)
                stop();
            m_timeToStop = 0.0f;
        }

        if (m_playbackMode != DPM_STOPPED && m_playbackMode != DPM_INACTIVE && m_autoStop)
            ResetScreenSaver();

        // BLOCK: Check playback mode...
        {
            DVDPlayerMode playbackMode = DDP_GetPlayerMode(m_hPlayer);
            if (m_playbackMode != playbackMode)
            {
                m_playbackMode = playbackMode;

                if (m_playbackMode == DPM_PAUSED)
                    m_timeToStop = XAppGetNow() + AUTOSTOP_TIMEOUT;
                else
                    m_timeToStop = 0.0f;

                CallFunction(this, _T("OnPlaybackModeChange"));
            }

            VDR_EnablePIP(m_hUnitSet, m_playbackMode != DPM_STOPPED);
        }

        // BLOCK: Update position and check for A-B repeat
        {
            DVDLocation loc;
            VERIFYDVD(DDP_GetCurrentLocation(m_hPlayer, loc));

            if (m_abRepeatState == AB_REPEATING && (m_playbackMode == DPM_PLAYING || m_playbackMode == DPM_SCANNING))
            {
                if (loc.title >= m_locationB.title && loc.titleTime >= m_locationB.titleTime)
                {
                    TRACE(_T("Hit B; going to A...\n"));
                    GotoBookmark(&m_LocationABookmark);

                    //
                    // GotoBookmark failing or not, the position should be different.
                    // Read it again.
                    //

                    VERIFYDVD(DDP_GetCurrentLocation(m_hPlayer, loc));
                }
            }

            if (m_domain != loc.domain)
            {
                m_domain = loc.domain;

                //
                // Reset our internal state variables. We need to do this to prevent
                // bogus state when you go to the menu during a fast forward, slow scan, etc...
                //

                m_bScanBackward = false;
                m_scanSpeed = 1;
                m_scanSlow = false;

                CallFunction(this, _T("OnDomainChange"));
            }

            if (m_title != loc.title)
            {
                m_title = loc.title;
                CallFunction(this, _T("OnTitleChange"));
            }

            if (m_chapter != loc.partOfTitle)
            {
                m_chapter = loc.partOfTitle;
                CallFunction(this, _T("OnChapterChange"));
            }

            int hours = loc.titleTime.Hours();
            int minutes = loc.titleTime.Minutes();
            int seconds = loc.titleTime.Seconds();
            m_frames = loc.titleTime.Frames();

            if (hours != m_hours || minutes != m_minutes || seconds != m_seconds)
            {
                m_hours = hours;
                m_minutes = minutes;
                m_seconds = seconds;
                CallFunction(this, _T("OnTimeChange"));
            }
        }

        // BLOCK: Angle info...
        {
            int angleCount = DDP_GetNumberOfAngles(m_hPlayer, (WORD)m_title);
            int angle = DDP_GetCurrentAngle(m_hPlayer);

            if (angleCount == 0)
            {
                angleCount = 1;
            }

            if(angle > angleCount)
            {
                // there is this strange behavior when you switch domains, the
                // angle count returned is always 1 and the current angle remains
                // the same resulting into something like angle 3 of 1. This is
                // a hack to prevent that.

                angle = 1;
            }

            if (m_angleCount != angleCount || m_angle != angle)
            {
                m_angleCount = angleCount;
                m_angle = angle;
                CallFunction(this, _T("OnAngleChange"));
            }
        }

        // BLOCK: Update audio info...
        {
            bool bChange = false;

            int audioStream = DDP_GetCurrentAudioStream(m_hPlayer);
            if (m_audioStream != audioStream)
            {
                m_audioStream = audioStream;
                bChange = true;
            }

            DVDAudioStreamFormat format;
            VERIFYDVD(DDP_GetAudioStreamAttributes(m_hPlayer, (WORD)m_audioStream, format));

            if (m_audioFormat != format.codingMode || m_audioChannels != format.channels)
            {
                m_audioFormat = format.codingMode;
                m_audioChannels = format.channels;
                bChange = true;
            }

            if (m_audioLanguageCode != format.languageCode)
            {
                m_audioLanguageCode = format.languageCode;
                bChange = true;

                const TCHAR* sz = LanguageNameFromCode(m_audioLanguageCode);

                delete [] m_audioLanguage;
                m_audioLanguage = NULL;

                if (sz != NULL)
                {
                    TCHAR buffer[MAX_TRANSLATE_LEN];
                    lstrcpy(buffer, _T("Lang "));
                    lstrcat(buffer, sz);
                    m_audioLanguage = new TCHAR [MAX_TRANSLATE_LEN];
                    Translate(buffer, m_audioLanguage);
                }
            }

            if (bChange)
            {
                TRACE(_T("Audio Changed:\n"));
                TRACE(_T("\tstream: %d\n"), m_audioStream);
                TRACE(_T("\tformat: %d\n"), m_audioFormat);
                TRACE(_T("\tchannels: %d\n"), m_audioChannels);
                TRACE(_T("\tlanguage: 0x%04x %s\n"), m_audioLanguageCode, m_audioLanguage == NULL ? _T("UNKNOWN") : m_audioLanguage);
//              TRACE(_T("\tapplication mode: %d\n"), format.applicationMode);
                TRACE(_T("\tbits per sample: %d\n"), format.bitsPerSample);
                TRACE(_T("\tsamples per second: %d\n"), format.samplesPerSecond);

                CallFunction(this, _T("OnAudioChange"));
            }
        }

        // BLOCK: Update sub-title info...
        {
            int subTitle = 0;
            if (DDP_IsCurrentSubPictureEnabled(m_hPlayer) && m_domain == TT_DOM)
                subTitle = DDP_GetCurrentSubPictureStream(m_hPlayer) + 1;

            if (m_subTitle != subTitle)
            {
                m_subTitle = subTitle;
                OnSubPictureStreamChange();
                CallFunction(this, _T("OnSubTitleChange"));
            }
        }

        // BLOCK: Update video size...
        {
            unsigned short videoWidth, videoHeight;
            VDR_ConfigureUnitsTags(m_hUnitSet,
                GET_MPEG_DISPLAY_WIDTH(videoWidth),
                GET_MPEG_DISPLAY_HEIGHT(videoHeight),
                TAGDONE);

            if (videoWidth != m_videoWidth || videoHeight != m_videoHeight)
            {
                m_videoWidth = videoWidth;
                m_videoHeight = videoHeight;
                TRACE(_T("DVD: video size: %dx%d\n"), m_videoWidth, m_videoHeight);
                CallFunction(this, _T("OnVideoSizeChange"));
            }
        }

        // BLOCK: Update scale and position
        {
            if (m_nZoomTime != 0.0f)
            {
                float t = (float) (XAppGetNow() - m_nZoomTime) / 0.5f;
                if (t >= 1.0f)
                {
                    m_nZoomTime = 0.0f;
                    m_nScaleStart = m_nScaleSet = m_nScale;
                    m_nOffsetXStart = m_nOffsetXSet = m_nOffsetX;
                    m_nOffsetYStart = m_nOffsetYSet = m_nOffsetY;
                }
                else
                {
                    m_nScaleSet = m_nScaleStart + (m_nScale - m_nScaleStart) * t;
                    m_nOffsetXSet = m_nOffsetXStart + (m_nOffsetX - m_nOffsetXStart) * t;
                    m_nOffsetYSet = m_nOffsetYStart + (m_nOffsetY - m_nOffsetYStart) * t;
                }
            }

            UpdateZoom();
        }

/*      if (m_bResetPosSize)
        {
            int width = m_width == 0 ? m_videoWidth : m_width;
            int height = m_height == 0 ? m_videoHeight : m_height;

            // REVIEW: These don't do what it seems they should; need docs from Ravisent...
            if (m_width == 0 || m_height == 0)
            {
                VDR_ConfigureUnitsTags(m_hUnitSet,
                    SET_PIP_ADAPT_SOURCE_SIZE(TRUE),
                    SET_PIP_DEST_LEFT(m_left),
                    SET_PIP_DEST_TOP(m_top),
                    TAGDONE);
            }
            else
            {
                VDR_ConfigureUnitsTags(m_hUnitSet,
                    SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
                    SET_PIP_DEST_LEFT(m_left),
                    SET_PIP_DEST_TOP(m_top),
                    SET_PIP_DEST_WIDTH(m_width),
                    SET_PIP_DEST_HEIGHT(m_height),
                    TAGDONE);
            }
            m_bResetPosSize = false;
        }
*/
    }

    if (m_parentalTooLow && !m_parentalPopup)
    {
        m_parentalPopup = true;
        VERIFYDVD(VDR_EnablePIP(m_hUnitSet, FALSE));
        CallFunction(this, _T("OnParentalLevelViolation"));
    }

    ProcessEvents();

    CNode::Advance(nSeconds);
}

void CDVDPlayer::init()
{
    Error err;
    BYTE DvdRegion;

    if (m_hPlayer != NULL)
        return;

    HalEnableSecureTrayEject();

    if (m_hvdr == NULL)
    {
        if (!DvdKeyInitialize(&DvdRegion, &err))
        {
            TRACE(_T("DvdKeyInitilize failed (0x%x) from DVDMediaPlayer!\n"), err);
            D3DDevice_SetFlickerFilter(5);
            CallFunction(this, _T("OnNoDongle"));
            return;
        }

        if (IS_ERROR(VDR_OpenDriver("CINEMAST", 0, m_hvdr)))
        {
            TRACE(_T("\001VDR_OpenDriver failed!\n"));
            cleanup();
            return;
        }

        VERIFY(VDR_OpenUnits(m_hvdr, MPEG_DECODER_UNIT | VIDEO_ENCODER_UNIT | PIP_UNIT, m_hUnitSet) == GNR_OK);

        DWORD dwVideoStandard = XGetVideoStandard();
        bool bPal = (dwVideoStandard == XC_VIDEO_STANDARD_PAL_I || dwVideoStandard == XC_VIDEO_STANDARD_PAL_M);

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_MPEG_AUDIO_MUTE(FALSE),
            SET_MPEG2_PRESENTATION_MODE(MPM_FULLSIZE),
            SET_VID_MODE(VMOD_PLAYBACK),
            SET_PIP_VIDEOSTANDARD(bPal ? VSTD_PAL : VSTD_NTSC),
            SET_VID_VIDEOSTANDARD(bPal ? VSTD_PAL : VSTD_NTSC),
            SET_PIP_WINDOW(NULL),
            SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
            SET_PIP_ADAPT_CLIENT_SIZE(FALSE),
            SET_PIP_COLORKEY_COLOR(XDASH_COLORKEY),
            TAGDONE);

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_DISPLAY_LEFT(0),
            SET_PIP_DISPLAY_TOP(0),
            SET_PIP_DISPLAY_WIDTH((USHORT)theApp.m_pp.BackBufferWidth),
            SET_PIP_DISPLAY_HEIGHT((USHORT)theApp.m_pp.BackBufferHeight),
            TAGDONE);

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
            SET_PIP_DEST_LEFT(0),
            SET_PIP_DEST_TOP(0),
            SET_PIP_DEST_WIDTH((USHORT)theApp.m_pp.BackBufferWidth),
            SET_PIP_DEST_HEIGHT((USHORT)theApp.m_pp.BackBufferHeight),
            TAGDONE);

        refreshAudioSettings();
    }

    DWORD dwType, dwDvdRegion;
    DWORD dwErr = XQueryValue(XC_DVD_REGION, &dwType, &dwDvdRegion, sizeof(dwDvdRegion), NULL);

    if (dwErr != ERROR_SUCCESS || dwDvdRegion == 0 || dwDvdRegion > 8)
    {
        dwDvdRegion = DvdRegion;
        XSetValue(XC_DVD_REGION, REG_DWORD, &dwDvdRegion, sizeof(dwDvdRegion));
        TRACE(_T("XDASH: DVD region of Xbox is now stamped to %d\n"), DvdRegion);
    }
#ifndef COOL_XDASH
    else if (dwDvdRegion != DvdRegion)
    {
        TRACE(_T("XDASH: DVD region of Xbox doesn't match dongle's\n"));
        D3DDevice_SetFlickerFilter(5);
        CallFunction(this, _T("OnXboxDVDRegionViolation"));
        return;
    }
#endif

#ifdef COOL_XDASH
    // For testing purpose, auto-detect the DVD region
    for (DvdRegion=1; DvdRegion<=6; DvdRegion++)
    {
        DDP_SetSystemRegion(m_hUnitSet, 'D', (BYTE) ~(1 << (DvdRegion - 1)));
        if (!IS_ERROR(DDP_OpenPlayer(m_hUnitSet, 'D', m_hPlayer)))
        {
            break;
        }
    }
#else
    DDP_SetSystemRegion(m_hUnitSet, 'D', (BYTE) ~(1 << (DvdRegion - 1)));

    err = DDP_OpenPlayer(m_hUnitSet, 'D', m_hPlayer);
    if (IS_ERROR(err))
    {
        if (err == GNR_REGIONS_DONT_MATCH)
        {
            D3DDevice_SetFlickerFilter(5);
            CallFunction(this, _T("OnDiscDVDRegionViolation"));
        }

        TRACE(_T("\001DDP_OpenPlayer failed (%d 0x%x)!\n"), err, err);
        return;
    }
#endif

    InstallEventHandlers();

    DisplayPresentationMode dpm = DPM_4BY3;

    DWORD dwVideoFlags;

    if (ERROR_SUCCESS == XQueryValue(XC_VIDEO_FLAGS, &dwType, &dwVideoFlags, sizeof(DWORD), NULL))
    {
        ASSERT(REG_DWORD == dwType);

        if (dwVideoFlags & AV_FLAGS_WIDESCREEN)
        {
            dpm = DPM_16BY9;
        }
        else if (dwVideoFlags & AV_FLAGS_LETTERBOX)
        {
            dpm = DPM_LETTERBOXED;
        }
        else
        {
            dpm = DPM_4BY3;
        }
    }

    dwErr = XQueryValue(XC_PARENTAL_CONTROL_MOVIES, &dwType, &m_parentalLevel, sizeof(m_parentalLevel), NULL);

    if (dwErr != ERROR_SUCCESS)
         m_parentalLevel = 8;
    else
        m_parentalLevel = 8 - m_parentalLevel; // revert it since we store the level backward in EEPROM

    DDP_SetDisplayMode(m_hPlayer, dpm);

    static const TCHAR rgchLangCodes [] = { _T("enjadefresit") };
    ASSERT(g_nCurLanguage >= 0 && g_nCurLanguage < countof (rgchLangCodes) / 2);
    WORD lang = MKLANG(rgchLangCodes[g_nCurLanguage * 2], rgchLangCodes[g_nCurLanguage * 2 + 1]);

    VERIFYDVD(DDP_InitialLanguageSelect(m_hPlayer, lang, 0, lang, 0));
    VERIFYDVD(DDP_ParentalCountrySelect(m_hPlayer, 0x5553));

    // Parental control level 8 means to disble parental control
    if (m_parentalLevel != 8)
    {
        VERIFYDVD(DDP_ParentalLevelSelect(m_hPlayer, (WORD)m_parentalLevel));
    }

    err = DDP_StartPresentation(m_hPlayer);
    VERIFYDVD(VDR_EnablePIP(m_hUnitSet, TRUE));

    if (err == GNR_INSUFFICIENT_RIGHTS || err == GNR_PARENTAL_LEVEL_TOO_LOW)
    {
        m_parentalTooLow = true;
    }
}

void CDVDPlayer::cleanup()
{
    if (m_hPlayer != NULL)
    {
        DDP_Stop(m_hPlayer);
        RemoveEventHandlers();
        DDP_ClosePlayer(m_hPlayer);
        m_hPlayer = NULL;
    }

    if (m_hUnitSet != NULL)
    {
        VDR_CloseUnits(m_hUnitSet);
        m_hUnitSet = NULL;
    }

#ifndef _XBOX
    if (m_hvdr != NULL)
    {
        VDR_CloseDriver(m_hvdr);
        m_hvdr = NULL;
    }
#endif

    m_playbackMode = DPM_STOPPED;
}


Error CDVDPlayer::CheckUserOp(Error e)
{
    if (e == GNR_UOP_PROHIBITED || e == GNR_OPERATION_PROHIBITED)
    {
        CallFunction(this, _T("OnProhibited"));
        return NO_ERROR;
    }

    CallFunction(this, _T("OnUserOpAllowed"));
    return e;
}

void CDVDPlayer::goUp()
{
    if (m_hPlayer == NULL)
        return;

    VERIFYDVD(CheckUserOp(DDP_GoUp(m_hPlayer)));
}

void CDVDPlayer::play()
{
    if (m_hPlayer == NULL)
    {
        init();
        return;
    }

    DisplayPresentationMode dpm = DDP_GetCurrentDisplayMode(m_hPlayer);

    if (dpm == DPM_16BY9)
    {
        enableWideScreen();
    }
    else
    {
        disableWideScreen();
    }

    // Get a fresh playback mode. We need to do this because this method
    // may be called before m_playbackMode gets updated (BUG#6628).

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    switch (m_playbackMode)
    {
    case DPM_STOPPED:

        if (m_StopBookmark.IsSet())
        {
            //
            // Resume from last position using bookmarks
            //

            Error e = GotoBookmark(&m_StopBookmark);

            if(IS_GNERROR(e))
            {
                //
                // if that failed, start at the beginning (better than nothing)
                //

                VERIFYDVD(DDP_StartPresentation(m_hPlayer));
            }

            m_StopBookmark.Reset();
        }
        else
        {
            //
            // No bookmark? Start at the beginning.
            //

            VERIFYDVD(DDP_StartPresentation(m_hPlayer));
        }
        break;

    case DPM_PAUSED:
        {
            VERIFYDVD(DDP_Resume(m_hPlayer));

            if (DDP_GetPlayerMode(m_hPlayer) != DPM_PLAYING)
            {
                VERIFYDVD(DDP_PauseOff(m_hPlayer));
                VERIFYDVD(DDP_StopScan(m_hPlayer));
            }
        }
        break;

    case DPM_STILL:
        VERIFYDVD(CheckUserOp(DDP_StillOff(m_hPlayer)));
        break;

    case DPM_SCANNING:
    case DPM_REVERSEPLAY:
    case DPM_TRICKPLAY:
    case DPM_REVERSESCAN:
        VERIFYDVD(DDP_StopScan(m_hPlayer));
        break;

    case DPM_PLAYING:
        {
            //
            // Check if we're in a menu. If so, press the current
            // selected button
            //

            ULONG uops = DDP_GetForbiddenUserOperations(m_hPlayer);

            if(! (uops & UOP_BUTTON))
            {
                VERIFYDVD(CheckUserOp(DDP_ButtonActivate(m_hPlayer)));
            }
        }
        break;
    }

    DDP_SetPlaybackSpeed(m_hPlayer, 1000);
    m_bScanBackward = false;
    m_scanSpeed = 1;
    m_scanSlow = false;

    //
    // Depending on the new mode or domain, the script
    // will show the status message. Calling Advance
    // will refresh these variables
    //

    Advance(0.0f);

}

void CDVDPlayer::playOrPause()
{
    if (m_hPlayer == NULL)
    {
        init();
        return;
    }

    DDP_SetPlaybackSpeed(m_hPlayer, 1000);
    m_bScanBackward = false;
    m_scanSpeed = 1;
    m_scanSlow = false;

    // Get a fresh playback mode. We need to do this because this method
    // may be called before m_playbackMode gets updated (BUG#6628).

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    switch (m_playbackMode)
    {
    case DPM_STOPPED:
        if (m_stopLocation.title != 0)
        {
            // Resume from last stopped position
            TRACE(_T("Resuming from saved stop position...\n"));
            VERIFYDVD(DDP_TimePlay(m_hPlayer, m_stopLocation.title, m_stopLocation.titleTime));
            ZeroMemory(&m_stopLocation, sizeof (m_stopLocation));
        }
        else
        {
            TRACE(_T("Starting presentation...\n"));
            VERIFYDVD(DDP_StartPresentation(m_hPlayer));
        }
        break;

    case DPM_SCANNING:
    case DPM_REVERSEPLAY:
    case DPM_TRICKPLAY:
    case DPM_REVERSESCAN:
        VERIFYDVD(DDP_StopScan(m_hPlayer));
        break;

    case DPM_STILL:
        VERIFYDVD(CheckUserOp(DDP_StillOff(m_hPlayer)));
        break;

    case DPM_PAUSED:
        VERIFYDVD(CheckUserOp(DDP_PauseOff(m_hPlayer)));
        break;

    default:
        VERIFYDVD(CheckUserOp(DDP_PauseOn(m_hPlayer)));
        break;
    }
}

void CDVDPlayer::eject()
{
    stop();
    DDP_EjectDiskInDrive('D');
}

void CDVDPlayer::stop()
{
    if (m_hPlayer == NULL)
        return;

    // Get a fresh playback mode. We need to do this because this method
    // may be called before m_playbackMode gets updated (BUG#6628).

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    switch (m_playbackMode)
    {
    case DPM_STOPPED:
        TRACE(_T("Clearing saved stop position...\n"));
        m_StopBookmark.Reset();
        break;

    default:
        TRACE(_T("Saving stop position...\n"));
        SetBookmark(&m_StopBookmark);
        VERIFYDVD(DDP_Stop(m_hPlayer));
        break;
    }

    m_abRepeatState = AB_DISABLED;
}

void CDVDPlayer::pause()
{
    if (m_hPlayer != NULL)
    {
        // Get a fresh playback mode. We need to do this because this method
        // may be called before m_playbackMode gets updated (BUG#6628).

        m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

        switch (m_playbackMode)
        {
        case DPM_PAUSED:
            if (m_bScanBackward)
            {
                TRACE(_T("Frame back\n"));
                VERIFYDVD(DDP_TrickPlay(m_hPlayer));
                VERIFYDVD(DDP_AdvanceFrameBy(m_hPlayer, -1));
            }
            else
            {
                VERIFYDVD(CheckUserOp(DDP_AdvanceFrame(m_hPlayer)));
            }

//          CheckUserOp(DDP_PauseOff(m_hPlayer));
            break;

        case DPM_SCANNING:
        case DPM_REVERSEPLAY:
//      case DPM_TRICKPLAY:
        case DPM_REVERSESCAN:
            VERIFYDVD(DDP_StopScan(m_hPlayer));
            // fall through
        case DPM_PLAYING:
            VERIFYDVD(CheckUserOp(DDP_PauseOn(m_hPlayer)));
            m_scanSpeed = 1;
            m_scanSlow = false;
            m_bScanBackward = false;
            break;
        }
    }
}

void CDVDPlayer::selectUp()
{
    if (m_hPlayer != NULL)
        VERIFYDVD(CheckUserOp(DDP_UpperButtonSelect(m_hPlayer)));
}

void CDVDPlayer::selectDown()
{
    if (m_hPlayer != NULL)
        VERIFYDVD(CheckUserOp(DDP_LowerButtonSelect(m_hPlayer)));
}

void CDVDPlayer::selectRight()
{
    if (m_hPlayer != NULL)
        VERIFYDVD(CheckUserOp(DDP_RightButtonSelect(m_hPlayer)));
}

void CDVDPlayer::selectLeft()
{
    if (m_hPlayer != NULL)
        VERIFYDVD(CheckUserOp(DDP_LeftButtonSelect(m_hPlayer)));
}

void CDVDPlayer::digit(int nDigit)
{
    if (nDigit < 0)
    {
        TRACE(_T("Resetting number\n"));
        m_numberTime = 0.0f;
        m_number = 0;
        return;
    }

#if 0
    if (m_number == 0 && nDigit == 0)
    {
        DisplayPresentationMode dpm = DDP_GetCurrentDisplayMode(m_hPlayer);
        TRACE(_T("Starting display mode: %s\n"), rgszDisplayPresentationMode[dpm]);

        for (int i = 0; i < 5; i += 1)
        {
            switch (dpm)
            {
            case DPM_4BY3:
                dpm = DPM_16BY9;
                break;
            case DPM_16BY9:
                dpm = DPM_LETTERBOXED;
                break;
            case DPM_LETTERBOXED:
                dpm = DPM_PANSCAN;
                break;
            case DPM_PANSCAN:
                dpm = DPM_NONE;
                break;
            case DPM_NONE:
                dpm = DPM_4BY3;
                break;
            }

            VERIFYDVD(DDP_SetDisplayMode(m_hPlayer, dpm));

            if (DDP_GetCurrentDisplayMode(m_hPlayer) == dpm)
                break;

            TRACE(_T("Failed to set display mode %s\n"), rgszDisplayPresentationMode[dpm]);
        }

        TRACE(_T("New display mode: %s\n"), rgszDisplayPresentationMode[dpm]);
        return;
    }
#endif

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    // check valid playback modes before computing the number

    if ( ((TT_DOM == m_domain) &&
          ((DPM_PLAYING == m_playbackMode) ||
           (DPM_PAUSED == m_playbackMode) ||
           (DPM_TRICKPLAY == m_playbackMode)) && (!m_scanSlow)) ||
         (STOP_DOM == m_domain && DPM_STOPPED == m_playbackMode) )
    {
        // valid mode

        m_numberTime = XAppGetNow();
        if (m_number < 1000)
            m_number = m_number * 10 + nDigit;
    }
    else
    {
        // invalid mode

        CallFunction(this, _T("OnProhibited"));
        m_numberTime = 0.0f;
        m_number = 0;
    }
}

void CDVDPlayer::activate()
{
    TRACE(_T("activate\n"));

    if (m_hPlayer == NULL)
        return;

    if (m_numberTime > 0.0f)
    {
        int nChapterCount = DDP_GetNumberOfPartOfTitle(m_hPlayer, (WORD)m_title);
        int nTitleCount = DDP_GetNumberOfTitles(m_hPlayer);
        m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

        if (m_playbackMode == DPM_STOPPED)
        {
            if (m_number > 0 && m_number < nTitleCount)
            {
                VERIFYDVD(CheckUserOp(DDP_TitlePlay(m_hPlayer, (WORD)m_number)));
            }
            else
            {
                VERIFYDVD(CheckUserOp(GNR_OPERATION_PROHIBITED));
            }
        }
        else
        {
            if (m_number > 0 && m_number <= nChapterCount)
            {
                // Before switching chapters, check if the player was paused
                // so we can pause again after switching

                bool bWasPaused = (m_playbackMode == DPM_PAUSED);

                VERIFYDVD(CheckUserOp(DDP_PTTSearch(m_hPlayer, (WORD)m_number)));

                if(bWasPaused)
                {
                    // Restore paused state

                    VERIFYDVD(DDP_PauseOn(m_hPlayer));
                }
            }
            else
            {
                VERIFYDVD(CheckUserOp(GNR_OPERATION_PROHIBITED));
            }
        }

        m_numberTime = 0.0f;
        m_number = 0;
        return;
    }

    VERIFYDVD(CheckUserOp(DDP_ButtonActivate(m_hPlayer)));
}

void CDVDPlayer::nextAudioStream()
{
    if (m_hPlayer == NULL)
        return;

    // Check prerequisites before executing.
    // Some modes specifically don't allow angle changes.

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    if(TT_DOM == m_domain &&
        DPM_PLAYING == m_playbackMode &&
        !m_scanSlow &&
        1 == m_scanSpeed &&
        isUOPValid(UOP_AUDIO_STREAM_CHANGE))
    {
        BYTE bAudio = 0;
        DWORD dwSubPicture = 0;
        VERIFYDVD(DDP_GetAvailStreams(m_hPlayer, bAudio, dwSubPicture));

        if (m_audioStream != 0 && (bAudio & (1 << m_audioStream)) == 0)
            m_audioStream = 0;

        m_audioStream += 1;
        while (m_audioStream < 8 && (bAudio & (1 << m_audioStream)) == 0)
            m_audioStream += 1;
        if (m_audioStream == 8)
            m_audioStream = 0;

        VERIFYDVD(CheckUserOp(DDP_AudioStreamChange(m_hPlayer, (WORD)m_audioStream)));

        // Reset A-B repeat. We've seen problems with it after switching modes

        m_abRepeatState = AB_DISABLED;

    }
    else if (TT_DOM != m_domain &&
        isUOPValid(UOP_MENU_CALL_AUDIO) &&
        DDP_CheckMenuAvail(m_hPlayer, VMT_AUDIO_MENU))
    {
        CallFunction(this, _T("OnMenuCall"));
        VERIFYDVD(CheckUserOp(DDP_MenuCall(m_hPlayer, VMT_AUDIO_MENU)));
    }
    else
    {
        // Wrong mode, alert user

        CallFunction(this, _T("OnProhibited"));
    }

//  OnAudioStreamChange();
}

void CDVDPlayer::nextAngle()
{
    if (m_hPlayer == NULL)
        return;

/*
    NOTE: This would use the DVD's own angle menu where there is one,
    but Victor doesn't want to do that...

    if (DDP_CheckMenuAvail(m_hPlayer, VMT_ANGLE_MENU))
    {
        DDP_MenuCall(m_hPlayer, VMT_ANGLE_MENU);
        return;
    }
*/

    // Check prerequisites before executing.
    // Some modes specifically don't allow angle changes.

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    if(TT_DOM == m_domain &&
        DPM_PLAYING == m_playbackMode &&
        !m_scanSlow &&
        1 == m_scanSpeed &&
        isUOPValid(UOP_ANGLE_CHANGE))
    {
        // Before switching angles, check if the player was paused
        // so we can pause again after switching

        bool bWasPaused = (m_playbackMode == DPM_PAUSED);

        m_angleCount = DDP_GetNumberOfAngles(m_hPlayer, (WORD)m_title);
        if (m_angleCount == 0)
            m_angleCount = 1;
        m_angle = DDP_GetCurrentAngle(m_hPlayer);

        m_angle += 1;
        if (m_angle > m_angleCount)
            m_angle = 1;

        VERIFYDVD(CheckUserOp(DDP_AngleChange(m_hPlayer, (WORD)m_angle)));
        m_angle = DDP_GetCurrentAngle(m_hPlayer);

        // Reset A-B repeat. We've seen problems with it after switching modes

        m_abRepeatState = AB_DISABLED;

        if(bWasPaused)
        {
            // Restore paused state

            VERIFYDVD(DDP_PauseOn(m_hPlayer));
        }
    }
    else
    {
        // Wrong mode, alert user

        CallFunction(this, _T("OnProhibited"));
    }
}

void CDVDPlayer::startChapter()
{
    if (m_hPlayer == NULL)
        return;

    VERIFYDVD(CheckUserOp(DDP_TopPGSearch(m_hPlayer)));
    m_abRepeatState = AB_DISABLED;
}

void CDVDPlayer::nextChapter()
{
    if (m_hPlayer != NULL)
    {
        // Other modes, skip to next chapter

        VERIFYDVD(CheckUserOp(DDP_NextPGSearch(m_hPlayer)));

        m_abRepeatState = AB_DISABLED;
        Advance(0.0f);
    }

    return;
}

void CDVDPlayer::prevChapter()
{
    if (m_hPlayer != NULL)
    {
        // Other modes. Depending on how far we're in this chapter go either
        // to the beginning or to the previous chapter.

        VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));

        if ((XAppGetNow() - m_prevChapterTime) > 4.0f)
        {
            // Go to beginning of chapter

            VERIFYDVD(CheckUserOp(DDP_TopPGSearch(m_hPlayer)));
        }
        else
        {
            // Skip to previous chapter

            VERIFYDVD(CheckUserOp(DDP_PrevPGSearch(m_hPlayer)));
        }

        m_abRepeatState = AB_DISABLED;
        m_prevChapterTime = XAppGetNow();
        Advance(0.0f);
    }

    return;
}

void CDVDPlayer::menu()
{
    if (m_hPlayer == NULL)
        return;

    VERIFYDVD(CheckUserOp(DDP_MenuCall(m_hPlayer, VMT_ROOT_MENU)));
    m_abRepeatState = AB_DISABLED;
}

void CDVDPlayer::titleMenu()
{
    if (m_hPlayer == NULL)
        return;

    VERIFYDVD(CheckUserOp(DDP_MenuCall(m_hPlayer, VMT_TITLE_MENU)));
    m_abRepeatState = AB_DISABLED;
}

void CDVDPlayer::nextSubtitle()
{
    if (m_hPlayer == NULL)
        return;

    if (TT_DOM == m_domain && isUOPValid(UOP_SUB_PICTURE_STREAM_CHANGE))
    {
        BYTE bAudio = 0;
        DWORD dwSubPicture = 0;
        VERIFYDVD(DDP_GetAvailStreams(m_hPlayer, bAudio, dwSubPicture));

        TRACE(_T("Available sub pictures: 0x%08x\n"), dwSubPicture);

        do
        {
            m_subTitle += 1;
        }
        while (m_subTitle < 33 && (dwSubPicture & (1 << (m_subTitle - 1))) == 0);

        if (m_subTitle > 32)
            m_subTitle = 0;

        if (m_subTitle == 0)
            VERIFYDVD(CheckUserOp(DDP_SubPictureStreamChange(m_hPlayer, 0, FALSE)));
        else
            VERIFYDVD(CheckUserOp(DDP_SubPictureStreamChange(m_hPlayer, (WORD)(m_subTitle - 1), TRUE)));

        // Reset A-B repeat. We've seen problems with it after switching modes

        m_abRepeatState = AB_DISABLED;

        OnSubPictureStreamChange();
    }
    else if (TT_DOM != m_domain &&
        isUOPValid(UOP_MENU_CALL_SUB_PICTURE) &&
        DDP_CheckMenuAvail(m_hPlayer, VMT_SUBPICTURE_MENU))
    {
        CallFunction(this, _T("OnMenuCall"));
        VERIFYDVD(CheckUserOp(DDP_MenuCall(m_hPlayer, VMT_SUBPICTURE_MENU)));
    }
    else
    {
        // Wrong mode, alert user

        CallFunction(this, _T("OnProhibited"));
    }
}

void CDVDPlayer::frameAdvance()
{
    if (m_hPlayer == NULL)
        return;

    // Get a fresh playback mode. We need to do this because this method
    // may be called before m_playbackMode gets updated (BUG#6628).

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    // Paused or trick-play mode required by DDP_AdvanceFrame.

    if( m_playbackMode != DPM_PAUSED &&
        m_playbackMode != DPM_TRICKPLAY )
    {
        // other mode currently, lets go with trick-play mode because it's required
        // by DDP_AdvanceFrameBy used in frameReverse.

        VERIFYDVD(CheckUserOp(DDP_TrickPlay(m_hPlayer)));

        m_scanSlow = false;
        m_bScanBackward = false;
        m_scanSpeed = 1;
    }

    VERIFYDVD(CheckUserOp(DDP_AdvanceFrame(m_hPlayer)));
}

void CDVDPlayer::frameReverse()
{
    if (m_hPlayer == NULL)
        return;

    // Get a fresh playback mode. We need to do this because this method
    // may be called before m_playbackMode gets updated (BUG#6628).

    m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

    // trick-play mode required by DDP_AdvanceFrameBy

    if( m_playbackMode != DPM_TRICKPLAY )
    {
        VERIFYDVD(CheckUserOp(DDP_TrickPlay(m_hPlayer)));

        m_scanSlow = false;
        m_bScanBackward = false;
        m_scanSpeed = 1;
    }

    VERIFYDVD(CheckUserOp(DDP_AdvanceFrameBy(m_hPlayer, -1)));
}

void CDVDPlayer::forwardScan()
{
    if (m_hPlayer == NULL)
        return;

    // scanning is only available in the TT_DOMain

    if (isPlaybackDomain())
    {
        // Get a fresh playback mode. We need to do this because this method
        // may be called before m_playbackMode gets updated (BUG#6628).

        m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

        if( (m_playbackMode == DPM_PAUSED) ||
            (m_playbackMode == DPM_TRICKPLAY))  // starting slow forward
        {
            // if player is currently paused, start slow scan, forward, at speed 2
            m_scanSlow = true;
            m_bScanBackward = false;
            m_scanSpeed = 2;

            VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
            VERIFYDVD(CheckUserOp(DDP_PauseOff(m_hPlayer)));
            VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
        }
        else if ((m_scanSpeed > 1) && (!m_scanSlow)) // fast scan update
        {
            if (!m_bScanBackward)
            {
                // Already scanning forward. Double speed. Limit is 32

                if (m_scanSpeed < 32)
                    m_scanSpeed *= 2;

                VERIFYDVD(CheckUserOp(DDP_ForwardScan(m_hPlayer, (WORD)m_scanSpeed)));
            }
            else
            {
                // Scanning backwards. Cut speed in half. If we reach 1,
                // we'll start the forward scan at 2x

                m_scanSpeed /= 2;

                if(m_scanSpeed <= 1)
                {
                    // Start forward scan at 2x

                    m_scanSpeed = 2;
                    m_bScanBackward = false;

                    VERIFYDVD(DDP_StopScan(m_hPlayer));
                    VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 * m_scanSpeed)));
                }
                else
                {
                    // Update backward scan speed

                    if(m_scanSpeed > 2)
                    {
                        VERIFYDVD(CheckUserOp(DDP_BackwardScan(m_hPlayer, (WORD)m_scanSpeed)));
                    }
                    else
                    {
                        VERIFYDVD(DDP_StopScan(m_hPlayer));
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 * m_scanSpeed)));
                    }
                }
            }
        }
        else
        {
            if (!m_scanSlow)
            {
                // Player is playing at regular speed. Start forward scan. Initial speed is 2x

                m_scanSpeed = 2;

                VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
                VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 *  m_scanSpeed)));
            }
            else
            {
                // Player is in slow scan mode

                if (!m_bScanBackward)
                {
                    // Already going forwards. Double speed divisor. Limit is 8.

                    if (m_scanSpeed < 8)
                    {
                        m_scanSpeed *= 2;
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                    }
                }
                else
                {
                    // Going backwards. Cut speed divisor in half. If we reach 1,
                    // go to forward scan.

                    m_scanSpeed /= 2;

                    if(m_scanSpeed <= 1)
                    {
                        // Start slow forward scan at 1/2

                        m_scanSpeed = 2;
                        m_bScanBackward = false;

                        VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                    }
                    else
                    {
                        // Update speed

                        if(m_scanSpeed > 2)
                        {
                            VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                        }
                        else
                        {
                            VERIFYDVD(DDP_StopScan(m_hPlayer));
                            VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                            VERIFYDVD(CheckUserOp(DDP_ReversePlayback(m_hPlayer)));
                        }
                    }
                }
            }
        }
    }
    else
    {
        // Other domains = failure.
        // The script will detect it by checking scanSpeed

        m_scanSpeed = 1;
    }
}

void CDVDPlayer::backwardScan()
{
    if (m_hPlayer == NULL)
        return;

    // scanning is only available in the TT_DOMain

    if (isPlaybackDomain())
    {
        // Get a fresh playback mode. We need to do this because this method
        // may be called before m_playbackMode gets updated (BUG#6628).

        m_playbackMode = DDP_GetPlayerMode(m_hPlayer);

        if( (m_playbackMode == DPM_PAUSED) ||
            (m_playbackMode == DPM_TRICKPLAY))
        {
            // if player is currently paused, start slow scan, backwards, at speed 2

            m_scanSlow = true;
            m_bScanBackward = true;
            m_scanSpeed = 2;

            VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
            VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
            VERIFYDVD(CheckUserOp(DDP_ReversePlayback(m_hPlayer)));
            VERIFYDVD(CheckUserOp(DDP_PauseOff(m_hPlayer)));
        }
        else if ((m_scanSpeed > 1) && (!m_scanSlow))
        {
            if (m_bScanBackward)
            {
                // Already scanning backwards. Double speed. Limit is 32

                if (m_scanSpeed < 32)
                    m_scanSpeed *= 2;

                VERIFYDVD(CheckUserOp(DDP_BackwardScan(m_hPlayer, (WORD)m_scanSpeed)));
            }
            else
            {
                // Scanning forward. Cut speed in half. If we reach 1,
                // we'll start the backward scan at 2x

                m_scanSpeed /= 2;

                if(m_scanSpeed <= 1)
                {
                    // Start backward scan at 2x

                    m_scanSpeed = 2;
                    m_bScanBackward = true;

                    VERIFYDVD(DDP_StopScan(m_hPlayer));
                    VERIFYDVD(CheckUserOp(DDP_ReversePlayback(m_hPlayer)));
                    VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 *  m_scanSpeed)));
                }
                else
                {
                    // Update forward scan speed

                    if(m_scanSpeed > 2)
                    {
                        VERIFYDVD(CheckUserOp(DDP_ForwardScan(m_hPlayer, (WORD)m_scanSpeed)));
                    }
                    else
                    {
                        VERIFYDVD(DDP_StopScan(m_hPlayer));
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 *  m_scanSpeed)));
                    }
                }
            }
        }
        else
        {
            if (!m_scanSlow)
            {
                // Player is playing at regular speed. Start backward scan. Initial speed is 2x

                m_scanSpeed = 2;
                m_bScanBackward = true;

                VERIFYDVD(DDP_StopScan(m_hPlayer));
                VERIFYDVD(CheckUserOp(DDP_ReversePlayback(m_hPlayer)));
                VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 *  m_scanSpeed)));
            }
            else
            {
                // Player is in slow scan mode

                if (m_bScanBackward)
                {
                    // Already going backwards. Double speed divisor. Limit is 8.

                    if (m_scanSpeed < 8)
                    {
                        m_scanSpeed *= 2;
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                    }
                }
                else
                {
                    // Going forward. Cut speed divisor in half. If we reach 1,
                    // start slow backward scan.

                    m_scanSpeed /= 2;

                    if(m_scanSpeed <= 1)
                    {
                        m_scanSpeed = 2;
                        m_bScanBackward = true;

                        VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                        VERIFYDVD(CheckUserOp(DDP_ReversePlayback(m_hPlayer)));
                    }
                    else
                    {
                        // Update speed

                        VERIFYDVD(CheckUserOp(DDP_SetPlaybackSpeed(m_hPlayer, 1000 / m_scanSpeed)));
                    }
                }
            }
        }
    }
    else
    {
        // Other domains = failure.
        // The script will detect it by checking scanSpeed

        m_scanSpeed = 1;
    }
}

void CDVDPlayer::stopScan()
{
    if (m_hPlayer == NULL)
        return;

    VERIFYDVD(CheckUserOp(DDP_StopScan(m_hPlayer)));
    m_bScanBackward = false;
    m_scanSpeed = 1;
}

int CDVDPlayer::isUOPValid(int nUOP)
{
    if (m_hPlayer == NULL)
        return 0;

    return (nUOP & DDP_GetForbiddenUserOperations(m_hPlayer)) == 0;
}

int CDVDPlayer::isPlaybackDomain()
{
    if (m_domain == VMGM_DOM || m_domain == VTSM_DOM || m_domain == TT_DOM)
        return 1;
    else
        return 0;
}

void CDVDPlayer::refreshAudioSettings()
{
    ASSERT(m_hUnitSet != NULL);

    DWORD AudioFlags = XGetAudioFlags();
    AC3SpeakerConfig SpeakerConfig;
    AudioTypeConfig DigitalConfig;

    switch (DSSPEAKER_BASIC(AudioFlags))
    {
    case DSSPEAKER_STEREO:
        SpeakerConfig = AC3SC_20_NORMAL;
        break;

    case DSSPEAKER_MONO:
        SpeakerConfig = AC3SC_10;
        break;

    case DSSPEAKER_SURROUND:
    default:
        SpeakerConfig = AC3SC_20_SURROUND_COMPATIBLE;
    }

    VERIFYDVD(VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_AC3_SPEAKER_CONFIG(SpeakerConfig), TAGDONE));

    DigitalConfig.config.spdifOutMode = DSSPEAKER_ENCODED(AudioFlags) & DSSPEAKER_ENABLE_DTS ? SPDIFOM_DEFAULT : SPDIFOM_MUTE_NULL;
    VERIFYDVD(VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_DTS_AUDIO_TYPE_CONFIG(DigitalConfig), TAGDONE));

    DigitalConfig.config.spdifOutMode = DSSPEAKER_ENCODED(AudioFlags) & DSSPEAKER_ENABLE_AC3 ? SPDIFOM_DEFAULT : SPDIFOM_MUTE_NULL;
    VERIFYDVD(VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_AC3_AUDIO_TYPE_CONFIG(DigitalConfig), TAGDONE));

    if (XGetAVPack() == XC_AV_PACK_RFU)
    {
        // Set AC3 decoder to "TV Style" dynamic range compression
        VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_AC3_DYNAMIC_RANGE(AC3DYNRG_TV), TAGDONE);

        // Set AC3 decoder to mono
        VDR_ConfigureUnitsTags(m_hUnitSet, SET_MPEG2_AC3_SPEAKER_CONFIG(AC3SC_10), TAGDONE);
    }
}

void CDVDPlayer::UpdateZoom()
{
    ASSERT(m_hUnitSet != NULL);

    WORD w, h;
    VDR_ConfigureUnitsTags(m_hUnitSet,
        GET_MPEG_DISPLAY_WIDTH(w),
        GET_MPEG_DISPLAY_HEIGHT(h),
        TAGDONE);

    float cx = (float)w / m_nScaleSet;
    float cy = (float)h / m_nScaleSet;

    int width = m_width == 0 ? m_videoWidth : m_width;
    int height = m_height == 0 ? m_videoHeight : m_height;

    float ws = width * m_nScaleSet;
    float hs = height * m_nScaleSet;

    if (m_nScaleSet > 1.0f)
    {
        float xo = (m_nOffsetXSet + 1.0f) / 2.0f;
        float yo = (m_nOffsetYSet + 1.0f) / 2.0f;

        WORD x = (WORD)(xo * ((float)w - cx));
        WORD y = (WORD)(yo * ((float)h - cy));

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
            SET_PIP_SOURCE_LEFT(x),
            SET_PIP_SOURCE_TOP(y),
            SET_PIP_SOURCE_WIDTH((WORD)cx),
            SET_PIP_SOURCE_HEIGHT((WORD)cy),
            TAGDONE);

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_DEST_LEFT(m_left),
            SET_PIP_DEST_TOP(m_top),
            SET_PIP_DEST_WIDTH(m_width),
            SET_PIP_DEST_HEIGHT(m_height),
            TAGDONE);
    }
    else
    {
//      if (m_videoHeight > m_height)
//      {
            VDR_ConfigureUnitsTags(m_hUnitSet,
                SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
                SET_PIP_SOURCE_LEFT((WORD)0),
                SET_PIP_SOURCE_TOP((WORD)0),
                SET_PIP_SOURCE_WIDTH((WORD)m_videoWidth),
                SET_PIP_SOURCE_HEIGHT((WORD)m_videoHeight),
                TAGDONE);

            VDR_ConfigureUnitsTags(m_hUnitSet,
                SET_PIP_DEST_LEFT(m_left),
                SET_PIP_DEST_TOP(m_top),
                SET_PIP_DEST_WIDTH(m_width),
                SET_PIP_DEST_HEIGHT(m_height),
                TAGDONE);
//      }
//      else if (m_videoWidth > m_width)
//      {
//      }
//      else
//      {
//      }
/*
        int nSrcWidth = m_videoWidth;
        int nSrcHeight = m_videoHeight;

        float rWidth = (float)m_videoWidth / (float)m_width;
        float rHeight = (float)m_height / (float)m_videoHeight;

        if (rWidth < rHeight)
        {
            nSrcHeight = (int)(rWidth * m_height);
            nSrcWidth = m_videoWidth;
        }
        else
        {
            nSrcWidth = (int)(rHeight * m_videoWidth);
            nSrcHeight = m_videoHeight;
        }

        int x = (m_videoWidth - nSrcWidth) / 2;
        if (x < 0)
            x = 0;

        int y = (m_videoHeight - nSrcHeight) / 2;
        if (y < 0)
            y = 0;

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_ADAPT_SOURCE_SIZE(FALSE),
            SET_PIP_SOURCE_LEFT((WORD)x),
            SET_PIP_SOURCE_TOP((WORD)y),
            SET_PIP_SOURCE_WIDTH((WORD)nSrcWidth),
            SET_PIP_SOURCE_HEIGHT((WORD)nSrcHeight),
            TAGDONE);

        int left = m_left;
        int top = m_top;
        int width = m_width;
        int height = m_height;

        if (m_width > nSrcWidth)
        {
            int cx = m_width - nSrcWidth;
            left += cx / 2;
            width -= cx;
        }

        if (m_height > nSrcHeight)
        {
            int cy = m_height - nSrcHeight;
            top += cy / 2;
            height -= cy;
        }

        VDR_ConfigureUnitsTags(m_hUnitSet,
            SET_PIP_DEST_LEFT(left),
            SET_PIP_DEST_TOP(top),
            SET_PIP_DEST_WIDTH(width),
            SET_PIP_DEST_HEIGHT(height),
            TAGDONE);

#ifdef _DEBUG
        {
            static int _x, _y, _cx, _cy;
            if (x != _x || y != _y || nSrcWidth != _cx || nSrcHeight != _cy)
            {
                _x = x;
                _y = y;
                _cx = nSrcWidth;
                _cy = nSrcHeight;

                TRACE(_T("PIP SOURCE: %d,%d %dx%d\n"), _x, _y, _cx, _cy);
            }
        }
#endif
*/
    }
}

void CDVDPlayer::setScale(float nScale)
{
    if (m_hUnitSet != NULL)
    {
        m_nScale = nScale;
        if (m_nScale == 1.0f)
        {
            m_nScaleSet = m_nScaleStart = 1.0f;
            m_nOffsetX = m_nOffsetXSet = m_nOffsetXStart = 0.0f;
            m_nOffsetY = m_nOffsetYSet = m_nOffsetYStart = 0.0f;
            m_nZoomTime = 0.0f;
            return;
        }

        m_nScaleStart = m_nScaleSet;
        m_nOffsetXStart = m_nOffsetXSet;
        m_nOffsetYStart = m_nOffsetYSet;
        m_nZoomTime = XAppGetNow();
    }
}

void CDVDPlayer::setZoomPos(float x, float y)
{
    // the offsets should be from -1 to 1 so joystick inputs will suffice

    m_nOffsetX = x;
    m_nOffsetY = y;

    m_nScaleStart = m_nScaleSet;
    m_nOffsetXStart = m_nOffsetXSet;
    m_nOffsetYStart = m_nOffsetYSet;
    m_nZoomTime = XAppGetNow();
}

void CDVDPlayer::OnSubPictureStreamChange()
{
    const TCHAR* sz = NULL;

    if (m_subTitle != 0)
    {
        DVDSubPictureStreamFormat format;
        VERIFYDVD(DDP_GetSubPictureStreamAttributes(m_hPlayer, (WORD)(m_subTitle - 1), format));
        sz = LanguageNameFromCode(format.languageCode);
    }

    delete [] m_subTitleLanguage;
    m_subTitleLanguage = NULL;

    if (sz != NULL)
    {
        TCHAR buffer[MAX_TRANSLATE_LEN];
        lstrcpy(buffer, _T("Lang "));
        lstrcat(buffer, sz);
        m_subTitleLanguage = new TCHAR [MAX_TRANSLATE_LEN];
        Translate(buffer, m_subTitleLanguage);
    }
}

/*
void CDVDPlayer::OnAudioStreamChange()
{
    DVDAudioStreamFormat format;
    DDP_GetAudioStreamAttributes(m_hPlayer, (WORD)m_audioStream, format);

    m_audioFormat = format.codingMode;
    m_audioChannels = format.channels;

    const TCHAR* sz = LanguageNameFromCode(format.languageCode);

    delete [] m_audioLanguage;
    m_audioLanguage = NULL;

    if (sz != NULL)
    {
        m_audioLanguage = new TCHAR [_tcslen(sz) + 1];
        _tcscpy(m_audioLanguage, sz);
    }
}
*/

void CDVDPlayer::abRepeat()
{
    Error err = GNR_OK;

    //
    // Check prerequisites before executing
    //

    VERIFYDVD(DDP_GetCurrentLocation(m_hPlayer, m_locationB));

    if( (TT_DOM == m_locationB.domain) &&
        (DPM_PLAYING == m_playbackMode ||
        DPM_PAUSED == m_playbackMode ||
        DPM_TRICKPLAY == m_playbackMode) &&
        (! m_scanSlow) &&
        1 == m_scanSpeed)
    {
        switch (m_abRepeatState)
        {
        case AB_DISABLED:
            TRACE(_T("Set A...\n"));
            VERIFYDVD(DDP_GetCurrentLocation(m_hPlayer, m_locationA));
            if (m_locationA.domain != TT_DOM)
            {
                TRACE(_T("A-B repeat is invalid at this time\n"));
                CheckUserOp(GNR_UOP_PROHIBITED);
                return;
            }
            VERIFYDVD(err = CheckUserOp(SetBookmark(&m_LocationABookmark)));
            if(IS_GNERROR(err))
            {
                return;
            }

            m_abRepeatState = AB_SETTING_B;
            break;

        case AB_SETTING_B:
            {
                TRACE(_T("Set B...\n"));

                //
                // Only set point B if we're in the same title
                // as point A and the time difference is greater
                // than MIN_REPEAT_AB_INTERVAL
                //

                if(m_locationB.title == m_locationA.title &&
                    m_locationB.titleTime.Millisecs() > m_locationA.titleTime.Millisecs() &&
                    (m_locationB.titleTime.Millisecs() - m_locationA.titleTime.Millisecs()) > MIN_REPEAT_AB_INTERVAL)
                {
                    m_abRepeatState = AB_REPEATING;

                    Error e = GotoBookmark(&m_LocationABookmark);
                    VERIFYDVD(CheckUserOp(e));
                    if (e == GNR_UOP_PROHIBITED)
                    {
                        TRACE(_T("A-B repeat is invalid at this time\n"));
                        m_abRepeatState = AB_DISABLED;
                    }
                }
                else
                {
                    //
                    // Didn't pass prerequisites. Disable AB repeat
                    //

                    m_abRepeatState = AB_DISABLED;
                    CheckUserOp(GNR_UOP_PROHIBITED);
                }
            }
            break;

        case AB_REPEATING:
            TRACE(_T("Disabling A-B Repeat...\n"));
            m_abRepeatState = AB_DISABLED;
            break;
        }
    }
    else
    {
        TRACE(_T("A-B repeat is invalid at this time\n"));
        m_abRepeatState = AB_DISABLED;
        CheckUserOp(GNR_UOP_PROHIBITED);
        return;
    }
}


////////////////////////////////////////////////////////////////////////////
// The EventHandler callback is invoked from a DVD-Player specific thread.
// The CDVDPlayer maintains a queue of messages yet to be processed and will
// deal with the entire queue when Advance() is called...
//
void __stdcall CDVDPlayer::EventHandler(DWORD event, void* pvUserData, DWORD info)
{
    CDVDPlayer* pDVDPlayer = (CDVDPlayer*)pvUserData;
    EnterCriticalSection(&pDVDPlayer->m_eventLock);
    pDVDPlayer->m_events[pDVDPlayer->m_eventWrite].event = event;
    pDVDPlayer->m_events[pDVDPlayer->m_eventWrite].info = info;
    if (pDVDPlayer->m_eventRead != ((pDVDPlayer->m_eventWrite + 1) % EVENTS_STORED))
        pDVDPlayer->m_eventWrite = (pDVDPlayer->m_eventWrite + 1) % EVENTS_STORED;
    LeaveCriticalSection(&pDVDPlayer->m_eventLock);
}

bool CDVDPlayer::GetNextEvent(DWORD& event, DWORD& info)
{
    EnterCriticalSection(&m_eventLock);
    if (m_eventRead == m_eventWrite)
    {
        LeaveCriticalSection(&m_eventLock);
        return false;
    }

    event = m_events[m_eventRead].event;
    info = m_events[m_eventRead].info;
    m_eventRead = (m_eventRead + 1) % EVENTS_STORED;
    LeaveCriticalSection(&m_eventLock);

    return true;
}

void CDVDPlayer::InstallEventHandlers()
{
    ASSERT(m_hPlayer != NULL);

    InitializeCriticalSection(&m_eventLock);

    m_eventRead = 0;
    m_eventWrite = 0;

    // TODO: Don't install handlers for events we don't care about...

    DDP_InstallEventHandler(m_hPlayer, DNE_TITLE_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_PART_OF_TITLE_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_VALID_UOP_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_ANGLE_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_AUDIO_STREAM_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_SUBPICTURE_STREAM_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_DOMAIN_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_PARENTAL_LEVEL_CHANGE, EventHandler, this);
//  DDP_InstallEventHandler(m_hPlayer, DNE_BITRATE_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_STILL_ON, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_STILL_OFF, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_PLAYBACK_MODE_CHANGE, EventHandler, this);
//  DDP_InstallEventHandler(m_hPlayer, DNE_CDA_PLAYING_GAP, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_READ_ERROR, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_DISPLAY_MODE_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_STREAMS_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_SCAN_SPEED_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_PLAYBACK_SPEED_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_VIDEO_STANDARD_CHANGE, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_BREAKPOINT_REACHED, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_DRIVE_DETACHED, EventHandler, this);
    DDP_InstallEventHandler(m_hPlayer, DNE_ERROR, EventHandler, this);
}

void CDVDPlayer::RemoveEventHandlers()
{
    if (m_hPlayer == NULL)
        return;

    DDP_RemoveEventHandler(m_hPlayer, DNE_TITLE_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_PART_OF_TITLE_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_VALID_UOP_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_ANGLE_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_AUDIO_STREAM_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_SUBPICTURE_STREAM_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_DOMAIN_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_PARENTAL_LEVEL_CHANGE);
//  DDP_RemoveEventHandler(m_hPlayer, DNE_BITRATE_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_STILL_ON);
    DDP_RemoveEventHandler(m_hPlayer, DNE_STILL_OFF);
    DDP_RemoveEventHandler(m_hPlayer, DNE_PLAYBACK_MODE_CHANGE);
//  DDP_RemoveEventHandler(m_hPlayer, DNE_CDA_PLAYING_GAP);
    DDP_RemoveEventHandler(m_hPlayer, DNE_READ_ERROR);
    DDP_RemoveEventHandler(m_hPlayer, DNE_DISPLAY_MODE_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_STREAMS_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_SCAN_SPEED_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_PLAYBACK_SPEED_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_VIDEO_STANDARD_CHANGE);
    DDP_RemoveEventHandler(m_hPlayer, DNE_BREAKPOINT_REACHED);
    DDP_RemoveEventHandler(m_hPlayer, DNE_DRIVE_DETACHED);
    DDP_RemoveEventHandler(m_hPlayer, DNE_ERROR);

    DeleteCriticalSection(&m_eventLock);
}


#ifdef _DEBUG
static const TCHAR* rgszPlayerMode [] =
{
    _T("DPM_STOPPED"),
    _T("DPM_PAUSED"),
    _T("DPM_STILL"),
    _T("DPM_PLAYING"),
    _T("DPM_BUSY"),
    _T("DPM_SCANNING"),
    _T("DPM_INACTIVE"),
    _T("DPM_REVERSEPLAY"),
    _T("DPM_TRICKPLAY"),
    _T("DPM_REVERSESCAN")
};

static const TCHAR* rgszDomain [] =
{
    _T("FP_DOM"),
    _T("VMGM_DOM"),
    _T("VTSM_DOM"),
    _T("TT_DOM"),
    _T("STOP_DOM")
};


static const TCHAR* rgszAudioCodingMode [] =
{
    _T("DAM_AC3"),
    _T("DAM_MPEG1"),
    _T("DAM_MPEG2"),
    _T("DAM_LPCM"),
    _T("DAM_DTS"),
    _T("DAM_SDDS")
};

static const TCHAR* rgszVideoStandard [] =
{
    _T("VSTD_NTSC"),
    _T("VSTD_PAL"),
    _T("VSTD_SECAM"),
    _T("VSTD_HDTV"),
    _T("VSTD_UNKNOWN"),
};

static const TCHAR* rgszUOP [] =
{
    _T("TIME PLAY SEARCH"),
    _T("PTT PLAY SEARCH"),
    _T("TITLE PLAY"),
    _T("STOP"),
    _T("GO UP"),
    _T("TIME PTT SEARCH"),
    _T("PREV TOP PG SEARCH"),
    _T("NEXT PG SEARCH"),
    _T("FORWARD SCAN"),
    _T("BACKWARD SCAN"),
    _T("MENU CALL TITLE"),
    _T("MENU CALL ROOT"),
    _T("MENU CALL SUB PICTURE"),
    _T("MENU CALL AUDIO"),
    _T("MENU CALL ANGLE"),
    _T("MENU CALL PTT"),
    _T("RESUME"),
    _T("BUTTON"),
    _T("STILL OFF"),
    _T("PAUSE ON"),
    _T("AUDIO STREAM CHANGE"),
    _T("SUB PICTURE STREAM CHANGE"),
    _T("ANGLE CHANGE"),
    _T("KARAOKE MODE CHANGE"),
    _T("VIDEO MODE CHANGE"),
    _T("SCAN OFF"),
    _T("PAUSE OFF"),
    _T("unknown 1"),
    _T("unknown 2"),
    _T("unknown 3"),
    _T("unknown 4"),
    _T("unknown 5"),
    _T("unknown 6")
};

static void DumpUOP(DWORD uop)
{
    TRACE(_T("User Operations:\n"));
    for (int i = 0; i < 32; i += 1)
    {
        if (uop & (1 << i))
            TRACE(_T("\t%s\n"), rgszUOP[i]);
    }
}


struct DVDERROR
{
    Error m_error;
    TCHAR* m_sz;
};

static const DVDERROR rgerror [] =
{
    { GNR_FILE_NOT_FOUND, _T("general file not found error") },
    { GNR_FILE_IN_USE, _T("the file is currently in use") },
    { GNR_FILE_WRONG_FORMAT, _T("the file is in the wrong file format") },
    { GNR_END_OF_FILE, _T("attempt to read behind the end of a file") },
    { GNR_NOT_ENOUGH_MEMORY, _T("general not enough memory left") },
    { GNR_MEM_NOT_ALLOCATED, _T("the memory that was requested to be freed was not allocated before.") },
    { GNR_MEM_ALLOCATED_BEFORE, _T("the memory was allocated before") },
    { GNR_UNIMPLEMENTED, _T("the function is not yet implemented, and will never be") },
    { GNR_OBJECT_NOT_FOUND, _T("the requested object could not be found") },
    { GNR_OBJECT_EXISTS, _T("the object requested to be created does already exist") },
    { GNR_OBJECT_IN_USE, _T("an operation that needs exclusive access to an object, found the object already in use") },
    { GNR_OBJECT_FOUND, _T("an object that was to be inserted in a data structure with unique objects was already in there") },
    { GNR_RANGE_VIOLATION, _T("a given parameter was out of bounds") },
    { GNR_INVALID_CONFIGURE_STATE, _T("the unit was in an invalid state for configuration") },
    { GNR_OBJECT_FULL, _T("GNR_OBJECT_FULL") },
    { GNR_OBJECT_EMPTY, _T("GNR_OBJECT_EMPTY") },
    { GNR_OBJECT_NOT_ALLOCATED, _T("GNR_OBJECT_NOT_ALLOCATED") },
    { GNR_OBJECT_READ_ONLY, _T("GNR_OBJECT_READ_ONLY") },
    { GNR_OBJECT_WRITE_ONLY, _T("GNR_OBJECT_WRITE_ONLY") },
    { GNR_OPERATION_PROHIBITED, _T("GNR_OPERATION_PROHIBITED") },
    { GNR_OBJECT_INVALID, _T("GNR_OBJECT_INVALID") },
    { GNR_INSUFFICIENT_RIGHTS, _T("GNR_INSUFFICIENT_RIGHTS") },
    { GNR_TIMEOUT, _T("GNR_TIMEOUT") },
    { GNR_FILE_READ_ERROR, _T("GNR_FILE_READ_ERROR") },
    { GNR_FILE_WRITE_ERROR, _T("GNR_FILE_WRITE_ERROR") },
    { GNR_INVALID_PARAMETERS, _T("GNR_INVALID_PARAMETERS") },
    { GNR_CONNECTION_LOST, _T("GNR_CONNECTION_LOST") },
    { GNR_OPERATION_ABORTED, _T("GNR_OPERATION_ABORTED") },
    { GNR_DMA_PIP_NOT_POSSIBLE, _T("Current screen mode does not allow DMA PIP") },
    { GNR_VIDEO_STD_NOT_SUPPORTED, _T("not supported.") },
    { GNR_PIP_NOT_RUNNING, _T("GNR_PIP_NOT_RUNNING") },
    { GNR_NO_OPTIMAL_MINPIX, _T("GNR_NO_OPTIMAL_MINPIX") },
    { GNR_DEST_RECT_SIZE, _T("Destination rectangle too small or too big.") },
    { GNR_WRONG_GRAB_SIZE, _T("Dimensions of frame to grab are too big.") },
    { GNR_NO_VBLANK_IRQ, _T("An expected VBlank IRQ did not occur.") },
    { GNR_GRAB_TIMEOUT, _T("A timeout occurred during grabbing a frame.") },
    { GNR_WRONG_GRAB_FORMAT, _T("An unsupported capture format was requested") },
    { GNR_SAMPLEMODE_NOT_SUPPORTED, _T("Desired video sample mode not supported") },
    { GNR_VP_ERROR, _T("General error with Video Port") },
    { GNR_VP_NO_PORT_MATCH, _T("Video source does not match Video Port") },
    { GNR_VP_HARDWARE_IN_USE, _T("Video Port Hardware in use") },
    { GNR_VPM_ERROR, _T("General error with VPM services") },
    { GNR_VPE_ERROR, _T("General error with DirectX5/VPE services") },
    { GNR_NOT_ENOUGH_VIDEO_MEMORY, _T("GNR_NOT_ENOUGH_VIDEO_MEMORY") },
    { GNR_NO_OVERLAY_HARDWARE, _T("GNR_NO_OVERLAY_HARDWARE") },
    { GNR_OVERLAY_BUSY, _T("GNR_OVERLAY_BUSY") },
    { GNR_PRIMARY_NOT_AVAILABLE, _T("GNR_PRIMARY_NOT_AVAILABLE") },
    { GNR_VENC_PARAMS, _T("illegal parameters") },
    { GNR_MACROVISION_NOT_SUPPORTED, _T("GNR_MACROVISION_NOT_SUPPORTED") },
    { GNR_CC_NOT_SUPPORTED, _T("GNR_CC_NOT_SUPPORTED") },
    { GNR_DISPLAY_MODE_NOT_SUPPORTED, _T("The display mode could not be set") },
    { GNR_AUDIO_TYPE_NOT_SUPPORTED, _T("The audio format is not supported") },
    { GNR_NO_SPDIF_HARDWARE, _T("We do not SPDIF hardware") },
    { GNR_FRAME_ADVANCE_BOUNDARY_REACHED, _T("GNR_FRAME_ADVANCE_BOUNDARY_REACHED") },
    { GNR_CSS_NOT_SUPPORTED, _T("GNR_CSS_NOT_SUPPORTED") },
    { GNR_AUTHENTICATION_FAILED, _T("GNR_AUTHENTICATION_FAILED") },
    { GNR_DRIVE_FAILURE, _T("General drive failure") },
    { GNR_NO_VALID_DISK, _T("No valid/known disk was found") },
    { GNR_NO_DRIVE, _T("Drive does not exist/could not be found") },
    { GNR_DRIVE_DETACHED, _T("The drive has been detached -> is not available for playback") },
    { GNR_NO_DVD_DRIVE, _T("The drive is not a DVD drive (used on PCs)") },
    { GNR_INVALID_DRIVE_LETTER, _T("The drive letter specified was not correct/out of range") },
    { GNR_DISK_READ_ONLY, _T("The disk is read-only") },
    { GNR_DRIVE_LOCK_FAILED, _T("Unable to lock/unlock the drive") },
    { GNR_DRIVE_ALREADY_LOCKED, _T("The drive was already locked") },
    { GNR_DRIVE_LOAD_FAILED, _T("Could not load/unload the drive") },
    { GNR_DRIVE_NOT_LOADABLE, _T("Drive does not support loading/unloading the disk") },
    { GNR_COPY_PROTECTION_VIOLATION, _T("GNR_COPY_PROTECTION_VIOLATION") },
    { GNR_COPY_PROTECTION_FAILED, _T("GNR_COPY_PROTECTION_FAILED") },
//  { GNR_PATH_NOT_FOUND, _T("The path specified was not found") },
//  { GNR_INVALID_PATH, _T("The path specified was invalid (e.g. contained invalid letters)") },
//  { GNR_FILE_READ_ONLY, _T("GNR_FILE_READ_ONLY") },
    { GNR_UNEXPECTED_NAVIGATION_ERROR, _T("Some internal error happened") },
    { GNR_INVALID_PLAYER, _T("The player handle is invalid") },
    { GNR_INVALID_NAV_INFO, _T("The navigation information is invalid (possible causes: wrong authoring, read error from drive, internal error)") },
    { GNR_LOST_DECODER, _T("The decoder has been preempted") },
    { GNR_OPERATION_NOT_SUPPORTED, _T("This operation is (currently) not supported by the player") },
    { GNR_TITLE_NOT_FOUND, _T("The title specified does not exist") },
    { GNR_CHAPTER_NOT_FOUND, _T("The chapter specified does not exist") },
    { GNR_TIME_OUT_OF_RANGE, _T("The time specified (e.g. for a search operation) is out of range") },
    { GNR_PROGRAM_LINK_NOT_FOUND, _T("The current program does not have a next/prev/upper/etc. program") },
    { GNR_MENU_DOES_NOT_EXIST, _T("The requested menu does not exist") },
    { GNR_STREAM_NOT_FOUND, _T("The stream (audio/subpicture) does not exist") },
    { GNR_FLAGS_NOT_SUPPORTED, _T("The flags specified for this operation are not supported") },
    { GNR_BUTTON_NOT_FOUND, _T("The specified button does not exist") },
    { GNR_UNKNOWN_EVENT_TYPE, _T("The event type specified does not exist") },
    { GNR_BREAKPOINT_NOT_FOUND, _T("The breakpoint to be deleted does not exist") },
    { GNR_INVALID_UNIQUE_KEY, _T("The unique key could not be created/was invalid") },
    { GNR_UOP_PROHIBITED, _T("The current UOPs do not allow this action") },
    { GNR_REGIONS_DONT_MATCH, _T("The system and disk regions don't match") },
    { GNR_REGION_CODE_INVALID, _T("The region code specified was invalid (e.g. multiregion when trying to set region)") },
    { GNR_NO_MORE_REGION_SETS, _T("The number of region changes is exhausted") },
    { GNR_REGION_WRITE_ERROR, _T("Unable to write region") },
    { GNR_REGION_READ_ERROR, _T("Unable to read region") },
    { GNR_PARENTAL_LEVEL_TOO_LOW, _T("The parental level currently set is too low to play the disc") },
    { GNR_ILLEGAL_NAVIGATION_COMMAND, _T("The DVD contains an illegal navigation command") },
    { GNR_ILLEGAL_DOMAIN, _T("The domain is illegal for this operation") },
    { GNR_NO_RESUME_INFORMATION, _T("GNR_NO_RESUME_INFORMATION") },
};

static const TCHAR* DVDErrorText(Error error)
{
    for (int i = 0; i < countof (rgerror); i += 1)
    {
        if (rgerror[i].m_error == error)
        {
            return rgerror[i].m_sz;
        }
    }

    return NULL;
}

static void LogDvdError(const TCHAR* szFile, int nLine, Error error)
{
    const TCHAR* szError = DVDErrorText(error);
    if (szError == NULL)
        Trace(_T("\001%s(%d): DVD Error: unknown error code 0x%08x\n"), szFile, nLine, error);
    else
        Trace(_T("\001%s(%d): DVD Error: %s\n"), szFile, nLine, szError);
}

#endif

void CDVDPlayer::ProcessEvents()
{
    if (m_hPlayer == NULL)
        return;

    DWORD event, info;

    while (GetNextEvent(event, info))
    {
        switch (event)
        {
        default:
            TRACE(_T("DVD event: Unknown Event 0x%x\n"), info);
            break;

        case DNE_NONE:
            TRACE(_T("DVD event: none\n"));
            break;

        case DNE_TITLE_CHANGE:
            TRACE(_T("DVD event: Title Change %d\n"), info);
/*
            m_title = (int)info;
            CallFunction(this, _T("OnTitleChange"));
*/
            break;

        case DNE_PART_OF_TITLE_CHANGE:
            TRACE(_T("DVD event: Part Of Title Change: %d\n"), info);
/*
            m_chapter = (int)info;
            CallFunction(this, _T("OnChapterChange"));
*/
            break;

        case DNE_VALID_UOP_CHANGE:
#ifdef _DEBUG
            TRACE(_T("DVD event: Valid UOP Change 0x%08x\n"), info);
            DumpUOP(info);
#endif
            CallFunction(this, _T("OnValidUOPChange"));
            break;

        case DNE_ANGLE_CHANGE:
            TRACE(_T("DVD event: Angle Change: %d\n"), info);
/*
            m_angle = (int)info;
            CallFunction(this, _T("OnAngleChange"));
*/
            break;

        case DNE_AUDIO_STREAM_CHANGE:
            TRACE(_T("DVD event: Audio Stream Change: %d\n"), info);
/*
            {
                m_audioStream = info;
                OnAudioStreamChange();
            }
*/
            break;

        case DNE_SUBPICTURE_STREAM_CHANGE:
            TRACE(_T("DVD event: Subpicture Stream Change: %d\n"), info);
/*
            {
                int subTitle = 0;
                if (DDP_IsCurrentSubPictureEnabled(m_hPlayer))
                    subTitle = DDP_GetCurrentSubPictureStream(m_hPlayer) + 1;

                if (m_subTitle != subTitle)
                {
                    m_subTitle = subTitle;
                    OnSubPictureStreamChange();
                }
            }
*/
            break;

        case DNE_PARENTAL_LEVEL_CHANGE:
            TRACE(_T("DVD event: Parental Level Change: %d\n"), info);
            if ((int)info > m_parentalLevel)
            {
                m_parentalTooLow = true;
            }
            break;

        case DNE_BITRATE_CHANGE:
            TRACE(_T("DVD event: Bitrate Change: %d\n"), info);
            break;

        case DNE_DOMAIN_CHANGE:

#ifdef _DEBUG
            TRACE(_T("DVD event: Domain Change: %s\n"), rgszDomain[info]);
#endif
/*
            m_domain = (DVDDomain)info;
            CallFunction(this, _T("OnDomainChange"));
*/
            break;

        case DNE_STILL_ON:
            TRACE(_T("DVD event: Still On: %d\n"), info);
            break;

        case DNE_STILL_OFF:
            TRACE(_T("DVD event: Still Off: %d\n"), info);
            break;

        case DNE_PLAYBACK_MODE_CHANGE:
#ifdef _DEBUG
            TRACE(_T("DVD event: Playback Mode Change: %s\n"), rgszPlayerMode[info]);
#endif
/*
            m_playbackMode = (DVDPlayerMode)info;

            // Five minutes of pausing results in a stop...
            if (m_playbackMode == DPM_PAUSED)
                m_timeToStop = XAppGetNow() + 5.0f * 60.0f;
            else
                m_timeToStop = 0.0f;

            CallFunction(this, _T("OnPlaybackModeChange"));
*/
            break;

//      case DNE_CDA_PLAYING_GAP:
//          TRACE(_T("DVD event: Playing Gap 0x%x\n"), info);
//          break;

        case DNE_READ_ERROR:
            TRACE(_T("DVD event: Read Error 0x%x\n"), info);
/*
            // REVIEW: Should we retry here?
            cleanup();
            CallFunction(this, _T("OnErrorStop"));
*/
            break;

        case DNE_DISPLAY_MODE_CHANGE:
            TRACE(_T("DVD event: Display Mode Change: 0x%x\n"), info);
            AvSendTVEncoderOption(0, AV_OPTION_WIDESCREEN, info == DPM_16BY9 ? TRUE : FALSE, NULL);
            break;

        case DNE_STREAMS_CHANGE:
            TRACE(_T("DVD event: Streams Change 0x%x\n"), info);
            break;

        case DNE_SCAN_SPEED_CHANGE:
            TRACE(_T("DVD event: Scan Speed Change: %d\n"), info);
            break;

        case DNE_PLAYBACK_SPEED_CHANGE:
            TRACE(_T("DVD event: Playback Speed Change: %d\n"), info);
            break;

        case DNE_VIDEO_STANDARD_CHANGE:
#ifdef _DEBUG
            TRACE(_T("DVD event: Video Change: %s\n"), rgszVideoStandard[info]);
#endif
            break;

        case DNE_BREAKPOINT_REACHED:
            TRACE(_T("DVD event: Breakpoint Reached 0x%x\n"), info);
            break;

        case DNE_DRIVE_DETACHED:
            TRACE(_T("DVD event: Drive Detached 0x%x\n"), info);
            break;

        case DNE_ERROR:
            TRACE(_T("DVD event: Error 0x%x\n"), info);
            if (info == GNR_PARENTAL_LEVEL_TOO_LOW)
            {
                m_parentalTooLow = true;
            }
/*
            // REVIEW: Should we retry here?
            cleanup();
            CallFunction(this, _T("OnErrorStop"));
*/
            break;
        }
    }
}


Error CDVDPlayer::SetBookmark(CDVDBookmark* pBookmark)
{
    Error errRet = GNR_OK;

    //
    // Player initialized?
    //

    if (m_hPlayer != NULL)
    {
        //
        // Reset bookmark and make first attempt to set the bookmark. If we don't have
        // enough buffer, the call should fail returning the required buffer size.
        //

        pBookmark->Reset();

        DWORD cbSize = pBookmark->GetSize();

        errRet = DDP_Freeze(m_hPlayer, pBookmark->GetBuffer(), cbSize);

        if(IS_GNERROR(errRet))
        {
            //
            // Adjust buffer size to value returned by DDP_Freeze
            // and try again
            //

            if(pBookmark->Alloc(cbSize))
            {
                VERIFYDVD(errRet = DDP_Freeze(m_hPlayer, pBookmark->GetBuffer(), cbSize));
            }
            else
            {
                errRet = GNR_NOT_ENOUGH_MEMORY;
            }
        }

        //
        // If one of our two attempts succeeded, mark the bookmark as
        // successfully set.
        //

        if(! IS_GNERROR(errRet))
        {
            pBookmark->Set();
        }
    }
    else
    {
        //
        // Error, player not initialized
        //

        errRet = GNR_ERROR;
    }

    return errRet;
}

Error CDVDPlayer::GotoBookmark(CDVDBookmark* pBookmark)
{
    Error errRet = GNR_OK;

    //
    // Player initialized?
    //

    if (m_hPlayer != NULL)
    {
        if(pBookmark->IsSet())
        {

            //
            // Activate bookmark
            //

            DWORD dwSize = pBookmark->GetSize();
            VERIFYDVD(errRet = DDP_Defrost(m_hPlayer, pBookmark->GetBuffer(), dwSize));

            if(!IS_GNERROR(errRet))
                {
                m_bScanBackward = false;
                m_scanSpeed = 1;
                m_scanSlow = false;
                }
        }
        else
        {
            errRet = GNR_OBJECT_INVALID;
        }
    }
    else
    {
        //
        // Error, player not initialized
        //

        errRet = GNR_ERROR;
    }

    return errRet;
}

void CDVDPlayer::enableWideScreen()
{
    AvSendTVEncoderOption(0, AV_OPTION_WIDESCREEN, TRUE, NULL);
}

void CDVDPlayer::disableWideScreen()
{
    AvSendTVEncoderOption(0, AV_OPTION_WIDESCREEN, FALSE, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\fft.h ===
#define FFT_BUFFER_SIZE_LOG 8
#define FFT_BUFFER_SIZE (1 << FFT_BUFFER_SIZE_LOG)
typedef short int sound_sample;
typedef struct _struct_fft_state fft_state;
fft_state* fft_init (void);
void fft_perform (const sound_sample* input, float* output, fft_state* state);
void fft_close (fft_state* state);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\fft.cpp ===
#include "std.h"
#include "fft.h"

#define PI 3.14159265358979323846f

struct _struct_fft_state
{
    /* Temporary data stores to perform FFT in. */
    float real [FFT_BUFFER_SIZE];
    float imag [FFT_BUFFER_SIZE];
};

static void fft_prepare(const sound_sample *input, float * re, float * im);
static void fft_calculate(float * re, float * im);
static void fft_output(const float *re, const float *im, float *output);
static int reverseBits(unsigned int initial);

/* Table to speed up bit reverse copy */
static unsigned int bitReverse [FFT_BUFFER_SIZE];

/* The next two tables could be made to use less space in memory, since they
 * overlap hugely, but hey. */
static float sintable [FFT_BUFFER_SIZE / 2];
static float costable [FFT_BUFFER_SIZE / 2];

/*
 * Initialisation routine - sets up tables and space to work in.
 * Returns a pointer to internal state, to be used when performing calls.
 * On error, returns NULL.
 * The pointer should be freed when it is finished with, by fft_close().
 */
fft_state* fft_init(void)
{
    fft_state *state;
    unsigned int i;

    state = (fft_state*)malloc(sizeof (fft_state));
    if (state == NULL)
	return NULL;

    for (i = 0; i < FFT_BUFFER_SIZE; i++)
	bitReverse[i] = reverseBits(i);

    for (i = 0; i < FFT_BUFFER_SIZE / 2; i++)
    {
	float j = 2.0f * PI * (float)i / (float)FFT_BUFFER_SIZE;

	costable[i] = cosf(j);
	sintable[i] = sinf(j);
    }

    return state;
}

/*
 * Do all the steps of the FFT, taking as input sound data (as described in
 * sound.h) and returning the intensities of each frequency as floats in the
 * range 0 to ((FFT_BUFFER_SIZE / 2) * 32768) ^ 2
 *
 * FIXME - the above range assumes no frequencies present have an amplitude
 * larger than that of the sample variation.  But this is false: we could have
 * a wave such that its maximums are always between samples, and it's just
 * inside the representable range at the places samples get taken.
 * Question: what _is_ the maximum value possible.  Twice that value?  Root
 * two times that value?  Hmmm.  Think it depends on the frequency, too.
 *
 * The input array is assumed to have FFT_BUFFER_SIZE elements,
 * and the output array is assumed to have (FFT_BUFFER_SIZE / 2 + 1) elements.
 * state is a (non-NULL) pointer returned by fft_init.
 */
void fft_perform(const sound_sample* input, float* output, fft_state* state)
{
    /* Convert data from sound format to be ready for FFT */
    fft_prepare(input, state->real, state->imag);

    /* Do the actual FFT */
    fft_calculate(state->real, state->imag);

    /* Convert the FFT output into intensities */
    fft_output(state->real, state->imag, output);
}

/*
 * Free the state.
 */
void fft_close(fft_state *state)
{
    if (state != NULL)
	free(state);
}

/*
 * Prepare data to perform an FFT on
 */
static void fft_prepare(const sound_sample* input, float* re, float* im)
{
    unsigned int i;
    float* realptr = re;
    float* imagptr = im;
    
    /* Get input, in reverse bit order */
    for (i = 0; i < FFT_BUFFER_SIZE; i++)
    {
	*realptr++ = input[bitReverse[i]];
	*imagptr++ = 0;
    }
}

/*
 * Take result of an FFT and calculate the intensities of each frequency
 * Note: only produces half as many data points as the input had.
 * This is roughly a consequence of the Nyquist sampling theorm thingy.
 * (FIXME - make this comment better, and helpful.)
 * 
 * The two divisions by 4 are also a consequence of this: the contributions
 * returned for each frequency are split into two parts, one at i in the
 * table, and the other at FFT_BUFFER_SIZE - i, except for i = 0 and
 * FFT_BUFFER_SIZE which would otherwise get float (and then 4* when squared)
 * the contributions.
 */
static void fft_output(const float* re, const float* im, float* output)
{
    float* outputptr = output;
    const float* realptr = re;
    const float* imagptr = im;
    float* endptr = output + FFT_BUFFER_SIZE / 2;
 
    while (outputptr <= endptr)
    {
	*outputptr = (*realptr * *realptr) + (*imagptr * *imagptr);
	outputptr++; realptr++; imagptr++;
    }

    /* Do divisions to keep the constant and highest frequency terms in scale
     * with the other terms. */
    *output /= 4;
    *endptr /= 4;
}

/*
 * Actually perform the FFT
 */
static void fft_calculate(float* re, float* im)
{
    unsigned int i, j, k;
    unsigned int exchanges;
    float fact_real, fact_imag;
    float tmp_real, tmp_imag;
    unsigned int factfact;
    
    /* Set up some variables to reduce calculation in the loops */
    exchanges = 1;
    factfact = FFT_BUFFER_SIZE / 2;

    /* Loop through the divide and conquer steps */
    for (i = FFT_BUFFER_SIZE_LOG; i != 0; i--)
    {
	/* In this step, we have 2 ^ (i - 1) exchange groups, each with
	 * 2 ^ (FFT_BUFFER_SIZE_LOG - i) exchanges
	 */
	/* Loop through the exchanges in a group */
	for (j = 0; j != exchanges; j++)
	{
	    /* Work out factor for this exchange
	     * factor ^ (exchanges) = -1
	     * So, real = cos(j * PI / exchanges),
	     *     imag = sin(j * PI / exchanges)
	     */
	    fact_real = costable[j * factfact];
	    fact_imag = sintable[j * factfact];
	    
	    /* Loop through all the exchange groups */
	    for (k = j; k < FFT_BUFFER_SIZE; k += exchanges << 1)
	    {
		int k1 = k + exchanges;
		/* newval[k]  := val[k] + factor * val[k1]
		 * newval[k1] := val[k] - factor * val[k1]
		 **/

		tmp_real = fact_real * re[k1] - fact_imag * im[k1];
		tmp_imag = fact_real * im[k1] + fact_imag * re[k1];
		re[k1] = re[k] - tmp_real;
		im[k1] = im[k] - tmp_imag;
		re[k] += tmp_real;
		im[k] += tmp_imag;
	    }
	}

	exchanges <<= 1;
	factfact >>= 1;
    }
}

static int reverseBits(unsigned int initial)
{
    unsigned int reversed = 0, loop;

    for (loop = 0; loop < FFT_BUFFER_SIZE_LOG; loop++)
    {
	reversed <<= 1;
	reversed += (initial & 1);
	initial >>= 1;
    }

    return reversed;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\falloff.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "Camera.h"


extern D3DXMATRIX g_matPosition;

#include "effect.h"
#include "effect2.h"
#include "effect3.h"
#include "effect4.h"
#include "aniso.h"


struct SHADEDESC
{
	int m_nEffect;
	DWORD* m_rgdwMicrocode;
	DWORD m_fvf;
	DWORD m_dwShader;
	bool m_bReportedError;
};

#define SHADERNAME(name) dw##name##VertexShader

SHADEDESC fixed_shaders [] =
{
	{
		0,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		2,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
};

SHADEDESC shaders [] =
{
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		1,
		SHADERNAME(Effect2),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
	{
		2,
		SHADERNAME(Aniso),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
	{
		3,
		SHADERNAME(Effect3),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3 | D3DFVF_TEX1
	},
	{
		4,
		SHADERNAME(Effect4),
		D3DFVF_XYZ | D3DFVF_NORMPACKED3
	},
    // Temporary shaders for uncompressed normals
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_DIFFUSE
	},
	{
		1,
		SHADERNAME(Effect),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
	{
		1,
		SHADERNAME(Effect2),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1
	},
	{
		2,
		SHADERNAME(Aniso),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
	{
		3,
		SHADERNAME(Effect3),
		D3DFVF_XYZ | D3DFVF_NORMAL | D3DFVF_TEX1
	},
	{
		4,
		SHADERNAME(Effect4),
		D3DFVF_XYZ | D3DFVF_NORMAL
	},
};

DWORD GetEffectShader(int nEffect, DWORD fvf)
{
	if (nEffect == 0)
		return fvf;

	SHADEDESC* pShadeDesc = shaders;
	for (int i = 0; pShadeDesc->m_nEffect != nEffect || pShadeDesc->m_fvf != fvf; i += 1, pShadeDesc += 1)
	{
		if (i >= countof (shaders) - 1)
		{
			TRACE(_T("\001Cannot find effect %d shader for fvf: 0x%08x\n"), nEffect, fvf);
			return fvf;
		}
	}

	if (pShadeDesc->m_dwShader == 0)
	{
		const DWORD* rgdwFunction = NULL;

		ASSERT(pShadeDesc->m_rgdwMicrocode != NULL);
		rgdwFunction = pShadeDesc->m_rgdwMicrocode;

		static DWORD decl1 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_NORMPACKED3 ), // Normal
			D3DVSD_END()
		};

		static DWORD decl2 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_NORMPACKED3 ), // Normal
			D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
			D3DVSD_END()
		};

		static DWORD decl3 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
			D3DVSD_END()
		};

		static DWORD decl4 [] = 
		{
			D3DVSD_STREAM( 0 ),
			D3DVSD_REG( 0, D3DVSDT_FLOAT3 ), // Position of first mesh
			D3DVSD_REG( 3, D3DVSDT_FLOAT3 ), // Normal
			D3DVSD_REG( 6, D3DVSDT_FLOAT2 ), // Tex coords
			D3DVSD_END()
		};

//		DWORD decl [MAX_FVF_DECL_SIZE];
//		VERIFYHR(D3DXDeclaratorFromFVF(fvf, decl));

		if (fvf & D3DFVF_NORMPACKED3) 
		{
			XAppCreateVertexShader(/*decl*/ (fvf & D3DFVF_TEX1) ? decl2 : decl1, rgdwFunction, &pShadeDesc->m_dwShader, 0);
		}
		else 
		{
			XAppCreateVertexShader(/*decl*/ (fvf & D3DFVF_TEX1) ? decl4 : decl3, rgdwFunction, &pShadeDesc->m_dwShader, 0);
		}
	}

	return pShadeDesc->m_dwShader;
}

DWORD GetFixedFunctionShader(DWORD fvf)
{
	SHADEDESC* pShadeDesc = fixed_shaders;
	for (int i = 0; pShadeDesc->m_fvf != fvf; i += 1, pShadeDesc += 1)
	{
		if (i >= countof (fixed_shaders) - 1)
		{
			if (fvf & D3DFVF_NORMAL)
			{
//				TRACE(_T("\001Cannot find compressed fixed function shader for fvf: 0x%08x\n"), fvf);
			}

			return fvf;
		}
	}

	if (pShadeDesc->m_dwShader == 0)
	{
		static DWORD decl[3][5] = 
		{
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_REG( D3DVSDE_DIFFUSE, D3DVSDT_D3DCOLOR ), // Diffuse color
				D3DVSD_END()
			},
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_END()
			},
			{
				D3DVSD_STREAM( 0 ),
				D3DVSD_REG( D3DVSDE_POSITION, D3DVSDT_FLOAT3 ), // Position of first mesh
				D3DVSD_REG( D3DVSDE_NORMAL, D3DVSDT_NORMPACKED3 ), // Normal
				D3DVSD_REG( D3DVSDE_TEXCOORD0, D3DVSDT_FLOAT2 ), // Tex coords
				D3DVSD_END()
			},
		};

		XAppCreateVertexShader(&decl[i][0], NULL, &pShadeDesc->m_dwShader, 0);
	}

	return pShadeDesc->m_dwShader;
}

DWORD CompressNormal(float* pvNormal) {

    float vNormal[3];
    float fLength;

    fLength = (float)sqrt(pvNormal[0] * pvNormal[0] + pvNormal[1] * pvNormal[1] + pvNormal[2] * pvNormal[2]);

    vNormal[0] = pvNormal[0] / fLength;
    vNormal[1] = pvNormal[1] / fLength;
    vNormal[2] = pvNormal[2] / fLength;

    return ((((DWORD)(vNormal[0] * 1023.0f) & 0x7FF) << 0)  |
            (((DWORD)(vNormal[1] * 1023.0f) & 0x7FF) << 11) |
            (((DWORD)(vNormal[2] *  511.0f) & 0x3FF) << 22));
}


extern D3DXMATRIX g_matView;
extern D3DXMATRIX g_matProjection;

void SetReflectShaderFrameValues()
{
    D3DXMATRIX mat, worldView;

    D3DXMatrixMultiply(&worldView, XAppGetWorld(), &g_matView);

     // World/View
    D3DXMatrixTranspose(&mat, &worldView);
    XAppSetVertexShaderConstant(40, &mat(0,0), 4);

    // Projection
    D3DXMatrixTranspose(&mat, &g_matProjection);
    XAppSetVertexShaderConstant(44, &mat(0,0), 4);

    XAppSetVertexShaderConstant(48, &D3DXVECTOR4(0.0f, 0.0f, 1.0f, 0.5f), 1);

	D3DXVECTOR4 lightDir(1.0f, 1.0f, -1.0f, 0.0f);
	D3DXVec4Normalize(&lightDir, &lightDir);
	D3DXMatrixTranspose(&mat, &worldView);
	D3DXVec3TransformNormal((D3DXVECTOR3*)&lightDir, (D3DXVECTOR3*)&lightDir, &mat);
	D3DXVec4Normalize(&lightDir, &lightDir);
	XAppSetVertexShaderConstant(49, &lightDir, 1);

    XAppSetRenderState(D3DRS_LIGHTING, FALSE);
}



void SetFalloffShaderFrameValues()
{
	D3DXMATRIX mat, worldView;

	D3DXMatrixMultiply(&worldView, XAppGetWorld(), &g_matView);

	// World/View/Projection
	D3DXMatrixMultiply(&mat, &worldView, &g_matProjection);
	D3DXMatrixTranspose(&mat, &mat);
	XAppSetVertexShaderConstant(0, &mat(0,0), 4);

	// Position Transform
	D3DXMatrixTranspose(&mat, &worldView);
	XAppSetVertexShaderConstant(10, &mat(0,0), 4);

	// Normal Transform
	D3DXMatrixInverse(&mat, NULL, &worldView);
	XAppSetVertexShaderConstant(5, &mat(0,0), 4);

	D3DXVECTOR4 v(0.0f, 0.5f, 1.0f, -1.0f);
	XAppSetVertexShaderConstant(9, &v, 1);
	
	D3DXVECTOR4 lightDir(1.0f, 1.0f, -1.0f, 0.0f);
	D3DXVec4Normalize(&lightDir, &lightDir);
	D3DXMatrixTranspose(&mat, &worldView);
	D3DXVec3TransformNormal((D3DXVECTOR3*)&lightDir, (D3DXVECTOR3*)&lightDir, &mat);
	D3DXVec4Normalize(&lightDir, &lightDir);
	XAppSetVertexShaderConstant(4, &lightDir, 1);

	XAppSetTexture(0, NULL);
	XAppSetRenderState(D3DRS_LIGHTING, FALSE);
}

float g_nEffectAlpha = 1.0f;

void SetFalloffShaderValues(const D3DXCOLOR& sideColor, const D3DXCOLOR& frontColor)
{
	D3DXVECTOR4 v;

	v.x = sideColor.r;
	v.y = sideColor.g;
	v.z = sideColor.b;
	v.w = sideColor.a * g_nEffectAlpha;
	XAppSetVertexShaderConstant(15, &v, 1);

	v.x = frontColor.r - sideColor.r;
	v.y = frontColor.g - sideColor.g;
	v.z = frontColor.b - sideColor.b;
	v.w = (frontColor.a - sideColor.a) * g_nEffectAlpha;
	XAppSetVertexShaderConstant(16, &v, 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\FileUtil.h ===
#pragma once

bool DoesFileExist(const TCHAR* szFileName);

void MakePath(TCHAR* szBuf, const TCHAR* szDir, const TCHAR* szFile);

int GetDirectoryBlocks(const TCHAR* szDirPath, int nBlockSize, bool bRecursive, HANDLE hCancelEvent);
int GetFileBlocks(const TCHAR* szFilePath, int nBlockSize);

void CleanFilePath(char* szPath, const TCHAR* szSrcPath);
#ifdef _UNICODE
void CleanFilePath(TCHAR* szPath, const TCHAR* szSrcPath);
#endif

void UpdateCurDirFromFile(const TCHAR* szURL);
void MakeAbsoluteURL2(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL);
void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szBase, const TCHAR* szURL);
void MakeAbsoluteURL(TCHAR* szBuf, const TCHAR* szURL);

DWORD GetUniqueFile(const TCHAR* szBase, TCHAR* szPath/*=NULL*/);
DWORD CreateUniqueDir(const TCHAR* szBase);

bool DeleteDirectory(const TCHAR* szPath);
bool CopyDirectory(const TCHAR* szSrcPath, const TCHAR* szDestPath);

void FindFilePath(TCHAR* szFullPath/*[MAX_PATH]*/, const TCHAR* szFile);

int GetFileSize(const TCHAR* szFilePath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xapp\Group.cpp ===
#include "std.h"
#include "xapp.h"
#include "Node.h"
#include "xip.h"
#include "Camera.h"
#include "Shape.h"

IMPLEMENT_NODE("Group", CGroup, CNode)

START_NODE_PROPS(CGroup, CNode)
    NODE_PROP(pt_children, CGroup, children)
END_NODE_PROPS()

CGroup::CGroup()
{
    m_bboxCenter.x = 0.0f;
    m_bboxCenter.y = 0.0f;
    m_bboxCenter.z = 0.0f;
    m_bboxSize.x = -1.0f;
    m_bboxSize.y = -1.0f;
    m_bboxSize.z = -1.0f;
    m_bboxSpecified = true;
    m_bboxDirty = true;
}

CGroup::~CGroup()
{
}

void CGroup::GetBBox(BBox* pBBox)
{
    if (m_bboxSize.x == -1.0f && m_bboxSize.y == -1.0f && m_bboxSize.z == -1.0f)
        m_bboxSpecified = false;

    if (m_bboxDirty && !m_bboxSpecified)
    {
        int nChildCount = m_children.GetLength();
        if (nChildCount == 0)
        {
            m_bboxCenter.x = 0.0f;
            m_bboxCenter.y = 0.0f;
            m_bboxCenter.z = 0.0f;
            m_bboxSize.x = 0.0f;
            m_bboxSize.y = 0.0f;
            m_bboxSize.z = 0.0f;
        }
        else
        {
            BBox bbox;
            m_children.GetNode(0)->GetBBox(&bbox);

            float xMin = bbox.center.x - bbox.size.x;
            float yMin = bbox.center.y - bbox.size.y;
            float zMin = bbox.center.z - bbox.size.z;
            float xMax = bbox.center.x + bbox.size.x;
            float yMax = bbox.center.y + bbox.size.y;
            float zMax = bbox.center.z + bbox.size.z;

            for (int i = 1; i < nChildCount; i += 1)
            {
                m_children.GetNode(i)->GetBBox(&bbox);

                if (xMin > bbox.center.x - bbox.size.x)
                    xMin = bbox.center.x - bbox.size.x;

                if (yMin > bbox.center.y - bbox.size.y)
                    yMin = bbox.center.y - bbox.size.y;

                if (zMin > bbox.center.z - bbox.size.z)
                    zMin = bbox.center.z - bbox.size.z;

                if (xMax > bbox.center.x + bbox.size.x)
                    xMax = bbox.center.x + bbox.size.x;

                if (yMax > bbox.center.y + bbox.size.y)
                    yMax = bbox.center.y + bbox.size.y;

                if (zMax > bbox.center.z + bbox.size.z)
                    zMax = bbox.center.z + bbox.size.z;
            }

            m_bboxCenter.x = (xMax + xMin) / 2.0f;
            m_bboxCenter.y = (yMax + yMin) / 2.0f;
            m_bboxCenter.z = (zMax + zMin) / 2.0f;

            m_bboxSize.x = xMax - xMin;
            m_bboxSize.y = yMax - yMin;
            m_bboxSize.z = zMax - zMin;
        }
    }

    pBBox->center = m_bboxCenter;
    pBBox->size = m_bboxSize;
}

float CGroup::GetRadius()
{
    float radius = 0.0f;

    for (int i = 0; i < m_children.GetLength(); i += 1)
    {
        float r = m_children.GetNode(i)->GetRadius();
        if (radius < r)
            radius = r;
    }

    return radius;
}

void CGroup::Render()
{
    for (int i = 0; i < m_children.GetLength(); i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        if (pNode->m_visible)
            pNode->Render();
    }
}

void CGroup::Advance(float nSeconds)
{
    CNode::Advance(nSeconds);

    for (int i = 0; i < m_children.GetLength(); i += 1)
        m_children.GetNode(i)->Advance(nSeconds);
}

#ifdef _LIGHTS
void CGroup::SetLight(int& nLight, D3DCOLORVALUE& ambient)
{
    for (int i = 0; i < m_children.GetLength(); i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        if (pNode != NULL)
            pNode->SetLight(nLight, ambient);
    }
}
#endif

void CGroup::RenderDynamicTexture(CSurfx* pSurfx)
{
    for (int i = 0; i < m_children.GetLength(); i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        if (pNode != NULL)
            pNode->RenderDynamicTexture(pSurfx);
    }
}

LPDIRECT3DTEXTURE8 CGroup::GetTextureSurface()
{
    for (int i = 0; i < m_children.GetLength(); i += 1)
    {
        CNode* pNode = m_children.GetNode(i);
        if (pNode != NULL)
        {
            LPDIRECT3DTEXTURE8 pSurface = pNode->GetTextureSurface();
            if (pSurface != NULL)
                return pSurface;
        }
    }

    return NULL;
}


////////////////////////////////////////////////////////////////////////////

// TODO: Lights are not transformed!

IMPLEMENT_NODE("Transform", CTransform, CGroup)

START_NODE_PROPS(CTransform, CGroup)
    NODE_PROP(pt_vec3, CTransform, center) // NOTE: Ignored!
    NODE_PROP(pt_vec4, CTransform, scaleOrientation) // NOTE: Ignored!
    NODE_PROP(pt_vec3, CTransform, scale)
    NODE_PROP(pt_vec4, CTransform, rotation)
    NODE_PROP(pt_vec3, CTransform, translation)
    NODE_PROP(pt_number, CTransform, fade)
    NODE_PROP(pt_boolean, CTransform, moving)
    NODE_PROP(pt_number, CTransform, alpha)
END_NODE_PROPS()

START_NODE_FUN(CTransform, CGroup)
    NODE_FUN_VNNN(SetScale)
    NODE_FUN_VNNNN(SetScaleOrientation)
    NODE_FUN_VNNN(SetTranslation)
    NODE_FUN_VNNN(SetCenter)
    NODE_FUN_VNNNN(SetRotation)
    NODE_FUN_VN(SetAlpha)
    NODE_FUN_VN(DisappearAfter)
END_NODE_FUN()

CTransform::CTransform() :
    m_center(0.0f, 0.0f, 0.0f),
    m_scaleOrientation(0.0f, 0.0f, 1.0f, 0.0f),
    m_scale(1.0f, 1.0f, 1.0f),
    m_rotation(0.0f, 0.0f, 1.0f, 0.0f),
    m_translation(0.0f, 0.0f, 0.0f),
    m_fade(0.0f),
    m_moving(false)
{
    m_bDirty = true;
    m_alpha = 1.0f;
    m_timeCenterStart = 0.0f;
    m_timeScaleStart = 0.0f;
    m_timeScaleOrientationStart = 0.0f;
    m_timeRotationStart = 0.0f;
    m_timeTranslationStart = 0.0f;
    m_timeAlphaStart = 0.0f;
    m_timeToDisappear = 0.0;
}

void CTransform::OnLoad()
{
    CGroup::OnLoad();

    D3DXQuaternionRotationAxis(&m_rotationQuat, (D3DXVECTOR3*)&m_rotation, m_rotation.w);
}

bool CTransform::OnSetProperty(const PRD* pprd, const void* pvValue)
{
    if ((int)pprd->pbOffset == offsetof(m_rotation))
    {
        const float* p = (const float*)pvValue;
        D3DXQuaternionRotationAxis(&m_rotationQuat, (D3DXVECTOR3*)p, p[3]);
    }
    else if ((int)pprd->pbOffset == offsetof(m_alpha))
    {
        SetAlpha(*(float*)pvValue);
        return false;
    }

/*
    if ((int)pprd->pbOffset == offsetof(m_scale))
    {
        m_scaleCur = m_scale;
        m_scaleStart = m_scale;
        m_scaleEnd = *((D3DXVECTOR3*)pvValue);
        m_timeStart = XAppGetNow();
    }

    m_bDirty = true;
*/
    return CGroup::OnSetProperty(pprd, pvValue);
}

void CTransform::Advance(float nSeconds)
{
    CGroup::Advance(nSeconds);
/*
    if (m_timeStart != 0.0f && m_fade != 0.0f)
    {
        float t = (XAppGetNow() - m_timeStart) / m_fade;
        if (t > 1.0f)
        {
            t = 1.0f;
            m_timeStart = 0.0f;
        }

        D3DXVec3Lerp(&m_scaleCur, &m_scaleStart, &m_scaleEnd, t);
        m_bDirty = true;
    }
*/

    if (m_timeAlphaStart > 0.0f)
    {
        float t = (float) (XAppGetNow() - m_timeAlphaStart) / m_fade;
        if (t >= 1.0f)
        {
            t = 1.0f;
            m_timeAlphaStart = 0.0f;
        }

        m_alpha = m_alphaStart + (m_alphaEnd - m_alphaStart) * t;
    }

    if (m_timeToDisappear > 0.0f && XAppGetNow() >= m_timeToDisappear)
    {
        m_alpha = 0.0f;
        m_timeToDisappear = 0.0f;
    }
}

void CTransform::CalcMatrix()
{
    D3DXQUATERNION scaleOrientation, rotation;

    D3DXMatrixIdentity(&m_matrix);

    if (m_timeScaleStart > 0.0f)
    {
        m_moving = true;

        float t = (float) (XAppGetNow() - m_timeScaleStart) / m_fade;
        if (t >= 1.0f)
        {
            t = 1.0f;
            m_timeScaleStart = 0.0f;
        }

        D3DXVec3Lerp(&m_scale, &m_scaleStart, &m_scaleEnd, t);
    }

    if (m_timeTranslationStart > 0.0f)
    {
        m_moving = true;

        float t = (float) (XAppGetNow() - m_timeTranslationStart) / m_fade;
        if (t >= 1.0f)
        {
            t = 1.0f;
            m_timeTranslationStart = 0.0f;
        }

        D3DXVec3Lerp(&m_translation, &m_translationStart, &m_translationEnd, t);
    }

    if (m_timeRotationStart > 0.0f)
    {
        m_moving = true;

        float t = (float) (XAppGetNow() - m_timeRotationStart) / m_fade;
        if (t >= 1.0f)
        {
            t = 1.0f;
            m_timeRotationStart = 0.0f;
        }

        D3DXQuaternionSlerp(&m_rotationQuat, &m_rotationStart, &m_rotationEnd, t);
