er(FVF_TLVERTEX);

        m_pDevice->SetStreamSource(0, m_pd3dr, sizeof(TLVERTEX));

        // Draw a triangle
        m_pDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);

        // End the scene
        m_pDevice->EndScene();

        // Update the screen
        m_pDevice->Present(NULL, NULL, NULL, NULL);

    } while (TRUE);

    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     DebugString
//
// Description:
//
//     Take the formatted output and send the output to the debugger.
//
// Arguments:
//
//     LPCTSTR szFormat         - Formatting string describing the output
//
//     Variable argument list   - Data to be placed in the output string
//
// Return Value:
//
//     None.
//
//******************************************************************************
void DebugString(LPCTSTR szFormat, ...) {

    va_list vl;
    TCHAR*  szBuffer = (LPTSTR)HeapAlloc(GetProcessHeap(), 0, 2304 * sizeof(TCHAR));
    if (!szBuffer) {
        OutputDebugString(TEXT("Insufficient memory for logging buffer allocation\n"));
        __asm int 3;
    }

    va_start(vl, szFormat);
    _vstprintf(szBuffer, szFormat, vl);
    va_end(vl);

    _tcscat(szBuffer, TEXT("\r\n"));

    OutputDebugString(szBuffer);

    HeapFree(GetProcessHeap(), 0, szBuffer);
}

//******************************************************************************
//
// Function:
//
//     ResultFailed
//
// Description:
//
//     Test a given return code: if the code is an error, output a debug 
//     message with the error value.  If the code is a warning, output
//     a debug message with the warning value.
//
// Arguments:
//
//     HRESULT hr               - Return code to test for an error
//
//     LPCTSTR sz               - String describing the method that produced 
//                                the return code
//
// Return Value:
//
//     TRUE if the given return code is an error, FALSE otherwise.
//
//******************************************************************************
BOOL ResultFailed(HRESULT hr, LPCTSTR sz) {

    TCHAR szError[256];

    if (SUCCEEDED(hr)) {
        return FALSE;
    }

    D3DXGetErrorString(hr, szError, 256);

    if (FAILED(hr)) {
        DebugString(TEXT("%s failed with %s [0x%X]"), sz, szError, hr);
        return TRUE;
    }
    else {
        DebugString(TEXT("%s returned %s [0x%X]"), sz, szError, hr);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\chessbrd\chessbrd.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    chessbrd.cpp

Author:

    Matt Bronder

Description:

    Test functions.

*******************************************************************************/

#include "d3dbase.h"
#include "chessbrd.h"

//#define PIXEL_LIGHTING
//#define FALLENKING_ILLUSION

//******************************************************************************
//
// Function:
//
//     TextureProjectXY
//
// Description:
//
//     Initialize the texture coordinates of the given mesh for a parallel
//     projection onto the XY plane.
//
// Arguments:
//
//     PVERTEX pr               - Array of vertices on which to project the 
//                                texture
//
//     UINT uNumVertices        - Number of vertices in the array
//
//     float fX1                - Reference value of x at which tu will be zero
//
//     float fX2                - Reference value of x at which tu will be one
//
//     float fY1                - Reference value of y at which tv will be zero
//
//     float fY2                - Reference value of y at which tv will be one
//
// Return Value:
//
//     None.
//
//******************************************************************************
void TextureProjectXY(PVERTEX pr, UINT uNumVertices,
                      float fX1, float fX2, float fY1, float fY2) 
{
    float    fWidth, fHeight;
    UINT     i;

    if (!pr) {
        return;
    }

    fWidth = fX2 - fX1;
    fHeight = fY2 - fY1;

    for (i = 0; i < uNumVertices; i++) {

        pr[i].u0 = (pr[i].vPosition.x - fX1) / fWidth;
        pr[i].v0 = (pr[i].vPosition.y - fY1) / fHeight;
    }
}

/*
void TextureProjectXYD(PVERTEX pr, UINT uNumVertices,
                      float fX1, float fX2, float fY1, float fY2) 
{
    float    fWidth, fHeight;
    UINT     i;
    float    fLeft = FLT_MAX;
    float    fRight = -FLT_MAX;
    float    fTop = -FLT_MAX;
    float    fBottom = FLT_MAX;

    if (!pr) {
        return;
    }

    fWidth = fX2 - fX1;
    fHeight = fY2 - fY1;

    for (i = 0; i < uNumVertices; i++) {

        if (pr[i].vPosition.x < fLeft) {
            fLeft = pr[i].vPosition.x;
        }
        if (pr[i].vPosition.x > fRight) {
            fRight = pr[i].vPosition.x;
        }
        if (pr[i].vPosition.y > fTop) {
            fTop = pr[i].vPosition.y;
        }
        if (pr[i].vPosition.y < fBottom) {
            fBottom = pr[i].vPosition.y;
        }
        pr[i].u0 = (pr[i].vPosition.x - fX1) / fWidth;
        pr[i].v0 = (pr[i].vPosition.y - fY1) / fHeight;
    }

    DebugString(TEXT("x: %3.3f to %3.3f, y: %3.3f to %3.3f"), fLeft, fRight, fTop, fBottom);
}
*/

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
BOOL ExhibitScene(CDisplay* pDisplay, int* pnExitCode) {

    CChessboard*    pChessBoard;
    BOOL            bRet;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    // Create the scene
    pChessBoard = new CChessboard();
    if (!pChessBoard) {
        return FALSE;
    }

    // Initialize the scene
    if (!pChessBoard->Create(pDisplay)) {
        pChessBoard->Release();
        return FALSE;
    }

    bRet = pChessBoard->Exhibit(pnExitCode);

    // Clean up the scene
    pChessBoard->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8* pd3d                - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
// CChessboard
//******************************************************************************

//******************************************************************************
//
// Method:
//
//     CChessboard
//
// Description:
//
//     Initialize the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CChessboard::CChessboard() {

    m_pd3dtBoardSurface = NULL;
    m_pd3dtBoardEdge = NULL;
    m_pd3dtPawn = NULL;
    m_pd3dtFallen = NULL;
    m_fTranslationDelta = 0.0f;
    m_fXRotationDelta = 0.0f;
    m_fYRotationDelta = 0.0f;
    m_bRotateCamera = TRUE;
    m_bFade = TRUE;
    memset(m_cmChessMesh, 0, 6 * sizeof(CHESSMESH));
    m_vLightDir = D3DXVECTOR3(1.0f, -1.0f, 1.0f);
}

//******************************************************************************
//
// Method:
//
//     ~CChessboard
//
// Description:
//
//     Clean up the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CChessboard::~CChessboard() {
}

//******************************************************************************
//
// Method:
//
//     Create
//
// Description:
//
//     Prepare the test for rendering.
//
// Arguments:
//
//     CDisplay* pDisplay               - Pointer to a Display object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CChessboard::Create(CDisplay* pDisplay) {

    D3DXMATRIX m;

    // Intialize the board surface vertices
    m_prBoardSurface[0] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 2.0f);
    m_prBoardSurface[1] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 0.0f);
    m_prBoardSurface[2] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 2.0f, 0.0f);
    m_prBoardSurface[3] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 2.0f, 2.0f);

    // Intialize the board edge vertices
    m_prBoardEdge[0][0] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 12.0f);
    m_prBoardEdge[0][1] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 0.0f);
    m_prBoardEdge[0][2] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 1.0f, 1.0f);
    m_prBoardEdge[0][3] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 1.0f, 11.0f);

    m_prBoardEdge[1][0] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 1.0f, 1.0f);
    m_prBoardEdge[1][1] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 0.0f);
    m_prBoardEdge[1][2] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 12.0f, 0.0f);
    m_prBoardEdge[1][3] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 11.0f, 1.0f);

    m_prBoardEdge[2][0] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 11.0f, 11.0f);
    m_prBoardEdge[2][1] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 10.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 11.0f, 1.0f);
    m_prBoardEdge[2][2] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 12.0f, 0.0f);
    m_prBoardEdge[2][3] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 12.0f, 12.0f);

    m_prBoardEdge[3][0] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 0.0f, 12.0f);
    m_prBoardEdge[3][1] = VERTEX(D3DXVECTOR3(0.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 1.0f, 11.0f);
    m_prBoardEdge[3][2] = VERTEX(D3DXVECTOR3(10.0f, 0.0f, 0.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 11.0f, 11.0f);
    m_prBoardEdge[3][3] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, 1.0f, 0.0f), 12.0f, 12.0f);

    m_prBoardEdge[4][0] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, -1.0f, 0.0f), 12.0f, 12.0f);
    m_prBoardEdge[4][1] = VERTEX(D3DXVECTOR3(11.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, -1.0f, 0.0f), 12.0f, 0.0f);
    m_prBoardEdge[4][2] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, 11.0f), D3DXVECTOR3(0.0f, -1.0f, 0.0f), 0.0f, 0.0f);
    m_prBoardEdge[4][3] = VERTEX(D3DXVECTOR3(-1.0f, 0.0f, -1.0f), D3DXVECTOR3(0.0f, -1.0f, 0.0f), 0.0f, 12.0f);

    // Initialize the reflection screen
    m_plrScreen[0][0] = LVERTEX(D3DXVECTOR3(-101.0f, 0.0f, -101.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][1] = LVERTEX(D3DXVECTOR3(-1.0f, 0.0f, -1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][2] = LVERTEX(D3DXVECTOR3(11.0f, 0.0f, -1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][3] = LVERTEX(D3DXVECTOR3(111.0f, 0.0f, -101.0f), 0, 0, 0.0f, 0.0f);

    m_plrScreen[1][0] = LVERTEX(D3DXVECTOR3(111.0f, 0.0f, -101.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][1] = LVERTEX(D3DXVECTOR3(11.0f, 0.0f, -1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][2] = LVERTEX(D3DXVECTOR3(11.0f, 0.0f, 11.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][3] = LVERTEX(D3DXVECTOR3(111.0f, 0.0f, 111.0f), 0, 0, 0.0f, 0.0f);

    m_plrScreen[2][0] = LVERTEX(D3DXVECTOR3(111.0f, 0.0f, 111.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][1] = LVERTEX(D3DXVECTOR3(11.0f, 0.0f, 11.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][2] = LVERTEX(D3DXVECTOR3(-1.0f, 0.0f, 11.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][3] = LVERTEX(D3DXVECTOR3(-101.0f, 0.0f, 111.0f), 0, 0, 0.0f, 0.0f);

    m_plrScreen[3][0] = LVERTEX(D3DXVECTOR3(-101.0f, 0.0f, 111.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[3][1] = LVERTEX(D3DXVECTOR3(-1.0f, 0.0f, 11.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[3][2] = LVERTEX(D3DXVECTOR3(-1.0f, 0.0f, -1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[3][3] = LVERTEX(D3DXVECTOR3(-101.0f, 0.0f, -101.0f), 0, 0, 0.0f, 0.0f);

    // Initialize world transforms
    InitMatrix(&m_mBoard,
        (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 1.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 1.0), (float)( 0.0),
        (float)(-5.0), (float)(-5.0), (float)(-5.0), (float)( 1.0)
    );

    InitMatrix(&m,
        (float)( 0.3), (float)( 0.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 0.3), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 0.3), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 0.0), (float)( 1.0)
    );

    InitMatrix(&m_mPawn,
        (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 1.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 1.0), (float)( 0.0),
        (float)( 0.6), (float)(-5.0), (float)( 0.6), (float)( 1.0)
    );

    InitMatrix(&m_mReflection,
        (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( cos(M_PI)), (float)( sin(M_PI)), (float)( 0.0),
        (float)( 0.0), (float)(-sin(M_PI)), (float)( cos(M_PI)), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 0.0), (float)( 1.0)
    );

    D3DXMatrixMultiply(&m_mReflection, &m, &m_mReflection);
    D3DXMatrixMultiply(&m_mReflection, &m_mReflection, &m_mPawn);

    // Create the pawn material
    SetMaterial(&m_matPawn, RGBA_MAKE(255, 255, 255, 255), 
                                RGBA_MAKE(64, 64, 64, 255), RGBA_MAKE(255, 255, 255, 255), 
                                RGBA_MAKE(0, 0, 0, 255), 40.0f);

    // Create the board edge material
    SetMaterial(&m_matBoardEdge, RGBA_MAKE(255, 255, 255, 255), 
                                RGBA_MAKE(192, 192, 192, 255), RGBA_MAKE(96, 96, 96, 255), 
                                RGBA_MAKE(0, 0, 0, 255), 10.0f);

    // Create the board surface material
    SetMaterial(&m_matBoardSurface, RGB_MAKE(255, 255, 255), RGB_MAKE(192, 192, 192),
                                RGB_MAKE(96, 96, 96), RGB_MAKE(0, 0, 0), 40.0f);
    SetMaterialTranslucency(&m_matBoardSurface, 0.4f);

    return CScene::Create(pDisplay);
}

//******************************************************************************
//
// Method:
//
//     Exhibit
//
// Description:
//
//     Execute the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The exit value contained in the wParam parameter of the WM_QUIT message.
//
//******************************************************************************
int CChessboard::Exhibit(int *pnExitCode) {

    return CScene::Exhibit(pnExitCode);
}

//******************************************************************************
//
// Method:
//
//     Setup
//
// Description:
//
//     Obtain the device interface pointer from the display, save the current
//     state of the device, and initialize the background vertices to the
//     dimensions of the render target.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared for initialization, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CChessboard::Setup() {

    return CScene::Setup();
}

#define SQUAREORIGIN -4.4f
#define SQUAREDIM    1.25f

//******************************************************************************
//
// Method:
//
//     Initialize
//
// Description:
//
//     Initialize the device and all device objects to be used in the test (or
//     at least all device resource objects to be created in the video, 
//     non-local video, or default memory pools).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the test was successfully initialized for rendering, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CChessboard::Initialize() {

    D3DXMATRIX mRotate, mTransform, m;
    MESH       mesh;
    UINT       i, j;
    LPTSTR     pszChessMesh[6] = {
                    TEXT("lpawn.xdg"),
                    TEXT("lrook.xdg"), 
                    TEXT("sknight.xdg"),
                    TEXT("lbishop.xdg"),
                    TEXT("lqueen.xdg"),
                    TEXT("lking.xdg")
    };

    if (!CScene::Initialize()) {
        return FALSE;
    }

    // Create the textures
    m_pd3dtBoardSurface = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("chess.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 256, 256);
    m_pd3dtBoardEdge = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("edge.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 128, 128);
    m_pd3dtPawn = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("pine.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 128, 128);
    m_pd3dtFallen = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("pine2.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 128, 128);
#ifdef UNDER_XBOX
    m_pd3dtBoardSurface->MoveResourceMemory(D3DMEM_VIDEO);
    m_pd3dtBoardEdge->MoveResourceMemory(D3DMEM_VIDEO);
    m_pd3dtPawn->MoveResourceMemory(D3DMEM_VIDEO);
    m_pd3dtFallen->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

#ifdef PIXEL_LIGHTING

    m_pd3dtcNorm = CreateNormalMap(m_pDevice, 256, 0.075f, D3DFMT_A8R8G8B8, TRUE);
    if (!m_pd3dtcNorm) {
        return FALSE;
    }

    m_pd3dtcHVec = CreateHalfVectorMap(m_pDevice, &m_vLightDir, 32, D3DFMT_A8R8G8B8, TRUE);
    if (!m_pd3dtcHVec) {
        return FALSE;
    }

#endif

    for (i = 0; i < 6; i++) {

        if (!CreateMesh(pszChessMesh[i], &mesh)) {
            return FALSE;
        }

        TextureProjectXY(mesh.prVertices, mesh.uNumVertices, -8.584f, 8.584f, 0.0f, 24.714f);

#ifndef PIXEL_LIGHTING

        InitMatrix(&m,
            (float)( 0.1), (float)( 0.0), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 0.1), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 0.0), (float)( 0.1), (float)( 0.0),
            (float)( 0.0), (float)( 0.0), (float)( 0.0), (float)( 1.0)
        );

        for (j = 0; j < mesh.uNumVertices; j++) {
            D3DXVec3TransformCoord(&mesh.prVertices[j].vPosition, &mesh.prVertices[j].vPosition, &m);
        }

#endif

        m_cmChessMesh[i].pd3dr = CreateVertexBuffer(m_pDevice, mesh.prVertices, mesh.uNumVertices * sizeof(VERTEX), 0, FVF_VERTEX);
        if (!m_cmChessMesh[i].pd3dr) {
            return FALSE;
        }

#ifdef UNDER_XBOX
        m_cmChessMesh[i].pd3dr->MoveResourceMemory(D3DMEM_VIDEO);
#endif

        m_cmChessMesh[i].pd3di = CreateIndexBuffer(m_pDevice, mesh.pwIndices, mesh.uNumIndices * sizeof(WORD));
        if (!m_cmChessMesh[i].pd3di) {
            return FALSE;
        }

        m_cmChessMesh[i].uNumVertices = mesh.uNumVertices;
        m_cmChessMesh[i].uNumIndices = mesh.uNumIndices;
        m_cmChessMesh[i].uNumPrimitives = mesh.uNumIndices / 3;

        ReleaseMesh(&mesh);
    }

    for (i = 0; i < 7; i++) {
        if (i < 6) {
            j = i;
        }
        else {
            j = 5;
        }
        m_cpPiece[i].pcmMesh = &m_cmChessMesh[j];
        m_cpReflection[i].pcmMesh = &m_cmChessMesh[j];
        m_cpPiece[i].mWorld = m_mIdentity;
#ifdef PIXEL_LIGHTING
        m_cpPiece[i].mWorld._11 = 0.1f;
        m_cpPiece[i].mWorld._22 = 0.1f;
        m_cpPiece[i].mWorld._33 = 0.1f;
#endif
        m_cpPiece[i].mWorld._42 = -5.0f;
        m_cpReflection[i].mWorld = m_mIdentity;
#ifdef PIXEL_LIGHTING
        m_cpReflection[i].mWorld._11 = 0.1f;
        m_cpReflection[i].mWorld._22 = 0.1f;
        m_cpReflection[i].mWorld._33 = 0.1f;
#endif
        m_cpReflection[i].mWorld._42 = -5.0f;
    }
    m_cpPiece[PAWN].mWorld._41 = m_cpReflection[PAWN].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 2.0f;
    m_cpPiece[PAWN].mWorld._43 = m_cpReflection[PAWN].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 2.0f;
    m_cpPiece[ROOK].mWorld._41 = m_cpReflection[ROOK].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 4.0f;
    m_cpPiece[ROOK].mWorld._43 = m_cpReflection[ROOK].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 1.0f;
    m_cpPiece[KNIGHT].mWorld._41 = m_cpReflection[KNIGHT].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 5.0f;
    m_cpPiece[KNIGHT].mWorld._43 = m_cpReflection[KNIGHT].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 3.0f;
    m_cpPiece[BISHOP].mWorld._41 = m_cpReflection[BISHOP].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 5.0f;
    m_cpPiece[BISHOP].mWorld._43 = m_cpReflection[BISHOP].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 2.0f;
    m_cpPiece[QUEEN].mWorld._41 = m_cpReflection[QUEEN].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 2.0f;
    m_cpPiece[QUEEN].mWorld._43 = m_cpReflection[QUEEN].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 4.0f;
    m_cpPiece[KING].mWorld._41 = m_cpReflection[KING].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 4.0f;
    m_cpPiece[KING].mWorld._43 = m_cpReflection[KING].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 6.0f;
    m_cpPiece[FALLENKING].mWorld._41 = m_cpReflection[FALLENKING].mWorld._41 = SQUAREORIGIN + SQUAREDIM * 5.0f;
    m_cpPiece[FALLENKING].mWorld._43 = m_cpReflection[FALLENKING].mWorld._43 = SQUAREORIGIN + SQUAREDIM * 5.0f;

    InitMatrix(&mRotate,
        (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
        (float)( 0.0), (float)( cos(M_PI)), (float)( sin(M_PI)), (float)( 0.0),
        (float)( 0.0), (float)(-sin(M_PI)), (float)( cos(M_PI)), (float)( 0.0),
        (float)( 0.0), (float)( 0.0), (float)( 0.0), (float)( 1.0)
    );

    m = m_mIdentity;
    m._11 = (float)cos(M_PI);
    m._13 = -(float)sin(M_PI);
    m._31 = (float)sin(M_PI);
    m._33 = (float)cos(M_PI);

    D3DXMatrixMultiply(&mRotate, &m, &mRotate);

    for (i = 0; i < 6; i++) {
        D3DXMatrixMultiply(&m_cpReflection[i].mWorld, &mRotate, &m_cpReflection[i].mWorld);
    }

#ifndef FALLENKING_ILLUSION
    mRotate = m_mIdentity;
#endif

    mTransform = m_mIdentity;
    mTransform._11 = (float)cos(M_PIDIV4);
    mTransform._13 = (float)-sin(M_PIDIV4);
    mTransform._31 = (float)sin(M_PIDIV4);
    mTransform._33 = (float)cos(M_PIDIV4);

    mRotate._22 = (float)cos(M_PIDIV2 * 1.035f);
    mRotate._23 = (float)sin(M_PIDIV2 * 1.035f);
    mRotate._32 = (float)-sin(M_PIDIV2 * 1.035f);
    mRotate._33 = (float)cos(M_PIDIV2 * 1.035f);

    D3DXMatrixMultiply(&m_cpPiece[FALLENKING].mWorld, &mTransform, &m_cpPiece[FALLENKING].mWorld);
    D3DXMatrixMultiply(&m_cpPiece[FALLENKING].mWorld, &mRotate, &m_cpPiece[FALLENKING].mWorld);

    mRotate._22 = (float)cos(M_PIDIV2 * 0.965f);
    mRotate._23 = (float)sin(M_PIDIV2 * 0.965f);
    mRotate._32 = (float)-sin(M_PIDIV2 * 0.965f);
    mRotate._33 = (float)cos(M_PIDIV2 * 0.965f);

    D3DXMatrixMultiply(&m_cpReflection[FALLENKING].mWorld, &mTransform, &m_cpReflection[FALLENKING].mWorld);
    D3DXMatrixMultiply(&m_cpReflection[FALLENKING].mWorld, &mRotate, &m_cpReflection[FALLENKING].mWorld);

    mTransform = m_mIdentity;
    mTransform._42 = 0.475f;
    D3DXMatrixMultiply(&m_cpPiece[FALLENKING].mWorld, &m_cpPiece[FALLENKING].mWorld, &mTransform);

    mTransform = m_mIdentity;
    mTransform._42 = -0.475f;
    D3DXMatrixMultiply(&m_cpReflection[FALLENKING].mWorld, &m_cpReflection[FALLENKING].mWorld, &mTransform);

    m_pd3drBSurface = CreateVertexBuffer(m_pDevice, m_prBoardSurface, 4 * sizeof(VERTEX), 0, FVF_VERTEX);
    if (!m_pd3drBSurface) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3drBSurface->MoveResourceMemory(D3DMEM_VIDEO);
#endif

    m_pd3drBEdge = CreateVertexBuffer(m_pDevice, m_prBoardEdge, 20 * sizeof(VERTEX), 0, FVF_VERTEX);
    if (!m_pd3drBEdge) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3drBEdge->MoveResourceMemory(D3DMEM_VIDEO);
#endif

    m_pd3drScreen = CreateVertexBuffer(m_pDevice, m_plrScreen, 16 * sizeof(LVERTEX), 0, FVF_LVERTEX);
    if (!m_pd3drScreen) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3drScreen->MoveResourceMemory(D3DMEM_VIDEO);
#endif

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Efface
//
// Description:
//
//     Release all device resource objects (or at least those objects created
//     in video memory, non-local video memory, or the default memory pools)
//     and restore the device to its initial state.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CChessboard::Efface() {

    CScene::Efface();
}

//******************************************************************************
//
// Method:
//
//     Update
//
// Description:
//
//     Update the state of the scene to coincide with the given time.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CChessboard::Update() {

    float fDelta = m_fTimeDelta / 0.0075f;

    if (m_bRotateCamera) {
        m_fYRotationDelta = CAMERA_ROTATION_DELTA * fDelta;
    }

    m_svView.fTranslation += m_fTranslationDelta * fDelta;
    if (m_svView.fTranslation < 0.0f) {
        m_svView.fTranslation = 0.0f;
    }
    m_svView.fXRotation += m_fXRotationDelta * fDelta;
    if (m_svView.fXRotation < -M_PIDIV2) {
        m_svView.fXRotation = -M_PIDIV2;
    }
    else if (m_svView.fXRotation > M_PIDIV2) {
        m_svView.fXRotation = M_PIDIV2;
    }
    m_svView.fYRotation += m_fYRotationDelta * fDelta;
    if (m_svView.fYRotation < 0.0f) {
        m_svView.fYRotation += M_2PI;
    }
    else if (m_svView.fYRotation > M_2PI) {
        m_svView.fYRotation -= M_2PI;
    }
}

//******************************************************************************
//
// Method:
//
//     Render
//
// Description:
//
//     Render the test scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CChessboard::Render() {

    D3DXVECTOR3 vLightDir;
    DWORD       dwClearFlags = D3DCLEAR_TARGET;
    UINT        i;
    HRESULT     hr;

#ifndef UNDER_XBOX
    hr = m_pDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return TRUE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!Reset()) {
                return FALSE;
            }
        }
    }
#endif

    // Clear the rendering target
    if (m_pDisplay->IsDepthBuffered()) {
        dwClearFlags |= D3DCLEAR_ZBUFFER;
    }
    m_pDevice->Clear(0, NULL, dwClearFlags, RGB_MAKE(0, 0, 0), 1.0f, 0);

    // Begin the scene
    m_pDevice->BeginScene();

    // Position the view
    SetViewTransform(&m_svView);

    m_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);

    // Use a fixed function shader
    m_pDevice->SetVertexShader(FVF_VERTEX);

    // Render the pawn's reflection
    m_pDevice->SetMaterial(&m_matPawn);

    m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

#ifdef PIXEL_LIGHTING

    m_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

    // Transform the light into camera space
    vLightDir.x = m_vLightDir.x * m_mView._11 + m_vLightDir.y * m_mView._21 + m_vLightDir.z * m_mView._31;
    vLightDir.y = m_vLightDir.x * m_mView._12 + m_vLightDir.y * m_mView._22 + m_vLightDir.z * m_mView._32;
    vLightDir.z = m_vLightDir.x * m_mView._13 + m_vLightDir.y * m_mView._23 + m_vLightDir.z * m_mView._33;

    // Update the cubemap with a light direction in camera space
    UpdateHalfVectorMap(m_pd3dtcHVec, &vLightDir);

    m_pDevice->SetTexture(0, m_pd3dtcNorm);
    m_pDevice->SetTexture(1, m_pd3dtcHVec);
    m_pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACENORMAL);
    m_pDevice->SetTextureStageState(1, D3DTSS_TEXCOORDINDEX, D3DTSS_TCI_CAMERASPACEPOSITION);
    m_pDevice->SetTextureStageState(3, D3DTSS_TEXCOORDINDEX, 0);
    SetColorStage(m_pDevice, 0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG1);
    SetColorStage(m_pDevice, 1, D3DTA_TEXTURE, D3DTA_CURRENT, D3DTOP_DOTPRODUCT3);
    SetColorStage(m_pDevice, 2, D3DTA_CURRENT, D3DTA_CURRENT, D3DTOP_MODULATE);
    SetColorStage(m_pDevice, 3, D3DTA_TEXTURE, D3DTA_CURRENT, D3DTOP_MODULATE);

#else

    m_pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);
    m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    m_pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
    SetColorStage(m_pDevice, 0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);

#endif // PIXEL_LIGHTING

    if (!(m_svView.fXRotation > 0.0f && (m_svView.fTranslation * sin(m_svView.fXRotation)) > 0.895f)) {

        for (i = 0; i < 7; i++) {
#ifdef PIXEL_LIGHTING
            m_pDevice->SetTexture(3, i < 6 ? m_pd3dtPawn : m_pd3dtFallen);
#else
            m_pDevice->SetTexture(0, i < 6 ? m_pd3dtPawn : m_pd3dtFallen);
#endif // PIXEL_LIGHTING
            m_pDevice->SetTransform(D3DTS_WORLD, &m_cpReflection[i].mWorld);
            m_pDevice->SetStreamSource(0, m_cpReflection[i].pcmMesh->pd3dr, sizeof(VERTEX));
            m_pDevice->SetIndices(m_cpReflection[i].pcmMesh->pd3di, 0);
            m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_cpReflection[i].pcmMesh->uNumVertices, 0, m_cpReflection[i].pcmMesh->uNumPrimitives);
        }
    }

    for (i = 0; i < 7; i++) {
#ifdef PIXEL_LIGHTING
        m_pDevice->SetTexture(3, i < 6 ? m_pd3dtPawn : m_pd3dtFallen);
#else
        m_pDevice->SetTexture(0, i < 6 ? m_pd3dtPawn : m_pd3dtFallen);
#endif // PIXEL_LIGHTING
        m_pDevice->SetTransform(D3DTS_WORLD, &m_cpPiece[i].mWorld);
        m_pDevice->SetStreamSource(0, m_cpPiece[i].pcmMesh->pd3dr, sizeof(VERTEX));
        m_pDevice->SetIndices(m_cpPiece[i].pcmMesh->pd3di, 0);
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_cpPiece[i].pcmMesh->uNumVertices, 0, m_cpPiece[i].pcmMesh->uNumPrimitives);
    }

    m_pDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0);
    SetColorStage(m_pDevice, 0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_MODULATE);
    m_pDevice->SetTextureStageState(1, D3DTSS_COLOROP, D3DTOP_DISABLE);

    m_pDevice->SetTransform(D3DTS_WORLD, &m_mBoard);

    // Render the pawn reflection screen
    m_pDevice->SetVertexShader(FVF_LVERTEX);

    m_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

    m_pDevice->SetStreamSource(0, m_pd3drScreen, sizeof(LVERTEX));

    for (i = 0; i < 4; i++) {
        m_pDevice->DrawPrimitive(D3DPT_TRIANGLEFAN,
                i * 4, 2);
    }

    m_pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

    // Render the edge of the chessboard
    m_pDevice->SetMaterial(&m_matBoardEdge);
    m_pDevice->SetTexture(0, m_pd3dtBoardEdge);

    m_pDevice->SetVertexShader(FVF_VERTEX);

    m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, FALSE);

    m_pDevice->SetStreamSource(0, m_pd3drBEdge, sizeof(VERTEX));

    for (i = 0; i < 5; i++) {
        m_pDevice->DrawPrimitive(D3DPT_TRIANGLEFAN,
                i * 4, 2);
    }

    // Render the surface of the chessboard
    m_pDevice->SetMaterial(&m_matBoardSurface);
    m_pDevice->SetTexture(0, m_pd3dtBoardSurface);

    m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    m_pDevice->SetStreamSource(0, m_pd3drBSurface, sizeof(VERTEX));

    m_pDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 
            0, 2);

    m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);

    // Display the adapter mode
    ShowDisplayMode();

    // Display the frame rate
    ShowFrameRate();

    // Display the console
    m_pDisplay->ShowConsole();

    // Fade out the scene on exit
    if (m_pfnFade) {
        (this->*m_pfnFade)();
    }

    // End the scene
    m_pDevice->EndScene();

    // Update the screen
    m_pDevice->Present(NULL, NULL, NULL, NULL);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     ProcessInput
//
// Description:
//
//     Process user input for the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CChessboard::ProcessInput() {

    KEYSDOWN kdKeys;

    CScene::ProcessInput();
    kdKeys = m_pDisplay->GetKeyState();

    m_fTranslationDelta = 0.0f;
    m_fXRotationDelta = 0.0f;
    m_fYRotationDelta = 0.0f;

    // A Button
    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_X)) {
        m_bRotateCamera = TRUE;
    }
    
    // Left trigger
    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_LTRIG)) {
        m_fTranslationDelta = -CAMERA_TRANSLATION_DELTA;
    }

    // Right trigger
    if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_RTRIG)) {
        m_fTranslationDelta = CAMERA_TRANSLATION_DELTA;
    }

    // Joystick x-axis
    m_fYRotationDelta = m_jsJoys.f1X * CAMERA_ROTATION_DELTA;
    if (m_jsJoys.f1X != 0.0f) {
        m_bRotateCamera = FALSE;
    }

    // Joystick y-axis
    m_fXRotationDelta = m_jsJoys.f1Y * CAMERA_ROTATION_DELTA;

    if (kdKeys & KEY_LEFT) {
        m_fYRotationDelta = -CAMERA_ROTATION_DELTA;
        m_bRotateCamera = FALSE;
    }

    if (kdKeys & KEY_RIGHT) {
        m_fYRotationDelta = CAMERA_ROTATION_DELTA;
        m_bRotateCamera = FALSE;
    }

    if (kdKeys & KEY_UP) {
        m_fXRotationDelta = -CAMERA_ROTATION_DELTA;
    }

    if (kdKeys & KEY_DOWN) {
        m_fXRotationDelta = CAMERA_ROTATION_DELTA;
    }

    if (kdKeys & KEY_ADD || kdKeys & KEY_PAGEUP) {
        m_fTranslationDelta = -CAMERA_TRANSLATION_DELTA;
    }

    if (kdKeys & KEY_SUBTRACT || kdKeys & KEY_INSERT) {
        m_fTranslationDelta = CAMERA_TRANSLATION_DELTA;
    }
}

//******************************************************************************
//
// Method:
//
//     InitView
//
// Description:
//
//     Initialize the camera view in the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CChessboard::InitView() {

    if (!m_pDisplay) {
        return FALSE;
    }

    // Set the view position
    m_svInitial.vInterest = D3DXVECTOR3(0.0f, -4.1f, 0.0f);
    m_svInitial.fTranslation = (float)(11.75f);
    m_svInitial.fXRotation = -0.189f;
    m_svInitial.fYRotation = M_2PI;
    memcpy(&m_svView, &m_svInitial, sizeof(SVIEW));
    SetViewTransform(&m_svView);
    return TRUE;
}

//******************************************************************************
//
// Function:
//
//     SetViewTransform
//
// Description:
//
//     Set the view transform according to the fields of the given CAMERA.
//
// Arguments:
//
//     LPDIRECT3DDEVICE2 pd3dDevice   - Direct3DDevice object
//
//     PCAMERA pcam             - Camera data
//
// Return Value:
//
//     Initialized view matrix.
//
//******************************************************************************
void CChessboard::SetViewTransform(PSVIEW psv) {

    D3DXMATRIX m1, m2;

    // Translate the view away from the interest by the given distance
    InitMatrix(&m1,
        (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( 0.0f), (float)(psv->fTranslation), (float)( 1.0f)
    );
    m2 = m1;

    // Rotate the view around the x axis
    m1._43 = 0.0f;
    m1._22 = (float)(cos(psv->fXRotation));
    m1._23 = (float)(sin(psv->fXRotation));
    m1._32 = -m1._23;
    m1._33 = m1._22;
    D3DXMatrixMultiply(&m2, &m1, &m2);

    // Rotate the view around the y axis
    m1._22 = 1.0f;
    m1._23 = 0.0f;
    m1._32 = 0.0f;
    m1._11 = (float)(cos(psv->fYRotation));
    m1._13 = (float)(-sin(psv->fYRotation));
    m1._31 = -m1._13;
    m1._33 = m1._11;
    D3DXMatrixMultiply(&m2, &m1, &m2);

    // Translate the view to position it at the camera interest
    m1._11 = 1.0f;
    m1._13 = 0.0f;
    m1._31 = 0.0f;
    m1._33 = 1.0f;
    m1._41 = -psv->vInterest.x;
    m1._42 = -psv->vInterest.y;
    m1._43 = -psv->vInterest.z;
    D3DXMatrixMultiply(&m_mView, &m1, &m2);

    m_pDevice->SetTransform(D3DTS_VIEW, &m_mView);
}

//******************************************************************************
// Scene window procedure (pseudo-subclassed off the main window procedure)
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Scene window procedure to process messages received by the main 
//     application window.
//
// Arguments:
//
//     LRESULT* plr             - Result of the message processing
//
//     HWND hWnd                - Application window
//
//     UINT uMsg                - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     TRUE if the message was handled, FALSE otherwise.
//
//******************************************************************************
BOOL CChessboard::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_RETURN: {
                    BOOL bRet = !m_bRotateCamera;
                    m_bRotateCamera = TRUE;
                    if (bRet) {
                        return TRUE;
                    }
                }
            }

            break;

        case WM_CHAR:

            switch (wParam) {

                case TEXT('O'):
                case TEXT('o'):
                    // Reset the camera to its initial position
                    memcpy(&m_svView, &m_svInitial, sizeof(SVIEW));
                    return TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CScene::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\chessbrd\sources.inc ===
TARGETNAME=chessbrd
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\sources.inc

SOURCES=\
    main.cpp \
    chessbrd.cpp \
    chessbrd.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\chessbrd\chessbrd.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    chessbrd.h

Author:

    Matt Bronder

Description:

    Direct3D test functions.

*******************************************************************************/

#ifndef __CHESSBRD_H__
#define __CHESSBRD_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define CAMERA_ROTATION_DELTA        0.011780625f//0.0157075f
#define CAMERA_TRANSLATION_DELTA     0.5f

#define PAWN                         0
#define ROOK                         1
#define KNIGHT                       2
#define BISHOP                       3
#define QUEEN                        4
#define KING                         5
#define FALLENKING                   6

//******************************************************************************
// Structures
//******************************************************************************

typedef struct SVIEW {
    D3DXVECTOR3 vInterest;
    float       fTranslation;
    float       fXRotation;
    float       fYRotation;
} SVIEW, *PSVIEW;

typedef struct _CHESSMESH {
    LPDIRECT3DVERTEXBUFFER8  pd3dr;
    LPDIRECT3DINDEXBUFFER8   pd3di;
    UINT                     uNumVertices;
    UINT                     uNumIndices;
    UINT                     uNumPrimitives;
} CHESSMESH, *PCHESSMESH;

typedef struct _CHESSPIECE {
    PCHESSMESH      pcmMesh;
    D3DXMATRIX      mWorld;
} CHESSPIECE, *PCHESSPIECE;

//******************************************************************************
// Function prototypes
//******************************************************************************

int         ExhibitScene(CDisplay* pDisplay);
BOOL        ValidateDisplay(LPDIRECT3D8* pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
class CChessboard : public CScene {

protected:

    LPDIRECT3DCUBETEXTURE8          m_pd3dtcNorm;
    LPDIRECT3DCUBETEXTURE8          m_pd3dtcHVec;
    CHESSMESH                       m_cmChessMesh[6];
    CHESSPIECE                      m_cpPiece[7];
    CHESSPIECE                      m_cpReflection[7];
    D3DXVECTOR3                     m_vLightDir;
    D3DXMATRIX                      m_mView;
    LPDIRECT3DVERTEXBUFFER8         m_pd3drBSurface;
    LPDIRECT3DVERTEXBUFFER8         m_pd3drBEdge;
    LPDIRECT3DVERTEXBUFFER8         m_pd3drScreen;
    VERTEX                          m_prBoardSurface[4];
    VERTEX                          m_prBoardEdge[5][4];
    LVERTEX                         m_plrScreen[4][4];
    D3DMATERIAL8                    m_matPawn;
    D3DMATERIAL8                    m_matBoardEdge;
    D3DMATERIAL8                    m_matBoardSurface;
    LPDIRECT3DTEXTURE8              m_pd3dtBoardSurface;
    LPDIRECT3DTEXTURE8              m_pd3dtBoardEdge;
    LPDIRECT3DTEXTURE8              m_pd3dtPawn;
    LPDIRECT3DTEXTURE8              m_pd3dtFallen;
    D3DXMATRIX                      m_mBoard, m_mPawn, m_mReflection;
    SVIEW                           m_svView;
    SVIEW                           m_svInitial;
    float                           m_fTranslationDelta;
    float                           m_fXRotationDelta;
    float                           m_fYRotationDelta;
    BOOL                            m_bRotateCamera;

public:

                                    CChessboard();
                                    ~CChessboard();

    virtual BOOL                    Create(CDisplay* pDisplay);
    virtual int                     Exhibit(int *pnExitCode);

protected:

    virtual BOOL                    Setup();
    virtual BOOL                    Initialize();
    virtual void                    Efface();
    virtual void                    Update();
    virtual BOOL                    Render();

    virtual void                    ProcessInput();
    virtual BOOL                    InitView();

    virtual void                    SetViewTransform(PSVIEW psv);

    virtual BOOL                    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
};

#endif //__CHESSBRD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\chessbrd\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Author:

    Matt Bronder

Description:

    Application entry point.

*******************************************************************************/

#include "d3dbase.h"

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifdef UNDER_XBOX

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

#endif // UNDER_XBOX

int         ExhibitScene(CDisplay* pDisplay, int *pnExitCode);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
// WinMain
//******************************************************************************

#ifndef UNDER_XBOX
#define RETURN(x)   return x
#else
#define RETURN(x)   return
#endif // UNDER_XBOX

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif // UNDER_XBOX
{
    CDisplay*       pDisplay;
    D3DCREATIONDESC d3dcd;
    int             ret;

    // Allow global access to the instance handle
#ifndef UNDER_XBOX
    RegisterInstance(hInstance);
#else
    RegisterInstance(NULL);
#endif

    // Seed the pseudo-random number generator
    srand(GetTickCount());

    // Create a heap for the application
    if (!CreateHeap()) {
        RETURN(0);
    }

    // Set the validation procedure for the device
    InitCheckDisplayProc(ValidateDisplay);

    // Initialize creation parameters
    memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
    d3dcd.d3ddt = D3DDEVTYPE_HAL;
    d3dcd.bWindowed = FALSE;
    d3dcd.d3ddm.Width = 640;
    d3dcd.d3ddm.Height = 480;
    d3dcd.d3ddm.Format = D3DFMT_X8R8G8B8;
//    SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
    d3dcd.bDepthBuffer = TRUE;
    d3dcd.fmtd = D3DFMT_D24S8;
    d3dcd.uPresentInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dcd.mst = D3DMULTISAMPLE_NONE;

    // Create the display
    pDisplay = new CDisplay();
    if (!pDisplay) {
        ReleaseHeap();
        RETURN(0);
    }

    // Initialize the display
    if (!pDisplay->Create(&d3dcd)) {
        DebugString(TEXT("CDisplay::Create failed"));
        pDisplay->Release();
        ReleaseHeap();
        RETURN(0);
    }

    // Render the 3D scene
    ExhibitScene(pDisplay, &ret);

    // Clean up
    pDisplay->Release();

    // Release the heap
    ReleaseHeap();

    // Reboot on Xbox
#ifdef UNDER_XBOX
    HalReturnToFirmware(HalQuickRebootRoutine);
#endif

    RETURN(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\rteapot\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Author:

    Matt Bronder

Description:

    Application entry point.

*******************************************************************************/

#include "d3dbase.h"

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifdef UNDER_XBOX

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

#endif // UNDER_XBOX

int         ExhibitScene(CDisplay* pDisplay, int *pnExitCode);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
// WinMain
//******************************************************************************

#ifndef UNDER_XBOX
#define RETURN(x)   return x
#else
#define RETURN(x)   return
#endif // UNDER_XBOX

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif // UNDER_XBOX
{
    CDisplay*       pDisplay;
    D3DCREATIONDESC d3dcd;
    int             ret;

    // Allow global access to the instance handle
#ifndef UNDER_XBOX
    RegisterInstance(hInstance);
#else
    RegisterInstance(NULL);
#endif

    // Seed the pseudo-random number generator
    srand(GetTickCount());

    // Create a heap for the application
    if (!CreateHeap()) {
        RETURN(0);
    }

    // Set the validation procedure for the device
    InitCheckDisplayProc(ValidateDisplay);

    // Initialize creation parameters
    memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
    d3dcd.d3ddt = D3DDEVTYPE_HAL;
    d3dcd.bWindowed = FALSE;
    d3dcd.d3ddm.Width = 640;
    d3dcd.d3ddm.Height = 480;
    d3dcd.d3ddm.Format = D3DFMT_X8R8G8B8;
//    SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
    d3dcd.bDepthBuffer = TRUE;
    d3dcd.fmtd = D3DFMT_D24S8;
    d3dcd.uPresentInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
    d3dcd.mst = D3DMULTISAMPLE_NONE;

    // Create the display
    pDisplay = new CDisplay();
    if (!pDisplay) {
        ReleaseHeap();
        RETURN(0);
    }

    // Initialize the display
    if (!pDisplay->Create(&d3dcd)) {
        DebugString(TEXT("CDisplay::Create failed"));
        pDisplay->Release();
        ReleaseHeap();
        RETURN(0);
    }

    // Render the 3D scene
    ExhibitScene(pDisplay, &ret);

    // Clean up
    pDisplay->Release();

    // Release the heap
    ReleaseHeap();

    // Reboot on Xbox
#ifdef UNDER_XBOX
    HalReturnToFirmware(HalQuickRebootRoutine);
#endif

    RETURN(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\clockwork.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    clockwork.h

Author:

    Matt Bronder

Description:

    Direct3D test functions.

*******************************************************************************/

#ifndef __CLOCKWORK_H__
#define __CLOCKWORK_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

//#define LIMITED

#define ORBIT_FRAMES            420

#define SPHERE_U                16
#define SPHERE_V                16

#ifdef LIMITED
#define NUM_GEARS               50
#define BOUND_RADIUS            32.0f//(D3DVAL(NUM_GEARS) * 0.5f)
#else
#define NUM_GEARS               200
#define BOUND_RADIUS            48.0f//(D3DVAL(NUM_GEARS) * 0.5f)
#endif // LIMITED

#define VIEW_Z                  (-(BOUND_RADIUS + 16.0f))

//******************************************************************************
// Function prototypes
//******************************************************************************

int         ExhibitScene(CDisplay* pDisplay);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
class CClockwork : public CScene {

protected:

    D3DXMATRIX                      m_mWorld;
    PVERTEX                         m_prSphere;
    DWORD                           m_dwSphereVertices;
    LPWORD                          m_pwSphere;
    DWORD                           m_dwSphereIndices;
    LPDIRECT3DVERTEXBUFFER8         m_pd3drSphere;
    LPDIRECT3DINDEXBUFFER8          m_pd3diSphere;
    CLOCKWORK                       m_cw;
    LPDIRECT3DTEXTURE8              m_pd3dtBackground;
    float                           m_fOrbitAngle;
    CAMERA                          m_cam;

public:

                                    CClockwork();
                                    ~CClockwork();

    virtual BOOL                    Create(CDisplay* pDisplay);
    virtual int                     Exhibit(int *pnExitCode);

protected:

    virtual BOOL                    Prepare();
    virtual BOOL                    Setup();
    virtual BOOL                    Initialize();
    virtual void                    Efface();
    virtual void                    Update();
    virtual BOOL                    Render();

    virtual void                    ProcessInput();
    virtual BOOL                    InitView();

    virtual BOOL                    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
};

#endif //__CLOCKWORK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\cogs.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    cogs.h

Author:

    Matt Bronder

Description:

    Clockwork animation and rendering.

*******************************************************************************/

#ifndef __COGS_H__
#define __COGS_H__

#define NUM_COG_TEXTURES        17
#define NUM_SHAFT_TEXTURES      7

#define SHAFT_RADIUS            0.25f
#define S_COG_RADIUS            (0.375f * 4.0f / 1.5f)
#define M_COG_RADIUS            (0.375f * 6.0f / 1.5f)
#define L_COG_RADIUS            (0.375f * 10.0f / 1.5f)
#define S_COG_WIDTH             (0.375f * 4.0f / 1.5f)
#define M_COG_WIDTH             (0.375f * 2.0f / 1.5f)
#define L_COG_WIDTH             (0.375f * 1.0f / 1.5f)
#define TOOTH_HEIGHT            (0.375f * 2.6f / 1.5f)
#define TOOTH_WIDTH_BASE        (0.375f * 2.6f / 1.5f)
#define TOOTH_WIDTH_TOP         (0.375f * 1.54f / 1.5f)
#define MIN_COG_SPACING         ((L_COG_RADIUS + TOOTH_HEIGHT) * 2.0f)
#define S_COG_SIDES             6
#define M_COG_SIDES             8
#define L_COG_SIDES             12

#define GEAR_LENGTH             ((3.0f * MIN_COG_SPACING) + FRND(5.0f))

#define CYLCAPS_NONE            0
#define CYLCAPS_TOP             1
#define CYLCAPS_BOTTOM          2
#define CYLCAPS_BOTH            3

typedef enum _COGSIZE {
    COGSIZE_SMALL = 0,
    COGSIZE_MEDIUM = 1,
    COGSIZE_LARGE = 2
} COGSIZE, *PCOGSIZE;

typedef struct _D3DRECT3D {
    D3DXVECTOR3         v1;     // -x,-y,-z
    D3DXVECTOR3         v2;     // +x,+y,+z
} D3DRECT3D, *PD3DRECT3D;

typedef struct _COG {
    DWORD                       dwSides;
    PVERTEX                     prCenter;
    LPDIRECT3DVERTEXBUFFER8     pd3drCenter;
    DWORD                       dwCenterVertices;
    LPWORD                      pwCenter;
    DWORD                       dwCenterIndices;
    LPDIRECT3DINDEXBUFFER8      pd3diCenter;
    PVERTEX*                    pprTeeth;
    LPDIRECT3DVERTEXBUFFER8     pd3drTeeth;
    DWORD                       dwTextureIndex;
} COG, *PCOG;

typedef struct _GEAR {

    COG                         cog[3];
    PVERTEX                     prShaft;
    LPDIRECT3DVERTEXBUFFER8     pd3drShaft;
    D3DXMATRIX                  mWorld;
    D3DXMATRIX                  mRotate;
    DWORD                       dwClip[4];

    DWORD                       dwShaftTextureIndex;
    int                         nMaterialIndex;
    int                         nLightIndex;
    int                         nSpecular;

    D3DXVECTOR3                 vPos;
    D3DXVECTOR3                 vDir;
    float                       fAngularVelocity;
    float                       fSpin;
    COGSIZE                     csCogSize[2];
    float                       fCogOffset[2];

    struct _GEAR*               pgearNext[2];

} GEAR, *PGEAR;

typedef struct _CLOCKWORK {

    PVERTEX                     prUnitShaft;

    DWORD                       dwShaftVertices;
    LPWORD                      pwShaft;
    DWORD                       dwShaftIndices;

    DWORD                       dwToothVertices;
    LPWORD                      pwTooth;
    DWORD                       dwToothIndices;

    LPDIRECT3DINDEXBUFFER8      pd3diShaft;
    LPDIRECT3DINDEXBUFFER8      pd3diTooth;

    PGEAR                       pgearRoot;

    LPDIRECT3DTEXTURE8          pd3dtCog[NUM_COG_TEXTURES];
    LPDIRECT3DTEXTURE8          pd3dtShaft[NUM_SHAFT_TEXTURES];

} CLOCKWORK, *PCLOCKWORK;

BOOL      CreateCog(PCOG pcog, DWORD dwSides, float fRadius, float fWidth, 
                    float fOffset = 0.0f);
void      ReleaseCog(PCOG pcog);

BOOL      CreateClockwork(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw);
void      UpdateClockwork(PCLOCKWORK pcw, float fTimeDilation);
void      RenderClockwork(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw);
void      ReleaseClockwork(PCLOCKWORK pcw);

PGEAR     CreateGear(PCLOCKWORK pcw, PCOGSIZE pcsCogSize, float* pfCogOffset, 
                    D3DXVECTOR3* pvPos, D3DXVECTOR3* pvDir, 
                    float fAngularVelocity, float fRotation, 
                    PD3DRECT3D prectBox, DWORD dwDepth = 1);
PGEAR     AddAttachedGear(PCLOCKWORK pcw, PGEAR pgearParent, UINT uCog, 
                    DWORD dwDepth);
void      AddGear(PCLOCKWORK pcw, PGEAR pgear, DWORD dwDepth = 1);
void      RotateGear(PCLOCKWORK pcw, PGEAR pgear, float fTheta);
void      RenderGear(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw, PGEAR pgear);
void      ReleaseGear(PGEAR pgear);

BOOL      CreateCylinder(PVERTEX* pprVertices, LPDWORD pdwNumVertices, 
                    LPWORD* ppwIndices, LPDWORD pdwNumIndices, 
                    DWORD dwSides, float fRadius, float fWidth,
                    DWORD dwCylinderCaps = CYLCAPS_BOTH);

void      ReleaseCylinder(PVERTEX prVertices, LPWORD pwIndices);

void      SetRect3D(PD3DRECT3D prect, D3DXVECTOR3* pv1, 
                    D3DXVECTOR3* pv2);
BOOL      GearCollision(PD3DRECT3D prectBox1, PD3DRECT3D prectBox2);

#endif // __COGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\clockwork.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    clockwork.cpp

Author:

    Matt Bronder

Description:

    Test functions.

*******************************************************************************/

#include "d3dbase.h"
#include "cogs.h"
#include "clockwork.h"

//******************************************************************************
BOOL CreateSphereV(float fRadius, PVERTEX* pprVertices, LPDWORD pdwNumVertices,
                  LPWORD* ppwIndices, LPDWORD pdwNumIndices) {

    PVERTEX     prVertices;
    PVERTEX     pr;
    DWORD       dwNumVertices;
    LPWORD      pwIndices;
    DWORD       dwNumIndices;
    UINT        uIndex = 0;
    UINT        uStepsU = SPHERE_U, uStepsV = SPHERE_V;
    UINT        i, j;
    float       fX, fY, fTX, fSinY, fCosY;

    if (!pprVertices || !pdwNumVertices || !ppwIndices || !pdwNumIndices) {
        return FALSE;
    }

    *pprVertices = NULL;
    *pdwNumVertices = 0;
    *ppwIndices = NULL;
    *pdwNumIndices = 0;

    dwNumVertices = (uStepsU + 1) * uStepsV;

    // Allocate memory for the vertices
    prVertices = (PVERTEX)MemAlloc32(dwNumVertices * sizeof(VERTEX));
    if (!prVertices) {
        return FALSE;
    }

    // Allocate memory for the indices
    dwNumIndices = uStepsU * (uStepsV - 1) * 6;

    pwIndices = new WORD[dwNumIndices];
    if (!pwIndices) {
        MemFree32(prVertices);
        return FALSE;
    }

    // Create the sphere
    for (j = 0; j < uStepsV; j++) {

        fY = (float)(j) / (float)(uStepsV - 1);
        fSinY = (float)(sin(fY * M_PI));
        fCosY = (float)(cos(fY * M_PI));

        for (i = 0; i <= uStepsU; i++) {

            pr = &prVertices[(uStepsU + 1) * j + i];
            fX = (float)(i) / (float)(uStepsU);
            fTX = fX * M_2PI;

            pr->vNormal.x = -(float)(sin(fTX));// * fSinY;
            pr->vNormal.y = -fCosY;
            pr->vNormal.z = (float)(cos(fTX));// * fSinY;
            pr->vPosition.x = -pr->vNormal.x * fRadius;
            pr->vPosition.y = -pr->vNormal.y * fRadius;
            pr->vPosition.z = -pr->vNormal.z * fRadius;
            pr->u0 = fX * 4.0f;
            pr->v0 = fY * 4.0f;
        }
    }

    for (j = 0; j < uStepsU; j++) {

        for (i = 0; i < uStepsV - 1; i++) {

            pwIndices[uIndex++] = i * (uStepsU + 1) + j;
            pwIndices[uIndex++] = (i + 1) * (uStepsU + 1) + j + 1;
            pwIndices[uIndex++] = i * (uStepsU + 1) + j + 1;
            pwIndices[uIndex++] = i * (uStepsU + 1) + j;
            pwIndices[uIndex++] = (i + 1) * (uStepsU + 1) + j;
            pwIndices[uIndex++] = (i + 1) * (uStepsU + 1) + j + 1;
        }
    }

    *pprVertices = prVertices;
    *pdwNumVertices = dwNumVertices;
    *ppwIndices = pwIndices;
    *pdwNumIndices = dwNumIndices;

    return TRUE;
}

//******************************************************************************
void ReleaseSphereV(PVERTEX* ppr, LPWORD* ppw) {

    if (ppr && *ppr) {
        MemFree32(*ppr);
    }
    if (ppw && *ppw) {
        delete [] *ppw;
    }
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
BOOL ExhibitScene(CDisplay* pDisplay, int* pnExitCode) {

    CClockwork*   pClockwork;
    BOOL          bRet;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    // Create the scene
    pClockwork = new CClockwork();
    if (!pClockwork) {
        return FALSE;
    }

    // Initialize the scene
    if (!pClockwork->Create(pDisplay)) {
        pClockwork->Release();
        return FALSE;
    }

    bRet = pClockwork->Exhibit(pnExitCode);

    // Clean up the scene
    pClockwork->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8 pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
// CClockwork
//******************************************************************************

//******************************************************************************
//
// Method:
//
//     CClockwork
//
// Description:
//
//     Initialize the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CClockwork::CClockwork() {

    m_pd3drSphere = NULL;
    m_pd3diSphere = NULL;
    m_pd3dtBackground = NULL;
    m_prSphere = NULL;
    m_pwSphere = NULL;
    m_fOrbitAngle = 0.0f;
    memset(&m_cw, 0, sizeof(CLOCKWORK));
}

//******************************************************************************
//
// Method:
//
//     ~CClockwork
//
// Description:
//
//     Clean up the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CClockwork::~CClockwork() {
}

//******************************************************************************
//
// Method:
//
//     Create
//
// Description:
//
//     Prepare the test for rendering.
//
// Arguments:
//
//     CDisplay* pDisplay               - Pointer to a Display object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CClockwork::Create(CDisplay* pDisplay) {

    return CScene::Create(pDisplay);
}

//******************************************************************************
//
// Method:
//
//     Exhibit
//
// Description:
//
//     Execute the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The exit value contained in the wParam parameter of the WM_QUIT message.
//
//******************************************************************************
int CClockwork::Exhibit(int *pnExitCode) {

    return CScene::Exhibit(pnExitCode);
}

//******************************************************************************
//
// Method:
//
//     Prepare
//
// Description:
//
//     Initialize all device-independent data to be used in the scene.  This
//     method is called only once at creation (as opposed to Setup and
//     Initialize, which get called each time the device is Reset).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared, FALSE if it was not.
//
//******************************************************************************
BOOL CClockwork::Prepare() {

    DWORD dwSeed;

    dwSeed = GetTickCount();
#ifdef LIMITED
    dwSeed = 441428380;
#else
    dwSeed = 2993;
//DebugString(TEXT("seeding pseudo-random number generator with 0x%X"), dwSeed);
#endif // !LIMITED
    srand(dwSeed);

    m_mWorld = m_mIdentity;

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Setup
//
// Description:
//
//     Obtain the device interface pointer from the display, save the current
//     state of the device, and initialize the background vertices to the
//     dimensions of the render target.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared for initialization, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CClockwork::Setup() {

    return CScene::Setup();
}

//******************************************************************************
//
// Method:
//
//     Initialize
//
// Description:
//
//     Initialize the device and all device objects to be used in the test (or
//     at least all device resource objects to be created in the video, 
//     non-local video, or default memory pools).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the test was successfully initialized for rendering, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CClockwork::Initialize() {

    SetDirectionalLight(m_pDevice, 0, D3DXVECTOR3(0.0f, -1.0f, 1.0f));
    SetMaterial(m_pDevice, RGB_MAKE(255, 255, 255));

    // Initialize the vertices
    if (!CreateSphereV(BOUND_RADIUS + 8.0f, &m_prSphere, &m_dwSphereVertices, &m_pwSphere, &m_dwSphereIndices)) {
        return FALSE;
    }

    CreateClockwork(m_pDevice, &m_cw);

    m_pd3dtBackground = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("backcogs.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 256, 256);
    if (!m_pd3dtBackground) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3dtBackground->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

    m_pd3drSphere = CreateVertexBuffer(m_pDevice, m_prSphere, m_dwSphereVertices * sizeof(VERTEX), 0, FVF_VERTEX);
    if (!m_pd3drSphere) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3drSphere->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

    m_pd3diSphere = CreateIndexBuffer(m_pDevice, m_pwSphere, m_dwSphereIndices * sizeof(WORD));
    if (!m_pd3diSphere) {
        return FALSE;
    }

    m_bFade = TRUE;

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Efface
//
// Description:
//
//     Release all device resource objects (or at least those objects created
//     in video memory, non-local video memory, or the default memory pools)
//     and restore the device to its initial state.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CClockwork::Efface() {

    ReleaseVertexBuffer(m_pd3drSphere);
    ReleaseIndexBuffer(m_pd3diSphere);
    ReleaseTexture(m_pd3dtBackground);
    m_pd3dtBackground = NULL;
    ReleaseClockwork(&m_cw);
    ReleaseSphereV(&m_prSphere, &m_pwSphere);

    CScene::Efface();
}

//******************************************************************************
//
// Method:
//
//     Update
//
// Description:
//
//     Update the state of the scene to coincide with the given time.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CClockwork::Update() {

    UpdateClockwork(&m_cw, m_fTimeDilation);

    m_fOrbitAngle += (M_2PI / (float)ORBIT_FRAMES * m_fTimeDilation);
    if (m_fOrbitAngle > M_2PI) {
        m_fOrbitAngle -= M_2PI;
    }

    m_cam.vPosition.x = (float)(sin(m_fOrbitAngle)) * VIEW_Z;
    m_cam.vPosition.z = (float)(cos(m_fOrbitAngle)) * VIEW_Z;
}

//******************************************************************************
//
// Method:
//
//     Render
//
// Description:
//
//     Render the test scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CClockwork::Render() {

    DWORD    dwClearFlags = D3DCLEAR_TARGET;
    HRESULT  hr;

#ifndef UNDER_XBOX

    hr = m_pDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return TRUE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!Reset()) {
                return FALSE;
            }
        }
    }

#endif

    // Clear the rendering target
    if (m_pDisplay->IsDepthBuffered()) {
        dwClearFlags |= D3DCLEAR_ZBUFFER;
    }
    m_pDevice->Clear(0, NULL, dwClearFlags, RGB_MAKE(0, 0, 0), 1.0f, 0);

    // Begin the scene
    m_pDevice->BeginScene();

    // Position the view using the default camera
    m_pDisplay->SetView(&m_cam);

    m_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);

    // Use a fixed function shader
    m_pDevice->SetVertexShader(FVF_VERTEX);

    m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld);

    m_pDevice->SetTexture(0, m_pd3dtBackground);

#ifndef UNDER_XBOX
    m_pDevice->SetRenderState(D3DRS_CLIPPING, TRUE);
#endif // !UNDER_XBOX

    m_pDevice->SetRenderState(D3DRS_AMBIENT, (DWORD)RGBA_MAKE(255, 255, 255, 255));

    m_pDevice->SetStreamSource(0, m_pd3drSphere, sizeof(VERTEX));
    m_pDevice->SetIndices(m_pd3diSphere, 0);

    m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_dwSphereVertices,
            0, m_dwSphereIndices / 3);

    m_pDevice->SetRenderState(D3DRS_AMBIENT, (DWORD)RGBA_MAKE(128, 128, 128, 128));

    RenderClockwork(m_pDevice, &m_cw);

    // Display the adapter mode
    ShowDisplayMode();

    // Display the frame rate
    ShowFrameRate();

    // Display the console
    m_pDisplay->ShowConsole();

    // Fade out the scene on exit
    if (m_pfnFade) {
        (this->*m_pfnFade)();
    }

    // End the scene
    m_pDevice->EndScene();

    // Update the screen
    m_pDevice->Present(NULL, NULL, NULL, NULL);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     ProcessInput
//
// Description:
//
//     Process user input for the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CClockwork::ProcessInput() {

    CScene::ProcessInput();
}
//******************************************************************************
//
// Method:
//
//     InitView
//
// Description:
//
//     Initialize the camera view in the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CClockwork::InitView() {

    if (!m_pDisplay) {
        return FALSE;
    }

    // Set the view position
    m_camInitial.vPosition     = D3DXVECTOR3(0.0f, 0.0f, VIEW_Z);
    m_camInitial.vInterest     = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    m_camInitial.fRoll         = 0.0f;
    m_camInitial.fFieldOfView  = M_PI / 4.0f;
    m_camInitial.fNearPlane    = 0.1f;
    m_camInitial.fFarPlane     = 1000.0f;
    m_pDisplay->SetCamera(&m_camInitial);
    memcpy(&m_cam, &m_camInitial, sizeof(CAMERA));

    return m_pDisplay->SetView(&m_camInitial);
}

//******************************************************************************
// Scene window procedure (pseudo-subclassed off the main window procedure)
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Scene window procedure to process messages received by the main 
//     application window.
//
// Arguments:
//
//     LRESULT* plr             - Result of the message processing
//
//     HWND hWnd                - Application window
//
//     UINT uMsg                - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     TRUE if the message was handled, FALSE otherwise.
//
//******************************************************************************
BOOL CClockwork::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_F12: // Toggle pause state
                    m_bPaused = !m_bPaused;
                    return TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CScene::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\cogs.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    cogs.cpp

Author:

    Matt Bronder

Description:

    Clockwork animation and rendering.

*******************************************************************************/

#include "d3dbase.h"
#include "cogs.h"
#include "clockwork.h"

static LPDIRECT3DDEVICE8    g_pDevice;

static D3DRECT3D            g_rectBox[NUM_GEARS * 4 + 6];
static UINT                 g_uNumBoxes;
static UINT                 g_uNumGears;
static DWORD                g_dwMaxDepth;

static UINT                 g_uCogTextures;
static UINT                 g_uShaftTextures;

static float                g_fFieldOfView = M_PI / 4.0f;

//******************************************************************************
BOOL CreateCog(PCOG pcog, DWORD dwSides, float fRadius, float fWidth, float fOffset) {

    float       fToothZ, fToothX, fTheta;
    D3DXVECTOR3 vN;
    D3DXMATRIX  mRotate;
    PVERTEX     pr;
    UINT        i, j;

    if (!pcog) {
        return FALSE;
    }

    memset(pcog, 0, sizeof(COG));

    pcog->dwSides = dwSides;

    pcog->pprTeeth = new PVERTEX[dwSides];
    if (!pcog->pprTeeth) {
        ReleaseCog(pcog);
        return FALSE;
    }

    for (i = 0; i < dwSides; i++) {
        pcog->pprTeeth[i] = (PVERTEX)MemAlloc32(8 * sizeof(VERTEX));
        if (!pcog->pprTeeth[i]) {
            ReleaseCog(pcog);
            return FALSE;
        }        
    }

    if (!CreateCylinder(&pcog->prCenter, &pcog->dwCenterVertices, 
                        &pcog->pwCenter, &pcog->dwCenterIndices, 
                        pcog->dwSides, fRadius, fWidth, 
                        CYLCAPS_BOTH))
    {
        ReleaseCog(pcog);
        return FALSE;
    }

    // Position the first tooth
    fToothX = fWidth / 2.0f * 0.9f;
    fToothZ = pcog->prCenter[0].vPosition.z - ((TOOTH_WIDTH_BASE / 2.0f) / 
            (pcog->prCenter[2].vPosition.y / (pcog->prCenter[0].vPosition.z - 
            pcog->prCenter[2].vPosition.z)));

    pcog->pprTeeth[0][0] = VERTEX(D3DXVECTOR3( fToothX, -TOOTH_WIDTH_BASE / 2.0f, fToothZ), *D3DXVec3Normalize(&vN, &D3DXVECTOR3( 1.0f, -1.0f, 0.0f)), 0.0f, 1.0f);
    pcog->pprTeeth[0][1] = VERTEX(D3DXVECTOR3(-fToothX, -TOOTH_WIDTH_BASE / 2.0f, fToothZ), *D3DXVec3Normalize(&vN, &D3DXVECTOR3(-1.0f, -1.0f, 0.0f)), 0.0f, 1.0f);
    pcog->pprTeeth[0][2] = VERTEX(D3DXVECTOR3( fToothX, -TOOTH_WIDTH_TOP  / 2.0f, fToothZ + TOOTH_HEIGHT), *D3DXVec3Normalize(&vN, &D3DXVECTOR3( 1.0f, -1.0f, 1.0f)), 1.0f, 1.0f);
    pcog->pprTeeth[0][3] = VERTEX(D3DXVECTOR3(-fToothX, -TOOTH_WIDTH_TOP  / 2.0f, fToothZ + TOOTH_HEIGHT), *D3DXVec3Normalize(&vN, &D3DXVECTOR3(-1.0f, -1.0f, 1.0f)), 1.0f, 1.0f);
    pcog->pprTeeth[0][4] = VERTEX(D3DXVECTOR3( fToothX,  TOOTH_WIDTH_TOP  / 2.0f, fToothZ + TOOTH_HEIGHT), *D3DXVec3Normalize(&vN, &D3DXVECTOR3( 1.0f,  1.0f, 1.0f)), 1.0f, 0.0f);
    pcog->pprTeeth[0][5] = VERTEX(D3DXVECTOR3(-fToothX,  TOOTH_WIDTH_TOP  / 2.0f, fToothZ + TOOTH_HEIGHT), *D3DXVec3Normalize(&vN, &D3DXVECTOR3(-1.0f,  1.0f, 1.0f)), 1.0f, 0.0f);
    pcog->pprTeeth[0][6] = VERTEX(D3DXVECTOR3( fToothX,  TOOTH_WIDTH_BASE / 2.0f, fToothZ), *D3DXVec3Normalize(&vN, &D3DXVECTOR3( 1.0f,  1.0f, 0.0f)), 0.0f, 0.0f);
    pcog->pprTeeth[0][7] = VERTEX(D3DXVECTOR3(-fToothX,  TOOTH_WIDTH_BASE / 2.0f, fToothZ), *D3DXVec3Normalize(&vN, &D3DXVECTOR3(-1.0f,  1.0f, 0.0f)), 0.0f, 0.0f);

    // Rotate the first tooth around the cog
    fTheta = M_2PI / (float)dwSides;
    InitMatrix(&mRotate,
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f, (float)cos(fTheta), (float)sin(fTheta), 0.0f,
        0.0f, (float)-sin(fTheta), (float)cos(fTheta), 0.0f,
        0.0f,  0.0f, 0.0f, 1.0f
    );

    for (i = 1; i < dwSides; i++) {
        for (j = 0; j < 8; j++) {
            D3DXVec3TransformCoord(&pcog->pprTeeth[i][j].vPosition, &pcog->pprTeeth[i-1][j].vPosition, &mRotate);
            D3DXVec3TransformCoord(&pcog->pprTeeth[i][j].vNormal, &pcog->pprTeeth[i-1][j].vNormal, &mRotate);
            memcpy(&pcog->pprTeeth[i][j].u0, &pcog->pprTeeth[i-1][j].u0, 2 * sizeof(float));
        }
    }

    // Offset the cog along the x axis
    for (i = 0; i < pcog->dwCenterVertices; i++)  {
        pcog->prCenter[i].vPosition.x += fOffset;
    }
    for (i = 0; i < dwSides; i++) {
        for (j = 0; j < 8; j++) {
            pcog->pprTeeth[i][j].vPosition.x += fOffset;
        }
    }

    pcog->pd3drCenter = CreateVertexBuffer(g_pDevice, pcog->prCenter, pcog->dwCenterVertices * sizeof(VERTEX), 0, FVF_VERTEX);
    if (!pcog->pd3drCenter) {
        ReleaseCog(pcog);
        return FALSE;
    }

#ifdef UNDER_XBOX
    pcog->pd3drCenter->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

    pcog->pd3diCenter = CreateIndexBuffer(g_pDevice, pcog->pwCenter, pcog->dwCenterIndices * sizeof(WORD));
    if (!pcog->pd3diCenter) {
        ReleaseCog(pcog);
        return FALSE;
    }

    g_pDevice->CreateVertexBuffer(dwSides * 8 * sizeof(VERTEX), 0, FVF_VERTEX, D3DPOOL_DEFAULT, &pcog->pd3drTeeth);
    pcog->pd3drTeeth->Lock(0, dwSides * 8 * sizeof(VERTEX), (LPBYTE*)&pr, 0);
    for (i = 0; i < dwSides; i++) {
        memcpy(&pr[i * 8], pcog->pprTeeth[i], 8 * sizeof(VERTEX));
    }
    pcog->pd3drTeeth->Unlock();

#ifdef UNDER_XBOX
    pcog->pd3drTeeth->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

    return TRUE;
}

//******************************************************************************
void ReleaseCog(PCOG pcog) {

    UINT i;

    ReleaseVertexBuffer(pcog->pd3drCenter);
    ReleaseIndexBuffer(pcog->pd3diCenter);
    ReleaseVertexBuffer(pcog->pd3drTeeth);

    ReleaseCylinder(pcog->prCenter, pcog->pwCenter);

    if (pcog->pprTeeth) {
        for (i = 0; i < pcog->dwSides; i++) {
            if (pcog->pprTeeth[i]) {
                MemFree32(pcog->pprTeeth[i]);
            }
        }
        delete [] pcog->pprTeeth;
    }

    memset(pcog, 0, sizeof(COG));
}

//******************************************************************************
PGEAR CreateGear(PCLOCKWORK pcw, PCOGSIZE pcsCogSize, float* pfCogOffset, 
                 D3DXVECTOR3* pvPos, D3DXVECTOR3* pvDir, float fAngularVelocity, 
                 float fRotation, PD3DRECT3D prectBox, DWORD dwDepth)
{
    PGEAR           pgear;
    D3DXMATRIX      mTranslate, mRotate, mWorld;
    float           fOrient, fAngle, fClipHeight, fClipRadius;
    BOOL            bRet;
    UINT            i, j;

    if (g_uNumGears == NUM_GEARS || dwDepth > g_dwMaxDepth) {
        return NULL;
    }

    if (!pcw || !pvPos || !pvDir) {
        return NULL;
    }

    if (pfCogOffset[1] < (3.0f * MIN_COG_SPACING)) {
        return NULL;
    }

    pgear = new GEAR;
    if (!pgear) {
        return NULL;
    }

    memset(pgear, 0, sizeof(GEAR));

    pgear->prShaft = (PVERTEX)MemAlloc32(pcw->dwShaftVertices * sizeof(VERTEX));
    if (!pgear->prShaft) {
        ReleaseGear(pgear);
        return NULL;
    }
    for (i = 0; i < pcw->dwShaftVertices; i++) {
        pgear->prShaft[i] = pcw->prUnitShaft[i];
        pgear->prShaft[i].vPosition.x *= pfCogOffset[1];
    }

    pgear->pd3drShaft = CreateVertexBuffer(g_pDevice, pgear->prShaft, pcw->dwShaftVertices * sizeof(VERTEX), 0, FVF_VERTEX);
    if (!pgear->pd3drShaft) {
        ReleaseGear(pgear);
        return NULL;
    }

#ifdef UNDER_XBOX
    pgear->pd3drShaft->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX

    for (j = 0; j < 3; j++) {

        switch (pcsCogSize[j]) {
            case COGSIZE_SMALL:
                bRet = CreateCog(&pgear->cog[j], S_COG_SIDES, S_COG_RADIUS, S_COG_WIDTH, !j ? 0.0f : pfCogOffset[j-1]);
                if (!j) {
                    fAngle = fRotation + M_PI / (float)S_COG_SIDES;
                }
                else {
                    pgear->csCogSize[j-1] = COGSIZE_SMALL;
                }
                break;
            case COGSIZE_MEDIUM:
                bRet = CreateCog(&pgear->cog[j], M_COG_SIDES, M_COG_RADIUS, M_COG_WIDTH, !j ? 0.0f : pfCogOffset[j-1]);
                if (!j) {
                    fAngle = fRotation + M_PI / (float)M_COG_SIDES;
                }
                else {
                    pgear->csCogSize[j-1] = COGSIZE_MEDIUM;
                }
                break;
            case COGSIZE_LARGE:
                bRet = CreateCog(&pgear->cog[j], L_COG_SIDES, L_COG_RADIUS, L_COG_WIDTH, !j ? 0.0f : pfCogOffset[j-1]);
                if (!j) {
                    fAngle = fRotation + M_PI / (float)L_COG_SIDES;
                }
                else {
                    pgear->csCogSize[j-1] = COGSIZE_LARGE;
                }
                break;
        }

        if (!bRet) {
            ReleaseGear(pgear);
            return NULL;
        }
    }

    pgear->fCogOffset[0] = pfCogOffset[0];
    pgear->fCogOffset[1] = pfCogOffset[1];

    for (i = 0; i < 3; i++) {
        pgear->cog[i].dwTextureIndex = g_uCogTextures++ % NUM_COG_TEXTURES;
    }
    pgear->dwShaftTextureIndex = g_uShaftTextures++ % NUM_SHAFT_TEXTURES;

    // Set up the rotation matrix
    InitMatrix(&pgear->mRotate,
        1.0f, 0.0f, 0.0f, 0.0f,
        0.0f, 1.0f, 0.0f, 0.0f,
        0.0f, 0.0f, 1.0f, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    );

    // Orient the gear in space
    if (pvDir->x != 0.0f) {

        fOrient = (pvDir->x > 0.0f) ? 0.0f : M_PI;

        InitMatrix(&mRotate,
            (float)( cos(fOrient)), (float)( 0.0f), (float)(-sin(fOrient)), (float)( 0.0f),
            (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( sin(fOrient)), (float)( 0.0f), (float)( cos(fOrient)), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
    }
    else if (pvDir->y != 0.0f) {

        fOrient = (pvDir->y > 0.0f) ? M_PIDIV2 : -M_PIDIV2;

        InitMatrix(&mRotate,
            (float)( cos(fOrient)), (float)( sin(fOrient)), (float)( 0.0f), (float)( 0.0f),
            (float)(-sin(fOrient)), (float)( cos(fOrient)), (float)( 0.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
    }
    else if (pvDir->z != 0.0f) {

        fOrient = (pvDir->z > 0.0f) ? -M_PIDIV2 : M_PIDIV2;

        InitMatrix(&mRotate,
            (float)( cos(fOrient)), (float)( 0.0f), (float)(-sin(fOrient)), (float)( 0.0f),
            (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( sin(fOrient)), (float)( 0.0f), (float)( cos(fOrient)), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
    }
    else {
        ReleaseGear(pgear);
        return NULL;
    }

    InitMatrix(&mTranslate,
        (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
        (float)( pvPos->x), (float)( pvPos->y), (float)( pvPos->z), (float)( 1.0f)
    );

    D3DXMatrixMultiply(&mWorld, &mRotate, &mTranslate);

    InitMatrix(&mRotate,
        (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
        (float)( 0.0f), (float)( cos(fAngle)), (float)( sin(fAngle)), (float)( 0.0f),
        (float)( 0.0f), (float)(-sin(fAngle)), (float)( cos(fAngle)), (float)( 0.0f),
        (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
    );

    D3DXMatrixMultiply(&pgear->mWorld, &mRotate, &mWorld);

    fClipHeight = (float)(tan(((g_fFieldOfView / 2.0f) * 480.0f) / 640.0f)) * ((float)(fabs(VIEW_Z)) - 32.0f);

    for (i = 0; i < 4; i++) {
        g_rectBox[g_uNumBoxes++] = prectBox[i];

        if (prectBox[i].v1.y > -fClipHeight && prectBox[i].v2.y < fClipHeight) {

            fClipRadius = (float)(cos(g_fFieldOfView / 2.0f)) * (float)(fabs(VIEW_Z));

            if (D3DXVec3Length(&D3DXVECTOR3(prectBox[i].v1.x, 0.0f, prectBox[i].v2.z)) < fClipRadius &&
                D3DXVec3Length(&D3DXVECTOR3(prectBox[i].v2.x, 0.0f, prectBox[i].v2.z)) < fClipRadius) 
            {
                pgear->dwClip[i] = FALSE;
            }
            else {
                pgear->dwClip[i] = TRUE;
            }
        }
    }

    g_uNumGears++;

    pgear->vPos = *pvPos;
    pgear->vDir = *pvDir;
    pgear->fAngularVelocity = fAngularVelocity;
    pgear->fSpin = fAngle;

    // Create attached gears
    for (i = 0; i < 2; i++) {
        pgear->pgearNext[i] = AddAttachedGear(pcw, pgear, i, dwDepth);
    }

    return pgear;
}

//******************************************************************************
PGEAR AddAttachedGear(PCLOCKWORK pcw, PGEAR pgearParent, UINT uCog, DWORD dwDepth) {

    PGEAR           pgear = NULL;
    COGSIZE         csCogSize[3];
    D3DXVECTOR3     vPos, vDir, vOffset;
    float           fCogOffset[2];
    float           fRotate, fAngle2;
    UINT            uDir, uBlocked, uBlockedDir[6];
    D3DRECT3D       rectBox[4];
    BOOL            bCollision;
    UINT            i, j;
    static float    fCogRadius[3] = {
                        S_COG_RADIUS,
                        M_COG_RADIUS,
                        L_COG_RADIUS
                    };
    static float    fCogWidth[3] = {
                        S_COG_WIDTH,
                        M_COG_WIDTH,
                        L_COG_WIDTH
                    };
    static float    fGearRatio[3] = {
                        (float)(S_COG_SIDES) / (float)(S_COG_SIDES),
                        (float)(M_COG_SIDES) / (float)(S_COG_SIDES),
                        (float)(L_COG_SIDES) / (float)(S_COG_SIDES)
                    };

    // Choose cog sizes for the attached gear
    for (j = 0; j < 3; j++) {
        switch (rand() % 3) {
            case 0:
                csCogSize[j] = COGSIZE_SMALL;
                break;
            case 1:
                csCogSize[j] = COGSIZE_MEDIUM;
                break;
            case 2:
                csCogSize[j] = COGSIZE_LARGE;
                break;
        }
    }

    // Space the cogs out
    fCogOffset[1] = GEAR_LENGTH;
    fCogOffset[0] = MIN_COG_SPACING + (FRND(fCogOffset[1] - 2.0f * MIN_COG_SPACING));

    memset(uBlockedDir, 0, 6 * sizeof(UINT));

    // Disallow parallel shafts connected to the center gear
    if (!uCog) {
        if (pgearParent->vDir.x != 0.0f) {
            uBlockedDir[0] = 1;
            uBlockedDir[1] = 1;
        }
        else if (pgearParent->vDir.y != 0.0f) {
            uBlockedDir[2] = 1;
            uBlockedDir[3] = 1;
        }
        else {
            uBlockedDir[4] = 1;
            uBlockedDir[5] = 1;
        }
        uBlocked = 2;
    }
    else {
        uBlocked = 0;
    }

    do {

        vPos = pgearParent->vPos + (pgearParent->vDir * pgearParent->fCogOffset[uCog]);

        do {
            uDir = rand() % 6;
        } while (uBlockedDir[uDir]);

        switch (uDir) {
            case 0:
                vDir = D3DXVECTOR3(1.0f, 0.0f, 0.0f);
                break;
            case 1:
                vDir = D3DXVECTOR3(-1.0f, 0.0f, 0.0f);
                break;
            case 2:
                vDir = D3DXVECTOR3(0.0f, 1.0f, 0.0f);
                break;
            case 3:
                vDir = D3DXVECTOR3(0.0f, -1.0f, 0.0f);
                break;
            case 4:
                vDir = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
                break;
            case 5:
                vDir = D3DXVECTOR3(0.0f, 0.0f, -1.0f);
                break;
        }

        if ((pgearParent->vDir.x != 0.0f && vDir.x != 0.0f) ||
            (pgearParent->vDir.y != 0.0f && vDir.y != 0.0f) ||
            (pgearParent->vDir.z != 0.0f && vDir.z != 0.0f))   // Parallel shafts
        {
            vOffset = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
            if (vDir.x != 0.0f) {
                if (rand() % 2) {
                    vOffset.y = (rand() % 2) ? 1.0f : -1.0f;
                }
                else {
                    vOffset.z = (rand() % 2) ? 1.0f : -1.0f;
                }
            }
            else if (vDir.y != 0.0f) {
                if (rand() % 2) {
                    vOffset.x = (rand() % 2) ? 1.0f : -1.0f;
                }
                else {
                    vOffset.z = (rand() % 2) ? 1.0f : -1.0f;
                }
            }
            else {
                if (rand() % 2) {
                    vOffset.y = (rand() % 2) ? 1.0f : -1.0f;
                }
                else {
                    vOffset.x = (rand() % 2) ? 1.0f : -1.0f;
                }
            }

            vOffset *= (fCogRadius[pgearParent->csCogSize[uCog]] + fCogRadius[csCogSize[0]] + TOOTH_HEIGHT);
            vPos += vOffset;

            if (pgearParent->vDir == vDir) {
                fRotate = -1.0f;
            }
            else {
                fRotate = 1.0f;
            }
        }
        else {

            vOffset = vDir * (fCogRadius[pgearParent->csCogSize[uCog]] + fCogWidth[csCogSize[0]] / 2.0f);
            fRotate = (rand() % 2) ? 1.0f : -1.0f;
            vOffset += (pgearParent->vDir * (fRotate * (fCogRadius[csCogSize[0]] + fCogWidth[pgearParent->csCogSize[uCog]] / 2.0f)));
            vPos += vOffset;
        }

        if ((pgearParent->vDir.x != 0.0f && vOffset.y > 0.0f) || (pgearParent->vDir.y != 0.0f && vOffset.x > 0.0f) || (pgearParent->vDir.z != 0.0f && vOffset.y > 0.0f)) {
            fAngle2 = M_PIDIV2 * (fGearRatio[pgearParent->csCogSize[uCog]] / fGearRatio[csCogSize[0]]) + M_PIDIV2;
        }
        else if ((pgearParent->vDir.x != 0.0f && vOffset.y < 0.0f) || (pgearParent->vDir.y != 0.0f && vOffset.x < 0.0f) || (pgearParent->vDir.z != 0.0f && vOffset.y < 0.0f)) {
            fAngle2 = M_PIDIV2 * (fGearRatio[pgearParent->csCogSize[uCog]] / fGearRatio[csCogSize[0]]) + M_3PIDIV2;
        }
        else if ((pgearParent->vDir.x != 0.0f && vOffset.z > 0.0f) || (pgearParent->vDir.y != 0.0f && vOffset.z > 0.0f) || (pgearParent->vDir.z != 0.0f && vOffset.x < 0.0f)) {
            fAngle2 = M_PIDIV2 * (fGearRatio[pgearParent->csCogSize[uCog]] / fGearRatio[csCogSize[0]]) + M_PI;
        }
        else {
            fAngle2 = 0.0f;
        }

        fAngle2 += fRotate * pgearParent->fSpin * (fGearRatio[pgearParent->csCogSize[uCog]] / fGearRatio[csCogSize[0]]);
        if (fRotate > 0.0f) {
            fAngle2 += M_PI;
        }

        if (vDir.x > 0.0f) {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] / 2.0f), vPos.y - SHAFT_RADIUS, vPos.z - SHAFT_RADIUS), &D3DXVECTOR3(vPos.x + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.y + SHAFT_RADIUS, vPos.z + SHAFT_RADIUS));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] / 2.0f), vPos.y - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.z - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogWidth[csCogSize[0]] / 2.0f), vPos.y + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x + fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f), vPos.y - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f), vPos.y + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x + fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.y - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.y + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)));
        }
        else if (vDir.x < 0.0f) {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.y - SHAFT_RADIUS, vPos.z - SHAFT_RADIUS), &D3DXVECTOR3(vPos.x + (fCogWidth[csCogSize[0]] / 2.0f), vPos.y + SHAFT_RADIUS, vPos.z + SHAFT_RADIUS));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] / 2.0f), vPos.y - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.z - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogWidth[csCogSize[0]] / 2.0f), vPos.y + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x - fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f), vPos.y - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x - fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f), vPos.y + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.y - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x - fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.y + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)));
        }
        else if (vDir.y > 0.0f) {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - SHAFT_RADIUS, vPos.y - (fCogWidth[csCogSize[0]] / 2.0f), vPos.z - SHAFT_RADIUS), &D3DXVECTOR3(vPos.x + SHAFT_RADIUS, vPos.y + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.z + SHAFT_RADIUS));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.y - (fCogWidth[csCogSize[0]] / 2.0f), vPos.z - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.y + (fCogWidth[csCogSize[0]] / 2.0f), vPos.z + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y + fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f), vPos.z - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y + fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f), vPos.z + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y + fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.z - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.z + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)));
        }
        else if (vDir.y < 0.0f) {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - SHAFT_RADIUS, vPos.y - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.z - SHAFT_RADIUS), &D3DXVECTOR3(vPos.x + SHAFT_RADIUS, vPos.y + (fCogWidth[csCogSize[0]] / 2.0f), vPos.z + SHAFT_RADIUS));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.y - (fCogWidth[csCogSize[0]] / 2.0f), vPos.z - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.y + (fCogWidth[csCogSize[0]] / 2.0f), vPos.z + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y - fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f), vPos.z - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y - fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f), vPos.z + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f), vPos.z - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y - fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f), vPos.z + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT)));
        }
        else if (vDir.z > 0.0f) {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - SHAFT_RADIUS, vPos.y - SHAFT_RADIUS, vPos.z - (fCogWidth[csCogSize[0]] / 2.0f)), &D3DXVECTOR3(vPos.x + SHAFT_RADIUS, vPos.y + SHAFT_RADIUS, vPos.z + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f)));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.y - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.z - (fCogWidth[csCogSize[0]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.z + (fCogWidth[csCogSize[0]] / 2.0f)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z + fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z + fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z + fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z + fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f)));
        }
        else {
            SetRect3D(&rectBox[0], &D3DXVECTOR3(vPos.x - SHAFT_RADIUS, vPos.y - SHAFT_RADIUS, vPos.z - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f)), &D3DXVECTOR3(vPos.x + SHAFT_RADIUS, vPos.y + SHAFT_RADIUS, vPos.z + (fCogWidth[csCogSize[0]] / 2.0f)));
            SetRect3D(&rectBox[1], &D3DXVECTOR3(vPos.x - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.y - (fCogWidth[csCogSize[0]] + TOOTH_HEIGHT), vPos.z - (fCogWidth[csCogSize[0]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[0]] + TOOTH_HEIGHT), vPos.z + (fCogWidth[csCogSize[0]] / 2.0f)));
            SetRect3D(&rectBox[2], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y - (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z - fCogOffset[0] - (fCogWidth[csCogSize[1]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[1]] + TOOTH_HEIGHT), vPos.z - fCogOffset[0] + (fCogWidth[csCogSize[1]] / 2.0f)));
            SetRect3D(&rectBox[3], &D3DXVECTOR3(vPos.x - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y - (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z - fCogOffset[1] - (fCogWidth[csCogSize[2]] / 2.0f)), &D3DXVECTOR3(vPos.x + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.y + (fCogRadius[csCogSize[2]] + TOOTH_HEIGHT), vPos.z - fCogOffset[1] + (fCogWidth[csCogSize[2]] / 2.0f)));
        }

        bCollision = FALSE;

        for (j = 0; j < 4 && !bCollision; j++) {
            for (i = 0; i < g_uNumBoxes && !bCollision; i++) {
                bCollision = GearCollision(&rectBox[j], &g_rectBox[i]);
            }
        }

        if (bCollision) {
            uBlockedDir[uDir] = 1;
            uBlocked++;
        }

    } while (bCollision && uBlocked < 6);

    if (uBlocked < 6) {
        pgear = CreateGear(pcw, csCogSize, fCogOffset, &vPos, &vDir, fRotate * pgearParent->fAngularVelocity * (fGearRatio[pgearParent->csCogSize[uCog]] / fGearRatio[csCogSize[0]]), fAngle2, rectBox, dwDepth+1);
    }

    return pgear;
}

//******************************************************************************
void AddGear(PCLOCKWORK pcw, PGEAR pgear, DWORD dwDepth) {

    UINT i;

    if (g_uNumGears == NUM_GEARS || dwDepth > g_dwMaxDepth) {
        return;
    }

    for (i = 0; i < 2; i++) {

        if (!pgear->pgearNext[i]) {
            pgear->pgearNext[i] = AddAttachedGear(pcw, pgear, i, dwDepth);
        }
        else {
            AddGear(pcw, pgear->pgearNext[i], dwDepth + 1);
        }
    }
}

//******************************************************************************
void RotateGear(PCLOCKWORK pcw, PGEAR pgear, float fTheta) {

    float       fAngularVelocity;
    D3DXMATRIX  r;
    UINT        i;

    if (!pgear) {
        return;
    }

    fAngularVelocity = fTheta * pgear->fAngularVelocity;
    pgear->mRotate._22 = (float)(cos(fAngularVelocity));
    pgear->mRotate._23 = (float)(sin(fAngularVelocity));
    pgear->mRotate._32 = -pgear->mRotate._23;
    pgear->mRotate._33 = pgear->mRotate._22;

    D3DXMatrixMultiply(&r, &pgear->mRotate, &pgear->mWorld);

    memcpy(&pgear->mWorld, &r, sizeof(D3DMATRIX));

    for (i = 0; i < 2; i++) {
        RotateGear(pcw, pgear->pgearNext[i], fTheta);
    }
}

//******************************************************************************
void RenderGear(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw, PGEAR pgear) {

    UINT i, j;

    if (!pgear) {
        return;
    }

    // Set the world transform
    pDevice->SetTransform(D3DTS_WORLD, &pgear->mWorld);

    pDevice->SetTexture(0, pcw->pd3dtShaft[pgear->dwShaftTextureIndex]);

#ifndef UNDER_XBOX
    pDevice->SetRenderState(D3DRS_CLIPPING, pgear->dwClip[0]);
#endif // !UNDER_XBOX

    pDevice->SetStreamSource(0, pgear->pd3drShaft, sizeof(VERTEX));
    pDevice->SetIndices(pcw->pd3diShaft, 0);

    // Draw the shaft
    pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, pcw->dwShaftVertices,
                    0, pcw->dwShaftIndices / 3);

    for (i = 0; i < 3; i++) {

        pDevice->SetTexture(0, pcw->pd3dtCog[pgear->cog[i].dwTextureIndex]);

#ifndef UNDER_XBOX
        pDevice->SetRenderState(D3DRS_CLIPPING, pgear->dwClip[i+1]);
#endif // !UNDER_XBOX

        pDevice->SetStreamSource(0, pgear->cog[i].pd3drCenter, sizeof(VERTEX));
        pDevice->SetIndices(pgear->cog[i].pd3diCenter, 0);

        pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0,
                    pgear->cog[i].dwCenterVertices, 0, pgear->cog[i].dwCenterIndices / 3);

        pDevice->SetStreamSource(0, pgear->cog[i].pd3drTeeth, sizeof(VERTEX));

        for (j = 0; j < pgear->cog[i].dwSides; j++) {
            pDevice->SetIndices(pcw->pd3diTooth, j * 8);
            pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0,
                    pcw->dwToothVertices, 0, pcw->dwToothIndices / 3);
        }
    }

    for (i = 0; i < 2; i++) {
        RenderGear(pDevice, pcw, pgear->pgearNext[i]);
    }
}

//******************************************************************************
void ReleaseGear(PGEAR pgear) {

    if (pgear) {
        UINT i;
        for (i = 0; i < 2; i++) {
            if (pgear->pgearNext[i]) {
                ReleaseGear(pgear->pgearNext[i]);
            }
        }
        ReleaseVertexBuffer(pgear->pd3drShaft);
        if (pgear->prShaft) {
            MemFree32(pgear->prShaft);
        }
        for (i = 0; i < 3; i++) {
            ReleaseCog(&pgear->cog[i]);
        }
        delete [] pgear;
        pgear = NULL;
    }
}

//******************************************************************************
BOOL CreateClockwork(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw) {

    COGSIZE      csCogSize[3];
    float        fCogOffset[2];
    D3DRECT3D    rectBox[4];
    UINT         i, uIndex;
    TCHAR        szTexture[256];
    D3DVIEWPORT8 viewport;
    float        fBoundHeight;
    
    if (!pcw) {
        return FALSE;
    }

    // ##HACK
    g_pDevice = pDevice;

    memset(pcw, 0, sizeof(CLOCKWORK));

    // Create textures
    for (i = 0; i < NUM_COG_TEXTURES; i++) {
        _stprintf(szTexture, TEXT("cog%d.bmp"), i);
        pcw->pd3dtCog[i] = (LPDIRECT3DTEXTURE8)CreateTexture(pDevice, szTexture, D3DFMT_A8R8G8B8);
        if (!pcw->pd3dtCog[i]) {
            ReleaseClockwork(pcw);
            return FALSE;
        }
#ifdef UNDER_XBOX
        pcw->pd3dtCog[i]->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX
    }

    for (i = 0; i < NUM_SHAFT_TEXTURES; i++) {
        _stprintf(szTexture, TEXT("shaft%d.bmp"), i);
        pcw->pd3dtShaft[i] = (LPDIRECT3DTEXTURE8)CreateTexture(pDevice, szTexture, D3DFMT_A8R8G8B8);
        if (!pcw->pd3dtShaft[i]) {
            ReleaseClockwork(pcw);
            return FALSE;
        }
#ifdef UNDER_XBOX
        pcw->pd3dtShaft[i]->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX
    }

    // Create a pentagonal shaft cylinder of length 1.0
    if (!CreateCylinder((PVERTEX*)&pcw->prUnitShaft, &pcw->dwShaftVertices, &pcw->pwShaft, 
                        &pcw->dwShaftIndices, 5, SHAFT_RADIUS, 1.0f, CYLCAPS_NONE))
    {
        ReleaseClockwork(pcw);
        return FALSE;
    }

    for (i = 0; i < pcw->dwShaftVertices; i++) {
        pcw->prUnitShaft[i].vPosition.x += 0.5f;
    }

    // Initialize tooth vertices and indices
    pcw->dwToothVertices = 8;
    pcw->dwToothIndices = 30;
    pcw->pwTooth = new WORD[pcw->dwToothIndices];
    if (!pcw->pwTooth) {
        ReleaseClockwork(pcw);
        return FALSE;
    }

    for (i = 0, uIndex = 0; i < 3; i++) {
        pcw->pwTooth[uIndex++] = i * 2;
        pcw->pwTooth[uIndex++] = i * 2 + 2;
        pcw->pwTooth[uIndex++] = i * 2 + 3;
        pcw->pwTooth[uIndex++] = i * 2;
        pcw->pwTooth[uIndex++] = i * 2 + 3;
        pcw->pwTooth[uIndex++] = i * 2 + 1;
    }

    for (i = 1; i < 3; i++) {
        pcw->pwTooth[uIndex++] = 0;
        pcw->pwTooth[uIndex++] = (i + 1) * 2;
        pcw->pwTooth[uIndex++] = i * 2;
    }

    for (i = 1; i < 3; i++) {
        pcw->pwTooth[uIndex++] = 1;
        pcw->pwTooth[uIndex++] = i * 2 + 1;
        pcw->pwTooth[uIndex++] = (i + 1) * 2 + 1;
    }

//    if (!OptimizeIndexedList(pcw->pwTooth, pcw->dwToothIndices)) {
//        ReleaseClockwork(pcw);
//        return false;
//    }

    pcw->pd3diShaft = CreateIndexBuffer(pDevice, pcw->pwShaft, pcw->dwShaftIndices * sizeof(WORD));
    if (!pcw->pd3diShaft) {
        ReleaseClockwork(pcw);
        return FALSE;
    }

    pcw->pd3diTooth = CreateIndexBuffer(pDevice, pcw->pwTooth, pcw->dwToothIndices * sizeof(WORD));
    if (!pcw->pd3diTooth) {
        ReleaseClockwork(pcw);
        return FALSE;
    }

    // Create six bounding boxes to enclose the gears
//    SetRect3D(&g_rectBox[0], &D3DXVECTOR3(-33.0f, -24.0f, -32.0f), &D3DXVECTOR3(-32.0f, 24.0f, 32.0f));
//    SetRect3D(&g_rectBox[1], &D3DXVECTOR3(32.0f, -24.0f, -32.0f), &D3DXVECTOR3(33.0f, 24.0f, 32.0f));
//    SetRect3D(&g_rectBox[2], &D3DXVECTOR3(-32.0f, -25.0f, -32.0f), &D3DXVECTOR3(32.0f, -24.0f, 32.0f));
//    SetRect3D(&g_rectBox[3], &D3DXVECTOR3(-32.0f, 24.0f, -32.0f), &D3DXVECTOR3(32.0f, 25.0f, 32.0f));
//    SetRect3D(&g_rectBox[4], &D3DXVECTOR3(-32.0f, -24.0f, -33.0f), &D3DXVECTOR3(32.0f, 24.0f, -32.0f));
//    SetRect3D(&g_rectBox[5], &D3DXVECTOR3(-32.0f, -24.0f, 32.0f), &D3DXVECTOR3(32.0f, 24.0f, 33.0f));

    pDevice->GetViewport(&viewport);
    fBoundHeight = BOUND_RADIUS * ((float)viewport.Height / (float)viewport.Width);

    SetRect3D(&g_rectBox[0], &D3DXVECTOR3(-BOUND_RADIUS - 1.0f, -fBoundHeight, -BOUND_RADIUS), &D3DXVECTOR3(-BOUND_RADIUS, fBoundHeight, BOUND_RADIUS));
    SetRect3D(&g_rectBox[1], &D3DXVECTOR3(BOUND_RADIUS, -fBoundHeight, -BOUND_RADIUS), &D3DXVECTOR3(BOUND_RADIUS + 1.0f, fBoundHeight, BOUND_RADIUS));
    SetRect3D(&g_rectBox[2], &D3DXVECTOR3(-BOUND_RADIUS, -fBoundHeight - 1.0f, -BOUND_RADIUS), &D3DXVECTOR3(BOUND_RADIUS, -fBoundHeight, BOUND_RADIUS));
    SetRect3D(&g_rectBox[3], &D3DXVECTOR3(-BOUND_RADIUS, fBoundHeight, -BOUND_RADIUS), &D3DXVECTOR3(BOUND_RADIUS, fBoundHeight + 1.0f, BOUND_RADIUS));
    SetRect3D(&g_rectBox[4], &D3DXVECTOR3(-BOUND_RADIUS, -fBoundHeight, -BOUND_RADIUS - 1.0f), &D3DXVECTOR3(BOUND_RADIUS, fBoundHeight, -BOUND_RADIUS));
    SetRect3D(&g_rectBox[5], &D3DXVECTOR3(-BOUND_RADIUS, -fBoundHeight, BOUND_RADIUS), &D3DXVECTOR3(BOUND_RADIUS, fBoundHeight, BOUND_RADIUS + 1.0f));

//float fBound = BOUND_RADIUS;
//    SetRect3D(&g_rectBox[0], &D3DXVECTOR3(-fBound, -fBound, -fBound), &D3DXVECTOR3(-fBound, fBound, fBound));
//    SetRect3D(&g_rectBox[1], &D3DXVECTOR3(fBound, -fBound, -fBound), &D3DXVECTOR3(fBound, fBound, fBound));
//    SetRect3D(&g_rectBox[2], &D3DXVECTOR3(-fBound, -fBound, -fBound), &D3DXVECTOR3(fBound, -fBound, fBound));
//    SetRect3D(&g_rectBox[3], &D3DXVECTOR3(-fBound, fBound, -fBound), &D3DXVECTOR3(fBound, fBound, fBound));
//    SetRect3D(&g_rectBox[4], &D3DXVECTOR3(-fBound, -fBound, -fBound), &D3DXVECTOR3(fBound, fBound, -fBound));
//    SetRect3D(&g_rectBox[5], &D3DXVECTOR3(-fBound, -fBound, fBound), &D3DXVECTOR3(fBound, fBound, fBound));

    g_uNumBoxes = 6;

    g_uNumGears = 0;

    g_uCogTextures = 0;
    g_uShaftTextures = 0;

    g_dwMaxDepth = ((UINT)((float)(log((double)NUM_GEARS)) / (float)(log(2.0))) + 1);

    csCogSize[0] = COGSIZE_SMALL;
    csCogSize[1] = COGSIZE_LARGE;
    csCogSize[2] = COGSIZE_MEDIUM;
    fCogOffset[1] = GEAR_LENGTH;
    fCogOffset[0] = fCogOffset[1] / 2.0f;
    SetRect3D(&rectBox[0], &D3DXVECTOR3(-10.0f - (S_COG_WIDTH / 2.0f), -SHAFT_RADIUS, -SHAFT_RADIUS), &D3DXVECTOR3(-10.0f + fCogOffset[1] + (M_COG_WIDTH / 2.0f), SHAFT_RADIUS, SHAFT_RADIUS));
    SetRect3D(&rectBox[1], &D3DXVECTOR3(-10.0f - (S_COG_WIDTH / 2.0f), -(S_COG_RADIUS + TOOTH_HEIGHT), -(S_COG_RADIUS + TOOTH_HEIGHT)), &D3DXVECTOR3(-10.0f + (S_COG_WIDTH / 2.0f), (S_COG_RADIUS + TOOTH_HEIGHT), (S_COG_RADIUS + TOOTH_HEIGHT)));
    SetRect3D(&rectBox[2], &D3DXVECTOR3(-10.0f + fCogOffset[0] - (L_COG_WIDTH / 2.0f), -(L_COG_RADIUS + TOOTH_HEIGHT), -(L_COG_RADIUS + TOOTH_HEIGHT)), &D3DXVECTOR3(-10.0f + fCogOffset[0] + (L_COG_WIDTH / 2.0f), (L_COG_RADIUS + TOOTH_HEIGHT), (L_COG_RADIUS + TOOTH_HEIGHT)));
    SetRect3D(&rectBox[3], &D3DXVECTOR3(-10.0f + fCogOffset[1] - (M_COG_WIDTH / 2.0f), -(M_COG_RADIUS + TOOTH_HEIGHT), -(M_COG_RADIUS + TOOTH_HEIGHT)), &D3DXVECTOR3(-10.0f + fCogOffset[1] + (M_COG_WIDTH / 2.0f), (M_COG_RADIUS + TOOTH_HEIGHT), (M_COG_RADIUS + TOOTH_HEIGHT)));

    pcw->pgearRoot = CreateGear(pcw, csCogSize, fCogOffset, &D3DXVECTOR3(-10.0f, 0.0f, 0.0f), &D3DXVECTOR3(1.0f, 0.0f, 0.0f), 1.0f, 0.0f, rectBox);
    if (!pcw->pgearRoot) {
        ReleaseClockwork(pcw);
        return FALSE;
    }

DebugString(TEXT("Created gears: %d"), g_uNumGears);

    for (g_dwMaxDepth++; g_uNumGears < NUM_GEARS && g_dwMaxDepth <= 15; g_dwMaxDepth++) {
        AddGear(pcw, pcw->pgearRoot);
    }

DebugString(TEXT("Created gears: %d"), g_uNumGears);

    if (g_uNumGears != NUM_GEARS) {
        DebugString(TEXT("WARNING: The requested number of gears (%d) could ")
                    TEXT("not be created: only %d gears fit into the scene.\r\n")
                    TEXT("Please lower the number of gears requested or change ")
                    TEXT("the seed for the pseudo-random number generator to\r\n")
                    TEXT("obtain a different gear set"), NUM_GEARS, g_uNumGears);
    }

    return TRUE;
}

//******************************************************************************
void UpdateClockwork(PCLOCKWORK pcw, float fTimeDilation) {

    RotateGear(pcw, pcw->pgearRoot, M_PI / 40.0f * fTimeDilation);
}

//******************************************************************************
void RenderClockwork(LPDIRECT3DDEVICE8 pDevice, PCLOCKWORK pcw) {

    RenderGear(pDevice, pcw, pcw->pgearRoot);
}

//******************************************************************************
void ReleaseClockwork(PCLOCKWORK pcw) {

    UINT i;

    ReleaseIndexBuffer(pcw->pd3diShaft);
    ReleaseIndexBuffer(pcw->pd3diTooth);
    ReleaseCylinder(pcw->prUnitShaft, pcw->pwShaft);
    if (pcw->pwTooth) {
        delete [] pcw->pwTooth;
    }

    for (i = 0; i < NUM_COG_TEXTURES; i++) {
        if (pcw->pd3dtCog[i]) {
            ReleaseTexture(pcw->pd3dtCog[i]);
        }
    }
    for (i = 0; i < NUM_SHAFT_TEXTURES; i++) {
        if (pcw->pd3dtShaft[i]) {
            ReleaseTexture(pcw->pd3dtShaft[i]);
        }
    }

    ReleaseGear(pcw->pgearRoot);
    memset(pcw, 0, sizeof(CLOCKWORK));
}

//******************************************************************************
// Create a cylinder oriented along the x axis
BOOL CreateCylinder(PVERTEX* pprVertices, LPDWORD pdwNumVertices, 
                    LPWORD* ppwIndices, LPDWORD pdwNumIndices, 
                    DWORD dwSides, float fRadius, float fWidth,
                    DWORD dwCylinderCaps) 
{
    PVERTEX     prVertices;
    DWORD       dwNumVertices;
    LPWORD      pwIndices;
    DWORD       dwNumIndices;
    float       fSin, fCos, fTheta, fDelta;
    D3DXVECTOR3 vN;
    UINT        uIndex;
    UINT        i;

    if (!pprVertices || !pdwNumVertices || !ppwIndices || !pdwNumIndices) {
        return FALSE;
    }

    dwNumVertices = dwSides * 2;

    prVertices = (PVERTEX)MemAlloc32(dwNumVertices * sizeof(VERTEX));
    if (!prVertices) {
        return FALSE;
    }

    fDelta = M_2PI / (float)(dwSides);

    for (i = 0, fTheta = 0.0f; i < dwSides; i++, fTheta += fDelta) {

        fSin = (float)(sin(fTheta));
        fCos = (float)(cos(fTheta));

        prVertices[i*2]   = VERTEX(D3DXVECTOR3(fWidth / 2.0f, fSin * fRadius, fCos * fRadius),
                                      *D3DXVec3Normalize(&vN, &D3DXVECTOR3(1.0f, fSin, fCos)), 
                                      1.0f - ((fCos + 1.0f) / 2.0f), 1.0f - ((fSin + 1.0f) / 2.0f));
        prVertices[i*2+1] = VERTEX(D3DXVECTOR3(-fWidth / 2.0f, fSin * fRadius, fCos * fRadius),
                                      *D3DXVec3Normalize(&vN, &D3DXVECTOR3(-1.0f, fSin, fCos)), 
                                      (fCos + 1.0f) / 2.0f, 1.0f - ((fSin + 1.0f) / 2.0f));
    }

    dwNumIndices = 6 * dwSides;
    if (dwCylinderCaps & CYLCAPS_TOP) {
        dwNumIndices += 3 * (dwSides - 2);
    }
    if (dwCylinderCaps & CYLCAPS_BOTTOM) {
        dwNumIndices += 3 * (dwSides - 2);
    }

    pwIndices = new WORD[dwNumIndices];
    if (!pwIndices) {
        MemFree32(prVertices);
        return FALSE;
    }

    for (i = 0, uIndex = 0; i < dwSides - 1; i++) {
        pwIndices[uIndex++] = i * 2;
        pwIndices[uIndex++] = i * 2 + 2;
        pwIndices[uIndex++] = i * 2 + 3;
        pwIndices[uIndex++] = i * 2;
        pwIndices[uIndex++] = i * 2 + 3;
        pwIndices[uIndex++] = i * 2 + 1;
    }

    pwIndices[uIndex++] = i * 2;
    pwIndices[uIndex++] = 0;
    pwIndices[uIndex++] = 1;
    pwIndices[uIndex++] = i * 2;
    pwIndices[uIndex++] = 1;
    pwIndices[uIndex++] = i * 2 + 1;

    if (dwCylinderCaps & CYLCAPS_TOP) {

        for (i = 1; i < dwSides - 1; i++) {
            pwIndices[uIndex++] = 0;
            pwIndices[uIndex++] = (i + 1) * 2;
            pwIndices[uIndex++] = i * 2;
        }
    }

    if (dwCylinderCaps & CYLCAPS_BOTTOM) {

        for (i = 1; i < dwSides - 1; i++) {
            pwIndices[uIndex++] = 1;
            pwIndices[uIndex++] = i * 2 + 1;
            pwIndices[uIndex++] = (i + 1) * 2 + 1;
        }
    }

//    if (!OptimizeIndexedList(pwIndices, dwNumIndices)) {
//        MemFree32(prVertices);
//        delete [] pwIndices;
//        return false;
//    }

    *pprVertices = prVertices;
    *pdwNumVertices = dwNumVertices;
    *ppwIndices = pwIndices;
    *pdwNumIndices = dwNumIndices;

    return TRUE;
}

//******************************************************************************
void ReleaseCylinder(PVERTEX prVertices, LPWORD pwIndices) {

    if (prVertices) {
        MemFree32(prVertices);
    }

    if (pwIndices) {
        delete [] pwIndices;
    }
}

//******************************************************************************
void SetRect3D(PD3DRECT3D prect, D3DXVECTOR3* pv1, D3DXVECTOR3* pv2) {
    
    prect->v1 = *pv1;
    prect->v2 = *pv2;
}

//******************************************************************************
BOOL GearCollision(PD3DRECT3D prectBox1, PD3DRECT3D prectBox2) {

    return !((prectBox1->v1.x >= prectBox2->v2.x || prectBox1->v2.x <= prectBox2->v1.x) ||
             (prectBox1->v1.y >= prectBox2->v2.y || prectBox1->v2.y <= prectBox2->v1.y) ||
             (prectBox1->v1.z >= prectBox2->v2.z || prectBox1->v2.z <= prectBox2->v1.z));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\sources.inc ===
TARGETNAME=clockwrk
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\sources.inc

SOURCES=\
    main.cpp \
    clockwork.cpp \
    cogs.cpp \
    clockwork.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\rteapot\sources.inc ===
TARGETNAME=rteapot
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\sources.inc

SOURCES=\
    main.cpp \
    rteapot.cpp \
    rteapot.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\rteapot\rteapot.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    rteapot.h

Author:

    Matt Bronder

Description:

    Direct3D test functions.

*******************************************************************************/

#ifndef __RTEAPOT_H__
#define __RTEAPOT_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define NUM_TEAPOTS                1

//******************************************************************************
// Function prototypes
//******************************************************************************

int         ExhibitScene(CDisplay* pDisplay);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
class CTeapot : public CScene {

protected:

    LPDIRECT3DVERTEXBUFFER8         m_pd3dr;
    LPDIRECT3DINDEXBUFFER8          m_pd3di;
    LPDIRECT3DVERTEXBUFFER8         m_pd3drBack;
    LPDIRECT3DTEXTURE8              m_pd3dt;
    D3DXMATRIX                      m_pmWorld[NUM_TEAPOTS];
    D3DXMATRIX                      m_pmRotation[NUM_TEAPOTS];
    MESH                            m_mesh;

public:

                                    CTeapot();
                                    ~CTeapot();

    virtual BOOL                    Create(CDisplay* pDisplay);
    virtual int                     Exhibit(int *pnExitCode);

protected:

    virtual BOOL                    Setup();
    virtual BOOL                    Initialize();
    virtual void                    Efface();
    virtual void                    Update();
    virtual BOOL                    Render();

    virtual void                    ProcessInput();
    virtual BOOL                    InitView();

    virtual BOOL                    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
};

#endif //__RTEAPOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\clockwork\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Author:

    Matt Bronder

Description:

    Application entry point.

*******************************************************************************/

#include "d3dbase.h"

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifdef UNDER_XBOX

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

#endif // UNDER_XBOX

int         ExhibitScene(CDisplay* pDisplay, int *pnExitCode);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
// WinMain
//******************************************************************************

#ifndef UNDER_XBOX
#define RETURN(x)   return x
#else
#define RETURN(x)   return
#endif // UNDER_XBOX

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif // UNDER_XBOX
{
    CDisplay*       pDisplay;
    D3DCREATIONDESC d3dcd;
    int             ret;

    // Allow global access to the instance handle
#ifndef UNDER_XBOX
    RegisterInstance(hInstance);
#else
    RegisterInstance(NULL);
#endif

    // Seed the pseudo-random number generator
    srand(GetTickCount());

    // Create a heap for the application
    if (!CreateHeap()) {
        RETURN(0);
    }

    // Set the validation procedure for the device
    InitCheckDisplayProc(ValidateDisplay);

    // Initialize creation parameters
    memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
    d3dcd.d3ddt = D3DDEVTYPE_HAL;
    d3dcd.bWindowed = FALSE;
    d3dcd.d3ddm.Width = 640;
    d3dcd.d3ddm.Height = 480;
    d3dcd.d3ddm.Format = D3DFMT_X8R8G8B8;
//    SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
    d3dcd.bDepthBuffer = TRUE;
    d3dcd.fmtd = D3DFMT_D24S8;
    d3dcd.uPresentInterval = D3DPRESENT_INTERVAL_ONE;
    d3dcd.mst = D3DMULTISAMPLE_NONE;

    // Create the display
    pDisplay = new CDisplay();
    if (!pDisplay) {
        ReleaseHeap();
        RETURN(0);
    }

    // Initialize the display
    if (!pDisplay->Create(&d3dcd)) {
        DebugString(TEXT("CDisplay::Create failed"));
        pDisplay->Release();
        ReleaseHeap();
        RETURN(0);
    }

    // Render the 3D scene
    ExhibitScene(pDisplay, &ret);

    // Clean up
    pDisplay->Release();

    // Release the heap
    ReleaseHeap();

    // Reboot on Xbox
#ifdef UNDER_XBOX
    HalReturnToFirmware(HalQuickRebootRoutine);
#endif

    RETURN(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\rteapot\rteapot.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    rteapot.cpp

Author:

    Matt Bronder

Description:

    Test functions.

*******************************************************************************/

#include "d3dbase.h"
#include "rteapot.h"

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define MAX_THETA                  (M_PI / 64.0f)

//******************************************************************************
D3DVECTOR VectorMatrixMultiply(D3DVECTOR* v, D3DXMATRIX* m) {

    D3DVECTOR r;
    r.x = v->x * m->_11 + v->y * m->_21 + v->z * m->_31 + m->_41;
    r.y = v->x * m->_12 + v->y * m->_22 + v->z * m->_32 + m->_42;
    r.z = v->x * m->_13 + v->y * m->_23 + v->z * m->_33 + m->_43;
    return r;
}

//******************************************************************************
void EnvironmentMap(LPDIRECT3DDEVICE8 pDevice, PVERTEX prVertices, UINT uNumVertices) {

    D3DXMATRIX  mWorld;
    D3DXMATRIX  mView;
    D3DXMATRIX  mMap;
    D3DXMATRIX  mWorld2;
    D3DXMATRIX  mView2;
    D3DXVECTOR3 vPoint;
    D3DXVECTOR3 vNormal;
    D3DXVECTOR3 vReflect;
    D3DXVECTOR3 vDot;
    D3DXVECTOR3 vT;
    float       fDivisor;
    UINT        i;

    pDevice->GetTransform(D3DTS_WORLD, &mWorld);
    pDevice->GetTransform(D3DTS_VIEW, &mView);

    D3DXMatrixMultiply(&mMap, &mWorld, &mView);

    mWorld2 = mWorld;
    mWorld2._41 = 0.0f;
    mWorld2._42 = 0.0f;
    mWorld2._43 = 0.0f;
    mView2 = mView;
    mView2._41 = 0.0f;
    mView2._42 = 0.0f;
    mView2._43 = 0.0f;

    for (i = 0; i < uNumVertices; i++) {

//        vNormal = D3DVECTOR(prVertices[i].nx, prVertices[i].ny, prVertices[i].nz);
        memcpy(&vNormal, &prVertices[i].vNormal, sizeof(D3DVECTOR));
//        vPoint  = D3DVECTOR(prVertices[i].x, prVertices[i].y, prVertices[i].z);
        memcpy(&vPoint, &prVertices[i].vPosition, sizeof(D3DVECTOR));

//        vPoint = VectorMatrixMultiply(vPoint, mWorld);
        vT = VectorMatrixMultiply(&vPoint, &mMap);
        D3DXVec3Normalize(&vPoint, &vT);
        vNormal = VectorMatrixMultiply(&vNormal, &mWorld2);
        vNormal = VectorMatrixMultiply(&vNormal, &mView2);
        vReflect = 2.0f * D3DXVec3Dot(&vNormal, &vPoint) * vNormal - vPoint;
        fDivisor = 2.0f * (float)(sqrt(vReflect.x * vReflect.x + vReflect.y * vReflect.y + (vReflect.z + 1.0f) * (vReflect.z + 1.0f)));
        prVertices[i].u0 = vReflect.x / fDivisor + 0.5f;
        prVertices[i].v0 = vReflect.y / fDivisor + 0.5f;
    }
}

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
BOOL ExhibitScene(CDisplay* pDisplay, int* pnExitCode) {

    CTeapot* pTeapot;
    BOOL     bRet;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    // Create the scene
    pTeapot = new CTeapot();
    if (!pTeapot) {
        return FALSE;
    }

    // Initialize the scene
    if (!pTeapot->Create(pDisplay)) {
        pTeapot->Release();
        return FALSE;
    }

    bRet = pTeapot->Exhibit(pnExitCode);

    // Clean up the scene
    pTeapot->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8 pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
// CTeapot
//******************************************************************************

//******************************************************************************
//
// Method:
//
//     CTeapot
//
// Description:
//
//     Initialize the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CTeapot::CTeapot() {

    m_mesh.prVertices = NULL;
    m_mesh.pwIndices = NULL;
    m_pd3dt = NULL;
    m_pd3dr = NULL;
    m_pd3di = NULL;
    m_pd3drBack = NULL;
    m_bFade = TRUE;
}

//******************************************************************************
//
// Method:
//
//     ~CTeapot
//
// Description:
//
//     Clean up the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CTeapot::~CTeapot() {

    ReleaseMesh(&m_mesh);
}

//******************************************************************************
//
// Method:
//
//     Create
//
// Description:
//
//     Prepare the test for rendering.
//
// Arguments:
//
//     CDisplay* pDisplay               - Pointer to a Display object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CTeapot::Create(CDisplay* pDisplay) {

    float   fTheta;
    UINT    i;

    if (!CreateMesh(TEXT("hteapot.xdg"), &m_mesh)) {
        return FALSE;
    }

    if (!CScene::Create(pDisplay)) {
        return FALSE;
    }

    if (NUM_TEAPOTS > 1) {

        for (i = 0; i < NUM_TEAPOTS; i++) {

            fTheta = 2 * MAX_THETA * RND() - MAX_THETA;
            InitMatrix(&m_pmRotation[i],
                (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
                (float)( 0.0f), (float)( cos(fTheta)), (float)( sin(fTheta)), (float)( 0.0f),
                (float)( 0.0f), (float)(-sin(fTheta)), (float)( cos(fTheta)), (float)( 0.0f),
                (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
            );

            fTheta = 2 * MAX_THETA * RND() - MAX_THETA;
            InitMatrix(&m_pmWorld[i],
                (float)( cos(fTheta)), (float)( 0.0f), (float)(-sin(fTheta)), (float)( 0.0f),
                (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
                (float)( sin(fTheta)), (float)( 0.0f), (float)( cos(fTheta)), (float)( 0.0f),
                (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
            );
            D3DXMatrixMultiply(&m_pmRotation[i], &m_pmWorld[i], &m_pmRotation[i]);

            fTheta = 2 * MAX_THETA * RND() - MAX_THETA;
            InitMatrix(&m_pmWorld[i],
                (float)( cos(fTheta)), (float)( sin(fTheta)), (float)( 0.0f), (float)( 0.0f),
                (float)(-sin(fTheta)), (float)( cos(fTheta)), (float)( 0.0f), (float)( 0.0f),
                (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
                (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
            );
            D3DXMatrixMultiply(&m_pmRotation[i], &m_pmWorld[i], &m_pmRotation[i]);

            InitMatrix(&m_pmWorld[i],
                (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
                (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
                (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
                (float)( -10.0f + 20.0f * RND()), (float)( -6.0f + 12.0f * RND()), 
                (float)( 25.0f + 10.0f * RND()), (float)( 1.0f)
            );
        }
    }
    else {

        fTheta = -0.0104847f;//-0.0139796f;
        InitMatrix(&m_pmRotation[0],
            (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( cos(fTheta)), (float)( sin(fTheta)), (float)( 0.0f),
            (float)( 0.0f), (float)(-sin(fTheta)), (float)( cos(fTheta)), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );

        fTheta = 0.036063525f;//0.0480847f;
        InitMatrix(&m_pmWorld[0],
            (float)( cos(fTheta)), (float)( 0.0f), (float)(-sin(fTheta)), (float)( 0.0f),
            (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( sin(fTheta)), (float)( 0.0f), (float)( cos(fTheta)), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
        D3DXMatrixMultiply(&m_pmRotation[0], &m_pmWorld[0], &m_pmRotation[0]);

        fTheta = -0.0162912f;//-0.0217216f;
        InitMatrix(&m_pmWorld[0],
            (float)( cos(fTheta)), (float)( sin(fTheta)), (float)( 0.0f), (float)( 0.0f),
            (float)(-sin(fTheta)), (float)( cos(fTheta)), (float)( 0.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
        D3DXMatrixMultiply(&m_pmRotation[0], &m_pmWorld[0], &m_pmRotation[0]);

        InitMatrix(&m_pmWorld[0],
            (float)( 1.0f), (float)( 0.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 1.0f), (float)( 0.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 1.0f), (float)( 0.0f),
            (float)( 0.0f), (float)( 0.0f), (float)( 0.0f), (float)( 1.0f)
        );
    }

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Exhibit
//
// Description:
//
//     Execute the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The exit value contained in the wParam parameter of the WM_QUIT message.
//
//******************************************************************************
int CTeapot::Exhibit(int *pnExitCode) {

    return CScene::Exhibit(pnExitCode);
}

//******************************************************************************
//
// Method:
//
//     Setup
//
// Description:
//
//     Obtain the device interface pointer from the display, save the current
//     state of the device, and initialize the background vertices to the
//     dimensions of the render target.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared for initialization, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CTeapot::Setup() {

    return CScene::Setup();
}

//******************************************************************************
//
// Method:
//
//     Initialize
//
// Description:
//
//     Initialize the device and all device objects to be used in the test (or
//     at least all device resource objects to be created in the video, 
//     non-local video, or default memory pools).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the test was successfully initialized for rendering, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CTeapot::Initialize() {

    LPBYTE pData;
    HRESULT hr;
    VERTEX prVertices[4];
    float  x, y, z = 30.0f;

    if (!CScene::Initialize()) {
        return FALSE;
    }

    // Create a material
//    pd3dm = CreateMaterial(g_pd3dDevice, &hMaterial, RGB_MAKE(196, 196, 196), RGB_MAKE(128, 128, 128), RGB_MAKE(255, 255, 255), 0, 20.0f);
    if (!SetMaterial(m_pDevice, RGB_MAKE(196, 196, 196), RGB_MAKE(128, 128, 128), RGB_MAKE(255, 255, 255), 0, 40.0f)) {
        return FALSE;
    }

    // Create an environment texture
    m_pd3dt = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("backgrnd.bmp"), D3DFMT_A8R8G8B8, TTYPE_TEXTURE, NULL, 1.0f, COLORKEY_NONE, D3DPOOL_MANAGED, 256, 256);
    if (!m_pd3dt) {
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3dt->MoveResourceMemory(D3DMEM_VIDEO);
#endif

    hr = m_pDevice->CreateVertexBuffer(m_mesh.uNumVertices * sizeof(VERTEX), 0, FVF_VERTEX, D3DPOOL_DEFAULT, &m_pd3dr);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DDevice8::CreateVertexBuffer"));
        return FALSE;
    }

    hr = m_pd3dr->Lock(0, m_mesh.uNumVertices * sizeof(VERTEX), &pData, 0);
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Lock"));
        return FALSE;
    }

    memcpy(pData, m_mesh.prVertices, m_mesh.uNumVertices * sizeof(VERTEX));

    hr = m_pd3dr->Unlock();
    if (FAILED(hr)) {
        ResultFailed(hr, TEXT("IDirect3DVertexBuffer8::Unlock"));
        return FALSE;
    }

#ifdef UNDER_XBOX
    m_pd3dr->MoveResourceMemory(D3DMEM_AGP);
#endif

    m_pd3di = CreateIndexBuffer(m_pDevice, m_mesh.pwIndices, m_mesh.uNumIndices * sizeof(WORD));
    if (!m_pd3di) {
        return FALSE;
    }

    x = 19.75f;
    y = x * (480.0f / 640.0f);

    prVertices[0] = VERTEX(D3DXVECTOR3(-x,-y, z), D3DXVECTOR3(0.0f, 0.0f, -1.0f), 0.0f, 1.0f);
    prVertices[1] = VERTEX(D3DXVECTOR3(-x, y, z), D3DXVECTOR3(0.0f, 0.0f, -1.0f), 0.0f, 0.0f);
    prVertices[2] = VERTEX(D3DXVECTOR3( x, y, z), D3DXVECTOR3(0.0f, 0.0f, -1.0f), 1.0f, 0.0f);
    prVertices[3] = VERTEX(D3DXVECTOR3( x,-y, z), D3DXVECTOR3(0.0f, 0.0f, -1.0f), 1.0f, 1.0f);

    m_pd3drBack = CreateVertexBuffer(m_pDevice, m_prBackground, 4 * sizeof(TLVERTEX), 0, FVF_TLVERTEX);
    if (!m_pd3drBack) {
        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Efface
//
// Description:
//
//     Release all device resource objects (or at least those objects created
//     in video memory, non-local video memory, or the default memory pools)
//     and restore the device to its initial state.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CTeapot::Efface() {

    if (m_pd3dr) {
        m_pd3dr->Release();
    }
    ReleaseIndexBuffer(m_pd3di);
    ReleaseVertexBuffer(m_pd3drBack);
    ReleaseTexture(m_pd3dt);
    CScene::Efface();
}

//******************************************************************************
//
// Method:
//
//     Update
//
// Description:
//
//     Update the state of the scene to coincide with the given time.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CTeapot::Update() {

    UINT i; 

    for (i = 0; i < NUM_TEAPOTS; i++) {
        D3DXMatrixMultiply(&m_pmWorld[i], &m_pmRotation[i], &m_pmWorld[i]);
    }
}

//******************************************************************************
//
// Method:
//
//     Render
//
// Description:
//
//     Render the test scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CTeapot::Render() {

    LPBYTE pData;
    UINT     i;
    DWORD    dwClearFlags = D3DCLEAR_TARGET;
    HRESULT  hr;

#ifndef UNDER_XBOX

    hr = m_pDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return TRUE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!Reset()) {
                return FALSE;
            }
        }
    }

#endif

    // Clear the rendering target
    if (m_pDisplay->IsDepthBuffered()) {
        dwClearFlags |= D3DCLEAR_ZBUFFER;
    }
    m_pDevice->Clear(0, NULL, dwClearFlags, RGB_MAKE(0, 0, 0), 1.0f, 0);

    // Begin the scene
    m_pDevice->BeginScene();

    // Position the view using the default camera
    m_pDisplay->SetView();

    m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);

    m_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);
    m_pDevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);

    // Use a fixed function shader
    m_pDevice->SetVertexShader(FVF_TLVERTEX);

    m_pDevice->SetTexture(0, m_pd3dt);

    m_pDevice->SetTransform(D3DTS_WORLD, &m_mIdentity);

    // Draw the background
    m_pDevice->SetStreamSource(0, m_pd3drBack, sizeof(TLVERTEX));

    m_pDevice->DrawPrimitive(D3DPT_TRIANGLEFAN, 0, 2);

//    m_pDevice->EndScene();
//    m_pDevice->BeginScene();

//    m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prBackground, sizeof(TLVERTEX));

    m_pDevice->SetVertexShader(FVF_VERTEX);

    m_pDevice->SetStreamSource(0, m_pd3dr, sizeof(VERTEX));

    m_pDevice->SetIndices(m_pd3di, 0);

    // Draw the teapot(s)
    for (i = 0; i < NUM_TEAPOTS; i++) {

        m_pDevice->SetTransform(D3DTS_WORLD, &m_pmWorld[i]);

        m_pd3dr->Lock(0, m_mesh.uNumVertices * sizeof(VERTEX), &pData, 0);
        EnvironmentMap(m_pDevice, (PVERTEX)pData, m_mesh.uNumVertices);
        m_pd3dr->Unlock();

//        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_mesh.uNumVertices, 0, m_mesh.uNumIndices / 6);
//        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_mesh.uNumVertices, m_mesh.uNumIndices / 2, m_mesh.uNumIndices / 6);
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, m_mesh.uNumVertices, 0, m_mesh.uNumIndices / 3);
//        m_pDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, m_mesh.uNumVertices, m_mesh.uNumIndices / 3, m_mesh.pwIndices, D3DFMT_INDEX16, m_mesh.prVertices, sizeof(VERTEX));
    }

    m_pDevice->SetTexture(0, NULL);

    // Display the adapter mode
    ShowDisplayMode();

    // Display the frame rate
    ShowFrameRate();

    // Display the console
    m_pDisplay->ShowConsole();

    // Fade out the scene on exit
    if (m_pfnFade) {
        (this->*m_pfnFade)();
    }

    // End the scene
    m_pDevice->EndScene();

    // Update the screen
    m_pDevice->Present(NULL, NULL, NULL, NULL);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     ProcessInput
//
// Description:
//
//     Process user input for the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CTeapot::ProcessInput() {

    CScene::ProcessInput();
}

//******************************************************************************
//
// Method:
//
//     InitView
//
// Description:
//
//     Initialize the camera view in the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CTeapot::InitView() {

    if (!m_pDisplay) {
        return FALSE;
    }

    // Set the view position
    m_camInitial.vPosition     = D3DXVECTOR3(0.0f, 0.0f, -15.0f);
    m_camInitial.vInterest     = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    m_camInitial.fRoll         = 0.0f;
    m_camInitial.fFieldOfView  = M_PI / 4.0f;
    m_camInitial.fNearPlane    = 0.1f;
    m_camInitial.fFarPlane     = 1000.0f;
    m_pDisplay->SetCamera(&m_camInitial);

    return m_pDisplay->SetView(&m_camInitial);
}

//******************************************************************************
// Scene window procedure (pseudo-subclassed off the main window procedure)
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Scene window procedure to process messages received by the main 
//     application window.
//
// Arguments:
//
//     LRESULT* plr             - Result of the message processing
//
//     HWND hWnd                - Application window
//
//     UINT uMsg                - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     TRUE if the message was handled, FALSE otherwise.
//
//******************************************************************************
BOOL CTeapot::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_F12: // Toggle pause state
                    m_bPaused = !m_bPaused;
                    return TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CScene::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\skulls\sources.inc ===
TARGETNAME=skulls
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\sources.inc

SOURCES=\
    main.cpp \
    skulls.cpp \
    skulls.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\skulls\skulls.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    skulls.cpp

Author:

    Matt Bronder

Description:

    Test functions.

*******************************************************************************/

#include "d3dbase.h"
#include "skulls.h"

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define BRIDGE_LENGTH       1.75f
#define EYE_LENGTH          2.0f
#define POS_AMPLITUDE       (BRIDGE_LENGTH / 2 + EYE_LENGTH / 2)
#define SKULL_DISTANCE      15.0f
#define DISTANCE_PER_FRAME  0.25f//0.09375f//0.125f
#define MAX_THETA           ((float)atan2((double)POS_AMPLITUDE, \
                            (double)SKULL_DISTANCE))
#define FRONT_CLIP

#ifndef FRONT_CLIP
#define CLIP_DELTA          4
#else
#define CLIP_DELTA          0
#endif // FRONT_CLIP

#ifndef UNDER_XBOX
#ifdef FRONT_CLIP
#define SET_CLIPPING_STATE(x)   m_pDevice->SetRenderState(D3DRS_CLIPPING, (x))
#else
#define SET_CLIPPING_STATE(x)   m_pDevice->SetRenderState(D3DRS_CLIPPING, FALSE)
#endif // FRONT_CLIP
#else
#define SET_CLIPPING_STATE(x)
#endif // UNDER_XBOX


//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
BOOL ExhibitScene(CDisplay* pDisplay, int* pnExitCode) {

    CSkulls*    pSkulls;
    BOOL        bRet;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    // Create the scene
    pSkulls = new CSkulls();
    if (!pSkulls) {
        return FALSE;
    }

    // Initialize the scene
    if (!pSkulls->Create(pDisplay)) {
        pSkulls->Release();
        return FALSE;
    }

    bRet = pSkulls->Exhibit(pnExitCode);

    // Clean up the scene
    pSkulls->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8 pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
// CSkulls
//******************************************************************************

//******************************************************************************
//
// Method:
//
//     CSkulls
//
// Description:
//
//     Initialize the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CSkulls::CSkulls() {

    m_pd3dr = NULL;
    m_pd3drScreen = NULL;
    m_pd3di = NULL;
    m_plr = NULL;
    m_mesh.prVertices = NULL;
    m_mesh.pwIndices = NULL;
    m_pmView = NULL;
    m_j = 0;
    m_bAdvanceView = FALSE;
    m_bFade = TRUE;
}

//******************************************************************************
//
// Method:
//
//     ~CSkulls
//
// Description:
//
//     Clean up the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CSkulls::~CSkulls() {

    MemFree32(m_plr);
    ReleaseMesh(&m_mesh);
    MemFree(m_pmView);
}

//******************************************************************************
//
// Method:
//
//     Create
//
// Description:
//
//     Prepare the test for rendering.
//
// Arguments:
//
//     CDisplay* pDisplay               - Pointer to a Display object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSkulls::Create(CDisplay* pDisplay) {

    D3DMATERIAL8                material;
    D3DLIGHT8                   light;
    UINT                        i;
    D3DXMATRIX                  m;
    float                       fTheta,
                                fScale,
                                z;

    if (m_bCreated || m_uCreated > 1) {
        return FALSE;
    }

    if (!pDisplay) {
        return FALSE;
    }

    m_uSteps = 2 * (UINT)((SKULL_DISTANCE / DISTANCE_PER_FRAME) + 0.5f);

    // Precalculate camera motion
    m_pmView = (D3DXMATRIX*)MemAlloc(m_uSteps * sizeof(D3DXMATRIX));
    z = -CLIP_DELTA * DISTANCE_PER_FRAME;

    for (i = 0; i < m_uSteps; i++) {

        fScale = (float)sin((double)(M_2PI * (z / (2.0f * SKULL_DISTANCE))));

        // Orient the camera
        fTheta = fScale * MAX_THETA;

        InitMatrix(&m_pmView[i],
             (float)cos(fTheta),  0.0f, 
             (float)-sin(fTheta), 0.0f,
             0.0f,       1.0f, 
             0.0f,       0.0f,
             (float)sin(fTheta), 0.0f, 
             (float)cos(fTheta), 0.0f,
             0.0f,       0.0f, 
             0.0f,       1.0f
        );

        // Transpose the camera
        InitMatrix(&m,
            (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 1.0), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 0.0), (float)( 1.0), (float)( 0.0),
            (float)( -fScale * POS_AMPLITUDE), (float)( 0.5), 
            (float)(  -z), (float)( 1.0)
        );

        D3DXMatrixMultiply(&m_pmView[i], &m, &m_pmView[i]);

        z -= DISTANCE_PER_FRAME;
    }

    for (i = 0; i < 3; i++) {

        InitMatrix(&m_mWorld[i],
            (float)( 1.0), (float)( 0.0), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 1.0), (float)( 0.0), (float)( 0.0),
            (float)( 0.0), (float)( 0.0), (float)( 1.0), (float)( 0.0),
            (float)( 0.0), (float)( 0.0), 
            (float)( SKULL_DISTANCE / 2.0f - i * SKULL_DISTANCE), 
            (float)( 1.0)
        );
    }

    // Initialize the skull vertices
    if (!CreateMesh(TEXT("skull.xdg"), &m_mesh)) {
        return FALSE;
    }

    // Initialize a bone material
    material.Diffuse.r =  0.78f;
    material.Diffuse.g =  0.78f;
    material.Diffuse.b =  0.78f;
    material.Ambient.r =  0.0f;
    material.Ambient.g =  0.0f;
    material.Ambient.b =  0.0f;
    material.Specular.r = 0.5f;
    material.Specular.g = 0.5f;
    material.Specular.b = 0.5f;
    material.Emissive.r = 0.0f;
    material.Emissive.g = 0.0f;
    material.Emissive.b = 0.0f;
    material.Power =      20.0f;

    SetDirectionalLight(&light, D3DXVECTOR3(0.0f, -1.0f, 1.0f), 0xFFFFFFFF);

    m_plr = (PLVERTEX)MemAlloc32(m_mesh.uNumVertices * sizeof(LVERTEX));
    if (!m_plr) {
        return FALSE;
    }

    for (i = 0; i < m_mesh.uNumVertices; i++) {
        m_plr[i].vPosition = m_mesh.prVertices[i].vPosition;
    }

    // Prelight the skull
    if (!LightVertices(m_mesh.prVertices, m_plr, m_mesh.uNumVertices, &material, &light, 0, &D3DXVECTOR3(0.0f, 0.0f, -10.0f))) {
        return FALSE;
    }

    // Initialize the screen vertices
    m_plrScreen[0][0] = LVERTEX(D3DXVECTOR3(-2.378f,-1.743f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][1] = LVERTEX(D3DXVECTOR3(-2.378f, 0.632f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][2] = LVERTEX(D3DXVECTOR3( 0.000f,-1.743f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[0][3] = LVERTEX(D3DXVECTOR3( 0.000f, 0.632f, 1.0f), 0, 0, 0.0f, 0.0f);

    m_plrScreen[1][0] = LVERTEX(D3DXVECTOR3( 0.000f,-1.743f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][1] = LVERTEX(D3DXVECTOR3( 0.000f, 0.632f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][2] = LVERTEX(D3DXVECTOR3( 2.378f,-1.743f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[1][3] = LVERTEX(D3DXVECTOR3( 2.378f, 0.632f, 1.0f), 0, 0, 0.0f, 0.0f);

    m_plrScreen[2][0] = LVERTEX(D3DXVECTOR3(-1.000f,-3.229f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][1] = LVERTEX(D3DXVECTOR3(-0.750f,-1.525f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][2] = LVERTEX(D3DXVECTOR3( 1.000f,-3.229f, 1.0f), 0, 0, 0.0f, 0.0f);
    m_plrScreen[2][3] = LVERTEX(D3DXVECTOR3( 0.750f,-1.525f, 1.0f), 0, 0, 0.0f, 0.0f);

    return CScene::Create(pDisplay);
}

//******************************************************************************
//
// Method:
//
//     Exhibit
//
// Description:
//
//     Execute the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The exit value contained in the wParam parameter of the WM_QUIT message.
//
//******************************************************************************
int CSkulls::Exhibit(int *pnExitCode) {

    return CScene::Exhibit(pnExitCode);
}

//******************************************************************************
//
// Method:
//
//     Setup
//
// Description:
//
//     Obtain the device interface pointer from the display, save the current
//     state of the device, and initialize the background vertices to the
//     dimensions of the render target.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared for initialization, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CSkulls::Setup() {

    return CScene::Setup();
}

//******************************************************************************
//
// Method:
//
//     Initialize
//
// Description:
//
//     Initialize the device and all device objects to be used in the test (or
//     at least all device resource objects to be created in the video, 
//     non-local video, or default memory pools).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the test was successfully initialized for rendering, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CSkulls::Initialize() {

    m_pDevice->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
    m_pDevice->SetRenderState(D3DRS_CULLMODE, (DWORD)D3DCULL_NONE);

    m_pd3dr = CreateVertexBuffer(m_pDevice, m_plr, m_mesh.uNumVertices * sizeof(LVERTEX), 0, FVF_LVERTEX);
#ifdef UNDER_XBOX
    m_pd3dr->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX
    m_pd3di = CreateIndexBuffer(m_pDevice, m_mesh.pwIndices, m_mesh.uNumIndices * sizeof(WORD));
    m_pd3drScreen = CreateVertexBuffer(m_pDevice, m_plrScreen, 12 * sizeof(LVERTEX), 0, FVF_LVERTEX);
#ifdef UNDER_XBOX
    m_pd3drScreen->MoveResourceMemory(D3DMEM_VIDEO);
#endif // UNDER_XBOX
    return (m_pd3dr && m_pd3di && m_pd3drScreen);
}

//******************************************************************************
//
// Method:
//
//     Efface
//
// Description:
//
//     Release all device resource objects (or at least those objects created
//     in video memory, non-local video memory, or the default memory pools)
//     and restore the device to its initial state.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSkulls::Efface() {

    ReleaseVertexBuffer(m_pd3dr);
    ReleaseIndexBuffer(m_pd3di);
    ReleaseVertexBuffer(m_pd3drScreen);
    CScene::Efface();
}

//******************************************************************************
//
// Method:
//
//     Update
//
// Description:
//
//     Update the state of the scene to coincide with the given time.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSkulls::Update() {

    int j = (int)m_j;
    int delta;

    delta = (int)m_fFrameDelta;
    if (delta < 1) {
        delta = 1;
    }

    if (m_bAdvanceView) {
        j -= delta;
        if (j < 0) {
            j += 2 * (int)(SKULL_DISTANCE / DISTANCE_PER_FRAME);
        }
    }
    else {
        j += delta;
        if (j >= 2 * (int)(SKULL_DISTANCE / DISTANCE_PER_FRAME)) {
            j -= 2 * (int)(SKULL_DISTANCE / DISTANCE_PER_FRAME);
        }
    }

    m_j = (UINT)j;
}

//******************************************************************************
//
// Method:
//
//     Render
//
// Description:
//
//     Render the test scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSkulls::Render() {

    UINT        uNumSkullPrim = m_mesh.uNumIndices / 3;
    DWORD       dwClearFlags = D3DCLEAR_TARGET;
    HRESULT     hr;

#ifndef UNDER_XBOX

    hr = m_pDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return TRUE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!Reset()) {
                return FALSE;
            }
        }
    }

#endif // !UNDER_XBOX

    // Clear the rendering target
    if (m_pDisplay->IsDepthBuffered()) {
        dwClearFlags |= D3DCLEAR_ZBUFFER;
    }
    m_pDevice->Clear(0, NULL, dwClearFlags, RGB_MAKE(0, 0, 0), 1.0f, 0);

    // Begin the scene
    m_pDevice->BeginScene();

    // Disable lighting
    m_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);

    m_pDevice->SetRenderState(D3DRS_ZENABLE, D3DZB_TRUE);
    m_pDevice->SetRenderState(D3DRS_ZWRITEENABLE, TRUE);

    // Use a fixed function shader
    m_pDevice->SetVertexShader(FVF_LVERTEX);

    m_pDevice->SetStreamSource(0, m_pd3dr, sizeof(LVERTEX));

    m_pDevice->SetIndices(m_pd3di, 0);

    m_pDevice->SetTransform(D3DTS_VIEW, &m_pmView[m_j]);

    // Draw the skulls
    if (m_j < m_uSteps / 2) {

        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld[0]);

        SET_CLIPPING_STATE(m_j < m_uSteps / 4);

        // Render
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, 0, uNumSkullPrim / 2);
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, m_mesh.uNumIndices / 2, uNumSkullPrim / 2);
    }

    if (!(m_j < m_uSteps / 4)) { 

        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld[1]);

        SET_CLIPPING_STATE(m_j < m_uSteps / 2);

        // Render
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, 0, uNumSkullPrim / 2);
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, m_mesh.uNumIndices / 2, uNumSkullPrim / 2);
    }


    if (!(m_j < 3 * m_uSteps / 4)) {

        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld[2]);

        SET_CLIPPING_STATE(TRUE);

        // Render
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, 0, uNumSkullPrim / 2);
        m_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 
                0, m_mesh.uNumVertices, m_mesh.uNumIndices / 2, uNumSkullPrim / 2);
    }

    // Draw the screens
    m_pDevice->SetStreamSource(0, m_pd3drScreen, sizeof(LVERTEX));

    m_pDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 
            8, 2);

    if (m_j > m_uSteps / 4 && m_j < 3 * m_uSteps / 4) {

        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld[1]);

        m_pDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 
                4, 2);
    }
    else {

        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld[(m_j < m_uSteps / 4)?0:2]);

        m_pDevice->DrawPrimitive(D3DPT_TRIANGLESTRIP, 
                0, 2);
    }

    // Display the adapter mode
    ShowDisplayMode();

    // Display the frame rate
    ShowFrameRate();

    // Display the console
    m_pDisplay->ShowConsole();

    // Fade out the scene on exit
    if (m_pfnFade) {
        (this->*m_pfnFade)();
    }

    // End the scene
    m_pDevice->EndScene();

    // Update the screen
    m_pDevice->Present(NULL, NULL, NULL, NULL);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     ProcessInput
//
// Description:
//
//     Process user input for the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSkulls::ProcessInput() {

    CScene::ProcessInput();

    if (BUTTON_CHANGED(m_jsJoys, m_jsLast, JOYBUTTON_X)) {
        if (BUTTON_PRESSED(m_jsJoys, JOYBUTTON_X)) {
            m_bAdvanceView = !m_bAdvanceView;
        }
    }
}

//******************************************************************************
//
// Method:
//
//     InitView
//
// Description:
//
//     Initialize the camera view in the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSkulls::InitView() {

    return CScene::InitView();
}

//******************************************************************************
// Scene window procedure (pseudo-subclassed off the main window procedure)
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Scene window procedure to process messages received by the main 
//     application window.
//
// Arguments:
//
//     LRESULT* plr             - Result of the message processing
//
//     HWND hWnd                - Application window
//
//     UINT uMsg                - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     TRUE if the message was handled, FALSE otherwise.
//
//******************************************************************************
BOOL CSkulls::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_F12: // Toggle pause state
                    m_bPaused = !m_bPaused;
                    return TRUE;
            }

            break;

        case WM_KEYUP:

            switch (wParam) {

                case VK_SPACE:

                    if (!m_bPaused) {
                        m_bAdvanceView = !m_bAdvanceView;
                        return TRUE;
                    }
                    break;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CScene::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\skulls\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Author:

    Matt Bronder

Description:

    Application entry point.

*******************************************************************************/

#include "d3dbase.h"

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifdef UNDER_XBOX

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

#endif // UNDER_XBOX

int         ExhibitScene(CDisplay* pDisplay, int *pnExitCode);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
// WinMain
//******************************************************************************

#ifndef UNDER_XBOX
#define RETURN(x)   return x
#else
#define RETURN(x)   return
#endif // UNDER_XBOX

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif // UNDER_XBOX
{
    CDisplay*       pDisplay;
    D3DCREATIONDESC d3dcd;
    int             ret;

    // Allow global access to the instance handle
#ifndef UNDER_XBOX
    RegisterInstance(hInstance);
#else
    RegisterInstance(NULL);
#endif // UNDER_XBOX

    // Seed the pseudo-random number generator
    srand(GetTickCount());

    // Create a heap for the application
    if (!CreateHeap()) {
        RETURN(0);
    }

    // Set the validation procedure for the device
    InitCheckDisplayProc(ValidateDisplay);

    // Initialize creation parameters
    memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
    d3dcd.d3ddt = D3DDEVTYPE_HAL;
    d3dcd.bWindowed = FALSE;
    d3dcd.d3ddm.Width = 640;
    d3dcd.d3ddm.Height = 480;
    d3dcd.d3ddm.Format = D3DFMT_X8R8G8B8;
//    SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
    d3dcd.bDepthBuffer = TRUE;
    d3dcd.fmtd = D3DFMT_D24S8;
    d3dcd.uPresentInterval = D3DPRESENT_INTERVAL_ONE;
    d3dcd.mst = D3DMULTISAMPLE_NONE;

    // Create the display
    pDisplay = new CDisplay();
    if (!pDisplay) {
        ReleaseHeap();
        RETURN(0);
    }

    // Initialize the display
    if (!pDisplay->Create(&d3dcd)) {
        DebugString(TEXT("CDisplay::Create failed"));
        pDisplay->Release();
        ReleaseHeap();
        RETURN(0);
    }

    // Render the 3D scene
    ExhibitScene(pDisplay, &ret);

    // Clean up
    pDisplay->Release();

    // Release the heap
    ReleaseHeap();

    // Reboot on Xbox
#ifdef UNDER_XBOX
    HalReturnToFirmware(HalQuickRebootRoutine);
#endif

    RETURN(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\skulls\skulls.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    skulls.h

Author:

    Matt Bronder

Description:

    Direct3D test functions.

*******************************************************************************/

#ifndef __SKULLS_H__
#define __SKULLS_H__

//******************************************************************************
// Function prototypes
//******************************************************************************

int         ExhibitScene(CDisplay* pDisplay);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
class CSkulls : public CScene {

protected:

    BOOL                            m_bAdvanceView;

    LPDIRECT3DVERTEXBUFFER8         m_pd3dr;
    LPDIRECT3DINDEXBUFFER8          m_pd3di;
    MESH                            m_mesh;
    PLVERTEX                        m_plr;
    D3DXMATRIX*                     m_pmView;
    D3DMATRIX                       m_mWorld[3];
    UINT                            m_uSteps;
    LVERTEX                         m_plrScreen[3][4];
    LPDIRECT3DVERTEXBUFFER8         m_pd3drScreen;
    UINT                            m_j;

public:

                                    CSkulls();
                                    ~CSkulls();

    virtual BOOL                    Create(CDisplay* pDisplay);
    virtual int                     Exhibit(int *pnExitCode);

protected:

    virtual BOOL                    Setup();
    virtual BOOL                    Initialize();
    virtual void                    Efface();
    virtual void                    Update();
    virtual BOOL                    Render();

    virtual void                    ProcessInput();
    virtual BOOL                    InitView();

    virtual BOOL                    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
};

#endif //__SKULLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\snowfall\sources.inc ===
TARGETNAME=snowfall
TARGETTYPE=PROGRAM
TARGETPATH=obj

!include ..\..\sources.inc

SOURCES=\
    main.cpp \
    snow.cpp \
    snow.rc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\snowfall\snow.h ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    snow.h

Author:

    Matt Bronder

Description:

    Let it snow.

*******************************************************************************/

#ifndef __SNOW_H__
#define __SNOW_H__

//******************************************************************************
// Preprocessor definitions
//******************************************************************************

#define NUM_FLAKES              100000
#define DEPTH_FRONT_PLANE       (float)(0.25f)
#define DEPTH_BACK_PLANE        (float)(15.0f)
#define CELLS_X                 10
#define CELLS_Y                 10
#define CELLS_Z                 10
#define OFFSET_X                (float)(0.004f)
#define OFFSET_Y                (float)(0.010f)

#define DEPTH_REFERENCE_PLANE   (float)(0.4f)
#define NUM_PLANES              7

//******************************************************************************
// Structures
//******************************************************************************

//******************************************************************************
typedef struct _SNOWCELL {
    float       x, y;
    UINT        uz;
    UINT        uMesh;
} SNOWCELL, *PSNOWCELL;

//******************************************************************************
typedef struct _SNOWSECTION {
    float       z;
    float       fMaxViewX,
                fMaxViewY;
    float       fLengthX,
                fLengthY;
} SNOWSECTION, *PSNOWSECTION;

//******************************************************************************
class CSnow : public CScene {

protected:

    LPDIRECT3DTEXTURE8              m_pd3dtBackground;
    LPDIRECT3DTEXTURE8              m_pd3dtSnowFlake;

    D3DXMATRIX                      m_mWorld;
    float                           m_fMaxU, m_fMaxV;
    PSNOWCELL                       m_pscList;
    UINT                            m_uNumCells;
    SNOWSECTION                     m_pssList[CELLS_Z];
    LPDIRECT3DVERTEXBUFFER8*        m_ppd3drSnowMesh;
    D3DXVECTOR3**                   m_pprSnowMesh;
    UINT                            m_uNumSnowVertices;

    float                           m_fFlakeDim;

public:

                                    CSnow();
                                    ~CSnow();

    virtual BOOL                    Create(CDisplay* pDisplay);
    virtual int                     Exhibit(int *pnExitCode);

protected:

    virtual BOOL                    Setup();
    virtual BOOL                    Initialize();
    virtual void                    Efface();
    virtual void                    Update();
    virtual BOOL                    Render();

    virtual void                    ProcessInput();
    virtual BOOL                    InitView();

    virtual BOOL                    WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam);
};

#endif //__SNOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\snowfall\main.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    main.cpp

Author:

    Matt Bronder

Description:

    Application entry point.

*******************************************************************************/

#include "d3dbase.h"

//******************************************************************************
// Function prototypes
//******************************************************************************

#ifdef UNDER_XBOX

typedef enum _FIRMWARE_REENTRY {
    HalHaltRoutine,
    HalRebootRoutine,
    HalQuickRebootRoutine,
    HalKdRebootRoutine,
    HalMaximumRoutine
} FIRMWARE_REENTRY, *PFIRMWARE_REENTRY;

extern "C" VOID HalReturnToFirmware(IN FIRMWARE_REENTRY Routine);

#endif // UNDER_XBOX

int         ExhibitScene(CDisplay* pDisplay, int *pnExitCode);
BOOL        ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, 
                            D3DDISPLAYMODE* pd3ddm);

//******************************************************************************
// WinMain
//******************************************************************************

#ifndef UNDER_XBOX
#define RETURN(x)   return x
#else
#define RETURN(x)   return
#endif // UNDER_XBOX

//******************************************************************************
//
// Function:
//
//     WinMain
//
// Description:
//
//     Entry point for the application.
//
// Arguments:
//
//     HINSTANCE hInstance      - Application instance handle
//
//     HINSTANCE hPrevInstance  - Previous instance of the application (always
//                                NULL for Win32 applications)
//
//     LPSTR szCmdLine          - Pointer to a string specifying the command
//                                line used in launching the application
//                                (excluding the program name)
//
//     int nCmdShow             - State specifying how the window is to be 
//                                displayed on creation
//
// Return Value:
//
//     0 on success, -1 on failure.
//
//******************************************************************************
#ifndef UNDER_XBOX
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) 
#else
void __cdecl main()
#endif // UNDER_XBOX
{
    CDisplay*       pDisplay;
    D3DCREATIONDESC d3dcd;
    int             ret;

    // Allow global access to the instance handle
#ifndef UNDER_XBOX
    RegisterInstance(hInstance);
#else
    RegisterInstance(NULL);
#endif // UNDER_XBOX

    // Seed the pseudo-random number generator
    srand(GetTickCount());

    // Create a heap for the application
    if (!CreateHeap()) {
        RETURN(0);
    }

    // Set the validation procedure for the device
    InitCheckDisplayProc(ValidateDisplay);

    // Initialize creation parameters
    memset(&d3dcd, 0, sizeof(D3DCREATIONDESC));
    d3dcd.d3ddt = D3DDEVTYPE_HAL;
    d3dcd.bWindowed = FALSE;
    d3dcd.d3ddm.Width = 640;
    d3dcd.d3ddm.Height = 480;
    d3dcd.d3ddm.Format = D3DFMT_X8R8G8B8;
//    SetRect(&d3dcd.rectWnd, 20, 20, 320, 320);
    d3dcd.bDepthBuffer = TRUE;
    d3dcd.fmtd = D3DFMT_D24S8;
    d3dcd.uPresentInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
#ifdef UNDER_XBOX
    d3dcd.mst = D3DMULTISAMPLE_2_SAMPLES_MULTISAMPLE_QUINCUNX;
    d3dcd.bAntialias = TRUE;
#endif // UNDER_XBOX

    // Create the display
    pDisplay = new CDisplay();
    if (!pDisplay) {
        ReleaseHeap();
        RETURN(0);
    }

    // Initialize the display
    if (!pDisplay->Create(&d3dcd)) {
        DebugString(TEXT("CDisplay::Create failed"));
        pDisplay->Release();
        ReleaseHeap();
        RETURN(0);
    }

    // Render the 3D scene
    ExhibitScene(pDisplay, &ret);

    // Clean up
    pDisplay->Release();

    // Release the heap
    ReleaseHeap();

    // Reboot on Xbox
#ifdef UNDER_XBOX
    HalReturnToFirmware(HalQuickRebootRoutine);
#endif

    RETURN(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\d3d\samples\snowfall\snow.cpp ===
/*******************************************************************************

Copyright (c) 2000 Microsoft Corporation.  All rights reserved.

File Name:

    snow.cpp

Author:

    Matt Bronder

Description:

    Test functions.

*******************************************************************************/

#include "d3dbase.h"
#include "snow.h"

#ifndef UNDER_XBOX
#define SPRITE_STAGE 0
#else
#define SPRITE_STAGE 3
#endif

//******************************************************************************
//
// Function:
//
//     ExhibitScene
//
// Description:
//
//     Create the scene, pump messages, process user input,
//     update the scene, render the scene, and release the scene when finished.
//
// Arguments:
//
//     CDisplay* pDisplay           - Pointer to the Display object
//
//     int* pnExitCode              - Optional pointer to an integer that will
//                                    be set to the exit value contained in the 
//                                    wParam parameter of the WM_QUIT message 
//                                    (if received)
//
// Return Value:
//
//     TRUE if the display remains functional on exit, FALSE otherwise.
//
//******************************************************************************
BOOL ExhibitScene(CDisplay* pDisplay, int* pnExitCode) {

    CSnow*   pSnow;
    BOOL     bRet;

    // Verify that the display has been initialized
    if (!pDisplay) {
        return FALSE;
    }

    // Create the scene
    pSnow = new CSnow();
    if (!pSnow) {
        return FALSE;
    }

    // Initialize the scene
    if (!pSnow->Create(pDisplay)) {
        pSnow->Release();
        return FALSE;
    }

    bRet = pSnow->Exhibit(pnExitCode);

    // Clean up the scene
    pSnow->Release();

    return bRet;
}

//******************************************************************************
//
// Function:
//
//     ValidateDisplay
//
// Description:
//
//     Evaluate the given display information in order to determine whether or
//     not the display is capable of rendering the scene.  If not, the given 
//     display will not be included in the display list.
//
// Arguments:
//
//     LPDIRECT3D8 pd3d                 - Pointer to the Direct3D object
//
//     D3DCAPS8* pd3dcaps               - Capabilities of the device
//
//     D3DDISPLAYMODE*                  - Display mode into which the device
//                                        will be placed
//
// Return Value:
//
//     TRUE if the scene can be rendered using the given display, FALSE if
//     it cannot.
//
//******************************************************************************
BOOL ValidateDisplay(LPDIRECT3D8 pd3d, D3DCAPS8* pd3dcaps, D3DDISPLAYMODE* pd3ddm) {

    return TRUE;
}

//******************************************************************************
// CSnow
//******************************************************************************

//******************************************************************************
//
// Method:
//
//     CSnow
//
// Description:
//
//     Initialize the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CSnow::CSnow() {

    m_pd3dtBackground = NULL;
    m_pd3dtSnowFlake = NULL;
    m_bFade = TRUE;
    m_pprSnowMesh = NULL;
}

//******************************************************************************
//
// Method:
//
//     ~CSnow
//
// Description:
//
//     Clean up the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
CSnow::~CSnow() {
}

//******************************************************************************
//
// Method:
//
//     Create
//
// Description:
//
//     Prepare the test for rendering.
//
// Arguments:
//
//     CDisplay* pDisplay               - Pointer to a Display object.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSnow::Create(CDisplay* pDisplay) {

    return CScene::Create(pDisplay);
}

//******************************************************************************
//
// Method:
//
//     Exhibit
//
// Description:
//
//     Execute the test.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     The exit value contained in the wParam parameter of the WM_QUIT message.
//
//******************************************************************************
int CSnow::Exhibit(int *pnExitCode) {

    return CScene::Exhibit(pnExitCode);
}

//******************************************************************************
//
// Method:
//
//     Setup
//
// Description:
//
//     Obtain the device interface pointer from the display, save the current
//     state of the device, and initialize the background vertices to the
//     dimensions of the render target.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the scene was successfully prepared for initialization, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CSnow::Setup() {

    return CScene::Setup();
}

//******************************************************************************
//
// Method:
//
//     Initialize
//
// Description:
//
//     Initialize the device and all device objects to be used in the test (or
//     at least all device resource objects to be created in the video, 
//     non-local video, or default memory pools).
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE if the test was successfully initialized for rendering, FALSE if
//     it was not.
//
//******************************************************************************
BOOL CSnow::Initialize() {

    float                       fTrigRatio,
                                fAspect;
    D3DCOLOR                    cSnowColorKey;
    UINT                        i, j, k;

    float                       fCellWidth, fCellHeight, fCellDepth;
    float                       fWidth, fHeight, fDepth;
    UINT                        uCellFlakes;
    UINT                        uCellsX, uCellsY, uCell;

    float                       fTU, fTV,
                                fUOffset, fVOffset,
                                fRefWidth,
                                fRefHeight;
    float                       fBackDepth;

    if (!CScene::Initialize()) {
        return FALSE;
    }

    m_uNumCells = 0;

    D3DXMatrixIdentity(&m_mWorld);

    // Calculate a snow cell's dimensions
    fAspect = (float)(m_pDisplay->GetHeight()) / (float)(m_pDisplay->GetWidth());
    fTrigRatio = (float)(tan(M_PI / (float)(8.0f)));
    fCellDepth = (DEPTH_BACK_PLANE - DEPTH_FRONT_PLANE) / (float)(CELLS_Z);
    fCellWidth = DEPTH_BACK_PLANE * fTrigRatio * 2.0f / (float)(CELLS_X);
    fCellHeight = DEPTH_BACK_PLANE * fTrigRatio * fAspect * 2.0f / (float)(CELLS_Y);

    // Calculate the number of cells needed
    for (i = 0, fDepth = DEPTH_FRONT_PLANE + CELLS_Z * fCellDepth; 
         i < CELLS_Z; 
         i++, fDepth -= fCellDepth) 
    {
        fWidth = fDepth * fTrigRatio * 2;
        fHeight = fWidth * fAspect;
        m_uNumCells += ((UINT)(fWidth / fCellWidth) + 2) * 
                     ((UINT)(fHeight / fCellHeight) + 2);
    }

    // Allocate memory
    m_pscList = (PSNOWCELL)MemAlloc(sizeof(SNOWCELL) * m_uNumCells);
    if (!m_pscList) {
        return FALSE;
    }
    uCellFlakes = NUM_FLAKES / m_uNumCells + 1;

    m_pprSnowMesh = (D3DXVECTOR3**)MemAlloc(sizeof(D3DXVECTOR3*) * m_uNumCells);
    if (!m_pprSnowMesh) {
        return FALSE;
    }
    memset(m_pprSnowMesh, 0, m_uNumCells * sizeof(D3DXVECTOR3*));
    m_uNumSnowVertices = uCellFlakes;
    for (i = 0; i < m_uNumCells; i++) {
        m_pprSnowMesh[i] = (D3DXVECTOR3*)MemAlloc32(m_uNumSnowVertices * sizeof(D3DXVECTOR3));
        if (!m_pprSnowMesh[i]) {
            return FALSE;
        }
    }

    // Initialize the snow meshes
    m_fFlakeDim = fCellHeight / 8.0f;
    for (i = 0; i < m_uNumCells; i++) {
        for (j = 0; j < m_uNumSnowVertices; j++) {
            m_pprSnowMesh[i][j] = D3DXVECTOR3(
                                            RND() * fCellWidth + m_fFlakeDim / 2.0f, 
                                            RND() * -fCellHeight - m_fFlakeDim / 2.0f, 
                                            RND() * -fCellDepth);
        }
    }

    m_ppd3drSnowMesh = (LPDIRECT3DVERTEXBUFFER8*)MemAlloc(sizeof(LPDIRECT3DVERTEXBUFFER8) * m_uNumCells);
    if (!m_ppd3drSnowMesh) {
        return FALSE;
    }
    memset(m_ppd3drSnowMesh, 0, m_uNumCells * sizeof(LPDIRECT3DVERTEXBUFFER8));
    for (i = 0; i < m_uNumCells; i++) {
        m_ppd3drSnowMesh[i] = CreateVertexBuffer(m_pDevice, m_pprSnowMesh[i], m_uNumSnowVertices * sizeof(D3DXVECTOR3), D3DUSAGE_POINTS, D3DFVF_XYZ);
        if (!m_ppd3drSnowMesh[i]) {
            return FALSE;
        }
#ifdef UNDER_XBOX
        m_ppd3drSnowMesh[i]->MoveResourceMemory(D3DMEM_VIDEO);
#endif
    }

    // Initialize the snow sections and cells
    uCell = 0;
    for (i = 0, fDepth = DEPTH_FRONT_PLANE + CELLS_Z * fCellDepth; 
         i < CELLS_Z; 
         i++, fDepth -= fCellDepth) 
    {
        m_pssList[i].z = fDepth;
        m_pssList[i].fMaxViewX = fDepth * fTrigRatio;
        m_pssList[i].fMaxViewY = m_pssList[i].fMaxViewX * fAspect;
        uCellsX = ((UINT)(m_pssList[i].fMaxViewX * 2 / fCellWidth) + 2);
        uCellsY = ((UINT)(m_pssList[i].fMaxViewY * 2 / fCellHeight) + 2);
        m_pssList[i].fLengthX = uCellsX * fCellWidth;
        m_pssList[i].fLengthY = uCellsY * fCellHeight;

        for (j = 0; j < uCellsY; j++) {

            for (k = 0; k < uCellsX; k++) {

                m_pscList[uCell + (j * uCellsX) + k].uz = i;
                m_pscList[uCell + (j * uCellsX) + k].uMesh = rand() % m_uNumCells;
                m_pscList[uCell + (j * uCellsX) + k].x = -m_pssList[i].fMaxViewX + k * fCellWidth;
                m_pscList[uCell + (j * uCellsX) + k].y = m_pssList[i].fMaxViewY - j * fCellHeight;
            }
        }

        m_pssList[i].fMaxViewX += fCellWidth;
        m_pssList[i].fMaxViewY += fCellHeight;

        uCell += uCellsX * uCellsY;
    }

    // Create a material for the snow
    SetMaterial(m_pDevice, RGBA_MAKE(255, 255, 255, 255));

    // Create a background texture
    m_pd3dtBackground = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("backgrnd.bmp"), D3DFMT_R5G6B5);

    // Create the snow field textures
    cSnowColorKey = RGB_MAKE(200, 200, 200);

    m_pd3dtSnowFlake = (LPDIRECT3DTEXTURE8)CreateTexture(m_pDevice, TEXT("snow.bmp"), 
                                   D3DFMT_A1R5G5B5, TTYPE_TEXTURE, NULL, 
                                   (float)(1.0f), cSnowColorKey);
#ifdef UNDER_XBOX
    m_pd3dtSnowFlake->MoveResourceMemory(D3DMEM_VIDEO);
#endif

    m_pDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     Efface
//
// Description:
//
//     Release all device resource objects (or at least those objects created
//     in video memory, non-local video memory, or the default memory pools)
//     and restore the device to its initial state.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSnow::Efface() {

    UINT i;

    ReleaseTexture(m_pd3dtSnowFlake);
    ReleaseTexture(m_pd3dtBackground);

    MemFree(m_pscList);
    for (i = 0; i < m_uNumCells; i++) {
        if (m_pprSnowMesh[i]) {
            MemFree32(m_pprSnowMesh[i]);
        }
    }
    MemFree(m_pprSnowMesh);

    for (i = 0; i < m_uNumCells; i++) {
        ReleaseVertexBuffer(m_ppd3drSnowMesh[i]);
    }
    MemFree(m_ppd3drSnowMesh);

    CScene::Efface();
}

//******************************************************************************
//
// Method:
//
//     Update
//
// Description:
//
//     Update the state of the scene to coincide with the given time.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSnow::Update() {

    UINT i, j;

    for (i = 0; i < m_uNumCells; i++) {

        // Update the cell position
        m_pscList[i].x -= OFFSET_X * m_fTimeDilation;
        m_pscList[i].y -= OFFSET_Y * m_fTimeDilation;
        if (m_pscList[i].x < -m_pssList[m_pscList[i].uz].fMaxViewX) {
            m_pscList[i].x += m_pssList[m_pscList[i].uz].fLengthX;
            m_pscList[i].uMesh = rand() % m_uNumCells;
        }
        if (m_pscList[i].y < -m_pssList[m_pscList[i].uz].fMaxViewY) {
            m_pscList[i].y += m_pssList[m_pscList[i].uz].fLengthY;
            m_pscList[i].uMesh = rand() % m_uNumCells;
        }
    }
}

//******************************************************************************
//
// Method:
//
//     Render
//
// Description:
//
//     Render the test scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSnow::Render() {

    UINT     i;
    DWORD    dwClearFlags = D3DCLEAR_TARGET;
    HRESULT  hr;

#ifndef UNDER_XBOX

    hr = m_pDevice->TestCooperativeLevel();
    if (FAILED(hr)) {
        if (hr == D3DERR_DEVICELOST) {
            return TRUE;
        }
        if (hr == D3DERR_DEVICENOTRESET) {
            if (!Reset()) {
                return FALSE;
            }
        }
    }

#endif

    // Clear the rendering target
    if (m_pDisplay->IsDepthBuffered()) {
        dwClearFlags |= D3DCLEAR_ZBUFFER;
    }
    m_pDevice->Clear(0, NULL, dwClearFlags, RGB_MAKE(0, 0, 0), 1.0f, 0);

    // Begin the scene
    m_pDevice->BeginScene();

    SetColorStage(m_pDevice, 0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG1);
    SetAlphaStage(m_pDevice, 0, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG1);

    // Use a fixed function shader
    m_pDevice->SetVertexShader(FVF_TLVERTEX);

    m_pDevice->SetTexture(0, m_pd3dtBackground);

    // Draw the background
    m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN, 2, m_prBackground, sizeof(TLVERTEX));

    // Use a fixed function shader
    m_pDevice->SetVertexShader(D3DFVF_XYZ);
/*
    // Set the snow sheet transform and texture
    m_mWorld._41 = 0.0f;
    m_mWorld._42 = 0.0f;
    m_mWorld._43 = 0.0f;
    m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld);
    m_pDevice->SetTexture(0, m_pd3dtSnowSheet);

    // Render the snow sheets
    for (i = 0; i < NUM_PLANES; i++) {
        m_pDevice->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP, 2,
                            m_prSnowSheet[i], sizeof(VERTEX));
    }
*/
    // Set the snow flake texture
    m_pDevice->SetTexture(SPRITE_STAGE, m_pd3dtSnowFlake);

    m_pDevice->SetRenderState(D3DRS_POINTSIZE, F2DW((m_fFlakeDim * 0.6f)));
    m_pDevice->SetRenderState(D3DRS_POINTSIZE_MIN, F2DW(1.0f));
    m_pDevice->SetRenderState(D3DRS_POINTSCALE_A, F2DW(0.0f));
    m_pDevice->SetRenderState(D3DRS_POINTSCALE_B, F2DW(0.0f));
    m_pDevice->SetRenderState(D3DRS_POINTSCALE_C, F2DW(1.0f));
    m_pDevice->SetRenderState(D3DRS_POINTSCALEENABLE, TRUE);
    m_pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, TRUE);

m_pDevice->SetRenderState(D3DRS_LIGHTING, FALSE);
SetColorStage(m_pDevice, SPRITE_STAGE, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG1);
SetAlphaStage(m_pDevice, SPRITE_STAGE, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_SELECTARG1);

    for (i = 0; i < m_uNumCells; i++) {

        // Set the world transform
        m_mWorld._41 = m_pscList[i].x;
        m_mWorld._42 = m_pscList[i].y;
        m_mWorld._43 = m_pssList[m_pscList[i].uz].z;
        m_pDevice->SetTransform(D3DTS_WORLD, &m_mWorld);

        m_pDevice->SetStreamSource(0, m_ppd3drSnowMesh[m_pscList[i].uMesh], sizeof(D3DXVECTOR3));
        m_pDevice->DrawPrimitive(D3DPT_POINTLIST, 0, m_uNumSnowVertices);

        // Render the snow cell mesh
//        m_pDevice->DrawPrimitiveUP(D3DPT_POINTLIST, 
//                            m_uNumSnowVertices,
//                            m_pprSnowMesh[m_pscList[i].uMesh], 
//                            sizeof(D3DXVECTOR3));
    }

    m_pDevice->SetTexture(SPRITE_STAGE, NULL);
    SetColorStage(m_pDevice, SPRITE_STAGE, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_DISABLE);
    SetAlphaStage(m_pDevice, SPRITE_STAGE, D3DTA_TEXTURE, D3DTA_DIFFUSE, D3DTOP_DISABLE);
    m_pDevice->SetRenderState(D3DRS_POINTSPRITEENABLE, FALSE);

m_pDevice->SetRenderState(D3DRS_LIGHTING, TRUE);

    // Display the adapter mode
    ShowDisplayMode();

    // Display the frame rate
    ShowFrameRate();

    // Display the console
    m_pDisplay->ShowConsole();

    // Fade out the scene on exit
    if (m_pfnFade) {
        (this->*m_pfnFade)();
    }

    // End the scene
    m_pDevice->EndScene();

    // Update the screen
    m_pDevice->Present(NULL, NULL, NULL, NULL);

    return TRUE;
}

//******************************************************************************
//
// Method:
//
//     ProcessInput
//
// Description:
//
//     Process user input for the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     None.
//
//******************************************************************************
void CSnow::ProcessInput() {

    CScene::ProcessInput();
}

//******************************************************************************
//
// Method:
//
//     InitView
//
// Description:
//
//     Initialize the camera view in the scene.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     TRUE on success, FALSE on failure.
//
//******************************************************************************
BOOL CSnow::InitView() {

    if (!m_pDisplay) {
        return FALSE;
    }

    // Set the view position
    m_camInitial.vPosition     = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
    m_camInitial.vInterest     = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
    m_camInitial.fRoll         = 0.0f;
    m_camInitial.fFieldOfView  = M_PI / 4.0f;
    m_camInitial.fNearPlane    = 0.1f;
    m_camInitial.fFarPlane     = 1000.0f;
    m_pDisplay->SetCamera(&m_camInitial);

    return m_pDisplay->SetView(&m_camInitial);
}

//******************************************************************************
// Scene window procedure (pseudo-subclassed off the main window procedure)
//******************************************************************************

//******************************************************************************
//
// Function:
//
//     WndProc
//
// Description:
//
//     Scene window procedure to process messages received by the main 
//     application window.
//
// Arguments:
//
//     LRESULT* plr             - Result of the message processing
//
//     HWND hWnd                - Application window
//
//     UINT uMsg                - Message to process
//
//     WPARAM wParam            - First message parameter
//
//     LPARAM lParam            - Second message parameter
//
// Return Value:
//
//     TRUE if the message was handled, FALSE otherwise.
//
//******************************************************************************
BOOL CSnow::WndProc(LRESULT* plr, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    *plr = 0;

#ifndef UNDER_XBOX

    switch (uMsg) {

        case WM_KEYDOWN:

            switch (wParam) {

                case VK_F12: // Toggle pause state
                    m_bPaused = !m_bPaused;
                    return TRUE;
            }

            break;
    }

#endif // !UNDER_XBOX

    return CScene::WndProc(plr, hWnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\dputils.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "wrappeer.h"
#include "wrapserver.h"
#include "wrapclient.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

extern HANDLE g_hHeap;

#undef DEBUG_SECTION
#define DEBUG_SECTION	"MemAlloc()"
//==================================================================================
// MemAlloc
//----------------------------------------------------------------------------------
//
// MemAlloc: Private heap allocation function
//
// Arguments:
//	DWORD		dwSize		Size of buffer to allocate from the private heap
//
// Returns: Valid pointer to newly allocated memory, NULL otherwise
//==================================================================================
LPVOID MemAlloc(DWORD dwSize)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return NULL;
	}

	return HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, dwSize);
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"MemFree()"
//==================================================================================
// MemFree
//----------------------------------------------------------------------------------
//
// Description: Private heap deallocation function
//
// Arguments:
//	LPVOID		pBuffer		Pointer to buffer to be released
//
// Returns: TRUE if the buffer was deallocated, FALSE otherwise
//==================================================================================
BOOL MemFree(LPVOID pBuffer)
{
	if(!g_hHeap)
	{
//		DbgPrint("DirectPlay test's private heap hasn't been created!");
		return FALSE;
	}

	return HeapFree(g_hHeap, 0, pBuffer);
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"SyncWithOtherTesters()"
//==================================================================================
// SyncWithOtherTesters
//----------------------------------------------------------------------------------
//
// Description: Function that establishes sync with other clients and exchanges data with them
//
// Arguments:
//	HANDLE		hLog
//	HANDLE		hNetsyncObject
//	LPCSTR		szEventName
//	PBYTE		pInputData
//	DWORD		dwInputDataSize
//	PBYTE		pOutputData
//	DWORD		dwOutputDataSize
// Returns: TRUE if sync was established, FALSE otherwise
//==================================================================================
BOOL SyncWithOtherTesters(HANDLE hLog, HANDLE hNetsyncObject, LPCSTR szEventName, PBYTE pInputData, DWORD dwInputDataSize, PBYTE pOutputData, DWORD *pdwOutputDataSize)
{
	PDP_SYNCWAIT pSyncWaitMsg = NULL;
	PDP_SYNCSIGNAL pSyncSignalMsg = NULL;
	IN_ADDR FromAddr;
	DWORD dwReceiveStatus, dwReceivedDataSize = 0;
	BOOL fRet = TRUE;

	if(dwInputDataSize > MAX_SYNC_DATASIZE)
	{
		xLog(hLog, XLL_FAIL, "Trying to sync with data size above maximum (%u > %u)", dwInputDataSize, MAX_SYNC_DATASIZE);
		fRet = FALSE;
		goto Exit;
	}

	if(dwInputDataSize && !pInputData)
	{
		xLog(hLog, XLL_FAIL, "Input data size %u is greater than 0, but no input buffer provided", dwInputDataSize);
		fRet = FALSE;
		goto Exit;
	}

	// Allocate the wait message
	pSyncWaitMsg = (PDP_SYNCWAIT) MemAlloc(sizeof(DP_SYNCWAIT) + dwInputDataSize);
				
	// Populate the wait message
	pSyncWaitMsg->dwMessageId = DPMSG_SYNCWAIT;
	pSyncWaitMsg->dwMinMachinesRequired = 0;
	strcpy(pSyncWaitMsg->szSyncDataName, szEventName);
	
	// Copy the input sync data into the wait message
	(pSyncWaitMsg->dwSyncDataSize = dwInputDataSize) ?
		memcpy((BYTE *) pSyncWaitMsg + sizeof(DP_SYNCWAIT), pInputData, dwInputDataSize) : 0;
				
	// TODO - No retries yet.  If we miss a single UDP packet we lose sync and the whole test is screwed
	// Acceptable for now... at least we'll get an error message when we don't receive the signal
	
	// Send the wait message to the server
	NetsyncSendClientMessage(hNetsyncObject, 0, sizeof(DP_SYNCWAIT) + dwInputDataSize, (char *) pSyncWaitMsg);

	dwReceivedDataSize = 0;

	// Wait 2 minutes to sync with other testers
	dwReceiveStatus = NetsyncReceiveClientMessage(hNetsyncObject,
		120000,
		&(FromAddr.S_un.S_addr), 
		&dwReceivedDataSize, 
		(char **) &pSyncSignalMsg);
				
	// If we didn't receive a sync signal from the server within 2 minutes
	if((dwReceiveStatus != WAIT_OBJECT_0) || (pSyncSignalMsg->dwMessageId != DPMSG_SYNCSIGNAL))
	{
		xLog(hLog, XLL_FAIL, "Didn't synchronize with other testers within 2 minutes", 0);
		
		fRet = FALSE;
		goto Exit;
	}
	
	xLog(hLog, XLL_INFO, "Synced on event: %s", pSyncWaitMsg->szSyncDataName);

	if(pOutputData)
	{
		if(pSyncSignalMsg->dwSyncDataSize > *pdwOutputDataSize)
		{
			xLog(hLog, XLL_WARN, "Received more data than output buffer can hold (%u > %u)",
				pSyncSignalMsg->dwSyncDataSize, *pdwOutputDataSize);
			
			*pdwOutputDataSize = 0;
			goto Exit;
		}
		
		// Copy the signal message data into the output buffer
		(*pdwOutputDataSize = pSyncSignalMsg->dwSyncDataSize) ? 
			memcpy(pOutputData, (BYTE *) pSyncSignalMsg + sizeof(DP_SYNCSIGNAL), pSyncSignalMsg->dwSyncDataSize) : 0;			
	}

Exit:

	pSyncWaitMsg ? MemFree(pSyncWaitMsg) : 0;
	pSyncSignalMsg ? NetsyncFreeMessage((char *) pSyncSignalMsg) : 0;

	return fRet;
}

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CreateHostAndWaitForPlayers"
//==================================================================================
// CreateHostAndWaitForPlayers
//----------------------------------------------------------------------------------
//
// Description: Creates a host at and waits for a given number of users to be created
//
// Arguments:
//	HANDLE						hLog				Handle to logging subsystem
//	PWRAPDP8PEER				*ppDP8Peer			Pointer filled with host peer
//	PBASESESSIONCREATECONTEXT	pContext			Callback context
//	DPN_APPLICATION_DESC		*pdpnad				Application descriptor of host session
//	PFNDPNMESSAGEHANDLER		pfnMessageHandler	Callback function
//	PDPNID						*ppPlayerList		Pointer filled with player ID's
//	DWORD						dwPlayersExpected	Number of players expected
//	DWORD						dwTimeout			Milliseconds before timing out operation
//
//
// Returns: TRUE if the session is connected to and the expected number of players is presen
//			FALSE otherwise
//==================================================================================
BOOL CreateHostAndWaitForPlayers(HANDLE hLog, PWRAPDP8PEER *ppDP8Peer, PBASESESSIONCREATECONTEXT pContext, DPN_APPLICATION_DESC *pdpnad, PFNDPNMESSAGEHANDLER pfnMessageHandler, PDPNID *ppPlayerList, DWORD dwPlayersExpected, DWORD dwTimeout)
{
	PDIRECTPLAY8ADDRESS		pDP8DeviceAddress = NULL;
	HRESULT					hr;
	DWORD					dwPort, dwPlayersActual;
	BOOL					fRet = TRUE;

	// Create the peer wrapper
	*ppDP8Peer = new CWrapDP8Peer(hLog);
	if (*ppDP8Peer == NULL)
	{
		DPTEST_TRACE(hLog, "Couldn't create peer wrapper object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create the DirectPlay peer object
	hr = (*ppDP8Peer)->CoCreate();
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create an address to host with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Set up the context
	pContext->dwPlayersCreated = 0;
	pContext->dwPlayersExpected = dwPlayersExpected;
	pContext->fPlayersHaveLeft = FALSE;
	pContext->hbsccAllPlayersCreated = CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!pContext->hbsccAllPlayersCreated)
	{
		DPTEST_TRACE(hLog, "Couldn't create AllPlayersCreated event!", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Initialized the host
	hr = (*ppDP8Peer)->DP8P_Initialize(pContext, pfnMessageHandler, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Initializing with context, 0 flags failed!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Always default to this port.  Allows netmon parsers to detect DirectPlay packets
	dwPort = 2302;
	
	if(pDP8DeviceAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD) != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't set port for host", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Host the session
	hr = (*ppDP8Peer)->DP8P_Host(pdpnad, &pDP8DeviceAddress, 1, NULL, NULL, NULL, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Hosting with 1 device failed!", 0);
		fRet = FALSE;
		goto EXIT;
	} // end if (couldn't host)

	// Wait for all the players to be connected
	if(WaitForSingleObject(pContext->hbsccAllPlayersCreated, 120000) != WAIT_OBJECT_0)
	{
		DPTEST_TRACE(hLog, "Players weren't created within 2 minutes", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the number of players created
	dwPlayersActual = 0;
	(*ppDP8Peer)->DP8P_EnumPlayersAndGroups(NULL, &dwPlayersActual, DPNENUM_PLAYERS);
	if(dwPlayersActual != pContext->dwPlayersExpected)
	{
		DPTEST_TRACE(hLog, "Unexpected number of players in session: (%u != %u)", 2, dwPlayersActual, dwPlayersExpected);
		fRet = FALSE;
		goto EXIT;
	}

	// Allocate a buffer for the players
	*ppPlayerList = (DPNID *) MemAlloc(sizeof(DPNID) * dwPlayersActual);
	if(!*ppPlayerList)
	{
		DPTEST_TRACE(hLog, "Couldn't allocate player ID buffer", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the players that were created
	hr = (*ppDP8Peer)->DP8P_EnumPlayersAndGroups(*ppPlayerList, &dwPlayersActual, DPNENUM_PLAYERS);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Error enumerating players from session: 0x%08x", 1, hr);
		fRet = FALSE;
		goto EXIT;
	}

	DPTEST_TRACE(hLog, "Session successfully hosted and all %u players created", 1, pContext->dwPlayersExpected);

EXIT:

	// Release the address
	if(pDP8DeviceAddress)
	{
		pDP8DeviceAddress->Release();
		pDP8DeviceAddress = NULL;
	}

	return fRet;
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnectNonHostAndWaitForPlayers()"
//==================================================================================
// ConnectNonHostAndWaitForPlayers
//----------------------------------------------------------------------------------
//
// Description: Connects to a host at a specified address and waits for a
//				given number of users to be created
//
// Arguments:
//	HANDLE						hLog				Handle to logging subsystem
//	PWRAPDP8PEER				*ppDP8Peer			Pointer filled with non-host peer
//	PBASESESSIONCREATECONTEXT	pContext			Callback context
//	DWORD						dwHostAddr			DWORD form of host's IP address
//	DPN_APPLICATION_DESC		*pdpnad				Application descriptor of host session
//	PFNDPNMESSAGEHANDLER		pfnMessageHandler	Callback function
//	PDPNID						*ppPlayerList		Pointer filled with player ID's
//	DWORD						dwPlayersExpected	Number of players expected
//	DWORD						dwTimeout			Milliseconds before timing out operation
//
//
// Returns: TRUE if the session is connected to and the expected number of players is presen
//			FALSE otherwise
//==================================================================================
BOOL ConnectNonHostAndWaitForPlayers(HANDLE hLog, PWRAPDP8PEER *ppDP8Peer, PBASESESSIONCREATECONTEXT pContext, DWORD dwHostAddr, DPN_APPLICATION_DESC *pdpnad, PFNDPNMESSAGEHANDLER pfnMessageHandler, PDPNID *ppPlayerList, DWORD dwPlayersExpected, DWORD dwTimeout)
{
	PDIRECTPLAY8ADDRESS		pDP8HostAddress = NULL, pDP8DeviceAddress = NULL;
	SOCKADDR_IN				HostAddr;
	HRESULT					hr;
	DPNHANDLE				hAsync = NULL;
	DWORD					dwPort, dwPlayersActual;
	BOOL					fRet = TRUE;

	// Create the peer wrapper
	*ppDP8Peer = new CWrapDP8Peer(hLog);
	if (*ppDP8Peer == NULL)
	{
		DPTEST_TRACE(hLog, "Couldn't create peer wrapper object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create the DirectPlay peer object
	hr = (*ppDP8Peer)->CoCreate();
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create an address to host with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8HostAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create an address for the device to connect with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate device DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	} // end if (CoCreate failed)


	// Set up the context
	pContext->dwPlayersCreated = 0;
	pContext->dwPlayersExpected = dwPlayersExpected;
	pContext->fPlayersHaveLeft = FALSE;
	pContext->hbsccAllPlayersCreated = CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!pContext->hbsccAllPlayersCreated)
	{
		DPTEST_TRACE(hLog, "Couldn't create AllPlayersCreated event!", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Initialized the host
	hr = (*ppDP8Peer)->DP8P_Initialize(pContext, pfnMessageHandler, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Initializing with context, 0 flags failed!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Build a socket address for the session on the host machine
	HostAddr.sin_family = AF_INET;
	HostAddr.sin_port = htons(2302);
	HostAddr.sin_addr.S_un.S_addr = dwHostAddr;

	// Set that address
	if(pDP8HostAddress->BuildFromSockAddr((SOCKADDR *) &HostAddr) != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't set port for host", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Host the session
	hr = (*ppDP8Peer)->DP8P_Connect(pdpnad, pDP8HostAddress, pDP8DeviceAddress, NULL, NULL, NULL, 0, NULL, NULL, &hAsync, 0);
	if (hr != DPNERR_PENDING)
	{
		DPTEST_TRACE(hLog, "Connecting to host failed: 0x%08x", 1, hr);
		fRet = FALSE;
		goto EXIT;
	} // end if (couldn't host)


	// Wait for all the players to be connected
	if(WaitForSingleObject(pContext->hbsccAllPlayersCreated, 120000) != WAIT_OBJECT_0)
	{
		DPTEST_TRACE(hLog, "Players weren't created within 2 minutes", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the number of players created
	dwPlayersActual = 0;
	(*ppDP8Peer)->DP8P_EnumPlayersAndGroups(NULL, &dwPlayersActual, DPNENUM_PLAYERS);
	if(dwPlayersActual != pContext->dwPlayersExpected)
	{
		DPTEST_TRACE(hLog, "Unexpected number of players in session: (%u != %u)", 2, dwPlayersActual, dwPlayersExpected);
		fRet = FALSE;
		goto EXIT;
	}

	// Allocate a buffer for the players
	*ppPlayerList = (DPNID *) MemAlloc(sizeof(DPNID) * dwPlayersActual);
	if(!*ppPlayerList)
	{
		DPTEST_TRACE(hLog, "Couldn't allocate player ID buffer", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the players that were created
	hr = (*ppDP8Peer)->DP8P_EnumPlayersAndGroups(*ppPlayerList, &dwPlayersActual, DPNENUM_PLAYERS);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Error enumerating players from session: 0x%08x", 1, hr);
		delete (*ppDP8Peer);
		*ppDP8Peer = NULL;
		fRet = FALSE;
		goto EXIT;
	}

	DPTEST_TRACE(hLog, "Session successfully connected and all %u players created", 1, pContext->dwPlayersExpected);

EXIT:

	// Release the address
	if(pDP8HostAddress)
	{
		pDP8HostAddress->Release();
		pDP8HostAddress = NULL;
	}

	// Release the address
	if(pDP8DeviceAddress)
	{
		pDP8DeviceAddress->Release();
		pDP8DeviceAddress = NULL;
	}

	return fRet;
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"CreateServerAndWaitForPlayers"
//==================================================================================
// CreateServerAndWaitForPlayers
//----------------------------------------------------------------------------------
//
// Description: Creates a host at and waits for a given number of users to be created
//
// Arguments:
//	HANDLE						hLog				Handle to logging subsystem
//	PWRAPDP8PEER				*ppDP8Server		Pointer filled with server
//	PBASESESSIONCREATECONTEXT	pContext			Callback context
//	DPN_APPLICATION_DESC		*pdpnad				Application descriptor of host session
//	PFNDPNMESSAGEHANDLER		pfnMessageHandler	Callback function
//	PDPNID						*ppPlayerList		Pointer filled with player ID's
//	DWORD						dwPlayersExpected	Number of players expected
//	DWORD						dwTimeout			Milliseconds before timing out operation
//
//
// Returns: TRUE if the session is connected to and the expected number of players is presen
//			FALSE otherwise
//==================================================================================
BOOL CreateServerAndWaitForPlayers(HANDLE hLog, PWRAPDP8SERVER *ppDP8Server, PBASESESSIONCREATECONTEXT pContext, DPN_APPLICATION_DESC *pdpnad, PFNDPNMESSAGEHANDLER pfnMessageHandler, PDPNID *ppPlayerList, DWORD dwPlayersExpected, DWORD dwTimeout)
{
	PDIRECTPLAY8ADDRESS		pDP8DeviceAddress = NULL;
	HRESULT					hr;
	DWORD					dwPort, dwPlayersActual;
	BOOL					fRet = TRUE;

	// Create the server wrapper
	*ppDP8Server = new CWrapDP8Server(hLog);
	if (*ppDP8Server == NULL)
	{
		DPTEST_TRACE(hLog, "Couldn't create server wrapper object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create the DirectPlay server object
	hr = (*ppDP8Server)->CoCreate();
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create an address to host with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Set up the context
	pContext->dwPlayersCreated = 0;
	pContext->dwPlayersExpected = dwPlayersExpected;
	pContext->fPlayersHaveLeft = FALSE;
	pContext->hbsccAllPlayersCreated = CreateEvent(NULL, FALSE, FALSE, NULL);

	if(!pContext->hbsccAllPlayersCreated)
	{
		DPTEST_TRACE(hLog, "Couldn't create AllPlayersCreated event!", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Initialized the host
	hr = (*ppDP8Server)->DP8S_Initialize(pContext, pfnMessageHandler, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Initializing with context, 0 flags failed!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Always default to this port.  Allows netmon parsers to detect DirectPlay packets
	dwPort = 2302;
	
	if(pDP8DeviceAddress->AddComponent(DPNA_KEY_PORT, &dwPort, sizeof(dwPort), DPNA_DATATYPE_DWORD) != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't set port for host", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Host the session
	hr = (*ppDP8Server)->DP8S_Host(pdpnad, &pDP8DeviceAddress, 1, NULL, NULL, NULL, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Hosting with 1 device failed!", 0);
		fRet = FALSE;
		goto EXIT;
	} // end if (couldn't host)

	// Wait for all the players to be connected
	if(WaitForSingleObject(pContext->hbsccAllPlayersCreated, 120000) != WAIT_OBJECT_0)
	{
		DPTEST_TRACE(hLog, "Players weren't created within 2 minutes", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the number of players created
	dwPlayersActual = 0;
	(*ppDP8Server)->DP8S_EnumPlayersAndGroups(NULL, &dwPlayersActual, DPNENUM_PLAYERS);
	if(dwPlayersActual != pContext->dwPlayersExpected)
	{
		DPTEST_TRACE(hLog, "Unexpected number of players in session: (%u != %u)", 2, dwPlayersActual, dwPlayersExpected);
		fRet = FALSE;
		goto EXIT;
	}

	// Allocate a buffer for the players
	*ppPlayerList = (DPNID *) MemAlloc(sizeof(DPNID) * dwPlayersActual);
	if(!*ppPlayerList)
	{
		DPTEST_TRACE(hLog, "Couldn't allocate player ID buffer", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Get the players that were created
	hr = (*ppDP8Server)->DP8S_EnumPlayersAndGroups(*ppPlayerList, &dwPlayersActual, DPNENUM_PLAYERS);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Error enumerating players from session: 0x%08x", 1, hr);
		fRet = FALSE;
		goto EXIT;
	}

	DPTEST_TRACE(hLog, "Session successfully hosted and all %u players created", 1, pContext->dwPlayersExpected);

EXIT:

	// Release the address
	if(pDP8DeviceAddress)
	{
		pDP8DeviceAddress->Release();
		pDP8DeviceAddress = NULL;
	}

	return fRet;
}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnectClient()"
//==================================================================================
// ConnectClient
//----------------------------------------------------------------------------------
//
// Description: Connects to a server at a specified address
//
// Arguments:
//	HANDLE						hLog				Handle to logging subsystem
//	PWRAPDP8CLIENT				*ppDP8Client		Pointer filled with client
//	PBASESESSIONCREATECONTEXT	pContext			Callback context
//	DWORD						dwHostAddr			DWORD form of host's IP address
//	DPN_APPLICATION_DESC		*pdpnad				Application descriptor of host session
//	PFNDPNMESSAGEHANDLER		pfnMessageHandler	Callback function
//	DWORD						dwTimeout			Milliseconds before timing out operation
//
//
// Returns: TRUE if the session is connected to and the expected number of players is presen
//			FALSE otherwise
//==================================================================================
BOOL ConnectClient(HANDLE hLog, PWRAPDP8CLIENT *ppDP8Client, PBASESESSIONCREATECONTEXT pContext, DWORD dwHostAddr, DPN_APPLICATION_DESC *pdpnad, PFNDPNMESSAGEHANDLER pfnMessageHandler, DWORD dwTimeout)
{
	PDIRECTPLAY8ADDRESS		pDP8HostAddress = NULL, pDP8DeviceAddress = NULL;
	SOCKADDR_IN				HostAddr;
	DPNHANDLE				hAsync = NULL;
	HRESULT					hr;
	DWORD					dwPort;
	BOOL					fRet;

	// Create the clinet wrapper
	*ppDP8Client = new CWrapDP8Client(hLog);
	if (*ppDP8Client == NULL)
	{
		DPTEST_TRACE(hLog, "Couldn't create client wrapper object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create the DirectPlay client object
	hr = (*ppDP8Client)->CoCreate();
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate DirectPlay8Client object!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Create an address to host with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8HostAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Create an address for the device we are connecting with
	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8DeviceAddress, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't CoCreate first DirectPlay8Address object!", 0);
		fRet = FALSE;
		goto EXIT;
	}

	// Clients done get CREATE_PLAYER callbacks, to this shouldn't be needed
	pContext->hbsccAllPlayersCreated = NULL;

	// Initialized the host
	hr = (*ppDP8Client)->DP8C_Initialize(pContext, pfnMessageHandler, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Initializing with context, 0 flags failed!", 0);
		fRet = FALSE;
		goto EXIT;
	}
	
	// Build a socket address for the session on the host machine
	HostAddr.sin_family = AF_INET;
	HostAddr.sin_port = htons(2302);
	HostAddr.sin_addr.S_un.S_addr = dwHostAddr;

	// Set that address
	if(pDP8HostAddress->BuildFromSockAddr((SOCKADDR *) &HostAddr) != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't set port for host", 0);
		fRet = FALSE;
		goto EXIT;
	}


	// Host the session
	hr = (*ppDP8Client)->DP8C_Connect(pdpnad, pDP8HostAddress, pDP8DeviceAddress, NULL, NULL, NULL, 0, NULL, &hAsync, 0);
	if (hr != DPNERR_PENDING)
	{
		DPTEST_TRACE(hLog, "Connecting to server failed: 0x%08x", 1, hr);
		fRet = FALSE;
		goto EXIT;
	} // end if (couldn't host)

	// Wait for all the players to be connected
	if(WaitForSingleObject(pContext->hbsccAllPlayersCreated, 120000) != WAIT_OBJECT_0)
	{
		DPTEST_TRACE(hLog, "Players weren't created within 2 minutes", 0);
		fRet = FALSE;
		goto EXIT;
	}

	DPTEST_TRACE(hLog, "Session successfully connected", 0);

EXIT:

	// Release the address
	if(pDP8HostAddress)
	{
		pDP8HostAddress->Release();
		pDP8HostAddress = NULL;
	}

	// Release the address
	if(pDP8DeviceAddress)
	{
		pDP8DeviceAddress->Release();
		pDP8DeviceAddress = NULL;
	}

	return fRet;


}
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"PollUntilEventSignalled()"
//==================================================================================
// PollUntilEventSignalled
//----------------------------------------------------------------------------------
//
// Description: Calls the peer's DoWork function until the specified event is signalled
//
// Arguments:
//	HANDLE					hLog			Handle to logging subsystem
//	PDP_DOWORKLIST			pDoWorkList		Pointer to structure containing objects to call DoWork on
//	DWORD					dwMaxTime		Maximum time to wait before returning failure
//	HANDLE					hEvent			Handle to event that must be signalled to exit
//
// Returns: TRUE if the event signalled successfully
//			FALSE otherwise
//==================================================================================
BOOL PollUntilEventSignalled(HANDLE hLog, PDP_DOWORKLIST pDoWorkList, DWORD dwMaxTime, HANDLE hEvent)
{
	HRESULT	hr = S_OK;
	DWORD	dwStartDoWorkTime, dwEndDoWorkTime, dwAdjustedDoWorkDuration, dwWaitResult;
	DWORD	dwTotalTime, dwStartTime, dwEndTime, dwCurrentObject;
	DWORD	*pdwPeerDoWorkTotalTimes = NULL;
	DWORD	*pdwPeerDoWorkTotalCalls = NULL;
	DWORD	*pdwPeerDoWorkMaxTime = NULL;
	DWORD	*pdwPeerDoWorkMinTime = NULL;
	DWORD	*pdwClientDoWorkTotalTimes = NULL;
	DWORD	*pdwClientDoWorkTotalCalls = NULL;
	DWORD	*pdwClientDoWorkMaxTime = NULL;
	DWORD	*pdwClientDoWorkMinTime = NULL;
	DWORD	*pdwServerDoWorkTotalTimes = NULL;
	DWORD	*pdwServerDoWorkTotalCalls = NULL;
	DWORD	*pdwServerDoWorkMaxTime = NULL;
	DWORD	*pdwServerDoWorkMinTime = NULL;
	BOOL	fRet = TRUE, fRunDoWorkLoop = TRUE;

	// Need to get the start time to determine later if too much time has been
	// spent doing work and waiting
	if(dwMaxTime != INFINITE)
	{
		dwStartTime = GetTickCount();
		dwTotalTime = 0;
	}

	// If we're tracking DoWork times.  Take a global DoWork start time.
	if(pDoWorkList->fTrackDoWorkTimes)
	{
		// Allocate and initialize variables for tracking any peer object DoWork times
		if(pDoWorkList->dwNumPeers)
		{
			pdwPeerDoWorkTotalTimes = (DWORD *) MemAlloc(pDoWorkList->dwNumPeers * sizeof(DWORD));
			pdwPeerDoWorkTotalCalls = (DWORD *) MemAlloc(pDoWorkList->dwNumPeers * sizeof(DWORD));
			pdwPeerDoWorkMaxTime = (DWORD *) MemAlloc(pDoWorkList->dwNumPeers * sizeof(DWORD));
			pdwPeerDoWorkMinTime = (DWORD *) MemAlloc(pDoWorkList->dwNumPeers * sizeof(DWORD));

			if(!pdwPeerDoWorkTotalTimes || !pdwPeerDoWorkTotalCalls || !pdwPeerDoWorkMaxTime || !pdwPeerDoWorkMinTime)
			{
				xLog(hLog, XLL_WARN, "Couldn't allocate variables for tracking DoWork time on peer objects!");
				fRet = FALSE;
				goto Exit;
			}

			memset(pdwPeerDoWorkTotalTimes, 0, pDoWorkList->dwNumPeers * sizeof(DWORD));
			memset(pdwPeerDoWorkTotalCalls, 0, pDoWorkList->dwNumPeers * sizeof(DWORD));
			memset(pdwPeerDoWorkMaxTime, 0, pDoWorkList->dwNumPeers * sizeof(DWORD));
			memset(pdwPeerDoWorkMinTime, 0xFF, pDoWorkList->dwNumPeers * sizeof(DWORD));
		}

		// Allocate and initialize variables for tracking any client object DoWork times
		if(pDoWorkList->dwNumClients)
		{
			pdwClientDoWorkTotalTimes = (DWORD *) MemAlloc(pDoWorkList->dwNumClients * sizeof(DWORD));
			pdwClientDoWorkTotalCalls = (DWORD *) MemAlloc(pDoWorkList->dwNumClients * sizeof(DWORD));
			pdwClientDoWorkMaxTime = (DWORD *) MemAlloc(pDoWorkList->dwNumClients * sizeof(DWORD));
			pdwClientDoWorkMinTime = (DWORD *) MemAlloc(pDoWorkList->dwNumClients * sizeof(DWORD));

			if(!pdwClientDoWorkTotalTimes || !pdwClientDoWorkTotalCalls || !pdwClientDoWorkMaxTime || !pdwClientDoWorkMinTime)
			{
				xLog(hLog, XLL_WARN, "Couldn't allocate variables for tracking DoWork time on client objects!");
				fRet = FALSE;
				goto Exit;
			}

			memset(pdwClientDoWorkTotalTimes, 0, pDoWorkList->dwNumClients * sizeof(DWORD));
			memset(pdwClientDoWorkTotalCalls, 0, pDoWorkList->dwNumClients * sizeof(DWORD));
			memset(pdwClientDoWorkMaxTime, 0, pDoWorkList->dwNumClients * sizeof(DWORD));
			memset(pdwClientDoWorkMinTime, 0xFF, pDoWorkList->dwNumClients * sizeof(DWORD));
		}

		// Allocate and initialize variables for tracking any server object DoWork times
		if(pDoWorkList->dwNumServers)
		{
			pdwServerDoWorkTotalTimes = (DWORD *) MemAlloc(pDoWorkList->dwNumServers * sizeof(DWORD));
			pdwServerDoWorkTotalCalls = (DWORD *) MemAlloc(pDoWorkList->dwNumServers * sizeof(DWORD));
			pdwServerDoWorkMaxTime = (DWORD *) MemAlloc(pDoWorkList->dwNumServers * sizeof(DWORD));
			pdwServerDoWorkMinTime = (DWORD *) MemAlloc(pDoWorkList->dwNumServers * sizeof(DWORD));

			if(!pdwServerDoWorkTotalTimes || !pdwServerDoWorkTotalCalls || !pdwServerDoWorkMaxTime || !pdwServerDoWorkMinTime)
			{
				xLog(hLog, XLL_WARN, "Couldn't allocate variables for tracking DoWork time on server objects!");
				fRet = FALSE;
				goto Exit;
			}

			memset(pdwServerDoWorkTotalTimes, 0, pDoWorkList->dwNumServers * sizeof(DWORD));
			memset(pdwServerDoWorkTotalCalls, 0, pDoWorkList->dwNumServers * sizeof(DWORD));
			memset(pdwServerDoWorkMaxTime, 0, pDoWorkList->dwNumServers * sizeof(DWORD));
			memset(pdwServerDoWorkMinTime, 0xFF, pDoWorkList->dwNumServers * sizeof(DWORD));
		}
	}

	// Wait to see if the event has completed.  May not even require a DoWork call
	dwWaitResult = WaitForSingleObject(hEvent, 0);
	switch(dwWaitResult)
	{
	case WAIT_OBJECT_0:
		xLog(hLog, XLL_INFO, "Event completed without needing to call DoWork!");
		fRunDoWorkLoop = FALSE;
		break;
	case WAIT_TIMEOUT:
		break;
	default:
		xLog(hLog, XLL_WARN, "Error %u occurred while waiting on event handle 0x%08x", dwWaitResult, hEvent);
		fRet = FALSE;
		goto Exit;
	}

	while(fRunDoWorkLoop)
	{
		// Cycle through peer objects and perform DoWork processing
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumPeers; ++dwCurrentObject)
		{
			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Blank out the callback time tracker for this object
				// This is a pointer to the part of the objects context that contains
				// the DWORD that tracks total time spent in the callback
				*((pDoWorkList->apdwPeerCallbackTimes)[dwCurrentObject]) = 0;

				// Get the time immediately before calling DoWork
				dwStartDoWorkTime = GetTickCount();
			}

			// Do work on this object
			pDoWorkList->apDP8Peers[dwCurrentObject]->DoWork(0);

			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Get the end time immediately after calling DoWork
				dwEndDoWorkTime = GetTickCount();
				
				// Compute the delta between the start time of DoWork and the end time
				// Taking into account the rare possibility of the system clock rolling over
				if(dwEndDoWorkTime >= dwStartDoWorkTime)
					dwAdjustedDoWorkDuration = dwEndDoWorkTime - dwStartDoWorkTime;
				else
					dwAdjustedDoWorkDuration = (0xFFFFFFFF - dwStartDoWorkTime) + dwEndDoWorkTime;
				
				// Not sure if this is possible... but if a callback was triggered by another thread
				// between the time that the callback time was set to 0 and the time that DoWork was
				// called, then it could be possible for the callback time to exceed the total DoWork
				// time...  In this case, log a message and just assume that 0 time was spent in callback
				if(dwAdjustedDoWorkDuration < *((pDoWorkList->apdwPeerCallbackTimes)[dwCurrentObject]))
				{
					xLog(hLog, XLL_WARN, "Timing problem!  DoWork time (%u) is less than callback time (%u)",
						dwAdjustedDoWorkDuration, *((pDoWorkList->apdwPeerCallbackTimes)[dwCurrentObject]));
				}

				// Account for the time spent in the callback
				dwAdjustedDoWorkDuration -= *((pDoWorkList->apdwPeerCallbackTimes)[dwCurrentObject]);

				// Update the new minimum's and maximums
				if(pdwPeerDoWorkMaxTime[dwCurrentObject] < dwAdjustedDoWorkDuration)
					pdwPeerDoWorkMaxTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				if(pdwPeerDoWorkMinTime[dwCurrentObject] > dwAdjustedDoWorkDuration)
					pdwPeerDoWorkMinTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				// Update the new totals.  Taking into account the rare possibility that
				// the measure totals have rolled over the value of a DWORD
				if((0xFFFFFFFF - pdwPeerDoWorkTotalTimes[dwCurrentObject]) < dwAdjustedDoWorkDuration)
					pdwPeerDoWorkTotalTimes[dwCurrentObject] = 0xFFFFFFFF;
				else
					pdwPeerDoWorkTotalTimes[dwCurrentObject] += dwAdjustedDoWorkDuration;

				if(pdwPeerDoWorkTotalCalls[dwCurrentObject] != 0xFFFFFFFF)
					++pdwPeerDoWorkTotalCalls[dwCurrentObject];
			}

			if(hr != DPN_OK)
			{
				xLog(hLog, XLL_WARN, "Couldn't do DirectPlay work on a peer object! (0x%08x)", hr);
				fRet = FALSE;
				goto Exit;
			}

			// Wait for the desired result
			dwWaitResult = WaitForSingleObject(hEvent, 0);

			// Event completed.  Exit the loop
			if(dwWaitResult == WAIT_OBJECT_0)
				goto Exit;

			// If there's an upper bound on the amount of time that can be spent waiting for is event
			// See if that amount of time has already passed
			if(dwMaxTime != INFINITE)
			{
				dwEndTime = GetTickCount();
				dwTotalTime = (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

				// If time has expired... bail
				if(dwTotalTime > dwMaxTime)
				{
					xLog(hLog, XLL_WARN, "Event wasn't signalled within %u ms", dwMaxTime);
					fRet = FALSE;
					goto Exit;
				}
			}
		} // End of loop for doing work over peer objects

		// Cycle through client objects and perform DoWork processing
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumClients; ++dwCurrentObject)
		{
			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Blank out the callback time tracker for this object
				// This is a pointer to the part of the objects context that contains
				// the DWORD that tracks total time spent in the callback
				*((pDoWorkList->apdwClientCallbackTimes)[dwCurrentObject]) = 0;

				// Get the time immediately before calling DoWork
				dwStartDoWorkTime = GetTickCount();
			}

			// Do work on this object
			pDoWorkList->apDP8Clients[dwCurrentObject]->DoWork(0);

			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Get the end time immediately after calling DoWork
				dwEndDoWorkTime = GetTickCount();
				
				// Compute the delta between the start time of DoWork and the end time
				// Taking into account the rare possibility of the system clock rolling over
				if(dwEndDoWorkTime >= dwStartDoWorkTime)
					dwAdjustedDoWorkDuration = dwEndDoWorkTime - dwStartDoWorkTime;
				else
					dwAdjustedDoWorkDuration = (0xFFFFFFFF - dwStartDoWorkTime) + dwEndDoWorkTime;
				
				// Not sure if this is possible... but if a callback was triggered by another thread
				// between the time that the callback time was set to 0 and the time that DoWork was
				// called, then it could be possible for the callback time to exceed the total DoWork
				// time...  In this case, log a message and just assume that 0 time was spent in callback
				if(dwAdjustedDoWorkDuration < *((pDoWorkList->apdwClientCallbackTimes)[dwCurrentObject]))
				{
					xLog(hLog, XLL_WARN, "Timing problem!  DoWork time (%u) is less than callback time (%u)",
						dwAdjustedDoWorkDuration, *((pDoWorkList->apdwClientCallbackTimes)[dwCurrentObject]));
				}

				// Account for the time spent in the callback
				dwAdjustedDoWorkDuration -= *((pDoWorkList->apdwClientCallbackTimes)[dwCurrentObject]);

				// Update the new minimum's and maximums
				if(pdwClientDoWorkMaxTime[dwCurrentObject] < dwAdjustedDoWorkDuration)
					pdwClientDoWorkMaxTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				if(pdwClientDoWorkMinTime[dwCurrentObject] > dwAdjustedDoWorkDuration)
					pdwClientDoWorkMinTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				// Update the new totals.  Taking into account the rare possibility that
				// the measure totals have rolled over the value of a DWORD
				if(0xFFFFFFFF - pdwClientDoWorkTotalTimes[dwCurrentObject] < dwAdjustedDoWorkDuration)
					pdwClientDoWorkTotalTimes[dwCurrentObject] = 0xFFFFFFFF;
				else
					pdwClientDoWorkTotalTimes[dwCurrentObject] += dwAdjustedDoWorkDuration;

				if(pdwClientDoWorkTotalCalls[dwCurrentObject] != 0xFFFFFFFF)
					++pdwClientDoWorkTotalCalls[dwCurrentObject];
			}

			if(hr != DPN_OK)
			{
				xLog(hLog, XLL_WARN, "Couldn't do DirectPlay work on a client object! (0x%08x)", hr);
				fRet = FALSE;
				goto Exit;
			}

			// Wait for the desired result
			dwWaitResult = WaitForSingleObject(hEvent, 0);

			// Event completed.  Exit the loop
			if(dwWaitResult == WAIT_OBJECT_0)
				goto Exit;

			// If there's an upper bound on the amount of time that can be spent waiting for is event
			// See if that amount of time has already passed
			if(dwMaxTime != INFINITE)
			{
				dwEndTime = GetTickCount();
				dwTotalTime = (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

				// If time has expired... bail
				if(dwTotalTime > dwMaxTime)
				{
					xLog(hLog, XLL_WARN, "Event wasn't signalled within %u ms", dwMaxTime);
					fRet = FALSE;
					goto Exit;
				}
			}
		} // End of loop for doing work over client objects


		// Cycle through server objects and perform DoWork processing
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumServers; ++dwCurrentObject)
		{
			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Blank out the callback time tracker for this object
				// This is a pointer to the part of the objects context that contains
				// the DWORD that tracks total time spent in the callback
				*((pDoWorkList->apdwServerCallbackTimes)[dwCurrentObject]) = 0;

				// Get the time immediately before calling DoWork
				dwStartDoWorkTime = GetTickCount();
			}

			// Do work on this object
			pDoWorkList->apDP8Servers[dwCurrentObject]->DoWork(0);

			if(pDoWorkList->fTrackDoWorkTimes)
			{
				// Get the end time immediately after calling DoWork
				dwEndDoWorkTime = GetTickCount();
				
				// Compute the delta between the start time of DoWork and the end time
				// Taking into account the rare possibility of the system clock rolling over
				if(dwEndDoWorkTime >= dwStartDoWorkTime)
					dwAdjustedDoWorkDuration = dwEndDoWorkTime - dwStartDoWorkTime;
				else
					dwAdjustedDoWorkDuration = (0xFFFFFFFF - dwStartDoWorkTime) + dwEndDoWorkTime;
				
				// Not sure if this is possible... but if a callback was triggered by another thread
				// between the time that the callback time was set to 0 and the time that DoWork was
				// called, then it could be possible for the callback time to exceed the total DoWork
				// time...  In this case, log a message and just assume that 0 time was spent in callback
				if(dwAdjustedDoWorkDuration < *((pDoWorkList->apdwServerCallbackTimes)[dwCurrentObject]))
				{
					xLog(hLog, XLL_WARN, "Timing problem!  DoWork time (%u) is less than callback time (%u)",
						dwAdjustedDoWorkDuration, *((pDoWorkList->apdwServerCallbackTimes)[dwCurrentObject]));
				}

				// Account for the time spent in the callback
				dwAdjustedDoWorkDuration -= *((pDoWorkList->apdwServerCallbackTimes)[dwCurrentObject]);

				// Update the new minimum's and maximums
				if(pdwServerDoWorkMaxTime[dwCurrentObject] < dwAdjustedDoWorkDuration)
					pdwServerDoWorkMaxTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				if(pdwServerDoWorkMinTime[dwCurrentObject] > dwAdjustedDoWorkDuration)
					pdwServerDoWorkMinTime[dwCurrentObject] = dwAdjustedDoWorkDuration;

				// Update the new totals.  Taking into account the rare possibility that
				// the measure totals have rolled over the value of a DWORD
				if(0xFFFFFFFF - pdwServerDoWorkTotalTimes[dwCurrentObject] < dwAdjustedDoWorkDuration)
					pdwServerDoWorkTotalTimes[dwCurrentObject] = 0xFFFFFFFF;
				else
					pdwServerDoWorkTotalTimes[dwCurrentObject] += dwAdjustedDoWorkDuration;

				if(pdwServerDoWorkTotalCalls[dwCurrentObject] != 0xFFFFFFFF)
					++pdwServerDoWorkTotalCalls[dwCurrentObject];
			}

			if(hr != DPN_OK)
			{
				xLog(hLog, XLL_WARN, "Couldn't do DirectPlay work on a server object! (0x%08x)", hr);
				fRet = FALSE;
				goto Exit;
			}

			// Wait for the desired result
			dwWaitResult = WaitForSingleObject(hEvent, 0);

			// Event completed.  Exit the loop
			if(dwWaitResult == WAIT_OBJECT_0)
				goto Exit;

			// If there's an upper bound on the amount of time that can be spent waiting for is event
			// See if that amount of time has already passed
			if(dwMaxTime != INFINITE)
			{
				dwEndTime = GetTickCount();
				dwTotalTime = (dwEndTime >= dwStartTime) ? dwEndTime - dwStartTime : (0xFFFFFFFF - dwStartTime) + dwEndTime;

				// If time has expired... bail
				if(dwTotalTime > dwMaxTime)
				{
					xLog(hLog, XLL_WARN, "Event wasn't signalled within %u ms", dwMaxTime);
					fRet = FALSE;
					goto Exit;
				}
			}
		} // End of loop for doing work over server objects
	}

Exit:

	// The loop only exits if the event that's being waited for is successfully signalled
	// Otherwise, there would be a goto directly to the Exit.  So this is where DoWork
	// time information should be logged
	if(pDoWorkList->fTrackDoWorkTimes)
	{
		xLog(hLog, XLL_INFO, "DoWork processing times:");

		// Loop through peer objects and display DoWork times
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumPeers; ++dwCurrentObject)
		{
			if(pdwPeerDoWorkTotalCalls[dwCurrentObject])
			{
				xLog(hLog, XLL_INFO, "    Peer   %2u:  %u calls  (%u ms total, %u ms max, %u ms min)",
					dwCurrentObject + 1,
					pdwPeerDoWorkTotalCalls[dwCurrentObject],
					pdwPeerDoWorkTotalTimes[dwCurrentObject],
					pdwPeerDoWorkMaxTime[dwCurrentObject],
					pdwPeerDoWorkMinTime[dwCurrentObject]);
			}
			else
			{
				xLog(hLog, XLL_INFO, "    Peer   %2u:  0 calls",
					dwCurrentObject + 1);
			}
		}

		// Loop through client objects and display DoWork times
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumClients; ++dwCurrentObject)
		{
			if(pdwClientDoWorkTotalCalls[dwCurrentObject])
			{
				xLog(hLog, XLL_INFO, "    Client %2u:  %u calls  (%u ms total, %u ms max, %u ms min)",
					dwCurrentObject + 1,
					pdwClientDoWorkTotalCalls[dwCurrentObject],
					pdwClientDoWorkTotalTimes[dwCurrentObject],
					pdwClientDoWorkMaxTime[dwCurrentObject],
					pdwClientDoWorkMinTime[dwCurrentObject]);
			}
			else
			{
				xLog(hLog, XLL_INFO, "    Client %2u:  0 calls",
					dwCurrentObject + 1);
			}
		}

		// Loop through server objects and display DoWork times
		for(dwCurrentObject = 0; dwCurrentObject < pDoWorkList->dwNumServers; ++dwCurrentObject)
		{
			if(pdwServerDoWorkTotalCalls[dwCurrentObject])
			{
				xLog(hLog, XLL_INFO, "    Server %2u:  %u calls  (%u ms total, %u ms max, %u ms min)",
					dwCurrentObject + 1,
					pdwServerDoWorkTotalCalls[dwCurrentObject],
					pdwServerDoWorkTotalTimes[dwCurrentObject],
					pdwServerDoWorkMaxTime[dwCurrentObject],
					pdwServerDoWorkMinTime[dwCurrentObject]);
			}
			else
			{
				xLog(hLog, XLL_INFO, "    Server %2u:  0 calls",
					dwCurrentObject + 1);
			}
		}
	}

	if(pDoWorkList->fTrackDoWorkTimes)
	{
		// Release peer DoWork time tracker variables
		if(pDoWorkList->dwNumPeers)
		{
			pdwPeerDoWorkTotalTimes ? MemFree(pdwPeerDoWorkTotalTimes) : 0;
			pdwPeerDoWorkTotalCalls ? MemFree(pdwPeerDoWorkTotalCalls) : 0;
			pdwPeerDoWorkMaxTime ? MemFree(pdwPeerDoWorkMaxTime) : 0;
			pdwPeerDoWorkMinTime ? MemFree(pdwPeerDoWorkMinTime) : 0;
		}

		// Release client DoWork time tracker variables
		if(pDoWorkList->dwNumClients)
		{
			pdwClientDoWorkTotalTimes ? MemFree(pdwClientDoWorkTotalTimes) : 0;
			pdwClientDoWorkTotalCalls ? MemFree(pdwClientDoWorkTotalCalls) : 0;
			pdwClientDoWorkMaxTime ? MemFree(pdwClientDoWorkMaxTime) : 0;
			pdwClientDoWorkMinTime ? MemFree(pdwClientDoWorkMinTime) : 0;
		}

		// Release server DoWork time tracker variables
		if(pDoWorkList->dwNumServers)
		{
			pdwServerDoWorkTotalTimes ? MemFree(pdwServerDoWorkTotalTimes) : 0;
			pdwServerDoWorkTotalCalls ? MemFree(pdwServerDoWorkTotalCalls) : 0;
			pdwServerDoWorkMaxTime ? MemFree(pdwServerDoWorkMaxTime) : 0;
			pdwServerDoWorkMinTime ? MemFree(pdwServerDoWorkMinTime) : 0;
		}
	}

	return fRet;
}

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\dptest.h ===
#ifndef __DPTEST_H__
#define __DPTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <stdio.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>

#include <dplay8.h>
#include <dpaddr.h>

#include "guids.h"
#include "dpmsg.h"
#include "wrappeer.h"
#include "wrapserver.h"
#include "wrapclient.h"

namespace DPlayCoreNamespace {

//==================================================================================
// Defines
//==================================================================================
#define DP_SERVER_DLL_W L"dpserv.dll"
#define DP_SERVER_MAIN_FUNCTION_A "DpServerCallbackFunction"
#define DP_SERVER_START_FUNCTION_A "DpServerStartFunction"
#define DP_SERVER_STOP_FUNCTION_A "DpServerStopFunction"

#define SIMPLE_SERVER_EVENT "SimpleServer"
#define SIMPLE_HOST_EVENT "SimpleHost"
#define CS_ENUM_EVENT "CSEnum"
#define PEER_ENUM_EVENT "PeerEnum"
#define CSREJECT_ENUM_EVENT "CSReject"
#define PEERREJECT_ENUM_EVENT "PeerReject"
#define CSAPP_ENUM_EVENT "CSApp"
#define PEERAPP_ENUM_EVENT "PeerApp"
#define CSUSER_ENUM_EVENT "CSUser"
#define PEERUSER_ENUM_EVENT "PeerUser"
#define ENUM_VALIDATE_EVENT "EnumValidate"
#define SEND_BEGIN_EVENT "SendBegin"
#define SEND_END_EVENT "SendEnd"
#define GROUP_BEGIN_EVENT "GroupBegin"
#define PEER_GROUP_EVENT "PeerGroup"
#define PEER_SENDS_EVENT "PeerSends"
#define CS_GROUP_EVENT "CSGroup"
#define CS_SENDS_EVENT "CSSends"

#define MAX_REQUEST_RETRIES 5
#define RECEIVE_TIMEOUT 30000
#define	MAX_SYNC_DATASIZE 512

//#pragma TODO(tristan, "Do ANSI versions need to be present in Xbox header?")
#ifndef DPNA_SEPARATOR_KEYVALUE_A
#define DPNA_SEPARATOR_KEYVALUE_A			'='
#endif

#ifndef DPNA_SEPARATOR_USERDATA_A
#define DPNA_SEPARATOR_USERDATA_A			'#'
#endif

#ifndef DPNA_SEPARATOR_COMPONENT_A
#define DPNA_SEPARATOR_COMPONENT_A			';'
#endif

#ifndef DPNA_ESCAPECHAR_A
#define DPNA_ESCAPECHAR_A					'%'
#endif

#ifndef DPNA_HEADER_A
#define DPNA_HEADER_A						"x-directplay:/"
#endif

#ifndef DPNA_KEY_APPLICATION_INSTANCE_A
#define DPNA_KEY_APPLICATION_INSTANCE_A		"applicationinstance"
#endif

#ifndef DPNA_KEY_BAUD_A
#define DPNA_KEY_BAUD_A						"baud"
#endif

#ifndef DPNA_KEY_DEVICE_A
#define DPNA_KEY_DEVICE_A					"device"
#endif

#ifndef DPNA_KEY_FLOWCONTROL_A
#define DPNA_KEY_FLOWCONTROL_A				"flowcontrol"
#endif

#ifndef DPNA_KEY_HOSTNAME_A
#define DPNA_KEY_HOSTNAME_A					"hostname"
#endif

#ifndef DPNA_KEY_PARITY_A
#define DPNA_KEY_PARITY_A					"parity"
#endif

#ifndef DPNA_KEY_PHONENUMBER_A
#define DPNA_KEY_PHONENUMBER_A				"phonenumber"
#endif

#ifndef DPNA_KEY_PORT_A
#define DPNA_KEY_PORT_A						"port"
#endif

#ifndef DPNA_KEY_PROGRAM_A
#define DPNA_KEY_PROGRAM_A					"program"
#endif

#ifndef DPNA_KEY_PROVIDER_A
#define DPNA_KEY_PROVIDER_A					"provider"
#endif

#ifndef DPNA_KEY_STOPBITS_A
#define DPNA_KEY_STOPBITS_A					"stopbits"
#endif

#ifndef DPNA_VALUE_TCPIPPROVIDER_A
#define DPNA_VALUE_TCPIPPROVIDER_A			"IP"
#endif

//==================================================================================
// Typedefs
//==================================================================================

// DP test case IDs
typedef enum _DPMSG_LOCAL_TESTTYPES
{
	DPMSG_LOCAL_BASE = 0,
	DPMSG_ADDR_BUILDW = 0,
	DPMSG_ADDR_BUILDA,
	DPMSG_ADDR_DUPLICATE,
	DPMSG_ADDR_SETEQUAL,
	DPMSG_ADDR_ISEQUAL,
	DPMSG_ADDR_CLEAR,
	DPMSG_ADDR_GETURLW,
	DPMSG_ADDR_GETURLA,
	DPMSG_ADDR_GETSP,
	DPMSG_ADDR_GETUSERDATA,
	DPMSG_ADDR_SETSP,
	DPMSG_ADDR_SETUSERDATA,
	DPMSG_ADDR_GETNUMCOMPONENTS,
	DPMSG_ADDR_GETBYNAME,
	DPMSG_ADDR_GETBYINDEX,
	DPMSG_ADDR_ADD,
	DPMSG_ADDR_GETDEVICE,
	DPMSG_ADDR_SETDEVICE,
		
	DPMSG_ADDRIP_BUILDSOCKADDR,
	DPMSG_ADDRIP_GETSOCKADDR,
	DPMSG_ADDRIP_BUILDADDRESS,
	DPMSG_ADDRIP_GETADDRESS,
	DPMSG_ADDRIP_BUILDLOCALADDRESS,
	DPMSG_ADDRIP_GETLOCALADDRESS,
		
	DPMSG_CLIENT_GETSENDQINFO,
	DPMSG_CLIENT_SETCLIENTINFO,
	DPMSG_CLIENT_GETSERVERINFO,
	DPMSG_CLIENT_GETSERVERADDRESS,
	DPMSG_CLIENT_GETCONNINFO,
		
	DPMSG_PEER_CREATEQI,
	DPMSG_PEER_INIT,
	DPMSG_PEER_ENUMSPS,
	DPMSG_PEER_CANCEL,
	DPMSG_PEER_CONNECT,
	DPMSG_PEER_SENDTO,
	DPMSG_PEER_GETSENDQINFO,
	DPMSG_PEER_HOST,
	DPMSG_PEER_GETAPPDESC,
	DPMSG_PEER_SETAPPDESC,
	DPMSG_PEER_CREATEGROUP,
	DPMSG_PEER_DESTROYGROUP,
	DPMSG_PEER_ADDTOGROUP,
	DPMSG_PEER_REMOVEFROMGROUP,
	DPMSG_PEER_SETGROUPINFO,
	DPMSG_PEER_GETGROUPINFO,
	DPMSG_PEER_ENUMPANDG,
	DPMSG_PEER_ENUMGROUPMEMBERS,
	DPMSG_PEER_SETPEERINFO,
	DPMSG_PEER_GETPEERINFO,
	DPMSG_PEER_GETPEERADDRESS,
	DPMSG_PEER_GETLHOSTADDRESSES,
	DPMSG_PEER_CLOSE,
	DPMSG_PEER_ENUMHOSTS,
	DPMSG_PEER_DESTROYPEER,
	DPMSG_PEER_RETURN,
	DPMSG_PEER_GETPLAYERCONTEXT,
	DPMSG_PEER_GETGROUPCONTEXT,
	DPMSG_PEER_GETCAPS,
	DPMSG_PEER_SETCAPS,
	DPMSG_PEER_SETSPCAPS,
	DPMSG_PEER_GETSPCAPS,
	DPMSG_PEER_GETCONNINFO,
	DPMSG_PEER_TERMINATE,
	
	DPMSG_SERVER_CREATEQI,
	DPMSG_SERVER_INIT,
	DPMSG_SERVER_ENUMSPS,
	DPMSG_SERVER_CANCEL,
	DPMSG_SERVER_GETSENDQINFO,
	DPMSG_SERVER_GETAPPDESC,
	DPMSG_SERVER_SETSERVERINFO,
	DPMSG_SERVER_GETCLIENTINFO,
	DPMSG_SERVER_GETCLIENTADDRESS,
	
	DPMSG_LOCAL_MAXTEST
} DPMSG_LOCAL_TESTTYPES, *PDPMSG_LOCAL_TESTTYPES;

// DP test function
typedef HRESULT (*PDP_LOCAL_TEST_FUNCTION)(HANDLE hLog);

typedef struct _BASESESSIONCREATECONTEXT
{
	BOOL		fPlayersHaveLeft;
	HANDLE		hbsccAllPlayersCreated;
	DWORD		dwPlayersExpected;
	DWORD		dwPlayersCreated;
} BASESESSIONCREATECONTEXT, *PBASESESSIONCREATECONTEXT;

typedef struct _DP_ENUMTESTPARAM {
	HANDLE hNetsyncObject;
	CHAR szServerIPAddr[16];
	DWORD dwAppDescDataSize;
	DWORD dwUserEnumDataSize;
	DWORD dwEnumCount;
	DWORD dwRetryInterval;
	DWORD dwTimeOut;
	BOOL fClientServer;
	BOOL fHostTest;
	BOOL fBroadcast;
	BOOL fReject;
} DP_ENUMTESTPARAM, *PDP_ENUMTESTPARAM;

typedef struct _DP_SENDTESTPARAM {
	DWORD dwHostAddr; // DWORD value of host's IP address
	DWORD dwFlags;  // Flags to provide to send... possibly DPNSEND_SYNC
	DWORD dwTimeout;  // Milliseconds to wait before timing out the send operation
	DWORD dwCancelInterval; // How many sends to do before trying a cancel.  Can be 0 for no cancels
	DWORD dwNumMsgs; // Number of sends to perform
	BOOL fHostTest; // Is this the host/server?
	DWORD dwNumMachines; // Total number of players we're expecting
	DWORD dwMsgSize; // Size of message to send
	DWORD dwPercentEatCPU; // If implemented, will set the amount of background CPU utilization
	HANDLE hNetsyncObject; // Handle to netsync
	DWORD dwInterval; // milliseconds to sleep between sends
	BOOL fSendToAllPlayersGroup; // Broadcast to all vs. send to individuals
	DWORD dwCancelFlags; // Flags to provide to cancel... like _SENDS
} DP_SENDTESTPARAM, *PDP_SENDTESTPARAM;


typedef struct _DP_GROUPTESTPARAM {
	DWORD dwHostAddr; // DWORD value of host's IP address
	BOOL fHostTest; // Is this the host/server?
	DWORD dwNumMachines; // Total number of players we're expecting
	HANDLE hNetsyncObject; // Handle to netsync
} DP_GROUPTESTPARAM, *PDP_GROUPTESTPARAM;

// This is cumbersome, but its needed in order to get an idea of how much time
// is being spent inside the DoWork code.  It's also needed so that the polling function
// can know which objects it needs to call DoWork on to complete a particular event
typedef struct _DP_DOWORKLIST {
	BOOL					fTrackDoWorkTimes;			// Boolean indicates if DoWork times should be tracked
														// If true, then CallbackTimes members should be present
														// for all objects
														// If false, then CallbackTimes members will be ignored

	DWORD					dwNumPeers;					// Number of peer objects present
	PDIRECTPLAY8PEER		*apDP8Peers;				// An array of pointers to peer objects
	DWORD					**apdwPeerCallbackTimes;	// An array of pointers to DWORDS that track the
														// amount of time spent in callbacks per peer

	DWORD					dwNumClients;				// Number of client objects present
	PDIRECTPLAY8CLIENT		*apDP8Clients;				// An array of pointers to client objects
	DWORD					**apdwClientCallbackTimes;	// An array of pointers to DWORDS that track the
														// amount of time spent in callbacks per client

	DWORD					dwNumServers;				// Number of client objects present
	PDIRECTPLAY8SERVER		*apDP8Servers;				// An array of pointers to server objects
	DWORD					**apdwServerCallbackTimes;	// An array of pointers to DWORDS that track the
														// amount of time spent in callbacks per server
} DP_DOWORKLIST, *PDP_DOWORKLIST;

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI DpTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI DpTestStartTest(IN HANDLE hLog);
VOID WINAPI DpTestEndTest();

// Helper functions
LPVOID MemAlloc(DWORD dwSize);
BOOL MemFree(LPVOID pBuffer);
void DPTEST_TRACE(HANDLE hLog, LPSTR szFormat, INT nNumArgs ...);
void DPTEST_FAIL(HANDLE hLog, LPSTR szFormat, INT nNumArgs ...);
BOOL SyncWithOtherTesters(HANDLE, HANDLE, LPCSTR, PBYTE, DWORD, PBYTE, DWORD *);
BOOL CreateHostAndWaitForPlayers(HANDLE, PWRAPDP8PEER *, PBASESESSIONCREATECONTEXT, DPN_APPLICATION_DESC *, PFNDPNMESSAGEHANDLER, PDPNID *, DWORD, DWORD);
BOOL ConnectNonHostAndWaitForPlayers(HANDLE, PWRAPDP8PEER *, PBASESESSIONCREATECONTEXT, DWORD, DPN_APPLICATION_DESC *, PFNDPNMESSAGEHANDLER, PDPNID *, DWORD, DWORD);
BOOL CreateServerAndWaitForPlayers(HANDLE, PWRAPDP8SERVER *, PBASESESSIONCREATECONTEXT, DPN_APPLICATION_DESC *, PFNDPNMESSAGEHANDLER, PDPNID *, DWORD, DWORD);
BOOL ConnectClient(HANDLE, PWRAPDP8CLIENT *, PBASESESSIONCREATECONTEXT, DWORD, DPN_APPLICATION_DESC *, PFNDPNMESSAGEHANDLER, DWORD);
BOOL PollUntilEventSignalled(HANDLE hLog, PDP_DOWORKLIST pDoWorkList, DWORD dwMaxTime, HANDLE hEvent);

// DirectPlay8Address tests
HRESULT ParmVExec_BBuildW(HANDLE hLog);
HRESULT ParmVExec_BBuildA(HANDLE hLog);
HRESULT ParmVExec_BDuplicate(HANDLE hLog);
HRESULT ParmVExec_BSetEqual(HANDLE hLog);
HRESULT ParmVExec_BIsEqual(HANDLE hLog);
HRESULT ParmVExec_BClear(HANDLE hLog);
HRESULT ParmVExec_BGetURLW(HANDLE hLog);
HRESULT ParmVExec_BGetURLA(HANDLE hLog);
HRESULT ParmVExec_BGetSP(HANDLE hLog);
HRESULT ParmVExec_BGetUserData(HANDLE hLog);
HRESULT ParmVExec_BSetSP(HANDLE hLog);
HRESULT ParmVExec_BSetUserData(HANDLE hLog);
HRESULT ParmVExec_BGetNumComponents(HANDLE hLog);
HRESULT ParmVExec_BGetByName(HANDLE hLog);
HRESULT ParmVExec_BGetByIndex(HANDLE hLog);
HRESULT ParmVExec_BAdd(HANDLE hLog);
HRESULT ParmVExec_BGetDevice(HANDLE hLog);
HRESULT ParmVExec_BSetDevice(HANDLE hLog);

// DirectPlay8AddressIP tests
HRESULT ParmVExec_IPBuildSockAddr(HANDLE hLog);
HRESULT ParmVExec_IPGetSockAddr(HANDLE hLog);
HRESULT ParmVExec_IPBuildAddress(HANDLE hLog);
HRESULT ParmVExec_IPGetAddress(HANDLE hLog);
HRESULT ParmVExec_IPBuildLocalAddress(HANDLE hLog);
HRESULT ParmVExec_IPGetLocalAddress(HANDLE hLog);

// DirectPlay8Client tests
HRESULT ParmVClientExec_GetSendQInfo(HANDLE hLog);
HRESULT ParmVClientExec_SetClientInfo(HANDLE hLog);
HRESULT ParmVClientExec_GetServerInfo(HANDLE hLog);
HRESULT ParmVClientExec_GetServerAddress(HANDLE hLog);
HRESULT ParmVClientExec_GetConnInfo(HANDLE hLog);

// DirectPlay8Peer tests
HRESULT ParmVPeerExec_CreateQI(HANDLE hLog);
HRESULT ParmVPeerExec_Init(HANDLE hLog);
HRESULT ParmVPeerExec_EnumSPs(HANDLE hLog);
HRESULT ParmVPeerExec_Cancel(HANDLE hLog);
HRESULT ParmVPeerExec_Connect(HANDLE hLog);
HRESULT ParmVPeerExec_SendTo(HANDLE hLog);
HRESULT ParmVPeerExec_GetSendQInfo(HANDLE hLog);
HRESULT ParmVPeerExec_Host(HANDLE hLog);
HRESULT ParmVPeerExec_GetAppDesc(HANDLE hLog);
HRESULT ParmVPeerExec_SetAppDesc(HANDLE hLog);
HRESULT ParmVPeerExec_CreateGroup(HANDLE hLog);
HRESULT ParmVPeerExec_DestroyGroup(HANDLE hLog);
HRESULT ParmVPeerExec_AddToGroup(HANDLE hLog);
HRESULT ParmVPeerExec_RemoveFromGroup(HANDLE hLog);
HRESULT ParmVPeerExec_SetGroupInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetGroupInfo(HANDLE hLog);
HRESULT ParmVPeerExec_EnumPAndG(HANDLE hLog);
HRESULT ParmVPeerExec_EnumGroupMembers(HANDLE hLog);
HRESULT ParmVPeerExec_SetPeerInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetPeerInfo(HANDLE hLog);
HRESULT ParmVPeerExec_GetPeerAddress(HANDLE hLog);
HRESULT ParmVPeerExec_GetLHostAddresses(HANDLE hLog);
HRESULT ParmVPeerExec_Close(HANDLE hLog);
HRESULT ParmVPeerExec_EnumHosts(HANDLE hLog);
HRESULT ParmVPeerExec_DestroyPeer(HANDLE hLog);
HRESULT ParmVPeerExec_Return(HANDLE hLog);
HRESULT ParmVPeerExec_GetPlayerContext(HANDLE hLog);
HRESULT ParmVPeerExec_GetGroupContext(HANDLE hLog);
HRESULT ParmVPeerExec_GetCaps(HANDLE hLog);
HRESULT ParmVPeerExec_SetCaps(HANDLE hLog);
HRESULT ParmVPeerExec_SetSPCaps(HANDLE hLog);
HRESULT ParmVPeerExec_GetSPCaps(HANDLE hLog);
HRESULT ParmVPeerExec_GetConnInfo(HANDLE hLog);
HRESULT ParmVPeerExec_Terminate(HANDLE hLog);

// DirectPlay8Server tests
HRESULT ParmVServerExec_CreateQI(HANDLE hLog);
HRESULT ParmVServerExec_Init(HANDLE hLog);
HRESULT ParmVServerExec_EnumSPs(HANDLE hLog);
HRESULT ParmVServerExec_Cancel(HANDLE hLog);
HRESULT ParmVServerExec_GetSendQInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetAppDesc(HANDLE hLog);
HRESULT ParmVServerExec_SetServerInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetClientInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetClientAddress(HANDLE hLog);


HRESULT DirectPlayExec_SimpleConnect(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort);
HRESULT DirectPlayExec_SimpleHost(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort);
HRESULT DirectPlayExec_SimpleClient(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort);
HRESULT DirectPlayExec_SimpleServer(HANDLE hLog, PDP_HOSTINFO pHostInfo, WORD LowPort);

HRESULT GroupsExec_SimplePeer(HANDLE hLog, PDP_GROUPTESTPARAM pGroupTestParam);
HRESULT GroupsExec_SimpleCS(HANDLE hLog, PDP_GROUPTESTPARAM pGroupTestParam);
HRESULT SendsExec_SimplePeer(HANDLE hLog, PDP_SENDTESTPARAM pSendTestParam);
HRESULT SendsExec_SimpleCS(HANDLE hLog, PDP_SENDTESTPARAM pSendTestParam);
//HRESULT SendsExec_PendingPeer(HANDLE hLog, PDP_SENDTESTPARAM pSendTestParam);
//HRESULT SendsExec_PendingCS(HANDLE hLog, PDP_SENDTESTPARAM pSendTestParam);

//==================================================================================
// Helper classes 
//==================================================================================
class CTNSystemResult
{
	private:
		HRESULT		m_hr;


	public:
		CTNSystemResult(void):
		  m_hr(S_OK)
		{
		};

		CTNSystemResult(HRESULT hr):
		  m_hr(hr)
		{
		};

		~CTNSystemResult(void)
		{
		};


		inline void operator =(HRESULT hr)
		{
			this->m_hr = hr;
		};

		inline BOOL operator ==(HRESULT hr)
		{
			if (this->m_hr == hr)
				return (TRUE);
			return (FALSE);
		};

		inline BOOL operator !=(HRESULT hr)
		{
			if (this->m_hr != hr)
				return (TRUE);
			return (FALSE);
		};

		inline operator HRESULT(void)
		{
			return (this->m_hr);
		};
};

class CTNTestResult
{
	private:
		HRESULT		m_hr;


	public:
		CTNTestResult(void):
		  m_hr(S_OK)
		{
		};

		CTNTestResult(HRESULT hr):
		  m_hr(hr)
		{
		};

		~CTNTestResult(void)
		{
		};


		inline void operator =(HRESULT hr)
		{
			this->m_hr = hr;
		};

		inline BOOL operator ==(HRESULT hr)
		{
			if (this->m_hr == hr)
				return (TRUE);
			return (FALSE);
		};

		inline BOOL operator !=(HRESULT hr)
		{
			if (this->m_hr != hr)
				return (TRUE);
			return (FALSE);
		};

		inline operator HRESULT(void)
		{
			return (this->m_hr);
		};
};

} // namespace DPlayCoreNamespace

#endif // __DPTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\connex.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>

#include "..\..\..\tncommon\debugprint.h"
#include "..\..\..\tncommon\cppobjhelp.h"
#include "..\..\..\tncommon\linklist.h"
#include "..\..\..\tncommon\linkedstr.h"
#include "..\..\..\tncommon\strutils.h"
#include "..\..\..\tncommon\sprintf.h"

#include "..\..\..\tncontrl\tncontrl.h"


#include "..\main.h"

#include "..\bldssn\blddp8.h"

#include "connex.h"



//==================================================================================
// Defines
//==================================================================================
#define DATAPATTERN_CONNECT		0x0711F00D
#define DATAPATTERN_REPLY		0xB001B00F




//==================================================================================
// Structures
//==================================================================================

typedef struct tagHOSTADDRESSESSYNCDATA
{
	DWORD				dwNumAddresses; // number of addresses the host has in the following buffer
	
	// Anything after this is part of the host's addresses blob.
} HOSTADDRESSESSYNCDATA, * PHOSTADDRESSESSYNCDATA;

typedef struct tagHOSTADDRESSESCSANDPEERSYNCDATA
{
	DWORD				dwNumAddressesCS; // number of addresses for c/s session the host has in the following buffer
	DWORD				dwNumAddressesPeer; // number of addresses for peer session the host has in the following buffer
	
	// Anything after this is part of the host's addresses blobs.
} HOSTADDRESSESCSANDPEERSYNCDATA, * PHOSTADDRESSESCSANDPEERSYNCDATA;



typedef struct tagCONNEXLEAVEWHILEJOINCONTEXT:public BLDDP8DPNHANDLERCONTEXTHEADER
{
	// See blddp8.h BLDDP8DPNHANDLERCONTEXTHEADER for first members of structure

	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	DPNID*				padpnidTesters; // array of player IDs, in tester number order
	BOOL				fEnsureDisconnectBeforeJoin; // ensure the dropping player can't see joining player
	BOOL				fSelfIndicate; // set to TRUE if expecting our own player to connect/disconnect, FALSE if not
	int					iCurrentDroppingPlayer; // tester number of player who is dropping this iteration
	int					iCurrentJoiningPlayer; // tester number of player who is joining this iteration
	BOOL*				pafTesterIndicated; // pointer to array to use to remember whether an indication has already arrived for the tester
	PWRAPDP8PEER		pDP8Peer; // DPlay8 peer object in use
	HANDLE				hDroppedAndJoinedEvent; // event to set when players expected to connect/disconnect actually have
	HANDLE				hDestroyPlayerForRacingLeave; // event to set when dropping player who sneaked into nametable drops as expected
} CONNEXLEAVEWHILEJOINCONTEXT, * PCONNEXLEAVEWHILEJOINCONTEXT;

typedef struct tagCONNEXMANYHOSTCONTEXT
{
	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	DWORD				dwUserDataSize; // size of user connect data and reply data to use
	PVOID				pvReplyData; // pointer to reply data buffer to use
	BOOL				fReject; // whether to reject the attempts or not
	int					iNumConnectsRemaining; // how many connect attempts remaing
	HANDLE				hConnectsDoneEvent; // event to set when all connects are indicated (and their reply buffers are returned)
} CONNEXMANYHOSTCONTEXT, * PCONNEXMANYHOSTCONTEXT;

typedef struct tagCONNEXMANYCONNECTORCONTEXT
{
	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	HANDLE*				pahConnectCompleteEvents; // connect completion events
	DPNHANDLE*			padpnhConnects; // DPlay8 handles to connect calls
	DWORD				dwReplyDataSize; // size of expected reply data
	BOOL				fReject; // whether to reject the attempts or not
} CONNEXMANYCONNECTORCONTEXT, * PCONNEXMANYCONNECTORCONTEXT;

typedef struct tagCONNEXSERVERLOSSCONTEXT:public BLDDP8DPNHANDLERCONTEXTHEADER
{
	// See blddp8.h BLDDP8DPNHANDLERCONTEXTHEADER for first members of structure

	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	BOOL				fSelfIndicate; // whether the server expects to see the local player drop or not
	DPNID*				padpnidTesters; // array of player IDs, in tester number order
	BOOL*				pafTesterIndicated; // pointer to array to use to remember whether a DESTROY_PLAYER has already arrived for the tester
	HANDLE				hDisconnectEvent; // event to set when server disconnection is complete
} CONNEXSERVERLOSSCONTEXT, * PCONNEXSERVERLOSSCONTEXT;


typedef struct tagCONNEXREJECTCONTEXT
{
	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	PVOID				pvConnectData; // data to send with connection/reply
	DWORD				dwConnectDataSize; // size of data to send with connection/reply
	HANDLE				hConnectEvent; // event for player to set when connection is indicated/completes
	HANDLE				hReplyBufferReturnedEvent; // event for host player to set when reply buffer (if any) is returned
} CONNEXREJECTCONTEXT, * PCONNEXREJECTCONTEXT;


typedef struct tagCONNEXNOTALLOWEDCONTEXT
{
	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	HRESULT				hrExpectedResult; // expected result code for connect attempt
	HANDLE				hConnectCompletedEvent; // event for player to set when connection attempt completes
	BOOL				fConnectsAllowed; // whether connects are allowed or not
} CONNEXNOTALLOWEDCONTEXT, * PCONNEXNOTALLOWEDCONTEXT;





//==================================================================================
// Prototypes
//==================================================================================
HRESULT ConnexCanRun_NonServerLoss(PTNCANRUNDATA pTNcrd);

HRESULT ConnexGet_LeaveWhileJoinAll(PTNGETINPUTDATA pTNgid);
HRESULT ConnexWrite_LeaveWhileJoinAll(PTNWRITEDATA pTNwd);
HRESULT ConnexExec_LeaveWhileJoinPeer(PTNEXECCASEDATA pTNecd);
HRESULT ConnexExec_LeaveWhileJoinCS(PTNEXECCASEDATA pTNecd);

HRESULT ConnexGet_ManyAll(PTNGETINPUTDATA pTNgid);
HRESULT ConnexWrite_ManyAll(PTNWRITEDATA pTNwd);
HRESULT ConnexExec_ManyAll(PTNEXECCASEDATA pTNecd);

HRESULT ConnexCanRun_ServerLoss(PTNCANRUNDATA pTNcrd);
HRESULT ConnexExec_ServerLoss(PTNEXECCASEDATA pTNecd);

HRESULT ConnexExec_Reject(PTNEXECCASEDATA pTNecd);

HRESULT ConnexExec_NotAllowed(PTNEXECCASEDATA pTNecd);



HRESULT ConnexLeaveWhileJoinPeerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ConnexLeaveWhileJoinServerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ConnexLeaveWhileJoinClientDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ConnexManyHostDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ConnexManyConnectorDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ConnexServerLossServerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ConnexServerLossClientDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ConnexRejectDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

HRESULT ConnexNotAllowedDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexLoadTestTable()"
//==================================================================================
// ConnexLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.7			Connection/disconnection tests
//				2.7.1		Leave while joining tests
//				2.7.1.1		Simple normal leave while joining peer test
//				2.7.1.2		Simple normal leave while joining peer test
//				2.7.1.3		Round robin normal leave while joining client/server test
//				2.7.1.4		Round robin normal leave while joining client/server test
//				2.7.2		Drop while joining tests
//				2.7.2.1		Simple drop while joining peer test
//				2.7.2.2		Simple drop while joining peer test
//				2.7.2.3		Round robin drop while joining client/server test
//				2.7.2.4		Round robin drop while joining client/server test
//				2.7.3		Many connect attempts tests
//				2.7.3.1		Many peer connect attempts test
//				2.7.3.2		Many client/server connect attempts test
//				2.7.4		Server loss tests
//				2.7.4.1		Server leave test
//				2.7.4.2		Server drop test
//				2.7.5		Simple reject connection tests
//				2.7.5.1		Simple peer reject connections test
//				2.7.5.2		Simple client/server reject connections test
//				2.7.6		Not allowed connection tests
//				2.7.6.1		All not-allowed connection types test
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	PTNTESTTABLEGROUP	pSubSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7		Connection/disconnection tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase, "2.7", "Connection/disconnection tests", &pSubGroup);




	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.1	Leave while joining tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.1", "Leave while joining tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.1.1	Simple normal leave while joining peer test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.1.1";
	tnatd.pszName			= "Simple normal leave while joining peer test";
	tnatd.pszDescription	= "Simple normal leave while joining peer test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinPeer;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.1.2	Simple normal leave while joining client/server test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.1.2";
	tnatd.pszName			= "Simple normal leave while joining client/server test";
	tnatd.pszDescription	= "Simple normal leave while joining client/server test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinCS;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.1.3	Round robin normal leave while joining peer test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.1.3";
	tnatd.pszName			= "Round robin normal leave while joining peer test";
	tnatd.pszDescription	= "Round robin normal leave while joining peer test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to join and leave";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_LeaveWhileJoinAll;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinPeer;
	tnatd.pfnWriteData		= ConnexWrite_LeaveWhileJoinAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.1.4	Round robin normal leave while joining client/server test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.1.4";
	tnatd.pszName			= "Round robin normal leave while joining client/server test";
	tnatd.pszDescription	= "Round robin normal leave while joining client/server test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to join and leave";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_LeaveWhileJoinAll;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinCS;
	tnatd.pfnWriteData		= ConnexWrite_LeaveWhileJoinAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.2	Drop while joining tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.2", "Drop while joining tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.2.1	Simple drop while joining peer test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.2.1";
	tnatd.pszName			= "Simple drop while joining peer test";
	tnatd.pszDescription	= "Simple drop while joining peer test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinPeer;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.2.2	Simple drop while joining client/server test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.2.2";
	tnatd.pszName			= "Simple drop while joining client/server test";
	tnatd.pszDescription	= "Simple drop while joining client/server test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinCS;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.2.3	Round robin drop while joining peer test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.2.3";
	tnatd.pszName			= "Round robin drop while joining peer test";
	tnatd.pszDescription	= "Round robin drop while joining peer test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to join and drop";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_LeaveWhileJoinAll;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinPeer;
	tnatd.pfnWriteData		= ConnexWrite_LeaveWhileJoinAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.2.4	Round robin drop while joining client/server test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.2.4";
	tnatd.pszName			= "Round robin drop while joining client/server test";
	tnatd.pszDescription	= "Round robin drop while joining client/server test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to join and drop";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_LeaveWhileJoinAll;
	tnatd.pfnExecCase		= ConnexExec_LeaveWhileJoinCS;
	tnatd.pfnWriteData		= ConnexWrite_LeaveWhileJoinAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.3	Many connect attempts tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.3", "Many connect attempts tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.3.1	Many peer connect attempts test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.3.1";
	tnatd.pszName			= "Many peer connect attempts test";
	tnatd.pszDescription	= "Testers try multiple times (optionally using multiple objects) to connect to the host.";
	tnatd.pszInputDataHelp	= "NumIterations = How many times slaves try to connect\n"
								"NumObjects = Number of individual interfaces each client uses (connects may overlap if > 1)\n"
								"Overlap = TRUE if connect attempts can overlap, FALSE if attempts are sequential\n"
								"UserDataSize = Size of user connect data and reply data\n"
								"Reject = TRUE to have reject connections, FALSE for to accept them";

	tnatd.iNumMachines		= -2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_ManyAll;
	tnatd.pfnExecCase		= ConnexExec_ManyAll;
	tnatd.pfnWriteData		= ConnexWrite_ManyAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.3.2	Many client/server connect attempts test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.3.2";
	tnatd.pszName			= "Many client/server connect attempts test";
	tnatd.pszDescription	= "Testers try multiple times (optionally using multiple objects) to connect to the host.";
	tnatd.pszInputDataHelp	= "NumIterations = How many times slaves try to connect\n"
								"NumObjects = Number of individual interfaces each client uses (connects may overlap if > 1)\n"
								"Overlap = TRUE if connect attempts can overlap, FALSE if attempts are sequential\n"
								"UserDataSize = Size of user connect data and reply data\n"
								"Reject = TRUE to have reject connections, FALSE for to accept them";

	tnatd.iNumMachines		= -2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= ConnexGet_ManyAll;
	tnatd.pfnExecCase		= ConnexExec_ManyAll;
	tnatd.pfnWriteData		= ConnexWrite_ManyAll;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.4	Server loss tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.4", "Server loss tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.4.1	Server leave test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.4.1";
	tnatd.pszName			= "Server leave test";
	tnatd.pszDescription	= "Server leave test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= -2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_ServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_ServerLoss;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.4.2	Server drop test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.4.2";
	tnatd.pszName			= "Server drop test";
	tnatd.pszDescription	= "Server drop test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= -2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_ServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_ServerLoss;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.5	Simple reject connection tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.5", "Simple reject connection tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.5.1	Simple peer reject connections test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.5.1";
	tnatd.pszName			= "Simple peer reject connections test";
	tnatd.pszDescription	= "Simple peer reject connections test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_Reject;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.5.2	Simple client/server reject connections test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.5.2";
	tnatd.pszName			= "Simple client/server reject connections test";
	tnatd.pszDescription	= "Simple client/server reject connections test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_Reject;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.6	Not allowed connection tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.7.6", "Not allowed connection tests", &pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.7.6.1	All not-allowed connection types test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.7.6.1";
	tnatd.pszName			= "All not-allowed connection types test";
	tnatd.pszDescription	= "All not-allowed connection types test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= ConnexCanRun_NonServerLoss;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ConnexExec_NotAllowed;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	return (S_OK);
} // ConnexLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexCanRun_NonServerLoss()"
//==================================================================================
// ConnexCanRun_NonServerLoss
//----------------------------------------------------------------------------------
//
// Description: Callback that checks a possible tester list to make sure the test
//				can be run correctly for the following test case(s):
//				2.7.1.1 - Simple normal leave while joining peer test
//				2.7.1.2 - Simple normal leave while joining client/server test
//				2.7.1.3 - Round robin normal leave while joining peer test
//				2.7.1.4 - Round robin normal leave while joining client/server test
//				2.7.2.1 - Simple drop while joining peer test
//				2.7.2.2 - Simple drop while joining client/server test
//				2.7.2.3 - Round robin drop while joining peer test
//				2.7.2.4 - Round robin drop while joining client/server test
//				2.7.3.1 - Many peer connect attempts test
//				2.7.5.1 - Simple peer reject connections test
//				2.7.5.2 - Simple client/server reject connections test
//				2.7.6.1 - All not-allowed connection types test
//
// Arguments:
//	PTNCANRUNDATA pTNcrd	Pointer to parameter block with information on what
//							configuration to check.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexCanRun_NonServerLoss(PTNCANRUNDATA pTNcrd)
{
	HRESULT		hr;
	int			i;


	// Make sure all subsequent testers can connect to the first.
	for(i = 1; i < pTNcrd->iNumMachines; i++)
	{
		// Only the second tester needs to have IMTest installed in the simple (i.e
		// only 1 time) drop test cases.  All non-host testers need it in the round
		// robin drop cases.
		if (((strcmp(pTNcrd->pTest->m_pszID, "2.7.2.1") == 0) && (i == 1)) ||
			((strcmp(pTNcrd->pTest->m_pszID, "2.7.2.2") == 0) && (i == 1)) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.7.2.3") == 0) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.7.2.4") == 0))
		{
			pTNcrd->fCanRun = pTNcrd->apTesters[i]->m_fFaultSimIMTestAvailable;

			if (! pTNcrd->fCanRun)
			{
				DPL(1, "Tester %i (%s) doesn't have IMTest fault simulator available.",
					2, i, pTNcrd->apTesters[i]->m_szComputerName);

				return (S_OK);
			} // end if (tester doesn't have IMTest)
		} // end if (drop test)


		if (pTNcrd->pMaster->AreOnSameMachine(pTNcrd->apTesters[i],
											pTNcrd->apTesters[0]))
		{
			DPL(1, "Tester 1 is on same machine as tester 0 (%s), assuming can reach via UDP.",
				1, pTNcrd->apTesters[0]->m_szComputerName);

			pTNcrd->fCanRun = TRUE;
		} // end if (are on same machine)
		else
		{
			hr = pTNcrd->pMaster->CanReachViaIP(pTNcrd->apTesters[i],
												pTNcrd->apTesters[0],
												DPLAY8_PORT,
												TNCR_IP_UDP,
												&(pTNcrd->fCanRun));
			if (hr != S_OK)
			{
				DPL(0, "Couldn't have tester %i (%s) try to reach tester 0 (%s) via UDP!",
					3, i, pTNcrd->apTesters[i]->m_szComputerName,
					pTNcrd->apTesters[0]->m_szComputerName);

				return (hr);
			} // end if (couldn't test reachability)

			if (! pTNcrd->fCanRun)
			{
				DPL(1, "Tester %i (%s) can't reach tester 0 (%s) via UDP.",
					3, i, pTNcrd->apTesters[i]->m_szComputerName,
					pTNcrd->apTesters[0]->m_szComputerName);

				return (S_OK);
			} // end if (tester couldn't reach tester 0)
		} // end else (not on same machine)
	} // end for (each tester after 0)

	return (S_OK);
} // ConnexCanRun_NonServerLoss
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexGet_LeaveWhileJoinAll()"
//==================================================================================
// ConnexGet_LeaveWhileJoinAll
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				2.7.1.1 - Simple normal leave while joining peer test
//				2.7.1.2 - Simple normal leave while joining client/server test
//				2.7.1.3 - Round robin normal leave while joining peer test
//				2.7.1.4 - Round robin normal leave while joining client/server test
//				2.7.2.1 - Simple drop while joining peer test
//				2.7.2.2 - Simple drop while joining client/server test
//				2.7.2.3 - Round robin drop while joining peer test
//				2.7.2.4 - Round robin drop while joining client/server test
//
// Arguments:
//	PTNGETINPUTDATA pTNgid	Pointer to parameter block with information on how and
//							where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexGet_LeaveWhileJoinAll(PTNGETINPUTDATA pTNgid)
{
	PTID_PCONNEX_LEAVEWHILEJOIN		pParams = (PTID_PCONNEX_LEAVEWHILEJOIN) pTNgid->pvData;
	PLSTRINGLIST					pStrings = NULL;
	char*							pszTemp;



	pTNgid->dwDataSize = sizeof (TID_PCONNEX_LEAVEWHILEJOIN);

	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	// Start with default values
	pParams->iNumIterations = 5;
    

	// Get any input data strings that might exist.
	GETANYINPUTSTRINGS(pTNgid, pStrings);


	// Okay, so if we found strings, check if any of the options are specified.
	// If they are, override the default with the items' value.
	if (pStrings != NULL)
	{
		pszTemp = pStrings->GetValueOfKey("NumIterations");
		if (pszTemp != NULL)
			pParams->iNumIterations = StringToInt(pszTemp);
	} // end if (we found some items)


	return (S_OK);
} // ConnexGet_LeaveWhileJoinAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexWrite_LeaveWhileJoinAll()"
//==================================================================================
// ConnexWrite_LeaveWhileJoinAll
//----------------------------------------------------------------------------------
//
// Description: Callback that converts a buffer to strings for the test case(s):
//				2.7.1.1 - Simple normal leave while joining peer test
//				2.7.1.2 - Simple normal leave while joining client/server test
//				2.7.1.3 - Round robin normal leave while joining peer test
//				2.7.1.4 - Round robin normal leave while joining client/server test
//				2.7.2.1 - Simple drop while joining peer test
//				2.7.2.2 - Simple drop while joining client/server test
//				2.7.2.3 - Round robin drop while joining peer test
//				2.7.2.4 - Round robin drop while joining client/server test
//
// Arguments:
//	PTNWRITEDATA pTNwd	Parameter block with information and data to write.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexWrite_LeaveWhileJoinAll(PTNWRITEDATA pTNwd)
{
	PTID_PCONNEX_LEAVEWHILEJOIN		pInputData = (PTID_PCONNEX_LEAVEWHILEJOIN) pTNwd->pvData;

	
	switch (pTNwd->dwLocation)
	{
		case TNTSDL_REPORTASSIGN:
			REQUIRE_ASSIGNREPORT_DATA(sizeof (TID_PCONNEX_LEAVEWHILEJOIN));


			WRITESPRINTFDATALINE("NumIterations= %i", 1, pInputData->iNumIterations);
		  break;

		default:
			DPL(0, "Got data for unexpected location %u!",
				1, pTNwd->dwLocation);
			return (ERROR_INVALID_PARAMETER);
		  break;
	} // end switch (on the source of the data buffer)

	
	return (S_OK);
} // ConnexWrite_LeaveWhileJoinAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_LeaveWhileJoinPeer()"
//==================================================================================
// ConnexExec_LeaveWhileJoinPeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.1.1 - Simple normal leave while joining peer test
//				2.7.1.3 - Round robin normal leave while joining peer test
//				2.7.2.1 - Simple drop while joining peer test
//				2.7.2.3 - Round robin drop while joining peer test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_LeaveWhileJoinPeer(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTID_PCONNEX_LEAVEWHILEJOIN		pInput = (PTID_PCONNEX_LEAVEWHILEJOIN) pTNecd->pvInputData;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	DWORD							dwSubInputDataSize;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PTOD_BBLDDP8_PEER_CREATE		pBldDP8PeerCreateOutput = NULL;
	DWORD							dwSubOutputDataSize;
	CONNEXLEAVEWHILEJOINCONTEXT		context;
	DPN_APPLICATION_DESC			dpnad;
	PDIRECTPLAY8ADDRESS				pDP8AddressRemote = NULL;
	PDIRECTPLAY8ADDRESS				pDP8AddressLocal = NULL;
	PTNFAULTSIM						pFaultSim = NULL;
	HANDLE							hConnectCompleteEvent = NULL;
	DPNHANDLE						dpnhConnect;
	CTNSyncDataList					syncdata;
	PVOID							pvSyncData;
	int*							paiDestroyTesters = NULL;
	DPNID*							padpnidDestroyTesters = NULL;
	int								iNumIterations;
	int								iCurrentIteration;
	int								i;
	int								j;
#ifdef DEBUG
	char*							pszURL = NULL;
	DWORD							dwURLBufferSize = 0;
	DWORD							dwURLSize;
#endif // DEBUG



	ZeroMemory(&context, sizeof (CONNEXLEAVEWHILEJOINCONTEXT));
	context.pTNecd = pTNecd;


	BEGIN_TESTCASE
	{
		if ((pTNecd->pExecutor->IsCase("2.7.1.1")) || (pTNecd->pExecutor->IsCase("2.7.2.1")))
		{
			iNumIterations = 1;
		} // end if (simple case)
		else
		{
			REQUIRE_INPUT_DATA(sizeof (TID_PCONNEX_LEAVEWHILEJOIN));

			iNumIterations = pInput->iNumIterations;
		} // end else (round robin case)

		DPL(1, "Will perform %i iterations.", 1, iNumIterations);



		// Allocate an array for all testers' player IDs.  The position of a tester
		// is always the same, regardless of the iteration.
		// We allocate this array even though build session will give us one
		// because we need to modify it, and we can't modify someone else's buffer.

		LOCALALLOC_OR_THROW(DPNID*, context.padpnidTesters,
							(pTNecd->iNumMachines * sizeof (DPNID)));

		// Allocate an array for add player/delete player indications.  The position
		// of a tester is always the same, regardless of the iteration.

		LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
							(pTNecd->iNumMachines * sizeof (BOOL)));



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating peer-to-peer session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.pfnDPNMessageHandler = ConnexLeaveWhileJoinPeerDPNMessageHandler;
		context.pTNecd = pTNecd;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_MIGRATE_HOST | DPNSESSION_NODPNSVR;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_CONNEX_LEAVEWHILEJOIN_PEER;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;



		dwSubInputDataSize = sizeof (TID_BBLDDP8_ALL_CREATE);
							//+ (pTNecd->iNumMachines * sizeof (int));

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		/*
		for(i = 0; i < pTNecd->iNumMachines; i++)
		{
			*((PVOID*) (((PBYTE) pvSubInputData) + sizeof (TID_BBLDDP8_ALL_CREATE) + (i * sizeof (int*)))) = &(context.paiReliableMsgsReceivedFromTesters[i]);
		} // end for (each tester)
		*/


		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.1.1", pvSubInputData,
												dwSubInputDataSize, 0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPL(0, "Couldn't execute sub test case BldSsn:BldPeer:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.1",
									"Creating peer-to-peer session failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pBldDP8PeerCreateOutput,
									dwSubOutputDataSize,
									(sizeof (TOD_BBLDDP8_PEER_CREATE) + (pTNecd->iNumMachines * sizeof (DPNID))));

		pDP8Peer = pBldDP8PeerCreateOutput->pDP8Peer;
		pDP8Peer->m_dwRefCount++; // we're using it during this function

		CopyMemory(context.padpnidTesters, (pBldDP8PeerCreateOutput + 1),
					(pTNecd->iNumMachines * sizeof (DPNID)));


		// Everybody who might be rejoining the session at some point needs to
		// retrieve the address of the host so they can rejoin easily.
		TESTSECTION_IF(pTNecd->iTesterNum != 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting host's session address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->DP8P_GetPeerAddress(context.padpnidTesters[0],
											&pDP8AddressRemote,
											0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get host's address!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get peer address)


#ifdef DEBUG
			do
			{
				dwURLSize = dwURLBufferSize;

				tr = pDP8AddressRemote->GetURLA(pszURL, &dwURLSize);
				if (tr == DPNERR_BUFFERTOOSMALL)
				{
					SAFE_LOCALFREE(pszURL);
					LOCALALLOC_OR_THROW(char*, pszURL, dwURLSize);
					dwURLBufferSize = dwURLSize;
				} // end if (buffer too small)
				else if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get next host address's URL!", 0);
					THROW_TESTRESULT;
				} // end if (didn't get URL)
			} // end do (while buffer too small)
			while (tr == DPNERR_BUFFERTOOSMALL);

			DPL(1, "Will use address (\"%s\") to reconnect.", 1, pszURL);
#endif // DEBUG
		} // end if (not host)
		TESTSECTION_ENDIF



		// If we're the tester who's supposed to join first, we need to drop out of
		// the session we built (we only joined the first time so we could get the
		// host's address.

		context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (context.hDroppedAndJoinedEvent == NULL)
		{
			sr = GetLastError();
			DPL(0, "Couldn't create dropped and joined event!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't create event)


		context.iCurrentDroppingPlayer = pTNecd->iNumMachines - 1;
		context.iCurrentJoiningPlayer = -1;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for all testers to be ready for tester to temporarily leave");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Ready for temp leave", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		TESTSECTION_IF(pTNecd->iTesterNum == (pTNecd->iNumMachines - 1))
		{
			// We expect our own player to be removed.
			context.fSelfIndicate = TRUE;


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Leaving session temporarily");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->DP8P_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't close interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)



			// Make sure everyone got removed from nametable.
			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				if (! context.pafTesterIndicated[i])
				{
					DPL(0, "Nametable didn't unwind during Close(), tester %i (player ID %u/%x) hasn't been removed!",
						3, i, context.padpnidTesters[i], context.padpnidTesters[i]);
					SETTHROW_TESTRESULT(ERROR_IO_INCOMPLETE);
				} // end if (tester hasn't been removed)
			} // end for (each tester)


			context.fSelfIndicate = FALSE;



#pragma TODO(vanceo, "Make release optional")

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release)
		} // end if (first joiner)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for player to temporarily drop");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDroppedAndJoinedEvent),
														1,
														NULL,
														-1,
														INFINITE,
														NULL);
			HANDLE_WAIT_RESULT;
		} // end else (not first joiner)
		TESTSECTION_ENDIF


		// Forget the dropping player's ID
		context.padpnidTesters[pTNecd->iNumMachines - 1] = 0;

		CloseHandle(context.hDroppedAndJoinedEvent);
		context.hDroppedAndJoinedEvent = NULL;



		
		// Start at the very beginning...
		iCurrentIteration = 0;
		TESTSECTION_DO
		{
			// Remember who's dropping and who's joining.
			context.iCurrentDroppingPlayer = (iCurrentIteration % (pTNecd->iNumMachines - 1)) + 1;
			context.iCurrentJoiningPlayer = context.iCurrentDroppingPlayer + (pTNecd->iNumMachines - 2);
			if (context.iCurrentJoiningPlayer >= pTNecd->iNumMachines)
				context.iCurrentJoiningPlayer = (context.iCurrentJoiningPlayer - pTNecd->iNumMachines) + 1;
			
			// Note that tester 0 should never be a dropping or joining player.


			DPL(1, "Iteration %i: dropping player = %i, joining player = %i, (we're tester %i so normal = %B)",
				5, iCurrentIteration, context.iCurrentDroppingPlayer,
				context.iCurrentJoiningPlayer, pTNecd->iTesterNum,
				(((pTNecd->iTesterNum == context.iCurrentDroppingPlayer) || (pTNecd->iTesterNum == context.iCurrentJoiningPlayer)) ? FALSE : TRUE));

			// Ignore error
			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Starting iteration #%i",
									1, (iCurrentIteration + 1));


			TESTSECTION_IF(pTNecd->iTesterNum == context.iCurrentDroppingPlayer)
			{
				// Get ready for DESTROY_PLAYER indications for everyone.
				ZeroMemory(context.pafTesterIndicated,
							(pTNecd->iNumMachines * sizeof (BOOL)));

				// NOTE: If we're not ensuring that the joining player can never
				// send any traffic to us, then we race with him to leave the
				// session before he joins it.  It's therefore possible to get the
				// CREATE_PLAYER for him.  If we do, however, we need to get a
				// DESTROY_PLAYER for him when he finally does leave the session.
				// Mark him as indicated now, so that if the CREATE_PLAYER doesn't
				// arrive, we're not waiting forever for the DESTROY_PLAYER that
				// will never show up.  But if the CREATE_PLAYER does come in, then
				// we do need to wait for the DESTROY_PLAYER.  That means, we force
				// CREATE_PLAYER to have the opposite behavior of marking this guy
				// as _not_ indicated when the indication comes in.  That way the
				// matching DESTROY_PLAYER resets it to the way we want.  Certainly
				// not foolproof, but it should catch any realistically possible bug
				// in DPlay.
				context.pafTesterIndicated[context.iCurrentJoiningPlayer] = TRUE;


				context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (context.hDroppedAndJoinedEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create dropped and joined event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with rejoining player and those still in session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														0);
				HANDLE_SYNC_RESULT;



				TESTSECTION_IF((pTNecd->pExecutor->IsCase("2.7.2.1")) || (pTNecd->pExecutor->IsCase("2.7.2.3")))
				{
					// We do NOT expect our local player to be removed.
					context.fSelfIndicate = FALSE;



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Creating IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
															TN_FAULTSIM_IMTEST,
															NULL,
															0);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't create IMTest fault simulator!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't create fault simulator)




					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Disconnecting sends and received, will drop from session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)



#pragma TODO(vanceo, "Timeout (be able to set protocol caps: keepalives?)")
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for connections to all other players to drop");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hDroppedAndJoinedEvent,
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;





					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Restoring send and receive traffic");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Releasing IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't release fault simulator %x!", 1, pFaultSim);
						THROW_SYSTEMRESULT;
					} // end if (couldn't release fault simulator)
				} // end if (drop host migration case)
				TESTSECTION_ENDIF



				// We expect our own player to be removed.
				context.fSelfIndicate = TRUE;


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Disconnecting from session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_Close(0);
				if (tr != DPN_OK)
				{
					DPL(0, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)



				// Clear this, to be paranoid.
				context.pDP8Peer = NULL;



				TESTSECTION_IF((pTNecd->pExecutor->IsCase("2.7.2.1")) || (pTNecd->pExecutor->IsCase("2.7.2.3")))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Ensuring local host player has been removed");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				} // end if (drop case)
				TESTSECTION_ELSE
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Ensuring all players have been removed");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				} // end else (normal leave case)
				TESTSECTION_ENDIF


				for(i = 0; i < pTNecd->iNumMachines; i++)
				{
					if (! context.pafTesterIndicated[i])
					{
						DPL(0, "Nametable didn't unwind during Close(), tester %i (player ID %u/%x) hasn't been removed (current joining tester = %i)!",
							4, i, context.padpnidTesters[i], context.padpnidTesters[i],
							context.iCurrentJoiningPlayer);
						SETTHROW_TESTRESULT(ERROR_IO_INCOMPLETE);
					} // end if (tester hasn't been removed)
				} // end for (each tester)



#pragma TODO(vanceo, "Make release optional")

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Peer object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release)




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Retrieving player ID for rejoiner");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct rejoiner player ID",
														NULL, 0,
														&syncdata,
														0);
				HANDLE_SYNC_RESULT;

				CHECKANDGET_SYNCDATA(syncdata, context.iCurrentJoiningPlayer,
									pvSyncData, dwSubOutputDataSize, sizeof (DPNID));


				// Store the player ID.
				context.padpnidTesters[context.iCurrentJoiningPlayer] = *((DPNID*) pvSyncData);
			} // end if (we're the dropping player)
			TESTSECTION_ELSEIF(pTNecd->iTesterNum == context.iCurrentJoiningPlayer)
			{
#pragma TODO(vanceo, "Make release optional")

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Recreating DirectPlay8Peer object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->CoCreate();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't CoCreate DirectPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't CoCreate)

				context.pDP8Peer = pDP8Peer; // update context pointer for this, too




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Initializing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				// We have to use the bldssn message handler because we use the
				// destroy session helper later, and that requires the appropriate
				// message handler.
				tr = pDP8Peer->DP8P_Initialize(&context,
												BldDP8PeerDPNMessageHandler,
												0);
				if (tr != S_OK)
				{
					DPL(0, "Couldn't initialize peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't initialize)



				hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (hConnectCompleteEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create connect completion event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)

				context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (context.hDroppedAndJoinedEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create dropped and joined event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)

				// Create an event for the DESTROY_PLAYER race in case it happens,
				// see notes below.
				context.hDestroyPlayerForRacingLeave = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (context.hDestroyPlayerForRacingLeave == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create destroy player for racing leave event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("CoCreating local address object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL,
									CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address,
									(LPVOID*) &pDP8AddressLocal);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't CoCreate address object!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't CoCreate object)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Setting local address' SP");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't set local address' SP!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't set SP)



				// Get ready for everyone to reconnect.
				ZeroMemory(context.pafTesterIndicated,
							(pTNecd->iNumMachines * sizeof (BOOL)));


				// We're going to join, so we expect our player to appear.
				context.fSelfIndicate = TRUE;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with dropping player and those still in session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														0);
				HANDLE_SYNC_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Reconnecting to session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_Connect(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											hConnectCompleteEvent,
											&dpnhConnect,
											0);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPL(0, "Connect didn't return expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (connect not pending)


				// We don't need the local address anymore.
				pDP8AddressLocal->Release();
				pDP8AddressLocal = NULL;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for all players in session to connect");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDroppedAndJoinedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(context.hDroppedAndJoinedEvent);
				context.hDroppedAndJoinedEvent = NULL;


				context.fSelfIndicate = FALSE;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for connect completion notification");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&hConnectCompleteEvent,
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(hConnectCompleteEvent);
				hConnectCompleteEvent = NULL;



				// NOTE: If we're not ensuring that the dropping player can never
				// see any traffic from us, then we race with him to join the
				// session before he leaves it.  It's therefore possible to get the
				// CREATE_PLAYER for him.  If we do, however, we need to get a
				// DESTROY_PLAYER for him when he finally does leave the session.
				// Wait for it to come in if that's the case.
				if (context.pafTesterIndicated[context.iCurrentDroppingPlayer])
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Dropping player made it into the name table, waiting for DESTROY_PLAYER");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDestroyPlayerForRacingLeave),
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;
				} // end if (dropping player made it in)

				CloseHandle(context.hDestroyPlayerForRacingLeave);
				context.hDestroyPlayerForRacingLeave = NULL;




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Ensure everyone has our player ID correct");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct rejoiner player ID",
														&(context.padpnidTesters[pTNecd->iTesterNum]),
														sizeof (DPNID),
														NULL,
														0);
				HANDLE_SYNC_RESULT;
			} // end else if (we're the joining player)
			TESTSECTION_ELSE
			{
				context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (context.hDroppedAndJoinedEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create rejoin event event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)


				// Get ready for players to drop and join.
				context.pafTesterIndicated[context.iCurrentDroppingPlayer] = FALSE;
				context.pafTesterIndicated[context.iCurrentJoiningPlayer] = FALSE;
				context.padpnidTesters[context.iCurrentJoiningPlayer] = 0;


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with leaving and joining players");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														0);
				HANDLE_SYNC_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for players to drop and rejoin as appropriate");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDroppedAndJoinedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(context.hDroppedAndJoinedEvent);
				context.hDroppedAndJoinedEvent = NULL;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Making sure new player ID for rejoiner is correct");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct rejoiner player ID",
														NULL, 0,
														&syncdata,
														0);
				HANDLE_SYNC_RESULT;

				CHECKANDGET_SYNCDATA(syncdata, context.iCurrentJoiningPlayer,
									pvSyncData, dwSubOutputDataSize, sizeof (DPNID));

				// Make sure he got the same ID we saw him get.
				if (context.padpnidTesters[context.iCurrentJoiningPlayer] != *((DPNID*) pvSyncData))
				{
					DPL(0, "The original host (tester %i) rejoining player ID %u/%x we received differs from the ID he claims he got (%u/%x)!",
						5, context.iCurrentJoiningPlayer,
						context.padpnidTesters[context.iCurrentJoiningPlayer],
						context.padpnidTesters[context.iCurrentJoiningPlayer],
						*((DPNID*) pvSyncData),
						*((DPNID*) pvSyncData));
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (IDs don't match)
			} // end else (we're a normal player)
			TESTSECTION_ENDIF




			iCurrentIteration++;

			// If there aren't any more iterations, we can skip the rejoin phase.
			TESTSECTION_IF(iCurrentIteration >= iNumIterations)
			{
				DPL(1, "Final iteration completed.", 0);
				TESTSECTION_BREAK;
			} // end if (last iteration)
			TESTSECTION_ENDIF
		} // end do (while still more iterations to go)
		TESTSECTION_DOWHILE(TRUE);



		// Cleanup people still in session after last iteration.
		TESTSECTION_IF(pTNecd->iTesterNum == context.iCurrentDroppingPlayer)
		{
			sr = g_pDP8PeersList->RemoveFirstReference(pDP8Peer);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't remove DirectPlay8Peer wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)

			pDP8Peer->m_dwRefCount--;
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPL(0, "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
					2, pDP8Peer, pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;
		} // end if (current dropping tester)
		TESTSECTION_ELSE
		{
			paiDestroyTesters = NULL;
			padpnidDestroyTesters = NULL;

			LOCALALLOC_OR_THROW(int*, paiDestroyTesters,
								((pTNecd->iNumMachines - 1) * sizeof (int)));

			LOCALALLOC_OR_THROW(DPNID*, padpnidDestroyTesters,
								((pTNecd->iNumMachines - 1) * sizeof (DPNID)));

			// Clear this, to be paranoid.
			context.pDP8Peer = NULL;


			// Build arrays of tester numbers and player IDs that exclude the
			// missing player.
			j = 0;
			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				// Skip the player not in the session.
				if (i == context.iCurrentDroppingPlayer)
					continue;

				paiDestroyTesters[j] = i;
				padpnidDestroyTesters[j] = context.padpnidTesters[i];

				j++;
			} // end for (each tester)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_PEER_DESTROY));
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pDP8Peer = pDP8Peer;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->padpnidTesters = padpnidDestroyTesters;

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.1.2", pvSubInputData,
														sizeof (TID_BBLDDP8_PEER_DESTROY),
														(pTNecd->iNumMachines - 1),
														paiDestroyTesters);
			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			LocalFree(padpnidDestroyTesters);
			padpnidDestroyTesters = NULL;

			LocalFree(paiDestroyTesters);
			paiDestroyTesters = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:BldPeer:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.2",
										"Destroying peer-to-peer session failed!");


			pDP8Peer->m_dwRefCount--;
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPL(0, "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
					2, pDP8Peer, pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;
		} // end else (not current dropping tester)
		TESTSECTION_ENDIF




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Making sure everyone survived final iteration");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pFaultSim != NULL)
	{
		temphr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
		if (temphr != S_OK)
		{
			DPL(0, "Couldn't release fault sim %x!  0x%08x", 2, pFaultSim, temphr);
			
			OVERWRITE_SR_IF_OK(temphr);

			pFaultSim = NULL;
		} // end if (couldn't remove handler)
	} // end if (have fault sim)

	SAFE_LOCALFREE(pszURL);
	SAFE_LOCALFREE(pvSubInputData);
	SAFE_CLOSEHANDLE(hConnectCompleteEvent);
	SAFE_CLOSEHANDLE(context.hDroppedAndJoinedEvent);
	SAFE_CLOSEHANDLE(context.hDroppedAndJoinedEvent);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_LOCALFREE(context.pafTesterIndicated);
	SAFE_LOCALFREE(context.padpnidTesters);

	if (pDP8Peer != NULL)
	{
		temphr = pDP8Peer->DP8P_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing peer interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing peer interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8PeersList->RemoveFirstReference(pDP8Peer);


		pDP8Peer->m_dwRefCount--;
		if (pDP8Peer->m_dwRefCount == 0)
		{
			DPL(7, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
			delete (pDP8Peer);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
				2, pDP8Peer, pDP8Peer->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Peer = NULL;
	} // end if (have peer object)

	return (sr);
} // ConnexExec_LeaveWhileJoinPeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_LeaveWhileJoinCS()"
//==================================================================================
// ConnexExec_LeaveWhileJoinCS
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.1.2 - Simple normal leave while joining client/server test
//				2.7.1.4 - Round robin normal leave while joining client/server test
//				2.7.2.2 - Simple drop while joining client/server test
//				2.7.2.4 - Round robin drop while joining client/server test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_LeaveWhileJoinCS(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTID_PCONNEX_LEAVEWHILEJOIN		pInput = (PTID_PCONNEX_LEAVEWHILEJOIN) pTNecd->pvInputData;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	DWORD							dwSubInputDataSize;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client= NULL;
	PTOD_BBLDDP8_CS_CREATE_0		pBldDP8CSCreateOutput0 = NULL;
	PTOD_BBLDDP8_CS_CREATE_NOT0		pBldDP8CSCreateOutputNot0 = NULL;
	DWORD							dwSubOutputDataSize;
	CONNEXLEAVEWHILEJOINCONTEXT		context;
	DPN_APPLICATION_DESC			dpnad;
	PDIRECTPLAY8ADDRESS				pDP8AddressRemote = NULL;
	PDIRECTPLAY8ADDRESS				pDP8AddressLocal = NULL;
	PTNFAULTSIM						pFaultSim = NULL;
	HANDLE							hConnectCompleteEvent = NULL;
	DPNHANDLE						dpnhConnect;
	int*							paiDestroyTesters = NULL;
	DPNID*							padpnidDestroyTesters = NULL;
	int								iNumIterations;
	int								iCurrentIteration;
	int								i;
	int								j;
#ifdef DEBUG
	char*							pszURL = NULL;
	DWORD							dwURLBufferSize = 0;
	DWORD							dwURLSize;
#endif // DEBUG



	ZeroMemory(&context, sizeof (CONNEXLEAVEWHILEJOINCONTEXT));
	context.pTNecd = pTNecd;


	BEGIN_TESTCASE
	{
		if ((pTNecd->pExecutor->IsCase("2.7.1.2")) || (pTNecd->pExecutor->IsCase("2.7.2.2")))
		{
			iNumIterations = 1;
		} // end if (simple case)
		else
		{
			REQUIRE_INPUT_DATA(sizeof (TID_PCONNEX_LEAVEWHILEJOIN));

			iNumIterations = pInput->iNumIterations;
		} // end else (round robin case)

		DPL(1, "Will perform %i iterations.", 1, iNumIterations);


		if (pTNecd->iTesterNum == 0)
		{
			// Servers need to allocate an array for all testers' player IDs.  The
			// position of a tester is always the same, regardless of the iteration.
			// We allocate this array even though build session will give us one
			// because we need to modify it, and we can't modify someone else's
			// buffer.

			LOCALALLOC_OR_THROW(DPNID*, context.padpnidTesters,
								(pTNecd->iNumMachines * sizeof (DPNID)));

			// Servers need to allocate an array for add player/delete player
			// indications.  The position of a tester is always the same, regardless
			// of the iteration.

			LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
								(pTNecd->iNumMachines * sizeof (BOOL)));
		} // end if (tester 0)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating client/server session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if (pTNecd->iTesterNum == 0)
			context.pfnDPNMessageHandler = ConnexLeaveWhileJoinServerDPNMessageHandler;
		else
			context.pfnDPNMessageHandler = ConnexLeaveWhileJoinClientDPNMessageHandler;

		context.pTNecd = pTNecd;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER | DPNSESSION_NODPNSVR;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_CONNEX_LEAVEWHILEJOIN_CS;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;



		dwSubInputDataSize = sizeof (TID_BBLDDP8_ALL_CREATE);
							//+ (pTNecd->iNumMachines * sizeof (int));

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		/*
		for(i = 0; i < pTNecd->iNumMachines; i++)
		{
			*((PVOID*) (((PBYTE) pvSubInputData) + sizeof (TID_BBLDDP8_ALL_CREATE) + (i * sizeof (int*)))) = &(context.paiReliableMsgsReceivedFromTesters[i]);
		} // end for (each tester)
		*/


		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.2.1", pvSubInputData,
												dwSubInputDataSize, 0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPL(0, "Couldn't execute sub test case BldSsn:BldCS:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.1",
									"Creating client/server session failed!");


		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutput0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_0) + (pTNecd->iNumMachines * sizeof (DPNID))));

			pDP8Server = pBldDP8CSCreateOutput0->pDP8Server;
			pDP8Server->m_dwRefCount++; // we're using it during this function

			CopyMemory(context.padpnidTesters, (pBldDP8CSCreateOutput0 + 1),
						(pTNecd->iNumMachines * sizeof (DPNID)));
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutputNot0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_NOT0) + (pTNecd->iNumMachines * sizeof (DPNID))));

			pDP8Client = pBldDP8CSCreateOutputNot0->pDP8Client;
			pDP8Client->m_dwRefCount++; // we're using it during this function



			// Everybody who might be rejoining the session at some point needs to
			// retrieve the address of the host so they can rejoin easily.

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting host's session address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_GetServerAddress(&pDP8AddressRemote, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get server address!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get server address)


#ifdef DEBUG
			do
			{
				dwURLSize = dwURLBufferSize;

				tr = pDP8AddressRemote->GetURLA(pszURL, &dwURLSize);
				if (tr == DPNERR_BUFFERTOOSMALL)
				{
					SAFE_LOCALFREE(pszURL);
					LOCALALLOC_OR_THROW(char*, pszURL, dwURLSize);
					dwURLBufferSize = dwURLSize;
				} // end if (buffer too small)
				else if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get next host address's URL!", 0);
					THROW_TESTRESULT;
				} // end if (didn't get URL)
			} // end do (while buffer too small)
			while (tr == DPNERR_BUFFERTOOSMALL);

			DPL(1, "Will use address (\"%s\") to reconnect.", 1, pszURL);
#endif // DEBUG
		} // end else (not tester 0)
		TESTSECTION_ENDIF





		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// The tester who's supposed to join first needs to drop out of
			// the session we built.

			context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (context.hDroppedAndJoinedEvent == NULL)
			{
				sr = GetLastError();
				DPL(0, "Couldn't create dropped and joined event!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't create event)


			context.iCurrentDroppingPlayer = pTNecd->iNumMachines - 1;
			context.iCurrentJoiningPlayer = -1;


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for testers to be ready to temporarily leave");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

			sr = pTNecd->pExecutor->SyncWithTesters("Ready for temp leave", NULL, 0, NULL,
													1, (pTNecd->iNumMachines - 1));
			HANDLE_SYNC_RESULT;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for player to temporarily drop");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDroppedAndJoinedEvent),
														1,
														NULL,
														-1,
														INFINITE,
														NULL);
			HANDLE_WAIT_RESULT;


			// Forget the dropping player's ID
			context.padpnidTesters[pTNecd->iNumMachines - 1] = 0;

			CloseHandle(context.hDroppedAndJoinedEvent);
			context.hDroppedAndJoinedEvent = NULL;
		} // end if (tester 0)
		TESTSECTION_ELSEIF(pTNecd->iTesterNum == (pTNecd->iNumMachines - 1))
		{
			// If we're the tester who's supposed to join first, we need to drop out of
			// the session we built (we only joined the first time so we could get the
			// host's address.

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for host to be ready for our temporary leave");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

			sr = pTNecd->pExecutor->SyncWithTesters("Ready for temp leave", NULL, 0, NULL,
													1, 0);
			HANDLE_SYNC_RESULT;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Leaving session temporarily");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't close interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)



#pragma TODO(vanceo, "Make release optional")

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Client object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release)
		} // end else if (first joiner)
		TESTSECTION_ENDIF




		
		// Start at the very beginning...
		iCurrentIteration = 0;
		TESTSECTION_DO
		{
			// Remember who's dropping and who's joining.
			context.iCurrentDroppingPlayer = (iCurrentIteration % (pTNecd->iNumMachines - 1)) + 1;
			context.iCurrentJoiningPlayer = context.iCurrentDroppingPlayer + (pTNecd->iNumMachines - 2);
			if (context.iCurrentJoiningPlayer >= pTNecd->iNumMachines)
				context.iCurrentJoiningPlayer = (context.iCurrentJoiningPlayer - pTNecd->iNumMachines) + 1;
			
			// Note that tester 0 should never be a dropping or joining player.


			DPL(1, "Iteration %i: dropping player = %i, joining player = %i, (we're tester %i so normal = %B)",
				5, iCurrentIteration, context.iCurrentDroppingPlayer,
				context.iCurrentJoiningPlayer, pTNecd->iTesterNum,
				(((pTNecd->iTesterNum == context.iCurrentDroppingPlayer) || (pTNecd->iTesterNum == context.iCurrentJoiningPlayer)) ? FALSE : TRUE));

			// Ignore error
			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Starting iteration #%i",
									1, (iCurrentIteration + 1));


			TESTSECTION_IF(pTNecd->iTesterNum == 0)
			{
				context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (context.hDroppedAndJoinedEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create rejoin event event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)


				// Get ready for players to drop and join.
				context.pafTesterIndicated[context.iCurrentDroppingPlayer] = FALSE;
				context.pafTesterIndicated[context.iCurrentJoiningPlayer] = FALSE;
				context.padpnidTesters[context.iCurrentJoiningPlayer] = 0;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with dropping and joining players");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														2, context.iCurrentDroppingPlayer,
														context.iCurrentJoiningPlayer);
				HANDLE_SYNC_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for players to drop and rejoin as appropriate");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hDroppedAndJoinedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(context.hDroppedAndJoinedEvent);
				context.hDroppedAndJoinedEvent = NULL;
			} // end if (tester 0)
			TESTSECTION_ELSEIF(pTNecd->iTesterNum == context.iCurrentDroppingPlayer)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with host before dropping");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														1, 0);
				HANDLE_SYNC_RESULT;



				TESTSECTION_IF((pTNecd->pExecutor->IsCase("2.7.2.2")) || (pTNecd->pExecutor->IsCase("2.7.2.4")))
				{
					context.hDroppedAndJoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
					if (context.hDroppedAndJoinedEvent == NULL)
					{
						sr = GetLastError();
						DPL(0, "Couldn't create rejoin event event!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't create event)



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Creating IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
															TN_FAULTSIM_IMTEST,
															NULL,
															0);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't create IMTest fault simulator!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't create fault simulator)




					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Disconnecting sends and received, will drop from session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)



#pragma TODO(vanceo, "Timeout (be able to set protocol caps: keepalives?)")
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for connection to server to drop");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hDroppedAndJoinedEvent,
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;



					CloseHandle(context.hDroppedAndJoinedEvent);
					context.hDroppedAndJoinedEvent = NULL;



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Restoring send and receive traffic");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Releasing IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't release fault simulator %x!", 1, pFaultSim);
						THROW_SYSTEMRESULT;
					} // end if (couldn't release fault simulator)
				} // end if (drop host migration case)
				TESTSECTION_ENDIF




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Disconnecting from session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->DP8C_Close(0);
				if (tr != DPN_OK)
				{
					DPL(0, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)




#pragma TODO(vanceo, "Make release optional")

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Client object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release)
			} // end if (we're the dropping player)
			TESTSECTION_ELSEIF(pTNecd->iTesterNum == context.iCurrentJoiningPlayer)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Recreating DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->CoCreate();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't CoCreate DirectPlay8Client object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't CoCreate)




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Initializing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				// We have to use the bldssn message handler because we use the
				// destroy session helper later, and that requires the appropriate
				// message handler.
				tr = pDP8Client->DP8C_Initialize(&context,
												BldDP8ClientDPNMessageHandler,
												0);
				if (tr != S_OK)
				{
					DPL(0, "Couldn't initialize client object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't initialize)



				hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (hConnectCompleteEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create connect completion event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("CoCreating local address object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL,
									CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address,
									(LPVOID*) &pDP8AddressLocal);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't CoCreate address object!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't CoCreate object)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Setting local address' SP");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't set local address' SP!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't set SP)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with host before rejoining");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for player leave & join",
														NULL, 0,
														NULL,
														1, 0);
				HANDLE_SYNC_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Reconnecting to session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->DP8C_Connect(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											hConnectCompleteEvent,
											&dpnhConnect,
											0);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPL(0, "Connect didn't return expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (connect not pending)


				// We don't need the local address anymore.
				pDP8AddressLocal->Release();
				pDP8AddressLocal = NULL;




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for connect completion notification");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&hConnectCompleteEvent,
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(hConnectCompleteEvent);
				hConnectCompleteEvent = NULL;

			} // end else if (we're the joining player)
			TESTSECTION_ELSE
			{
				// We've got nothing to do.

				DPL(1, "Nothing to do for tester %i during iteration %i (dropping player = %i, joining player = %i)",
					4, pTNecd->iTesterNum, iCurrentIteration,
					context.iCurrentDroppingPlayer, context.iCurrentJoiningPlayer);

				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Nothing to do for tester %i during iteration %i",
										2, pTNecd->iTesterNum,
										(iCurrentIteration + 1));
			} // end else (we're a normal player)
			TESTSECTION_ENDIF



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for everyone to complete iteration");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Iteration complete", NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;



			iCurrentIteration++;

			// If there aren't any more iterations, we can skip the rejoin phase.
			TESTSECTION_IF(iCurrentIteration >= iNumIterations)
			{
				DPL(1, "Final iteration completed.", 0);
				TESTSECTION_BREAK;
			} // end if (last iteration)
			TESTSECTION_ENDIF
		} // end do (while still more iterations to go)
		TESTSECTION_DOWHILE(TRUE);



		// Cleanup people still in session after last iteration.
		TESTSECTION_IF(pTNecd->iTesterNum == context.iCurrentDroppingPlayer)
		{
			sr = g_pDP8ClientsList->RemoveFirstReference(pDP8Client);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't remove DirectPlay8Client wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)

			pDP8Client->m_dwRefCount--;
			if (pDP8Client->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Client wrapper object %x.",
					1, pDP8Client);
				delete (pDP8Client);
			} // end if (can delete the object)
			else
			{
				DPL(0, "WARNING: Can't delete DirectPlay8Client wrapper object %x, it's refcount is %u!?",
					2, pDP8Client, pDP8Client->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Client = NULL;
		} // end if (current dropping tester)
		TESTSECTION_ELSE
		{
			paiDestroyTesters = NULL;
			padpnidDestroyTesters = NULL;

			LOCALALLOC_OR_THROW(int*, paiDestroyTesters,
								((pTNecd->iNumMachines - 1) * sizeof (int)));

			if (pTNecd->iTesterNum == 0)
			{
				LOCALALLOC_OR_THROW(DPNID*, padpnidDestroyTesters,
									((pTNecd->iNumMachines - 1) * sizeof (DPNID)));
			} // end if (tester 0)


			// Build arrays of tester numbers and player IDs that exclude the
			// missing player.
			j = 0;
			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				// Skip the player not in the session.
				if (i == context.iCurrentDroppingPlayer)
					continue;

				paiDestroyTesters[j] = i;

				if (pTNecd->iTesterNum == 0)
					padpnidDestroyTesters[j] = context.padpnidTesters[i];

				j++;
			} // end for (each tester)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (pTNecd->iTesterNum == 0)
			{
				dwSubInputDataSize = sizeof (TID_BBLDDP8_CS_DESTROY_0);
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pDP8Server = pDP8Server;
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pHandlerContext = &context;
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->padpnidTesters = padpnidDestroyTesters;
			} // end if (tester 0)
			else
			{
				dwSubInputDataSize = sizeof (TID_BBLDDP8_CS_DESTROY_NOT0);
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
				((PTID_BBLDDP8_CS_DESTROY_NOT0) pvSubInputData)->pDP8Client = pDP8Client;
			} // end else (not tester 0)

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.2.2",
														pvSubInputData,
														dwSubInputDataSize,
														(pTNecd->iNumMachines - 1),
														paiDestroyTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			SAFE_LOCALFREE(padpnidDestroyTesters);

			LocalFree(paiDestroyTesters);
			paiDestroyTesters = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:BldCS:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.2",
										"Destroying client/server session failed!");

			if (pTNecd->iTesterNum == 0)
			{
				pDP8Server->m_dwRefCount--;
				if (pDP8Server->m_dwRefCount == 0)
				{
					DPL(7, "Deleting server wrapper object %x.", 1, pDP8Server);
					delete (pDP8Server);
				} // end if (can delete the object)
				else
				{
					DPL(0, "WARNING: Can't delete server wrapper object %x, it's refcount is %u!?",
						2, pDP8Server, pDP8Server->m_dwRefCount);
				} // end else (can't delete the object)
				pDP8Server = NULL;
			} // end if (tester 0)
			else
			{
				pDP8Client->m_dwRefCount--;
				if (pDP8Client->m_dwRefCount == 0)
				{
					DPL(7, "Deleting client wrapper object %x.", 1, pDP8Client);
					delete (pDP8Client);
				} // end if (can delete the object)
				else
				{
					DPL(0, "WARNING: Can't delete client wrapper object %x, it's refcount is %u!?",
						2, pDP8Client, pDP8Client->m_dwRefCount);
				} // end else (can't delete the object)
				pDP8Client = NULL;
			} // end else (not tester 0)
		} // end else (not current dropping tester)
		TESTSECTION_ENDIF




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Making sure everyone survived final iteration");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pFaultSim != NULL)
	{
		temphr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
		if (temphr != S_OK)
		{
			DPL(0, "Couldn't release fault sim %x!  0x%08x", 2, pFaultSim, temphr);
			
			OVERWRITE_SR_IF_OK(temphr);

			pFaultSim = NULL;
		} // end if (couldn't remove handler)
	} // end if (have fault sim)

	SAFE_LOCALFREE(pszURL);
	SAFE_LOCALFREE(pvSubInputData);
	SAFE_CLOSEHANDLE(hConnectCompleteEvent);
	SAFE_CLOSEHANDLE(context.hDroppedAndJoinedEvent);
	SAFE_CLOSEHANDLE(context.hDroppedAndJoinedEvent);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_LOCALFREE(context.pafTesterIndicated);
	SAFE_LOCALFREE(context.padpnidTesters);

	if (pDP8Server != NULL)
	{
		temphr = pDP8Server->DP8S_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing server interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing server interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ServersList->RemoveFirstReference(pDP8Server);


		pDP8Server->m_dwRefCount--;
		if (pDP8Server->m_dwRefCount == 0)
		{
			DPL(7, "Deleting server wrapper object %x.", 1, pDP8Server);
			delete (pDP8Server);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete server wrapper object %x, it's refcount is %u!?",
				2, pDP8Server, pDP8Server->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		temphr = pDP8Client->DP8C_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing client interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing client interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ClientsList->RemoveFirstReference(pDP8Client);


		pDP8Client->m_dwRefCount--;
		if (pDP8Client->m_dwRefCount == 0)
		{
			DPL(7, "Deleting client wrapper object %x.", 1, pDP8Client);
			delete (pDP8Client);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete client wrapper object %x, it's refcount is %u!?",
				2, pDP8Client, pDP8Client->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Client = NULL;
	} // end if (have client object)

	return (sr);
} // ConnexExec_LeaveWhileJoinCS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexGet_ManyAll()"
//==================================================================================
// ConnexGet_ManyAll
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				2.7.3.1 - Many peer connect attempts test
//				2.7.3.2 - Many client/server connect attempts test
//
// Arguments:
//	PTNGETINPUTDATA pTNgid	Pointer to parameter block with information on how and
//							where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexGet_ManyAll(PTNGETINPUTDATA pTNgid)
{
	PTID_PCONNEX_MANY	pParams = (PTID_PCONNEX_MANY) pTNgid->pvData;
	PLSTRINGLIST		pStrings = NULL;
	char*				pszTemp;



	pTNgid->dwDataSize = sizeof (TID_PCONNEX_MANY);

	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	// Start with default values
	pParams->iNumIterations = 5;
	pParams->iNumObjects = 1;
	pParams->fOverlap = FALSE;
	pParams->fDontReuseObjects = FALSE;
	pParams->dwUserDataSize = 0;
	pParams->fReject = FALSE;
    

	// Get any input data strings that might exist.
	GETANYINPUTSTRINGS(pTNgid, pStrings);


	// Okay, so if we found strings, check if any of the options are specified.
	// If they are, override the default with the items' value.
	if (pStrings != NULL)
	{
		pszTemp = pStrings->GetValueOfKey("NumIterations");
		if (pszTemp != NULL)
			pParams->iNumIterations = StringToInt(pszTemp);

		pszTemp = pStrings->GetValueOfKey("NumObjects");
		if (pszTemp != NULL)
			pParams->iNumObjects = StringToInt(pszTemp);

		pParams->fOverlap = pStrings->IsKeyTrue("Overlap");
		pParams->fDontReuseObjects = pStrings->IsKeyTrue("DontReuseObjects");

		pszTemp = pStrings->GetValueOfKey("UserDataSize");
		if (pszTemp != NULL)
			pParams->dwUserDataSize = StringToDWord(pszTemp);

		pParams->fReject = pStrings->IsKeyTrue("Reject");
	} // end if (we found some items)


	return (S_OK);
} // ConnexGet_ManyAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexWrite_ManyAll()"
//==================================================================================
// ConnexWrite_ManyAll
//----------------------------------------------------------------------------------
//
// Description: Callback that converts a buffer to strings for the test case(s):
//				2.7.3.1 - Many peer connect attempts test
//				2.7.3.2 - Many client/server connect attempts test
//
// Arguments:
//	PTNWRITEDATA pTNwd	Parameter block with information and data to write.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexWrite_ManyAll(PTNWRITEDATA pTNwd)
{
	PTID_PCONNEX_MANY	pInputData = (PTID_PCONNEX_MANY) pTNwd->pvData;

	
	switch (pTNwd->dwLocation)
	{
		case TNTSDL_REPORTASSIGN:
			REQUIRE_ASSIGNREPORT_DATA(sizeof (TID_PCONNEX_MANY));


			WRITESPRINTFDATALINE("NumIterations= %i", 1, pInputData->iNumIterations);
			WRITESPRINTFDATALINE("NumObjects= %i", 1, pInputData->iNumObjects);
			WRITESPRINTFDATALINE("Overlap= %B", 1, pInputData->fOverlap);
			WRITESPRINTFDATALINE("DontReuseObjects= %B", 1, pInputData->fDontReuseObjects);
			WRITESPRINTFDATALINE("UserDataSize= %u", 1, pInputData->dwUserDataSize);
			WRITESPRINTFDATALINE("Reject= %B", 1, pInputData->fReject);
		  break;

		default:
			DPL(0, "Got data for unexpected location %u!",
				1, pTNwd->dwLocation);
			return (ERROR_INVALID_PARAMETER);
		  break;
	} // end switch (on the source of the data buffer)

	
	return (S_OK);
} // ConnexWrite_ManyAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_ManyAll()"
//==================================================================================
// ConnexExec_ManyAll
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.3.1 - Many peer connect attempts test
//				2.7.3.2 - Many client/server connect attempts test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_ManyAll(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	//HRESULT						temphr;
	PTID_PCONNEX_MANY			pInput = (PTID_PCONNEX_MANY) pTNecd->pvInputData;
	PVOID*						papvInterfaces = NULL;
	int							iNumInterfaces = 0;
	BOOL						fClientServer = FALSE;
	DPN_APPLICATION_DESC		dpnad;
	PDIRECTPLAY8ADDRESS			pDP8AddressRemote = NULL;
	PDIRECTPLAY8ADDRESS			pDP8AddressLocal = NULL;
	CTNSyncDataList				syncdata;
	PVOID						pvSyncData;
	DWORD						dwSyncDataSize;
	CONNEXMANYHOSTCONTEXT		hostcontext;
	CONNEXMANYCONNECTORCONTEXT	connectorcontext;
	PVOID						pvUserConnectData = NULL;
	int							i;
	int							iCurrentIteration;
	int							iCurrentConnectingTester;
	int							iCurrentConnectingInterface;
	PHOSTADDRESSESSYNCDATA		pHostAddressesSyncData = NULL;
	PDIRECTPLAY8ADDRESS*		paDP8HostAddresses = NULL;
	DWORD						dwNumAddresses = 0;
	DWORD						dwTemp;
	DWORD						dwURLsBufferSize = 0;
	DWORD						dwRemainingBufferSize;
	char*						pszURL;
	DWORD						dwSize;
	DWORD						dwDataType;
	char						szIPString[16]; // max IP string size + NULL termination
	WCHAR						wszIPCompareString[16]; // max IP string size + NULL termination



	ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));

	ZeroMemory(&hostcontext, sizeof (CONNEXMANYHOSTCONTEXT));
	hostcontext.pTNecd = pTNecd;

	ZeroMemory(&connectorcontext, sizeof (CONNEXMANYCONNECTORCONTEXT));
	connectorcontext.pTNecd = pTNecd;


	BEGIN_TESTCASE
	{
		REQUIRE_INPUT_DATA(sizeof (TID_PCONNEX_MANY));


		if (pTNecd->pExecutor->IsCase("2.7.3.2"))
			fClientServer = TRUE;



		if (pTNecd->iTesterNum == 0)
		{
			// Pre-allocate the user data buffer we're going to when replying.
			hostcontext.dwUserDataSize = pInput->dwUserDataSize;
			if (pInput->dwUserDataSize > 0)
			{
				LOCALALLOC_OR_THROW(PVOID, hostcontext.pvReplyData,
									pInput->dwUserDataSize);

				FillWithDWord(hostcontext.pvReplyData, pInput->dwUserDataSize,
							DATAPATTERN_REPLY);
			} // end if (there's supposed to be user data)

			hostcontext.fReject = pInput->fReject;


			CREATEEVENT_OR_THROW(hostcontext.hConnectsDoneEvent,
								NULL, FALSE, FALSE, NULL);

			hostcontext.iNumConnectsRemaining = pInput->iNumIterations;

			
			iNumInterfaces = 1;
		} // end if (tester 0)
		else
		{
			// Pre-allocate the user data buffer we're going to send.
			if (pInput->dwUserDataSize > 0)
			{
				LOCALALLOC_OR_THROW(PVOID, pvUserConnectData,
									pInput->dwUserDataSize);

				FillWithDWord(pvUserConnectData, pInput->dwUserDataSize,
							DATAPATTERN_CONNECT);
			} // end if (there's supposed to be user data)

			connectorcontext.dwReplyDataSize = pInput->dwUserDataSize;

			connectorcontext.fReject = pInput->fReject;


			
			iNumInterfaces = pInput->iNumObjects;

			LOCALALLOC_OR_THROW(HANDLE*, connectorcontext.pahConnectCompleteEvents,
								(iNumInterfaces * sizeof (HANDLE)));

			LOCALALLOC_OR_THROW(DPNHANDLE*, connectorcontext.padpnhConnects,
								(iNumInterfaces * sizeof (DPNHANDLE)));
		} // end else (not tester 0)

		LOCALALLOC_OR_THROW(PVOID*, papvInterfaces,
							sizeof (PVOID) * iNumInterfaces);



		TESTSECTION_FOR(i = 0; i < iNumInterfaces; i++)
		{
			TESTSECTION_IF(fClientServer)
			{
				TESTSECTION_IF(pTNecd->iTesterNum == 0)
				{
					DPL(0, "Creating DirectPlay8Server object %i", 1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Creating DirectPlay8Server object %i",
											1, i);


					papvInterfaces[i] = new (CWrapDP8Server);
					if (papvInterfaces[i] == NULL)
					{
						SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
					} // end if (couldn't allocate object)


					tr = ((PWRAPDP8SERVER) papvInterfaces[i])->CoCreate();
					if (tr != DPN_OK)
					{
						DPL(0, "CoCreating DP8Server object failed!", 0);
						THROW_TESTRESULT;
					} // end if (function failed)



					DPL(0, "Initializing DirectPlay8Server object %i", 1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Initializing DirectPlay8Server object %i",
											1, i);

					tr = ((PWRAPDP8SERVER) papvInterfaces[i])->DP8S_Initialize(&hostcontext,
																				ConnexManyHostDPNMessageHandler,
																				0);
					if (tr != S_OK)
					{
						DPL(0, "Couldn't initialize server object!", 0);
						THROW_TESTRESULT;
					} // end if (couldn't initialize)
				} // end if (tester 0)
				TESTSECTION_ELSE
				{
					DPL(0, "Creating DirectPlay8Client object %i", 1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Creating DirectPlay8Client object %i",
											1, i);


					papvInterfaces[i] = new (CWrapDP8Client);
					if (papvInterfaces[i] == NULL)
					{
						SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
					} // end if (couldn't allocate object)


					tr = ((PWRAPDP8CLIENT) papvInterfaces[i])->CoCreate();
					if (tr != DPN_OK)
					{
						DPL(0, "CoCreating DP8Client object failed!", 0);
						THROW_TESTRESULT;
					} // end if (function failed)




					DPL(0, "Initializing DirectPlay8Client object %i", 1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Initializing DirectPlay8Client object %i",
											1, i);

					tr = ((PWRAPDP8CLIENT) papvInterfaces[i])->DP8C_Initialize(&connectorcontext,
																				ConnexManyConnectorDPNMessageHandler,
																				0);
					if (tr != S_OK)
					{
						DPL(0, "Couldn't initialize client object!", 0);
						THROW_TESTRESULT;
					} // end if (couldn't initialize)
				} // end else (not tester 0)
				TESTSECTION_ENDIF
			} // end if (client/server)
			TESTSECTION_ELSE
			{
				DPL(0, "Creating DirectPlay8Peer object %i", 1, i);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Creating DirectPlay8Peer object %i",
										1, i);



				papvInterfaces[i] = new (CWrapDP8Peer);
				if (papvInterfaces[i] == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)


				tr = ((PWRAPDP8PEER) papvInterfaces[i])->CoCreate();
				if (tr != DPN_OK)
				{
					DPL(0, "CoCreating DP8Peer object failed!", 0);
					THROW_TESTRESULT;
				} // end if (function failed)




				DPL(0, "Initializing DirectPlay8Peer object %i", 1, i);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Initializing DirectPlay8Peer object %i",
										1, i);

				if (pTNecd->iTesterNum == 0)
				{
					tr = ((PWRAPDP8PEER) papvInterfaces[i])->DP8P_Initialize(&hostcontext,
																			ConnexManyHostDPNMessageHandler,
																			0);
				} // end if (tester 0)
				else
				{
					tr = ((PWRAPDP8PEER) papvInterfaces[i])->DP8P_Initialize(&connectorcontext,
																			ConnexManyConnectorDPNMessageHandler,
																			0);
				} // end else (not tester 0)

				if (tr != S_OK)
				{
					DPL(0, "Couldn't initialize peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't initialize)
			} // end else (peer-to-peer)
			TESTSECTION_ENDIF
		} // end for (each interface to create)
		TESTSECTION_ENDFOR



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating local address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressLocal);
		if (sr != S_OK)
		{
			DPL(0, "Couldn't CoCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != S_OK)
		{
			DPL(0, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		if ((pTNecd->iTesterNum == 0) && (fClientServer))
			dpnad.dwFlags |= DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = (fClientServer) ? GUID_CONNEX_MANY_CS : GUID_CONNEX_MANY_PEER;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = (pTNecd->iTesterNum == 0) ? L"Session" : NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;



		// Tester 0 should start hosting a session, tester 1 should wait until
		// the session is up.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				tr = ((PWRAPDP8SERVER) papvInterfaces[0])->DP8S_Host(&dpnad,
																	&pDP8AddressLocal,
																	1,
																	NULL,
																	NULL,
																	NULL,
																	0);
			} // end if (client/server)
			else
			{
				tr = ((PWRAPDP8PEER) papvInterfaces[0])->DP8P_Host(&dpnad,
																	&pDP8AddressLocal,
																	1,
																	NULL,
																	NULL,
																	NULL,
																	0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't start hosting session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)


			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting local host addresses");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				tr = ((PWRAPDP8SERVER) papvInterfaces[0])->DP8S_GetLocalHostAddresses(NULL,
																					&dwNumAddresses,
																					0);
			} // end if (client/server)
			else
			{
				tr = ((PWRAPDP8PEER) papvInterfaces[0])->DP8P_GetLocalHostAddresses(NULL,
																					&dwNumAddresses,
																					0);
			} // end else (peer-to-peer)

			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get number of host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)



			DPL(1, "We are hosting on %u addresses.", 1, dwNumAddresses); 


			LOCALALLOC_OR_THROW(PDIRECTPLAY8ADDRESS*, paDP8HostAddresses,
								dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));


			if (fClientServer)
			{
				tr = ((PWRAPDP8SERVER) papvInterfaces[0])->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
																					&dwNumAddresses,
																					0);
			} // end if (client/server)
			else
			{
				tr = ((PWRAPDP8PEER) papvInterfaces[0])->DP8P_GetLocalHostAddresses(paDP8HostAddresses,
																					&dwNumAddresses,
																					0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)

			// Get the total size of all the addresses.
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = 0;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(NULL, &dwSize);
				if (tr != DPNERR_BUFFERTOOSMALL)
				{
					DPL(0, "Couldn't get host address %u's URL size!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (not buffer too small)
				
				dwURLsBufferSize += dwSize;
			} // end for (each address)

			// Allocate a buffer for all the URLs.
			LOCALALLOC_OR_THROW(PHOSTADDRESSESSYNCDATA,
								pHostAddressesSyncData,
								sizeof (HOSTADDRESSESSYNCDATA) + dwURLsBufferSize);

			pHostAddressesSyncData->dwNumAddresses = dwNumAddresses;
			pszURL = (char*) (pHostAddressesSyncData + 1);
			dwRemainingBufferSize = dwURLsBufferSize;


			// Actually fill in all the URLs and release the objects (since we're
			// done with them).
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = dwRemainingBufferSize;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(pszURL,
														&dwSize);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host address %u's URL!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (failed)


				DPL(1, "Address %u: \"%s\"",
					2, dwTemp, pszURL);

				dwRemainingBufferSize -= dwSize;
				pszURL += dwSize;

				
				// We're done with this address object.
				paDP8HostAddresses[dwTemp]->Release();
				paDP8HostAddresses[dwTemp] = NULL;
			} // end for (each address)

			// We're done with the address array.
			LocalFree(paDP8HostAddresses);
			paDP8HostAddresses = NULL;


			// Make sure we used all of the buffer.
			if (dwRemainingBufferSize != 0)
			{
				DPL(0, "Didn't use all of or overran the allocated buffer (didn't use %i bytes)!",
					1, ((int) dwRemainingBufferSize));
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (didn't use all of the buffer)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending addresses to everyone");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													pHostAddressesSyncData,
													(sizeof (HOSTADDRESSESSYNCDATA) + dwURLsBufferSize),
													NULL,
													0);
			HANDLE_SYNC_RESULT;


			LocalFree(pHostAddressesSyncData);
			pHostAddressesSyncData = NULL;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Beginning multiple connection sequence");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			// Technically it already began once the sync completed.  Picky picky
			// picky...


			TESTSECTION_IF(! pInput->fOverlap)
			{
				// We don't need to synchronize on the last iteration, it will be caught by
				// the final sync.
				TESTSECTION_FOR(iCurrentIteration = 0; iCurrentIteration < (pInput->iNumIterations - 1); iCurrentIteration++)
				{
					iCurrentConnectingTester = (iCurrentIteration % (pTNecd->iNumMachines - 1)) + 1;
					iCurrentConnectingInterface = (iCurrentIteration / (pTNecd->iNumMachines - 1)) % pInput->iNumObjects;
					

					DPL(1, "Waiting for tester %i to perform connection iteration #%i (using interface %i).",
						3, iCurrentConnectingTester, iCurrentIteration,
						iCurrentConnectingInterface);

					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Waiting for tester %i to perform connection iteration #%i",
											2, iCurrentConnectingTester,
											iCurrentIteration);


					// Synchronize with everyone.
					sr = pTNecd->pExecutor->SyncWithTesters("Connection iteration complete",
															NULL, 0, NULL,
															0);
					HANDLE_SYNC_RESULT;
				} // end for (each iteration)
				TESTSECTION_ENDFOR
			} // end if (not overlapped connections)
			TESTSECTION_ENDIF
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Receiving addresses of host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													NULL,
													0,
													&syncdata,
													0);
			HANDLE_SYNC_RESULT;

			CHECKANDGET_MINIMUM_SYNCDATA(syncdata, 0, pvSyncData, dwSyncDataSize,
										(sizeof (HOSTADDRESSESSYNCDATA) + (strlen(DPNA_HEADER_A) + 1)));


			dwNumAddresses = ((PHOSTADDRESSESSYNCDATA) pvSyncData)->dwNumAddresses;

			// Start with the first address
			pszURL = (char*) (((PBYTE) pvSyncData) + sizeof (HOSTADDRESSESSYNCDATA));



			DPL(1, "Tester 0 (host) has %u connectable addresses.",
				1, dwNumAddresses);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressRemote);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't CoCreate remote (host's) address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma TODO(vanceo, "Support other SPs")
			// Figure out what IP we should use to connect to the host.
			sr = pTNecd->pExecutor->GetTestersIPForPort(0, DPLAY8_PORT, szIPString);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't get tester 0's IP for port %u!",
					1, DPLAY8_PORT);
				THROW_SYSTEMRESULT;
			} // end if (couldn't get tester 0's IP)


			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				DPL(1, "Host address %u: %s", 2, dwTemp, pszURL);


				DPL(0, "Building remote address %u from string URL.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Building remote address %u from string URL.",
										1, dwTemp);


				tr = pDP8AddressRemote->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't build host's address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPL(0, "Getting remote address %u's hostname component.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Getting remote address %u's hostname component.",
										1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemote->GetComponentByName(DPNA_KEY_HOSTNAME,
															wszIPCompareString,
															&dwSize,
															&dwDataType);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host's address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPL(0, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPL(0, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(wszIPCompareString, szIPString, TRUE))
				{
					DPL(1, "Found IP address \"%s\", using host's address %u (\"%s\").",
						3, szIPString, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddresses)
			{
				DPL(0, "Couldn't find the correct host address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)


			// At this point, the remote address object has the correct host
			// address we should use when connecting.



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Beginning multiple connection sequence");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			TESTSECTION_FOR(iCurrentIteration = 0; iCurrentIteration < pInput->iNumIterations; iCurrentIteration++)
			{
				iCurrentConnectingTester = (iCurrentIteration % (pTNecd->iNumMachines - 1)) + 1;
				

				TESTSECTION_IF(iCurrentConnectingTester == pTNecd->iTesterNum)
				{
					iCurrentConnectingInterface = (iCurrentIteration / (pTNecd->iNumMachines - 1)) % pInput->iNumObjects;

					DPL(0, "Starting connection iteration #%i, connecting with interface %i.",
						2, iCurrentIteration, iCurrentConnectingInterface);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Starting connection iteration #%i",
											1, iCurrentIteration);



					TESTSECTION_IF(connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface] == NULL)
					{
						// This is the first time through the loop, or we're not
						// overlapping connects, so create the event for this time.
						CREATEEVENT_OR_THROW(connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface],
											NULL, FALSE, FALSE, NULL);
					} // end if (don't have event)
					TESTSECTION_ELSE
					{
						// This is not the first time through the loop with
						// overlapping connects.  We must wait for the previous
						// connect to complete.

						DPL(0, "Waiting for object %i connect to %s.",
							2, iCurrentConnectingInterface,
							((pInput->fReject) ? "be rejected" : "complete successfully"));
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Waiting for object %i connect to %s",
												2, iCurrentConnectingInterface,
												((pInput->fReject) ? "be rejected" : "complete successfully"));

						sr = pTNecd->pExecutor->WaitForEventOrCancel(&(connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface]),
																	1,
																	NULL,
																	-1,
																	INFINITE,
																	NULL);
						HANDLE_WAIT_RESULT;


						// The connect completed, so close the object and prepare to
						// try again.

						DPL(0, "Closing object %i", 1, iCurrentConnectingInterface);
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Closing object %i",
												1, iCurrentConnectingInterface);

						if (fClientServer)
						{
							tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->DP8C_Close(0);
						} // end if (client/server)
						else
						{
							tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->DP8P_Close(0);
						} // end else (peer-to-peer)

						if (tr != DPN_OK)
						{
							DPL(0, "Failed closing object %i!",
								1, iCurrentConnectingInterface);
							THROW_TESTRESULT;
						} // end if (couldn't close)


						if (pInput->fDontReuseObjects)
						{
							DPL(0, "Releasing object %i", 1, iCurrentConnectingInterface);
							// Ignore error
							pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
													"Releasing object %i",
													1, iCurrentConnectingInterface);
							if (fClientServer)
							{
								tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->Release();
							} // end if (client/server)
							else
							{
								tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->Release();
							} // end else (peer-to-peer)

							if (tr != DPN_OK)
							{
								DPL(0, "Failed releasing object %i!",
									1, iCurrentConnectingInterface);
								THROW_TESTRESULT;
							} // end if (couldn't release)


							DPL(0, "Recreating object %i", 1, iCurrentConnectingInterface);
							// Ignore error
							pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
													"Recreating object %i",
													1, iCurrentConnectingInterface);
							if (fClientServer)
							{
								tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->CoCreate();
							} // end if (client/server)
							else
							{
								tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->CoCreate();
							} // end else (peer-to-peer)

							if (tr != DPN_OK)
							{
								DPL(0, "Failed recreating object %i!",
									1, iCurrentConnectingInterface);
								THROW_TESTRESULT;
							} // end if (couldn't cocreate)
						} // end if (reusing objects)



						// Reinitialize the object.

						DPL(0, "Re-initializing object %i",
							1, iCurrentConnectingInterface);
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Re-initializing object %i",
												1, iCurrentConnectingInterface);

						if (fClientServer)
						{
							tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->DP8C_Initialize(&connectorcontext,
																												ConnexManyConnectorDPNMessageHandler,
																												0);
						} // end if (client/server)
						else
						{
							tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->DP8P_Initialize(&connectorcontext,
																												ConnexManyConnectorDPNMessageHandler,
																												0);
						} // end else (peer-to-peer)

						if (tr != DPN_OK)
						{
							DPL(0, "Failed re-initializing object %i!",
								1, iCurrentConnectingInterface);
							THROW_TESTRESULT;
						} // end if (couldn't initialize)
					} // end else (do have event)
					TESTSECTION_ENDIF



					DPL(0, "Connecting object %i", 1, iCurrentConnectingInterface);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Connecting object %i",
											1, iCurrentConnectingInterface);
					
					// Use the interface index as the context.
					if (fClientServer)
					{
						tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->DP8C_Connect(&dpnad,
																										pDP8AddressRemote,
																										pDP8AddressLocal,
																										NULL,
																										NULL,
																										pvUserConnectData,
																										pInput->dwUserDataSize,
																										(PVOID) ((INT_PTR) iCurrentConnectingInterface),
																										&(connectorcontext.padpnhConnects[i % pInput->iNumObjects]),
																										0);
					} // end if (client/server)
					else
					{
						tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->DP8P_Connect(&dpnad,
																										pDP8AddressRemote,
																										pDP8AddressLocal,
																										NULL,
																										NULL,
																										pvUserConnectData,
																										pInput->dwUserDataSize,
																										NULL,
																										(PVOID) ((INT_PTR) iCurrentConnectingInterface),
																										&(connectorcontext.padpnhConnects[i % pInput->iNumObjects]),
																										0);
					} // end else (peer-to-peer)

					if (tr != (HRESULT) DPNSUCCESS_PENDING)
					{
						DPL(0, "Couldn't start connecting object %i!",
							1, iCurrentConnectingInterface);
						THROW_TESTRESULT;
					} // end if (couldn't connect)


					TESTSECTION_IF(! pInput->fOverlap)
					{
						DPL(0, "Waiting for object %i connect to %s.",
							2, iCurrentConnectingInterface,
							((pInput->fReject) ? "be rejected" : "complete successfully"));
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Waiting for object %i connect to %s",
												2, iCurrentConnectingInterface,
												((pInput->fReject) ? "be rejected" : "complete successfully"));

						sr = pTNecd->pExecutor->WaitForEventOrCancel(&(connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface]),
																	1,
																	NULL,
																	-1,
																	INFINITE,
																	NULL);
						HANDLE_WAIT_RESULT;


						CloseHandle(connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface]);
						connectorcontext.pahConnectCompleteEvents[iCurrentConnectingInterface] = NULL;


						// The connect completed, so close the object and prepare to
						// try again.

						DPL(0, "Closing object %i",
							1, (i % pInput->iNumObjects));
						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Closing object %i",
												1, iCurrentConnectingInterface);

						if (fClientServer)
						{
							tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->DP8C_Close(0);
						} // end if (client/server)
						else
						{
							tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->DP8P_Close(0);
						} // end else (peer-to-peer)

						if (tr != DPN_OK)
						{
							DPL(0, "Failed closing object %i!",
								1, iCurrentConnectingInterface);
							THROW_TESTRESULT;
						} // end if (couldn't connect)



						// Reinitialize the object if that wasn't the last iteration
						// this interface will be doing.
						TESTSECTION_IF(iCurrentIteration < (pInput->iNumIterations - ((pTNecd->iNumMachines - 1) * pInput->iNumObjects)))
						{
							if (pInput->fDontReuseObjects)
							{
								DPL(0, "Releasing object %i", 1, iCurrentConnectingInterface);
								// Ignore error
								pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
														"Releasing object %i",
														1, iCurrentConnectingInterface);
								if (fClientServer)
								{
									tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->Release();
								} // end if (client/server)
								else
								{
									tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->Release();
								} // end else (peer-to-peer)

								if (tr != DPN_OK)
								{
									DPL(0, "Failed releasing object %i!",
										1, iCurrentConnectingInterface);
									THROW_TESTRESULT;
								} // end if (couldn't release)


								DPL(0, "Recreating object %i", 1, iCurrentConnectingInterface);
								// Ignore error
								pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
														"Recreating object %i",
														1, iCurrentConnectingInterface);
								if (fClientServer)
								{
									tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->CoCreate();
								} // end if (client/server)
								else
								{
									tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->CoCreate();
								} // end else (peer-to-peer)

								if (tr != DPN_OK)
								{
									DPL(0, "Failed recreating object %i!",
										1, iCurrentConnectingInterface);
									THROW_TESTRESULT;
								} // end if (couldn't cocreate)
							} // end if (reusing objects)


							DPL(0, "Re-initializing object %i",
								1, iCurrentConnectingInterface);
							// Ignore error
							pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
													"Re-initializing object %i",
													1, iCurrentConnectingInterface);

							if (fClientServer)
							{
								tr = ((PWRAPDP8CLIENT) papvInterfaces[iCurrentConnectingInterface])->DP8C_Initialize(&connectorcontext,
																													ConnexManyConnectorDPNMessageHandler,
																													0);
							} // end if (client/server)
							else
							{
								tr = ((PWRAPDP8PEER) papvInterfaces[iCurrentConnectingInterface])->DP8P_Initialize(&connectorcontext,
																													ConnexManyConnectorDPNMessageHandler,
																													0);
							} // end else (peer-to-peer)

							if (tr != DPN_OK)
							{
								DPL(0, "Failed re-initializing object %i!",
									1, iCurrentConnectingInterface);
								THROW_TESTRESULT;
							} // end if (couldn't connect)
						} // end if (not last iteration for object)
						TESTSECTION_ENDIF


						// Synchronize with everyone if this isn't the absolute last
						// iteration
						TESTSECTION_IF(iCurrentIteration < (pInput->iNumIterations - 1))
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Letting other testers know iteration is complete");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -


							// Synchronize with everyone.
							sr = pTNecd->pExecutor->SyncWithTesters("Connection iteration complete",
																	NULL, 0, NULL,
																	0);
							HANDLE_SYNC_RESULT;
						} // end if (not absolute last iteration)
						TESTSECTION_ENDIF
					} // end if (not overlapping connects)
					TESTSECTION_ENDIF
				} // end if (it's current client's turn to connect)
				TESTSECTION_ELSE
				{
					TESTSECTION_IF(pInput->fOverlap)
					{
						DPL(1, "Not involved with connection iteration #%i (tester %i is the connector).",
							2, iCurrentIteration, iCurrentConnectingTester);

						// Ignore error
						pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
												"Not involved with connection iteration #%i",
												1, iCurrentIteration);
					} // end if (overlapping connects)
					TESTSECTION_ELSE
					{
						TESTSECTION_IF(iCurrentIteration < (pInput->iNumIterations - 1))
						{
							DPL(1, "Waiting for tester %i to perform connection iteration #%i.",
								2, iCurrentConnectingTester, iCurrentIteration);

							// Ignore error
							pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
													"Waiting for tester %i to perform connection iteration #%i",
													2, iCurrentConnectingTester,
													iCurrentIteration);


							// Synchronize with everyone.
							sr = pTNecd->pExecutor->SyncWithTesters("Connection iteration complete",
																	NULL, 0, NULL,
																	0);
							HANDLE_SYNC_RESULT;
						} // end if (not last iteration for object)
						TESTSECTION_ENDIF
					} // end else (not overlapping connects)
					TESTSECTION_ENDIF
				} // end else (it's not current client's turn to connect)
				TESTSECTION_ENDIF
			} // end for (each iteration)
			TESTSECTION_ENDFOR



			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			pDP8AddressRemote->Release();
			pDP8AddressRemote = NULL;




			// If we overlapped connect attempts on the interfaces, wait for them
			// to complete now, and then close the interfaces.
			TESTSECTION_IF(pInput->fOverlap)
			{
				TESTSECTION_FOR(i = 0; i < iNumInterfaces; i++)
				{
					DPL(0, "Waiting for object %i connect to %s.",
						2, i,
						((pInput->fReject) ? "be rejected" : "complete successfully"));
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Waiting for object %i connect to %s",
											2, i,
											((pInput->fReject) ? "be rejected" : "complete successfully"));

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&(connectorcontext.pahConnectCompleteEvents[i]),
																1,
																NULL,
																-1,
																INFINITE,
																NULL);

					HANDLE_WAIT_RESULT;

					CloseHandle(connectorcontext.pahConnectCompleteEvents[i]);
					connectorcontext.pahConnectCompleteEvents[i] = NULL;


					// The connect completed, so close the object and prepare to
					// try again.

					DPL(0, "Closing object %i", 1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Closing object %i",
											1, i);

					if (fClientServer)
					{
						tr = ((PWRAPDP8CLIENT) papvInterfaces[i])->DP8C_Close(0);
					} // end if (client/server)
					else
					{
						tr = ((PWRAPDP8PEER) papvInterfaces[i])->DP8P_Close(0);
					} // end else (peer-to-peer)

					if (tr != DPN_OK)
					{
						DPL(0, "Failed closing object %i!", 1, i);
						THROW_TESTRESULT;
					} // end if (couldn't connect)
				} // end for (each interface)
				TESTSECTION_ENDFOR
			} // end if (overlapping connects)
			TESTSECTION_ENDIF
		} // end else (not tester 0)
		TESTSECTION_ENDIF



		// Tester 0 needs to wait for his determination of connect indications and
		// their reply buffers being returned.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			TESTSECTION_IF(pInput->dwUserDataSize > 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for all connect reply buffers to be returned");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			} // end if (user data)
			TESTSECTION_ELSE
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Ensuring all connects were indicated");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			} // end else (no user data)
			TESTSECTION_ENDIF


			pTNecd->pExecutor->WaitForEventOrCancel(&(hostcontext.hConnectsDoneEvent),
													1, NULL, -1, INFINITE, NULL);
		} // end if (tester 0)
		TESTSECTION_ENDIF




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Making sure all testers have finished the connect(s) sequence");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("All connects complete", NULL, 0,
												NULL, 0);
		HANDLE_SYNC_RESULT;



		// Tester 0 needs to close his interface
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing hosted session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				tr = ((PWRAPDP8SERVER) papvInterfaces[0])->DP8S_Close(0);
			} // end if (client/server)
			else
			{
				tr = ((PWRAPDP8PEER) papvInterfaces[0])->DP8P_Close(0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPL(0, "Failed closing hosting object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)
		} // end if (tester 0)
		TESTSECTION_ENDIF



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing interfaces");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Everybody needs to release there interfaces.
		TESTSECTION_FOR(i = 0; i < iNumInterfaces; i++)
		{
			if (fClientServer)
			{
				if (pTNecd->iTesterNum == 0)
				{
					DPL(0, "Releasing DirectPlay8Server object %i",
						1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Releasing DirectPlay8Server object %i",
											1, i);

					tr = ((PWRAPDP8SERVER) papvInterfaces[i])->Release();
					if (tr != S_OK)
					{
						DPL(0, "Couldn't release DirectPlay8Server object!", 0);
						THROW_TESTRESULT;
					} // end if (couldn't release object)

					delete ((PWRAPDP8SERVER) papvInterfaces[i]);
				} // end if (tester 0)
				else
				{
					DPL(0, "Releasing DirectPlay8Client object %i",
						1, i);
					// Ignore error
					pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
											"Releasing DirectPlay8Client object %i",
											1, i);

					tr = ((PWRAPDP8CLIENT) papvInterfaces[i])->Release();
					if (tr != S_OK)
					{
						DPL(0, "Couldn't release DirectPlay8Client object!", 0);
						THROW_TESTRESULT;
					} // end if (couldn't release object)

					delete ((PWRAPDP8CLIENT) papvInterfaces[i]);
				} // end else (not tester 0)
			} // end if (client/server)
			else
			{
				DPL(0, "Releasing DirectPlay8Peer object %i",
					1, i);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Releasing DirectPlay8Peer object %i",
										1, i);

				tr = ((PWRAPDP8PEER) papvInterfaces[i])->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)

				delete ((PWRAPDP8PEER) papvInterfaces[i]);
			} // end else (peer-to-peer)
			papvInterfaces[i] = NULL;
		} // end for (each interface)
		TESTSECTION_ENDFOR

		LocalFree(papvInterfaces);
		papvInterfaces = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (papvInterfaces != NULL)
	{
		for(i = 0; i < iNumInterfaces; i++)
		{
			if (papvInterfaces[i] != NULL)
			{
				if (fClientServer)
				{
					if (pTNecd->iTesterNum == 0)
					{
						delete ((PWRAPDP8SERVER) papvInterfaces[i]);
					} // end if (tester 0)
					else
					{
						delete ((PWRAPDP8CLIENT) papvInterfaces[i]);
					} // end else (not tester 0)
				} // end if (client/server)
				else
				{
					delete ((PWRAPDP8PEER) papvInterfaces[i]);
				} // end else (peer-to-peer)
				papvInterfaces[i] = NULL;
			} // end if (actually have interface)
		} // end for (each interface)

		LocalFree(papvInterfaces);
		papvInterfaces = NULL;
	} // end if (have interface array)

	if (paDP8HostAddresses != NULL)
	{
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			SAFE_RELEASE(paDP8HostAddresses[dwTemp]);
		} // end for (each address)

		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (have array of host addresses)


	if (connectorcontext.pahConnectCompleteEvents != NULL)
	{
		for(i = 0; i < iNumInterfaces; i++)
		{
			SAFE_CLOSEHANDLE(connectorcontext.pahConnectCompleteEvents[i]);
		} // end for (each address)

		LocalFree(connectorcontext.pahConnectCompleteEvents);
		connectorcontext.pahConnectCompleteEvents = NULL;
	} // end if (have array of connect complete events)

	SAFE_LOCALFREE(connectorcontext.padpnhConnects);
	SAFE_LOCALFREE(pHostAddressesSyncData);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_LOCALFREE(pvUserConnectData);
	SAFE_LOCALFREE(hostcontext.pvReplyData);

	return (sr);
} // ConnexExec_ManyAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexCanRun_ServerLoss()"
//==================================================================================
// ConnexCanRun_ServerLoss
//----------------------------------------------------------------------------------
//
// Description: Callback that checks a possible tester list to make sure the test
//				can be run correctly for the following test case(s):
//				2.7.4.1 - Server leave test
//				2.7.4.2 - Server drop test
//
// Arguments:
//	PTNCANRUNDATA pTNcrd	Pointer to parameter block with information on what
//							configuration to check.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ConnexCanRun_ServerLoss(PTNCANRUNDATA pTNcrd)
{
	HRESULT		hr;
	int			i;


	// The host tester needs to have IMTest installed in the drop case.
	if (strcmp(pTNcrd->pTest->m_pszID, "2.7.4.2") == 0)
	{
		pTNcrd->fCanRun = pTNcrd->apTesters[0]->m_fFaultSimIMTestAvailable;

		if (! pTNcrd->fCanRun)
		{
			DPL(1, "Tester 0 (%s) doesn't have IMTest fault simulator available.",
				1, pTNcrd->apTesters[0]->m_szComputerName);

			return (S_OK);
		} // end if (tester doesn't have IMTest)
	} // end if (drop test)


	// Make sure all subsequent testers can connect to the first.
	for(i = 1; i < pTNcrd->iNumMachines; i++)
	{
		if (pTNcrd->pMaster->AreOnSameMachine(pTNcrd->apTesters[i],
											pTNcrd->apTesters[0]))
		{
			DPL(1, "Tester 1 is on same machine as tester 0 (%s), assuming can reach via UDP.",
				1, pTNcrd->apTesters[0]->m_szComputerName);

			pTNcrd->fCanRun = TRUE;
		} // end if (are on same machine)
		else
		{
			hr = pTNcrd->pMaster->CanReachViaIP(pTNcrd->apTesters[i],
												pTNcrd->apTesters[0],
												DPLAY8_PORT,
												TNCR_IP_UDP,
												&(pTNcrd->fCanRun));
			if (hr != S_OK)
			{
				DPL(0, "Couldn't have tester %i (%s) try to reach tester 0 (%s) via UDP!",
					3, i, pTNcrd->apTesters[i]->m_szComputerName,
					pTNcrd->apTesters[0]->m_szComputerName);

				return (hr);
			} // end if (couldn't test reachability)

			if (! pTNcrd->fCanRun)
			{
				DPL(1, "Tester %i (%s) can't reach tester 0 (%s) via UDP.",
					3, i, pTNcrd->apTesters[i]->m_szComputerName,
					pTNcrd->apTesters[0]->m_szComputerName);

				return (S_OK);
			} // end if (tester couldn't reach tester 0)
		} // end else (not on same machine)
	} // end for (each tester after 0)

	return (S_OK);
} // ConnexCanRun_ServerLoss
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_ServerLoss()"
//==================================================================================
// ConnexExec_ServerLoss
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.4.1 - Server leave test
//				2.7.4.2 - Server drop test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_ServerLoss(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PTOD_BBLDDP8_CS_CREATE_0		pBldDP8CSCreateOutput0 = NULL;
	PTOD_BBLDDP8_CS_CREATE_NOT0		pBldDP8CSCreateOutputNot0 = NULL;
	DWORD							dwSubOutputDataSize;
	CONNEXSERVERLOSSCONTEXT			context;
	DPN_APPLICATION_DESC			dpnad;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	PTNFAULTSIM						pFaultSim = NULL;
	int								i;



	ZeroMemory(&context, sizeof (CONNEXSERVERLOSSCONTEXT));
	context.pTNecd = pTNecd;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating client/server session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if (pTNecd->iTesterNum == 0)
			context.pfnDPNMessageHandler = ConnexServerLossServerDPNMessageHandler;
		else
			context.pfnDPNMessageHandler = ConnexServerLossClientDPNMessageHandler;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_ALL_CREATE));
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.2.1",
												pvSubInputData,
												sizeof (TID_BBLDDP8_ALL_CREATE),
												0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPL(0, "Couldn't execute sub test case BldSsn:BldCS:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.1",
									"Creating client/server session failed!");

		// Otherwise get the object created.
		if (pTNecd->iTesterNum == 0)
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutput0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_0) + (pTNecd->iNumMachines * sizeof (DPNID))));

			pDP8Server = pBldDP8CSCreateOutput0->pDP8Server;
			pDP8Server->m_dwRefCount++; // we're using it during this function
			context.padpnidTesters = (DPNID*) (pBldDP8CSCreateOutput0 + 1);
		} // end if (tester 0)
		else
		{
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutputNot0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_CS_CREATE_NOT0) + (pTNecd->iNumMachines * sizeof (DPNID))));

			pDP8Client = pBldDP8CSCreateOutputNot0->pDP8Client;
			pDP8Client->m_dwRefCount++; // we're using it during this function
			context.padpnidTesters = (DPNID*) (pBldDP8CSCreateOutputNot0 + 1);
		} // end else (not tester 0)



		if (pTNecd->iTesterNum == 0)
		{
			// Servers need to allocate an array for delete player indications.
			LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
								(pTNecd->iNumMachines * sizeof (BOOL)));
		} // end if (tester 0)


		context.hDisconnectEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (context.hDisconnectEvent == NULL)
		{
			sr = GetLastError();
			DPL(0, "Couldn't create disconnect event!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't create event)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready for server disconnection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Ready for disconnect", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.7.4.2"))
			{
				// We do NOT expect our local player to be removed.
				context.fSelfIndicate = FALSE;


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating IMTest fault simulator");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
														TN_FAULTSIM_IMTEST,
														NULL,
														0);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't create IMTest fault simulator!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create fault simulator)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Disconnecting sends and receives, will drop from session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't disconnect sends!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't disconnect)

				sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't disconnect receives!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't disconnect)



#pragma TODO(vanceo, "Timeout (be able to set protocol caps: keepalives?)")
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for connections to all other players to drop");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hDisconnectEvent,
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;





				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Restoring send and receive traffic");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't reconnect sends!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)

				sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't reconnect receives!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't reconnect)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing IMTest fault simulator");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't release fault simulator %x!", 1, pFaultSim);
					THROW_SYSTEMRESULT;
				} // end if (couldn't release fault simulator)
			} // end if (drop case)
			TESTSECTION_ENDIF



			// We expect our own player to be removed.
			context.fSelfIndicate = TRUE;


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Disconnecting from session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)


			// Make sure the nametable has been unwound properly.
			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				if (! context.pafTesterIndicated[i])
				{
					DPL(0, "Haven't received DELETE_PLAYER for tester %i!", 1, i);
					SETTHROW_TESTRESULT(E_FAIL);
				} // end if (tester hasn't been deleted)
			} // end for (each tester)
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connection to server to drop");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hDisconnectEvent,
														1,
														NULL,
														-1,
														INFINITE,
														NULL);
			HANDLE_WAIT_RESULT;
		} // end else (not tester 0)
		TESTSECTION_ENDIF



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Making sure everyone survived server disconnection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Server object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)


			sr = g_pDP8ServersList->RemoveFirstReference(pDP8Server);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't remove DirectPlay8Server wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)


			pDP8Server->m_dwRefCount--; // release our reference
			if (pDP8Server->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Server wrapper object %x.",
					1, pDP8Server);
				delete (pDP8Server);
			} // end if (can delete the object)
			else
			{
				DPL(7, "Can't delete DirectPlay8Server wrapper object %x, it's refcount is %u.",
					2, pDP8Server,
					pDP8Server->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Server = NULL;
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Client object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)


			sr = g_pDP8ClientsList->RemoveFirstReference(pDP8Client);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't remove DirectPlay8Client wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)


			pDP8Client->m_dwRefCount--; // release our reference
			if (pDP8Client->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Client wrapper object %x.",
					1, pDP8Client);
				delete (pDP8Client);
			} // end if (can delete the object)
			else
			{
				DPL(7, "Can't delete DirectPlay8Client wrapper object %x, it's refcount is %u.",
					2, pDP8Client,
					pDP8Client->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Client = NULL;
		} // end else (not tester 0)
		TESTSECTION_ENDIF




		FINAL_SUCCESS;
	}
	END_TESTCASE



	if (pDP8Server != NULL)
	{
		temphr = pDP8Server->DP8S_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing server interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing server interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ServersList->RemoveFirstReference(pDP8Server);


		pDP8Server->m_dwRefCount--;
		if (pDP8Server->m_dwRefCount == 0)
		{
			DPL(7, "Deleting wrapper object %x.", 1, pDP8Server);
			delete (pDP8Server);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete wrapper object %x, it's refcount is %u!?",
				2, pDP8Server, pDP8Server->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		temphr = pDP8Client->DP8C_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing client interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing client interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8ClientsList->RemoveFirstReference(pDP8Client);


		pDP8Client->m_dwRefCount--;
		if (pDP8Client->m_dwRefCount == 0)
		{
			DPL(7, "Deleting DirectPlay8Client wrapper object %x.", 1, pDP8Client);
			delete (pDP8Client);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete DirectPlay8Client wrapper object %x, it's refcount is %u!?",
				2, pDP8Client, pDP8Client->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Client = NULL;
	} // end if (have client object)

	SAFE_CLOSEHANDLE(context.hDisconnectEvent);
	SAFE_LOCALFREE(context.pafTesterIndicated);

	return (sr);
} // ConnexExec_ServerLoss
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_Reject()"
//==================================================================================
// ConnexExec_Reject
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.5.1 - Simple peer reject connections test
//				2.7.5.2 - Simple client/server reject connections test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_Reject(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	CONNEXREJECTCONTEXT		context;
	DPN_APPLICATION_DESC	dpnad;
	CTNSyncDataList			syncdata;
	PVOID					pvSyncData;
	DWORD					dwSyncDataSize;
	BOOL					fClientServer = FALSE;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8SERVER			pDP8Server = NULL;
	PWRAPDP8CLIENT			pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressLocal = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressRemote = NULL;
	DPNHANDLE				dpnhConnect = NULL;
	PHOSTADDRESSESSYNCDATA	pHostAddressesSyncData = NULL;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	DWORD					dwNumAddresses = 0;
	DWORD					dwTemp;
	DWORD					dwURLsBufferSize = 0;
	DWORD					dwRemainingBufferSize;
	char*					pszURL;
	DWORD					dwSize;
	DWORD					dwDataType;
	char					szIPString[16]; // max IP string size + NULL termination
	WCHAR					wszIPCompareString[16]; // max IP string size + NULL termination



	ZeroMemory(&context, sizeof (CONNEXREJECTCONTEXT));
	context.pTNecd = pTNecd;



	BEGIN_TESTCASE
	{
		TESTSECTION_IF(pTNecd->pExecutor->IsCase("2.7.5.2"))
		{
			fClientServer = TRUE;

			TESTSECTION_IF(pTNecd->iTesterNum == 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Server object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Server = new (CWrapDP8Server);
				if (pDP8Server == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)


				tr = pDP8Server->CoCreate();
				if (tr != DPN_OK)
				{
					DPL(0, "CoCreating DP8Server object failed!", 0);
					THROW_TESTRESULT;
				} // end if (function failed)
			} // end if (tester 0)
			TESTSECTION_ELSE
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Client = new (CWrapDP8Client);
				if (pDP8Client == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)


				tr = pDP8Client->CoCreate();
				if (tr != DPN_OK)
				{
					DPL(0, "CoCreating DP8Client object failed!", 0);
					THROW_TESTRESULT;
				} // end if (function failed)
			} // end else (not tester 0)
			TESTSECTION_ENDIF
		} // end if (client/server)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8Peer = new (CWrapDP8Peer);
			if (pDP8Peer == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8Peer->CoCreate();
			if (tr != DPN_OK)
			{
				DPL(0, "CoCreating DP8Peer object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)
		} // end else (peer-to-peer)
		TESTSECTION_ENDIF



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating local address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressLocal);
		if (sr != S_OK)
		{
			DPL(0, "Couldn't CoCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != S_OK)
		{
			DPL(0, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if (fClientServer)
		{
			if (pTNecd->iTesterNum == 0)
			{
				tr = pDP8Server->DP8S_Initialize(&context,
												ConnexRejectDPNMessageHandler,
												0);
			} // end if (tester 0)
			else
			{
				tr = pDP8Client->DP8C_Initialize(&context,
												ConnexRejectDPNMessageHandler,
												0);
			} // end else (not tester 0)
		} // end if (client/server)
		else
		{
			tr = pDP8Peer->DP8P_Initialize(&context,
											ConnexRejectDPNMessageHandler,
											0);
		} // end else (peer-to-peer)

		if (tr != S_OK)
		{
			DPL(0, "Couldn't initialize!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		if ((pTNecd->iTesterNum == 0) && (fClientServer))
			dpnad.dwFlags |= DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
#pragma TODO(vanceo, "Get real GUID")
		dpnad.guidApplication = GUID_ENUMS_SIMPLE;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = (pTNecd->iTesterNum == 0) ? L"Session" : NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;



		/*
		context.dwConnectDataSize = pInput->dwConnectDataSize;
		if (context.dwConnectDataSize > 0)
		{
			LOCALALLOC_OR_THROW(PVOID, context.pvConnectData, context.dwConnectDataSize);

			// Fill the memory with some pattern (different for connects vs.
			// responses).
			FillWithDWord(context.pvConnectData, context.dwConnectDataSize,
						((pTNecd->iTesterNum == 0) ? DATAPATTERN_REPLY : DATAPATTERN_CONNECT));
		} // end if (data should be sent)
		*/

		CREATEEVENT_OR_THROW(context.hConnectEvent,
							NULL, FALSE, FALSE, NULL);



		// Tester 0 should start hosting a session, tester 1 should wait until
		// the session is up.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				tr = pDP8Server->DP8S_Host(&dpnad, &pDP8AddressLocal, 1, NULL, NULL,
											NULL, 0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_Host(&dpnad, &pDP8AddressLocal, 1, NULL, NULL,
										NULL, 0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't start hosting session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)


			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting host addresses");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				tr = pDP8Server->DP8S_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);
			} // end else (peer-to-peer)

			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get number of host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)



			DPL(1, "We are hosting on %u addresses.", 1, dwNumAddresses); 


			LOCALALLOC_OR_THROW(PDIRECTPLAY8ADDRESS*, paDP8HostAddresses,
								dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));


			if (fClientServer)
			{
				tr = pDP8Server->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
															&dwNumAddresses,
															0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_GetLocalHostAddresses(paDP8HostAddresses,
														&dwNumAddresses,
														0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)


			// Get the total size of all the addresses.
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = 0;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(NULL, &dwSize);
				if (tr != DPNERR_BUFFERTOOSMALL)
				{
					DPL(0, "Couldn't get host address %u's URL size!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (not buffer too small)
				
				dwURLsBufferSize += dwSize;
			} // end for (each address)

			// Allocate a buffer for all the URLs.
			LOCALALLOC_OR_THROW(PHOSTADDRESSESSYNCDATA,
								pHostAddressesSyncData,
								sizeof (HOSTADDRESSESSYNCDATA) + dwURLsBufferSize);

			pHostAddressesSyncData->dwNumAddresses = dwNumAddresses;
			pszURL = (char*) (pHostAddressesSyncData + 1);
			dwRemainingBufferSize = dwURLsBufferSize;


			// Actually fill in all the URLs and release the objects (since we're
			// done with them).
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = dwRemainingBufferSize;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(pszURL,
														&dwSize);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host address %u's URL!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (failed)


				DPL(1, "Address %u: \"%s\"",
					2, dwTemp, pszURL);

				dwRemainingBufferSize -= dwSize;
				pszURL += dwSize;

				
				// We're done with this address object.
				paDP8HostAddresses[dwTemp]->Release();
				paDP8HostAddresses[dwTemp] = NULL;
			} // end for (each address)

			// We're done with the address array.
			LocalFree(paDP8HostAddresses);
			paDP8HostAddresses = NULL;


			// Make sure we used all of the buffer.
			if (dwRemainingBufferSize != 0)
			{
				DPL(0, "Didn't use all of or overran the allocated buffer (didn't use %i bytes)!",
					1, ((int) dwRemainingBufferSize));
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (didn't use all of the buffer)



			CREATEEVENT_OR_THROW(context.hReplyBufferReturnedEvent,
								NULL, FALSE, FALSE, NULL);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending session addresses to connector");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													pHostAddressesSyncData,
													(sizeof (HOSTADDRESSESSYNCDATA) + dwURLsBufferSize),
													NULL,
													0);
			HANDLE_SYNC_RESULT;


			LocalFree(pHostAddressesSyncData);
			pHostAddressesSyncData = NULL;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connection indication");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			// Make sure the reply data was returned, if we had any.
			if (context.pvConnectData != NULL)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for reply buffer to be returned");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hReplyBufferReturnedEvent,
															1, NULL, -1, INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;



				CloseHandle(context.hReplyBufferReturnedEvent);
				context.hReplyBufferReturnedEvent = NULL;
			} // end if (there's connect data)
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Receiving addresses of host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													NULL,
													0,
													&syncdata,
													0);
			HANDLE_SYNC_RESULT;

			CHECKANDGET_MINIMUM_SYNCDATA(syncdata, 0, pvSyncData, dwSyncDataSize,
										(sizeof (HOSTADDRESSESSYNCDATA) + (strlen(DPNA_HEADER_A) + 1)));


			dwNumAddresses = ((PHOSTADDRESSESSYNCDATA) pvSyncData)->dwNumAddresses;

			// Start with the first address
			pszURL = (char*) (((PBYTE) pvSyncData) + sizeof (HOSTADDRESSESSYNCDATA));



			DPL(1, "Tester 0 (host) has %u connectable addresses.",
				1, dwNumAddresses);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressRemote);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't CoCreate remote (host's) address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8AddressRemote->SetSP(&CLSID_DP8SP_TCPIP);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't set SP for remote (host's) address object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set SP)


#pragma TODO(vanceo, "Support other SPs")
			// Figure out what IP we should use to connect to the host.
			sr = pTNecd->pExecutor->GetTestersIPForPort(0, DPLAY8_PORT, szIPString);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't get tester 0's IP for port %u!",
					1, DPLAY8_PORT);
				THROW_SYSTEMRESULT;
			} // end if (couldn't get tester 0's IP)


			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				DPL(1, "Host address %u: %s", 2, dwTemp, pszURL);


				DPL(0, "Building remote address %u from string URL.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Building remote address %u from string URL.",
										1, dwTemp);


				tr = pDP8AddressRemote->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't build host's address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPL(0, "Getting remote address %u's hostname component.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Getting remote address %u's hostname component.",
										1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemote->GetComponentByName(DPNA_KEY_HOSTNAME,
															wszIPCompareString,
															&dwSize,
															&dwDataType);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host's address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPL(0, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPL(0, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(wszIPCompareString, szIPString, TRUE))
				{
					DPL(1, "Found IP address \"%s\", using host's address %u (\"%s\").",
						3, szIPString, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddresses)
			{
				DPL(0, "Couldn't find the correct host address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)


			// At this point, the remote address object has the correct host
			// address we should use when connecting.

			if (fClientServer)
			{
				tr = pDP8Client->DP8C_Connect(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											NULL,
											NULL,
											context.pvConnectData,
											context.dwConnectDataSize,
											context.hConnectEvent,
											&dpnhConnect,
											0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_Connect(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											NULL,
											NULL,
											context.pvConnectData,
											context.dwConnectDataSize,
											NULL,
											context.hConnectEvent,
											&dpnhConnect,
											0);
			} // end else (peer-to-peer)

			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)



			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			pDP8AddressRemote->Release();
			pDP8AddressRemote = NULL;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connection to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;
		} // end else (not tester 0)
		TESTSECTION_ENDIF


		CloseHandle(context.hConnectEvent);
		context.hConnectEvent = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to complete connect sequence");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Connect done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



	
		TESTSECTION_IF(fClientServer)
		{
			TESTSECTION_IF(pTNecd->iTesterNum == 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Server->DP8S_Close(0);
				if (tr != DPN_OK)
				{
					DPL(0, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Server object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Server->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Server object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)

				delete (pDP8Server);
				pDP8Server = NULL;
			} // end if (tester 0)
			TESTSECTION_ELSE
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->DP8C_Close(0);
				if (tr != DPN_OK)
				{
					DPL(0, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Client object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)

				delete (pDP8Client);
				pDP8Client = NULL;
			} // end else (not tester 0)
			TESTSECTION_ENDIF
		} // end if (client/server)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->DP8P_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8Peer);
			pDP8Peer = NULL;
		} // end else (peer-to-peer)
		TESTSECTION_ENDIF



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (paDP8HostAddresses != NULL)
	{
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			SAFE_RELEASE(paDP8HostAddresses[dwTemp]);
		} // end for (each address)

		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (have array of host addresses)

	SAFE_LOCALFREE(context.pvConnectData);
	SAFE_LOCALFREE(pHostAddressesSyncData);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_CLOSEHANDLE(context.hConnectEvent);
	SAFE_CLOSEHANDLE(context.hReplyBufferReturnedEvent);


	return (sr);
} // ConnexExec_Reject
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexExec_NotAllowed()"
//==================================================================================
// ConnexExec_NotAllowed
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.7.6.1 - All not-allowed connection types test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ConnexExec_NotAllowed(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult						sr;
	CTNTestResult						tr;
	CONNEXNOTALLOWEDCONTEXT				context;
	DPN_APPLICATION_DESC				dpnadCS;
	DPN_APPLICATION_DESC				dpnadPeer;
	CTNSyncDataList						syncdata;
	PVOID								pvSyncData;
	DWORD								dwSyncDataSize;
	PWRAPDP8PEER						pDP8PeerHost = NULL;
	PWRAPDP8PEER						pDP8PeerClient = NULL;
	PWRAPDP8SERVER						pDP8Server = NULL;
	PWRAPDP8CLIENT						pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressLocal = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressRemoteCS = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressRemotePeer = NULL;
	DPNHANDLE							dpnhConnect = NULL;
	PHOSTADDRESSESCSANDPEERSYNCDATA		pHostAddressesCSAndPeerSyncData = NULL;
	PDIRECTPLAY8ADDRESS*				paDP8HostAddresses = NULL;
	DWORD								dwNumAddressesCS = 0;
	DWORD								dwNumAddressesPeer = 0;
	DWORD								dwTemp;
	DWORD								dwURLsBufferSize = 0;
	DWORD								dwRemainingBufferSize;
	char*								pszURL;
	DWORD								dwSize;
	DWORD								dwDataType;
	char								szIPString[16]; // max IP string size + NULL termination
	WCHAR								wszIPCompareString[16]; // max IP string size + NULL termination



	ZeroMemory(&context, sizeof (CONNEXNOTALLOWEDCONTEXT));
	context.pTNecd = pTNecd;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new (CWrapDP8Client);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)


		tr = pDP8Client->CoCreate();
		if (tr != DPN_OK)
		{
			DPL(0, "CoCreating DP8Client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (function failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8PeerClient = new (CWrapDP8Peer);
		if (pDP8PeerClient == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)


		tr = pDP8PeerClient->CoCreate();
		if (tr != DPN_OK)
		{
			DPL(0, "CoCreating DP8Peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (function failed)



		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating DirectPlay8Server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8Server = new (CWrapDP8Server);
			if (pDP8Server == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8Server->CoCreate();
			if (tr != DPN_OK)
			{
				DPL(0, "CoCreating DP8Server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating secondary DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8PeerHost = new (CWrapDP8Peer);
			if (pDP8PeerClient == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8PeerHost->CoCreate();
			if (tr != DPN_OK)
			{
				DPL(0, "CoCreating DP8Peer object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)
		} // end if (tester 0)
		TESTSECTION_ENDIF





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating local address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressLocal);
		if (sr != S_OK)
		{
			DPL(0, "Couldn't CoCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != S_OK)
		{
			DPL(0, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing objects");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Initialize(&context,
										ConnexNotAllowedDPNMessageHandler,
										0);
		if (tr != S_OK)
		{
			DPL(0, "Couldn't initialize client interface!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


		tr = pDP8PeerClient->DP8P_Initialize(&context,
											ConnexNotAllowedDPNMessageHandler,
											0);
		if (tr != S_OK)
		{
			DPL(0, "Couldn't initialize peer client interface!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


		if (pTNecd->iTesterNum == 0)
		{
			tr = pDP8Server->DP8S_Initialize(&context,
											ConnexNotAllowedDPNMessageHandler,
											0);
			if (tr != S_OK)
			{
				DPL(0, "Couldn't initialize server interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't initialize)


			tr = pDP8PeerHost->DP8P_Initialize(&context,
												ConnexNotAllowedDPNMessageHandler,
												0);
			if (tr != S_OK)
			{
				DPL(0, "Couldn't initialize peer host interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't initialize)
		} // end if (tester 0)





		ZeroMemory(&dpnadCS, sizeof (DPN_APPLICATION_DESC));
		dpnadCS.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnadCS.dwFlags = 0;
		dpnadCS.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnadCS.guidInstance = GUID_NULL;
#pragma TODO(vanceo, "Get real GUID")
		dpnadCS.guidApplication = GUID_ENUMS_SIMPLE;
		//dpnadCS.dwMaxPlayers = 0;
		//dpnadCS.dwCurrentPlayers = 0;
		dpnadCS.pwszSessionName = (pTNecd->iTesterNum == 0) ? L"Session" : NULL;
		//dpnadCS.pwszPassword = NULL;
		//dpnadCS.pvReservedData = NULL;
		//dpnadCS.dwReservedDataSize = 0;
		//dpnadCS.pvApplicationReservedData = NULL;
		//dpnad.CSpvApplicationReservedData = 0;



		ZeroMemory(&dpnadPeer, sizeof (DPN_APPLICATION_DESC));
		dpnadPeer.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnadPeer.dwFlags = 0;
		dpnadPeer.dwFlags = 0;
		//dpnadPeer.guidInstance = GUID_NULL;
#pragma TODO(vanceo, "Get real GUID")
		dpnadPeer.guidApplication = GUID_ENUMS_SIMPLE;
		//dpnadPeer.dwMaxPlayers = 0;
		//dpnadPeer.dwCurrentPlayers = 0;
		dpnadPeer.pwszSessionName = (pTNecd->iTesterNum == 0) ? L"Session" : NULL;
		//dpnadPeer.pwszPassword = NULL;
		//dpnadPeer.pvReservedData = NULL;
		//dpnadPeer.dwReservedDataSize = 0;
		//dpnadPeer.pvApplicationReservedData = NULL;
		//dpnadPeer.pvApplicationReservedData = 0;




		// Tester 0 should start hosting the sessions, tester 1 should wait until
		// they are up.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_Host(&dpnadCS, &pDP8AddressLocal, 1, NULL, NULL,
										NULL, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't start hosting client/server session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_Host(&dpnadPeer, &pDP8AddressLocal, 1, NULL, NULL,
										NULL, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't start hosting peer session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting number of host addresses for client/server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_GetLocalHostAddresses(NULL, &dwNumAddressesCS, 0);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get number of client/server host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get local host addresses)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting number of host addresses for peer-to-peer");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_GetLocalHostAddresses(NULL, &dwNumAddressesPeer, 0);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get number of peer-to-peer host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get local host addresses)




			DPL(1, "We are hosting on %u C/S addresses and %u peer addresses.",
				2, dwNumAddressesCS, dwNumAddressesPeer); 


			LOCALALLOC_OR_THROW(PDIRECTPLAY8ADDRESS*, paDP8HostAddresses,
								(dwNumAddressesCS + dwNumAddressesPeer) * sizeof (PDIRECTPLAY8ADDRESS));



			tr = pDP8Server->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
														&dwNumAddressesCS,
														0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get c/s host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't local host addresses)


			tr = pDP8PeerHost->DP8P_GetLocalHostAddresses(paDP8HostAddresses + dwNumAddressesCS,
														&dwNumAddressesPeer,
														0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get peer host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't local host addresses)



			// Connect the client objects.
			context.fConnectsAllowed = TRUE;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting local c/s client to local session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			context.hrExpectedResult = DPN_OK;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										paDP8HostAddresses[0],
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										NULL,
										NULL,
										DPNCONNECT_SYNC);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't connect!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting local peer client to local session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											paDP8HostAddresses[dwNumAddressesCS],
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											NULL,
											NULL,
											DPNCONNECT_SYNC);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't connect!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)


			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;


			// No more connects should ever be allowed or expected.
			context.fConnectsAllowed = FALSE;



			// Get the total size of all the addresses.
			for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
			{
				dwSize = 0;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(NULL, &dwSize);
				if (tr != DPNERR_BUFFERTOOSMALL)
				{
					DPL(0, "Couldn't get host address %u's URL size!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (not buffer too small)
				
				dwURLsBufferSize += dwSize;
			} // end for (each address)

			// Allocate a buffer for all the URLs.
			LOCALALLOC_OR_THROW(PHOSTADDRESSESCSANDPEERSYNCDATA,
								pHostAddressesCSAndPeerSyncData,
								sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + dwURLsBufferSize);

			pHostAddressesCSAndPeerSyncData->dwNumAddressesCS = dwNumAddressesCS;
			pHostAddressesCSAndPeerSyncData->dwNumAddressesPeer = dwNumAddressesPeer;
			pszURL = (char*) (pHostAddressesCSAndPeerSyncData + 1);
			dwRemainingBufferSize = dwURLsBufferSize;


			// Actually fill in all the URLs and release the objects (since we're
			// done with them).
			for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
			{
				dwSize = dwRemainingBufferSize;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(pszURL,
														&dwSize);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host address %u's URL!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (failed)


				DPL(1, "Address %u: \"%s\"",
					2, dwTemp, pszURL);

				dwRemainingBufferSize -= dwSize;
				pszURL += dwSize;

				
				// We're done with this address object.
				paDP8HostAddresses[dwTemp]->Release();
				paDP8HostAddresses[dwTemp] = NULL;
			} // end for (each address)

			// We're done with the address array.
			LocalFree(paDP8HostAddresses);
			paDP8HostAddresses = NULL;


			// Make sure we used all of the buffer.
			if (dwRemainingBufferSize != 0)
			{
				DPL(0, "Didn't use all of or overran the allocated buffer (didn't use %i bytes)!",
					1, ((int) dwRemainingBufferSize));
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (didn't use all of the buffer)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending session addresses to connector");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													pHostAddressesCSAndPeerSyncData,
													(sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + dwURLsBufferSize),
													NULL,
													0);
			HANDLE_SYNC_RESULT;


			LocalFree(pHostAddressesCSAndPeerSyncData);
			pHostAddressesCSAndPeerSyncData = NULL;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connector to finish connecting to wrong interface type");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Receiving addresses of host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Host addresses",
													NULL,
													0,
													&syncdata,
													0);
			HANDLE_SYNC_RESULT;

			CHECKANDGET_MINIMUM_SYNCDATA(syncdata, 0, pvSyncData, dwSyncDataSize,
										(sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + ((strlen(DPNA_HEADER_A) + 1) * 2)));


			dwNumAddressesCS = ((PHOSTADDRESSESCSANDPEERSYNCDATA) pvSyncData)->dwNumAddressesCS;
			dwNumAddressesPeer = ((PHOSTADDRESSESCSANDPEERSYNCDATA) pvSyncData)->dwNumAddressesPeer;

			// Start with the first address
			pszURL = (char*) (((PBYTE) pvSyncData) + sizeof (HOSTADDRESSESCSANDPEERSYNCDATA));



			DPL(1, "Tester 0 (host) has %u c/s and %u peer connectable addresses.",
				2, dwNumAddressesCS, dwNumAddressesPeer);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) client/server address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressRemoteCS);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't CoCreate remote (host's) client/server address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) peer-to-peer address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
								IID_IDirectPlay8Address, (LPVOID*) &pDP8AddressRemotePeer);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't CoCreate remote (host's) peer-to-peer address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate c/s address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma TODO(vanceo, "Support other SPs")
			// Figure out what IP we should use to connect to the host.
			sr = pTNecd->pExecutor->GetTestersIPForPort(0, DPLAY8_PORT, szIPString);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't get tester 0's IP for port %u!",
					1, DPLAY8_PORT);
				THROW_SYSTEMRESULT;
			} // end if (couldn't get tester 0's IP)


			for(dwTemp = 0; dwTemp < dwNumAddressesCS; dwTemp++)
			{
				DPL(1, "Host c/s address %u: %s", 2, dwTemp, pszURL);


				DPL(0, "Building remote c/s address %u from string URL.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Building remote c/s address %u from string URL.",
										1, dwTemp);


				tr = pDP8AddressRemoteCS->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't build host's c/s address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPL(0, "Getting remote c/s address %u's hostname component.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Getting remote c/s address %u's hostname component.",
										1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemoteCS->GetComponentByName(DPNA_KEY_HOSTNAME,
															wszIPCompareString,
															&dwSize,
															&dwDataType);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host's c/s address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPL(0, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPL(0, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(wszIPCompareString, szIPString, TRUE))
				{
					DPL(1, "Found IP address \"%s\", using host's c/s address %u (\"%s\").",
						3, szIPString, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddressesCS)
			{
				DPL(0, "Couldn't find the correct host c/s address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)



			// Move to the start of the peer addresses.
			while (dwTemp < dwNumAddressesCS)
			{
				pszURL += strlen(pszURL) + 1;
				dwTemp++;
			} // end for (each host address)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate peer address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			for(dwTemp = 0; dwTemp < dwNumAddressesPeer; dwTemp++)
			{
				DPL(1, "Host peer address %u: %s", 2, dwTemp, pszURL);


				DPL(0, "Building remote peer address %u from string URL.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Building remote peer address %u from string URL.",
										1, dwTemp);


				tr = pDP8AddressRemotePeer->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't build host's peer address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPL(0, "Getting remote peer address %u's hostname component.", 1, dwTemp);
				// Ignore error
				pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
										"Getting remote peer address %u's hostname component.",
										1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemotePeer->GetComponentByName(DPNA_KEY_HOSTNAME,
																wszIPCompareString,
																&dwSize,
																&dwDataType);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't get host's peer address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPL(0, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPL(0, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(wszIPCompareString, szIPString, TRUE))
				{
					DPL(1, "Found IP address \"%s\", using host's peer address %u (\"%s\").",
						3, szIPString, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddressesPeer)
			{
				DPL(0, "Couldn't find the correct host peer address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)



			CREATEEVENT_OR_THROW(context.hConnectCompletedEvent,
								NULL, FALSE, FALSE, NULL);



			// At this point, the remote address objects have the correct host
			// addresses we should use when connecting.


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to peer-to-peer session using client/server interface");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			context.hrExpectedResult = DPNERR_INVALIDINTERFACE;

			tr = pDP8Client->DP8C_Connect(&dpnadPeer,
										pDP8AddressRemotePeer,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDINTERFACE");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to client/server session using peer-to-peer interface");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_Connect(&dpnadCS,
											pDP8AddressRemoteCS,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDINTERFACE");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to client/server session with wrong instance GUID");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.guidInstance = GUID_UNKNOWN;

			context.hrExpectedResult = DPNERR_INVALIDINSTANCE;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDINSTANCE");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to peer-to-peer session with wrong instance GUID");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.guidInstance = GUID_UNKNOWN;

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDINSTANCE");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to client/server session with wrong application GUID");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.guidInstance = GUID_NULL;
			dpnadCS.guidApplication = GUID_UNKNOWN;

			context.hrExpectedResult = DPNERR_INVALIDAPPLICATION;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDAPPLICATION");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to peer-to-peer session with wrong application GUID");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.guidInstance = GUID_NULL;
			dpnadPeer.guidApplication = GUID_UNKNOWN;

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDAPPLICATION");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying host that we're ready to test max players");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		TESTSECTION_ENDIF


		sr = pTNecd->pExecutor->SyncWithTesters("Interfaces and GUIDs done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		// Tester 0 should cap the number of players allowed in the sessions, tester
		// 1 should wait until that's ready.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Limiting number of players allowed in client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.dwMaxPlayers = 2;

			tr = pDP8Server->DP8S_SetApplicationDesc(&dpnadCS, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't set application desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set application desc)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Limiting number of players allowed in peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.dwMaxPlayers = 2;

			tr = pDP8PeerHost->DP8P_SetApplicationDesc(&dpnadPeer, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't set application desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set application desc)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Telling connector to start trying to join maxxed out sessions");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for session player limits to be set");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		TESTSECTION_ENDIF


		sr = pTNecd->pExecutor->SyncWithTesters("Player limits set", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		// Tester 0 should wait until tester 1 has tried connecting to both sessions.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other tester to try connecting to maxxed out sessions");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to maxxed out client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.guidApplication = GUID_NULL;

			context.hrExpectedResult = DPNERR_SESSIONFULL;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with SESSIONFULL");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;







			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to maxxed out peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.guidApplication = GUID_NULL;

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with SESSIONFULL");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying host that we're ready to test invalid password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		TESTSECTION_ENDIF


		sr = pTNecd->pExecutor->SyncWithTesters("Player limit done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		// Tester 0 should set a password for the sessions, tester 1 should wait
		// until that's ready.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Removing player limit and setting password for client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.dwFlags = DPNSESSION_CLIENT_SERVER | DPNSESSION_REQUIREPASSWORD;
			dpnadCS.dwMaxPlayers = 0;
			dpnadCS.pwszPassword = L"I bet you can't get this password!";

			tr = pDP8Server->DP8S_SetApplicationDesc(&dpnadCS, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't set application desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set application desc)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Removing player limit and setting password for peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.dwFlags = DPNSESSION_REQUIREPASSWORD;
			dpnadPeer.dwMaxPlayers = 0;
			dpnadPeer.pwszPassword = L"I bet you can't get this password!";

			tr = pDP8PeerHost->DP8P_SetApplicationDesc(&dpnadPeer, 0);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't set application desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set application desc)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Telling connector to start trying to join password protected sessions");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for password to be set");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		TESTSECTION_ENDIF


		sr = pTNecd->pExecutor->SyncWithTesters("Password set", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;



		// Tester 0 should wait until tester 1 has tried connecting to both sessions.
		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Retrieving c/s client address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "Get real player ID")
			tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x00300003,
												&pDP8AddressRemoteCS,
												0);
			if (tr != DPN_OK)
			{
				DPL(0, "Getting c/s client address failed!", 0);
				THROW_TESTRESULT;
			} // end if (getting client address failed)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Retrieving peer client address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "Get real player ID")
			tr = pDP8PeerHost->DP8P_GetPeerAddress((DPNID) 0x00300003,
													&pDP8AddressRemotePeer,
													0);
			if (tr != DPN_OK)
			{
				DPL(0, "Getting peer client address failed!", 0);
				THROW_TESTRESULT;
			} // end if (getting peer address failed)




			dwSize = 0;
			dwURLsBufferSize = 0;

			tr = pDP8AddressRemoteCS->GetURLA(NULL, &dwSize);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get c/s client address' URL size!", 0);
				THROW_TESTRESULT;
			} // end if (not buffer too small)
			
			dwURLsBufferSize += dwSize;

			dwSize = 0;
			tr = pDP8AddressRemotePeer->GetURLA(NULL, &dwSize);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPL(0, "Couldn't get peer client address' URL size!", 0);
				THROW_TESTRESULT;
			} // end if (not buffer too small)
			
			dwURLsBufferSize += dwSize;




			// Allocate a buffer for both the URLs.
			pszURL = NULL;
			LOCALALLOC_OR_THROW(char*, pszURL, dwURLsBufferSize);




			dwSize = dwURLsBufferSize;
			tr = pDP8AddressRemoteCS->GetURLA(pszURL, &dwSize);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get c/s client address' URL!", 0);

				LocalFree(pszURL);
				pszURL = NULL;

				THROW_TESTRESULT;
			} // end if (failed)


			DPL(1, "C/S client address: \"%s\"", 1, pszURL);

			// We're done with this address object.
			pDP8AddressRemoteCS->Release();
			pDP8AddressRemoteCS = NULL;


			dwTemp = dwURLsBufferSize - dwSize;
			tr = pDP8AddressRemotePeer->GetURLA(pszURL + dwSize, &dwTemp);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't get peer client address' URL!", 0);

				LocalFree(pszURL);
				pszURL = NULL;

				THROW_TESTRESULT;
			} // end if (failed)

			DPL(1, "Peer client address: \"%s\"", 1, pszURL + dwSize);


			// We're done with this address object.
			pDP8AddressRemotePeer->Release();
			pDP8AddressRemotePeer = NULL;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other tester finish connecting to password protected sessions and sending clients' addresses");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Password set & non-host URLs",
													pszURL, dwURLsBufferSize,
													NULL, 0);
			HANDLE_SYNC_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for other tester to finish connecting to non-hosts");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		TESTSECTION_ELSE
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to password protected client/server session without a password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			context.hrExpectedResult = DPNERR_INVALIDPASSWORD;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDPASSWORD");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to password protected peer-to-peer session without a password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDPASSWORD");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to password protected client/server session with wrong password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.pwszPassword = L"This is most definitely not the password.";

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDPASSWORD");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to password protected peer-to-peer session with wrong password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.pwszPassword = L"This is most definitely not the password.";

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with INVALIDPASSWORD");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Retrieving non-host addresses");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Password set & non-host URLs",
													NULL, 0, &syncdata, 0);
			HANDLE_SYNC_RESULT;



			CHECKANDGET_MINIMUM_SYNCDATA(syncdata, 0, pszURL, dwSyncDataSize,
										((strlen(DPNA_HEADER_A) + 1) * 2));



			tr = pDP8AddressRemoteCS->BuildFromURLA(pszURL);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't build host's C/S address from URL (\"%s\")!",
					1, pszURL);
				THROW_TESTRESULT;
			} // end if (couldn't build from URL)

			pszURL += strlen(pszURL) + 1;


			tr = pDP8AddressRemotePeer->BuildFromURLA(pszURL);
			if (tr != DPN_OK)
			{
				DPL(0, "Couldn't build host's peer address from URL (\"%s\")!",
					1, pszURL);
				THROW_TESTRESULT;
			} // end if (couldn't build from URL)






			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to client in client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			context.hrExpectedResult = DPNERR_NORESPONSE;

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										pDP8AddressRemoteCS,
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										context.hConnectCompletedEvent,
										&dpnhConnect,
										0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with NORESPONSE");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to peer client in peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			context.hrExpectedResult = DPNERR_NOTHOST;

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											context.hConnectCompletedEvent,
											&dpnhConnect,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPL(0, "Couldn't start connecting!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connect to complete with NOTHOST");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hConnectCompletedEvent, 1,
														NULL, -1, INFINITE, NULL);
			HANDLE_WAIT_RESULT;




			CloseHandle(context.hConnectCompletedEvent);
			context.hConnectCompletedEvent = NULL;




			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			pDP8AddressRemoteCS->Release();
			pDP8AddressRemoteCS = NULL;

			pDP8AddressRemotePeer->Release();
			pDP8AddressRemotePeer = NULL;




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying host that we're done");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		TESTSECTION_ENDIF



		sr = pTNecd->pExecutor->SyncWithTesters("All connects done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPL(0, "Closing failed!", 0);
			THROW_TESTRESULT;
		} // end if (close failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPL(0, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerClient->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPL(0, "Closing failed!", 0);
			THROW_TESTRESULT;
		} // end if (close failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerClient->Release();
		if (tr != S_OK)
		{
			DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerClient);
		pDP8PeerClient = NULL;




		TESTSECTION_IF(pTNecd->iTesterNum == 0)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Server object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8Server);
			pDP8Server = NULL;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing peer host object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_Close(0);
			if (tr != DPN_OK)
			{
				DPL(0, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->Release();
			if (tr != S_OK)
			{
				DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8PeerHost);
			pDP8PeerHost = NULL;
		} // end if (tester 0)
		TESTSECTION_ENDIF




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8PeerClient != NULL)
	{
		delete (pDP8PeerClient);
		pDP8PeerClient = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)


	if (paDP8HostAddresses != NULL)
	{
		for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
		{
			SAFE_RELEASE(paDP8HostAddresses[dwTemp]);
		} // end for (each address)

		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (have array of host addresses)

	SAFE_LOCALFREE(pHostAddressesCSAndPeerSyncData);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemoteCS);
	SAFE_RELEASE(pDP8AddressRemotePeer);
	SAFE_CLOSEHANDLE(context.hConnectCompletedEvent);


	return (sr);
} // ConnexExec_NotAllowed
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexLeaveWhileJoinPeerDPNMessageHandler()"
//==================================================================================
// ConnexLeaveWhileJoinPeerDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexLeaveWhileJoinPeerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PCONNEXLEAVEWHILEJOINCONTEXT	pContext = (PCONNEXLEAVEWHILEJOINCONTEXT) pvContext;
	DWORD							dwSize = 0;
	PDPN_PLAYER_INFO				pdpnpi = NULL;
	int								iTesterNum;
	BOOL							fFound;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			

#pragma TODO(vanceo, "Just fail test")
			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPL(0, "Failed connecting!  DEBUGBREAK()-ing.  0x%08x", 1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
			}


			// The connect context was a message handle, so set it.
			if (! SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set ConnectCompletion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pConnectCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				//goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			// If we're rejoining, make sure the nametable we're rebuilding is
			// correct.
			if ((pContext->pTNecd->iTesterNum == pContext->iCurrentJoiningPlayer) &&
				(pContext->fSelfIndicate))
			{
				hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pCreatePlayerMsg->dpnidPlayer,
															NULL,
															&dwSize,
															0);
				if (hr != DPNERR_BUFFERTOOSMALL)
				{
					DPL(0, "Getting peer info didn't return expected error BUFFERTOOSMALL!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (didn't return expected error)

				pdpnpi = (PDPN_PLAYER_INFO) MemAlloc(LPTR, dwSize);
				if (pdpnpi == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

				hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pCreatePlayerMsg->dpnidPlayer,
															pdpnpi,
															&dwSize,
															0);
				if (hr != DPN_OK)
				{
					DPL(0, "Getting peer info failed!  DEBUGBREAK()-ing.  0x%08x", 1, hr);

					DEBUGBREAK();

					goto DONE;
				} // end if (didn't return expected error)

				if (pdpnpi->dwPlayerFlags & DPNPLAYER_LOCAL)
				{
					if (pContext->pafTesterIndicated[pContext->pTNecd->iTesterNum])
					{
						DPL(0, "Got duplicate CREATE_PLAYER for the local player (tester %i, prev player ID = %u/%x, new player ID = %u/%x)!  DEBUGBREAK()-ing.",
							5, pContext->pTNecd->iTesterNum,
							pContext->padpnidTesters[pContext->pTNecd->iTesterNum],
							pContext->padpnidTesters[pContext->pTNecd->iTesterNum],
							pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate CREATE_PLAYER for the local player!",
														0);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (already found the player)

					pContext->padpnidTesters[pContext->pTNecd->iTesterNum] = pCreatePlayerMsg->dpnidPlayer;


					iTesterNum = pContext->pTNecd->iTesterNum;


					DPL(1, "Local tester (%i, player ID %u/%x) has connected.",
						3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
						pCreatePlayerMsg->dpnidPlayer);
				} // end if (it's our local player)
				else
				{
					fFound = FALSE;

					// Lookup this ID in the list of IDs everyone who had previously
					// joined (except ourselves).
					for(iTesterNum = 0; iTesterNum <= pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// Skip our ID if this is it.
						if (iTesterNum == pContext->pTNecd->iTesterNum)
							continue;

						// If we found the tester ID
						if (pContext->padpnidTesters[iTesterNum] == pCreatePlayerMsg->dpnidPlayer)
						{
							// If that player already connected, something's wrong.
							if (pContext->pafTesterIndicated[iTesterNum])
							{
								DPL(0, "Got duplicate CREATE_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
									3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
									pCreatePlayerMsg->dpnidPlayer);

								//Ignore error
								pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																"Got duplicate CREATE_PLAYER for tester %i!",
																1, iTesterNum);

								DEBUGBREAK();

								hr = E_FAIL;
								goto DONE;
							} // end if (player already connected)


							DPL(1, "Tester %i (player ID %u/%x) has connected.",
								3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
								pCreatePlayerMsg->dpnidPlayer);

							fFound = TRUE;
							break;
						} // end if (found)
					} // end for (each tester who's already joined)


					// If we didn't recognize that player ID, we're screwed.
					if (! fFound)
					{
						DPL(0, "Got CREATE_PLAYER for unexpected player ID %u/%x!  DEBUGBREAK()-ing.",
							2, pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got CREATE_PLAYER for unexpected player ID %u/%x!",
														2, pCreatePlayerMsg->dpnidPlayer,
														pCreatePlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (didn't find player ID)


					// If we ensured that the dropping player couldn't connect, but here
					// he is, we've got a problem.
					if (iTesterNum == pContext->iCurrentDroppingPlayer)
					{
						if (pContext->fEnsureDisconnectBeforeJoin)
						{
							DPL(0, "Got CREATE_PLAYER for dropping player (tester %i, player ID %u/%x) even he should have been disconnected before we joined!  DEBUGBREAK()-ing.",
								3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
								pCreatePlayerMsg->dpnidPlayer);
							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
															"Got CREATE_PLAYER for dropping player (tester %i, player ID %u/%x) even he should have been disconnected before we joined!",
															3, iTesterNum,
															pCreatePlayerMsg->dpnidPlayer,
															pCreatePlayerMsg->dpnidPlayer);

							DEBUGBREAK();

							hr = E_FAIL;
							goto DONE;
						} // end if (ensured disconnect)
						else
						{
							DPL(0, "Got CREATE_PLAYER for dropping player (tester %i, player ID %u/%x), we'd better get a DESTROY_PLAYER soon.",
								3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
								pCreatePlayerMsg->dpnidPlayer);
							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_IMPORTANT | TNLF_PREFIX_TESTUNIQUEID,
															"Got CREATE_PLAYER for dropping player (tester %i, player ID %u/%x), we'd better get a DESTROY_PLAYER soon.",
															3, iTesterNum,
															pCreatePlayerMsg->dpnidPlayer,
															pCreatePlayerMsg->dpnidPlayer);
						} // end else (didn't ensure disconnect)
					} // end if (dropping player
				} // end else (it's some other player)


				// Associate the context with this player.
				//pCreatePlayerMsg->pvPlayerContext = &(pContext->paiReliableMsgsReceivedFromTesters[iTesterNum]);

				//DPL(8, "Player context is now %x.", 1, pCreatePlayerMsg->pvPlayerContext);


				pContext->pafTesterIndicated[iTesterNum] = TRUE;


				// See if that's the last person we're waiting on to connect.
				for(iTesterNum = 0; iTesterNum < pContext->pTNecd->iNumMachines; iTesterNum++)
				{
					// Don't worry about the dropping tester.
					if (iTesterNum == pContext->iCurrentDroppingPlayer)
						continue;


					if (! pContext->pafTesterIndicated[iTesterNum])
					{
						DPL(4, "Still expecting tester %i to connect, not notifying main thread.",
							1, iTesterNum);
						// No sense in looking further, just return OK.
						goto DONE;
					} // end if (tester hasn't connected yet)
				} // end for (each tester who's already joined)


				// If we got here, it means all the testers that should have connected
				// (including ourselves) did.  Notify the main thread.

				DPL(2, "All testers expected to connect actually have, notifying main thread.", 0);

				if (! SetEvent(pContext->hDroppedAndJoinedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set dropped and joined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hDroppedAndJoinedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (we're the rejoining player)
			else
			{
				if (pContext->padpnidTesters[pContext->iCurrentJoiningPlayer] != 0)
				{
					DPL(0, "Got duplicate CREATE_PLAYER for rejoining player (tester %i, prev player ID = %u/%x, new player ID = %u/%x)!  DEBUGBREAK()-ing.",
						5, pContext->iCurrentJoiningPlayer,
						pContext->padpnidTesters[pContext->iCurrentJoiningPlayer],
						pContext->padpnidTesters[pContext->iCurrentJoiningPlayer],
						pCreatePlayerMsg->dpnidPlayer,
						pCreatePlayerMsg->dpnidPlayer);

					//Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Got duplicate CREATE_PLAYER for rejoining player ID %u/%x!",
													2, pCreatePlayerMsg->dpnidPlayer,
													pCreatePlayerMsg->dpnidPlayer);

					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				} // end if (already have the rejoining player's ID)


				DPL(1, "Joining tester %i has entered the session with player ID %u/%x.",
					3, pContext->iCurrentJoiningPlayer, pCreatePlayerMsg->dpnidPlayer,
					pCreatePlayerMsg->dpnidPlayer);


				// Associate the context with this player.
				//pCreatePlayerMsg->pvPlayerContext = &(pContext->paiReliableMsgsReceivedFromTesters[pContext->iCurrentJoiningPlayer]);
	
				//DPL(8, "Player context is now %x.", 1, pCreatePlayerMsg->pvPlayerContext);


				// Store the player ID.
				pContext->padpnidTesters[pContext->iCurrentJoiningPlayer] = pCreatePlayerMsg->dpnidPlayer;

				if (pContext->pTNecd->iTesterNum == pContext->iCurrentDroppingPlayer)
				{
					DPL(0, "Joining tester (%i) sneaked in with player ID %u/%x, we had better get a corresponding DELETE_PLAYER shortly!",
						3, pContext->iCurrentDroppingPlayer, pCreatePlayerMsg->dpnidPlayer,
						pCreatePlayerMsg->dpnidPlayer);

					// Note we special case mark him as _not_ indicated.  This is
					// not protected by locks or anything, so I think it may be
					// possible for this to go wrong.
					pContext->pafTesterIndicated[pContext->iCurrentJoiningPlayer] = FALSE;

					// And we're done here, so return DPN_OK.
					goto DONE;
				} // end if (we're dropping player)


				// If we're here, we're not a dropping or joining player, and the
				// joining player just joined.  Mark him as indicated, and see if
				// the dropping player has dropped.
				pContext->pafTesterIndicated[pContext->iCurrentJoiningPlayer] = TRUE;
				

				// If the dropping player hasn't left yet, we need to wait.
				if (! pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer])
				{
					DPL(2, "Dropping tester %i (player ID %u/%x) has not left yet, not notifying main thread.",
						3, pContext->iCurrentDroppingPlayer,
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

					// Just return DPN_OK.
					goto DONE;
				} // end if (dropping player hasn't yet)


				// If we got here, the dropping player has gone already, so notify
				// the main thread.

				DPL(2, "Testers expected to leave and join have done so, notifying main thread.", 0);

				if (! SetEvent(pContext->hDroppedAndJoinedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set dropped and joined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hDroppedAndJoinedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end else (we're not the joining player)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			if (pContext->hDroppedAndJoinedEvent == NULL)
			{
				DPL(0, "WARNING: Ignoring DPN_MSGID_DESTROY_PLAYER message because no DroppedAndJoined event, this had better be because of a test failure!", 0);
			} // end if (no dropped and joined event)
			else
			{
				// If we're a dropping player, then we should be seeing all the
				// players be removed from the session.  If not, just the dropping
				// players should be going away.
				if (pContext->pTNecd->iTesterNum == pContext->iCurrentDroppingPlayer)
				{
					fFound = FALSE;

					// Lookup this ID in the list of testers' player IDs.
					for(iTesterNum = 0; iTesterNum <= pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// If we're not waiting for our local player to disconnect,
						// and this is currently our tester number, skip it.
						if ((! pContext->fSelfIndicate) &&
							(iTesterNum == pContext->pTNecd->iTesterNum))
						{
							continue;
						} // end if (won't wait for self to disconnect and this is self)


						// If we found the tester ID...
						if (pContext->padpnidTesters[iTesterNum] == pDestroyPlayerMsg->dpnidPlayer)
						{
							if (iTesterNum == pContext->iCurrentJoiningPlayer)
							{
								DPL(0, "Joining tester (%i) sneaked in with player ID %u/%x, this is the DELETE_PLAYER.",
									3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
									pDestroyPlayerMsg->dpnidPlayer);
								
								// If that player wasn't indicated, something's
								// wrong.
								if (! pContext->pafTesterIndicated[iTesterNum])
								{
									DPL(0, "Got unexpected DESTROY_PLAYER for rejoining tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
										3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
										pDestroyPlayerMsg->dpnidPlayer);

									//Ignore error
									pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																	"Got unexpected DESTROY_PLAYER for rejoining tester %i!",
																	1, iTesterNum);

									DEBUGBREAK();

									hr = E_FAIL;
									goto DONE;
								} // end if (player already connected)

								// Mark him as disconnected now.
								pContext->pafTesterIndicated[iTesterNum] = FALSE;
							} // end if (it's the joining player)
							else
							{
								// If that player already disconnected, something's
								// wrong.
								if (pContext->pafTesterIndicated[iTesterNum])
								{
									DPL(0, "Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
										3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
										pDestroyPlayerMsg->dpnidPlayer);

									//Ignore error
									pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																	"Got duplicate DESTROY_PLAYER for tester %i!",
																	1, iTesterNum);

									DEBUGBREAK();

									hr = E_FAIL;
									goto DONE;
								} // end if (player already connected)

								// Mark him as disconnected now.
								pContext->pafTesterIndicated[iTesterNum] = TRUE;

								DPL(1, "Tester %i (player ID %u/%x) has disconnected.",
									3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
									pDestroyPlayerMsg->dpnidPlayer);
							} // end else (not the joining player)

							fFound = TRUE;
							break;
						} // end if (found)
					} // end for (each tester who's already joined)


					// If we didn't recognize that player ID, we're screwed.
					if (! fFound)
					{
						DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x!  DEBUGBREAK()-ing.",
							2, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
														2, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (didn't find player ID)


					// See if that's the last person we're waiting on to disconnect.
					for(iTesterNum = 0; iTesterNum < pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// If we're not waiting for our local player to disconnect,
						// and this is currently our tester number, skip it.
						if ((! pContext->fSelfIndicate) &&
							(iTesterNum == pContext->pTNecd->iTesterNum))
						{
							continue;
						} // end if (won't wait for self to disconnect and this is self)


						if (! pContext->pafTesterIndicated[iTesterNum])
						{
							DPL(4, "Still expecting tester %i to disconnect, not notifying main thread.",
								1, iTesterNum);
							// No sense in looking further, just return OK.
							goto DONE;
						} // end if (tester hasn't connected yet)
					} // end for (each tester who's already joined)
				} // end if (current leaving player)
				else
				{
					// Make sure the leaving player is the right one.
					if (pDestroyPlayerMsg->dpnidPlayer != pContext->padpnidTesters[pContext->iCurrentDroppingPlayer])
					{
						DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x (leaving player (tester %i) is ID %u/%x)!  DEBUGBREAK()-ing",
							5, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer,
							pContext->iCurrentDroppingPlayer,
							pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
							pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
														2, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (leaving player isn't expected)

					
					if (pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer])
					{
						DPL(0, "Got duplicate DESTROY_PLAYER for leaving tester %i, player ID %u/%x!  DEBUGBREAK()-ing.",
							3, pContext->iCurrentDroppingPlayer,
							pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
							pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate DESTROY_PLAYER for leaving tester (ID %u/%x)!",
														2, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (tester already disconnected)


					DPL(1, "Dropping tester %i (player ID %u/%x) has left the session.",
						3, pContext->iCurrentDroppingPlayer, pDestroyPlayerMsg->dpnidPlayer,
						pDestroyPlayerMsg->dpnidPlayer);


					// Mark dropping player as disconnected now.
					pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer] = TRUE;


					// If the joining player hasn't done so, just return DPN_OK;
					if (! pContext->pafTesterIndicated[pContext->iCurrentJoiningPlayer])
					{
						DPL(2, "Joining tester %i has not done so yet, not notifying main thread.",
							1, pContext->iCurrentJoiningPlayer);
						goto DONE;
					} // end if (joining player hasn't done so)
				} // end else (not current leaving player)



				// If we got here, then we're good to go.
				DPL(2, "All testers expected to disconnect actually have, notifying main thread.", 0);

				if (! SetEvent(pContext->hDroppedAndJoinedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set dropped and joined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hDroppedAndJoinedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set dropped and joined event)
			} // end else (dropped and joined event)
		  break;

		case DPN_MSGID_HOST_MIGRATE:
			DPL(0, "WARNING: Ignoring HOST_MIGRATE, this had better be because of a test failure!", 0);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			/*
			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
			*/

#pragma TODO(vanceo, "Validate this")
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	SAFE_LOCALFREE(pdpnpi);

	return (hr);
} // ConnexLeaveWhileJoinPeerDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexLeaveWhileJoinServerDPNMessageHandler()"
//==================================================================================
// ConnexLeaveWhileJoinServerDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexLeaveWhileJoinServerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PCONNEXLEAVEWHILEJOINCONTEXT	pContext = (PCONNEXLEAVEWHILEJOINCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			if (pContext->padpnidTesters[pContext->iCurrentJoiningPlayer] != 0)
			{
				DPL(0, "Got duplicate CREATE_PLAYER for rejoining player (tester %i, prev player ID = %u/%x, new player ID = %u/%x)!  DEBUGBREAK()-ing.",
					5, pContext->iCurrentJoiningPlayer,
					pContext->padpnidTesters[pContext->iCurrentJoiningPlayer],
					pContext->padpnidTesters[pContext->iCurrentJoiningPlayer],
					pCreatePlayerMsg->dpnidPlayer,
					pCreatePlayerMsg->dpnidPlayer);

				//Ignore error
				pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
												"Got duplicate CREATE_PLAYER for rejoining player ID %u/%x!",
												2, pCreatePlayerMsg->dpnidPlayer,
												pCreatePlayerMsg->dpnidPlayer);

				DEBUGBREAK();

				hr = E_FAIL;
				goto DONE;
			} // end if (already have the rejoining player's ID)


			DPL(1, "Joining tester %i has entered the session with player ID %u/%x.",
				3, pContext->iCurrentJoiningPlayer, pCreatePlayerMsg->dpnidPlayer,
				pCreatePlayerMsg->dpnidPlayer);


			// Associate the context with this player.
			//pCreatePlayerMsg->pvPlayerContext = &(pContext->paiReliableMsgsReceivedFromTesters[pContext->iCurrentJoiningPlayer]);

			//DPL(8, "Player context is now %x.", 1, pCreatePlayerMsg->pvPlayerContext);


			// Store the player ID.
			pContext->padpnidTesters[pContext->iCurrentJoiningPlayer] = pCreatePlayerMsg->dpnidPlayer;

			pContext->pafTesterIndicated[pContext->iCurrentJoiningPlayer] = TRUE;


			// If the dropping player hasn't left yet, we need to wait.
			if (! pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer])
			{
				DPL(2, "Dropping tester %i (player ID %u/%x) has not left yet, not notifying main thread.",
					3, pContext->iCurrentDroppingPlayer,
					pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
					pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

				// Just return DPN_OK.
				goto DONE;
			} // end if (dropping player hasn't yet)


			// If we got here, the dropping player has gone already, so notify
			// the main thread.

			DPL(2, "Testers expected to leave and join have done so, notifying main thread.", 0);

			if (! SetEvent(pContext->hDroppedAndJoinedEvent))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set dropped and joined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hDroppedAndJoinedEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			if (pContext->hDroppedAndJoinedEvent == NULL)
			{
				DPL(0, "WARNING: Ignoring DPN_MSGID_DESTROY_PLAYER message because no DroppedAndJoined event, this had better be because of a test failure!", 0);
			} // end if (no dropped and joined event)
			else
			{
				// Make sure the leaving player is the right one.
				if (pDestroyPlayerMsg->dpnidPlayer != pContext->padpnidTesters[pContext->iCurrentDroppingPlayer])
				{
					DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x (leaving player (tester %i) is ID %u/%x)!  DEBUGBREAK()-ing",
						5, pDestroyPlayerMsg->dpnidPlayer,
						pDestroyPlayerMsg->dpnidPlayer,
						pContext->iCurrentDroppingPlayer,
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

					//Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
													2, pDestroyPlayerMsg->dpnidPlayer,
													pDestroyPlayerMsg->dpnidPlayer);

					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				} // end if (leaving player isn't expected)

				
				if (pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer])
				{
					DPL(0, "Got duplicate DESTROY_PLAYER for leaving tester %i, player ID %u/%x!  DEBUGBREAK()-ing.",
						3, pContext->iCurrentDroppingPlayer,
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer],
						pContext->padpnidTesters[pContext->iCurrentDroppingPlayer]);

					//Ignore error
					pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
													"Got duplicate DESTROY_PLAYER for leaving tester (ID %u/%x)!",
													2, pDestroyPlayerMsg->dpnidPlayer,
													pDestroyPlayerMsg->dpnidPlayer);

					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				} // end if (tester already disconnected)


				DPL(1, "Dropping tester %i (player ID %u/%x) has left the session.",
					3, pContext->iCurrentDroppingPlayer, pDestroyPlayerMsg->dpnidPlayer,
					pDestroyPlayerMsg->dpnidPlayer);


				// Mark dropping player as disconnected now.
				pContext->pafTesterIndicated[pContext->iCurrentDroppingPlayer] = TRUE;


				// If the joining player hasn't done so, just return DPN_OK;
				if (! pContext->pafTesterIndicated[pContext->iCurrentJoiningPlayer])
				{
					DPL(2, "Joining tester %i has not done so yet, not notifying main thread.",
						1, pContext->iCurrentJoiningPlayer);
					goto DONE;
				} // end if (joining player hasn't done so)



				// If we got here, then we're good to go.
				DPL(2, "Testers expected to joing and disconnect actually have, notifying main thread.", 0);

				if (! SetEvent(pContext->hDroppedAndJoinedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set dropped and joined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hDroppedAndJoinedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set dropped and joined event)
			} // end else (dropped and joined event)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			/*
			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);
			*/

#pragma TODO(vanceo, "Validate this")
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexLeaveWhileJoinServerDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexLeaveWhileJoinClientDPNMessageHandler()"
//==================================================================================
// ConnexLeaveWhileJoinClientDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexLeaveWhileJoinClientDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PCONNEXLEAVEWHILEJOINCONTEXT	pContext = (PCONNEXLEAVEWHILEJOINCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPL(0, "WARNING: Connect completion failed, this had better be because of a test failure!  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
#pragma TODO(vanceo, "How do we notify main thread?")
			} // end if (connect completion failed)

			if (! SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set connect complete event %x!  0x%08x",
					2, pConnectCompleteMsg->pvUserContext, hr);

				if (hr == DPN_OK)
					hr = E_FAIL;

				//goto DONE;
			} // end if (couldn't set completion event)
		  break;

		case DPN_MSGID_TERMINATE_SESSION:
			if (pContext->hDroppedAndJoinedEvent == NULL)
			{
				DPL(0, "WARNING: Ignoring TERMINATE_SESSION message because no DroppedAndJoined event, this had better be because of a test failure!", 0);
			} // end if (no dropped and joined event)
			else
			{
				if (! SetEvent(pContext->hDroppedAndJoinedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set DroppedAndJoined event %x!  0x%08x",
						2, pContext->hDroppedAndJoinedEvent, hr);

					if (hr == DPN_OK)
						hr = E_FAIL;

					//goto DONE;
				} // end if (couldn't set dropped and joined event)
			} // end else (dropped and joined event)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ConnexLeaveWhileJoinClientDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexManyHostDPNMessageHandler()"
//==================================================================================
// ConnexManyHostDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexManyHostDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PCONNEXMANYHOSTCONTEXT	pContext = (PCONNEXMANYHOSTCONTEXT) pvContext;
	int						iTempCount;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_CREATE_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER		pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);


			// Verify the incoming data.
			if (pIndicateConnectMsg->pvUserConnectData != NULL)
			{
				if (pContext->pvReplyData == NULL)
				{
					DPL(0, "%u bytes of user connect data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pIndicateConnectMsg->dwUserConnectDataSize,
						pIndicateConnectMsg->pvUserConnectData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pIndicateConnectMsg->dwUserConnectDataSize != pContext->dwUserDataSize)
				{
					DPL(0, "Size of user connect data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pIndicateConnectMsg->dwUserConnectDataSize,
						pIndicateConnectMsg->pvUserConnectData, pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)


				if (! IsFilledWithDWord(pIndicateConnectMsg->pvUserConnectData, pIndicateConnectMsg->dwUserConnectDataSize, DATAPATTERN_CONNECT))
				{
					DPL(0, "User connect data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pIndicateConnectMsg->pvUserConnectData,
						pIndicateConnectMsg->dwUserConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->pvReplyData != NULL)
				{
					DPL(0, "%u bytes of user connect data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pIndicateConnectMsg->dwUserConnectDataSize != 0)
				{
					DPL(0, "User connect data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pIndicateConnectMsg->dwUserConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)


			// Make sure the context is NULL.
			if (pIndicateConnectMsg->pvPlayerContext != NULL)
			{
				DPL(0, "Initial value for context is not NULL (%x)!  DEBUGBREAK()-ing.",
					1, pIndicateConnectMsg->pvPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is not NULL)

#pragma TODO(vanceo, "Make sure it's the other tester (address)")

			// Respond with data, if there is any.
			if (pContext->pvReplyData != NULL)
			{
				pIndicateConnectMsg->pvReplyData = pContext->pvReplyData;
				pIndicateConnectMsg->dwReplyDataSize = pContext->dwUserDataSize;
				pIndicateConnectMsg->pvReplyContext = NULL;

				DPL(0, "Replying to connect with %u bytes of data at %x.",
					2, pContext->dwUserDataSize, pContext->pvReplyData);
			} // end if (there's some user data)
			else
			{
				// Otherwise see if that's the last connect necessary.

				iTempCount = InterlockedDecrement((LPLONG) (&pContext->iNumConnectsRemaining));
				if (iTempCount < 0)
				{
					DPL(0, "Number of connects remaining is bad!  DEBUGBREAK()-ing.", 0);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (count went negative)
				
				// Still more connects?
				if (iTempCount > 0)
				{
					DPL(2, "Still approximately %i more connects remaining, not notifying main thread.",
						1, iTempCount);
				} // end if (still more connects)
				else
				{
					// If we got here, that was the last connect expected, so notify
					// the main thread.

					DPL(1, "Last connect indicated, notifying main thread.", 0);

					if (! SetEvent(pContext->hConnectsDoneEvent))
					{
						hr = GetLastError();
						DPL(0, "Couldn't set connects done event (%x)!  0x%08x",
							2, pContext->hConnectsDoneEvent, hr);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;

						goto DONE;
					} // end if (couldn't set event)
				} // end else (no more connects)
			} // end else (no data)


			// If we're rejecting connection attempts, do so.
			if (pContext->fReject)
			{
				DPL(1, "Rejecting connection attempt.", 0);
				hr = E_FAIL;
			} // end if (rejecting connection attempt)
		  break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER	pReturnBufferMsg;



			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;

			DPL(0, "DPN_MSGID_RETURN_BUFFER", 0);
			DPL(0, "    dwSize = %u", 1, pReturnBufferMsg->dwSize);
			DPL(0, "    hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
			DPL(0, "    pvBuffer = %x", 1, pReturnBufferMsg->pvBuffer);
			DPL(0, "    pvUserContext = %x", 1, pReturnBufferMsg->pvUserContext);


			if (pContext->pvReplyData == NULL)
			{
				DPL(0, "No reply data was sent but returning buffer %x (context = %x)!?  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer,
					pReturnBufferMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not using data)

			if (pReturnBufferMsg->pvBuffer != pContext->pvReplyData)
			{
				DPL(0, "Buffer returned is not expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer, pContext->pvReplyData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (buffer is wrong)

			if (pReturnBufferMsg->pvUserContext != NULL)
			{
				DPL(0, "Reply context returned is wrong (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pReturnBufferMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is NULL)


			iTempCount = InterlockedDecrement((LPLONG) (&pContext->iNumConnectsRemaining));
			if (iTempCount < 0)
			{
				DPL(0, "Number of connects remaining is bad!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (count went negative)
			
			// Still more connects?
			if (iTempCount > 0)
			{
				DPL(2, "Still approximately %i more connects remaining, not notifying main thread.",
					1, iTempCount);
				goto DONE;
			} // end if (still more connects)


			// If we got here, that was the buffer for the last expected connect
			// attempt, so notify the main thread.

			DPL(1, "Last connect reply buffer returned, notifying main thread.", 0);

			if (! SetEvent(pContext->hConnectsDoneEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set connects done event (%x)!  0x%08x",
					2, pContext->hConnectsDoneEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				//goto DONE;
			} // end if (couldn't set event)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexManyHostDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexManyConnectorDPNMessageHandler()"
//==================================================================================
// ConnexManyConnectorDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexManyConnectorDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PCONNEXMANYCONNECTORCONTEXT		pContext = (PCONNEXMANYCONNECTORCONTEXT) pvContext;
	int								iInterface;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPL(0, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPL(0, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPL(0, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPL(0, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPL(0, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPL(0, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPL(0, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);

			iInterface = (int) ((INT_PTR) pConnectCompleteMsg->pvUserContext);

			if (pContext->fReject)
			{
				if (pConnectCompleteMsg->hResultCode != DPNERR_HOSTREJECTEDCONNECTION)
				{
					DPL(0, "Connect didn't complete with expected HOSTREJECTEDCONNECTION failure!  DEBUGBREAK()-ing.  0x%08x",
						1, pConnectCompleteMsg->hResultCode);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (connect completion failed)
			} // end if (connect attempts should be rejected)
			else
			{
				if (pConnectCompleteMsg->hResultCode != DPN_OK)
				{
					DPL(0, "Connect completion failed, this had better be because of a test failure!  DEBUGBREAK()-ing.  0x%08x",
						1, pConnectCompleteMsg->hResultCode);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (connect completion failed)
			} // end else (connect attempts should succeed)


			// Verify the incoming data.
			if (pConnectCompleteMsg->pvApplicationReplyData != NULL)
			{
				if (pContext->dwReplyDataSize == 0)
				{
					DPL(0, "%u bytes of reply data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pConnectCompleteMsg->dwApplicationReplyDataSize,
						pConnectCompleteMsg->pvApplicationReplyData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pConnectCompleteMsg->dwApplicationReplyDataSize != pContext->dwReplyDataSize)
				{
					DPL(0, "Size of reply data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pConnectCompleteMsg->dwApplicationReplyDataSize,
						pConnectCompleteMsg->pvApplicationReplyData,
						pContext->dwReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)


				if (! IsFilledWithDWord(pConnectCompleteMsg->pvApplicationReplyData, pConnectCompleteMsg->dwApplicationReplyDataSize, DATAPATTERN_REPLY))
				{
					DPL(0, "Reply data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pConnectCompleteMsg->pvApplicationReplyData,
						pConnectCompleteMsg->dwApplicationReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->dwReplyDataSize != 0)
				{
					DPL(0, "%u bytes of reply data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pConnectCompleteMsg->dwApplicationReplyDataSize != 0)
				{
					DPL(0, "Reply received data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pConnectCompleteMsg->dwApplicationReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)


			if (! SetEvent(pContext->pahConnectCompleteEvents[iInterface]))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set connect complete %i event %x!  0x%08x",
					3, iInterface, pContext->pahConnectCompleteEvents[iInterface], hr);

				if (hr == DPN_OK)
					hr = E_FAIL;

				//goto DONE;
			} // end if (couldn't set completion event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_CREATE_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexManyConnectorDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexServerLossServerDPNMessageHandler()"
//==================================================================================
// ConnexServerLossServerDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexServerLossServerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PCONNEXSERVERLOSSCONTEXT	pContext = (PCONNEXSERVERLOSSCONTEXT) pvContext;
	int							iFirstTesterNotIndicated = -1;
	BOOL						fFoundPlayer = FALSE;
	int							i;


	switch (dwMsgType)
	{
		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER		pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			for(i = 0; i < pContext->pTNecd->iNumMachines; i++)
			{
				if (pContext->padpnidTesters[i] == pDestroyPlayerMsg->dpnidPlayer)
				{
					fFoundPlayer = TRUE;

					if (pContext->pafTesterIndicated[i])
					{
						DPL(0, "Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing!",
							3, i, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer);
						// Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing!",
														3, i, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (tester was already indicated)

					if ((i == 0) && (! pContext->fSelfIndicate))
					{
						DPL(0, "Got unexpected DESTROY_PLAYER for local player (ID %u/%x)!  DEBUGBREAK()-ing!",
							2, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer);
						// Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got unexpected DESTROY_PLAYER for local player (ID %u/%x)!  DEBUGBREAK()-ing!",
														2, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (local player but shouldn't get it)

					pContext->pafTesterIndicated[i] = TRUE;
				} // end if (found player)


				// Make sure everyone so far has been indicated (except local
				// player if not expecting that).
				if ((i != 0) || (pContext->fSelfIndicate))
				{
					if (! pContext->pafTesterIndicated[i])
						iFirstTesterNotIndicated = i;
				} // end if (not local player or self indicating)


				// If we found the player we wanted, but not all the players have
				// been indicated, then we're done here.
				if ((fFoundPlayer) && (iFirstTesterNotIndicated >= 0))
				{
					DPL(2, "Found tester corresponding to DELETE_PLAYER, but tester %i still hasn't disconnected, not notifying main thread.",
						1, iFirstTesterNotIndicated);
					goto DONE;
				} // end if (found tester, but not all indicated)
			} // end for (each tester)

			if (! fFoundPlayer)
			{
				DPL(0, "Got DESTROY_PLAYER for unknown player ID %u/%x!  DEBUGBREAK()-ing!",
					2, pDestroyPlayerMsg->dpnidPlayer,
					pDestroyPlayerMsg->dpnidPlayer);
				// Ignore error
				pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
												"Got DESTROY_PLAYER for unknown player ID %u/%x!  DEBUGBREAK()-ing!",
												2, pDestroyPlayerMsg->dpnidPlayer,
												pDestroyPlayerMsg->dpnidPlayer);

				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (local player but shouldn't get it)


			// If we made it here, we found the tester matching this DELETE_PLAYER
			// message, and now all testers expected to be deleted actually have.
			DPL(1, "All testers expected to be deleted have been, notifying main thread.", 0);

			if (! SetEvent(pContext->hDisconnectEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set disconnect event (%x)!  0x%08x",
					2, pContext->hDisconnectEvent, hr);
				if (hr == S_OK)
					hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set disconnect event)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexServerLossServerDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexServerLossClientDPNMessageHandler()"
//==================================================================================
// ConnexServerLossClientDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexServerLossClientDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PCONNEXSERVERLOSSCONTEXT	pContext = (PCONNEXSERVERLOSSCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_TERMINATE_SESSION:
			PDPNMSG_TERMINATE_SESSION	pTerminateSessionMsg;


			pTerminateSessionMsg = (PDPNMSG_TERMINATE_SESSION) pvMsg;

#pragma BUGBUG(vanceo, "Validate DPN_MSGID_TERMINATE_SESSION")

			DPL(1, "Got expected terminate session message, notifying main thread.", 0);

			if (! SetEvent(pContext->hDisconnectEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set disconnect event (%x)!  0x%08x",
					2, pContext->hDisconnectEvent, hr);
				if (hr == S_OK)
					hr = E_FAIL;
				//goto DONE;
			} // end if (couldn't set disconnect event)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // ConnexServerLossClientDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexRejectDPNMessageHandler()"
//==================================================================================
// ConnexRejectDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexRejectDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PCONNEXREJECTCONTEXT	pContext = (PCONNEXREJECTCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;



			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			DPL(0, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPL(0, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPL(0, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPL(0, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPL(0, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPL(0, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPL(0, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			if (pContext->pTNecd->iTesterNum == 0)
			{
				DPL(0, "Getting connect completion on host!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)

#pragma TODO(vanceo, "Validate hAsyncOp")

			if (pConnectCompleteMsg->pvUserContext != pContext->hConnectEvent)
			{
				DPL(0, "Connect completion context is wrong (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvUserContext, pContext->hConnectEvent);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context wrong)


			// Make sure we got the right error result code.
			if (pConnectCompleteMsg->hResultCode != DPNERR_HOSTREJECTEDCONNECTION)
			{
				DPL(0, "Connect completed with wrong error result code (not HOSTREJECTEDCONNECTION)!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong error code)


			// Verify the incoming data.
			if (pConnectCompleteMsg->pvApplicationReplyData != NULL)
			{
				if (pContext->pvConnectData == NULL)
				{
					DPL(0, "%u bytes of reply data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pConnectCompleteMsg->dwApplicationReplyDataSize,
						pConnectCompleteMsg->pvApplicationReplyData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pConnectCompleteMsg->dwApplicationReplyDataSize != pContext->dwConnectDataSize)
				{
					DPL(0, "Size of reply data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pConnectCompleteMsg->dwApplicationReplyDataSize,
						pConnectCompleteMsg->pvApplicationReplyData,
						pContext->dwConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)

				if (! IsFilledWithDWord(pConnectCompleteMsg->pvApplicationReplyData, pConnectCompleteMsg->dwApplicationReplyDataSize, DATAPATTERN_REPLY))
				{
					DPL(0, "Reply data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pConnectCompleteMsg->pvApplicationReplyData,
						pConnectCompleteMsg->dwApplicationReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->pvConnectData != NULL)
				{
					DPL(0, "%u bytes of reply data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pConnectCompleteMsg->dwApplicationReplyDataSize != 0)
				{
					DPL(0, "Reply received data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pConnectCompleteMsg->dwApplicationReplyDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)


			// Alert the main thread.
			if (! SetEvent(pContext->hConnectEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set connect completion event (%x)!  0x%08x",
					2, pContext->hConnectEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_CREATE_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;



			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;
			
			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting indicate connect on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

			// Verify the incoming data.
			if (pIndicateConnectMsg->pvUserConnectData != NULL)
			{
				if (pContext->pvConnectData == NULL)
				{
					DPL(0, "%u bytes of user connect data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pIndicateConnectMsg->dwUserConnectDataSize,
						pIndicateConnectMsg->pvUserConnectData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pIndicateConnectMsg->dwUserConnectDataSize != pContext->dwConnectDataSize)
				{
					DPL(0, "Size of user connect data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pIndicateConnectMsg->dwUserConnectDataSize,
						pIndicateConnectMsg->pvUserConnectData, pContext->dwConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)

				if (! IsFilledWithDWord(pIndicateConnectMsg->pvUserConnectData, pIndicateConnectMsg->dwUserConnectDataSize, DATAPATTERN_CONNECT))
				{
					DPL(0, "User connect data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pIndicateConnectMsg->pvUserConnectData,
						pIndicateConnectMsg->dwUserConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->pvConnectData != NULL)
				{
					DPL(0, "%u bytes of user connect data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pIndicateConnectMsg->dwUserConnectDataSize != 0)
				{
					DPL(0, "User connect data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pIndicateConnectMsg->dwUserConnectDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)


#pragma TODO(vanceo, "Make sure it's the other tester querying (address)")


			// Respond with data, if there is any.
			if (pContext->pvConnectData != NULL)
			{
				pIndicateConnectMsg->pvReplyData = pContext->pvConnectData;
				pIndicateConnectMsg->dwReplyDataSize = pContext->dwConnectDataSize;
				pIndicateConnectMsg->pvReplyContext = pContext->hReplyBufferReturnedEvent;

				DPL(0, "Rejecting connect with %u bytes of data at %x.",
					2, pContext->dwConnectDataSize, pContext->pvConnectData);
			} // end if (there's some user data)



			// Alert the main thread.
			if (! SetEvent(pContext->hConnectEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set connect indication event (%x)!  0x%08x",
					2, pContext->hConnectEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)


			// Return a failure to reject the connection.
			hr = E_FAIL;
		  break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER	pReturnBufferMsg;



			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;

			DPL(0, "DPN_MSGID_RETURN_BUFFER", 0);
			DPL(0, "    dwSize = %u", 1, pReturnBufferMsg->dwSize);
			DPL(0, "    hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
			DPL(0, "    pvBuffer = %x", 1, pReturnBufferMsg->pvBuffer);
			DPL(0, "    pvUserContext = %x", 1, pReturnBufferMsg->pvUserContext);


			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting return buffer on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)


			if (pContext->pvConnectData == NULL)
			{
				DPL(0, "No response data was sent but returning buffer %x (context = %x)!?  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer,
					pReturnBufferMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not using data)

			if (pReturnBufferMsg->pvBuffer != pContext->pvConnectData)
			{
				DPL(0, "Buffer returned is not expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer, pContext->pvConnectData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (buffer is wrong)

			if (pReturnBufferMsg->pvUserContext != pContext->hReplyBufferReturnedEvent)
			{
				DPL(0, "Context returned is wrong (%x != %x)!  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvUserContext, pContext->hReplyBufferReturnedEvent);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is NULL)


			// Alert the main thread.
			if (! SetEvent(pContext->hReplyBufferReturnedEvent))
			{
				hr = GetLastError();
				DPL(0, "Couldn't set reply buffer returned event (%x)!  0x%08x",
					2, pContext->hReplyBufferReturnedEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexRejectDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ConnexNotAllowedDPNMessageHandler()"
//==================================================================================
// ConnexNotAllowedDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ConnexNotAllowedDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PCONNEXNOTALLOWEDCONTEXT	pContext = (PCONNEXNOTALLOWEDCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_APPLICATION_DESC:
			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting application desc notification on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;



			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			DPL(0, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPL(0, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPL(0, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPL(0, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPL(0, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPL(0, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPL(0, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			if ((pContext->pTNecd->iTesterNum == 0) && (! pContext->fConnectsAllowed))
			{
				DPL(0, "Getting connect completion on host when they're not expected!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)

#pragma TODO(vanceo, "Validate hAsyncOp")

			if (pConnectCompleteMsg->pvUserContext != pContext->hConnectCompletedEvent)
			{
				DPL(0, "Connect completion context is wrong (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvUserContext, pContext->hConnectCompletedEvent);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context wrong)


			// Make sure we got the right error result code.
			if (pConnectCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				DPL(0, "Connect completed with wrong error result code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hResultCode,
					pContext->hrExpectedResult);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong error code)


			// Verify the incoming data.
			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPL(0, "%u bytes of reply data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwApplicationReplyDataSize,
					pConnectCompleteMsg->pvApplicationReplyData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)


			// Alert the main thread, if necessary.
			if (pContext->hConnectCompletedEvent != NULL)
			{
				if (! SetEvent(pContext->hConnectCompletedEvent))
				{
					hr = GetLastError();
					DPL(0, "Couldn't set connect completion event (%x)!  0x%08x",
						2, pContext->hConnectCompletedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (there's an event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_CREATE_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;



			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;
			
			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

			if (pContext->pTNecd->iTesterNum != 0)
			{
				DPL(0, "Getting indicate connect on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

			if (! pContext->fConnectsAllowed)
			{
				DPL(0, "Getting unexpected DPN_MSGID_INDICATE_CONNECT (msg = %x)!  DEBUGBREAK()-ing.",
					1, pIndicateConnectMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (connects are not allowed)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ConnexNotAllowedDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\groups.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Structures
//==================================================================================
typedef struct tagGROUPSCONTEXT :public BASESESSIONCREATECONTEXT
{
	HANDLE				hLog;
	HANDLE				hGroupCreatedEvent; // event to set when the create group message comes in
	HANDLE				hPlayerAddedEvent; // event to set when the add player to group message comes in
	HANDLE				hReceiveEvent; // event to set when the message sent to group comes in
	DPNID				dpnidGroup; // ID of group created
} GROUPSCONTEXT, * PGROUPSCONTEXT;


//==================================================================================
// Prototypes
//==================================================================================
HRESULT GroupsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

#undef DEBUG_SECTION
#define DEBUG_SECTION	"GroupsExec_SimplePeer()"
//==================================================================================
// GroupsExec_SimplePeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.5.1.1 - Simple peer-to-peer group test
//
// Arguments:
//	HANDLE				hLog				Handle to logging subsystem
//	DP_GROUPTESTPARAM	*pGroupTestParam	Pointer to params for this test
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT GroupsExec_SimplePeer(HANDLE hLog, DP_GROUPTESTPARAM *pGroupTestParam)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	HRESULT						temphr;
	DWORD						dwSubOutputDataSize;
	GROUPSCONTEXT				context;
	DPN_APPLICATION_DESC		dpnad;
	PWRAPDP8PEER				pDP8Peer = NULL;
	DPNID*						padpnidTesters = NULL;
	HANDLE						hCreateGroupCompleteEvent = NULL;
	DPNHANDLE					dpnhCreateGroup = NULL;
	HANDLE						hAddToGroupCompleteEvent = NULL;
	DPNHANDLE					dpnhAddToGroup = NULL;
	HANDLE						hSendCompleteEvent = NULL;
	DPNHANDLE					dpnhSend = NULL;
	DPN_GROUP_INFO				dpngi;
	DPN_BUFFER_DESC				dpnbd;
	int							i;



	ZeroMemory(&context, sizeof (GROUPSCONTEXT));
	context.hLog = hLog;

	BEGIN_TESTCASE
	{
		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = 0;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;

		if(pGroupTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating session host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid peer and an array of tester DPNID's
			if(!CreateHostAndWaitForPlayers(hLog, &pDP8Peer, &context, &dpnad, GroupsDPNMessageHandler,
				&padpnidTesters, pGroupTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create host and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to session host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid peer and an array of tester DPNID's
			if(!ConnectNonHostAndWaitForPlayers(hLog, &pDP8Peer, &context, pGroupTestParam->dwHostAddr, &dpnad, GroupsDPNMessageHandler,
				&padpnidTesters, pGroupTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create host and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}


		CREATEEVENT_OR_THROW(context.hGroupCreatedEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(context.hPlayerAddedEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hCreateGroupCompleteEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hAddToGroupCompleteEvent, NULL, FALSE, FALSE, NULL);
		CREATEEVENT_OR_THROW(hSendCompleteEvent, NULL, FALSE, FALSE, NULL);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready for group creation");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pGroupTestParam->hNetsyncObject, GROUP_BEGIN_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, GROUP_BEGIN_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}
		

		// Do this twice, the first time the host will create the group and send,
		// the second time the joiner will.
		for(i = 0; i < 2; i++)
		{
			// If it's our turn to create the group, do so.
			if((pGroupTestParam->fHostTest && (i == 0)) || (!pGroupTestParam->fHostTest && (i == 1)))
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating group");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
				dpngi.dwSize = sizeof (DPN_GROUP_INFO);
// BUGBUG - Group names not working
//				dpngi.dwInfoFlags = DPNINFO_NAME;
//				dpngi.pwszName = L"Group name";
				//dpngi.pvData = NULL;
				//dpngi.dwDataSize = 0;
				//dpngi.dwGroupFlags = 0;

				tr = pDP8Peer->DP8P_CreateGroup(&dpngi,
												NULL,
												hCreateGroupCompleteEvent,
												&dpnhCreateGroup,
												0);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog,  "Couldn't start creating group!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't create group)

				if (dpnhCreateGroup == NULL)
				{
					DPTEST_FAIL(hLog,  "CreateGroup async operation handle was not set!", 0);
					SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
				} // end if (async handle was not set)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for group to be created");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				
				if(WaitForSingleObject(context.hGroupCreatedEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Group wasn't created within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for CreateGroup op to complete");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(hCreateGroupCompleteEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Group creation operation didn't complete within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				dpnhCreateGroup = NULL;

				CloseHandle(hCreateGroupCompleteEvent);
				hCreateGroupCompleteEvent = NULL;

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Add other tester to group");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_AddPlayerToGroup(context.dpnidGroup,
													padpnidTesters[pGroupTestParam->fHostTest ? 1 : 0],
													hAddToGroupCompleteEvent,
													&dpnhAddToGroup,
													0);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog,  "Couldn't start adding player to group!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't add player to group)

				if (dpnhAddToGroup == NULL)
				{
					DPTEST_FAIL(hLog,  "AddPlayerToGroup async operation handle was not set!", 0);
					SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
				} // end if (async handle was not set)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for player to be added group");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(context.hPlayerAddedEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Player wasn't added within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for AddPlayerToGroup op to complete");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(hAddToGroupCompleteEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Player add operation didn't complete within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				dpnhAddToGroup = NULL;


				CloseHandle(hAddToGroupCompleteEvent);
				hAddToGroupCompleteEvent = NULL;

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Sending guaranteed message to group");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));
				dpnbd.pBufferData = (PBYTE) "My String";
				dpnbd.dwBufferSize = strlen("My String") + 1;

				tr = pDP8Peer->DP8P_SendTo(context.dpnidGroup,
											&dpnbd,
											1,
											0,
											hSendCompleteEvent,
											&dpnhSend,
											DPNSEND_NOCOPY | DPNSEND_GUARANTEED);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog,  "Couldn't start sending to group!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't send to)

				if (dpnhSend == NULL)
				{
					DPTEST_FAIL(hLog,  "Send async operation handle was not set!", 0);
					SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
				} // end if (async handle was not set)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for send to complete");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(hSendCompleteEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Send operation didn't complete within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				CloseHandle(hSendCompleteEvent);
				hSendCompleteEvent = NULL;

			} // end if (our turn to create group)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for group to be created");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(context.hGroupCreatedEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Group wasn't created within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for player to be added to group");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(context.hPlayerAddedEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Player wasn't added within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting to receive message");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if(WaitForSingleObject(context.hReceiveEvent, 30000) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Message wasn't received within 30 seconds", 0);
					THROW_SYSTEMRESULT;
				}

				CloseHandle(context.hReceiveEvent);
				context.hReceiveEvent = NULL;

			} // end else (not our turn to create group)
		} // end for (each player times)


		CloseHandle(context.hGroupCreatedEvent);
		context.hGroupCreatedEvent = NULL;

		CloseHandle(context.hPlayerAddedEvent);
		context.hPlayerAddedEvent = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Releaseing peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		DPTEST_TRACE(hLog, "Releasing peer wrapper", 0);
		delete (pDP8Peer);
		pDP8Peer = NULL;

		SAFE_LOCALFREE(padpnidTesters);

		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		temphr = pDP8Peer->DP8P_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing peer interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing peer interface failed)

		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(padpnidTesters);
	SAFE_CLOSEHANDLE(context.hbsccAllPlayersCreated);
	SAFE_CLOSEHANDLE(hCreateGroupCompleteEvent);
	SAFE_CLOSEHANDLE(context.hGroupCreatedEvent);
	SAFE_CLOSEHANDLE(hAddToGroupCompleteEvent);
	SAFE_CLOSEHANDLE(context.hPlayerAddedEvent);
	SAFE_CLOSEHANDLE(hSendCompleteEvent);
	SAFE_CLOSEHANDLE(context.hReceiveEvent);

	return (sr);
} // GroupsExec_SimplePeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"GroupsExec_SimpleCS()"
//==================================================================================
// GroupsExec_SimpleCS
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.5.2.1 - Simple client/server group test
//
// Arguments:
//	HANDLE				hLog				Handle to logging subsystem
//	DP_GROUPTESTPARAM	*pGroupTestParam	Pointer to params for this test
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT GroupsExec_SimpleCS(HANDLE hLog, DP_GROUPTESTPARAM *pGroupTestParam)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	GROUPSCONTEXT					context;
	DPN_APPLICATION_DESC			dpnad;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	DPNID*							padpnidTesters = NULL;
	HANDLE							hCreateGroupCompleteEvent = NULL;
	DPNHANDLE						dpnhCreateGroup = NULL;
	HANDLE							hAddToGroupCompleteEvent = NULL;
	DPNHANDLE						dpnhAddToGroup = NULL;
	HANDLE							hSendCompleteEvent = NULL;
	DPNHANDLE						dpnhSend = NULL;
	DPN_GROUP_INFO					dpngi;
	DPN_BUFFER_DESC					dpnbd;



	ZeroMemory(&context, sizeof (GROUPSCONTEXT));
	context.hLog = hLog;

	BEGIN_TESTCASE
	{
		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
#pragma BUGBUG(vanceo, "Real GUID")
		dpnad.guidApplication = GUID_UNKNOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		if(pGroupTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating session server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid server and an array of tester DPNID's
			if(!CreateServerAndWaitForPlayers(hLog, &pDP8Server, &context, &dpnad, GroupsDPNMessageHandler,
				&padpnidTesters, pGroupTestParam->dwNumMachines, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't create server and receive correct number of players", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}

		}
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting to session server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// When function returns we should have a valid client
			if(!ConnectClient(hLog, &pDP8Client, &context, pGroupTestParam->dwHostAddr, &dpnad,
				GroupsDPNMessageHandler, 120000))
			{
				DPTEST_FAIL(hLog, "Couldn't connect client", 0);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		}


		if (pGroupTestParam->fHostTest)
		{
			CREATEEVENT_OR_THROW(context.hGroupCreatedEvent, NULL, FALSE, FALSE, NULL);
			CREATEEVENT_OR_THROW(context.hPlayerAddedEvent, NULL, FALSE, FALSE, NULL);
			CREATEEVENT_OR_THROW(hCreateGroupCompleteEvent, NULL, FALSE, FALSE, NULL);
			CREATEEVENT_OR_THROW(hAddToGroupCompleteEvent, NULL, FALSE, FALSE, NULL);
			CREATEEVENT_OR_THROW(hSendCompleteEvent, NULL, FALSE, FALSE, NULL);
		} // end if (tester 0)

		CREATEEVENT_OR_THROW(context.hReceiveEvent, NULL, FALSE, FALSE, NULL);





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready for group creation");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pGroupTestParam->hNetsyncObject, GROUP_BEGIN_EVENT, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, GROUP_BEGIN_EVENT);
			SETTHROW_TESTRESULT(E_ABORT);
		}
		

		// The server should create a group, add himself and the other tester to it,
		// and send to.  Both testers should receive the message.
		if(pGroupTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
			dpngi.dwSize = sizeof (DPN_GROUP_INFO);
// BUGBUG - Group names not working
//			dpngi.dwInfoFlags = DPNINFO_NAME;
//			dpngi.pwszName = L"Group name";
			//dpngi.pvData = NULL;
			//dpngi.dwDataSize = 0;
			//dpngi.dwGroupFlags = 0;

			tr = pDP8Server->DP8S_CreateGroup(&dpngi,
											NULL,
											hCreateGroupCompleteEvent,
											&dpnhCreateGroup,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog,  "Couldn't start creating group!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't create group)

			if (dpnhCreateGroup == NULL)
			{
				DPTEST_FAIL(hLog,  "CreateGroup async operation handle was not set!", 0);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (async handle was not set)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for group to be created");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			if(WaitForSingleObject(context.hGroupCreatedEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Group wasn't created within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			CloseHandle(context.hGroupCreatedEvent);
			context.hGroupCreatedEvent = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for CreateGroup op to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hCreateGroupCompleteEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Group creation operation didn't complete within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			dpnhCreateGroup = NULL;

			CloseHandle(hCreateGroupCompleteEvent);
			hCreateGroupCompleteEvent = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Add self to group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_AddPlayerToGroup(context.dpnidGroup,
												padpnidTesters[0],
												hAddToGroupCompleteEvent,
												&dpnhAddToGroup,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog,  "Couldn't start adding self to group!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't add player to group)

			if (dpnhAddToGroup == NULL)
			{
				DPTEST_FAIL(hLog,  "AddPlayerToGroup async operation handle was not set!", 0);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (async handle was not set)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for player to be added group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(context.hPlayerAddedEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Player wasn't added within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for AddPlayerToGroup op to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hAddToGroupCompleteEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Player add operation didn't complete within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			dpnhAddToGroup = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Add other tester to group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_AddPlayerToGroup(context.dpnidGroup,
												padpnidTesters[1],
												hAddToGroupCompleteEvent,
												&dpnhAddToGroup,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog,  "Couldn't start adding player to group!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't add player to group)

			if (dpnhAddToGroup == NULL)
			{
				DPTEST_FAIL(hLog,  "AddPlayerToGroup async operation handle was not set!", 0);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (async handle was not set)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for player to be added group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(context.hPlayerAddedEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Player wasn't added within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			CloseHandle(context.hPlayerAddedEvent);
			context.hPlayerAddedEvent = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for AddPlayerToGroup op to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hAddToGroupCompleteEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Player add operation didn't complete within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			dpnhAddToGroup = NULL;


			CloseHandle(hAddToGroupCompleteEvent);
			hAddToGroupCompleteEvent = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending guaranteed message to group");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));
			dpnbd.pBufferData = (PBYTE) "My String";
			dpnbd.dwBufferSize = strlen("My String") + 1;

			tr = pDP8Server->DP8S_SendTo(context.dpnidGroup,
										&dpnbd,
										1,
										0,
										hSendCompleteEvent,
										&dpnhSend,
										DPNSEND_NOCOPY | DPNSEND_GUARANTEED);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog,  "Couldn't start sending to group!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't send to)

			if (dpnhSend == NULL)
			{
				DPTEST_FAIL(hLog,  "Send async operation handle was not set!", 0);
				SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
			} // end if (async handle was not set)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for send to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hSendCompleteEvent, 30000) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Send operation didn't complete within 30 seconds", 0);
				THROW_SYSTEMRESULT;
			}

			CloseHandle(hSendCompleteEvent);
			hSendCompleteEvent = NULL;

		} // end if (server)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting to receive message");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		if(WaitForSingleObject(context.hReceiveEvent, 30000) != WAIT_OBJECT_0)
		{
			DPTEST_FAIL(hLog, "Message wasn't received within 30 seconds", 0);
			THROW_SYSTEMRESULT;
		}

		CloseHandle(context.hReceiveEvent);
		context.hReceiveEvent = NULL;

		if (pGroupTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Server->DP8S_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Server->Release();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Releaseing server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			DPTEST_TRACE(hLog, "Releasing server wrapper", 0);
			delete (pDP8Server);
			pDP8Server = NULL;
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Client->DP8C_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing client object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing client object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			tr = pDP8Client->Release();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Releaseing client object failed!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't close)
			
		
			DPTEST_TRACE(hLog, "Releasing client wrapper", 0);
			delete (pDP8Client);
			pDP8Client = NULL;
		} // end else (not tester 0)

		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Server != NULL)
	{
		temphr = pDP8Server->DP8S_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing server interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing server interface failed)

		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		temphr = pDP8Client->DP8C_Close(0);
		if (temphr != DPN_OK)
		{
			DPTEST_FAIL(hLog,  "Closing client interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing client interface failed)

		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	SAFE_LOCALFREE(padpnidTesters);
	SAFE_CLOSEHANDLE(context.hbsccAllPlayersCreated);
	SAFE_CLOSEHANDLE(hCreateGroupCompleteEvent);
	SAFE_CLOSEHANDLE(context.hGroupCreatedEvent);
	SAFE_CLOSEHANDLE(hAddToGroupCompleteEvent);
	SAFE_CLOSEHANDLE(context.hPlayerAddedEvent);
	SAFE_CLOSEHANDLE(hSendCompleteEvent);
	SAFE_CLOSEHANDLE(context.hReceiveEvent);

	return (sr);
} // GroupsExec_SimpleCS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"GroupsDPNMessageHandler()"
//==================================================================================
// GroupsDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT GroupsDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT			hr = DPN_OK;
	PGROUPSCONTEXT	pContext = (PGROUPSCONTEXT) pvContext;
	DWORD			dwCurrentPlayers = 0;


	switch (dwMsgType)
	{
		case DPN_MSGID_ADD_PLAYER_TO_GROUP:
			PDPNMSG_ADD_PLAYER_TO_GROUP		pAddPlayerToGroupMsg;


			pAddPlayerToGroupMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;

#pragma BUGBUG(vanceo, "Validate")

			if (! SetEvent(pContext->hPlayerAddedEvent))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog,  "Couldn't set player added event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hPlayerAddedEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

#pragma TODO(vanceo, "Verify result code is DPN_OK")

			if (! SetEvent(pAsyncOpCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog,  "Couldn't set async op completion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pAsyncOpCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

#pragma BUGBUG(vanceo, "Validate")

			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (! SetEvent(pContext->hGroupCreatedEvent))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog,  "Couldn't set group creation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hGroupCreatedEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

#pragma BUGBUG(vanceo, "Validate")
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			// Safely increment the number of player create messages we've received
			dwCurrentPlayers = InterlockedIncrement((LPLONG) (&pContext->dwPlayersCreated));

			// If all the expected players have connected, then signal the main thread
			if(dwCurrentPlayers == pContext->dwPlayersExpected)
			{
				if(!SetEvent(pContext->hbsccAllPlayersCreated))
				{
					DPTEST_TRACE(pContext->hLog,  "SetEvent failed!  DEBUGBREAK()-ing.  0x%08x", 0);
					DEBUGBREAK();

					hr = E_FAIL;
					goto DONE;
				}
				DPTEST_TRACE(pContext->hLog,  "All %u expected players created", 1, dwCurrentPlayers);
			}
			break;

		case DPN_MSGID_DESTROY_PLAYER:
			// Indicate that some players have left
			pContext->fPlayersHaveLeft = TRUE;
			break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			DPTEST_TRACE(pContext->hLog,  "DPN_MSGID_RECEIVE", 0);
			DPTEST_TRACE(pContext->hLog,  "    dwSize = %u", 1, pReceiveMsg->dwSize);
			DPTEST_TRACE(pContext->hLog,  "    dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
			DPTEST_TRACE(pContext->hLog,  "    pvPlayerContext = %x", 1, pReceiveMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog,  "    pReceiveData = %x", 1, pReceiveMsg->pReceiveData);
			DPTEST_TRACE(pContext->hLog,  "    dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
			DPTEST_TRACE(pContext->hLog,  "    hBufferHandle = %x", 1, pReceiveMsg->hBufferHandle);

#pragma TODO(vanceo, "Verify message")

			if (! SetEvent(pContext->hReceiveEvent))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog,  "Couldn't set receive event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hReceiveEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
#pragma TODO(vanceo, "Verify message")
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog,  "DPN_MSGID_SEND_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog,  "    dwSize = %u", 1, pSendCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog,  "    hAsyncOp = %x", 1, pSendCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog,  "    pvUserContext = %u", 1, pSendCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog,  "    hResultCode = %x", 1, pSendCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog,  "    dwSendTime = %u", 1, pSendCompleteMsg->dwSendTime);

#pragma TODO(vanceo, "Verify result code is DPN_OK")

			if (! SetEvent(pSendCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog,  "Couldn't set send completion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pSendCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		default:
//			DPTEST_TRACE(pContext->hLog,  "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);
			DPTEST_TRACE(pContext->hLog,  "Unexpected message type %x!  Do we need to handle this?", 1, dwMsgType);
//			DEBUGBREAK();

//			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

DONE:

	return (hr);
} // GroupsDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\dptest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Globals
//==================================================================================
// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
HANDLE g_hHeap = NULL;

static PDP_LOCAL_TEST_FUNCTION g_LocalTestFunctions[DPMSG_LOCAL_MAXTEST] = 
{
	ParmVExec_BBuildW,							//DPMSG_ADDR_BUILDW
	ParmVExec_BBuildA,							//DPMSG_ADDR_BUILDA
	ParmVExec_BDuplicate,						//DPMSG_ADDR_DUPLICATE
	ParmVExec_BSetEqual,						//DPMSG_ADDR_SETEQUAL
	ParmVExec_BIsEqual,							//DPMSG_ADDR_ISEQUAL
	ParmVExec_BClear,							//DPMSG_ADDR_CLEAR
	ParmVExec_BGetURLW,							//DPMSG_ADDR_GETURLW
	ParmVExec_BGetURLA,							//DPMSG_ADDR_GETURLA
	ParmVExec_BGetSP,							//DPMSG_ADDR_GETSP
	ParmVExec_BGetUserData,						//DPMSG_ADDR_GETUSERDATA
	ParmVExec_BSetSP,							//DPMSG_ADDR_SETSP
	ParmVExec_BSetUserData,						//DPMSG_ADDR_SETUSERDATA
	ParmVExec_BGetNumComponents,				//DPMSG_ADDR_GETNUMCOMPONENTS
	ParmVExec_BGetByName,						//DPMSG_ADDR_GETBYNAME
	ParmVExec_BGetByIndex,						//DPMSG_ADDR_GETBYINDEX
	ParmVExec_BAdd,								//DPMSG_ADDR_ADD
	ParmVExec_BGetDevice,						//DPMSG_ADDR_GETDEVICE
	ParmVExec_BSetDevice,						//DPMSG_ADDR_SETDEVICE
	
	ParmVExec_IPBuildSockAddr,					//DPMSG_ADDRIP_BUILDSOCKADDR
	ParmVExec_IPGetSockAddr,					//DPMSG_ADDRIP_GETSOCKADDR
	ParmVExec_IPBuildAddress,					//DPMSG_ADDRIP_BUILDADDRESS
	ParmVExec_IPGetAddress,						//DPMSG_ADDRIP_GETADDRESS
	ParmVExec_IPBuildLocalAddress,				//DPMSG_ADDRIP_BUILDLOCALADDRESS
	ParmVExec_IPGetLocalAddress,				//DPMSG_ADDRIP_GETLOCALADDRESS

	ParmVClientExec_GetSendQInfo,				//DPMSG_CLIENT_GETSENDQINFO
	ParmVClientExec_SetClientInfo,				//DPMSG_CLIENT_SETCLIENTINFO
	ParmVClientExec_GetServerInfo,				//DPMSG_CLIENT_GETSERVERINFO
	ParmVClientExec_GetServerAddress,			//DPMSG_CLIENT_GETSERVERADDRESS
	ParmVClientExec_GetConnInfo,				//DPMSG_CLIENT_GETCONNINFO

	ParmVPeerExec_CreateQI,						//DPMSG_PEER_CREATEQI
	ParmVPeerExec_Init,							//DPMSG_PEER_INIT
	ParmVPeerExec_EnumSPs,						//DPMSG_PEER_ENUMSPS
	ParmVPeerExec_Cancel,						//DPMSG_PEER_CANCEL
	ParmVPeerExec_Connect,						//DPMSG_PEER_CONNECT
	ParmVPeerExec_SendTo,						//DPMSG_PEER_SENDTO
	ParmVPeerExec_GetSendQInfo,					//DPMSG_PEER_GETSENDQINFO
	ParmVPeerExec_Host,							//DPMSG_PEER_HOST
	ParmVPeerExec_GetAppDesc,					//DPMSG_PEER_GETAPPDESC
	ParmVPeerExec_SetAppDesc,					//DPMSG_PEER_SETAPPDESC
	ParmVPeerExec_CreateGroup,					//DPMSG_PEER_CREATEGROUP
	ParmVPeerExec_DestroyGroup,					//DPMSG_PEER_DESTROYGROUP
	ParmVPeerExec_AddToGroup,					//DPMSG_PEER_ADDTOGROUP
	ParmVPeerExec_RemoveFromGroup,				//DPMSG_PEER_REMOVEFROMGROUP
	ParmVPeerExec_SetGroupInfo,					//DPMSG_PEER_SETGROUPINFO
	ParmVPeerExec_GetGroupInfo,					//DPMSG_PEER_GETGROUPINFO
	ParmVPeerExec_EnumPAndG,					//DPMSG_PEER_ENUMPANDG
	ParmVPeerExec_EnumGroupMembers,				//DPMSG_PEER_ENUMGROUPMEMBERS
	ParmVPeerExec_SetPeerInfo,					//DPMSG_PEER_SETPEERINFO
	ParmVPeerExec_GetPeerInfo,					//DPMSG_PEER_GETPEERINFO
	ParmVPeerExec_GetPeerAddress,				//DPMSG_PEER_GETPEERADDRESS
	ParmVPeerExec_GetLHostAddresses,			//DPMSG_PEER_GETLHOSTADDRESSES
	ParmVPeerExec_Close,						//DPMSG_PEER_CLOSE
	ParmVPeerExec_EnumHosts,					//DPMSG_PEER_ENUMHOSTS
	ParmVPeerExec_DestroyPeer,					//DPMSG_PEER_DESTROYPEER
	ParmVPeerExec_Return,						//DPMSG_PEER_RETURN
	ParmVPeerExec_GetPlayerContext,				//DPMSG_PEER_GETPLAYERCONTEXT
	ParmVPeerExec_GetGroupContext,				//DPMSG_PEER_GETGROUPCONTEXT
	ParmVPeerExec_GetCaps,						//DPMSG_PEER_GETCAPS
	ParmVPeerExec_SetCaps,						//DPMSG_PEER_SETCAPS
	ParmVPeerExec_SetSPCaps,					//DPMSG_PEER_SETSPCAPS
	ParmVPeerExec_GetSPCaps,					//DPMSG_PEER_GETSPCAPS
	ParmVPeerExec_GetConnInfo,					//DPMSG_PEER_GETCONNINFO
	ParmVPeerExec_Terminate,					//DPMSG_PEER_TERMINATE

	ParmVServerExec_CreateQI,					//DPMSG_SERVER_CREATEQI
	ParmVServerExec_Init,						//DPMSG_SERVER_INIT
	ParmVServerExec_EnumSPs,					//DPMSG_SERVER_ENUMSPS
	ParmVServerExec_Cancel,						//DPMSG_SERVER_CANCEL
	ParmVServerExec_GetSendQInfo,				//DPMSG_SERVER_GETSENDQINFO
	ParmVServerExec_GetAppDesc,					//DPMSG_SERVER_GETAPPDESC
	ParmVServerExec_SetServerInfo,				//DPMSG_SERVER_SETSERVERINFO
	ParmVServerExec_GetClientInfo,				//DPMSG_SERVER_GETCLIENTINFO
	ParmVServerExec_GetClientAddress			//DPMSG_SERVER_GETCLIENTADDRESS
};

static LPSTR g_LocalTestNames[DPMSG_LOCAL_MAXTEST] = 
{
	"Addr: BBuildW",							//DPMSG_ADDR_BUILDW
	"Addr: BBuildA",							//DPMSG_ADDR_BUILDA
	"Addr: BDuplicate",							//DPMSG_ADDR_DUPLICATE
	"Addr: BSetEqual",							//DPMSG_ADDR_SETEQUAL
	"Addr: BIsEqual",							//DPMSG_ADDR_ISEQUAL
	"Addr: BClear",								//DPMSG_ADDR_CLEAR
	"Addr: BGetURLW",							//DPMSG_ADDR_GETURLW
	"Addr: BGetURLA",							//DPMSG_ADDR_GETURLA
	"Addr: BGetSP",								//DPMSG_ADDR_GETSP
	"Addr: BGetUserData",						//DPMSG_ADDR_GETUSERDATA
	"Addr: BSetSP",								//DPMSG_ADDR_SETSP
	"Addr: BSetUserData",						//DPMSG_ADDR_SETUSERDATA
	"Addr: BGetNumComponents",					//DPMSG_ADDR_GETNUMCOMPONENTS
	"Addr: BGetByName",							//DPMSG_ADDR_GETBYNAME
	"Addr: BGetByIndex",						//DPMSG_ADDR_GETBYINDEX
	"Addr: BAdd",								//DPMSG_ADDR_ADD
	"Addr: BGetDevice",							//DPMSG_ADDR_GETDEVICE
	"Addr: BSetDevice",							//DPMSG_ADDR_SETDEVICE
	
	"AddrIP: BuildSockAddr",					//DPMSG_ADDRIP_BUILDSOCKADDR
	"AddrIP: GetSockAddr",						//DPMSG_ADDRIP_GETSOCKADDR
	"AddrIP: BuildAddress",						//DPMSG_ADDRIP_BUILDADDRESS
	"AddrIP: GetAddress",						//DPMSG_ADDRIP_GETADDRESS
	"AddrIP: BuildLocalAddress",				//DPMSG_ADDRIP_BUILDLOCALADDRESS
	"AddrIP: GetLocalAddress",					//DPMSG_ADDRIP_GETLOCALADDRESS

	"Client: GetSendQInfo",						//DPMSG_CLIENT_GETSENDQINFO
	"Client: SetClientInfo",					//DPMSG_CLIENT_SETCLIENTINFO
	"Client: GetServerInfo",					//DPMSG_CLIENT_GETSERVERINFO
	"Client: GetServerAddress",					//DPMSG_CLIENT_GETSERVERADDRESS
	"Client: GetConnInfo",						//DPMSG_CLIENT_GETCONNINFO

	"Peer: CreateQI",							//DPMSG_PEER_CREATEQI
	"Peer: Init",								//DPMSG_PEER_INIT
	"Peer: EnumSPs",							//DPMSG_PEER_ENUMSPS
	"Peer: Cancel",								//DPMSG_PEER_CANCEL
	"Peer: Connect",							//DPMSG_PEER_CONNECT
	"Peer: SendTo",								//DPMSG_PEER_SENDTO
	"Peer: GetSendQInfo",						//DPMSG_PEER_GETSENDQINFO
	"Peer: Host",								//DPMSG_PEER_HOST
	"Peer: GetAppDesc",							//DPMSG_PEER_GETAPPDESC
	"Peer: SetAppDesc",							//DPMSG_PEER_SETAPPDESC
	"Peer: CreateGroup",						//DPMSG_PEER_CREATEGROUP
	"Peer: DestroyGroup",						//DPMSG_PEER_DESTROYGROUP
	"Peer: AddToGroup",							//DPMSG_PEER_ADDTOGROUP
	"Peer: RemoveFromGroup",					//DPMSG_PEER_REMOVEFROMGROUP
	"Peer: SetGroupInfo",						//DPMSG_PEER_SETGROUPINFO
	"Peer: GetGroupInfo",						//DPMSG_PEER_GETGROUPINFO
	"Peer: EnumPAndG",							//DPMSG_PEER_ENUMPANDG
	"Peer: EnumGroupMembers",					//DPMSG_PEER_ENUMGROUPMEMBERS
	"Peer: SetPeerInfo",						//DPMSG_PEER_SETPEERINFO
	"Peer: GetPeerInfo",						//DPMSG_PEER_GETPEERINFO
	"Peer: GetPeerAddress",						//DPMSG_PEER_GETPEERADDRESS
	"Peer: GetLHostAddresses",					//DPMSG_PEER_GETLHOSTADDRESSES
	"Peer: Close",								//DPMSG_PEER_CLOSE
	"Peer: EnumHosts",							//DPMSG_PEER_ENUMHOSTS
	"Peer: DestroyPeer",						//DPMSG_PEER_DESTROYPEER
	"Peer: Return",								//DPMSG_PEER_RETURN
	"Peer: GetPlayerContext",					//DPMSG_PEER_GETPLAYERCONTEXT
	"Peer: GetGroupContext",					//DPMSG_PEER_GETGROUPCONTEXT
	"Peer: GetCaps",							//DPMSG_PEER_GETCAPS
	"Peer: SetCaps",							//DPMSG_PEER_SETCAPS
	"Peer: SetSPCaps",							//DPMSG_PEER_SETSPCAPS
	"Peer: GetSPCaps",							//DPMSG_PEER_GETSPCAPS
	"Peer: GetConnInfo",						//DPMSG_PEER_GETCONNINFO
	"Peer: Terminate",							//DPMSG_PEER_TERMINATE

	"Server: CreateQI",							//DPMSG_SERVER_CREATEQI
	"Server: Init",								//DPMSG_SERVER_INIT
	"Server: EnumSPs",							//DPMSG_SERVER_ENUMSPS
	"Server: Cancel",							//DPMSG_SERVER_CANCEL
	"Server: GetSendQInfo",						//DPMSG_SERVER_GETSENDQINFO
	"Server: GetAppDesc",						//DPMSG_SERVER_GETAPPDESC
	"Server: SetServerInfo",					//DPMSG_SERVER_SETSERVERINFO
	"Server: GetClientInfo",					//DPMSG_SERVER_GETCLIENTINFO
	"Server: GetClientAddress"					//DPMSG_SERVER_GETCLIENTADDRESS
};

//static PDP_TEST_FUNCTION g_NetworkTestFunctions[DPMSG_NET_MAXTEST] = 
//{
//	DPSourceMaxTest										// DPMSG_SOURCEPORT_MAX
//};

//static LPSTR g_NetworkTestNames[DPMSG_NET_MAXTEST] = 
//{
//	"Packet from maximum port"							// DPMSG_SOURCEPORT_MAX
//};

//==================================================================================
// DpTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI DpTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XnetInitialize(NULL, TRUE);
		WSAStartup(MAKEWORD(2, 2), &WSAData);
		InitializeCriticalSection(&g_csSerializeAccess);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XnetCleanup();
		DeleteCriticalSection(&g_csSerializeAccess);
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}

HRESULT TestHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	return S_OK;
}

/*
HRESULT ParmVPCreateGroupDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

typedef struct tagPARMVPCREATEGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fHost; // whether this is the host context or not
	DPNID					dpnidHost; // ID of host player
	DPNID					dpnidClient; // ID of client player
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroupCreated; // the DPNID of the group created
	HANDLE					hGotCreateGroupEvent; // event to set when create group indication is received
} PARMVPCREATEGROUPCONTEXT, * PPARMVPCREATEGROUPCONTEXT;

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVPeerExec_CreateGroupProblem()"
HRESULT ParmVPeerExec_CreateGroupProblem(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8PEER				pDP8Peer = NULL;
	PWRAPDP8PEER				pDP8PeerHost = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DPN_GROUP_INFO				dpngi;
	DPN_APPLICATION_DESC		dpnad;
	PARMVPCREATEGROUPCONTEXT	hostcontext;
	PARMVPCREATEGROUPCONTEXT	nonhostcontext;
	DPNID						dpnidGroup;
	DPNHANDLE					dpnhCreateGroup;
	DP_DOWORKLIST				DoWorkList;
	DPNHANDLE					hAsyncOp;
	HANDLE						hAsyncOpComplete = NULL;
	DWORD						i = 0;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));
	ZeroMemory(&hostcontext, sizeof (PARMVPCREATEGROUPCONTEXT));
	hostcontext.fHost = TRUE;

	ZeroMemory(&nonhostcontext, sizeof (PARMVPCREATEGROUPCONTEXT));

	ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
	dpngi.dwSize = sizeof (DPN_GROUP_INFO);

	ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
	dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpnad.guidApplication = GUID_PARMV_PEER_GETAPPDESC;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Peer = new CWrapDP8Peer(hLog);
		if (pDP8Peer == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Peer->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing peer object with nonhost context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		nonhostcontext.hLog = hLog;

		tr = pDP8Peer->DP8P_Initialize(&nonhostcontext,
										ParmVPCreateGroupDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing peer object with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating new peer host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		hostcontext.hLog = hLog;

		tr = ParmVCreatePeerHost(hLog, ParmVPCreateGroupDPNMessageHandler,
								&hostcontext,
								&dpnad,
								&(hostcontext.dpnidHost),
								&pDP8PeerHost,
								&pDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating peer host failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create peer host)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Connecting peer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

// XBOX - Had to make connection asynchronous

		// Host should get the create player now.
		CREATEEVENT_OR_THROW(hostcontext.hClientCreatedEvent, NULL, FALSE, FALSE, NULL);
		SAFE_CLOSEHANDLE(hAsyncOpComplete);
		CREATEEVENT_OR_THROW(hAsyncOpComplete, NULL, FALSE, FALSE, NULL);

		// Even though it's synchronous, we'll still get a completion.  The async op
		// handle will be NULL, though.
		nonhostcontext.fConnectCanComplete = TRUE;

		tr = pDP8Peer->DP8P_Connect(&dpnad,
									pDP8Address,
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									&(nonhostcontext.dpnidClient),
									hAsyncOpComplete,
									&hAsyncOp,
									0);

		if((tr != DPNSUCCESS_PENDING) && (tr != DPN_OK))
		{
			DPTEST_FAIL(hLog, "Couldn't connect! (error 0x%08x)", 1, tr);
			THROW_TESTRESULT;
		} // end if (couldn't connect)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for connect to complete on non-host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hAsyncOpComplete))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird connects from completing.
		nonhostcontext.fConnectCanComplete = FALSE;

		// Reset the context.
		nonhostcontext.fConnectCompleted = FALSE;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for create player to be indicated on host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumPeers = 2;
		DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
		DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
		DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hClientCreatedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		for(i = 0; i < 1; i++)
		{
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating group on host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			dpnhCreateGroup = (DPNHANDLE) 0x666;
			
			// Expect the create group message and async op completion on the host.
			//hostcontext.dpnidExpectedGroupOwner = 0;
			hostcontext.fCanGetCreateGroup = TRUE;
			SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
			CREATEEVENT_OR_THROW(hostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);
			hostcontext.fAsyncOpCanComplete = TRUE;
			
			// Expect the create group message on the client.
			//nonhostcontext.dpnidExpectedGroupOwner = 0;
			SAFE_CLOSEHANDLE(nonhostcontext.hGotCreateGroupEvent);
			CREATEEVENT_OR_THROW(nonhostcontext.hGotCreateGroupEvent, NULL, FALSE, FALSE, NULL);
			nonhostcontext.fCanGetCreateGroup = TRUE;
			
			tr = pDP8PeerHost->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Creating group on host didn't return expected PENDING success code!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't create group)
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for async op to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
			DoWorkList.fTrackDoWorkTimes = FALSE;
			DoWorkList.dwNumPeers = 2;
			DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
			DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
			DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;
			
			if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hAsyncOpCompletedEvent))
			{
				DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			}
			
			ClearDoWorkList(&DoWorkList);
			
			// The create group message should have arrived by now.
			hostcontext.fCanGetCreateGroup = FALSE;
			
			// Prevent any weird async op completions.
			hostcontext.fAsyncOpCanComplete = FALSE;
			
			// Reset the context.
			hostcontext.fAsyncOpCompleted = FALSE;
			CloseHandle(hostcontext.hAsyncOpCompletedEvent);
			hostcontext.hAsyncOpCompletedEvent = NULL;
			
			// Reset the context.
			hostcontext.dpnidGroupCreated = 0;
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for group creation to be indicated on client");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
			DoWorkList.fTrackDoWorkTimes = FALSE;
			DoWorkList.dwNumPeers = 2;
			DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
			DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
			DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;
			
			if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hGotCreateGroupEvent))
			{
				DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			}
			
			ClearDoWorkList(&DoWorkList);
			
			// Prevent any weird group creations.
			nonhostcontext.fCanGetCreateGroup = FALSE;
			
			// Reset the context.
			CloseHandle(nonhostcontext.hGotCreateGroupEvent);
			nonhostcontext.hGotCreateGroupEvent = NULL;
			nonhostcontext.dpnidGroupCreated = 0;
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating group on client");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			dpnhCreateGroup = (DPNHANDLE) 0x666;
			
			// Expect the create group message on the host.
			//hostcontext.dpnidExpectedGroupOwner = 0;
			SAFE_CLOSEHANDLE(hostcontext.hGotCreateGroupEvent);
			CREATEEVENT_OR_THROW(hostcontext.hGotCreateGroupEvent, NULL, FALSE, FALSE, NULL);
			hostcontext.fCanGetCreateGroup = TRUE;
			
			// Expect the create group message and async op completion on the client.
			//nonhostcontext.dpnidExpectedGroupOwner = 0;
			nonhostcontext.fCanGetCreateGroup = TRUE;
			SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
			CREATEEVENT_OR_THROW(nonhostcontext.hAsyncOpCompletedEvent, NULL, FALSE, FALSE, NULL);
			nonhostcontext.fAsyncOpCanComplete = TRUE;
			
			tr = pDP8Peer->DP8P_CreateGroup(&dpngi, NULL, NULL, &dpnhCreateGroup, 0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Creating group on client didn't return expected PENDING success code!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't create group)
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for async op to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
			DoWorkList.fTrackDoWorkTimes = FALSE;
			DoWorkList.dwNumPeers = 2;
			DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
			DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
			DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;
			
			if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, nonhostcontext.hAsyncOpCompletedEvent))
			{
				DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			}
			
			ClearDoWorkList(&DoWorkList);
			
			// The create group message should have arrived by now.
			nonhostcontext.fCanGetCreateGroup = FALSE;
			
			// Prevent any weird async op completions.
			nonhostcontext.fAsyncOpCanComplete = FALSE;
			
			// Reset the context.
			nonhostcontext.fAsyncOpCompleted = FALSE;
			CloseHandle(nonhostcontext.hAsyncOpCompletedEvent);
			nonhostcontext.hAsyncOpCompletedEvent = NULL;
			
			// Reset the context.
			nonhostcontext.dpnidGroupCreated = 0;
			
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for group creation to be indicated on host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
			DoWorkList.fTrackDoWorkTimes = FALSE;
			DoWorkList.dwNumPeers = 2;
			DoWorkList.apDP8Peers = (PDIRECTPLAY8PEER *) MemAlloc(sizeof(LPVOID) * 2);
			DoWorkList.apDP8Peers[0] = pDP8Peer->m_pDP8Peer;
			DoWorkList.apDP8Peers[1] = pDP8PeerHost->m_pDP8Peer;
			
			if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hostcontext.hGotCreateGroupEvent))
			{
				DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
				SETTHROW_TESTRESULT(E_FAIL);
			}
			
			ClearDoWorkList(&DoWorkList);
			
			// Prevent any weird group creations.
			hostcontext.fCanGetCreateGroup = FALSE;
			
			// Reset the context.
			CloseHandle(hostcontext.hGotCreateGroupEvent);
			hostcontext.hGotCreateGroupEvent = NULL;
			hostcontext.dpnidGroupCreated = 0;
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing peer client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing host object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerHost->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Peer->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Peer);
		pDP8Peer = NULL;

		FINAL_SUCCESS;
	}
	END_TESTCASE

	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	SAFE_CLOSEHANDLE(hostcontext.hGotCreateGroupEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hGotCreateGroupEvent);
	SAFE_CLOSEHANDLE(hostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(nonhostcontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(hostcontext.hClientCreatedEvent);
	SAFE_RELEASE(pDP8Address);
	ClearDoWorkList(&DoWorkList);
	SAFE_CLOSEHANDLE(hAsyncOpComplete);

	return (sr);
} // ParmVPeerExec_CreateGroup
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/

//==================================================================================
// DpTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI DpTestStartTest(IN HANDLE  hLog)
{
	SESSION_TYPE_CALLBACK CallbackSessionInfo;
	DP_GROUPTESTPARAM GroupTestParam;
	DP_ENUMTESTPARAM EnumTestParam;
	DP_SENDTESTPARAM SendTestParam;
	PDP_HOSTINFO pHostInfoMsg = NULL;
	HRESULT hr = DPN_OK;
	IN_ADDR NetsyncServerAddr, HostAddr, FromAddr, LocalAddr;
	WSADATA WSAData;
	HANDLE hPingObject = NULL, hEnumObject = NULL, hClientObject = NULL;
	DWORD dwHostInfoSize, dwReceiveStatus, dwAddressType;
	BOOL fDPlayInitialized = FALSE;
	WORD LowPort, HighPort;
	INT nRet = 0, i;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "DirectPlay (S-n)");
	xSetFunctionName(g_hLog, "<none>");

	hr = DPlayInitialize(1024 * 200);
	if(hr != DPN_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init DPlay: 0x%08x", hr);
		goto Exit;
	}

	fDPlayInitialized = TRUE;
//	xLog(g_hLog, XLL_INFO, "DirectPlay layer initialized");

	// Determine our local IP address and how it was obtained
	dwAddressType = XnetGetIpAddress(&LocalAddr);

	xLog(g_hLog, XLL_INFO, "Network info:", inet_ntoa(LocalAddr));

	switch(dwAddressType & (XNET_ADDR_NONE | XNET_ADDR_DHCP | XNET_ADDR_AUTOIP | XNET_ADDR_STATIC | XNET_ADDR_LOOPBACK))
	{
	case XNET_ADDR_NONE:
//		xLog(g_hLog, XLL_FAIL, "    No IP address available!");
		goto Exit;
	case XNET_ADDR_DHCP:
//		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was obtained via DHCP", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_AUTOIP:
//		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was obtained via AutoIP", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_STATIC:
//		xLog(g_hLog, XLL_INFO, "    Local IP (%s) was statically assigned", inet_ntoa(LocalAddr));
		break;
	case XNET_ADDR_LOOPBACK:
//		xLog(g_hLog, XLL_INFO, "    Local IP (%s) is a loopback address", inet_ntoa(LocalAddr));
		break;
	default:
		xLog(g_hLog, XLL_FAIL, "GetBestIpAddress returned an unknown value: 0x%08x", dwAddressType);
		goto Exit;
	}

	if(dwAddressType & XNET_HAS_GATEWAY)
		xLog(g_hLog, XLL_INFO, "    Gateway is available");
	else
		xLog(g_hLog, XLL_INFO, "    No gateway is avaiable");

	// Run tests that don't require another machine
//	for(i = DPMSG_LOCAL_BASE; i < DPMSG_LOCAL_MAXTEST; i++)
	for(i = DPMSG_PEER_DESTROYPEER; i <= DPMSG_PEER_DESTROYPEER; i++)
	{
		xSetFunctionName(g_hLog, g_LocalTestNames[i]);

		g_LocalTestFunctions[i](hLog);

		xSetFunctionName(g_hLog, "");
	}
//	for(i = 1; TRUE; i++)
//	{
//		xSetFunctionName(g_hLog, "Test func");
//
//		ParmVPeerExec_CreateGroupProblem(hLog);
//		g_LocalTestFunctions[DPMSG_PEER_GETPEERADDRESS](hLog);
//
//		xSetFunctionName(g_hLog, "");
//	}

/*
	// Prepare to find a server that can run the DP tests
	CallbackSessionInfo.byMinClientCount = 2;
	CallbackSessionInfo.byMaxClientCount = 2;
	CallbackSessionInfo.nMinPortCount = 1;
	CallbackSessionInfo.lpszDllName_W = DP_SERVER_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = DP_SERVER_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = DP_SERVER_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = DP_SERVER_STOP_FUNCTION_A;


	hPingObject = NetsyncFindFirstServer(0, NULL);
	hPingObject ? NetsyncCloseFindServer(hPingObject) : 0;

	// Begin enumerating servers
	hEnumObject = NetsyncFindFirstServer(SESSION_CALLBACK, &CallbackSessionInfo);
	if(hEnumObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't find a server to run DP test");
		goto Exit;
	}

	// Find a specific server
	if(!NetsyncFindServer(hEnumObject, &(NetsyncServerAddr.S_un.S_addr)))
	{
		xLog(g_hLog, XLL_FAIL, "Server refused to run DP test");
		goto Exit;
	}

	// Create a client to communicate with that server
	hClientObject = NetsyncCreateClient(hEnumObject, NetsyncServerAddr.S_un.S_addr, &LowPort, &HighPort);
	if(hClientObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create Netsync client");
		goto Exit;
	}
	
	dwHostInfoSize = 0;
	pHostInfoMsg = NULL;

	// Wait for information on the other hosts in the session from the Netsync server
	dwReceiveStatus = NetsyncReceiveClientMessage(hClientObject, RECEIVE_TIMEOUT, &(FromAddr.S_un.S_addr), &dwHostInfoSize, (char **) &pHostInfoMsg);

	// If we didn't receive the host information from the server then report failure and end the test
	if((dwReceiveStatus != WAIT_OBJECT_0) || (pHostInfoMsg->dwMessageId != DPMSG_HOSTINFO))
	{
		xLog(g_hLog, XLL_FAIL, "Didn't receive host info from server");
		goto Exit;
	}

	// Set up the host machines address as an IN_ADDR for easy conversion to a string
	HostAddr.S_un.S_addr = pHostInfoMsg->dwHostAddr;

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run simple server/client tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	if(!SyncWithOtherTesters(hLog, hClientObject, SIMPLE_SERVER_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	(HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr) ? 
		DirectPlayExec_SimpleServer(hLog, pHostInfoMsg, LowPort) : 
		DirectPlayExec_SimpleClient(hLog, pHostInfoMsg, LowPort);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run simple peer tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	
	if(!SyncWithOtherTesters(hLog, hClientObject, SIMPLE_HOST_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	(HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr) ? 
		DirectPlayExec_SimpleHost(hLog, pHostInfoMsg, LowPort) :
		DirectPlayExec_SimpleConnect(hLog, pHostInfoMsg, LowPort);

/*
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run basic client/server enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fClientServer = TRUE;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run basic peer enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server enum reject tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CSREJECT_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fClientServer = TRUE;
	EnumTestParam.fReject = TRUE;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer enum reject tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEERREJECT_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fReject = TRUE;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server app data enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CSAPP_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fClientServer = TRUE;
	EnumTestParam.dwAppDescDataSize = 100;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer app data enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEERAPP_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.dwAppDescDataSize = 100;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server user data enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CSUSER_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fClientServer = TRUE;
	EnumTestParam.dwUserEnumDataSize = 100;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server user data enum tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEERUSER_ENUM_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.dwUserEnumDataSize = 100;
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_SimpleAll(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run enum validation tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, ENUM_VALIDATE_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&EnumTestParam, 0, sizeof(DP_ENUMTESTPARAM));
	EnumTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	EnumTestParam.hNetsyncObject = hClientObject;
	strcpy(EnumTestParam.szServerIPAddr, inet_ntoa(HostAddr));
	
	EnumsExec_Validate(g_hLog, &EnumTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer group tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_GROUP_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&GroupTestParam, 0, sizeof(DP_GROUPTESTPARAM));
	GroupTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	GroupTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	GroupTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	GroupTestParam.hNetsyncObject = hClientObject;

	GroupsExec_SimplePeer(g_hLog, &GroupTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server group tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_GROUP_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&GroupTestParam, 0, sizeof(DP_GROUPTESTPARAM));
	GroupTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	GroupTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	GroupTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	GroupTestParam.hNetsyncObject = hClientObject;

	GroupsExec_SimpleCS(g_hLog, &GroupTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests to AllPlayersGroup
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests, high priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_HIGH;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests to AllPlayersGroup, high priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_HIGH;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests, low priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_LOW;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests to AllPlayersGroup, low priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_LOW;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests, complete on process
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run peer sends tests to AllPlayersGroup, complete on process
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, PEER_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimplePeer(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests to AllPlayersGroup
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests, high priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_HIGH;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests to AllPlayersGroup, high priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_HIGH;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests, low priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_LOW;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests to AllPlayersGroup, low priority
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_PRIORITY_LOW;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests, complete on process
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// Run client/server sends tests to AllPlayersGroup, complete on process
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	if(!SyncWithOtherTesters(hLog, hClientObject, CS_SENDS_EVENT, NULL, 0, NULL, 0))
		goto Exit;
	
	memset(&SendTestParam, 0, sizeof(DP_SENDTESTPARAM));
	SendTestParam.dwHostAddr = HostAddr.S_un.S_addr;
	SendTestParam.fSendToAllPlayersGroup = TRUE;
	SendTestParam.dwMsgSize = 256;
	SendTestParam.dwNumMachines = pHostInfoMsg->dwTotalMachines;
	SendTestParam.dwNumMsgs = 1000;
	SendTestParam.fHostTest = (HostAddr.S_un.S_addr == LocalAddr.S_un.S_addr);
	SendTestParam.fSendToAllPlayersGroup = FALSE;
	SendTestParam.dwFlags = DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED;
	SendTestParam.hNetsyncObject = hClientObject;

	SendsExec_SimpleCS(g_hLog, &SendTestParam);
*/

Exit:

/*
	hClientObject ? NetsyncCloseClient(hClientObject) : 0;
	hEnumObject ? NetsyncCloseFindServer(hEnumObject) : 0;
	pHostInfoMsg ? NetsyncFreeMessage((char *) pHostInfoMsg) : 0;
*/

	if(fDPlayInitialized)
	{
		hr = DPlayCleanup();
		if(hr != DPN_OK)
			xLog(g_hLog, XLL_FAIL, "Couldn't cleanup DPlay: 0x%08x", hr);
//		else
//			xLog(g_hLog, XLL_INFO, "DirectPlay layer cleaned-up");
	}

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// DpTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI DpTestEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// Helper functions
//==================================================================================

//==================================================================================
// DPTEST_TRACE
//----------------------------------------------------------------------------------
//
// Description: Wrapper for the logging stuff that was imported from testnet
//
// Arguments:
//	HANDLE hLog							Indicates level to log message as
//	LPCTSTR szFormat					Buffer that contains the format string
//	INT nNumArgs						Indicates the number of variable arguments present
//
// Returns: nothing
//==================================================================================
void DPTEST_TRACE(HANDLE hLog, LPSTR szFormat, INT nNumArgs ...) {
	CHAR szBuffer[1024] = "";
	va_list pArgs; 

	va_start(pArgs, nNumArgs);
	
	if(!hLog)
	{
		vsprintf(szBuffer, szFormat, pArgs);
//		DbgPrint(szBuffer);
	}
	else
		xLog_va(hLog, XLL_INFO, szFormat, pArgs);
	
	va_end(pArgs);
}

//==================================================================================
// DPTEST_FAIL
//----------------------------------------------------------------------------------
//
// Description: Wrapper for the logging stuff that was imported from testnet
//
// Arguments:
//	HANDLE hLog							Indicates level to log message as
//	LPCTSTR szFormat					Buffer that contains the format string
//	INT nNumArgs						Indicates the number of variable arguments present
//
// Returns: nothing
//==================================================================================
void DPTEST_FAIL(HANDLE hLog, LPSTR szFormat, INT nNumArgs ...) {
	CHAR szBuffer[1024] = "";
	va_list pArgs; 

	va_start(pArgs, nNumArgs);
	
	if(!hLog)
	{
		vsprintf(szBuffer, szFormat, pArgs);
//		DbgPrint(szBuffer);
	}
	else
		xLog_va(hLog, XLL_FAIL, szFormat, pArgs);
	
	va_end(pArgs);
}

} // namespace DPlayCoreNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( dptest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( dptest )
    EXPORT_TABLE_ENTRY( "StartTest", DpTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", DpTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", DpTestDllMain )
END_EXPORT_TABLE( dptest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\enums.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Defines
//==================================================================================
#define ENUMDATAPATTERN_APPDESC		0x12345678
#define ENUMDATAPATTERN_QUERY		0x0711F00D
#define ENUMDATAPATTERN_RESPONSE	0xB001B00F

#define ENUM_HOSTS_TIMEOUT			60000
#define ENUM_SESSION_NAME			L"EnumSession"

#define ADDRESSES_EVENT_NAME		"HostAddresses"
#define ENUMSDONE_EVENT_NAME		"EnumsDone"
#define BUFRETURNED_EVENT_NAME		"BufReturned"

#define VALHOSTADDR_EVENT_NAME		"ValHostAddrs"
#define CSTOPPDONE_EVENT_NAME		"CS2PPDone"
#define PPTOCSDONE_EVENT_NAME		"PP2CSDone"
#define CSCAPPED_EVENT_NAME			"CSCapped"
#define CSMAXPLAYER_EVENT_NAME		"CSMaxPlayer"
#define PPCAPPED_EVENT_NAME			"PPCapped"
#define PPMAXPLAYER_EVENT_NAME		"PPMaxPlayer"
#define CSPW_EVENT_NAME				"CSPW"
#define CSPWDONE_EVENT_NAME			"CSPWDone"
#define PPPW_EVENT_NAME				"PPPW"
#define PPPWDONE_EVENT_NAME			"PPPWDone"
#define NONHOST_EVENT_NAME			"NonHost"
#define NONHOSTDONE_EVENT_NAME		"NonHostDone"

//==================================================================================
// Structures
//==================================================================================

typedef struct tagHOSTADDRESSESSYNCDATA
{
	DWORD				dwNumAddresses; // number of addresses the host has in the following buffer
	
	// Anything after this is part of the host's addresses blob.
} HOSTADDRESSESSYNCDATA, * PHOSTADDRESSESSYNCDATA;

typedef struct tagHOSTADDRESSESCSANDPEERSYNCDATA
{
	DWORD				dwNumAddressesCS; // number of addresses for c/s session the host has in the following buffer
	DWORD				dwNumAddressesPeer; // number of addresses for peer session the host has in the following buffer
	
	// Anything after this is part of the host's addresses blobs.
} HOSTADDRESSESCSANDPEERSYNCDATA, * PHOSTADDRESSESCSANDPEERSYNCDATA;

typedef struct tagENUMSSIMPLECONTEXT
{
	PDP_ENUMTESTPARAM	pEnumTestParam; // pointer to test parameters
	HANDLE				hLog; // handle to logging subsystem
	DWORD				dwNumMsgs; // number of messages received (queries on host, responses on clients)
	DWORD				dwAppDescDataSize; // size of application desc data expected
	PVOID				pvUserData; // pointer to user data payload to send with query/response
	DWORD				dwUserDataSize; // size of user data payload to send with query/response
	BOOL				fDontRespondWithData; // boolean that will be set when responses should not be responded to with data anymore
	LONG				lNumOutstandingResponseData; // number of outstanding responses that haven't returned the data yet
	BOOL				fReject; // whether the host should refuse to respond or not
	BOOL				fCancelled; // has the enum been cancelled yet
} ENUMSSIMPLECONTEXT, * PENUMSSIMPLECONTEXT;

typedef struct tagENUMSVALIDATECONTEXT
{
	PDP_ENUMTESTPARAM	pEnumTestParam; // pointer to test parameters
	HANDLE				hLog; // handle to logging subsystem
	DWORD				dwNumMsgs; // number of messages received (queries on host, responses on clients)
	DWORD				dwExpectedMaxPlayers; // expected number of max players in enum app descs
} ENUMSVALIDATECONTEXT, * PENUMSVALIDATECONTEXT;




//==================================================================================
// Prototypes
//==================================================================================

HRESULT EnumsSimpleDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT EnumsValidateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
//HRESULT EnumsStartUpDownDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);


#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsExec_SimpleAll()"
//==================================================================================
// EnumsExec_SimpleAll
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.4.1 - Simple peer-to-peer enumeration test
//				2.4.2 - Simple client/server enumeration test
//
// Arguments:
//	HANDLE				hLog				Handle to the logging subsystem
//	DP_ENUMTESTPARAM	*pEnumTestParam		Pointer to parameters for this test
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT EnumsExec_SimpleAll(HANDLE hLog, PDP_ENUMTESTPARAM pEnumTestParam)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	ENUMSSIMPLECONTEXT		context;
	DPN_APPLICATION_DESC	dpnad;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8SERVER			pDP8Server = NULL;
	PWRAPDP8CLIENT			pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressLocal = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressRemote = NULL;
	HANDLE					hEnumDoneEvent = NULL;
	DPNHANDLE				dpnhEnumHosts = NULL;
	PHOSTADDRESSESSYNCDATA	pHostAddressesSyncData = NULL;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	LPVOID					pvSyncData = NULL;
	DWORD					dwSyncDataSize;
	DWORD					dwNumAddresses = 0;
	DWORD					dwWaitResult;
	DWORD					dwTemp;
	DWORD					dwURLsBufferSize = 0;
	DWORD					dwRemainingBufferSize;
	char*					pszURL;
	DWORD					dwSize;
	DWORD					dwDataType;
	WCHAR					wszIPCompareString[16]; // max IP string size + NULL termination

	ZeroMemory(&context, sizeof (ENUMSSIMPLECONTEXT));
	ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));

	BEGIN_TESTCASE
	{
		context.dwAppDescDataSize = pEnumTestParam->dwAppDescDataSize;
		context.dwUserDataSize = pEnumTestParam->dwUserEnumDataSize;
		context.pEnumTestParam = pEnumTestParam;
		context.hLog = hLog;

		if (context.dwUserDataSize > 0)
		{
			LOCALALLOC_OR_THROW( PVOID, context.pvUserData, context.dwUserDataSize);

			// Fill the memory with some pattern (different for queries vs.
			// responses).
			FillWithDWord(context.pvUserData, context.dwUserDataSize,
						((pEnumTestParam->fHostTest) ? ENUMDATAPATTERN_RESPONSE : ENUMDATAPATTERN_QUERY));
		} // end if (data should be sent)

		context.fReject = pEnumTestParam->fReject;


		if(pEnumTestParam->fClientServer)
		{

			if(pEnumTestParam->fHostTest)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Server object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Server = new CWrapDP8Server(hLog);
				if (pDP8Server == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)


				tr = pDP8Server->CoCreate();
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "CoCreating DP8Server object failed!", 0);
					THROW_TESTRESULT;
				} // end if (function failed)

			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Client = new CWrapDP8Client(hLog);
				if (pDP8Client == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)


				tr = pDP8Client->CoCreate();
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "CoCreating DP8Client object failed!", 0);
					THROW_TESTRESULT;
				} // end if (function failed)

			} // end else (not tester 0)
			
		} // end if (client/server)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8Peer = new CWrapDP8Peer(hLog);
			if (pDP8Peer == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8Peer->CoCreate();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "CoCreating DP8Peer object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)

		} // end else (peer-to-peer)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8AddressCreate local address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressLocal, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't DirectPlay8AddressCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if (pEnumTestParam->fClientServer)
		{
			if (pEnumTestParam->fHostTest)
			{
				tr = pDP8Server->DP8S_Initialize(&context,
												EnumsSimpleDPNMessageHandler,
												0);
			} // end if pEnumTestParam->fHostTest
			else
			{
				tr = pDP8Client->DP8C_Initialize(&context,
												EnumsSimpleDPNMessageHandler,
												0);
			} // end else !pEnumTestParam->fHostTest
		} // end if (client/server)
		else
		{
			tr = pDP8Peer->DP8P_Initialize(&context,
											EnumsSimpleDPNMessageHandler,
											0);
		} // end else (peer-to-peer)

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't initialize!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)

		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		if (pEnumTestParam->fHostTest && pEnumTestParam->fClientServer)
			dpnad.dwFlags |= DPNSESSION_CLIENT_SERVER;
		dpnad.guidApplication = GUID_ENUMS_SIMPLE;
		dpnad.pwszSessionName = pEnumTestParam->fHostTest ? ENUM_SESSION_NAME : NULL;
		if (pEnumTestParam->fHostTest && pEnumTestParam->dwAppDescDataSize)
		{
			dpnad.dwApplicationReservedDataSize = pEnumTestParam->dwAppDescDataSize;
			LOCALALLOC_OR_THROW( PVOID, dpnad.pvApplicationReservedData, pEnumTestParam->dwAppDescDataSize);

			FillWithDWord(dpnad.pvApplicationReservedData, pEnumTestParam->dwAppDescDataSize, ENUMDATAPATTERN_APPDESC);
		} // end if (hosting test and there's app desc data)


		// Tester 0 should start hosting a session, tester 1 should wait until
		// the session is up.
		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (pEnumTestParam->fClientServer)
			{
				tr = pDP8Server->DP8S_Host(&dpnad, &pDP8AddressLocal, 1, NULL, NULL, NULL, 0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_Host(&dpnad, &pDP8AddressLocal, 1, NULL, NULL, NULL, 0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)


			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting host addresses");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (pEnumTestParam->fClientServer)
			{
				tr = pDP8Server->DP8S_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);
			} // end else (peer-to-peer)

			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Couldn't get number of host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)

			DPTEST_TRACE(hLog, "We are hosting on %u addresses.", 1, dwNumAddresses); 

			LOCALALLOC_OR_THROW( PDIRECTPLAY8ADDRESS*, paDP8HostAddresses, dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));


			if (pEnumTestParam->fClientServer)
			{
				tr = pDP8Server->DP8S_GetLocalHostAddresses(paDP8HostAddresses, &dwNumAddresses, 0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_GetLocalHostAddresses(paDP8HostAddresses, &dwNumAddresses, 0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get host address)


			// Get the total size of all the addresses.
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = 0;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(NULL, &dwSize);
				if (tr != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_FAIL(hLog, "Couldn't get host address %u's URL size!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (not buffer too small)
				
				dwURLsBufferSize += dwSize;
			} // end for (each address)

			// Allocate a buffer for all the URLs.
			LOCALALLOC_OR_THROW( PHOSTADDRESSESSYNCDATA,
								pHostAddressesSyncData,
								sizeof (HOSTADDRESSESSYNCDATA) + dwURLsBufferSize);

			pHostAddressesSyncData->dwNumAddresses = dwNumAddresses;
			pszURL = (char*) (pHostAddressesSyncData + 1);
			dwRemainingBufferSize = dwURLsBufferSize;


			// Actually fill in all the URLs and release the objects (since we're
			// done with them).
			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				dwSize = dwRemainingBufferSize;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(pszURL,
														&dwSize);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't get host address %u's URL!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (failed)


				DPTEST_TRACE(hLog, "Address %u: \"%s\"", 2, dwTemp, pszURL);

				dwRemainingBufferSize -= dwSize;
				pszURL += dwSize;

				
				// We're done with this address object.
				paDP8HostAddresses[dwTemp]->Release();
				paDP8HostAddresses[dwTemp] = NULL;
			} // end for (each address)

			// We're done with the address array.
			MemFree(paDP8HostAddresses);
			paDP8HostAddresses = NULL;


			// Make sure we used all of the buffer.
			if (dwRemainingBufferSize != 0)
			{
				DPTEST_FAIL(hLog, "Didn't use all of or overran the allocated buffer (didn't use %i bytes)!",
					1, ((int) dwRemainingBufferSize));
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (didn't use all of the buffer)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending session addresses to enumerator");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, ADDRESSES_EVENT_NAME, (PBYTE) pHostAddressesSyncData,
				sizeof(HOSTADDRESSESSYNCDATA) + dwURLsBufferSize, NULL, 0))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, ADDRESSES_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Receiving addresses of host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			LOCALALLOC_OR_THROW( LPVOID, pvSyncData, MAX_SYNC_DATASIZE);

			dwSyncDataSize = MAX_SYNC_DATASIZE;
			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, ADDRESSES_EVENT_NAME, NULL, 0, (PBYTE) pvSyncData, &dwSyncDataSize))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, ADDRESSES_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

			if(dwSyncDataSize < (DWORD) (sizeof (HOSTADDRESSESSYNCDATA) + (strlen(DPNA_HEADER_A) + 1)))
			{
				DPTEST_FAIL(hLog, "Received sync data is below minimum amount (%u < %u)", 2,
					dwSyncDataSize, (sizeof (HOSTADDRESSESSYNCDATA) + (strlen(DPNA_HEADER_A) + 1)));
				SETTHROW_TESTRESULT(E_ABORT);
			}

			dwNumAddresses = ((PHOSTADDRESSESSYNCDATA) pvSyncData)->dwNumAddresses;

			// Start with the first address
			pszURL = (char*) (((PBYTE) pvSyncData) + sizeof (HOSTADDRESSESSYNCDATA));

			DPTEST_TRACE(hLog, "Tester 0 (host) has %u connectable addresses.", 1, dwNumAddresses);

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressRemote, NULL);
			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't DirectPlay8CreateAddress remote (host's) address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)

			for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
			{
				DPTEST_TRACE(hLog, "Host address %u: %s", 2, dwTemp, pszURL);


				DPTEST_TRACE(hLog, "Building remote address %u from string URL.", 1, dwTemp);


				tr = pDP8AddressRemote->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't build host's address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPTEST_TRACE(hLog, "Getting remote address %u's hostname component.", 1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemote->GetComponentByName(DPNA_KEY_HOSTNAME,
															wszIPCompareString,
															&dwSize,
															&dwDataType);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't get host's address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPTEST_FAIL(hLog, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPTEST_FAIL(hLog, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(hLog, wszIPCompareString, pEnumTestParam->szServerIPAddr, TRUE))
				{
					DPTEST_TRACE(hLog, "Found IP address \"%s\", using host's address %u (\"%s\").",
						3, pEnumTestParam->szServerIPAddr, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddresses)
			{
				DPTEST_FAIL(hLog, "Couldn't find the correct host address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)

			// We've determined what the host's real address should be.  However, we
			// don't use that for EnumHosts when broadcasting, so start from scratch.

			if(pEnumTestParam->fBroadcast)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Clearing remote (host's) address object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8AddressRemote->Clear();
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't clear remote (host's) address object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't clear)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Setting remote (host's) address object's SP");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8AddressRemote->SetSP(&CLSID_DP8SP_TCPIP);

				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't set SP for remote (host's) address object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't set SP)

			} // end if (broadcasting)
			


			// At this point, the remote address object has the correct host
			// address we should use when enumerating.


			CREATEEVENT_OR_THROW(hEnumDoneEvent, NULL, FALSE, FALSE, NULL);

			if (pEnumTestParam->fClientServer)
			{
				tr = pDP8Client->DP8C_EnumHosts(&dpnad,
												pDP8AddressRemote,
												pDP8AddressLocal,
												context.pvUserData,
												context.dwUserDataSize,
												pEnumTestParam->dwEnumCount,
												pEnumTestParam->dwRetryInterval,
												pEnumTestParam->dwTimeOut,
												hEnumDoneEvent,
												&dpnhEnumHosts,
												0);
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_EnumHosts(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											context.pvUserData,
											context.dwUserDataSize,
											pEnumTestParam->dwEnumCount,
											pEnumTestParam->dwRetryInterval,
											pEnumTestParam->dwTimeOut,
											hEnumDoneEvent,
											&dpnhEnumHosts,
											0);
			} // end else (peer-to-peer)

			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)



			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			pDP8AddressRemote->Release();
			pDP8AddressRemote = NULL;



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			dwWaitResult = WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT);
			if((dwWaitResult != WAIT_OBJECT_0) && (dwWaitResult != WAIT_TIMEOUT))
			{
				DPTEST_FAIL(hLog, "Failure waiting for enumeration: %u", 1, dwWaitResult);
				THROW_SYSTEMRESULT;
			}
												
			sr = (HRESULT) S_OK;

			// If it timed out, it's time to cancel the enumeration.
			if(dwWaitResult == WAIT_TIMEOUT)
			{
				// Cancel the enumeration.  Note that we're doing it.
				// NOTE: There's a window where the enum could finish on its own
				// just before we go to cancel it.
				context.fCancelled = TRUE;

				if (pEnumTestParam->fClientServer)
				{
					tr = pDP8Client->DP8C_CancelAsyncOperation(dpnhEnumHosts, 0);
				} // end if (client/server)
				else
				{
					tr = pDP8Peer->DP8P_CancelAsyncOperation(dpnhEnumHosts, 0);
				} // end else (peer-to-peer)

				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't cancel enumeration!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't cancel enumeration)


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for cancelled enumeration to complete");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				
				if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
				{
					DPTEST_FAIL(hLog, "Canceled enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
					THROW_SYSTEMRESULT;
				}
				
				sr = (HRESULT) S_OK;

			} // end if (wait timed out)
			



			CloseHandle(hEnumDoneEvent);
			hEnumDoneEvent = NULL;


			// Make sure we saw some responses come in if the host wasn't rejecting
			// our queries.
			if (! pEnumTestParam->fReject)
			{
				if (context.dwNumMsgs == 0)
				{
					DPTEST_FAIL(hLog, "Didn't receive any enum responses!", 0);
					SETTHROW_TESTRESULT(ERROR_NO_DATA);
				} // end if (no responses)
//#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//#pragma WAITFORDEVFIX(vanceo, ?, ?, "EnumCount still acts like RetryCount")
				/*
				else if ((pEnumTestParam->dwEnumCount > 0) &&
						(context.dwNumMsgs > pEnumTestParam->dwEnumCount))
				*/
				else if ((pEnumTestParam->dwEnumCount > 0) &&
						(context.dwNumMsgs > (pEnumTestParam->dwEnumCount + 1)))
				{
					DPTEST_FAIL(hLog, "Received too many enum responses (%u > %u)!",
						2, context.dwNumMsgs, pEnumTestParam->dwEnumCount);
					SETTHROW_TESTRESULT(E_FAIL);
				} // end else if (too many responses)
				else
				{
					DPTEST_TRACE(hLog, "Received %u enum responses.", 1, context.dwNumMsgs);
				} // end else (valid num responses)
			} // end if (not rejecting)
		} // end else (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Implement this using Netsync
		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, ENUMSDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, ENUMSDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		// Make sure we saw some queries and all our buffers got returned.
		if(pEnumTestParam->fHostTest)
		{
			if (context.dwNumMsgs == 0)
			{
				DPTEST_FAIL(hLog, "Didn't receive any enum queries!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (no queries)
//#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//#pragma WAITFORDEVFIX(vanceo, ?, ?, "EnumCount still acts like RetryCount")
			/*
			else if ((pEnumTestParam->dwEnumCount > 0) &&
					(context.dwNumMsgs > pEnumTestParam->dwEnumCount))
			*/
			else if ((pEnumTestParam->dwEnumCount > 0) &&
					(context.dwNumMsgs > (pEnumTestParam->dwEnumCount + 1)))
			{
				DPTEST_FAIL(hLog, "Received too many enum queries (%u > %u)!",
					2, context.dwNumMsgs, pEnumTestParam->dwEnumCount);
				SETTHROW_TESTRESULT(E_FAIL);
			} // end else if (too many queries)
			else
			{
				DPTEST_TRACE(hLog, "Received %u enum queries.", 1, context.dwNumMsgs);
			} // end else (valid num queries)


			if(context.pvUserData != NULL)
			{
				DWORD dwCurrentRetry = 0;
				// This is somewhat murky, since we don't know how many enums are
				// coming in, so we don't know how many responses went out.
				//
				// We also don't know when the queries will stop trickling in, so
				// theoretically we could still be receiving the responses.  Thus,
				// even though the outstanding count could hit 0 now, it might pop
				// back up if another query came in.  To solve that, we're going to
				// signal the callback to not give any more data to DPlay if they do
				// come in, and we can just wait til the count hits zero.
				context.fDontRespondWithData = TRUE;

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for response buffers to be returned");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				// TODO - there needs to be a time limit established
				while ((context.lNumOutstandingResponseData != 0) && (dwCurrentRetry < 5))
				{
					DPTEST_FAIL(hLog, "Waiting for %i response buffers to be returned.",
						1, context.lNumOutstandingResponseData);

					Sleep(1000);
					++dwCurrentRetry;
				} // end while (still more buffers outstanding)

				if(dwCurrentRetry >= 5)
				{
					DPTEST_FAIL(hLog, "Outstanding response data wasn't returned within %u seconds", 1, dwCurrentRetry);
					SETTHROW_TESTRESULT(E_FAIL);
				}

			} // end if (sent data)
			
		} // end if (tester 0)
		




		if(context.pvUserData != NULL)
		{
			if(pEnumTestParam->fHostTest)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Notifiying other tester that buffers are returned");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for host's reply buffers to be returned");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			} // end else (not tester 0)
			
			
			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, BUFRETURNED_EVENT_NAME, NULL, 0, NULL, 0))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, BUFRETURNED_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}
		
		} // end if (sent data)
		




		if(pEnumTestParam->fClientServer)
		{
			if(pEnumTestParam->fHostTest)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Server->DP8S_Close(0);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Server object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Server->Release();
				if (tr != S_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)

				delete (pDP8Server);
				pDP8Server = NULL;

			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Closing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->DP8C_Close(0);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)

				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Client object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Client->Release();
				if (tr != S_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)

				delete (pDP8Client);
				pDP8Client = NULL;
			
			} // end else (not tester 0)
			
		} // end if (client/server)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->DP8P_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Peer->Release();
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8Peer);
			pDP8Peer = NULL;
			
		} // end else (peer-to-peer)
		



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (paDP8HostAddresses != NULL)
	{
		for(dwTemp = 0; dwTemp < dwNumAddresses; dwTemp++)
		{
			SAFE_RELEASE(paDP8HostAddresses[dwTemp]);
		} // end for (each address)

		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (have array of host addresses)

	SAFE_LOCALFREE(pvSyncData);
	SAFE_LOCALFREE(dpnad.pvApplicationReservedData);
	SAFE_LOCALFREE(context.pvUserData);
	SAFE_LOCALFREE(pHostAddressesSyncData);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_CLOSEHANDLE(hEnumDoneEvent);

	
	return (sr);
} // EnumsExec_SimpleAll
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsExec_Validate()"
//==================================================================================
// EnumsExec_Validate
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.4.3 - Procedural validation enumeration types test
//
// Arguments:
//	HANDLE				hLog				Handle to the logging subsystem
//	DP_ENUMTESTPARAM	*pEnumTestParam		Pointer to parameters for this test
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT EnumsExec_Validate(HANDLE hLog, DP_ENUMTESTPARAM *pEnumTestParam)
{
	CTNSystemResult						sr;
	CTNTestResult						tr;
	ENUMSVALIDATECONTEXT				context;
	DPN_APPLICATION_DESC				dpnadCS;
	DPN_APPLICATION_DESC				dpnadPeer;
	PVOID								pvSyncData = NULL;
	DWORD								dwSyncDataSize;
	PWRAPDP8PEER						pDP8PeerHost = NULL;
	PWRAPDP8PEER						pDP8PeerClient = NULL;
	PWRAPDP8SERVER						pDP8Server = NULL;
	PWRAPDP8CLIENT						pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressLocal = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressRemoteCS = NULL;
	PDIRECTPLAY8ADDRESS					pDP8AddressRemotePeer = NULL;
	HANDLE								hEnumDoneEvent = NULL;
	DPNHANDLE							dpnhEnumHosts = NULL;
	PHOSTADDRESSESCSANDPEERSYNCDATA		pHostAddressesCSAndPeerSyncData = NULL;
	PDIRECTPLAY8ADDRESS*				paDP8HostAddresses = NULL;
	DWORD								dwNumAddressesCS = 0;
	DWORD								dwNumAddressesPeer = 0;
	DWORD								dwTemp;
	DWORD								dwURLsBufferSize = 0;
	DWORD								dwRemainingBufferSize;
	char*								pszURL;
	DWORD								dwSize;
	DWORD								dwDataType;
	WCHAR								wszIPCompareString[16]; // max IP string size + NULL termination

	ZeroMemory(&context, sizeof (ENUMSVALIDATECONTEXT));

	BEGIN_TESTCASE
	{
		context.hLog = hLog;
		context.pEnumTestParam = pEnumTestParam;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Client = new CWrapDP8Client(hLog);
		if (pDP8Client == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)


		tr = pDP8Client->CoCreate();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "CoCreating DP8Client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (function failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8PeerClient = new CWrapDP8Peer(hLog);
		if (pDP8PeerClient == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)


		tr = pDP8PeerClient->CoCreate();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "CoCreating DP8Peer object failed!", 0);
			THROW_TESTRESULT;
		} // end if (function failed)


		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating DirectPlay8Server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8Server = new CWrapDP8Server(hLog);
			if (pDP8Server == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8Server->CoCreate();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "CoCreating DP8Server object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating secondary DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8PeerHost = new CWrapDP8Peer(hLog);
			if (pDP8PeerClient == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)


			tr = pDP8PeerHost->CoCreate();
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "CoCreating DP8Peer object failed!", 0);
				THROW_TESTRESULT;
			} // end if (function failed)

		} // end if (tester 0)
		





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating local address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressLocal, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting local address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing objects");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Initialize(&context,
										EnumsValidateDPNMessageHandler,
										0);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't initialize client interface!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


		tr = pDP8PeerClient->DP8P_Initialize(&context,
											EnumsValidateDPNMessageHandler,
											0);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't initialize peer client interface!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)


		if (pEnumTestParam->fHostTest)
		{
			tr = pDP8Server->DP8S_Initialize(&context,
											EnumsValidateDPNMessageHandler,
											0);
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't initialize server interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't initialize)


			tr = pDP8PeerHost->DP8P_Initialize(&context,
												EnumsValidateDPNMessageHandler,
												0);
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't initialize peer host interface!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't initialize)
		} // end if (tester 0)



		ZeroMemory(&dpnadCS, sizeof (DPN_APPLICATION_DESC));
		dpnadCS.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnadCS.dwFlags = 0;
		dpnadCS.dwFlags = (pEnumTestParam->fHostTest) ? DPNSESSION_CLIENT_SERVER : 0;
		//dpnadCS.guidInstance = GUID_NULL;
		dpnadCS.guidApplication = GUID_ENUMS_VALIDATE;
		//dpnadCS.dwMaxPlayers = 0;
		//dpnadCS.dwCurrentPlayers = 0;
		dpnadCS.pwszSessionName = (pEnumTestParam->fHostTest) ? ENUM_SESSION_NAME : NULL;
		//dpnadCS.pwszPassword = NULL;
		//dpnadCS.pvReservedData = NULL;
		//dpnadCS.dwReservedDataSize = 0;
		//dpnadCS.pvApplicationReservedData = NULL;
		//dpnad.CSpvApplicationReservedData = 0;



		ZeroMemory(&dpnadPeer, sizeof (DPN_APPLICATION_DESC));
		dpnadPeer.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnadPeer.dwFlags = 0;
		dpnadPeer.dwFlags = 0;
		//dpnadPeer.guidInstance = GUID_NULL;
		dpnadPeer.guidApplication = GUID_ENUMS_VALIDATE;
		//dpnadPeer.dwMaxPlayers = 0;
		//dpnadPeer.dwCurrentPlayers = 0;
		dpnadPeer.pwszSessionName = (pEnumTestParam->fHostTest) ? ENUM_SESSION_NAME : NULL;
		//dpnadPeer.pwszPassword = NULL;
		//dpnadPeer.pvReservedData = NULL;
		//dpnadPeer.dwReservedDataSize = 0;
		//dpnadPeer.pvApplicationReservedData = NULL;
		//dpnadPeer.pvApplicationReservedData = 0;




		// Tester 0 should start hosting the sessions, tester 1 should wait until
		// they are up.
		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_Host(&dpnadCS, &pDP8AddressLocal, 1, NULL, NULL,
										NULL, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't start hosting client/server session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Hosting session peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_Host(&dpnadPeer, &pDP8AddressLocal, 1, NULL, NULL,
										NULL, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't start hosting peer session!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't host session)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting number of host addresses for client/server");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_GetLocalHostAddresses(NULL, &dwNumAddressesCS, 0);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Couldn't get number of client/server host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get local host addresses)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Getting number of host addresses for peer-to-peer");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_GetLocalHostAddresses(NULL, &dwNumAddressesPeer, 0);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Couldn't get number of peer-to-peer host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't get local host addresses)


			DPTEST_TRACE(hLog, "We are hosting on %u C/S addresses and %u peer addresses.",
				2, dwNumAddressesCS, dwNumAddressesPeer); 


			LOCALALLOC_OR_THROW( PDIRECTPLAY8ADDRESS*, paDP8HostAddresses,
								(dwNumAddressesCS + dwNumAddressesPeer) * sizeof (PDIRECTPLAY8ADDRESS));



			tr = pDP8Server->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
														&dwNumAddressesCS,
														0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get c/s host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't local host addresses)


			tr = pDP8PeerHost->DP8P_GetLocalHostAddresses(paDP8HostAddresses + dwNumAddressesCS,
														&dwNumAddressesPeer,
														0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get peer host addresses!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't local host addresses)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting local c/s client to local session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_Connect(&dpnadCS,
										paDP8HostAddresses[0],
										pDP8AddressLocal,
										NULL,
										NULL,
										NULL,
										0,
										NULL,
										NULL,
										DPNCONNECT_SYNC);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't connect!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Connecting local peer client to local session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_Connect(&dpnadPeer,
											paDP8HostAddresses[dwNumAddressesCS],
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											NULL,
											NULL,
											DPNCONNECT_SYNC);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't connect!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't connect)


			pDP8AddressLocal->Release();
			pDP8AddressLocal = NULL;

			// Get the total size of all the addresses.
			for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
			{
				dwSize = 0;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(NULL, &dwSize);
				if (tr != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_FAIL(hLog, "Couldn't get host address %u's URL size!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (not buffer too small)
				
				dwURLsBufferSize += dwSize;
			} // end for (each address)

			// Allocate a buffer for all the URLs.
			LOCALALLOC_OR_THROW( PHOSTADDRESSESCSANDPEERSYNCDATA,
								pHostAddressesCSAndPeerSyncData,
								sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + dwURLsBufferSize);

			pHostAddressesCSAndPeerSyncData->dwNumAddressesCS = dwNumAddressesCS;
			pHostAddressesCSAndPeerSyncData->dwNumAddressesPeer = dwNumAddressesPeer;
			pszURL = (char*) (pHostAddressesCSAndPeerSyncData + 1);
			dwRemainingBufferSize = dwURLsBufferSize;


			// Actually fill in all the URLs and release the objects (since we're
			// done with them).
			for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
			{
				dwSize = dwRemainingBufferSize;
				tr = paDP8HostAddresses[dwTemp]->GetURLA(pszURL,
														&dwSize);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't get host address %u's URL!", 1, dwTemp);
					THROW_TESTRESULT;
				} // end if (failed)


				DPTEST_TRACE(hLog, "Address %u: \"%s\"",
					2, dwTemp, pszURL);

				dwRemainingBufferSize -= dwSize;
				pszURL += dwSize;

				
				// We're done with this address object.
				paDP8HostAddresses[dwTemp]->Release();
				paDP8HostAddresses[dwTemp] = NULL;
			} // end for (each address)

			// We're done with the address array.
			MemFree(paDP8HostAddresses);
			paDP8HostAddresses = NULL;


			// Make sure we used all of the buffer.
			if (dwRemainingBufferSize != 0)
			{
				DPTEST_FAIL(hLog, "Didn't use all of or overran the allocated buffer (didn't use %i bytes)!",
					1, ((int) dwRemainingBufferSize));
				SETTHROW_TESTRESULT(E_FAIL);
			} // end if (didn't use all of the buffer)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sending session addresses to connector");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, VALHOSTADDR_EVENT_NAME,
				(BYTE *) pHostAddressesCSAndPeerSyncData, (sizeof(HOSTADDRESSESCSANDPEERSYNCDATA) + dwURLsBufferSize), NULL, 0))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, VALHOSTADDR_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

			MemFree(pHostAddressesCSAndPeerSyncData);
			pHostAddressesCSAndPeerSyncData = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for connector to finish connecting to wrong interface type");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Receiving addresses of host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			LOCALALLOC_OR_THROW( LPVOID, pvSyncData, MAX_SYNC_DATASIZE);

			dwSyncDataSize = MAX_SYNC_DATASIZE;
			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, VALHOSTADDR_EVENT_NAME,
				NULL, 0, (PBYTE) pvSyncData, &dwSyncDataSize))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, VALHOSTADDR_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

			if(dwSyncDataSize < (DWORD) (sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + ((strlen(DPNA_HEADER_A) + 1) * 2)))
			{
				DPTEST_FAIL(hLog, "Received sync data is below minimum amount (%u < %u)", 2,
					dwSyncDataSize, (sizeof (HOSTADDRESSESCSANDPEERSYNCDATA) + ((strlen(DPNA_HEADER_A) + 1) * 2)));
				SETTHROW_TESTRESULT(E_ABORT);
			}

			dwNumAddressesCS = ((PHOSTADDRESSESCSANDPEERSYNCDATA) pvSyncData)->dwNumAddressesCS;
			dwNumAddressesPeer = ((PHOSTADDRESSESCSANDPEERSYNCDATA) pvSyncData)->dwNumAddressesPeer;

			// Start with the first address
			pszURL = (char*) (((PBYTE) pvSyncData) + sizeof (HOSTADDRESSESCSANDPEERSYNCDATA));

			DPTEST_TRACE(hLog, "Tester 0 (host) has %u c/s and %u peer connectable addresses.",
				2, dwNumAddressesCS, dwNumAddressesPeer);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) client/server address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressRemoteCS, NULL);
			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't CoCreate remote (host's) client/server address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating remote (host's) peer-to-peer address object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressRemotePeer, NULL);
			if (sr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't CoCreate remote (host's) peer-to-peer address object!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't CoCreate object)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate c/s address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			for(dwTemp = 0; dwTemp < dwNumAddressesCS; dwTemp++)
			{
				DPTEST_TRACE(hLog, "Host c/s address %u: %s", 2, dwTemp, pszURL);


				DPTEST_TRACE(hLog, "Building remote c/s address %u from string URL.", 1, dwTemp);

				tr = pDP8AddressRemoteCS->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't build host's c/s address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPTEST_TRACE(hLog, "Getting remote c/s address %u's hostname component.", 1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemoteCS->GetComponentByName(DPNA_KEY_HOSTNAME,
															wszIPCompareString,
															&dwSize,
															&dwDataType);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't get host's c/s address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPTEST_FAIL(hLog, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPTEST_FAIL(hLog, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(hLog, wszIPCompareString, pEnumTestParam->szServerIPAddr, TRUE))
				{
					DPTEST_TRACE(hLog, "Found IP address \"%s\", using host's c/s address %u (\"%s\").",
						3, pEnumTestParam->szServerIPAddr, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddressesCS)
			{
				DPTEST_FAIL(hLog, "Couldn't find the correct host c/s address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)



			// Move to the start of the peer addresses.
			while (dwTemp < dwNumAddressesCS)
			{
				pszURL += strlen(pszURL) + 1;
				dwTemp++;
			} // end for (each host address)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Finding appropriate peer address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			for(dwTemp = 0; dwTemp < dwNumAddressesPeer; dwTemp++)
			{
				DPTEST_TRACE(hLog, "Host peer address %u: %s", 2, dwTemp, pszURL);


				DPTEST_TRACE(hLog, "Building remote peer address %u from string URL.", 1, dwTemp);

				tr = pDP8AddressRemotePeer->BuildFromURLA(pszURL);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't build host's peer address %u from URL (\"%s\")!",
						2, dwTemp, pszURL);
					THROW_TESTRESULT;
				} // end if (couldn't build from URL)



				DPTEST_TRACE(hLog, "Getting remote peer address %u's hostname component.", 1, dwTemp);

				dwSize = 16 * sizeof (WCHAR);

				tr = pDP8AddressRemotePeer->GetComponentByName(DPNA_KEY_HOSTNAME,
																wszIPCompareString,
																&dwSize,
																&dwDataType);
				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Couldn't get host's peer address %u hostname component!",
						1, dwTemp);
					THROW_TESTRESULT;
				} // end if (couldn't get component by name)

				// Make sure it's the right size for IP address.
				if (dwSize > (16 * sizeof (WCHAR)))
				{
					DPTEST_FAIL(hLog, "Size of hostname component is unexpected (%u > %u)!",
						2, dwSize, (16 * sizeof (WCHAR)));
					SETTHROW_TESTRESULT(E_UNEXPECTED);
				} // end if (didn't use all of the buffer)

				if (dwDataType != DPNA_DATATYPE_STRING)
				{
					DPTEST_FAIL(hLog, "Data type for hostname component is unexpected (%u != %u)!",
						2, dwDataType, DPNA_DATATYPE_STRING);
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't use all of the buffer)


				// See if we found the IP address we want to use when
				// connecting.  If so, we're done.
				if (StringCmpAToU(hLog, wszIPCompareString, pEnumTestParam->szServerIPAddr, TRUE))
				{
					DPTEST_TRACE(hLog, "Found IP address \"%s\", using host's peer address %u (\"%s\").",
						3, pEnumTestParam->szServerIPAddr, dwTemp, pszURL);
					break;
				} // end if (found IP address)


				pszURL += strlen(pszURL) + 1;
			} // end for (each host address)

			// If we didn't find the address to use, we have to bail.
			if (dwTemp >= dwNumAddressesPeer)
			{
				DPTEST_FAIL(hLog, "Couldn't find the correct host peer address to use!", 0);
				SETTHROW_TESTRESULT(ERROR_NOT_FOUND);
			} // end if (didn't find address)

			// At this point, the remote address objects have the correct host
			// addresses we should use when enumerating.

			CREATEEVENT_OR_THROW(hEnumDoneEvent, NULL, FALSE, FALSE, NULL);


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating peer-to-peer session using client/server interface");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_EnumHosts(&dpnadPeer,
											pDP8AddressRemotePeer,
											pDP8AddressLocal,
											NULL,
											0,
											0, // default EnumCount
											0, // default RetryInterval
											0, // default TimeOut
											hEnumDoneEvent,
											&dpnhEnumHosts,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			
			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}
				
			sr = (HRESULT) S_OK;

		} // end else (not tester 0)
		


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish c/s to p-p enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, CSTOPPDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, CSTOPPDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")

//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;

		if(!pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating client/server session using peer-to-peer interface");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_EnumHosts(&dpnadCS,
												pDP8AddressRemoteCS,
												pDP8AddressLocal,
												NULL,
												0,
												0, // default EnumCount
												0, // default RetryInterval
												0, // default TimeOut
												hEnumDoneEvent,
												&dpnhEnumHosts,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}
				
			sr = (HRESULT) S_OK;

		} // end else (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish p-p to c/s enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, PPTOCSDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, PPTOCSDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}


		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;
		

		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Capping the number of client/server clients");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.dwMaxPlayers = 2;

			tr = pDP8Server->DP8S_SetApplicationDesc(&dpnadCS, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't set app desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set app desc)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying enumerator of c/s player limit change");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for host to limit number of c/s players");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		


		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, CSCAPPED_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, CSCAPPED_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		if(!pEnumTestParam->fHostTest)
		{
			context.dwExpectedMaxPlayers = 2;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating maxxed out client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_EnumHosts(&dpnadCS,
											pDP8AddressRemoteCS,
											pDP8AddressLocal,
											NULL,
											0,
											0, // default EnumCount
											0, // default RetryInterval
											0, // default TimeOut
											hEnumDoneEvent,
											&dpnhEnumHosts,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

		} // end else (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish c/s max players enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, CSMAXPLAYER_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, CSMAXPLAYER_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;

		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Capping the number of peer-to-peer players");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.dwMaxPlayers = 2;

			tr = pDP8PeerHost->DP8P_SetApplicationDesc(&dpnadPeer, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't set app desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set app desc)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying enumerator of p-p player limit change");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for host to limit number of p-p players");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		


		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, PPCAPPED_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, PPCAPPED_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		if(!pEnumTestParam->fHostTest)
		{
			//context.dwExpectedMaxPlayers = 2;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating maxxed out peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_EnumHosts(&dpnadPeer,
												pDP8AddressRemotePeer,
												pDP8AddressLocal,
												NULL,
												0,
												0, // default EnumCount
												0, // default RetryInterval
												0, // default TimeOut
												hEnumDoneEvent,
												&dpnhEnumHosts,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

		} // end else (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish p-p max players enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, PPMAXPLAYER_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, PPMAXPLAYER_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;


		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Setting password on client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadCS.dwFlags = DPNSESSION_CLIENT_SERVER | DPNSESSION_REQUIREPASSWORD;
			dpnadCS.dwMaxPlayers = 0;
			dpnadCS.pwszPassword = L"Some password, huh?";

			tr = pDP8Server->DP8S_SetApplicationDesc(&dpnadCS, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't set app desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set app desc)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying enumerator of c/s password change");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for host to set c/s password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		


		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, CSPW_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, CSPW_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		if(!pEnumTestParam->fHostTest)
		{
			context.dwExpectedMaxPlayers = 0;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating password protected client/server session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_EnumHosts(&dpnadCS,
											pDP8AddressRemoteCS,
											pDP8AddressLocal,
											NULL,
											0,
											0, // default EnumCount
											0, // default RetryInterval
											0, // default TimeOut
											hEnumDoneEvent,
											&dpnhEnumHosts,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

		} // end else (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish c/s password enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, CSPWDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, CSPWDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;

		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Setting password on peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			dpnadPeer.dwFlags = DPNSESSION_REQUIREPASSWORD;
			dpnadPeer.dwMaxPlayers = 0;
			dpnadPeer.pwszPassword = L"Some password, huh?";

			tr = pDP8PeerHost->DP8P_SetApplicationDesc(&dpnadPeer, 0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't set app desc!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't set app desc)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Notifying enumerator of p-p password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for host to set p-p password");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		} // end else (not tester 0)
		


		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, PPPW_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, PPPW_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}

		if(!pEnumTestParam->fHostTest)
		{
			//context.dwExpectedMaxPlayers = 0;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating password protected peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_EnumHosts(&dpnadPeer,
												pDP8AddressRemotePeer,
												pDP8AddressLocal,
												NULL,
												0,
												0, // default EnumCount
												0, // default RetryInterval
												0, // default TimeOut
												hEnumDoneEvent,
												&dpnhEnumHosts,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

		} // end if (not tester 0)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish p-p password enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, PPPWDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, PPPWDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}



		// Make sure we saw some queries/responses come in.
		if (context.dwNumMsgs == 0)
		{
			DPTEST_FAIL(hLog, "Didn't receive any enum queries/responses!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no queries/responses)
#pragma TODO(vanceo, "Retrieve SP caps to determine 0 (default) num attempts")
//		else if (context.dwNumMsgs > pInput->dwEnumCount)
//		{
//			DPTEST_FAIL(hLog, "Received too many enum queries/responses (%u > %u)!",
//				2, context.dwNumMsgs, pInput->dwEnumCount);
//			SETTHROW_TESTRESULT(E_FAIL);
//		} // end else if (too many queries/responses)
		else
		{
			DPTEST_TRACE(hLog, "Received %u enum queries/responses.", 1, context.dwNumMsgs);
		} // end else (valid num queries/responses)

		// Reset the count.
		context.dwNumMsgs = 0;

		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Retrieving c/s client address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "Get real player ID")
			tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x00300003,
												&pDP8AddressRemoteCS,
												0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Getting c/s client address failed!", 0);
				THROW_TESTRESULT;
			} // end if (getting client address failed)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Retrieving peer client address");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "Get real player ID")
			tr = pDP8PeerHost->DP8P_GetPeerAddress((DPNID) 0x00300003,
													&pDP8AddressRemotePeer,
													0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Getting peer client address failed!", 0);
				THROW_TESTRESULT;
			} // end if (getting peer address failed)


			dwSize = 0;
			dwURLsBufferSize = 0;

			tr = pDP8AddressRemoteCS->GetURLA(NULL, &dwSize);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Couldn't get c/s client address' URL size!", 0);
				THROW_TESTRESULT;
			} // end if (not buffer too small)
			
			dwURLsBufferSize += dwSize;

			dwSize = 0;
			tr = pDP8AddressRemotePeer->GetURLA(NULL, &dwSize);
			if (tr != DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Couldn't get peer client address' URL size!", 0);
				THROW_TESTRESULT;
			} // end if (not buffer too small)
			
			dwURLsBufferSize += dwSize;




			// Allocate a buffer for both the URLs.
			pszURL = NULL;
			LOCALALLOC_OR_THROW( char*, pszURL, dwURLsBufferSize);




			dwSize = dwURLsBufferSize;
			tr = pDP8AddressRemoteCS->GetURLA(pszURL, &dwSize);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get c/s client address' URL!", 0);

				MemFree(pszURL);
				pszURL = NULL;

				THROW_TESTRESULT;
			} // end if (failed)


			DPTEST_TRACE(hLog, "C/S client address: \"%s\"", 1, pszURL);

			// We're done with this address object.
			pDP8AddressRemoteCS->Release();
			pDP8AddressRemoteCS = NULL;


			dwTemp = dwURLsBufferSize - dwSize;
			tr = pDP8AddressRemotePeer->GetURLA(pszURL + dwSize, &dwTemp);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't get peer client address' URL!", 0);

				MemFree(pszURL);
				pszURL = NULL;

				THROW_TESTRESULT;
			} // end if (failed)

			DPTEST_TRACE(hLog, "Peer client address: \"%s\"", 1, pszURL + dwSize);


			// We're done with this address object.
			pDP8AddressRemotePeer->Release();
			pDP8AddressRemotePeer = NULL;




			// Straggling enums can still mosey in.  Give them some time so that
			// they don't screw up our non-host enum count.

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Sleeping 10 seconds to allow for straggling enums");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			Sleep(10000);


			if (context.dwNumMsgs > 0)
			{
				DPTEST_TRACE(hLog, "Note: %u enum(s) took their sweet time arriving.",
					1, context.dwNumMsgs);

				context.dwNumMsgs = 0;
			} // end if (enums straggled in)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Ensuring other tester is ready for non-host enums");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, NONHOST_EVENT_NAME,
				(BYTE *) pszURL, dwURLsBufferSize, NULL, 0))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, NONHOST_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

		} // end if (tester 0)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Ensuring other tester is ready for non-host enums");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			LOCALALLOC_OR_THROW( char *, pszURL, MAX_SYNC_DATASIZE);

			dwSyncDataSize = MAX_SYNC_DATASIZE;
			if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, NONHOST_EVENT_NAME,
				NULL, 0, (PBYTE) pszURL, &dwSyncDataSize))
			{
				DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, NONHOST_EVENT_NAME);
				SETTHROW_TESTRESULT(E_ABORT);
			}

			if(dwSyncDataSize < (DWORD) ((strlen(DPNA_HEADER_A) + 1) * 2))
			{
				DPTEST_FAIL(hLog, "Received sync data is below minimum amount (%u < %u)", 2,
					dwSyncDataSize, ((strlen(DPNA_HEADER_A) + 1) * 2));
				SETTHROW_TESTRESULT(E_ABORT);
			}

			tr = pDP8AddressRemoteCS->BuildFromURLA(pszURL);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't build host's C/S address from URL (\"%s\")!",
					1, pszURL);
				THROW_TESTRESULT;
			} // end if (couldn't build from URL)

			pszURL += strlen(pszURL) + 1;


			tr = pDP8AddressRemotePeer->BuildFromURLA(pszURL);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't build host's peer address from URL (\"%s\")!",
					1, pszURL);
				THROW_TESTRESULT;
			} // end if (couldn't build from URL)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating c/s client");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Client->DP8C_EnumHosts(&dpnadCS,
											pDP8AddressRemoteCS,
											pDP8AddressLocal,
											NULL,
											0,
											0, // default EnumCount
											0, // default RetryInterval
											0, // default TimeOut
											hEnumDoneEvent,
											&dpnhEnumHosts,
											0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Enumerating non-host peer");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerClient->DP8P_EnumHosts(&dpnadPeer,
												pDP8AddressRemotePeer,
												pDP8AddressLocal,
												NULL,
												0,
												0, // default EnumCount
												0, // default RetryInterval
												0, // default TimeOut
												hEnumDoneEvent,
												&dpnhEnumHosts,
												0);
			if (tr != (HRESULT) DPNSUCCESS_PENDING)
			{
				DPTEST_FAIL(hLog, "Couldn't start enumerating hosts!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't enumhosts)


			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for enumeration to complete");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if(WaitForSingleObject(hEnumDoneEvent, ENUM_HOSTS_TIMEOUT) != WAIT_OBJECT_0)
			{
				DPTEST_FAIL(hLog, "Enumeration didn't complete within %u seconds", 1, ENUM_HOSTS_TIMEOUT / 1000);
				THROW_SYSTEMRESULT;
			}

			sr = (HRESULT) S_OK;

			CloseHandle(hEnumDoneEvent);
			hEnumDoneEvent = NULL;
		} // end if (not tester 0)
		






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish non-host enumeration phase");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		if(!SyncWithOtherTesters(hLog, pEnumTestParam->hNetsyncObject, NONHOSTDONE_EVENT_NAME, NULL, 0, NULL, 0))
		{
			DPTEST_FAIL(hLog, "Couldn't sync with other testers on \"%s\" event", 1, NONHOSTDONE_EVENT_NAME);
			SETTHROW_TESTRESULT(E_ABORT);
		}


		// Make sure we didn't see any queries/responses come in.
		if (context.dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Received %u enum queries/responses!", 1, context.dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_MORE_DATA);
		} // end if (got queries/responses)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing failed!", 0);
			THROW_TESTRESULT;
		} // end if (close failed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing peer client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerClient->DP8P_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing failed!", 0);
			THROW_TESTRESULT;
		} // end if (close failed)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Peer object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8PeerClient->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8PeerClient);
		pDP8PeerClient = NULL;


		if(pEnumTestParam->fHostTest)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->DP8S_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Server object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8Server->Release();
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8Server);
			pDP8Server = NULL;

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing peer host object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->DP8P_Close(0);
			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing failed!", 0);
				THROW_TESTRESULT;
			} // end if (close failed)

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			tr = pDP8PeerHost->Release();
			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
				THROW_TESTRESULT;
			} // end if (couldn't release object)

			delete (pDP8PeerHost);
			pDP8PeerHost = NULL;

		} // end if (tester 0)
		




		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8PeerClient != NULL)
	{
		delete (pDP8PeerClient);
		pDP8PeerClient = NULL;
	} // end if (have peer object)

	if (pDP8PeerHost != NULL)
	{
		delete (pDP8PeerHost);
		pDP8PeerHost = NULL;
	} // end if (have peer object)

	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)


	if (paDP8HostAddresses != NULL)
	{
		for(dwTemp = 0; dwTemp < (dwNumAddressesCS + dwNumAddressesPeer); dwTemp++)
		{
			SAFE_RELEASE(paDP8HostAddresses[dwTemp]);
		} // end for (each address)

		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (have array of host addresses)

	SAFE_LOCALFREE(pszURL);
	SAFE_LOCALFREE(pvSyncData);
	SAFE_LOCALFREE(pHostAddressesCSAndPeerSyncData);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_RELEASE(pDP8AddressRemoteCS);
	SAFE_RELEASE(pDP8AddressRemotePeer);
	SAFE_CLOSEHANDLE(hEnumDoneEvent);

	
	return (sr);
} // EnumsExec_Validate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsExec_StartUpDown()"
//==================================================================================
// EnumsExec_StartUpDown
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.4.4 - Peer-to-peer enumeration during startup and shutdown test
//				2.4.5 - Client/server enumeration during startup and shutdown test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT EnumsExec_StartUpDown(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	DPN_APPLICATION_DESC	dpnad;
	PWRAPDP8PEER			pDP8Peer = NULL;
	PWRAPDP8SERVER			pDP8Server = NULL;
	PWRAPDP8CLIENT			pDP8Client = NULL;
	BOOL					fClientServer = FALSE;
	PDIRECTPLAY8ADDRESS		pDP8Address = NULL;
	HANDLE					hEnumDoneEvent = NULL;
	DPNHANDLE				dpnhEnumHosts = NULL;
	DWORD					dwTemp;

	
	
	BEGIN_TESTCASE
	{
		if(pTNecd->pExecutor->IsCase("2.4.2"))
		{
			fClientServer = TRUE;

			if(pTNecd->iTesterNum == 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Server wrapper object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Server = new (CWrapDP8Server);
				if (pDP8Server == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)
			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Creating DirectPlay8Client wrapper object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				pDP8Client = new (CWrapDP8Client);
				if (pDP8Client == NULL)
				{
					SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
				} // end if (couldn't allocate object)
			} // end else (not tester 0)
			
		} // end if (client/server)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Creating DirectPlay8Peer wrapper object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			pDP8Peer = new (CWrapDP8Peer);
			if (pDP8Peer == NULL)
			{
				SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
			} // end if (couldn't allocate object)
		} // end else (peer-to-peer)
		



		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		//dpnad.dwFlags = 0;
		if ((pTNecd->iTesterNum == 0) && (fClientServer))
			dpnad.dwFlags |= DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_ENUMS_STARTUPDOWN;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = (pTNecd->iTesterNum == 0) ? ENUM_SESSION_NAME : NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreating address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (couldn't CoCreate object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set SP for address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




#pragma TODO(vanceo, "Customize number of iterations")
		TESTSECTION_FOR(dwTemp = 0; dwTemp < 20; dwTemp++)
		{
			DPTEST_TRACE(hLog, "Beginning iteration %u.", 1, dwTemp);

			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Beginning iteration %u",
									1, dwTemp);



			// Leave a little time between attempts, while making sure the control
			// layer doesn't think we've deadlocked.
			TNSLEEP(100);



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("CoCreating object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				if (pTNecd->iTesterNum == 0)
				{
					tr = pDP8Server->CoCreate();
				} // end if (tester 0)
				else
				{
					tr = pDP8Client->CoCreate();
				} // end else (not tester 0)
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->CoCreate();
			} // end else (peer-to-peer)

			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "CoCreating object failed!", 0);
				THROW_TESTRESULT;
			} // end if (CoCreating failed)



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Initializing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				if (pTNecd->iTesterNum == 0)
				{
					tr = pDP8Server->DP8S_Initialize(NULL,
													EnumsStartUpDownDPNMessageHandler,
													0);
				} // end if (tester 0)
				else
				{
					tr = pDP8Client->DP8C_Initialize(NULL,
													EnumsStartUpDownDPNMessageHandler,
													0);
				} // end else (not tester 0)
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_Initialize(NULL,
												EnumsStartUpDownDPNMessageHandler,
												0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Initializing object failed!", 0);
				THROW_TESTRESULT;
			} // end if (initializing failed)



			if(pTNecd->iTesterNum == 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Hosting session object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				
				if (fClientServer)
				{
					tr = pDP8Server->DP8S_Host(&dpnad, &pDP8Address, 1,
												NULL, NULL, NULL, 0);
				} // end if (client/server)
				else
				{
					tr = pDP8Peer->DP8P_Host(&dpnad, &pDP8Address, 1,
											NULL, NULL, NULL, 0);
				} // end else (peer-to-peer)

				if (tr != DPN_OK)
				{
					DPTEST_FAIL(hLog, "Initializing object failed!", 0);
					THROW_TESTRESULT;
				} // end if (initializing failed)
			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Starting enumeration");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				
#pragma TODO(vanceo, "Customize retry interval")
				if (fClientServer)
				{
					tr = pDP8Client->DP8C_EnumHosts(&dpnad, NULL, pDP8Address,
													NULL, 0,
													INFINITE, 50, 0,
													NULL, &dpnhEnumHosts, 0);
				} // end if (client/server)
				else
				{
					tr = pDP8Peer->DP8P_EnumHosts(&dpnad, NULL, pDP8Address,
													NULL, 0,
													INFINITE, 50, 0,
													NULL, &dpnhEnumHosts, 0);
				} // end else (peer-to-peer)

				if (tr != DPNSUCCESS_PENDING)
				{
					DPTEST_FAIL(hLog, "Starting enumeration failed!", 0);
					THROW_TESTRESULT;
				} // end if (enumhosts failed)
			} // end else (not tester 0)
			



#pragma TODO(vanceo, "Programatically vary sleep time; customize iterations")
			if(dwTemp == (20 / 2))
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing at half-way point");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Halfway", NULL, 0, NULL, 0);
				HANDLE_SYNC_RESULT;
			} // end if (exactly half-way through)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Sleeping for 2 seconds");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				TNSLEEP(2000);
			} // end else (not exactly half-way through)
			




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Closing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				if (pTNecd->iTesterNum == 0)
				{
					tr = pDP8Server->DP8S_Close(0);
				} // end if (tester 0)
				else
				{
					tr = pDP8Client->DP8C_Close(0);
				} // end else (not tester 0)
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->DP8P_Close(0);
			} // end else (peer-to-peer)

			if (tr != DPN_OK)
			{
				DPTEST_FAIL(hLog, "Closing object failed!", 0);
				THROW_TESTRESULT;
			} // end if (closing failed)




			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			if (fClientServer)
			{
				if (pTNecd->iTesterNum == 0)
				{
					tr = pDP8Server->Release();
				} // end if (tester 0)
				else
				{
					tr = pDP8Client->Release();
				} // end else (not tester 0)
			} // end if (client/server)
			else
			{
				tr = pDP8Peer->Release();
			} // end else (peer-to-peer)

			if (tr != S_OK)
			{
				DPTEST_FAIL(hLog, "Releasing object failed!", 0);
				THROW_TESTRESULT;
			} // end if (releasing failed)
		} // end for (each startup/shutdown iteration)
		TESTSECTION_ENDFOR




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for other tester to finish");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("All done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		if(fClientServer)
		{
			if(pTNecd->iTesterNum == 0)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Destroying DirectPlay8Server wrapper object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				delete (pDP8Server);
				pDP8Server = NULL;
			} // end if (tester 0)
			else
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Destroying DirectPlay8Client wrapper object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				delete (pDP8Client);
				pDP8Client = NULL;
			} // end else (not tester 0)
			
		} // end if (client/server)
		else
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying DirectPlay8Peer wrapper object");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			delete (pDP8Peer);
			pDP8Peer = NULL;
		} // end else (peer-to-peer)
		



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Peer != NULL)
	{
		delete (pDP8Peer);
		pDP8Peer = NULL;
	} // end if (have peer object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(hEnumDoneEvent);

	
	return (sr);
} // EnumsExec_StartUpDown
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/






#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsSimpleDPNMessageHandler()"
//==================================================================================
// EnumsSimpleDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT EnumsSimpleDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PENUMSSIMPLECONTEXT		pContext = (PENUMSSIMPLECONTEXT) pvContext;
	DWORD					dwTempNumQueries;
	LONG					lTempNumOutstanding;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

			if (pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting operation complete on host!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)

			if (pContext->fCancelled)
			{
				if (pAsyncOpCompleteMsg->hResultCode != DPNERR_USERCANCEL)
				{
					DPTEST_TRACE(pContext->hLog, "Enumeration didn't complete with expected error USERCANCEL!  DEBUGBREAK()-ing.  0x%08x",
						1, pAsyncOpCompleteMsg->hResultCode);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (not user cancell error)
			} // end if (user cancelled)
			else
			{
				if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Enumeration completed with a failure!  DEBUGBREAK()-ing.  0x%08x",
						1, pAsyncOpCompleteMsg->hResultCode);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (not ok)
			} // end else (not cancelled)

			if (! SetEvent(pAsyncOpCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pAsyncOpCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_ENUM_HOSTS_QUERY:
			PDPNMSG_ENUM_HOSTS_QUERY	pEnumQueryMsg;



			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting enum response on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)


			pEnumQueryMsg = (PDPNMSG_ENUM_HOSTS_QUERY) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_QUERY", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumQueryMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumQueryMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumQueryMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pvReceivedData = %x", 1, pEnumQueryMsg->pvReceivedData);
			DPTEST_TRACE(pContext->hLog, "    dwReceivedDataSize = %u", 1, pEnumQueryMsg->dwReceivedDataSize);
			DPTEST_TRACE(pContext->hLog, "    dwMaxResponseDataSize = %u", 1, pEnumQueryMsg->dwMaxResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumQueryMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumQueryMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseContext = %x", 1, pEnumQueryMsg->pvResponseContext);


			// Verify the incoming data.
			if (pEnumQueryMsg->pvReceivedData != NULL)
			{
				if (pContext->pvUserData == NULL)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of query user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pEnumQueryMsg->dwReceivedDataSize,
						pEnumQueryMsg->pvReceivedData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pEnumQueryMsg->dwReceivedDataSize != pContext->dwUserDataSize)
				{
					DPTEST_TRACE(pContext->hLog, "Size of query user data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pEnumQueryMsg->dwReceivedDataSize,
						pEnumQueryMsg->pvReceivedData, pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)

				if (! IsFilledWithDWord(pEnumQueryMsg->pvReceivedData, pEnumQueryMsg->dwReceivedDataSize, ENUMDATAPATTERN_QUERY))
				{
					DPTEST_TRACE(pContext->hLog, "Query user data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pEnumQueryMsg->pvReceivedData,
						pEnumQueryMsg->dwReceivedDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->pvUserData != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of query user data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pEnumQueryMsg->dwReceivedDataSize != 0)
				{
					DPTEST_TRACE(pContext->hLog, "Query received data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pEnumQueryMsg->dwReceivedDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)


#pragma TODO(vanceo, "Make sure it's the other tester querying (address, don't respond if not him)")

			dwTempNumQueries = (DWORD) InterlockedIncrement((LPLONG) &(pContext->dwNumMsgs));

			// Respond with data, if there is any.
			if (pContext->pvUserData != NULL)
			{
				// Make sure we're allowed to respond with data.
				if (pContext->fDontRespondWithData)
				{
					DPTEST_TRACE(pContext->hLog, "Not responding to straggling enum query (%u) with data like normal.",
						1, dwTempNumQueries);
				} // end if (shouldn't respond with data)
				else
				{
					lTempNumOutstanding = InterlockedIncrement(&(pContext->lNumOutstandingResponseData));
					if (lTempNumOutstanding <= 0)
					{
						DPTEST_TRACE(pContext->hLog, "Number of outstanding response data buffers is bad!  DEBUGBREAK()-ing.", 0);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (count went negative)

					pEnumQueryMsg->pvResponseData = pContext->pvUserData;
					pEnumQueryMsg->dwResponseDataSize = pContext->dwUserDataSize;
					pEnumQueryMsg->pvResponseContext = (PVOID) (DWORD_PTR) dwTempNumQueries;

					DPTEST_TRACE(pContext->hLog, "Setting query %u response data to %u bytes at %x (now %i outstanding responses).",
						4, dwTempNumQueries, pContext->dwUserDataSize,
						pContext->pvUserData, lTempNumOutstanding);
				} // end else (can respond with data)
			} // end if (there's some user data)

			// If we're refusing to respond, do so.
			if (pContext->fReject)
			{
				DPTEST_TRACE(pContext->hLog, "Refusing to respond to query.", 0);
				hr = E_FAIL;
			} // end if (rejecting enumeration)
		  break;

		case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			PDPNMSG_ENUM_HOSTS_RESPONSE		pEnumHostsResponseMsg;



			if (pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting enum response on host!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)


			pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_RESPONSE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumHostsResponseMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumHostsResponseMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumHostsResponseMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pApplicationDescription = %x", 1, pEnumHostsResponseMsg->pApplicationDescription);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumHostsResponseMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumHostsResponseMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pEnumHostsResponseMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    dwRoundTripLatencyMS = %u", 1, pEnumHostsResponseMsg->dwRoundTripLatencyMS);


			if (pContext->fReject)
			{
				DPTEST_TRACE(pContext->hLog, "Getting enum response even though host should have not replied!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (host supposed to reject)

#pragma TODO(vanceo, "Make sure it's the other tester responding (address)")

			if (pEnumHostsResponseMsg->pApplicationDescription->dwSize != sizeof (DPN_APPLICATION_DESC))
			{
				DPTEST_TRACE(pContext->hLog, "Size of application desc is wrong (%u != %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwSize,
					sizeof (DPN_APPLICATION_DESC));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

#pragma TODO(vanceo, "Validate app desc dwFlags and guidInstance")

			if (memcmp(&(pEnumHostsResponseMsg->pApplicationDescription->guidApplication), &GUID_ENUMS_SIMPLE, sizeof (GUID)) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc app guid is wrong (%g != %g)!  DEBUGBREAK()-ing.",
					2, &pEnumHostsResponseMsg->pApplicationDescription->guidApplication,
					&GUID_ENUMS_SIMPLE);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc max players is wrong (%u != 0)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc max players is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers != 1)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc current players is wrong (%u != 1)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc current players is wrong)

			if (wcscmp(pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName, ENUM_SESSION_NAME) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc session name is wrong (\"%S\" != \"%S\")!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName,
					ENUM_SESSION_NAME);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc session name is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->pwszPassword != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc password is not NULL (%S)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->pwszPassword);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc password is wrong)

			if ((pEnumHostsResponseMsg->pApplicationDescription->pvReservedData != NULL) ||
				(pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Application desc reserved data is not NULL/0 (%x, %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->pvReservedData,
					pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc reserved data is wrong)


			// Verify the app desc data.
			if (pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData != NULL)
			{
				if (pContext->dwAppDescDataSize == 0)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of application desc data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize,
						pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize != pContext->dwAppDescDataSize)
				{
					DPTEST_TRACE(pContext->hLog, "Size of application desc data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize,
						pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData,
						pContext->dwAppDescDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)

				if (! IsFilledWithDWord(pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize, ENUMDATAPATTERN_APPDESC))
				{
					DPTEST_TRACE(pContext->hLog, "Application desc data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData,
						pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (appdesc data)
			else
			{
				if (pContext->dwAppDescDataSize != 0)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of application desc data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwAppDescDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize != 0)
				{
					DPTEST_TRACE(pContext->hLog, "Application desc received data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no appdesc data)


			// Verify the incoming data.
			if (pEnumHostsResponseMsg->pvResponseData != NULL)
			{
				if (pContext->pvUserData == NULL)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of response user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
						2, pEnumHostsResponseMsg->dwResponseDataSize,
						pEnumHostsResponseMsg->pvResponseData);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's not supposed to be data)

				if (pEnumHostsResponseMsg->dwResponseDataSize != pContext->dwUserDataSize)
				{
					DPTEST_TRACE(pContext->hLog, "Size of response user data received (%u bytes at %x) but not expected value (%u)!  DEBUGBREAK()-ing.",
						3, pEnumHostsResponseMsg->dwResponseDataSize,
						pEnumHostsResponseMsg->pvResponseData,
						pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data size isn't correct)

				if (! IsFilledWithDWord(pEnumHostsResponseMsg->pvResponseData, pEnumHostsResponseMsg->dwResponseDataSize, ENUMDATAPATTERN_RESPONSE))
				{
					DPTEST_TRACE(pContext->hLog, "Response user data received is corrupted (%x, %u bytes)!  DEBUGBREAK()-ing.",
						2, pEnumHostsResponseMsg->pvResponseData,
						pEnumHostsResponseMsg->dwResponseDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (data isn't correct)
			} // end if (incoming data)
			else
			{
				if (pContext->pvUserData != NULL)
				{
					DPTEST_TRACE(pContext->hLog, "%u bytes of response user data was expected but none was received!  DEBUGBREAK()-ing.",
						1, pContext->dwUserDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (there's supposed to be data)

				if (pEnumHostsResponseMsg->dwResponseDataSize != 0)
				{
					DPTEST_TRACE(pContext->hLog, "Response received data pointer was NULL as expected, but size was %u!  DEBUGBREAK()-ing.",
						1, pEnumHostsResponseMsg->dwResponseDataSize);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (the size is not right)
			} // end else (no incoming data)

			InterlockedIncrement((LPLONG) &(pContext->dwNumMsgs));
		  break;

		case DPN_MSGID_RETURN_BUFFER:
			PDPNMSG_RETURN_BUFFER	pReturnBufferMsg;



			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting return buffer on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)


			pReturnBufferMsg = (PDPNMSG_RETURN_BUFFER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_RETURN_BUFFER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pReturnBufferMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pReturnBufferMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvBuffer = %x", 1, pReturnBufferMsg->pvBuffer);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pReturnBufferMsg->pvUserContext);


			if (pContext->pvUserData == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "No response data was sent but returning buffer %x (context = %x)!?  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer,
					pReturnBufferMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not using data)

			if (pReturnBufferMsg->pvBuffer != pContext->pvUserData)
			{
				DPTEST_TRACE(pContext->hLog, "Buffer returned is not expected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pReturnBufferMsg->pvBuffer, pContext->pvUserData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (buffer is wrong)

			if (pReturnBufferMsg->pvUserContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Context returned is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is NULL)

			lTempNumOutstanding = InterlockedDecrement(&(pContext->lNumOutstandingResponseData));
			if (lTempNumOutstanding < 0)
			{
				DPTEST_TRACE(pContext->hLog, "Number of outstanding response data buffers has gone negative!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (count went negative)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // EnumsSimpleDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsValidateDPNMessageHandler()"
//==================================================================================
// EnumsValidateDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT EnumsValidateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PENUMSVALIDATECONTEXT	pContext = (PENUMSVALIDATECONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_APPLICATION_DESC:
			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting application desc notification on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)
		  break;

		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			if (pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting operation complete on host!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Enumeration completed with a failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not ok)

			if (! SetEvent(pAsyncOpCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pAsyncOpCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;



			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting connect completion on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)

#pragma TODO(vanceo, "Validate hAsyncOp")

			// Make sure we got the right error result code.
			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect failed!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong error code)


			// Verify the incoming data.
			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of reply data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwApplicationReplyDataSize,
					pConnectCompleteMsg->pvApplicationReplyData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting destroy player on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_ENUM_HOSTS_QUERY:
			PDPNMSG_ENUM_HOSTS_QUERY	pEnumQueryMsg;



			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting enum response on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)


			pEnumQueryMsg = (PDPNMSG_ENUM_HOSTS_QUERY) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_QUERY", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumQueryMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumQueryMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumQueryMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pvReceivedData = %x", 1, pEnumQueryMsg->pvReceivedData);
			DPTEST_TRACE(pContext->hLog, "    dwReceivedDataSize = %u", 1, pEnumQueryMsg->dwReceivedDataSize);
			DPTEST_TRACE(pContext->hLog, "    dwMaxResponseDataSize = %u", 1, pEnumQueryMsg->dwMaxResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumQueryMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumQueryMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvResponseContext = %x", 1, pEnumQueryMsg->pvResponseContext);


#pragma TODO(vanceo, "Detect queries on non-host interfaces of tester 0")

			// Verify the incoming data.
			if (pEnumQueryMsg->pvReceivedData != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of query user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumQueryMsg->dwReceivedDataSize,
					pEnumQueryMsg->pvReceivedData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)


#pragma TODO(vanceo, "Make sure it's the other tester querying (address, don't respond if not him)")

			InterlockedIncrement((LPLONG) &(pContext->dwNumMsgs));
		  break;

		case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			PDPNMSG_ENUM_HOSTS_RESPONSE		pEnumHostsResponseMsg;



			if (pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting enum response on host!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (tester 0)


			pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ENUM_HOSTS_RESPONSE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pEnumHostsResponseMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pAddressSender = 0x%08x", 1, pEnumHostsResponseMsg->pAddressSender);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pEnumHostsResponseMsg->pAddressDevice);
			DPTEST_TRACE(pContext->hLog, "    pApplicationDescription = %x", 1, pEnumHostsResponseMsg->pApplicationDescription);
			DPTEST_TRACE(pContext->hLog, "    pvResponseData = %x", 1, pEnumHostsResponseMsg->pvResponseData);
			DPTEST_TRACE(pContext->hLog, "    dwResponseDataSize = %u", 1, pEnumHostsResponseMsg->dwResponseDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pEnumHostsResponseMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    dwRoundTripLatencyMS = %u", 1, pEnumHostsResponseMsg->dwRoundTripLatencyMS);


#pragma TODO(vanceo, "Make sure it's the other tester responding (address)")

			if (pEnumHostsResponseMsg->pApplicationDescription->dwSize != sizeof (DPN_APPLICATION_DESC))
			{
				DPTEST_TRACE(pContext->hLog, "Size of application desc is wrong (%u != %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwSize,
					sizeof (DPN_APPLICATION_DESC));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

#pragma TODO(vanceo, "Validate app desc dwFlags and guidInstance")

#pragma TODO(vanceo, "Get real GUID")
			if (memcmp(&(pEnumHostsResponseMsg->pApplicationDescription->guidApplication), &GUID_ENUMS_VALIDATE, sizeof (GUID)) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc app guid is wrong (%g != %g)!  DEBUGBREAK()-ing.",
					2, &pEnumHostsResponseMsg->pApplicationDescription->guidApplication,
					&GUID_ENUMS_SIMPLE);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc size is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers != pContext->dwExpectedMaxPlayers)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc max players is wrong (%u != %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwMaxPlayers,
					pContext->dwExpectedMaxPlayers);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc max players is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers != 2)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc current players is wrong (%u != 2)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->dwCurrentPlayers);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc current players is wrong)

			if (wcscmp(pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName, ENUM_SESSION_NAME) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc session name is wrong (\"%S\" != \"%S\")!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->pwszSessionName,
					ENUM_SESSION_NAME);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc session name is wrong)

			if (pEnumHostsResponseMsg->pApplicationDescription->pwszPassword != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Application desc password is not NULL (%S)!  DEBUGBREAK()-ing.",
					1, pEnumHostsResponseMsg->pApplicationDescription->pwszPassword);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc password is wrong)

			if ((pEnumHostsResponseMsg->pApplicationDescription->pvReservedData != NULL) ||
				(pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Application desc reserved data is not NULL/0 (%x, %u)!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->pvReservedData,
					pEnumHostsResponseMsg->pApplicationDescription->dwReservedDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (app desc reserved data is wrong)


			// Verify the app desc data.
			if (pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of application desc data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->pApplicationDescription->dwApplicationReservedDataSize,
					pEnumHostsResponseMsg->pApplicationDescription->pvApplicationReservedData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (appdesc data)


			// Verify the incoming data.
			if (pEnumHostsResponseMsg->pvResponseData != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "%u bytes of response user data was received (%x) but none was expected!  DEBUGBREAK()-ing.",
					2, pEnumHostsResponseMsg->dwResponseDataSize,
					pEnumHostsResponseMsg->pvResponseData);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (incoming data)

			InterlockedIncrement((LPLONG) &(pContext->dwNumMsgs));
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;



			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;
			
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

			if (!pContext->pEnumTestParam->fHostTest)
			{
				DPTEST_TRACE(pContext->hLog, "Getting indicate connect on non-tester 0!?  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (not tester 0)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // EnumsValidateDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"EnumsStartUpDownDPNMessageHandler()"
//==================================================================================
// EnumsStartUpDownDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT EnumsStartUpDownDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT		hr = DPN_OK;



	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPL(0, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPL(0, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPL(0, "    hAsyncOp = %u", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPL(0, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPL(0, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);

#pragma TODO(vanceo, "Validate DPN_MSGID_ASYNC_OP_COMPLETE")
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_CREATE_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;
			
			DPL(0, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPL(0, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPL(0, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPL(0, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_ENUM_HOSTS_QUERY:
			PDPNMSG_ENUM_HOSTS_QUERY	pEnumQueryMsg;


			pEnumQueryMsg = (PDPNMSG_ENUM_HOSTS_QUERY) pvMsg;
			
			DPL(6, "DPN_MSGID_ENUM_HOSTS_QUERY", 0);
			DPL(6, "    dwSize = %u", 1, pEnumQueryMsg->dwSize);
			DPL(6, "    pAddressSender = 0x%08x", 1, pEnumQueryMsg->pAddressSender);
			DPL(6, "    pAddressDevice = 0x%08x", 1, pEnumQueryMsg->pAddressDevice);
			DPL(6, "    pvReceivedData = %x", 1, pEnumQueryMsg->pvReceivedData);
			DPL(6, "    dwReceivedDataSize = %u", 1, pEnumQueryMsg->dwReceivedDataSize);
			DPL(6, "    dwMaxResponseDataSize = %u", 1, pEnumQueryMsg->dwMaxResponseDataSize);
			DPL(6, "    pvResponseData = %x", 1, pEnumQueryMsg->pvResponseData);
			DPL(6, "    dwResponseDataSize = %u", 1, pEnumQueryMsg->dwResponseDataSize);
			DPL(6, "    pvResponseContext = %x", 1, pEnumQueryMsg->pvResponseContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_ENUM_HOSTS_QUERY")
		  break;

		case DPN_MSGID_ENUM_HOSTS_RESPONSE:
			PDPNMSG_ENUM_HOSTS_RESPONSE		pEnumHostsResponseMsg;


			pEnumHostsResponseMsg = (PDPNMSG_ENUM_HOSTS_RESPONSE) pvMsg;
			
			DPL(6, "DPN_MSGID_ENUM_HOSTS_RESPONSE", 0);
			DPL(6, "    dwSize = %u", 1, pEnumHostsResponseMsg->dwSize);
			DPL(6, "    pAddressSender = 0x%08x", 1, pEnumHostsResponseMsg->pAddressSender);
			DPL(6, "    pAddressDevice = 0x%08x", 1, pEnumHostsResponseMsg->pAddressDevice);
			DPL(6, "    pApplicationDescription = %x", 1, pEnumHostsResponseMsg->pApplicationDescription);
			DPL(6, "    pvResponseData = %x", 1, pEnumHostsResponseMsg->pvResponseData);
			DPL(6, "    dwResponseDataSize = %u", 1, pEnumHostsResponseMsg->dwResponseDataSize);
			DPL(6, "    pvUserContext = %x", 1, pEnumHostsResponseMsg->pvUserContext);
			DPL(6, "    dwRoundTripLatencyMS = %u", 1, pEnumHostsResponseMsg->dwRoundTripLatencyMS);

#pragma TODO(vanceo, "Validate DPN_MSGID_ENUM_HOSTS_RESPONSE")
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


//DONE:

	return (hr);
} // EnumsStartUpDownDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\hostmigrate.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <mmsystem.h>

#include "..\..\..\tncommon\debugprint.h"
#include "..\..\..\tncommon\cppobjhelp.h"
#include "..\..\..\tncommon\linklist.h"
#include "..\..\..\tncommon\linkedstr.h"
#include "..\..\..\tncommon\strutils.h"
#include "..\..\..\tncommon\sprintf.h"

#include "..\..\..\tncontrl\tncontrl.h"


#include "..\main.h"

#include "..\bldssn\blddp8.h"

#include "hostmigrate.h"




//==================================================================================
// Defines
//==================================================================================
#define GROUPORDATAOP_NONE						-1

#define GROUPORDATAOP_SETPEERINFO				1
#define GROUPORDATAOP_CREATEGROUP				2
#define GROUPORDATAOP_SETGROUPINFO				3
#define GROUPORDATAOP_ADDPLAYERTOGROUP			4
#define GROUPORDATAOP_REMOVEPLAYERFROMGROUP		5
#define GROUPORDATAOP_DESTROYGROUP				6




//==================================================================================
// Structures
//==================================================================================
typedef struct tagHOSTMIGRATECONTEXT:public BLDDP8DPNHANDLERCONTEXTHEADER
{
	// See blddp8.h BLDDP8DPNHANDLERCONTEXTHEADER for first members of structure

	PTNEXECCASEDATA		pTNecd; // pointer to EXECCASEDATA passed in to test
	HANDLE				hPlayersGoneEvent; // event to set when all other players have been removed from session when expected
	BOOL				fSelfIndicate; // set to TRUE if expecting our own player to connect/disconnect, FALSE if not
	HANDLE				hHostMigratedEvent; // event to set when host migration message comes in
	DPNID*				padpnidTesters; // array of player IDs, in tester number order
	int					iCurrentHost; // tester number who was original host for this iteration
	BOOL				fDroppingPlayer; // whether we're a dropping player or not
	BOOL				fSecondInCommandCase; // whether this is a second-in-command migration case
	int					iGroupOrDataOperation; // particular group or data operation that will be performed, or -1 for none
	BOOL				fGroupOrDataOperatingPlayer; // whether we're the player performing the group or data operation or not
	PWRAPDP8PEER		pDP8Peer; // DPlay8 peer object in use
	BOOL*				pafTesterIndicated; // pointer to array to use to remember whether an indication has already arrived for this tester
	HANDLE				hRejoinedEvent; // event to set when tester has rejoined session after migration; round robin only
	int*				paiReliableMsgsReceivedFromTesters; // pointer to array to use when setting player contexts while rejoining; round robin only
	HANDLE				hGroupOrDataOperationEvent; // event to set when group or data operation is indicated
	DPNID				dpnidGroup; // ID of group created
	DPNID				dpnidPlayerAddedToGroup; // ID of player added to group
	volatile BOOL		fNoAsyncOpCompletion; // boolean indicating whether the group or data operation failed to get started and that no async op would be forthcoming
	BOOL				fPeerInfoSet; // whether the peer info data indication arrived or not
	BOOL				fGroupInfoSet; // whether the peer info data indication arrived or not
} HOSTMIGRATECONTEXT, * PHOSTMIGRATECONTEXT;





//==================================================================================
// Prototypes
//==================================================================================
HRESULT HostMigrateCanRun_All(PTNCANRUNDATA pTNcrd);
HRESULT HostMigrateGet_RoundRobin(PTNGETINPUTDATA pTNgid);
HRESULT HostMigrateWrite_RoundRobin(PTNWRITEDATA pTNwd);
HRESULT HostMigrateExec_All(PTNEXECCASEDATA pTNecd);


HRESULT HostMigrateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);





#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateLoadTestTable()"
//==================================================================================
// HostMigrateLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.3			Host migration tests
//				2.3.1		Normal host migration test cases
//				2.3.1.1		Simple 3 player normal host migration test
//				2.3.1.2		Round robin normal host migration test
//				2.3.1.3		Round robin normal host and second-in-command migration test
//				2.3.1.4		Round robin group and data operations during normal host migration test
//				2.3.1.5		Round robin group and data operations during normal host and second-in-command migration test
//				2.3.2		Dropped host migration test cases
//				2.3.2.1		Simple 3 player dropped host migration test
//				2.3.2.2		Round robin dropped host migration test
//				2.3.2.3		Round robin dropped host and second-in-command migration test
//				2.3.2.4		Round robin group and data operations during dropped host migration test
//				2.3.2.5		Round robin group and data operations during dropped host and second-in-command migration test
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT HostMigrateLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	PTNTESTTABLEGROUP	pSubSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3		Host migration tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase, "2.3", "Host migration tests", &pSubGroup);




	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1	Normal host migration test cases
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.3.1", "Normal host migration test cases",
				&pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.1	Simple 3 player normal host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.1";
	tnatd.pszName			= "Simple 3 player normal host migration test";
	tnatd.pszDescription	= "Simple 3 player normal host migration test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.2	Round robin normal host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.2";
	tnatd.pszName			= "Round robin normal host migration test";
	tnatd.pszDescription	= "Round robin normal host migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.3	Round robin normal host and second-in-command migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.3";
	tnatd.pszName			= "Round robin normal host and second-in-command migration test";
	tnatd.pszDescription	= "Round robin normal host and second-in-command migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.4	Round robin group and data operations during normal host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.4";
	tnatd.pszName			= "Round robin group and data operations during normal host migration test";
	tnatd.pszDescription	= "Round robin group and data operations during normal host migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.5	Round robin group and data operations during normal host and second-in-command migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.5";
	tnatd.pszName			= "Round robin group and data operations during normal host and second-in-command migration test";
	tnatd.pszDescription	= "Round robin group and data operations during normal host and second-in-command migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);





	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.2	Dropped host migration test cases
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pSubGroup, "2.3.2", "Dropped host migration test cases",
				&pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.2.1	Simple 3 player dropped host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.2.1";
	tnatd.pszName			= "Simple 3 player dropped host migration test";
	tnatd.pszDescription	= "Simple 3 player dropped host migration test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.2.2	Round robin dropped host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.2.2";
	tnatd.pszName			= "Round robin dropped host migration test";
	tnatd.pszDescription	= "Round robin dropped host migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.2.3	Round robin dropped host and second-in-command migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.2.3";
	tnatd.pszName			= "Round dropped normal host and second-in-command migration test";
	tnatd.pszDescription	= "Round dropped normal host and second-in-command migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.2.4	Round robin group and data operations during dropped host migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.2.4";
	tnatd.pszName			= "Round robin group and data operations during dropped host migration test";
	tnatd.pszDescription	= "Round robin group and data operations during dropped host migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -3;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.3.1.5	Round robin group and data operations during dropped host and second-in-command migration test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.3.1.5";
	tnatd.pszName			= "Round robin group and data operations during dropped host and second-in-command migration test";
	tnatd.pszDescription	= "Round robin group and data operations during dropped host and second-in-command migration test";
	tnatd.pszInputDataHelp	= "NumIterations = How many times to migrate host";

	tnatd.iNumMachines		= -4;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= HostMigrateCanRun_All;
	tnatd.pfnGetInputData	= HostMigrateGet_RoundRobin;
	tnatd.pfnExecCase		= HostMigrateExec_All;
	tnatd.pfnWriteData		= HostMigrateWrite_RoundRobin;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubSubGroup);


	return (S_OK);
} // HostMigrateLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateCanRun_All()"
//==================================================================================
// HostMigrateCanRun_All
//----------------------------------------------------------------------------------
//
// Description: Callback that checks a possible tester list to make sure the test
//				can be run correctly for the following test case(s):
//				2.3.1.1 - Simple 3 player normal host migration test
//				2.3.1.2 - Round robin normal host migration test
//				2.3.1.3 - Round robin normal host and second-in-command migration test
//				2.3.1.4 - Round robin group and data operations during normal host migration test
//				2.3.1.5 - Round robin group and data operations during normal host and second-in-command migration test
//				2.3.2.1 - Simple 3 player dropped host migration test
//				2.3.2.2 - Round robin dropped host migration test
//				2.3.2.3 - Round robin dropped host and second-in-command migration test
//				2.3.2.4 - Round robin group and data operations during dropped host migration test
//				2.3.2.5 - Round robin group and data operations during dropped host and second-in-command migration test
//
// Arguments:
//	PTNCANRUNDATA pTNcrd	Pointer to parameter block with information on what
//							configuration to check.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT HostMigrateCanRun_All(PTNCANRUNDATA pTNcrd)
{
	HRESULT		hr;
	int			i;
	int			j;


	// Loop through all the testers to make sure they can connect to each other.
	for(i = 0; i < pTNcrd->iNumMachines; i++)
	{
		// Only the first host needs to have IMTest installed in the simple (i.e
		// only 1 time) drop test case.  All testers need it in the round robin
		// drop cases.
		if (((strcmp(pTNcrd->pTest->m_pszID, "2.3.2.1") == 0) && (i == 0)) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.3.2.2") == 0) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.3.2.3") == 0) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.3.2.4") == 0) ||
			(strcmp(pTNcrd->pTest->m_pszID, "2.3.2.5") == 0))
		{
			pTNcrd->fCanRun = pTNcrd->apTesters[i]->m_fFaultSimIMTestAvailable;

			if (! pTNcrd->fCanRun)
			{
				DPL(1, "Tester %i (%s) doesn't have IMTest fault simulator available.",
					2, i, pTNcrd->apTesters[i]->m_szComputerName);

				return (S_OK);
			} // end if (tester couldn't reach other tester)
		} // end if (first tester or round robin)


		for(j = 0; j < pTNcrd->iNumMachines; j++)
		{
			// Testers don't need to connect to themselves.
			if (i == j)
				continue;

			if (pTNcrd->pMaster->AreOnSameMachine(pTNcrd->apTesters[i],
												pTNcrd->apTesters[j]))
			{
				DPL(1, "Tester %i is on same machine as tester %i (%s), assuming can reach via UDP.",
					3, i, j, pTNcrd->apTesters[i]->m_szComputerName);

				pTNcrd->fCanRun = TRUE;
			} // end if (are on same machine)
			else
			{
				hr = pTNcrd->pMaster->CanReachViaIP(pTNcrd->apTesters[i],
													pTNcrd->apTesters[j],
													DPLAY8_PORT,
													TNCR_IP_UDP,
													&(pTNcrd->fCanRun));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't have tester %i (%s) try to reach tester %i (%s) via UDP!",
						4, i, pTNcrd->apTesters[i]->m_szComputerName,
						j, pTNcrd->apTesters[j]->m_szComputerName);

					return (hr);
				} // end if (couldn't test reachability)

				if (! pTNcrd->fCanRun)
				{
					DPL(1, "Tester %i (%s) can't reach tester %i (%s) via UDP.",
						4, i, pTNcrd->apTesters[i]->m_szComputerName,
						j, pTNcrd->apTesters[j]->m_szComputerName);

					return (S_OK);
				} // end if (tester couldn't reach other tester)
			} // end else (not on same machine)
		} // end for (each tester)
	} // end for (each tester)


	return (S_OK);
} // HostMigrateCanRun_All
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateGet_RoundRobin()"
//==================================================================================
// HostMigrateGet_RoundRobin
//----------------------------------------------------------------------------------
//
// Description: Callback that retrieves the initial data for the test case(s):
//				2.3.1.2 - Round robin normal host migration test
//				2.3.1.3 - Round robin normal host and second-in-command migration test
//				2.3.1.4 - Round robin group and data operations during normal host migration test
//				2.3.1.5 - Round robin group and data operations during normal host and second-in-command migration test
//				2.3.2.2 - Round robin dropped host migration test
//				2.3.2.3 - Round robin dropped host and second-in-command migration test
//				2.3.2.4 - Round robin group and data operations during dropped host migration test
//				2.3.2.5 - Round robin group and data operations during dropped host and second-in-command migration test
//
// Arguments:
//	PTNGETINPUTDATA pTNgid	Pointer to parameter block with information on how and
//							where to place the input data.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT HostMigrateGet_RoundRobin(PTNGETINPUTDATA pTNgid)
{
	PTID_PHOSTMIGRATE_ROUNDROBIN	pParams = (PTID_PHOSTMIGRATE_ROUNDROBIN) pTNgid->pvData;
	PLSTRINGLIST					pStrings = NULL;
	char*							pszTemp;



	pTNgid->dwDataSize = sizeof (TID_PHOSTMIGRATE_ROUNDROBIN);

	if (pParams == NULL)
		return (ERROR_BUFFER_TOO_SMALL);


	// Start with default values
	pParams->iNumIterations = 5;
    

	// Get any input data strings that might exist.
	GETANYINPUTSTRINGS(pTNgid, pStrings);


	// Okay, so if we found strings, check if any of the options are specified.
	// If they are, override the default with the items' value.
	if (pStrings != NULL)
	{
		pszTemp = pStrings->GetValueOfKey("NumIterations");
		if (pszTemp != NULL)
			pParams->iNumIterations = StringToInt(pszTemp);
	} // end if (we found some items)


	return (S_OK);
} // HostMigrateGet_RoundRobin
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateWrite_RoundRobin()"
//==================================================================================
// HostMigrateWrite_RoundRobin
//----------------------------------------------------------------------------------
//
// Description: Callback that converts a buffer to strings for the test case(s):
//				2.3.1.2 - Round robin normal host migration test
//				2.3.1.3 - Round robin normal host and second-in-command migration test
//				2.3.1.4 - Round robin group and data operations during normal host migration test
//				2.3.1.5 - Round robin group and data operations during normal host and second-in-command migration test
//				2.3.2.2 - Round robin dropped host migration test
//				2.3.2.3 - Round robin dropped host and second-in-command migration test
//				2.3.2.4 - Round robin group and data operations during dropped host migration test
//				2.3.2.5 - Round robin group and data operations during dropped host and second-in-command migration test
//
// Arguments:
//	PTNWRITEDATA pTNwd	Parameter block with information and data to write.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT HostMigrateWrite_RoundRobin(PTNWRITEDATA pTNwd)
{
	PTID_PHOSTMIGRATE_ROUNDROBIN	pInputData = (PTID_PHOSTMIGRATE_ROUNDROBIN) pTNwd->pvData;

	
	switch (pTNwd->dwLocation)
	{
		case TNTSDL_REPORTASSIGN:
			REQUIRE_ASSIGNREPORT_DATA(sizeof (TID_PHOSTMIGRATE_ROUNDROBIN));


			WRITESPRINTFDATALINE("NumIterations= %i", 1, pInputData->iNumIterations);
		  break;

		default:
			DPL(0, "Got data for unexpected location %u!",
				1, pTNwd->dwLocation);
			return (ERROR_INVALID_PARAMETER);
		  break;
	} // end switch (on the source of the data buffer)

	
	return (S_OK);
} // HostMigrateWrite_RoundRobin
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateExec_All()"
//==================================================================================
// HostMigrateExec_All
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.3.1.1 - Simple 3 player normal host migration test
//				2.3.1.2 - Round robin normal host migration test
//				2.3.1.3 - Round robin normal host and second-in-command migration test
//				2.3.1.4 - Round robin group and data operations during normal host migration test
//				2.3.1.5 - Round robin group and data operations during normal host and second-in-command migration test
//				2.3.2.1 - Simple 3 player dropped host migration test
//				2.3.2.2 - Round robin dropped host migration test
//				2.3.2.3 - Round robin dropped host and second-in-command migration test
//				2.3.2.4 - Round robin group and data operations during dropped host migration test
//				2.3.2.5 - Round robin group and data operations during dropped host and second-in-command migration test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT HostMigrateExec_All(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTID_PHOSTMIGRATE_ROUNDROBIN	pRoundRobinInput = (PTID_PHOSTMIGRATE_ROUNDROBIN) pTNecd->pvInputData;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	DWORD							dwSubInputDataSize;
	PTOD_BBLDDP8_PEER_CREATE		pBldDP8PeerCreateOutput = NULL;
	DWORD							dwSubOutputDataSize;
	CTNSyncDataList					syncdata;
	PVOID							pvSyncData;
	HOSTMIGRATECONTEXT				context;
	DPN_APPLICATION_DESC			dpnad;
	DPN_PLAYER_INFO					dpnpi;
	DPN_GROUP_INFO					dpngi;
	PWRAPDP8PEER					pDP8Peer = NULL;
	PTNFAULTSIM						pFaultSim = NULL;
	int*							paiOtherTesters = NULL;
	int*							paiReliableMsgsSentToTesters = NULL;
	int								iCurrentIteration;
	DWORD							dwSyncDataSize;
	int*							paiReliableMsgsSentByTester;
	DPN_BUFFER_DESC					dpnbdUnreliable;
	DPN_BUFFER_DESC					dpnbdReliable;
	int								i;
	int								j;
	DWORD							dwStartTime;
	DPNHANDLE						dpnhSend;
	DPNHANDLE						dpnhConnect;
	DWORD							dwNumMsgs;
	PDPNID							padpnidDestroyTesters = NULL;
	PDIRECTPLAY8ADDRESS				pDP8AddressRemote = NULL;
	PDIRECTPLAY8ADDRESS				pDP8AddressLocal = NULL;
	HANDLE							hConnectCompleteEvent = NULL;
	int								iNextHost;
	DPNHANDLE						dpnhGroupOrDataOp;
#ifdef DEBUG
	char*							pszURL = NULL;
	DWORD							dwURLBufferSize = 0;
	DWORD							dwURLSize;
#endif // DEBUG




	ZeroMemory(&context, sizeof (HOSTMIGRATECONTEXT));

	ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
	dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);

	ZeroMemory(&dpngi, sizeof (DPN_GROUP_INFO));
	dpngi.dwSize = sizeof (DPN_GROUP_INFO);


	BEGIN_TESTCASE
	{
		// Remember whether this is a second in command case or not.
		if ((pTNecd->pExecutor->IsCase("2.3.1.3")) ||
			(pTNecd->pExecutor->IsCase("2.3.1.5")) ||
			(pTNecd->pExecutor->IsCase("2.3.2.3")) ||
			(pTNecd->pExecutor->IsCase("2.3.2.5")))
		{
			context.fSecondInCommandCase = TRUE;

#ifdef DEBUG
			// We need at least 4 machines to run this test.
			if (pTNecd->iNumMachines < 4)
			{
				DPL(0, "Can't run host and second-in-command migration test case with fewer than 4 machines (%i)!  DEBUGBREAK()-ing.",
					1, pTNecd->iNumMachines);
				DEBUGBREAK();
			} // end if (fewer than 3 machines)
#endif // DEBUG
		} // end if (second in command case)
		else
		{
			//context.fSecondInCommandCase = FALSE;

#ifdef DEBUG
			// We need at least 3 machines to run this test.
			if (pTNecd->iNumMachines < 3)
			{
				DPL(0, "Can't run host migration test case with fewer than 3 machines (%i)!  DEBUGBREAK()-ing.",
					1, pTNecd->iNumMachines);
				DEBUGBREAK();
			} // end if (fewer than 3 machines)
#endif // DEBUG
		} // end else (not a second in command case)

		if ((! pTNecd->pExecutor->IsCase("2.3.1.1")) &&
			(! pTNecd->pExecutor->IsCase("2.3.2.1")))
		{
			REQUIRE_INPUT_DATA(sizeof (TID_PHOSTMIGRATE_ROUNDROBIN));
		} // end if (round robin case)


		// Remember whether this is a group operations case or not.
		if ((pTNecd->pExecutor->IsCase("2.3.1.4")) ||
			(pTNecd->pExecutor->IsCase("2.3.1.5")) ||
			(pTNecd->pExecutor->IsCase("2.3.2.4")) ||
			(pTNecd->pExecutor->IsCase("2.3.2.5")))
		{
			context.iGroupOrDataOperation = GROUPORDATAOP_SETPEERINFO;
		} // end if (group/data operations case)
		else
		{
			context.iGroupOrDataOperation = GROUPORDATAOP_NONE;
		} // end else (not a group/data operations case)




		// Allocate an array for all testers' player IDs.  The position of a tester
		// is always the same, regardless of the iteration.
		// We allocate this array even though build session will give us one
		// because we need to modify it, and we can't modify someone else's buffer.

		LOCALALLOC_OR_THROW(DPNID*, context.padpnidTesters,
							(pTNecd->iNumMachines * sizeof (DPNID)));


		// Allocate an array to hold the number of reliable messages sent to each
		// tester.  The position of a tester is always the same, regardless of the
		// iteration.

		LOCALALLOC_OR_THROW(int*, paiReliableMsgsSentToTesters,
							(pTNecd->iNumMachines * sizeof (int)));

		// Also allocate an array to hold the number of reliable messages received
		// from each tester.  The position of a tester is always the same,
		// regardless of the iteration.

		LOCALALLOC_OR_THROW(int*, context.paiReliableMsgsReceivedFromTesters,
							(pTNecd->iNumMachines * sizeof (int)));


		// Allocate an array for all the other testers' numbers.  The position of
		// testers will vary depending on the iteration.

		LOCALALLOC_OR_THROW(int*, paiOtherTesters,
							((pTNecd->iNumMachines - 1) * sizeof (int)));


		// Allocate an array for add player/delete player indications.  The position
		// of a tester is always the same, regardless of the iteration.

		LOCALALLOC_OR_THROW(BOOL*, context.pafTesterIndicated,
							(pTNecd->iNumMachines * sizeof (BOOL)));




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating peer-to-peer session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		context.pfnDPNMessageHandler = HostMigrateDPNMessageHandler;
		context.pTNecd = pTNecd;

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_MIGRATE_HOST | DPNSESSION_NODPNSVR;
		//dpnad.guidInstance = GUID_NULL;
		if (pTNecd->pExecutor->IsCase("2.3.1.1"))
			dpnad.guidApplication = GUID_HOSTMIGRATE_SIMPLE3PNORMAL;
		else if (pTNecd->pExecutor->IsCase("2.3.1.2"))
			dpnad.guidApplication = GUID_HOSTMIGRATE_ROUNDROBINNORMAL;
		else if (pTNecd->pExecutor->IsCase("2.3.2.1"))
			dpnad.guidApplication = GUID_HOSTMIGRATE_SIMPLE3PDROP;
		else
			dpnad.guidApplication = GUID_HOSTMIGRATE_ROUNDROBINDROP;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		dpnad.pwszSessionName = L"Session";
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.pvApplicationReservedData = 0;


		dwSubInputDataSize = sizeof (TID_BBLDDP8_ALL_CREATE)
							+ (pTNecd->iNumMachines * sizeof (int));

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, dwSubInputDataSize);
#pragma TODO(vanceo, "Allow SP to be selected")
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
		((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

		// Set the testers' player contexts to all be pointers to that tester's
		// entry in the number of reliable messages received array.
		for(i = 0; i < pTNecd->iNumMachines; i++)
		{
			*((PVOID*) (((PBYTE) pvSubInputData) + sizeof (TID_BBLDDP8_ALL_CREATE) + (i * sizeof (int*)))) = &(context.paiReliableMsgsReceivedFromTesters[i]);
		} // end for (each tester)


		sr = pTNecd->pExecutor->ExecSubTestCase("3.1.1.1", pvSubInputData,
												dwSubInputDataSize, 0);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPL(0, "Couldn't execute sub test case BldSsn:BldPeer:Create!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.1",
									"Creating peer-to-peer session failed!");


		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pBldDP8PeerCreateOutput,
									dwSubOutputDataSize,
									(sizeof (TOD_BBLDDP8_PEER_CREATE) + (pTNecd->iNumMachines * sizeof (DPNID))));

		pDP8Peer = pBldDP8PeerCreateOutput->pDP8Peer;
		pDP8Peer->m_dwRefCount++; // we're using it during this function

		CopyMemory(context.padpnidTesters,
					(pBldDP8PeerCreateOutput + 1),
					(pTNecd->iNumMachines * sizeof (DPNID)));




#pragma TODO(vanceo, "Free output vars if possible")



		// Start at the very beginning...
		iCurrentIteration = 0;
		TESTSECTION_DO
		{
			DPL(0, "Starting migration iteration #%i.", 1, iCurrentIteration);
			// Ignore error
			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Starting migration iteration #%i",
									1, iCurrentIteration);


			// Who's the original host of this iteration?  For second in command
			// cases, the host moves by twos (since host and next in line drop).
			if (context.fSecondInCommandCase)
				context.iCurrentHost = (iCurrentIteration * 2) % pTNecd->iNumMachines;
			else
				context.iCurrentHost = iCurrentIteration % pTNecd->iNumMachines;

			if ((context.iCurrentHost == pTNecd->iTesterNum) ||
				((context.fSecondInCommandCase) && (pTNecd->iTesterNum == ((context.iCurrentHost + 1) % pTNecd->iNumMachines))))
			{
				DPL(1, "We're going to drop this iteration (tester num = %i, host for iteration = %i).",
					2, pTNecd->iTesterNum, context.iCurrentHost);

				context.fDroppingPlayer = TRUE;
			} // end if (dropping player)
			else
			{
				DPL(1, "Host for this iteration is tester %i, we're not going to drop (we're tester %i).",
					2, context.iCurrentHost, pTNecd->iTesterNum);

				context.fDroppingPlayer = FALSE;
			} // end else (not dropping player)

			if (context.iGroupOrDataOperation != GROUPORDATAOP_NONE)
			{
				if (pTNecd->iTesterNum == ((context.iCurrentHost + pTNecd->iNumMachines - 1) % pTNecd->iNumMachines))
				{
					DPL(1, "We're going to perform group/data operation %i this iteration (tester num = %i).",
						2, context.iGroupOrDataOperation, pTNecd->iTesterNum);

					context.fGroupOrDataOperatingPlayer = TRUE;
				} // end if (group op tester)
				else
				{
					DPL(1, "We're expecting tester %i to perform group/data operation %i this iteration (we're tester num %i).",
						3, ((context.iCurrentHost + pTNecd->iNumMachines - 1) % pTNecd->iNumMachines),
						context.iGroupOrDataOperation, pTNecd->iTesterNum);

					context.fGroupOrDataOperatingPlayer = FALSE;
				} // end else (group op tester)
			} // end if (group/data operations case)


			
			// Fill the other tester number array for the current iteration.
			// The first (0th) entry in the array will always be the current host
			// for the session before this iteration's host migration, unless of
			// course the tester IS the current host (testers won't have themselves
			// in the array).
			// The second entry in the array will always be the second in command,
			// tester unless, the tester IS the second in command (for same reason
			// as above), or the current host (because of the effects of above).
			//
			// For a four person test in the first (0) non second-in-command
			// iteration:
			//   Tester 0's other testers array = {1, 2, 3}
			//   Tester 1's other testers array = {0, 2, 3}
			//   Tester 2's other testers array = {0, 1, 3}
			//   Tester 3's other testers array = {0, 1, 2}
			//
			// For a four person test in the second (1) non second-in-command:
			// iteration:
			//   Tester 0's other testers array = {1, 2, 3}
			//   Tester 1's other testers array = {2, 3, 0}
			//   Tester 2's other testers array = {1, 3, 0}
			//   Tester 3's other testers array = {1, 2, 0}
			//
			// For a four person test in the third (2) non second-in-command:
			// iteration:
			//   Tester 0's other testers array = {2, 3, 1}
			//   Tester 1's other testers array = {2, 3, 0}
			//   Tester 2's other testers array = {3, 0, 1}
			//   Tester 3's other testers array = {2, 0, 1}

			j = 0;
			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				if (((i + context.iCurrentHost) % pTNecd->iNumMachines) != pTNecd->iTesterNum)
					paiOtherTesters[j++] = (i + context.iCurrentHost) % pTNecd->iNumMachines;
			} // end for (each other tester)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Starting sends to all players");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			ZeroMemory(&dpnbdUnreliable, sizeof (DPN_BUFFER_DESC));
			dpnbdUnreliable.dwBufferSize = strlen("Unreliable send string") + 1;
			dpnbdUnreliable.pBufferData = (PBYTE) "Unreliable send string";

			ZeroMemory(&dpnbdReliable, sizeof (DPN_BUFFER_DESC));
			dpnbdReliable.dwBufferSize = strlen("Reliable send string") + 1;
			dpnbdReliable.pBufferData = (PBYTE) "Reliable send string";

			i = 0;
			dwStartTime = timeGetTime();

			do
			{
				// Move to the next person to send to.
				i++;


				// Use the API directly so we don't have tons of our wrapper spew.
				// We'll send a reliable message every (NumMachines + 1)th send.
				// Since we're sending to (NumMachines) different targets, we'll end
				// up sending that reliable message to a different person every time
				// (wrapping back around of course).
				// By sending guaranteed messages synchronously, we don't have to
				// wait for completions, DPlay will do it for us.  We really only
				// need to wait for the last completion, because order is preserved
				// for reliable messages, but since we're sending for a set amount
				// of time, we don't know which send will be the last one.  So, in
				// keeping with my laziness, we'll send them all synchronously.
				// They're also "complete on process" so I don't have to implement
				// any timeouts waiting for acked reliable messages (messages that
				// completed on the sending side) but have yet to be received at the
				// app level.
				// Everyone is in the session, and we send to ourselves, so we don't
				// have to worry about skipping over some slot in the array.

				if ((i % (pTNecd->iNumMachines + 1)) == 0)
					paiReliableMsgsSentToTesters[i % pTNecd->iNumMachines]++;

				tr = pDP8Peer->m_pDP8Peer->SendTo(context.padpnidTesters[i % pTNecd->iNumMachines],
													(((i % (pTNecd->iNumMachines + 1)) == 0) ? &dpnbdReliable : &dpnbdUnreliable),
													1,
													0,
													NULL,
													(((i % (pTNecd->iNumMachines + 1)) == 0) ? NULL : &dpnhSend),
													(((i % (pTNecd->iNumMachines + 1)) == 0) ? (DPNSEND_SYNC | DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED) : DPNSEND_NOCOPY));

				// Allow OK for SYNC and PENDING for async sends.
				if ((tr != DPN_OK) && (tr != (HRESULT) DPNSUCCESS_PENDING))
				{
					DPL(0, "SendTo didn't return OK or expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (didn't get pending)



				// Sleep for 200 ms.  We don't use WaitForEventOrCancel because that
				// puts spew out and we sort of want to send as fast as possible.
				Sleep(200);
			} // end do (while haven't exceeded time)
			while ((timeGetTime() - dwStartTime) < 10000);


			DPL(1, "Sent %i total messages in approximately 10 seconds.", 1, i);




#pragma TODO(vanceo, "Improve this waiting mechanism here and below")

			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting until send queues empty");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
				// Skip our tester number.
				if (i == pTNecd->iTesterNum)
					continue;


				tr = pDP8Peer->DP8P_GetSendQueueInfo(context.padpnidTesters[i],
													&dwNumMsgs,
													NULL,
													0);
				if (tr != DPN_OK)
				{
					DPL(0, "Getting send queue info for tester %i (player ID %u/%x) failed!",
						3, i, context.padpnidTesters[i], context.padpnidTesters[i]);
					THROW_TESTRESULT;
				} // end if (get send queue failed)

				if (dwNumMsgs > 0)
				{
					dwStartTime = timeGetTime();

					do
					{
						DPL(7, "Tester %i (player ID %u/%x)'s send queue has %u messages still in it.",
							4, i, context.padpnidTesters[i], context.padpnidTesters[i],
							dwNumMsgs);


						// Sleep for 100 ms.  We don't use WaitForEventOrCancel because
						// that has overhead that we really don't need.
						Sleep(100);


						// Use the API directly so we don't have tons of our wrapper
						// spew.
						tr = pDP8Peer->m_pDP8Peer->GetSendQueueInfo(context.padpnidTesters[i],
																	&dwNumMsgs,
																	NULL,
																	0);
						if (tr != DPN_OK)
						{
							DPL(0, "Getting send queue info for tester %i (player ID %u/%x) failed!",
								3, i, context.padpnidTesters[i],
								context.padpnidTesters[i]);
							THROW_TESTRESULT;
						} // end if (get send queue failed)
					} // end do (while still messages in queue)
					while (dwNumMsgs > 0);

					DPL(0, "WARNING: Waited about %u ms for tester %i (player ID %u/%x)'s send queue to clear.",
						4, timeGetTime() - dwStartTime, i,
						context.padpnidTesters[i], context.padpnidTesters[i]);
				} // end if (there are messages in queue)
			} // end for (each tester)





			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Exchanging reliable message counts (pre-migration)");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// Note that we send the entire array, including the entry for sending
			// to ourselves.  It's just easier to send extra data than deal with the
			// hassle of creating an array just for this sync.
			sr = pTNecd->pExecutor->SyncWithTesters("Exchange message counts pre",
													paiReliableMsgsSentToTesters,
													(pTNecd->iNumMachines * sizeof (int)),
													&syncdata,
													0);
			HANDLE_SYNC_RESULT;


			for(i = 0; i < pTNecd->iNumMachines; i++)
			{
#pragma TODO(vanceo, "Check the number of messages we get from ourselves, too")
				// Skip our tester number
				if (i == pTNecd->iTesterNum)
					continue;

				CHECKANDGET_SYNCDATA(syncdata, i, paiReliableMsgsSentByTester,
									dwSyncDataSize, (pTNecd->iNumMachines * sizeof (int)));


				if (context.paiReliableMsgsReceivedFromTesters[i] != paiReliableMsgsSentByTester[pTNecd->iTesterNum])
				{
					DPL(0, "We received %i reliable messages from tester %i (player %u/%x) but he says he sent %i to us.",
						5, context.paiReliableMsgsReceivedFromTesters[i],
						i,
						context.padpnidTesters[i],
						context.padpnidTesters[i],
						paiReliableMsgsSentByTester[pTNecd->iTesterNum]);

					pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
										"We received %i reliable messages from tester %i (player %u/%x) but he says he sent %i to us.",
										5, context.paiReliableMsgsReceivedFromTesters[i],
										i,
										context.padpnidTesters[i],
										context.padpnidTesters[i],
										paiReliableMsgsSentByTester[pTNecd->iTesterNum]);

					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (didn't get expected amount)

				DPL(1, "Tester %i sent %i reliable messages to us.",
					2, i, context.paiReliableMsgsReceivedFromTesters[i]);
			} // end for (each tester)

			
			// Reset the reliable message counts for the post-migration sends.
			ZeroMemory(paiReliableMsgsSentToTesters,
						(pTNecd->iNumMachines * sizeof (int)));

			ZeroMemory(context.paiReliableMsgsReceivedFromTesters,
						(pTNecd->iNumMachines * sizeof (int)));




			TESTSECTION_IF(context.fDroppingPlayer)
			{
				TESTSECTION_IF((pRoundRobinInput != NULL) && ((iCurrentIteration + 1) < pRoundRobinInput->iNumIterations))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Getting soon-to-be-host's address for reconnection later");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


					if (context.fSecondInCommandCase)
						iNextHost = (context.iCurrentHost + 2) % pTNecd->iNumMachines;
					else
						iNextHost = (context.iCurrentHost + 1) % pTNecd->iNumMachines;

					tr = pDP8Peer->DP8P_GetPeerAddress(context.padpnidTesters[iNextHost],
													&pDP8AddressRemote,
													0);
					if (tr != DPN_OK)
					{
						DPL(0, "Couldn't get next host (%i)'s address!",
							1, iNextHost);
						THROW_TESTRESULT;
					} // end if (couldn't get peer address)


#ifdef DEBUG
					do
					{
						dwURLSize = dwURLBufferSize;

						tr = pDP8AddressRemote->GetURLA(pszURL, &dwURLSize);
						if (tr == DPNERR_BUFFERTOOSMALL)
						{
							SAFE_LOCALFREE(pszURL);
							LOCALALLOC_OR_THROW(char*, pszURL, dwURLSize);
							dwURLBufferSize = dwURLSize;
						} // end if (buffer too small)
						else if (tr != DPN_OK)
						{
							DPL(0, "Couldn't get next host address's URL!", 0);
							THROW_TESTRESULT;
						} // end if (didn't get URL)
					} // end do (while buffer too small)
					while (tr == DPNERR_BUFFERTOOSMALL);

					DPL(1, "Will use address (\"%s\") to reconnect (to tester %i, ID %u/%x).",
						4, pszURL, iNextHost, context.padpnidTesters[iNextHost],
						context.padpnidTesters[iNextHost]);
#endif // DEBUG
				} // end if (more iterations)
				TESTSECTION_ENDIF
			} // end if (dropping player)
			TESTSECTION_ENDIF



			// Create an event to set when the appropriate DESTROY_PLAYERs are
			// received.
			CREATEEVENT_OR_THROW(context.hPlayersGoneEvent,
								NULL, FALSE, FALSE, NULL);

			// Testers who aren't the current host need to get ready for the
			// host to migrate when he leaves.
			if (! context.fDroppingPlayer)
			{
				CREATEEVENT_OR_THROW(context.hHostMigratedEvent,
									NULL, FALSE, FALSE, NULL);

				if (context.iGroupOrDataOperation != GROUPORDATAOP_NONE)
				{
					CREATEEVENT_OR_THROW(context.hGroupOrDataOperationEvent,
										NULL, FALSE, FALSE, NULL);
				} // end if (group/data operations case)
			} // end if (not current original host tester)

			ZeroMemory(context.pafTesterIndicated,
						(pTNecd->iNumMachines * sizeof (BOOL)));



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Waiting for everyone to be ready to migrate host");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = pTNecd->pExecutor->SyncWithTesters("Ready to migrate host", NULL, 0, NULL, 0);
			HANDLE_SYNC_RESULT;



			// The current host should close his session, and everyone remaining in
			// the session should see him leave, plus agree upon who became the new
			// host.
			TESTSECTION_IF(context.fDroppingPlayer)
			{
				TESTSECTION_IF((pTNecd->pExecutor->IsCase("2.3.2.1")) || (pTNecd->pExecutor->IsCase("2.3.2.2")))
				{
					// We do NOT expect our local player to be removed.
					context.fSelfIndicate = FALSE;



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Creating IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->CreateNewFaultSim(&pFaultSim,
															TN_FAULTSIM_IMTEST,
															NULL,
															0);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't create IMTest fault simulator!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't create fault simulator)




					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Disconnecting sends and receives, will drop from session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)

					sr = pTNecd->pExecutor->FaultSimDisconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't disconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't disconnect)



#pragma TODO(vanceo, "Timeout (be able to set protocol caps: keepalives?)")
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for connections to all other players to drop");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&context.hPlayersGoneEvent,
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;





					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Restoring send and receive traffic");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, TRUE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect sends!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)

					sr = pTNecd->pExecutor->FaultSimReconnect(pFaultSim, FALSE);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't reconnect receives!", 0);
						THROW_SYSTEMRESULT;
					} // end if (couldn't reconnect)



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Releasing IMTest fault simulator");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
					if (sr != S_OK)
					{
						DPL(0, "Couldn't release fault simulator %x!", 1, pFaultSim);
						THROW_SYSTEMRESULT;
					} // end if (couldn't release fault simulator)
				} // end if (drop host migration case)
				TESTSECTION_ENDIF



				// We expect our own player to be removed.
				context.fSelfIndicate = TRUE;


				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Disconnecting from session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_Close(0);
				if (tr != DPN_OK)
				{
					DPL(0, "Closing failed!", 0);
					THROW_TESTRESULT;
				} // end if (close failed)


				// Make sure the group operations were unwound, if necessary.
				if (context.dpnidPlayerAddedToGroup != 0)
				{
					DPL(0, "Player add to group ID wasn't cleared!", 0);
					SETTHROW_TESTRESULT(ERROR_NO_DATA);
				} // end if (player ID wasn't cleared)

				if (context.dpnidGroup != 0)
				{
					DPL(0, "Group ID wasn't cleared!", 0);
					SETTHROW_TESTRESULT(ERROR_NO_DATA);
				} // end if (group ID wasn't cleared)

				// Make sure all the players are gone.
				for(i = 0; i < pTNecd->iNumMachines; i++)
				{
					if (! context.pafTesterIndicated[i])
					{
						DPL(0, "Tester %i was not removed from nametable!",
							1, i);
						SETTHROW_TESTRESULT(ERROR_NO_DATA);
					} // end if (tester not indicated)
				} // end for (each tester)

				if (context.iGroupOrDataOperation == GROUPORDATAOP_SETPEERINFO)
				{
					if (context.fPeerInfoSet)
					{
						DPL(0, "Noting (again) that the peer info update notification sneaked in sometime during shutdown.", 0);
						context.fPeerInfoSet = FALSE;
					} // end if (peer info indication arrived)
				} // end if (set peer info group/data operation)
				else if (context.iGroupOrDataOperation == GROUPORDATAOP_SETGROUPINFO)
				{
					if (context.fGroupInfoSet)
					{
						DPL(0, "Noting (again) that the group info update notification sneaked in sometime during shutdown.", 0);
						context.fGroupInfoSet = FALSE;
					} // end if (group info indication arrived)
				} // end if (set group info group/data operation)



				// Technically, we didn't even need this event for the normal leave
				// case.
				CloseHandle(context.hPlayersGoneEvent);
				context.hPlayersGoneEvent = NULL;



				// Clear this, to be paranoid.
				context.pDP8Peer = NULL;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Releasing DirectPlay8Peer object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->Release();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't release DirectPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't release object)
			} // end if (dropping tester)
			TESTSECTION_ELSE
			{
				// If this is a group operation case and we're supposed to perform
				// the group operation, do so.
				TESTSECTION_IF(context.fGroupOrDataOperatingPlayer)
				{
					TESTSECTION_SWITCH(context.iGroupOrDataOperation)
					{
						TESTSECTION_CASE(GROUPORDATAOP_SETPEERINFO)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to set peer info");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							tr = pDP8Peer->DP8P_SetPeerInfo(&dpnpi,
															NULL,
															&dpnhGroupOrDataOp,
															0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								DPL(0, "Setting peer info didn't return expected PENDING success code!", 0);
								THROW_TESTRESULT;
							} // end if (couldn't set peer info)
						}
						TESTSECTION_ENDCASE

						TESTSECTION_CASE(GROUPORDATAOP_CREATEGROUP)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to create a group");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							tr = pDP8Peer->DP8P_CreateGroup(&dpngi,
															NULL,
															NULL,
															&dpnhGroupOrDataOp,
															0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								DPL(0, "Creating group didn't return expected PENDING success code!", 0);
								THROW_TESTRESULT;
							} // end if (couldn't create group)
						}
						TESTSECTION_ENDCASE

						TESTSECTION_CASE(GROUPORDATAOP_SETGROUPINFO)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to set group info");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							tr = pDP8Peer->DP8P_SetGroupInfo(context.dpnidGroup,
															&dpngi,
															NULL,
															&dpnhGroupOrDataOp,
															0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								DPL(0, "Setting group info didn't return expected PENDING success code!", 0);
								THROW_TESTRESULT;
							} // end if (couldn't set group info)
						}
						TESTSECTION_ENDCASE

						TESTSECTION_CASE(GROUPORDATAOP_ADDPLAYERTOGROUP)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to add self to the group");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							tr = pDP8Peer->DP8P_AddPlayerToGroup(context.dpnidGroup,
																context.padpnidTesters[pTNecd->iTesterNum],
																NULL,
																&dpnhGroupOrDataOp,
																0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								DPL(0, "Adding player to group didn't return expected PENDING success code!", 0);
								THROW_TESTRESULT;
							} // end if (couldn't add player to group)
						}
						TESTSECTION_ENDCASE

						TESTSECTION_CASE(GROUPORDATAOP_REMOVEPLAYERFROMGROUP)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to remove the player from the group");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							// Since we're removing a different player that might be
							// racing to drop from the session, we need to handle
							// the INVALIDPLAYER and PLAYERNOTINGROUP error codes as
							// well.
							tr = pDP8Peer->DP8P_RemovePlayerFromGroup(context.dpnidGroup,
																	context.dpnidPlayerAddedToGroup,
																	NULL,
																	&dpnhGroupOrDataOp,
																	0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								if ((tr != (HRESULT) DPNSUCCESS_PENDING) &&
									(tr != (HRESULT) DPNERR_INVALIDPLAYER) &&
									(tr != (HRESULT) DPNERR_PLAYERNOTINGROUP))
								{
									DPL(0, "Removing player from group didn't return expected PENDING, INVALIDPLAYER, or PLAYERNOTINGROUP!", 0);
									THROW_TESTRESULT;
								} // end if (couldn't remove player from group)

								// It failed to even startup up, so we won't get an
								// async op completion.  However, we still expect
								// the REMOVE_PLAYER_FROM_GROUP to be indicated due
								// to the nametable unwind.  It may have already
								// arrived by the time we notify the callback, so
								// check right after we set the alerting boolean.
								context.fNoAsyncOpCompletion = TRUE;
								if (context.dpnidPlayerAddedToGroup == 0)
								{
									DPL(0, "REMOVE_PLAYER_FROM_GROUP message appears to already have arrived, setting event.", 0);
									
									if (! SetEvent(context.hGroupOrDataOperationEvent))
									{
										sr = GetLastError();

										DPL(0, "Couldn't set group or data operation event (%x)!",
											1, context.hGroupOrDataOperationEvent);
										THROW_SYSTEMRESULT;
									} // end if (couldn't set event)
								} // end if (message already arrived)
							} // end if (couldn't remove player from group)
						}
						TESTSECTION_ENDCASE

						TESTSECTION_CASE(GROUPORDATAOP_DESTROYGROUP)
						{
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -
							TEST_SECTION("Starting to destroy the group");
							// - - - - - - - - - - - - - - - - - - - - - - - - - - -

							tr = pDP8Peer->DP8P_DestroyGroup(context.dpnidGroup,
															NULL,
															&dpnhGroupOrDataOp,
															0);
							if (tr != (HRESULT) DPNSUCCESS_PENDING)
							{
								DPL(0, "Destroying group didn't return expected PENDING success code!", 0);
								THROW_TESTRESULT;
							} // end if (couldn't destroy group)
						}
						TESTSECTION_ENDCASE

#ifdef DEBUG
						TESTSECTION_DEFAULT
						{
							DPL(0, "Unexpected group/data operation %i!  DEBUGBREAK()-ing.",
								1, context.iGroupOrDataOperation);
							DEBUGBREAK();
						}
						TESTSECTION_ENDDEFAULT
#endif // DEBUG
					} // end if (creating a group)
					TESTSECTION_ENDSWITCH
				} // end if (group operations case)
				TESTSECTION_ENDIF


				TESTSECTION_IF(context.fSecondInCommandCase)
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for old host and second in command delete player notifications");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				} // end if (second in command case)
				TESTSECTION_ELSE
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for old host's delete player notification");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				} // end else (not second in command case)
				TESTSECTION_ENDIF

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hPlayersGoneEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(context.hPlayersGoneEvent);
				context.hPlayersGoneEvent = NULL;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for host migration notification");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hHostMigratedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;

				CloseHandle(context.hHostMigratedEvent);
				context.hHostMigratedEvent = NULL;



				TESTSECTION_IF(context.iGroupOrDataOperation != GROUPORDATAOP_NONE)
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for group or data operation notification");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hGroupOrDataOperationEvent),
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;


					// Make sure we got the indication correctly.  We really
					// shouldn't have our event set if we didn't, but we'll double
					// check to be sure.
					switch (context.iGroupOrDataOperation)
					{
						case GROUPORDATAOP_SETPEERINFO:
							if (! context.fPeerInfoSet)
							{
								DPL(0, "Peer info wasn't set!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (peer info wasn't set)

							// Reset the value.
							context.fPeerInfoSet = FALSE;
						  break;

						case GROUPORDATAOP_CREATEGROUP:
							if (context.dpnidGroup == 0)
							{
								DPL(0, "Group ID wasn't set!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (group ID wasn't set)
						  break;

						case GROUPORDATAOP_SETGROUPINFO:
							if (! context.fGroupInfoSet)
							{
								DPL(0, "Group info wasn't set!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (group info wasn't set)

							// Reset the value.
							context.fGroupInfoSet = FALSE;
						  break;

						case GROUPORDATAOP_ADDPLAYERTOGROUP:
							if (context.dpnidPlayerAddedToGroup == 0)
							{
								DPL(0, "Player add to group ID wasn't set!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (player ID wasn't set)
						  break;

						case GROUPORDATAOP_REMOVEPLAYERFROMGROUP:
							if (context.dpnidPlayerAddedToGroup != 0)
							{
								DPL(0, "Player add to group ID wasn't cleared!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (player ID wasn't cleared)
						  break;

						case GROUPORDATAOP_DESTROYGROUP:
							if (context.dpnidGroup != 0)
							{
								DPL(0, "Group ID wasn't cleared!", 0);
								SETTHROW_TESTRESULT(ERROR_NO_DATA);
							} // end if (group ID wasn't cleared)
						  break;
					} // end switch (on group operation)

					CloseHandle(context.hGroupOrDataOperationEvent);
					context.hGroupOrDataOperationEvent = NULL;


					// Reset this boolean in case it was set.
					context.fNoAsyncOpCompletion = FALSE;
				} // end if (group operations case)
				TESTSECTION_ENDIF



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Starting sends after host migration");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				i = 0;
				dwStartTime = timeGetTime();

				do
				{
					// Move to the next person to send to.
					i++;


					// Use the API directly so we don't have tons of our wrapper
					// spew.
					// We'll send a reliable message every (NumMachines)th send.
					// Since we're sending to (NumMachines - 1) different targets
					// now, we'll end up sending that reliable message to a
					// different person every time (wrapping back around of course).
					// By sending guaranteed messages synchronously, we don't have
					// to wait for completions, DPlay will do it for us.  We really
					// only need to wait for the last completion, because order is
					// preserved for reliable messages, but since we're sending for
					// a set amount of time, we don't know which send will be the
					// last one.  So, in keeping with my laziness, we'll send them
					// all synchronously.
					// They're also "complete on process" so I don't have to
					// implement any timeouts waiting for acked reliable messages
					// (messages that completed on the sending side) but have yet
					// to be received at the app level.
					// Not everyone is in the session, so we have to skip the
					// current original host's (and second-in-command's, if that type
					// of test) index in the array.

					if (context.fSecondInCommandCase)
					{
						if ((i % (pTNecd->iNumMachines - 1)) == 0)
							paiReliableMsgsSentToTesters[((i % (pTNecd->iNumMachines - 2)) + context.iCurrentHost + 2) % pTNecd->iNumMachines]++;

						tr = pDP8Peer->m_pDP8Peer->SendTo(context.padpnidTesters[((i % (pTNecd->iNumMachines - 2)) + context.iCurrentHost + 2) % pTNecd->iNumMachines],
															(((i % (pTNecd->iNumMachines - 1)) == 0) ? &dpnbdReliable : &dpnbdUnreliable),
															1,
															0,
															NULL,
															(((i % (pTNecd->iNumMachines - 1)) == 0) ? NULL : &dpnhSend),
															(((i % (pTNecd->iNumMachines - 1)) == 0) ? (DPNSEND_SYNC | DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED) : DPNSEND_NOCOPY));
					} // end if (second in command case)
					else
					{
						if ((i % pTNecd->iNumMachines) == 0)
							paiReliableMsgsSentToTesters[((i % (pTNecd->iNumMachines - 1)) + context.iCurrentHost + 1) % pTNecd->iNumMachines]++;

						tr = pDP8Peer->m_pDP8Peer->SendTo(context.padpnidTesters[((i % (pTNecd->iNumMachines - 1)) + context.iCurrentHost + 1) % pTNecd->iNumMachines],
															(((i % pTNecd->iNumMachines) == 0) ? &dpnbdReliable : &dpnbdUnreliable),
															1,
															0,
															NULL,
															(((i % pTNecd->iNumMachines) == 0) ? NULL : &dpnhSend),
															(((i % pTNecd->iNumMachines) == 0) ? (DPNSEND_SYNC | DPNSEND_NOCOPY | DPNSEND_COMPLETEONPROCESS | DPNSEND_GUARANTEED) : DPNSEND_NOCOPY));
					} // end else (not second in command case)

					// Allow OK for SYNC and PENDING for async sends.
					if ((tr != DPN_OK) && (tr != (HRESULT) DPNSUCCESS_PENDING))
					{
						DPL(0, "SendTo didn't return OK or expected PENDING success code!", 0);
						THROW_TESTRESULT;
					} // end if (didn't get pending)



					// Sleep for 200 ms.  We don't use WaitForEventOrCancel because
					// that puts spew out and we sort of want to send as fast as
					// possible.
					Sleep(200);
				} // end do (while haven't exceeded time)
				while ((timeGetTime() - dwStartTime) < 10000);


				DPL(1, "Sent %i total messages in approximately 10 seconds.", 1, i);




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting until send queues empty");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				for(i = 0; i < pTNecd->iNumMachines; i++)
				{
					// Skip our tester number and the people who left the session.
					if ((i == pTNecd->iTesterNum) || (i == context.iCurrentHost) ||
						((context.fSecondInCommandCase) && (i == ((context.iCurrentHost + 1) % pTNecd->iNumMachines))))
					{
						continue;
					} // end if (self or missing player)


					tr = pDP8Peer->DP8P_GetSendQueueInfo(context.padpnidTesters[i],
														&dwNumMsgs,
														NULL,
														0);
					if (tr != DPN_OK)
					{
						DPL(0, "Getting send queue info for tester %i (player ID %u/%x) failed!",
							3, i, context.padpnidTesters[i], context.padpnidTesters[i]);
						THROW_TESTRESULT;
					} // end if (get send queue failed)

					if (dwNumMsgs > 0)
					{
						dwStartTime = timeGetTime();

						do
						{
							DPL(7, "Tester %i (player ID %u/%x)'s send queue has %u messages still in it.",
								4, i, context.padpnidTesters[i], context.padpnidTesters[i],
								dwNumMsgs);


							// Sleep for 100 ms.  We don't use WaitForEventOrCancel because
							// that has overhead that we really don't need.
							Sleep(100);


							// Use the API directly so we don't have tons of our wrapper
							// spew.
							tr = pDP8Peer->m_pDP8Peer->GetSendQueueInfo(context.padpnidTesters[i],
																		&dwNumMsgs,
																		NULL,
																		0);
							if (tr != DPN_OK)
							{
								DPL(0, "Getting send queue info for tester %i (player ID %u/%x) failed!",
									3, i, context.padpnidTesters[i],
									context.padpnidTesters[i]);
								THROW_TESTRESULT;
							} // end if (get send queue failed)
						} // end do (while still messages in queue)
						while (dwNumMsgs > 0);

						DPL(0, "WARNING: Waited about %u ms for tester %i (player ID %u/%x)'s send queue to clear.",
							4, timeGetTime() - dwStartTime, i,
							context.padpnidTesters[i], context.padpnidTesters[i]);
					} // end if (there are messages in queue)
				} // end for (each tester)





				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Exchanging reliable message counts (post-migration)");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				// Note we actually send the count of messages we sent to the
				// missing player(s) (which should always be zero) AND the number
				// we sent to ourselves.  It's easier to just send 2-3 extra integers
				// than copy to another array just for this sync.
				// We synchronize only with the players that didn't drop out of the
				// session, though.
				if (context.fSecondInCommandCase)
				{
					sr = pTNecd->pExecutor->SyncWithTestersArray("Exchange message counts post",
																paiReliableMsgsSentToTesters,
																(pTNecd->iNumMachines * sizeof (int)),
																&syncdata,
																(pTNecd->iNumMachines - 3),
																(paiOtherTesters + 2));
				} // end if (second in command case)
				else
				{
					sr = pTNecd->pExecutor->SyncWithTestersArray("Exchange message counts post",
																paiReliableMsgsSentToTesters,
																(pTNecd->iNumMachines * sizeof (int)),
																&syncdata,
																(pTNecd->iNumMachines - 2),
																(paiOtherTesters + 1));
				} // end else (not second in command case)
				HANDLE_SYNC_RESULT;


				for(i = 0; i < pTNecd->iNumMachines; i++)
				{
#pragma TODO(vanceo, "Check the number of messages we get from ourselves, too")
					// Skip our tester number and the people who left the session.
					if ((i == pTNecd->iTesterNum) || (i == context.iCurrentHost) ||
						((context.fSecondInCommandCase) && (i == ((context.iCurrentHost + 1) % pTNecd->iNumMachines))))
					{
						continue;
					} // end if (self or missing player)


					CHECKANDGET_SYNCDATA(syncdata, i, paiReliableMsgsSentByTester,
										dwSyncDataSize, (pTNecd->iNumMachines * sizeof (int)));


					if (context.paiReliableMsgsReceivedFromTesters[i] != paiReliableMsgsSentByTester[pTNecd->iTesterNum])
					{
						DPL(0, "We received %i reliable messages from tester %i (player %u/%x) but he says he sent %i to us.",
							5, context.paiReliableMsgsReceivedFromTesters[i],
							i,
							context.padpnidTesters[i],
							context.padpnidTesters[i],
							paiReliableMsgsSentByTester[pTNecd->iTesterNum]);

						pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
											"We received %i reliable messages from tester %i (player %u/%x) but he says he sent %i to us.",
											5, context.paiReliableMsgsReceivedFromTesters[i],
											i,
											context.padpnidTesters[i],
											context.padpnidTesters[i],
											paiReliableMsgsSentByTester[pTNecd->iTesterNum]);

						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (didn't get expected amount)

					DPL(1, "Tester %i sent %i reliable messages to us.",
						2, i, context.paiReliableMsgsReceivedFromTesters[i]);
				} // end for (each tester)
			} // end else (not dropping tester)
			TESTSECTION_ENDIF



			TESTSECTION_IF(pRoundRobinInput == NULL)
			{
				DPL(1, "Simple case, only one iteration required.", 0);
				TESTSECTION_BREAK;
			} // end if (not round robin case)
			TESTSECTION_ENDIF



			iCurrentIteration++;

			// If there aren't any more iterations, we can skip the rejoin phase.
			TESTSECTION_IF(iCurrentIteration >= pRoundRobinInput->iNumIterations)
			{
				DPL(1, "Final iteration completed.", 0);
				TESTSECTION_BREAK;
			} // end if (last iteration)
			TESTSECTION_ENDIF



			DPL(1, "Preparing for iteration %i.", 1, iCurrentIteration);
			pTNecd->pExecutor->Log(TNLF_PREFIX_TESTUNIQUEID,
									"Preparing for iteration %i.",
									1, iCurrentIteration);



			// Reset the player ID for the original host since he's no longer in
			// the session.  Same goes for second in command, if he's gone.
			context.padpnidTesters[context.iCurrentHost] = 0;
			if (context.fSecondInCommandCase)
				context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines] = 0;


			context.pDP8Peer = pDP8Peer; // this will be NULL for original host

			context.hRejoinedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (context.hRejoinedEvent == NULL)
			{
				sr = GetLastError();
				DPL(0, "Couldn't create rejoin event!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't create event)


			// Reset the reliable message counts for the next round of sends.
			ZeroMemory(paiReliableMsgsSentToTesters,
						(pTNecd->iNumMachines * sizeof (int)));

			ZeroMemory(context.paiReliableMsgsReceivedFromTesters,
						(pTNecd->iNumMachines * sizeof (int)));

			ZeroMemory(context.pafTesterIndicated,
						(pTNecd->iNumMachines * sizeof (BOOL)));



			// Now the players who left should rejoin the session.
			TESTSECTION_IF(context.fDroppingPlayer)
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Recreating DirectPlay8Peer object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->CoCreate();
				if (tr != S_OK)
				{
					DPL(0, "Couldn't CoCreate DirectPlay8Peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't CoCreate)

				context.pDP8Peer = pDP8Peer; // update context pointer for this, too




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Initializing object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				// We have to use the bldssn message handler because we use the
				// destroy session helper later, and that requires the appropriate
				// message handler.
				tr = pDP8Peer->DP8P_Initialize(&context,
												BldDP8PeerDPNMessageHandler,
												0);
				if (tr != S_OK)
				{
					DPL(0, "Couldn't initialize peer object!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't initialize)



				hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (hConnectCompleteEvent == NULL)
				{
					sr = GetLastError();
					DPL(0, "Couldn't create connect completion event!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't create event)




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("CoCreating local address object");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = CoCreateInstance(CLSID_DirectPlay8Address, NULL,
									CLSCTX_INPROC_SERVER, IID_IDirectPlay8Address,
									(LPVOID*) &pDP8AddressLocal);
				if (sr != S_OK)
				{
					DPL(0, "Couldn't CoCreate address object!", 0);
					THROW_SYSTEMRESULT;
				} // end if (couldn't CoCreate object)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Setting local address' SP");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8AddressLocal->SetSP(&CLSID_DP8SP_TCPIP);
				if (tr != DPN_OK)
				{
					DPL(0, "Couldn't set local address' SP!", 0);
					THROW_TESTRESULT;
				} // end if (couldn't set SP)


				context.fSelfIndicate = TRUE;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with players still in session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for old host rejoin",
														NULL, 0,
														NULL,
														0);
				HANDLE_SYNC_RESULT;



				TESTSECTION_IF(context.iCurrentHost != pTNecd->iTesterNum)
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for old host to rejoin before us");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old host player ID",
															NULL, 0,
															&syncdata,
															0);
					HANDLE_SYNC_RESULT;

					CHECKANDGET_SYNCDATA(syncdata, context.iCurrentHost,
										pvSyncData, dwSubOutputDataSize, sizeof (DPNID));


					// Store the original host's new player ID.
					context.padpnidTesters[context.iCurrentHost] = *((DPNID*) pvSyncData);
				} // end if (not original host)
				TESTSECTION_ENDIF



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Reconnecting to session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				tr = pDP8Peer->DP8P_Connect(&dpnad,
											pDP8AddressRemote,
											pDP8AddressLocal,
											NULL,
											NULL,
											NULL,
											0,
											NULL,
											hConnectCompleteEvent,
											&dpnhConnect,
											0);
				if (tr != (HRESULT) DPNSUCCESS_PENDING)
				{
					DPL(0, "Connect didn't return expected PENDING success code!", 0);
					THROW_TESTRESULT;
				} // end if (connect not pending)


				// We don't need the remote address anymore.
				pDP8AddressRemote->Release();
				pDP8AddressRemote = NULL;

				// We don't need the local address anymore.
				pDP8AddressLocal->Release();
				pDP8AddressLocal = NULL;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for all players in session to connect");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hRejoinedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;



				context.fSelfIndicate = FALSE;




				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for connect completion notification");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&hConnectCompleteEvent,
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;


				CloseHandle(hConnectCompleteEvent);
				hConnectCompleteEvent = NULL;

				// Make sure the current group status got rebuilt correctly.
				if (context.iGroupOrDataOperation != GROUPORDATAOP_NONE)
				{
					if ((context.iGroupOrDataOperation == GROUPORDATAOP_SETPEERINFO) ||
						(context.iGroupOrDataOperation == GROUPORDATAOP_DESTROYGROUP))
					{
						if (context.dpnidGroup != 0)
						{
							DPL(0, "Got CREATE_GROUP indication (ID = %u/%x)!",
								2, context.dpnidGroup, context.dpnidGroup);
							SETTHROW_TESTRESULT(E_FAIL);
						} // end if (group ID wasn't set)
					} // end if (destroy group operation)
					else
					{
						if (context.dpnidGroup == 0)
						{
							DPL(0, "Didn't get expected CREATE_GROUP indication!", 0);
							SETTHROW_TESTRESULT(ERROR_NO_DATA);
						} // end if (group ID wasn't set)
					} // end else (not destroy group operation)


					if (context.iGroupOrDataOperation == GROUPORDATAOP_ADDPLAYERTOGROUP)
					{
						if (context.dpnidPlayerAddedToGroup == 0)
						{
							DPL(0, "Didn't get expected ADD_PLAYER_TO_GROUP indication!", 0);
							SETTHROW_TESTRESULT(ERROR_NO_DATA);
						} // end if (player ID wasn't set)
					} // end if (add player to group operation)
					else
					{
						if (context.dpnidPlayerAddedToGroup != 0)
						{
							DPL(0, "Got ADD_PLAYER_TO_GROUP indication (player ID = %u/%x)!",
								2, context.dpnidPlayerAddedToGroup,
								context.dpnidPlayerAddedToGroup);
							SETTHROW_TESTRESULT(E_FAIL);
						} // end if (player ID wasn't set)
					} // end else (not add player to group operation)
				} // end if (group operations case)



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Ensure everyone has our player ID correct");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				if (context.iCurrentHost == pTNecd->iTesterNum)
				{
					sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old host player ID",
															&(context.padpnidTesters[pTNecd->iTesterNum]),
															sizeof (DPNID),
															NULL,
															0);
				} // end if (original host)
				else
				{
					sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old second-in-command player ID",
															&(context.padpnidTesters[pTNecd->iTesterNum]),
															sizeof (DPNID),
															NULL,
															0);
				} // end else (original second in command)
				HANDLE_SYNC_RESULT;



				TESTSECTION_IF((context.fSecondInCommandCase) && (context.iCurrentHost == pTNecd->iTesterNum))
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for old second-in-command to rejoin session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hRejoinedEvent),
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Making sure new player ID for old second-in-command is correct");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old second-in-command player ID",
															NULL, 0,
															&syncdata,
															0);
					HANDLE_SYNC_RESULT;

					CHECKANDGET_SYNCDATA(syncdata, ((context.iCurrentHost + 1) % pTNecd->iNumMachines),
										pvSyncData, dwSubOutputDataSize, sizeof (DPNID));


					// Make sure he got the same ID we saw him get.
					if (context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines] != *((DPNID*) pvSyncData))
					{
						DPL(0, "The original second-in-command (tester %i) rejoining player ID %u/%x we received differs from the ID he claims he got (%u/%x)!",
							5, ((context.iCurrentHost + 1) % pTNecd->iNumMachines),
							context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines],
							context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines],
							*((DPNID*) pvSyncData),
							*((DPNID*) pvSyncData));
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (IDs don't match)
				} // end if (not original host)
				TESTSECTION_ENDIF
			} // end if (original host who left)
			TESTSECTION_ELSE
			{
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Synchronizing with rejoining old host");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ready for old host rejoin",
														NULL, 0,
														NULL,
														0);
				HANDLE_SYNC_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Waiting for old host to rejoin session");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hRejoinedEvent),
															1,
															NULL,
															-1,
															INFINITE,
															NULL);
				HANDLE_WAIT_RESULT;



				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				TEST_SECTION("Making sure new player ID for old host is correct");
				// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

				sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old host player ID",
														NULL, 0,
														&syncdata,
														0);
				HANDLE_SYNC_RESULT;

				CHECKANDGET_SYNCDATA(syncdata, context.iCurrentHost,
									pvSyncData, dwSubOutputDataSize, sizeof (DPNID));


				// Make sure he got the same ID we saw him get.
				if (context.padpnidTesters[context.iCurrentHost] != *((DPNID*) pvSyncData))
				{
					DPL(0, "The original host (tester %i) rejoining player ID %u/%x we received differs from the ID he claims he got (%u/%x)!",
						5, context.iCurrentHost,
						context.padpnidTesters[context.iCurrentHost],
						context.padpnidTesters[context.iCurrentHost],
						*((DPNID*) pvSyncData),
						*((DPNID*) pvSyncData));
					SETTHROW_TESTRESULT(ERROR_NO_MATCH);
				} // end if (IDs don't match)



				TESTSECTION_IF(context.fSecondInCommandCase)
				{
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Waiting for old host to rejoin session");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->WaitForEventOrCancel(&(context.hRejoinedEvent),
																1,
																NULL,
																-1,
																INFINITE,
																NULL);
					HANDLE_WAIT_RESULT;



					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					TEST_SECTION("Making sure new player ID for old second-in-command is correct");
					// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

					sr = pTNecd->pExecutor->SyncWithTesters("Ensure correct old second-in-command player ID",
															NULL, 0,
															&syncdata,
															0);
					HANDLE_SYNC_RESULT;

					CHECKANDGET_SYNCDATA(syncdata, ((context.iCurrentHost + 1) % pTNecd->iNumMachines),
										pvSyncData, dwSubOutputDataSize, sizeof (DPNID));


					// Make sure he got the same ID we saw him get.
					if (context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines] != *((DPNID*) pvSyncData))
					{
						DPL(0, "The original second-in-command (tester %i) rejoining player ID %u/%x we received differs from the ID he claims he got (%u/%x)!",
							5, ((context.iCurrentHost + 1) % pTNecd->iNumMachines),
							context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines],
							context.padpnidTesters[(context.iCurrentHost + 1) % pTNecd->iNumMachines],
							*((DPNID*) pvSyncData),
							*((DPNID*) pvSyncData));
						SETTHROW_TESTRESULT(ERROR_NO_MATCH);
					} // end if (IDs don't match)
				} // end if (second in command case)
				TESTSECTION_ENDIF
			} // end else (not original host)
			TESTSECTION_ENDIF


			// Update to the group/data operation for the next iteration, if we're
			// doing that.
			if (context.iGroupOrDataOperation != GROUPORDATAOP_NONE)
			{
				context.iGroupOrDataOperation++;
				if (context.iGroupOrDataOperation > GROUPORDATAOP_DESTROYGROUP)
					context.iGroupOrDataOperation = GROUPORDATAOP_SETPEERINFO;
			} // end if (group /dataoperations)


			CloseHandle(context.hRejoinedEvent);
			context.hRejoinedEvent = NULL;
		} // end do (while still more iterations)
		TESTSECTION_DOWHILE(TRUE);




		TESTSECTION_IF(context.fDroppingPlayer)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Releasing DirectPlay8Peer wrapper");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			sr = g_pDP8PeersList->RemoveFirstReference(pDP8Peer);
			if (sr != S_OK)
			{
				DPL(0, "Couldn't remove DirectPlay8Peer wrapper object from list!", 0);
				THROW_SYSTEMRESULT;
			} // end if (couldn't remove object from list)


			pDP8Peer->m_dwRefCount--; // release our reference
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Peer wrapper object %x.",
					1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPL(7, "Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u.",
					2, pDP8Peer,
					pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;
		} // end if (dropping player)
		TESTSECTION_ELSE
		{
			// Cleanup people still in session after last iteration.


			// For second in command cases, this will allocate one extra slot.
			// Oh well.
			LOCALALLOC_OR_THROW(DPNID*, padpnidDestroyTesters,
								((pTNecd->iNumMachines - 1) * sizeof (DPNID)));

			// Clear this, to be paranoid.
			context.pDP8Peer = NULL;


			// Shuffle the array of testers' player IDs so that it doesn't wrap
			// around.  We need to do this because the destroy session helper
			// expects the array to be contiguous.
			// We can overwrite the other testers array because it won't be used
			// again.
			i = 0;
			j = context.iCurrentHost + 1;
			if (context.fSecondInCommandCase)
				j++; // we dropped second in command, too
			j = j % pTNecd->iNumMachines; // don't start past end of array

			do
			{
				paiOtherTesters[i] = j;
				padpnidDestroyTesters[i] = context.padpnidTesters[j];

				i++;
				j = (j + 1) % pTNecd->iNumMachines;

				// Stop when we wrap around (copied all the testers we need).
				if (j == context.iCurrentHost)
					break;
			} // end do (while more tester IDs to copy)
			while (TRUE);

			



			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			TEST_SECTION("Destroying peer-to-peer session");
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

			// This is a quick and dirty way to be able to leave the session with
			// the possible REMOVE_PLAYER_FROM_GROUP and DESTROY_GROUP messages
			// generated by nametable unwinding being marked as "expected". 
			context.fDroppingPlayer = TRUE;

			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_PEER_DESTROY));
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pDP8Peer = pDP8Peer;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->padpnidTesters = padpnidDestroyTesters;

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.1.2", pvSubInputData,
														sizeof (TID_BBLDDP8_PEER_DESTROY),
														((context.fSecondInCommandCase) ? (pTNecd->iNumMachines - 2) : (pTNecd->iNumMachines - 1)),
														paiOtherTesters);
			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			LocalFree(padpnidDestroyTesters);
			padpnidDestroyTesters = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:BldPeer:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.2",
										"Destroying peer-to-peer session failed!");


			pDP8Peer->m_dwRefCount--;
			if (pDP8Peer->m_dwRefCount == 0)
			{
				DPL(7, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
				delete (pDP8Peer);
			} // end if (can delete the object)
			else
			{
				DPL(0, "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
					2, pDP8Peer, pDP8Peer->m_dwRefCount);
			} // end else (can't delete the object)
			pDP8Peer = NULL;


			// Make sure the group operations were unwound, if necessary.
			if (context.dpnidPlayerAddedToGroup != 0)
			{
				DPL(0, "Player add to group ID wasn't cleared!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (player ID wasn't cleared)

			if (context.dpnidGroup != 0)
			{
				DPL(0, "Group ID wasn't cleared!", 0);
				SETTHROW_TESTRESULT(ERROR_NO_DATA);
			} // end if (group ID wasn't cleared)
		} // end else (not current dropping tester)
		TESTSECTION_ENDIF




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Making sure everyone survived final iteration");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Done", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;




		FINAL_SUCCESS;
	}
	END_TESTCASE



	if (pFaultSim != NULL)
	{
		temphr = pTNecd->pExecutor->ReleaseFaultSim(&pFaultSim);
		if (temphr != S_OK)
		{
			DPL(0, "Couldn't release fault sim %x!  0x%08x", 2, pFaultSim, temphr);
			
			OVERWRITE_SR_IF_OK(temphr);

			pFaultSim = NULL;
		} // end if (couldn't remove handler)
	} // end if (have fault sim)

	if (pDP8Peer != NULL)
	{
		temphr = pDP8Peer->DP8P_Close(0);
		if (temphr != DPN_OK)
		{
			DPL(0, "Closing peer interface failed!  0x%08x", 1, temphr);
			OVERWRITE_SR_IF_OK(temphr);
		} // end if (closing peer interface failed)


		// Ignore error, it may not actually be on the list.
		g_pDP8PeersList->RemoveFirstReference(pDP8Peer);


		pDP8Peer->m_dwRefCount--;
		if (pDP8Peer->m_dwRefCount == 0)
		{
			DPL(7, "Deleting DirectPlay8Peer wrapper object %x.", 1, pDP8Peer);
			delete (pDP8Peer);
		} // end if (can delete the object)
		else
		{
			DPL(0, "WARNING: Can't delete DirectPlay8Peer wrapper object %x, it's refcount is %u!?",
				2, pDP8Peer, pDP8Peer->m_dwRefCount);
		} // end else (can't delete the object)
		pDP8Peer = NULL;
	} // end if (have peer object)

	SAFE_LOCALFREE(pszURL);
	SAFE_RELEASE(pDP8AddressRemote);
	SAFE_RELEASE(pDP8AddressLocal);
	SAFE_LOCALFREE(pvSubInputData);
	SAFE_LOCALFREE(paiOtherTesters);
	SAFE_LOCALFREE(paiReliableMsgsSentToTesters);
	SAFE_CLOSEHANDLE(hConnectCompleteEvent);
	SAFE_CLOSEHANDLE(context.hPlayersGoneEvent);
	SAFE_CLOSEHANDLE(context.hHostMigratedEvent);
	SAFE_CLOSEHANDLE(context.hRejoinedEvent);
	SAFE_LOCALFREE(context.pafTesterIndicated);
	SAFE_LOCALFREE(context.padpnidTesters);
	SAFE_LOCALFREE(context.paiReliableMsgsReceivedFromTesters);
	SAFE_CLOSEHANDLE(context.hGroupOrDataOperationEvent);

	return (sr);
} // HostMigrateExec_All
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"HostMigrateDPNMessageHandler()"
//==================================================================================
// HostMigrateDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT HostMigrateDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PHOSTMIGRATECONTEXT		pContext = (PHOSTMIGRATECONTEXT) pvContext;
	DWORD					dwSize = 0;
	PDPN_PLAYER_INFO		pdpnpi = NULL;
	int						iTesterNum;
	BOOL					fFound;


	switch (dwMsgType)
	{
		case DPN_MSGID_ADD_PLAYER_TO_GROUP:
			PDPNMSG_ADD_PLAYER_TO_GROUP		pAddPlayerToGroupMsg;


			pAddPlayerToGroupMsg = (PDPNMSG_ADD_PLAYER_TO_GROUP) pvMsg;


			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				if (pContext->hRejoinedEvent == NULL)
				{
					if (pContext->iGroupOrDataOperation == GROUPORDATAOP_ADDPLAYERTOGROUP)
					{
						DPL(0, "ADD_PLAYER_TO_GROUP sneaked in while we were leaving session, we had better get a REMOVE_PLAYER_FROM_GROUP shortly.", 0);
					} // end if (adding player to group)
					else
					{
						DPL(0, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (msg = %x, group/data op = %i) while dropping!  DEBUGBREAK()-ing!",
							2, pAddPlayerToGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end else (some other group/data operation)
				} // end if (dropping)
				else
				{
					if (pContext->iGroupOrDataOperation == GROUPORDATAOP_ADDPLAYERTOGROUP)
					{
						DPL(1, "Previously dropped player got expected ADD_PLAYER_TO_GROUP during rejoin (group op = %i).",
							1, pContext->iGroupOrDataOperation);
					} // end if (adding player to group)
					else
					{
						DPL(0, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (msg = %x, group/data op = %i) while rejoining!  DEBUGBREAK()-ing!",
							2, pAddPlayerToGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end else (some other group/data operation)
				} // end else (rejoining)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_ADDPLAYERTOGROUP)
				{
					DPL(0, "Got unexpected DPN_MSGID_ADD_PLAYER_TO_GROUP (msg = %x, group op = %i)!  DEBUGBREAK()-ing!",
						2, pAddPlayerToGroupMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


			// Validate the message
			if (pAddPlayerToGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPL(0, "Group ID is wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					4, pAddPlayerToGroupMsg->dpnidGroup,
					pAddPlayerToGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)

			iTesterNum = (pContext->iCurrentHost + pContext->pTNecd->iNumMachines - 1) % pContext->pTNecd->iNumMachines;
			if (pAddPlayerToGroupMsg->dpnidPlayer != pContext->padpnidTesters[iTesterNum])
			{
				DPL(0, "Player ID is wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					4, pAddPlayerToGroupMsg->dpnidPlayer,
					pAddPlayerToGroupMsg->dpnidPlayer,
					pContext->padpnidTesters[iTesterNum],
					pContext->padpnidTesters[iTesterNum]);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is wrong)

			// Check for duplicates.
			if (pContext->dpnidPlayerAddedToGroup != 0)
			{
				DPL(0, "Getting duplicate DPN_MSGID_ADD_PLAYER_TO_GROUP (already received ID %u/%x, getting %u/%x)!  DEBUGBREAK()-ing!",
					4, pContext->dpnidPlayerAddedToGroup,
					pContext->dpnidPlayerAddedToGroup,
					pAddPlayerToGroupMsg->dpnidPlayer,
					pAddPlayerToGroupMsg->dpnidPlayer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already stored ID)

			pContext->dpnidPlayerAddedToGroup = pAddPlayerToGroupMsg->dpnidPlayer;



			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(1, "Not setting event after ADD_PLAYER_TO_GROUP, async op completion should trigger for group/data operating player (tester %i).",
					1, pContext->pTNecd->iTesterNum);
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected ADD_PLAYER_TO_GROUP on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;


			if (! pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(0, "Getting async op completion on unexpected tester (%i)!  DEBUGBREAK()-ing!",
					1, pContext->pTNecd->iTesterNum);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (we're not the instigator)
			
			if (pContext->iGroupOrDataOperation == GROUPORDATAOP_REMOVEPLAYERFROMGROUP)
			{
				if ((pAsyncOpCompleteMsg->hResultCode != DPN_OK) &&
					(pAsyncOpCompleteMsg->hResultCode != DPNERR_INVALIDPLAYER) &&
					(pAsyncOpCompleteMsg->hResultCode != DPNERR_PLAYERNOTINGROUP))
				{
					DPL(0, "Async op didn't complete with OK, INVALIDPLAYER, or PLAYERNOTINGROUP!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);
					DEBUGBREAK();
					hr = pAsyncOpCompleteMsg->hResultCode;
					goto DONE;
				} // end if (result code is not OK)
			} // end if (remove player from group)
			else
			{
				if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
				{
					DPL(0, "Async op completed with a failure!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);
					DEBUGBREAK();
					hr = pAsyncOpCompleteMsg->hResultCode;
					goto DONE;
				} // end if (result code is not OK)
			} // end else (not remove player from group)

			if (! SetEvent(pContext->hGroupOrDataOperationEvent))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hGroupOrDataOperationEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			

#pragma TODO(vanceo, "Just fail test")
			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPL(0, "Failed connecting!  DEBUGBREAK()-ing.  0x%08x", 1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
			}


			// The connect context was a message handle, so set it.
			if (! SetEvent((HANDLE) pConnectCompleteMsg->pvUserContext))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set ConnectCompletion event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pConnectCompleteMsg->pvUserContext, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				//goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				if (pContext->hRejoinedEvent == NULL)
				{
					if (pContext->iGroupOrDataOperation == GROUPORDATAOP_CREATEGROUP)
					{
						DPL(0, "CREATE_GROUP (ID %u/%x) sneaked in while we were leaving session, we had better get a DESTROY_GROUP shortly.",
							2, pCreateGroupMsg->dpnidGroup,
							pCreateGroupMsg->dpnidGroup);
					} // end if (adding player to group)
					else
					{
						DPL(0, "Got unexpected DPN_MSGID_CREATE_GROUP (msg = %x, group/data op = %i) while dropping!  DEBUGBREAK()-ing!",
							2, pCreateGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end else (some other group/data operation)
				} // end if (dropping)
				else
				{
					if ((pContext->iGroupOrDataOperation != GROUPORDATAOP_SETPEERINFO) &&
						(pContext->iGroupOrDataOperation != GROUPORDATAOP_DESTROYGROUP))
					{
						DPL(1, "Dropping player got expected CREATE_GROUP (ID %u/%x) during rejoin (group/data op = %i).",
							3, pCreateGroupMsg->dpnidGroup,
							pCreateGroupMsg->dpnidGroup,
							pContext->iGroupOrDataOperation);
					} // end if (adding player to group)
					else
					{
						DPL(0, "Got unexpected DPN_MSGID_CREATE_GROUP (msg = %x, group/data op = %i) while rejoining!  DEBUGBREAK()-ing!",
							2, pCreateGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end else (some other group operation)
				} // end else (rejoining)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_CREATEGROUP)
				{
					DPL(0, "Got unexpected DPN_MSGID_CREATE_GROUP (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pCreateGroupMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


			// Check for duplicates.
			if (pContext->dpnidGroup != 0)
			{
				DPL(0, "Getting duplicate DPN_MSGID_CREATE_GROUP (already received ID %u/%x, getting %u/%x)!  DEBUGBREAK()-ing!",
					4, pContext->dpnidGroup,
					pContext->dpnidGroup,
					pCreateGroupMsg->dpnidGroup,
					pCreateGroupMsg->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already stored ID)

			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;



			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(1, "Not setting event after CREATE_GROUP, async op completion should trigger for group/data operating player (tester %i).",
					1, pContext->pTNecd->iTesterNum);
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected CREATE_GROUP on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;
			
			// If we're one of the the players who dropped, but we're rejoining now,
			// make sure the nametable we're rebuilding is correct.
			if ((pContext->fDroppingPlayer) && (pContext->fSelfIndicate))
			{
				hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pCreatePlayerMsg->dpnidPlayer,
															NULL,
															&dwSize,
															0);
				if (hr != DPNERR_BUFFERTOOSMALL)
				{
					DPL(0, "Getting peer info didn't return expected error BUFFERTOOSMALL!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (didn't return expected error)

				pdpnpi = (PDPN_PLAYER_INFO) MemAlloc(dwSize);
				if (pdpnpi == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)
				pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

				hr = pContext->pDP8Peer->DP8P_GetPeerInfo(pCreatePlayerMsg->dpnidPlayer,
															pdpnpi,
															&dwSize,
															0);
				if (hr != DPN_OK)
				{
					DPL(0, "Getting peer info failed!  DEBUGBREAK()-ing.  0x%08x", 1, hr);

					DEBUGBREAK();

					goto DONE;
				} // end if (didn't return expected error)

				if (pdpnpi->dwPlayerFlags & DPNPLAYER_LOCAL)
				{
					if (pContext->pafTesterIndicated[pContext->pTNecd->iTesterNum])
					{
						DPL(0, "Got duplicate CREATE_PLAYER for the local player (tester %i, prev player ID = %u/%x, new player ID = %u/%x)!  DEBUGBREAK()-ing.",
							5, pContext->pTNecd->iTesterNum,
							pContext->padpnidTesters[pContext->pTNecd->iTesterNum],
							pContext->padpnidTesters[pContext->pTNecd->iTesterNum],
							pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate CREATE_PLAYER for the local player!",
														0);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (already found the player)

					iTesterNum = pContext->pTNecd->iTesterNum;

					DPL(1, "Local tester (%i, player ID %u/%x) has connected.",
						3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
						pCreatePlayerMsg->dpnidPlayer);
				} // end if (it's our local player)
				else
				{
					fFound = FALSE;

					// Lookup this ID in the list of IDs everyone who had previously
					// joined (except ourselves).
					for(iTesterNum = 0; iTesterNum <= pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// Skip our ID if this is it.
						if (iTesterNum == pContext->pTNecd->iTesterNum)
							continue;

						// If we found the tester ID
						if (pContext->padpnidTesters[iTesterNum] == pCreatePlayerMsg->dpnidPlayer)
						{
							// If that player already connected, something's wrong.
							if (pContext->pafTesterIndicated[iTesterNum])
							{
								DPL(0, "Got duplicate CREATE_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
									3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
									pCreatePlayerMsg->dpnidPlayer);

								//Ignore error
								pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																"Got duplicate CREATE_PLAYER for tester %i!",
																1, iTesterNum);

								DEBUGBREAK();

								hr = E_FAIL;
								goto DONE;
							} // end if (player already connected)


							DPL(1, "Tester %i (player ID %u/%x) has connected.",
								3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
								pCreatePlayerMsg->dpnidPlayer);

							fFound = TRUE;
							break;
						} // end if (found)
					} // end for (each tester who's already joined)


					// If we didn't recognize that player ID, we're screwed.
					if (! fFound)
					{
						DPL(0, "Got CREATE_PLAYER for unexpected player ID %u/%x!  DEBUGBREAK()-ing.",
							2, pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got CREATE_PLAYER for unexpected player ID %u/%x!",
														2, pCreatePlayerMsg->dpnidPlayer,
														pCreatePlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (didn't find player ID)
				} // end else (it's some other player)


				// Store the player ID.
				pContext->padpnidTesters[iTesterNum] = pCreatePlayerMsg->dpnidPlayer;

				// Associate the context with this player.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->paiReliableMsgsReceivedFromTesters[iTesterNum]);

				DPL(8, "Player context is now %x.", 1, pCreatePlayerMsg->pvPlayerContext);


				pContext->pafTesterIndicated[iTesterNum] = TRUE;


				// See if that's the last person we're waiting on to connect.
				for(iTesterNum = 0; iTesterNum < pContext->pTNecd->iNumMachines; iTesterNum++)
				{
					if (! pContext->pafTesterIndicated[iTesterNum])
					{
						// If we're the original host in a second-in-command case, and
						// we're just rejoining, then the original second-in-command
						// tester won't be in the session and therefore we shouldn't
						// wait for his CREATE_PLAYER.
						if ((pContext->fSecondInCommandCase) &&
							(pContext->pTNecd->iTesterNum == pContext->iCurrentHost) &&
							(pContext->fSelfIndicate) &&
							(iTesterNum == ((pContext->pTNecd->iTesterNum + 1) % pContext->pTNecd->iNumMachines)))
						{
							continue;
						} // end if (can skip second-in-command)

						DPL(4, "Still expecting tester %i to connect, not notifying main thread.",
							1, iTesterNum);
						// No sense in looking further, just return OK.
						goto DONE;
					} // end if (tester hasn't connected yet)
				} // end for (each tester who's already joined)
			} // end if (we're a rejoining player)
			else
			{
				// Start by assuming it's the rejoining original host.
				iTesterNum = pContext->iCurrentHost;

				if (pContext->padpnidTesters[pContext->iCurrentHost] != 0)
				{
					if (pContext->fSecondInCommandCase)
					{
						// Try looking at the rejoining original second-in-command.
						iTesterNum = (pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines;

						if (pContext->padpnidTesters[iTesterNum] != 0)
						{
							DPL(0, "Got duplicate CREATE_PLAYER (ID = %u/%x) for a rejoining player (original host tester %i player ID = %u/%x, original second-in-command tester %i player ID = %u/%x)!  DEBUGBREAK()-ing.",
								8, pCreatePlayerMsg->dpnidPlayer,
								pCreatePlayerMsg->dpnidPlayer,
								pContext->iCurrentHost,
								pContext->padpnidTesters[pContext->iCurrentHost],
								pContext->padpnidTesters[pContext->iCurrentHost],
								iTesterNum,
								pContext->padpnidTesters[iTesterNum],
								pContext->padpnidTesters[iTesterNum]);

							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
															"Got duplicate CREATE_PLAYER for a rejoining player ID %u/%x!",
															2, pCreatePlayerMsg->dpnidPlayer,
															pCreatePlayerMsg->dpnidPlayer);

							DEBUGBREAK();

							hr = E_FAIL;
							goto DONE;
						} // end if (original second in command already joined)


						DPL(1, "Original second-in-command (tester %i)'s rejoin player ID = %u/%x.",
							3, iTesterNum, pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);
					} // end if (second in command case)
					else
					{
						DPL(0, "Got duplicate CREATE_PLAYER for rejoining player (tester %i, prev player ID = %u/%x, new player ID = %u/%x)!  DEBUGBREAK()-ing.",
							5, pContext->iCurrentHost,
							pContext->padpnidTesters[pContext->iCurrentHost],
							pContext->padpnidTesters[pContext->iCurrentHost],
							pCreatePlayerMsg->dpnidPlayer,
							pCreatePlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got duplicate CREATE_PLAYER for rejoining player ID %u/%x!",
														2, pCreatePlayerMsg->dpnidPlayer,
														pCreatePlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end else (not second in command case)
				} // end if (already have the rejoining host's ID)


				// Store the player ID.
				pContext->padpnidTesters[iTesterNum] = pCreatePlayerMsg->dpnidPlayer;

				// Associate the context with this player.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->paiReliableMsgsReceivedFromTesters[iTesterNum]);
	

				DPL(8, "Player context is now %x.", 1, pCreatePlayerMsg->pvPlayerContext);
			} // end else (we're not the joining player)



			// If we got here, it means all the testers that should have connected
			// (including ourselves, if necessary) did.  Notify the main thread.

			DPL(2, "All testers expected to connect actually have, notifying main thread.", 0);

			if (! SetEvent(pContext->hRejoinedEvent))
			{
				hr = GetLastError();

				DPL(0, "Couldn't set rejoined event (%x)!  DEBUGBREAK()-ing.  0x%08x",
					2, pContext->hRejoinedEvent, hr);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				switch (pContext->iGroupOrDataOperation)
				{
					case GROUPORDATAOP_CREATEGROUP:
						DPL(0, "Got DESTROY_GROUP, assuming it's for an CREATE_GROUP that sneaked in.", 0);
					  break;

					case GROUPORDATAOP_SETGROUPINFO:
					case GROUPORDATAOP_ADDPLAYERTOGROUP:
					case GROUPORDATAOP_REMOVEPLAYERFROMGROUP:
						DPL(1, "Dropping player got DESTROY_GROUP (group/data op = %i).",
							1, pContext->iGroupOrDataOperation);
					  break;

					case GROUPORDATAOP_DESTROYGROUP:
						DPL(0, "Dropping player got DESTROY_GROUP that may or may not have sneaked in.", 0);
					  break;

					default:
						DPL(0, "Got unexpected DPN_MSGID_DESTROY_GROUP (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
							2, pDestroyGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					  break;
				} // end switch (on group/data operation)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_DESTROYGROUP)
				{
					DPL(0, "Got unexpected DPN_MSGID_DESTROY_GROUP (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pDestroyGroupMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


			// Check for duplicates and invalid group IDs.
			if (pDestroyGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPL(0, "Getting duplicate or wrong DPN_MSGID_DESTROY_GROUP (group ID %u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					4 ,pDestroyGroupMsg->dpnidGroup,
					pDestroyGroupMsg->dpnidGroup,
					pContext->dpnidGroup,
					pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is unexpected)

			pContext->dpnidGroup = 0;


			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(1, "Not setting event after DESTROY_GROUP, async op completion should trigger for group/data operating player (tester %i).",
					1, pContext->pTNecd->iTesterNum);
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected DESTROY_GROUP on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			if (pContext->hPlayersGoneEvent == NULL)
			{
				DPL(0, "WARNING: Ignoring DPN_MSGID_DESTROY_PLAYER message because no PlayersGone event, this had better be because of a test failure!", 0);
			} // end if (no players gone event)
			else
			{
				// If we're a dropping player, then we should be seeing all the
				// players be removed from the session.  If not, just the dropping
				// players should be going away.
				if (pContext->fDroppingPlayer)
				{
					fFound = FALSE;

					// Lookup this ID in the list of testers' player IDs.
					for(iTesterNum = 0; iTesterNum <= pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// If we're not waiting for our local player to disconnect,
						// and this is currently our tester number, skip it.
						if ((! pContext->fSelfIndicate) &&
							(iTesterNum == pContext->pTNecd->iTesterNum))
						{
							continue;
						} // end if (won't wait for self to disconnect and this is self)


						// If we found the tester ID...
						if (pContext->padpnidTesters[iTesterNum] == pDestroyPlayerMsg->dpnidPlayer)
						{
							// If that player already disconnected, something's
							// wrong.
							if (pContext->pafTesterIndicated[iTesterNum])
							{
								DPL(0, "Got duplicate DESTROY_PLAYER for tester %i (player ID %u/%x)!  DEBUGBREAK()-ing.",
									3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
									pDestroyPlayerMsg->dpnidPlayer);

								//Ignore error
								pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																"Got duplicate DESTROY_PLAYER for tester %i!",
																1, iTesterNum);

								DEBUGBREAK();

								hr = E_FAIL;
								goto DONE;
							} // end if (player already connected)

							// Mark him as disconnected now.
							pContext->pafTesterIndicated[iTesterNum] = TRUE;

							DPL(1, "Tester %i (player ID %u/%x) has disconnected.",
								3, iTesterNum, pDestroyPlayerMsg->dpnidPlayer,
								pDestroyPlayerMsg->dpnidPlayer);

							fFound = TRUE;
							break;
						} // end if (found)
					} // end for (each tester who's already joined)


					// If we didn't recognize that player ID, we're screwed.
					if (! fFound)
					{
						DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x!  DEBUGBREAK()-ing.",
							2, pDestroyPlayerMsg->dpnidPlayer,
							pDestroyPlayerMsg->dpnidPlayer);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
														2, pDestroyPlayerMsg->dpnidPlayer,
														pDestroyPlayerMsg->dpnidPlayer);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (didn't find player ID)


					// See if that's the last person we're waiting on to disconnect.
					for(iTesterNum = 0; iTesterNum < pContext->pTNecd->iNumMachines; iTesterNum++)
					{
						// If we're not waiting for our local player to disconnect,
						// and this is currently our tester number, skip it.
						if ((! pContext->fSelfIndicate) &&
							(iTesterNum == pContext->pTNecd->iTesterNum))
						{
							continue;
						} // end if (won't wait for self to disconnect and this is self)


						if (! pContext->pafTesterIndicated[iTesterNum])
						{
							DPL(4, "Still expecting tester %i to disconnect, not notifying main thread.",
								1, iTesterNum);
							// No sense in looking further, just return OK.
							goto DONE;
						} // end if (tester hasn't connected yet)
					} // end for (each tester who's already joined)
				} // end if (current leaving host)
				else
				{
					// Make sure the leaving player is the old host.
					if (pDestroyPlayerMsg->dpnidPlayer != pContext->padpnidTesters[pContext->iCurrentHost])
					{
						if (pContext->fSecondInCommandCase)
						{
							if (pDestroyPlayerMsg->dpnidPlayer != pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines])
							{
								DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x (leaving host (tester %i) is ID %u/%x, second in command (tester %i) is ID %u/%x)!  DEBUGBREAK()-ing.",
									8, pDestroyPlayerMsg->dpnidPlayer,
									pDestroyPlayerMsg->dpnidPlayer,
									pContext->iCurrentHost,
									pContext->padpnidTesters[pContext->iCurrentHost],
									pContext->padpnidTesters[pContext->iCurrentHost],
									((pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines),
									pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
									pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines]);

								//Ignore error
								pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
																2, pDestroyPlayerMsg->dpnidPlayer,
																pDestroyPlayerMsg->dpnidPlayer);

								DEBUGBREAK();

								hr = E_FAIL;
								goto DONE;
							} // end if (leaving player isn't second in command)
							else
							{
								if (pContext->pafTesterIndicated[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines])
								{
									DPL(0, "Got duplicate DESTROY_PLAYER for second-in-command tester %i, player ID %u/%x!  DEBUGBREAK()-ing.",
										3, ((pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines),
										pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
										pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines]);

									//Ignore error
									pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
																	"Got duplicate DESTROY_PLAYER for second-in-command tester (ID %u/%x)!",
																	2, pDestroyPlayerMsg->dpnidPlayer,
																	pDestroyPlayerMsg->dpnidPlayer);

									DEBUGBREAK();

									hr = E_FAIL;
									goto DONE;
								} // end if (tester already disconnected)

								// Mark second-in-command as disconnected now.
								pContext->pafTesterIndicated[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines] = TRUE;

								if (! pContext->pafTesterIndicated[pContext->iCurrentHost])
								{
									DPL(4, "Still expecting host (tester %i) to disconnect, not notifying main thread.",
										1, pContext->iCurrentHost);
									goto DONE;
								} // end if (tester hasn't connected yet)
							} // end else (leaving player is host)
						} // end if (second in command case)
						else
						{
							DPL(0, "Got DESTROY_PLAYER for unexpected player ID %u/%x (leaving host (tester %i) is ID %u/%x)!  DEBUGBREAK()-ing",
								5, pDestroyPlayerMsg->dpnidPlayer,
								pDestroyPlayerMsg->dpnidPlayer,
								pContext->iCurrentHost,
								pContext->padpnidTesters[pContext->iCurrentHost],
								pContext->padpnidTesters[pContext->iCurrentHost]);

							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
															"Got DESTROY_PLAYER for unexpected player ID %u/%x!",
															2, pDestroyPlayerMsg->dpnidPlayer,
															pDestroyPlayerMsg->dpnidPlayer);

							DEBUGBREAK();

							hr = E_FAIL;
							goto DONE;
						} // end else (not second in command case)
					} // end if (leaving player isn't host)
					else
					{
						if (pContext->pafTesterIndicated[pContext->iCurrentHost])
						{
							DPL(0, "Got duplicate DESTROY_PLAYER for original host tester %i, player ID %u/%x!  DEBUGBREAK()-ing.",
								3, pContext->iCurrentHost,
								pContext->padpnidTesters[pContext->iCurrentHost],
								pContext->padpnidTesters[pContext->iCurrentHost]);

							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
															"Got duplicate DESTROY_PLAYER for original host tester (ID %u/%x)!",
															2, pDestroyPlayerMsg->dpnidPlayer,
															pDestroyPlayerMsg->dpnidPlayer);

							DEBUGBREAK();

							hr = E_FAIL;
							goto DONE;
						} // end if (tester already disconnected)

						// Mark original host as disconnected now.
						pContext->pafTesterIndicated[pContext->iCurrentHost] = TRUE;

						if ((pContext->fSecondInCommandCase) &&
							(! pContext->pafTesterIndicated[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines]))
						{
							DPL(4, "Still expecting second in command (tester %i) to disconnect, not notifying main thread.",
								1, (pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines);
							goto DONE;
						} // end if (tester hasn't connected yet)
					} // end else (leaving player is host)
				} // end else (not current leaving host)



				DPL(2, "All testers expected to disconnect actually have, notifying main thread.", 0);

				if (! SetEvent(pContext->hPlayersGoneEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set PlayersGone event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hPlayersGoneEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set players gone event)
			} // end else (players gone event)
		  break;

		case DPN_MSGID_GROUP_INFO:
			PDPNMSG_GROUP_INFO	pGroupInfoMsg;


			pGroupInfoMsg = (PDPNMSG_GROUP_INFO) pvMsg;

			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				if (pContext->iGroupOrDataOperation == GROUPORDATAOP_SETGROUPINFO)
				{
					DPL(0, "GROUP_INFO sneaked in while we were leaving session.", 0);
				} // end if (setting peer info)
				else
				{
					DPL(0, "Got unexpected DPN_MSGID_GROUP_INFO (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pGroupInfoMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end else (some other group/data operation)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_SETGROUPINFO)
				{
					DPL(0, "Got unexpected DPN_MSGID_GROUP_INFO (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pGroupInfoMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


			// Validate the message
			if (pGroupInfoMsg->dwSize != sizeof (DPNMSG_GROUP_INFO))
			{
				DPL(0, "Group info indication structure size is wrong (%u != %u)!  DEBUGBREAK()-ing!",
					2, pGroupInfoMsg->dwSize, sizeof (DPNMSG_GROUP_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (structure size wrong)

			if (pGroupInfoMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPL(0, "Group info ID is wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					2, pGroupInfoMsg->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)


			// Check for duplicates.
			if (pContext->fGroupInfoSet)
			{
				DPL(0, "Getting duplicate DPN_MSGID_GROUP_INFO (%x)!  DEBUGBREAK()-ing!",
					1, pGroupInfoMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already got info)

			pContext->fGroupInfoSet = TRUE;



			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(1, "Not setting event after GROUP_INFO, async op completion should trigger for group/data operating player (tester %i).",
					1, pContext->pTNecd->iTesterNum);
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected GROUP_INFO on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		case DPN_MSGID_HOST_MIGRATE:
			PDPNMSG_HOST_MIGRATE	pHostMigrateMsg;


			pHostMigrateMsg = (PDPNMSG_HOST_MIGRATE) pvMsg;

			if (pContext->hHostMigratedEvent == NULL)
			{
				DPL(0, "WARNING: Ignoring DPN_MSGID_HOST_MIGRATE message because no HostMigrated event, this had better be because of a test failure!", 0);
			} // end if (host migrated event)
			else
			{
				if (pContext->fSecondInCommandCase)
				{
					if (pHostMigrateMsg->dpnidNewHost != pContext->padpnidTesters[(pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines])
					{
						if (pHostMigrateMsg->dpnidNewHost != pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines])
						{
							DPL(0, "Host didn't migrate to either expected machine (old second in command tester %i, player ID %u/%x, new host tester %i, player ID %u/%x), it migrated to player ID %u/%x!  DEBUGBREAK()-ing.",
								8, (pContext->iCurrentHost + 1),
								pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
								pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
								(pContext->iCurrentHost + 2),
								pContext->padpnidTesters[(pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines],
								pContext->padpnidTesters[(pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines],
								pHostMigrateMsg->dpnidNewHost,
								pHostMigrateMsg->dpnidNewHost);

							//Ignore error
							pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
															"Host didn't migrate to either expected machine!  DEBUGBREAK()-ing.",
															0);

							DEBUGBREAK();

							hr = E_FAIL;
							goto DONE;
						} // end if (host didn't migrate to second in command)
						else
						{
#pragma TODO(vanceo, "Make sure real comes after old second in command")

							DPL(0, "WARNING: Host migrated to old second in command (tester %i, player ID %u/%x) it had better not have already migrated to the real new host (tester %i, player ID %u/%x), but should do it next!",
								6, (pContext->iCurrentHost + 1),
								pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
								pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
								(pContext->iCurrentHost + 2),
								pContext->padpnidTesters[(pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines],
								pContext->padpnidTesters[(pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines]);

							// We're going to ignore it.
							goto DONE;
						} // end else (host did migrate to second in command)
					} // end if (host didn't migrate to expected machine)

#pragma TODO(vanceo, "Check for dupes")

					DPL(1, "Host migrated to tester %i (player ID %u/%x) as expected.",
						3, ((pContext->iCurrentHost + 2) % pContext->pTNecd->iNumMachines),
						pHostMigrateMsg->dpnidNewHost,
						pHostMigrateMsg->dpnidNewHost);
				} // end if (second in command case)
				else
				{
					if (pHostMigrateMsg->dpnidNewHost != pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines])
					{
						DPL(0, "Host didn't migrate to expected machine (tester %i, player ID %u/%x), it migrated to player ID %u/%x!  DEBUGBREAK()-ing.",
							5, (pContext->iCurrentHost + 1),
							pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
							pContext->padpnidTesters[(pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines],
							pHostMigrateMsg->dpnidNewHost,
							pHostMigrateMsg->dpnidNewHost);

						//Ignore error
						pContext->pTNecd->pExecutor->Log(TNLF_CRITICAL | TNLF_PREFIX_TESTUNIQUEID,
														"Host didn't migrate to expected machine!  DEBUGBREAK()-ing.",
														0);

						DEBUGBREAK();

						hr = E_FAIL;
						goto DONE;
					} // end if (host didn't migrate to expected player)

#pragma TODO(vanceo, "Check for dupes")

					DPL(1, "Host migrated to tester %i (player ID %u/%x) as expected.",
						3, ((pContext->iCurrentHost + 1) % pContext->pTNecd->iNumMachines),
						pHostMigrateMsg->dpnidNewHost,
						pHostMigrateMsg->dpnidNewHost);
				} // end else (not second in command case)


				if (! SetEvent(pContext->hHostMigratedEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set HostMigrated event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hHostMigratedEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set host migration event)
			} // end else (host migrated event)
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			/*
			DPL(0, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPL(0, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPL(0, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPL(0, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPL(0, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPL(0, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPL(0, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPL(0, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPL(0, "    pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			DPL(0, "    pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);
			*/

#pragma TODO(vanceo, "Validate this")
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			if (pReceiveMsg->dwReceiveDataSize < (strlen("Reliable send string") + 1))
			{
				DPL(0, "Received data (%x) that was too small (size = %u < %u)!  DEBUGBREAK()-ing",
					3, pReceiveMsg->pReceiveData,
					pReceiveMsg->dwReceiveDataSize,
					(strlen("Reliable send string") + 1));

				DEBUGBREAK();
			} // end if (too small data)
			else if (pReceiveMsg->dwReceiveDataSize > (strlen("Unreliable send string") + 1))
			{
				DPL(0, "Received data (%x) that was too large (size = %u)!  DEBUGBREAK()-ing",
					3, pReceiveMsg->pReceiveData,
					pReceiveMsg->dwReceiveDataSize,
					(strlen("Unreliable send string") + 1));

				DEBUGBREAK();
			} // end if (too large data)
			else
			{
				if (memcmp(pReceiveMsg->pReceiveData, "Unreliable send string", (strlen("Unreliable send string") + 1)) == 0)
				{
					DPL(9, "Received unreliable message from player %u/%x.",
						2, pReceiveMsg->dpnidSender,
						pReceiveMsg->dpnidSender);
				} // end if (unreliable message)
				else if (memcmp(pReceiveMsg->pReceiveData, "Reliable send string", (strlen("Reliable send string") + 1)) == 0)
				{
					DPL(9, "Received reliable message (received approximately %i already) from player %u/%x.",
						3, *((int*) pReceiveMsg->pvPlayerContext),
						pReceiveMsg->dpnidSender,
						pReceiveMsg->dpnidSender);

					// The player context is a pointer to the tester's entry in the
					// num reliable messages received array.  Update it.
					(*((int*) pReceiveMsg->pvPlayerContext))++;
				} // end else if (reliable message)
				else
				{
					DPL(0, "Received invalid data (at %x, size = %u)!  DEBUGBREAK()-ing",
						2, pReceiveMsg->pReceiveData,
						pReceiveMsg->dwReceiveDataSize);

					DEBUGBREAK();
				} // end else (incorrect message)
			} // end else (data is of valid size)
		  break;

		case DPN_MSGID_REMOVE_PLAYER_FROM_GROUP:
			PDPNMSG_REMOVE_PLAYER_FROM_GROUP	pRemovePlayerFromGroupMsg;


			pRemovePlayerFromGroupMsg = (PDPNMSG_REMOVE_PLAYER_FROM_GROUP) pvMsg;

			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				switch (pContext->iGroupOrDataOperation)
				{
					case GROUPORDATAOP_ADDPLAYERTOGROUP:
						DPL(0, "Got REMOVE_PLAYER_FROM_GROUP, assuming it's for an ADD_PLAYER_TO_GROUP that sneaked in or we're destroying the DPlay8 session.", 0);
					  break;

					case GROUPORDATAOP_REMOVEPLAYERFROMGROUP:
						DPL(0, "Dropping player got REMOVE_PLAYER_FROM_GROUP that may or may not have sneaked in.", 0);
					  break;

					default:
						DPL(0, "Got unexpected DPN_MSGID_REMOVE_PLAYER_FROM_GROUP (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
							2, pRemovePlayerFromGroupMsg, pContext->iGroupOrDataOperation);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					  break;
				} // end switch (on group/data operation)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_REMOVEPLAYERFROMGROUP)
				{
					DPL(0, "Got unexpected DPN_MSGID_REMOVE_PLAYER_FROM_GROUP (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pRemovePlayerFromGroupMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


			// Validate the message
			if (pRemovePlayerFromGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				DPL(0, "Group ID is wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					4, pRemovePlayerFromGroupMsg->dpnidGroup,
					pRemovePlayerFromGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (group ID is wrong)


			// Check for duplicates and invalid player IDs.
			if (pRemovePlayerFromGroupMsg->dpnidPlayer != pContext->dpnidPlayerAddedToGroup)
			{
				DPL(0, "Getting duplicate or wrong DPN_MSGID_REMOVE_PLAYER_FROM_GROUP (group ID %u/%x != %u/%x)!  DEBUGBREAK()-ing!",
					4 ,pRemovePlayerFromGroupMsg->dpnidPlayer,
					pRemovePlayerFromGroupMsg->dpnidPlayer,
					pContext->dpnidPlayerAddedToGroup,
					pContext->dpnidPlayerAddedToGroup);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is unexpected)

			pContext->dpnidPlayerAddedToGroup = 0;


			// Can't detect group ops that sneak in because it may just be the
			// nametable unwinding.
			/*
			if (pContext->fDroppingPlayer)
			{
				DPL(0, "REMOVE_PLAYER_FROM_GROUP sneaked in while we were leaving session.", 0);
			} // end if (dropping player)
			*/


			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				if (pContext->fNoAsyncOpCompletion)
				{
					DPL(0, "No async op completion expected on group/data operating player (tester %i), notifying main thread.",
						1, pContext->pTNecd->iTesterNum);

					if (! SetEvent(pContext->hGroupOrDataOperationEvent))
					{
						hr = GetLastError();

						DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
							2, pContext->hGroupOrDataOperationEvent, hr);

						DEBUGBREAK();

						if (hr == S_OK)
							hr = E_FAIL;
					} // end if (couldn't set event)
				} // end if (no async op completion)
				else
				{
					DPL(1, "Not setting event after REMOVE_PLAYER_FROM_GROUP, async op completion should trigger for group/data operating player (tester %i).",
						1, pContext->pTNecd->iTesterNum);
				} // end if (async op completion still expected)
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected REMOVE_PLAYER_FROM_GROUP on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			DPL(9, "DPN_MSGID_SEND_COMPLETE", 0);
		  break;

		case DPN_MSGID_PEER_INFO:
			PDPNMSG_PEER_INFO	pPeerInfoMsg;


			pPeerInfoMsg = (PDPNMSG_PEER_INFO) pvMsg;

			// Make sure we're supposed to get this message.
			if (pContext->fDroppingPlayer)
			{
				if (pContext->iGroupOrDataOperation == GROUPORDATAOP_SETPEERINFO)
				{
					DPL(0, "PEER_INFO sneaked in while we were leaving session.", 0);
				} // end if (setting peer info)
				else
				{
					DPL(0, "Got unexpected DPN_MSGID_PEER_INFO (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pPeerInfoMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end else (some other group/data operation)
			} // end if (dropping player)
			else
			{
				if (pContext->iGroupOrDataOperation != GROUPORDATAOP_SETPEERINFO)
				{
					DPL(0, "Got unexpected DPN_MSGID_PEER_INFO (msg = %x, group/data op = %i)!  DEBUGBREAK()-ing!",
						2, pPeerInfoMsg, pContext->iGroupOrDataOperation);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (operation unexpected)
			} // end else (not dropping player)


#pragma TODO(vanceo, "Validate the DPN_MSGID_PEER_INFO message")


			// Check for duplicates.
			if (pContext->fPeerInfoSet)
			{
				DPL(0, "Getting duplicate DPN_MSGID_PEER_INFO (%x)!  DEBUGBREAK()-ing!",
					1, pPeerInfoMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already got info)

			pContext->fPeerInfoSet = TRUE;



			// Notify the main thread, if necessary.
			if (pContext->fGroupOrDataOperatingPlayer)
			{
				DPL(1, "Not setting event after PEER_INFO, async op completion should trigger for group/data operating player (tester %i).",
					1, pContext->pTNecd->iTesterNum);
			} // end if (group/data operating player)
			else if (! pContext->fDroppingPlayer)
			{
				DPL(1, "Got expected PEER_INFO on tester %i, notifying main thread.",
					1, pContext->pTNecd->iTesterNum);

				if (! SetEvent(pContext->hGroupOrDataOperationEvent))
				{
					hr = GetLastError();

					DPL(0, "Couldn't set group or data operation event (%x)!  DEBUGBREAK()-ing.  0x%08x",
						2, pContext->hGroupOrDataOperationEvent, hr);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;
				} // end if (couldn't set event)
			} // end else if (not group/data operating or dropping player)
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	SAFE_LOCALFREE(pdpnpi);

	return (hr);
} // HostMigrateDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\multissn.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <mmsystem.h>

#include "..\..\..\tncommon\debugprint.h"
#include "..\..\..\tncommon\cppobjhelp.h"
#include "..\..\..\tncommon\linklist.h"
#include "..\..\..\tncommon\linkedstr.h"
#include "..\..\..\tncommon\strutils.h"
#include "..\..\..\tncommon\sprintf.h"

#include "..\..\..\tncontrl\tncontrl.h"


#include "..\main.h"

#include "..\bldssn\blddp8.h"

#include "multissn.h"




#pragma TODO(vanceo, "Make this input data")
#define NUM_SESSIONS_TO_HOST	2





//==================================================================================
// Prototypes
//==================================================================================
HRESULT MultiSsnCanRun_All(PTNCANRUNDATA pTNcrd);

HRESULT MultiSsnExec_SimplePeer(PTNEXECCASEDATA pTNecd);
HRESULT MultiSsnExec_SimpleCS(PTNEXECCASEDATA pTNecd);

HRESULT MultiSsnDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);






#undef DEBUG_SECTION
#define DEBUG_SECTION	"MultiSsnLoadTestTable()"
//==================================================================================
// MultiSsnLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.6			Multiple sessions tests
//				2.6.1		Simple peer-to-peer multiple sessions test
//				2.6.2		Simple client/server multiple sessions test
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT MultiSsnLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.6		Multiple sessions tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase, "2.6", "Multiple sessions tests", &pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.6.1	Simple peer-to-peer multiple sessions test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.6.1";
	tnatd.pszName			= "Simple peer-to-peer multiple sessions test";
	tnatd.pszDescription	= "Simple peer-to-peer multiple sessions test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= MultiSsnCanRun_All;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= MultiSsnExec_SimplePeer;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.6.2	Simple client/server multiple sessions test
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.6.2";
	tnatd.pszName			= "Simple client/server multiple sessions test";
	tnatd.pszDescription	= "Simple client/server multiple sessions test";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 2;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST
								| TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= MultiSsnCanRun_All;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= MultiSsnExec_SimpleCS;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);


	return (S_OK);
} // MultiSsnLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"MultiSsnCanRun_All()"
//==================================================================================
// MultiSsnCanRun_All
//----------------------------------------------------------------------------------
//
// Description: Callback that checks a possible tester list to make sure the test
//				can be run correctly for the following test case(s):
//				2.6.1 - Simple peer-to-peer multiple sessions test
//				2.6.2 - Simple client/server multiple sessions test
//
// Arguments:
//	PTNCANRUNDATA pTNcrd	Pointer to parameter block with information on what
//							configuration to check.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT MultiSsnCanRun_All(PTNCANRUNDATA pTNcrd)
{
	HRESULT		hr;
	int			i;
	int			j;


	// Make sure all the subsequent testers can connect to the first.
	for(i = 0; i < pTNcrd->iNumMachines; i++)
	{
		for(j = 0; j < pTNcrd->iNumMachines; j++)
		{
			// Nobody needs to connect to himself, so skip the check.
			if (j == i)
				continue;

			if (pTNcrd->pMaster->AreOnSameMachine(pTNcrd->apTesters[i],
												pTNcrd->apTesters[j]))
			{
				DPL(1, "Tester %i is on same machine as tester %i (%s), assuming can reach via UDP.",
					3, i, j, pTNcrd->apTesters[i]->m_szComputerName);

				pTNcrd->fCanRun = TRUE;
			} // end if (are on same machine)
			else
			{
				hr = pTNcrd->pMaster->CanReachViaIP(pTNcrd->apTesters[i],
													pTNcrd->apTesters[j],
													DPLAY8_PORT,
													TNCR_IP_UDP,
													&(pTNcrd->fCanRun));
				if (hr != S_OK)
				{
					DPL(0, "Couldn't have tester %i (%s) try to reach tester %i (%s) via UDP!",
						4, i, pTNcrd->apTesters[i]->m_szComputerName,
						j, pTNcrd->apTesters[j]->m_szComputerName);

					return (hr);
				} // end if (couldn't test reachability)

				if (! pTNcrd->fCanRun)
				{
					DPL(1, "Tester %i (%s) can't reach tester %i (%s) via UDP.",
						4, i, pTNcrd->apTesters[i]->m_szComputerName,
						j, pTNcrd->apTesters[0]->m_szComputerName);

					return (S_OK);
				} // end if (current tester couldn't reach tester 0)
			} // end else (not on same machine)
		} // end for (each tester)
	} // end for (each tester)


	return (S_OK);
} // MultiSsnCanRun_All
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"MultiSsnExec_SimplePeer()"
//==================================================================================
// MultiSsnExec_SimplePeer
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.6.1 - Simple peer-to-peer multiple sessions test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT MultiSsnExec_SimplePeer(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PTOD_BBLDDP8_PEER_CREATE		pBldDP8PeerCreateOutput = NULL;
	DWORD							dwSubOutputDataSize;
	BLDDP8DPNHANDLERCONTEXTHEADER	context;
	DPN_APPLICATION_DESC			dpnad;
	PVOID*							papvDP8Objects = NULL;
	DPNID**							papadpnidTesters = NULL;
	int*							paiTesters = NULL;
	int								i;
	int								j;



	BEGIN_TESTCASE
	{
		// Allocate the arrays to hold pointers to all the objects we'll generate.
		LOCALALLOC_OR_THROW(PVOID*, papvDP8Objects,
							NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines * sizeof (PVOID));

		LOCALALLOC_OR_THROW(DPNID**, papadpnidTesters,
							NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines * sizeof (DPNID*));

		// Allocate an array that will hold the tester numbers in varying orders
		// for each particular session.
		LOCALALLOC_OR_THROW(int*, paiTesters,
							pTNecd->iNumMachines * sizeof (int));




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating sessions");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			// Set the tester number order for this particular session.
			for(j = 0; j < pTNecd->iNumMachines; j++)
			{
				paiTesters[j] = (i + j) % pTNecd->iNumMachines;
			} // end for (each tester)


			DPL(0, "Creating peer-to-peer session %i (will %s).",
				2, i,
				(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "join"));

			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Creating peer session %i (will %s).",
									2, i,
									(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "join"));

			ZeroMemory(&context, sizeof (BLDDP8DPNHANDLERCONTEXTHEADER));
			context.pfnDPNMessageHandler = MultiSsnDPNMessageHandler;

			ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
			dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
			dpnad.dwFlags = 0;
			//dpnad.guidInstance = GUID_NULL;
			dpnad.guidApplication = GUID_MULTISSN_SIMPLE_PEER;
			//dpnad.dwMaxPlayers = 0;
			//dpnad.dwCurrentPlayers = 0;
			dpnad.pwszSessionName = L"Session";
			//dpnad.pwszPassword = NULL;
			//dpnad.pvReservedData = NULL;
			//dpnad.dwReservedDataSize = 0;
			//dpnad.pvApplicationReservedData = NULL;
			//dpnad.pvApplicationReservedData = 0;


			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_ALL_CREATE));
#pragma TODO(vanceo, "Allow SP to be selected")
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.1.1",
														pvSubInputData,
														sizeof (TID_BBLDDP8_ALL_CREATE),
														pTNecd->iNumMachines,
														paiTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:Create!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)


			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.1",
										"Creating peer-to-peer session failed!");

			// Otherwise get the object created.
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8PeerCreateOutput,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_PEER_CREATE) + (pTNecd->iNumMachines * sizeof (DPNID))));

			// We're using it during this function, so add a ref.
			pBldDP8PeerCreateOutput->pDP8Peer->m_dwRefCount++;
			papvDP8Objects[i] = pBldDP8PeerCreateOutput->pDP8Peer;

			papadpnidTesters[i] = (DPNID*) (pBldDP8PeerCreateOutput + 1);
		} // end for (each session)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Ready to close", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying sessions");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			// Set the tester number order for this particular session.
			for(j = 0; j < pTNecd->iNumMachines; j++)
			{
				paiTesters[j] = (i + j) % pTNecd->iNumMachines;
			} // end for (each tester)



			DPL(0, "Destroying peer-to-peer session %i (was %s).",
				2, i,
				(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "joiner"));

			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Destroying peer-to-peer session %i (was %s).",
									2, i,
									(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "joiner"));


			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_PEER_DESTROY));
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pDP8Peer = (PWRAPDP8PEER) papvDP8Objects[i];
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_PEER_DESTROY) pvSubInputData)->padpnidTesters = papadpnidTesters[i];

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.1.2",
														pvSubInputData,
														sizeof (TID_BBLDDP8_PEER_DESTROY),
														pTNecd->iNumMachines,
														paiTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:BldPeer:Destroy!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.1.2",
										"Destroying peer-to-peer session failed!");



			((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount--;
			if (((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount == 0)
			{
				DPL(7, "Deleting peer wrapper object %i (%x).",
					2, i, papvDP8Objects[i]);
				delete ((PWRAPDP8PEER) papvDP8Objects[i]);
			} // end if (can delete the object)
			else
			{
				DPL(0, "WARNING: Can't delete peer wrapper object %i (%x), it's refcount is %u!?",
					3, i, papvDP8Objects[i],
					((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount);
			} // end else (can't delete the object)
			papvDP8Objects[i] = NULL;
		} // end for (each session)


		LocalFree(papvDP8Objects);
		papvDP8Objects = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE



	SAFE_LOCALFREE(pvSubInputData);
	SAFE_LOCALFREE(papadpnidTesters);
	SAFE_LOCALFREE(paiTesters);

	if (papvDP8Objects != NULL)
	{
		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			if (papvDP8Objects[i] != NULL)
			{
				temphr = ((PWRAPDP8PEER) papvDP8Objects[i])->DP8P_Close(0);
				if (temphr != DPN_OK)
				{
					DPL(0, "Closing peer interface %i failed!  0x%08x", 2, i, temphr);
					OVERWRITE_SR_IF_OK(temphr);
				} // end if (closing peer interface failed)


				// Ignore error, it may not actually be on the list.
				g_pDP8PeersList->RemoveFirstReference((PWRAPDP8PEER) papvDP8Objects[i]);


				((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount--;
				if (((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount == 0)
				{
					DPL(7, "Deleting peer wrapper object %i (%x).",
						2, i, papvDP8Objects[i]);
					delete ((PWRAPDP8PEER) papvDP8Objects[i]);
				} // end if (can delete the object)
				else
				{
					DPL(0, "WARNING: Can't delete peer wrapper object %i (%x), it's refcount is %u!?",
						3, i, papvDP8Objects[i],
						((PWRAPDP8PEER) papvDP8Objects[i])->m_dwRefCount);
				} // end else (can't delete the object)

				papvDP8Objects[i] = NULL;
			} // end if (have object)
		} // end for (each session)

		LocalFree(papvDP8Objects);
		papvDP8Objects = NULL;
	} // end if (there are sessions possibly)

	return (sr);
} // MultiSsnExec_SimplePeer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"MultiSsnExec_SimpleCS()"
//==================================================================================
// MultiSsnExec_SimpleCS
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.6.2 - Simple client/server multiple sessions test
//
// Arguments:
//	PTNEXECCASEDATA pTNecd	Pointer to structure with parameters for test case.
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT MultiSsnExec_SimpleCS(PTNEXECCASEDATA pTNecd)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	HRESULT							temphr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PTOD_BBLDDP8_CS_CREATE_0		pBldDP8CSCreateOutput0 = NULL;
	PTOD_BBLDDP8_CS_CREATE_NOT0		pBldDP8CSCreateOutputNot0 = NULL;
	DWORD							dwSubOutputDataSize;
	BLDDP8DPNHANDLERCONTEXTHEADER	context;
	DPN_APPLICATION_DESC			dpnad;
	PVOID*							papvDP8Objects = NULL;
	DPNID**							papadpnidTesters = NULL;
	int*							paiTesters = NULL;
	BOOL							fClientServer = FALSE;
	int								i;
	int								j;



	BEGIN_TESTCASE
	{
		// Allocate the arrays to hold pointers to all the objects we'll generate.
		LOCALALLOC_OR_THROW(PVOID*, papvDP8Objects,
							NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines * sizeof (PVOID));

		LOCALALLOC_OR_THROW(DPNID**, papadpnidTesters,
							NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines * sizeof (DPNID*));

		// Allocate an array that will hold the tester numbers in varying orders
		// for each particular session.
		LOCALALLOC_OR_THROW(int*, paiTesters,
							pTNecd->iNumMachines * sizeof (int));



		if (pTNecd->pExecutor->IsCase("2.6.2"))
			fClientServer = TRUE;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating sessions");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			// Set the tester number order for this particular session.
			for(j = 0; j < pTNecd->iNumMachines; j++)
			{
				paiTesters[j] = (i + j) % pTNecd->iNumMachines;
			} // end for (each tester)


			DPL(0, "Creating client/server session %i (will %s).",
				2, i,
				(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "join"));

			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Creating client/server session %i (will %s).",
									2, i,
									(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "join"));

			ZeroMemory(&context, sizeof (BLDDP8DPNHANDLERCONTEXTHEADER));
			context.pfnDPNMessageHandler = MultiSsnDPNMessageHandler;

			ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
			dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
			dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
			//dpnad.guidInstance = GUID_NULL;
			dpnad.guidApplication = GUID_MULTISSN_SIMPLE_CS;
			//dpnad.dwMaxPlayers = 0;
			//dpnad.dwCurrentPlayers = 0;
			dpnad.pwszSessionName = L"Session";
			//dpnad.pwszPassword = NULL;
			//dpnad.pvReservedData = NULL;
			//dpnad.dwReservedDataSize = 0;
			//dpnad.pvApplicationReservedData = NULL;
			//dpnad.pvApplicationReservedData = 0;


			LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_ALL_CREATE));
#pragma TODO(vanceo, "Allow SP to be selected")
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->guidSP = CLSID_DP8SP_TCPIP;
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pHandlerContext = &context;
			((PTID_BBLDDP8_ALL_CREATE) pvSubInputData)->pdpnad = &dpnad;

			sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.2.1",
														pvSubInputData,
														sizeof (TID_BBLDDP8_ALL_CREATE),
														pTNecd->iNumMachines,
														paiTesters);

			LocalFree(pvSubInputData);
			pvSubInputData = NULL;

			if (sr != S_OK)
			{
				DPL(0, "Couldn't execute sub test case BldSsn:Create!", 0);
				THROW_SYSTEMRESULT;
			} // end if (failed executing sub test case)

			GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.1",
										"Creating client/server session failed!");

			// Otherwise get the object created.
			CHECKANDGET_SUBOUTPUTDATA(pSubResult,
										pBldDP8CSCreateOutput0,
										dwSubOutputDataSize,
										(sizeof (TOD_BBLDDP8_PEER_CREATE) + (pTNecd->iNumMachines * sizeof (DPNID))));

			if ((i % pTNecd->iNumMachines) == pTNecd->iTesterNum)
			{
				// We're using it during this function, so add a ref.
				pBldDP8CSCreateOutput0->pDP8Server->m_dwRefCount++;
				papvDP8Objects[i] = pBldDP8CSCreateOutput0->pDP8Server;

				papadpnidTesters[i] = (DPNID*) (pBldDP8CSCreateOutput0 + 1);
			} // end if (server)
			else
			{
				pBldDP8CSCreateOutputNot0 = (PTOD_BBLDDP8_CS_CREATE_NOT0) pBldDP8CSCreateOutput0;

				// We're using it during this function, so add a ref.
				pBldDP8CSCreateOutputNot0->pDP8Client->m_dwRefCount++;
				papvDP8Objects[i] = pBldDP8CSCreateOutputNot0->pDP8Client;

				papadpnidTesters[i] = (DPNID*) (pBldDP8CSCreateOutputNot0 + 1);
			} // end else (client)
		} // end for (each session)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for everyone to be ready to close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->SyncWithTesters("Ready to close", NULL, 0, NULL, 0);
		HANDLE_SYNC_RESULT;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Destroying sessions");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			// Set the tester number order for this particular session.
			for(j = 0; j < pTNecd->iNumMachines; j++)
			{
				paiTesters[j] = (i + j) % pTNecd->iNumMachines;
			} // end for (each tester)



			DPL(0, "Destroying client/server session %i (was %s).",
				2, i,
				(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "joiner"));

			pTNecd->pExecutor->Log(TNLF_VERBOSE | TNLF_PREFIX_TESTUNIQUEID,
									"Destroying client/server session %i (was %s).",
									2, i,
									(((i % pTNecd->iNumMachines) == pTNecd->iTesterNum) ? "host" : "joiner"));


			if ((i % pTNecd->iNumMachines) == pTNecd->iTesterNum)
			{
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_CS_DESTROY_0));
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pDP8Server = (PWRAPDP8SERVER) papvDP8Objects[i];
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->pHandlerContext = &context;
				((PTID_BBLDDP8_CS_DESTROY_0) pvSubInputData)->padpnidTesters = papadpnidTesters[i];

				sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.2.2",
															pvSubInputData,
															sizeof (TID_BBLDDP8_CS_DESTROY_0),
															pTNecd->iNumMachines,
															paiTesters);

				LocalFree(pvSubInputData);
				pvSubInputData = NULL;

				if (sr != S_OK)
				{
					DPL(0, "Couldn't execute sub test case BldSsn:BldCS:Destroy!", 0);
					THROW_SYSTEMRESULT;
				} // end if (failed executing sub test case)

				GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.2",
											"Destroying client/server session failed!");



				((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount--;
				if (((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount == 0)
				{
					DPL(7, "Deleting server wrapper object %i (%x).",
						2, i, papvDP8Objects[i]);
					delete ((PWRAPDP8SERVER) papvDP8Objects[i]);
				} // end if (can delete the object)
				else
				{
					DPL(0, "WARNING: Can't delete server wrapper object %i (%x), it's refcount is %u!?",
						3, i, papvDP8Objects[i],
						((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount);
				} // end else (can't delete the object)
				papvDP8Objects[i] = NULL;
			} // end if (server)
			else
			{
				LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_BBLDDP8_CS_DESTROY_NOT0));
				((PTID_BBLDDP8_CS_DESTROY_NOT0) pvSubInputData)->pDP8Client = (PWRAPDP8CLIENT) papvDP8Objects[i];

				sr = pTNecd->pExecutor->ExecSubTestCaseArray("3.1.2.2",
															pvSubInputData,
															sizeof (TID_BBLDDP8_CS_DESTROY_NOT0),
															pTNecd->iNumMachines,
															paiTesters);

				LocalFree(pvSubInputData);
				pvSubInputData = NULL;

				if (sr != S_OK)
				{
					DPL(0, "Couldn't execute sub test case BldSsn:BldCS:Destroy!", 0);
					THROW_SYSTEMRESULT;
				} // end if (failed executing sub test case)

				GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "3.1.2.2",
											"Destroying client/server session failed!");



				((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount--;
				if (((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount == 0)
				{
					DPL(7, "Deleting client wrapper object %i (%x).",
						2, i, papvDP8Objects[i]);
					delete ((PWRAPDP8CLIENT) papvDP8Objects[i]);
				} // end if (can delete the object)
				else
				{
					DPL(0, "WARNING: Can't delete client wrapper object %i (%x), it's refcount is %u!?",
						3, i, papvDP8Objects[i],
						((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount);
				} // end else (can't delete the object)
				papvDP8Objects[i] = NULL;
			} // end else (client)
		} // end for (each session)


		LocalFree(papvDP8Objects);
		papvDP8Objects = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE



	SAFE_LOCALFREE(pvSubInputData);
	SAFE_LOCALFREE(papadpnidTesters);
	SAFE_LOCALFREE(paiTesters);

	if (papvDP8Objects != NULL)
	{
		for(i = 0; i < NUM_SESSIONS_TO_HOST * pTNecd->iNumMachines; i++)
		{
			if (papvDP8Objects[i] != NULL)
			{
				if ((i % pTNecd->iNumMachines) == pTNecd->iTesterNum)
				{
					temphr = ((PWRAPDP8SERVER) papvDP8Objects[i])->DP8S_Close(0);
					if (temphr != DPN_OK)
					{
						DPL(0, "Closing server interface %i failed!  0x%08x", 2, i, temphr);
						OVERWRITE_SR_IF_OK(temphr);
					} // end if (closing server interface failed)


					// Ignore error, it may not actually be on the list.
					g_pDP8ServersList->RemoveFirstReference((PWRAPDP8SERVER) papvDP8Objects[i]);


					((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount--;
					if (((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount == 0)
					{
						DPL(7, "Deleting server wrapper object %i (%x).",
							2, i, papvDP8Objects[i]);
						delete ((PWRAPDP8SERVER) papvDP8Objects[i]);
					} // end if (can delete the object)
					else
					{
						DPL(0, "WARNING: Can't delete server wrapper object %i (%x), it's refcount is %u!?",
							3, i, papvDP8Objects[i],
							((PWRAPDP8SERVER) papvDP8Objects[i])->m_dwRefCount);
					} // end else (can't delete the object)
				} // end if (server)
				else
				{
					temphr = ((PWRAPDP8CLIENT) papvDP8Objects[i])->DP8C_Close(0);
					if (temphr != DPN_OK)
					{
						DPL(0, "Closing client interface %i failed!  0x%08x", 2, i, temphr);
						OVERWRITE_SR_IF_OK(temphr);
					} // end if (closing client interface failed)


					// Ignore error, it may not actually be on the list.
					g_pDP8ClientsList->RemoveFirstReference((PWRAPDP8CLIENT) papvDP8Objects[i]);


					((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount--;
					if (((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount == 0)
					{
						DPL(7, "Deleting client wrapper object %i (%x).",
							2, i, papvDP8Objects[i]);
						delete ((PWRAPDP8CLIENT) papvDP8Objects[i]);
					} // end if (can delete the object)
					else
					{
						DPL(0, "WARNING: Can't delete client wrapper object %i (%x), it's refcount is %u!?",
							3, i, papvDP8Objects[i],
							((PWRAPDP8CLIENT) papvDP8Objects[i])->m_dwRefCount);
					} // end else (can't delete the object)
				} // end else (client)

				papvDP8Objects[i] = NULL;
			} // end if (have object)
		} // end for (each session)

		LocalFree(papvDP8Objects);
		papvDP8Objects = NULL;
	} // end if (there are sessions possibly)

	return (sr);
} // MultiSsnExec_SimpleCS
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"MultiSsnDPNMessageHandler()"
//==================================================================================
// MultiSsnDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT MultiSsnDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PBLDDP8DPNHANDLERCONTEXTHEADER	pContext = (PBLDDP8DPNHANDLERCONTEXTHEADER) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_DESTROY_PLAYER:
			DPL(0, "WARNING: Ignoring DPN_MSGID_DESTROY_PLAYER message, this had better be because of a test failure!", 0); 
		  break;

		default:
			DPL(0, "Unexpected message type %x!  DEBUGBREAK()-ing.", 1, dwMsgType);

			DEBUGBREAK();

			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
} // MultiSsnDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvalidation.h ===
#ifndef __DNETRSLT_PROCEDURAL_PARMV__
#define __DNETRSLT_PROCEDURAL_PARMV__

#include "wrappeer.h"

namespace DPlayCoreNamespace {


//==================================================================================
// Defines
//==================================================================================

// Makes sure nobody touched the memory when they weren't supposed to.
#define DONT_TOUCH_MEMORY_PATTERN	0xBADAB00F

#define BUFFERPADDING_SIZE			64


#define NONLOCAL_CONTEXT			((PVOID) 0xD00FD00D)







//==================================================================================
// External Prototypes
//==================================================================================
HRESULT ParmVCompareAppDesc(HANDLE hLog,
							PDPN_APPLICATION_DESC pdpnadCompare,
							PDPN_APPLICATION_DESC pdpnadExpected);

HRESULT ParmVCompareGroupInfo(HANDLE hLog,
							  PDPN_GROUP_INFO pdpngiCompare,
							  PDPN_GROUP_INFO pdpngiExpected);

HRESULT ParmVComparePlayerInfo(HANDLE hLog,
							   PDPN_PLAYER_INFO pdpnpiCompare,
							   PDPN_PLAYER_INFO pdpnpiExpected);

HRESULT ParmVCreatePeerHost(HANDLE hLog,
							PFNDPNMESSAGEHANDLER pfn,
							PVOID pvContext,
							PDPN_APPLICATION_DESC pdpnad,
							PVOID pvPlayerContext,
							PWRAPDP8PEER* ppDP8PeerHost,
							PDIRECTPLAY8ADDRESS* ppDP8AddressHost);

HRESULT ParmVCreateAndConnectClient(HANDLE hLog,
									PFNDPNMESSAGEHANDLER pfn,
									PVOID pvContext,
									PWRAPDP8SERVER pDP8Server,
									PDPN_APPLICATION_DESC pdpnad,
									HANDLE hClientCreatedEvent,
									PWRAPDP8CLIENT* ppDP8Client);

HRESULT ParmVCreateServer(HANDLE hLog,
						PFNDPNMESSAGEHANDLER pfn,
						PVOID pvContext,
						PDPN_APPLICATION_DESC pdpnad,
						DPNID* pdpnidPlayerContext,
						PWRAPDP8SERVER* ppDP8Server,
						PDIRECTPLAY8ADDRESS* ppDP8AddressHost);

HRESULT ParmVNoMessagesDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVNewPlayerDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);

BOOL StringCmpAToU(HANDLE hLog, WCHAR* wszUnicodeString, char* szANSIString, BOOL fMatchCase);

VOID ClearDoWorkList(DP_DOWORKLIST *pDoWorkList);

} // namespace DPlayCoreNamespace

#endif //__DNETRSLT_PROCEDURAL_PARMV__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvaddrip.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "wrapbase.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Defines
//==================================================================================

// Makes sure nobody touched the memory when they weren't supposed to.
#define DONT_TOUCH_MEMORY_PATTERN	0xBADAB00F

#define BUFFERPADDING_SIZE			64


//==================================================================================
// Defines
//==================================================================================
#define FAKE_TCPIPADDRESS	L"nonexistentmachine"
#define FAKE_TCPIPADDRESS_A	"nonexistentmachine"

#define LOCALHOSTIP			L"127.0.0.1"
#define LOCALHOSTIP_A		"127.0.0.1"
#define LOCALHOSTIP_I		127.0.0.1

#define DPNSVR_PORT			L"6073"
#define DPNSVR_PORT_A		"6073"
#define DPNSVR_PORT_I		DPNA_DPNSVR_PORT   //6073

//==================================================================================
// Constants and defines for URLs
//==================================================================================
// Note this GUID must match GUID_UNKNOWN (see guids.h)
#define ENCODED_UNKNOWN_GUID		L"%7BFDFEFF00-FBFC-F9FA-F8F7-F6F5F4F3F2F1%7D"
#define ENCODED_UNKNOWN_GUID_A		 "%7BFDFEFF00-FBFC-F9FA-F8F7-F6F5F4F3F2F1%7D"


#define ENCODED_TCPIP_GUID			L"%7BEBFE7BA0-628D-11D2-AE0F-006097B01411%7D"
#define ENCODED_TCPIP_GUID_A		 "%7BEBFE7BA0-628D-11D2-AE0F-006097B01411%7D"


// This is data that won't have to be encoded to be stored in an URL.
#define NO_ENCODE_DATA				L"noencodedata"
#define NO_ENCODE_DATA_A			 "noencodedata"

// This is data that will have to be encoded to be stored in an URL.
#define MUST_ENCODE_DATA			L"please en{ode\tdata\n"
#define MUST_ENCODE_DATA_A			 "please en{ode\tdata\n"

#define ENCODED_MUST_ENCODE_DATA	L"please%20en%7Bode%09data%0A"
#define ENCODED_MUST_ENCODE_DATA_A	 "please%20en%7Bode%09data%0A"


#define MISCELLANEOUS_KEY1			L"misckey1"
#define MISCELLANEOUS_KEY1_A		 "misckey1"
#define MISCELLANEOUS_KEY2			L"misckey2"
#define MISCELLANEOUS_KEY2_A		 "misckey2"

#define MISCELLANEOUS_VALUE1		L"miscvalue1"
#define MISCELLANEOUS_VALUE1_A		 "miscvalue1"
#define MISCELLANEOUS_VALUE2		L"miscvalue2"
#define MISCELLANEOUS_VALUE2_A		 "miscvalue2"



#define BINARYDATA_KEY				L"binkey"
#define BINARYDATA_KEY_A			 "binkey"

const BYTE		c_abBinaryData[16] = {0xEE, 0xBE, 0xEE, 0xBE,
										0x0F, 0xB0, 0x0F, 0xB0,
										0xAC, 0xAC, 0xAC, 0xAC,
										0xCE, 0xFA, 0x11, 0xD0};

#define ENCODED_BINARYDATA			L"%EE%BE%EE%BE%0F%B0%0F%B0%AC%AC%AC%AC%CE%FA%11%D0"
#define ENCODED_BINARYDATA_A		 "%EE%BE%EE%BE%0F%B0%0F%B0%AC%AC%AC%AC%CE%FA%11%D0"




//==================================================================================
// Prototypes
//==================================================================================
//HRESULT ParmVExec_IPQI(HANDLE hLog);			//2.2.1.1
//HRESULT ParmVExec_IPDuplicate(HANDLE hLog);	//2.2.1.2
//HRESULT ParmVExec_IPSetEqual(HANDLE hLog);	//2.2.1.3
//HRESULT ParmVExec_IPIsEqual(HANDLE hLog);	//2.2.1.4
//HRESULT ParmVExec_IPGetURLW(HANDLE hLog);	//2.2.1.5
//HRESULT ParmVExec_IPGetURLA(HANDLE hLog);	//2.2.1.6	
//HRESULT ParmVExec_IPGetUserData(HANDLE hLog);//2.2.1.7
//HRESULT ParmVExec_IPSetUserData(HANDLE hLog);//2.2.1.8
HRESULT ParmVExec_IPBuildSockAddr(HANDLE hLog);	//2.2.1.9
HRESULT ParmVExec_IPGetSockAddr(HANDLE hLog);//2.2.1.10
HRESULT ParmVExec_IPBuildAddress(HANDLE hLog);	//2.2.1.11
HRESULT ParmVExec_IPGetAddress(HANDLE hLog);	//2.2.1.12
HRESULT ParmVExec_IPBuildLocalAddress(HANDLE hLog);	//2.2.1.13
HRESULT ParmVExec_IPGetLocalAddress(HANDLE hLog);	//2.2.1.14




/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVIP_LoadTestTable()"
//==================================================================================
// ParmV_IPLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.2			Parameter validation tests
//				2.2.1		IP interface parameter validation tests
//				2.2.1.1		IP QueryInterface parameter validation
//				2.2.1.2		IP Duplicate parameter validation
//				2.2.1.3		IP Set Equal parameter validation
//				2.2.1.4		IP Is Equal parameter validation
//				2.2.1.5		IP GetURLW parameter validation
//				2.2.1.6		IP GetURLA parameter validation
//				2.2.1.7		IP GetUserData parameter validation
//				2.2.1.8		IP SetUserData parameter validation
//				2.2.1.9		IP Build Sock Address parameter validation
//				2.2.1.10	IP Get Sock Address parameter validation
//				2.2.1.11	IP Build Address parameter validation
//				2.2.1.12	IP Get Address parameter validation
//				2.2.1.13	IP Build Local Address parameter validation
//				2.2.1.14	IP Get Local Address parameter validation
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVIP_LoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLEGROUP	pParmVIPTests = NULL;
	PTNTESTTABLEGROUP	pSubGroup = NULL;
	TNTESTCASEPROCS		procs;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.2		IP Parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	pParmVIPTests = pTNlttd->pBase->NewGroup("2.2", "IP Parameter validation tests");
	if (pParmVIPTests == NULL)
	{
		DPTEST_FAIL(hLog, "Couldn't create a new grouping!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't create a new grouping)



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.2.1	IP interface parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	pSubGroup = pParmVIPTests->NewGroup("2.2.1", "IP interface parameter validation tests");
	if (pSubGroup == NULL)
	{
		DPTEST_FAIL(hLog, "Couldn't create a new subgrouping!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't create a new subgrouping)


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPQI;

	hr = pSubGroup->AddTest(
	"2.2.1.1",	"IP QueryInterface parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPDuplicate;

	hr = pSubGroup->AddTest(
	"2.2.1.2",	"IP Duplicate parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPSetEqual;

	hr = pSubGroup->AddTest(
	"2.2.1.3",	"IP SetEqual parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPIsEqual;

	hr = pSubGroup->AddTest(
	"2.2.1.4",	"IP IsEqual parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetURLW;

	hr = pSubGroup->AddTest(
	"2.2.1.5",	"IP Get URLW parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetURLA;

	hr = pSubGroup->AddTest(
	"2.2.1.6",	"IP GetURLA parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetUserData;

	hr = pSubGroup->AddTest(
	"2.2.1.7",	"IP Get User Data parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPSetUserData;

	hr = pSubGroup->AddTest(
	"2.2.1.8",	"IP Set User Data parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPBuildSockAddr;

	hr = pSubGroup->AddTest(
	"2.2.1.9",	"IP Build Sock Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetSockAddr;

	hr = pSubGroup->AddTest(
	"2.2.1.10",	"IP Get Sock Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	
	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPBuildAddress;

	hr = pSubGroup->AddTest(
	"2.2.1.11",	"IP Build Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetAddress;

	hr = pSubGroup->AddTest(
	"2.2.1.12",	"IP Get Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPBuildLocalAddress;

	hr = pSubGroup->AddTest(
	"2.2.1.13",	"IP Build Local Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_IPGetLocalAddress;

	hr = pSubGroup->AddTest(
	"2.2.1.14",	"IP Get Local Address parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


DONE:

	return (hr);
} // ParmV_IPLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





/* XBOX - QueryInterface not available
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPQI()"
//==================================================================================
// ParmVExec_IPQI
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.1 - IP QueryInterface parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPQI(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
	IUnknown*						pUnknown = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8AddressIP object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8Address, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with IID_IDirectPlay8Address and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for GUID_NULL, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(GUID_NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with GUID_NULL and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for unknown GUID, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(GUID_UNKNOWN, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with unknown GUID and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											   (PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressIP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressIP,
											   (PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;

#pragma TODO(seanwh, "QI for these interfaces has not been implemented yet!")
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressIPX");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressIPX,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIPX failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIPX didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressModem");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressModem,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressModem failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressModem didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressSerial");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressSerial,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressSerial failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressSerial didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for GUID_NULL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(GUID_NULL, (PVOID*) &pUnknown);
		if (tr != DPNERR_NOINTERFACE)
		{
			DPTEST_FAIL(hLog, "Querying for GUID_NULL didn't return expected error NOINTERFACE!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown != NULL)
		{
			DPTEST_FAIL(hLog, "Querying for invalid interface returned an interface pointer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (got a pointer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for garbage GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(GUID_UNKNOWN, (PVOID*) &pUnknown);
		if (tr != DPNERR_NOINTERFACE)
		{
			DPTEST_FAIL(hLog, "Querying for unknown GUID didn't return expected error NOINTERFACE!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown != NULL)
		{
			DPTEST_FAIL(hLog, "Querying for invalid interface returned an interface pointer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (got a pointer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											  (PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pDP8AddressInternal == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressIP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressIP,
											   (PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8AddressIP object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8AddressIP object failed!");

		pDP8AddressIP = NULL;


		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);

	if (pUnknown != NULL)
	{
		pUnknown->Release();
		pUnknown = NULL;
	} // end if (have random interface)

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPQI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/






/*

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPDuplicate()"
//==================================================================================
// ParmVExec_IPDuplicate
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.2 - IP Duplicate parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPDuplicate(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;
	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8AddressIP object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_Duplicate(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Duplicating using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating without object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating without object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)



		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("QI for DP8Address Interface in order to build from URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating with object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)

		DPTEST_TRACE(hLog, "Got duplicate object at %x.", 1, pNonwrappedDP8Address);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pNonwrappedDP8Address->GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pNonwrappedDP8Address->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building original object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pNonwrappedDP8Address->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// We're done with the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;







		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											  (PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating with object being set while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)



		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing Base Address interface. For the BuildFromURL functions");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8AddressIP object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedDP8Address);
	SAFE_RELEASE(pNonwrappedMainDP8Address);
	SAFE_LOCALFREE(pwszURL);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPDuplicate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

*/



/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPSetEqual()"
//==================================================================================
// ParmVExec_BSetEqual
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.3 - IP Set Equal parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPSetEqual(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8AddressIP object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8AddressIP object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetEqual(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "SetEqual using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual to object without being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "SetEqual without object being set didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address != NULL)
		{
			DPTEST_FAIL(hLog, "Data returned with invalid object pointer!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreateInstance for another unwrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address,
							(PVOID*) &pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "CoCreateInstance for another unwrapped interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal from an Empty Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Empty Object to an Empty Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)

		

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal from pass in Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Valid Object to an Empty Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SetEqual main object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8AddressIP->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;


		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "SetEqual with object being set while locked didn't return DPNERR_NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)



		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual after object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SetEqual after object being locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;


		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing Nonwrapped Base Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedDP8Address);
	SAFE_LOCALFREE(pwszURL);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPSetEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


*/
/*


#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPIsEqual()"
//==================================================================================
// ParmVExec_IPIsEqual
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.4 - IP Is Equal parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPIsEqual(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;

	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_IsEqual(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "IsEqual using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual to object without being created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "IsEqual without object being set didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address != NULL)
		{
			DPTEST_FAIL(hLog, "Data returned with invalid object pointer!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("CoCreateInstance for another unwrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = CoCreateInstance(CLSID_DirectPlay8Address, NULL, CLSCTX_INPROC_SERVER,
							IID_IDirectPlay8Address,
							(PVOID*) &pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "CoCreateInstance for another unwrapped interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from an Empty Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Is Equal from an Empty Object to an Empty Object did not return DPNSUCCESS_EQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)
		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to an Empty Object didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("QI for DP8Address Interface in order to build from URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our main address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building main Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an equal Set Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to a Same set Object didn't return DPNSUCCESS_EQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an different Set Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to a Dirrerent set Object didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual with object being set while locked didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed IsEqual)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate base address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedDP8Address);
	SAFE_RELEASE(pNonwrappedMainDP8Address);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPIsEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

*/
/*

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetURLW()"
//==================================================================================
// ParmVExec_IPGetURLW
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.5 - IP GetURLW parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetURLW(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Unicode URL with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_GetURLW(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Unicode URL with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER) + 1;

		tr = pDP8AddressIP->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		
		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, DPNA_HEADER);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query Interface for the non-IP version of the Address to Build URL from!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address, 
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8AddressIP->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->AddComponent(MISCELLANEOUS_KEY1,
													 MISCELLANEOUS_VALUE1,
													 (wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
													 DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) + 1;

		tr = pDP8AddressIP->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8AddressIP->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing main Unwrapped Maininterface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedMainDP8Address);
	SAFE_LOCALFREE(pwszURL);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetURLW  
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


*/
/*


#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetURLA()"
//==================================================================================
// ParmVExec_BGetURLA
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.6 - Base GetURLA parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetURLA(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;

	CHAR*							pszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Ansi URL with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_GetURLA(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Ansi URL with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A) + 1;

		tr = pDP8AddressIP->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		
		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL, DPNA_HEADER_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query for non-ip non-wrapped address interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											   (PVOID*)&pNonwrappedMainDP8Address);
		if(tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Not able to query for DP8Address Interface!",0);
			THROW_TESTRESULT;
		}


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) + 1;

		tr = pDP8AddressIP->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)   



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->AddComponent(MISCELLANEOUS_KEY1,
														MISCELLANEOUS_VALUE1,
														(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
														DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Ansi URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A) + 1;

		tr = pDP8AddressIP->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Ansi URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											   (PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) + 1;

		tr = pDP8AddressIP->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL - size while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedMainDP8Address);
	SAFE_LOCALFREE(pszURL);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetURLA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



*/

/*



#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetUserData()"
//==================================================================================
// ParmVExec_IPGetUserData
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.7 - Base GetUserData parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetUserData(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;

	PVOID							pvUserData = NULL;
	DWORD							dwDataSize;
	DWORD							dwExpectedDataSize;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting user data with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_GetUserData(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting user data with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;

		tr = pDP8AddressIP->DPA_GetUserData(NULL, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object user data with NULL buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be empty.
		if (dwDataSize != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get 0 size for buffer!", 1, dwDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not 0 size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query for non-ip non-wrapped address interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											   (PVOID*)&pNonwrappedMainDP8Address);
		if(tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Not able to query for DP8Address Interface!",0);
			THROW_TESTRESULT;
		}


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;

		tr = pDP8AddressIP->DPA_GetUserData(NULL, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be empty.
		if (dwDataSize != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get 0 size for buffer!", 1, dwDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not 0 size)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedMainDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;
		dwExpectedDataSize = strlen(NO_ENCODE_DATA_A);

		tr = pDP8AddressIP->DPA_GetUserData(NULL, &dwDataSize);

		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be exactly enough to hold the special string.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Retrieved unexpected size for buffer (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvUserData, dwDataSize + BUFFERPADDING_SIZE);

		FillWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8AddressIP->DPA_GetUserData(pvUserData, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Size shouldn't have changed.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Size for buffer was unexpectedly changed (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)

		// Make sure we got the expected data back out.
		if (memcmp(pvUserData, NO_ENCODE_DATA_A, dwDataSize) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected user data (%u bytes of data at %x != \"%s\"!",
				3, dwDataSize, pvUserData, NO_ENCODE_DATA_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected user data)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pvUserData);
		pvUserData = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0; 
		dwExpectedDataSize = strlen(NO_ENCODE_DATA_A);

		tr = pDP8AddressIP->DPA_GetUserData(NULL, &dwDataSize);

		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be exactly enough to hold the special string.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Retrieved unexpected size for buffer (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvUserData, dwDataSize + BUFFERPADDING_SIZE);

		FillWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8AddressIP->DPA_GetUserData(pvUserData, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object user data while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Size shouldn't have changed.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Size for buffer was unexpectedly changed (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)

		// Make sure we got the expected data back out.
		if (memcmp(pvUserData, NO_ENCODE_DATA_A, dwDataSize) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected user data (%u bytes of data at %x != \"%s\"!",
				3, dwDataSize, pvUserData, NO_ENCODE_DATA_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected user data)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pvUserData);
		pvUserData = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing Nonwrapped Main DP8Address Pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(pNonwrappedMainDP8Address);
	SAFE_LOCALFREE(pvUserData);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


*/

/*


#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPSetUserData()"
//==================================================================================
// ParmVExec_IPSetUserData
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.8 - IP SetUserData parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPSetUserData(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_IP_CCIWRAP));
		pDP8AddressIP = ((PTOD_ABASICS_IP_CCIWRAP) pvSubOutputData)->pDP8AddressIP;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with NULL pointer and 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with NULL pointer and 0 size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with NULL pointer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NULL, 666);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting user data with NULL pointer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with invalid pointer and 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData((PVOID) 0x00000666, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with invalid pointer and 0 size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)  




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with invalid pointer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData((PVOID) 0x00000666, 666);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting user data with invalid pointer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)
		

		


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with no-encode data and zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NO_ENCODE_DATA_A, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with no-encode data and zero size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with no-encode data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NO_ENCODE_DATA_A,
											strlen(NO_ENCODE_DATA_A));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with no-encode data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data back to nothing");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
												(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data to nothing while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NULL, 0);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data back to nothing unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_IP_RELEASEWRAP));
		((PTID_ABASICS_IP_RELEASEWRAP) pvSubInputData)->pDP8AddressIP = pDP8AddressIP;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.2.2.1", pvSubInputData,
												sizeof (TID_ABASICS_IP_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:IP:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.2.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPSetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

*/

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPBuildSockAddr()"
//==================================================================================
// ParmVExec_IPBuildSockAddr
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.9 -  IP BuildFromSockAddr parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPBuildSockAddr(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;

	SOCKADDR_IN						SockAddrIn;

	WCHAR*							pwszExpectedURL = NULL;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Sock Address using NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_BuildFromSockAddr(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Building from Sock Address using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
*/



#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Sock Address using invalid pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA((char*)0x00000666);
		if (tr != DPNERR_INVALIDSTRING)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using invalid pointer didn't return expected error INVALIDSTRING!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
		*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the sock address to test with.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Set the port and the family type for the Sock Address
		//TCP and the Default Port for DPlay. 6073
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);
		
		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL,
							(wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
								   DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
								   DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1) * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
				DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for Regular DPlay8 interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;

/* XBOX - AF_IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the sock address with IPX family in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		SockAddrIn.sin_family = AF_IPX;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);
			
			
		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr with IPX family did not return INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the sock address with Port 0 in sock address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = 0;
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);
			
		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL,
							(wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
								   DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
								   DPNA_KEY_PORT L"=" L"0") + 1) * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
				DPNA_KEY_PORT L"=" L"0");
			
		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr with Port 0 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the sock address with NULL sock address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = NULL;
			
		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL,
							(wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
								   DPNA_KEY_HOSTNAME L"=" L"0.0.0.0" L";"
								   DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1) * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" L"0.0.0.0" L";"
				DPNA_KEY_PORT L"=" DPNSVR_PORT);

		
		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr with NULL Addr did not return INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from SockAddr.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;


		
/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Sock Addr while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);

		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Sock Addr using header, provider with unknown GUID, misc key & value while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_BuildFromSockAddr((PSOCKADDR)&SockAddrIn);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, misc key & value while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
*/




/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

/* XBOX - Interfaces are merged on Xbox, don't need to query
		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Free URL strings");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE

	SAFE_LOCALFREE(pwszExpectedURL);
	SAFE_LOCALFREE(pwszURL);

/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPBuildSockAddr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetSockAddr()"
//==================================================================================
// ParmVExec_IPGetSockAddr
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.10 -  IP GetSockAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetSockAddr(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	PSOCKADDR_IN					pSockAddrIn = NULL;
	DWORD							dwSockAddrLen = NULL;
	DWORD							dwExpectedSockAddrLen = NULL;

	SOCKADDR_IN						SockAddrIn;

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;
	DWORD							dwExpectedURLLen = NULL;

	WCHAR*							pwszExpectedURL = NULL;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL Sock pointer, NULL Sock Buffer Size Pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "NULL Pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
*/

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Valid Sock Addr, NULL Buffer Size pointer.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;

		tr = pDP8AddressIP->DPA_GetSockAddress((PSOCKADDR)pSockAddrIn, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "NULL Buffer Size pointer didn't return INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if 
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, no Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "NULL Sock Pointer, 0 buffer, No Address Set didn't return INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if 


/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for Nonwrapped DP8Address interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the sock address with a URL.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Set the port and the family type for the Sock Address
		//TCP and the Default Port for DPlay. 6073
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);
		
		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
								   DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
								   DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP L";"
				DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 100 value Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = 100;
		pSockAddrIn = NULL;

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "NULL Sock Pointer, 100 buffer, Address Set didn't return INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if 
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "NULL Sock Pointer, 0 buffer, Address Set didn't return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 

		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of one Sock Address!",0);
			THROW_TESTRESULT;
		}


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SockAddr Pointer, Valid Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PSOCKADDR_IN, pSockAddrIn, dwExpectedSockAddrLen + BUFFERPADDING_SIZE);

		FillWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)),
						BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8AddressIP->DPA_GetSockAddress((PSOCKADDR)pSockAddrIn, &dwSockAddrLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SockAddr Pointer, Valid Buffer Size, Address Set failed!", 0);
			THROW_TESTRESULT;
		} // end if 

		//Make sure the SockAddr size is still the expected value
		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of on Sock Address!",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(memcmp(&SockAddrIn.sin_addr, &pSockAddrIn->sin_addr, sizeof(in_addr)))
		{
			DPTEST_FAIL(hLog, "Address in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}
		
		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_family != pSockAddrIn->sin_family)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_port != pSockAddrIn->sin_port)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		
		SAFE_LOCALFREE(pSockAddrIn);
				

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the Invalid sock address with a URL.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Free the URL Buffer so we can use it again.
		SAFE_LOCALFREE(pwszExpectedURL);

		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP 
						  /*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
				/*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Invalid Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Retrieving Invalid Sock Address, No Port, didn't return INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the Invalid sock address No Host!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Free the URL Buffer so we can use it again.
		SAFE_LOCALFREE(pwszExpectedURL);

		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  /*L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP*/ 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
				/*L";"DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP*/
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Invalid Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Retrieving Invalid Sock Address No Host didn't return INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if 
		
		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the Invalid sock address Unknown GUID  Provider!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Free the URL Buffer so we can use it again.
		SAFE_LOCALFREE(pwszExpectedURL);

		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID
				L";"DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Unknown Guid Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);


		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INVALIDADDRESSFORMAT)
		{
			if(tr == DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2906 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Retrieving Invalid Sock Address No Host didn't return INVALIDADDRESSFORMAT!", 0);
				THROW_TESTRESULT;
			}
		} // end if 

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the Invalid sock address Junk HostName!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Free the URL Buffer so we can use it again.
		SAFE_LOCALFREE(pwszExpectedURL);

		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_VALUE1 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
				L";"DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_VALUE1
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Unknown Guid Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_INVALIDHOSTADDRESS)
		{
			DPTEST_FAIL(hLog, "Retrieving Invalid Sock Address No Host didn't return INVALIDREMOTEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if 


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Build the Valid sock address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Set the port and the family type for the Sock Address
		//TCP and the Default Port for DPlay. 6073
		SockAddrIn.sin_family = AF_INET;
		SockAddrIn.sin_port = htons(DPNSVR_PORT_I);
		SockAddrIn.sin_addr.S_un.S_addr = inet_addr(LOCALHOSTIP_A);

		//Free the URL Buffer so we can use it again.
		SAFE_LOCALFREE(pwszExpectedURL);

		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
				L";"DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
			
			
		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(pwszExpectedURL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Sock Addr from URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from SockAddr)


	
/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "NULL Sock Pointer, 0 buffer, Address Set didn't return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 

		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of one Sock Address!",0);
			THROW_TESTRESULT;
		}


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SockAddr Pointer, Valid Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PSOCKADDR_IN, pSockAddrIn, dwExpectedSockAddrLen + BUFFERPADDING_SIZE);

		FillWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)), BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8AddressIP->DPA_GetSockAddress((PSOCKADDR)pSockAddrIn, &dwSockAddrLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SockAddr Pointer, Valid Buffer Size, Address Set failed!", 0);
			THROW_TESTRESULT;
		} // end if 

		//Make sure the SockAddr size is still the expected value
		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of on Sock Address!",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(memcmp(&SockAddrIn.sin_addr, &pSockAddrIn->sin_addr, sizeof(in_addr)))
		{
			DPTEST_FAIL(hLog, "Address in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}
		
		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_family != pSockAddrIn->sin_family)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_port != pSockAddrIn->sin_port)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}
		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		
		SAFE_LOCALFREE(pSockAddrIn);
				


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("NULL for SockAddr Pointer, 0 value Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSockAddrLen = NULL;
		pSockAddrIn = NULL;
		dwExpectedSockAddrLen = sizeof(SOCKADDR);

		tr = pDP8AddressIP->DPA_GetSockAddress(NULL, &dwSockAddrLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "NULL Sock Pointer, 0 buffer, Address Set didn't return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 

		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of one Sock Address!",0);
			THROW_TESTRESULT;
		}


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SockAddr Pointer, Valid Buffer Size, Address Set.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PSOCKADDR_IN, pSockAddrIn, dwExpectedSockAddrLen + BUFFERPADDING_SIZE);

		FillWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)), BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8AddressIP->DPA_GetSockAddress((PSOCKADDR)pSockAddrIn, &dwSockAddrLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SockAddr Pointer, Valid Buffer Size, Address Set failed!", 0);
			THROW_TESTRESULT;
		} // end if 

		//Make sure the SockAddr size is still the expected value
		if(dwSockAddrLen != dwExpectedSockAddrLen)
		{
			DPTEST_FAIL(hLog, "Did not receive expected Sock Address length of on Sock Address!",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(memcmp(&SockAddrIn.sin_addr, &pSockAddrIn->sin_addr, sizeof(in_addr)))
		{
			DPTEST_FAIL(hLog, "Address in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}
		
		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_family != pSockAddrIn->sin_family)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}

		//Make sure the SockAddr we got back is what we expected.
		if(SockAddrIn.sin_port != pSockAddrIn->sin_port)
		{
			DPTEST_FAIL(hLog, "Family in Sock Addresses Do No Match.",0);
			THROW_TESTRESULT;
		}
		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pSockAddrIn + (dwSockAddrLen/sizeof(SOCKADDR)), BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		
/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing helper interfaces");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_RELEASE(pDP8AddressInternal);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
		SAFE_RELEASE(pNonwrappedMainDP8Address);
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Free our Sock Address Pointer interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_LOCALFREE(pSockAddrIn);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Free URL strings");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_LOCALFREE(pwszExpectedURL);
		SAFE_LOCALFREE(pwszURL);

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE

	SAFE_LOCALFREE(pwszExpectedURL);
	SAFE_LOCALFREE(pwszURL);


	SAFE_LOCALFREE(pSockAddrIn);
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetSockAddr
#undef DEBUG_SECTION
#define DEBUG_SECTION	""









#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPBuildAddress()"
//==================================================================================
// ParmVExec_IPBuildSockAddr
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.11 -  IP BuildAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPBuildAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;

	WCHAR*							pwszExpectedURL = NULL;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using NULL Address Pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_BuildAddress(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Building ddress using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using NULL Port");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP 
						  L";" DPNA_KEY_PORT L"=" L"0") + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
				L";" DPNA_KEY_PORT L"=" L"0");
		
		tr = pDP8AddressIP->DPA_BuildAddress(LOCALHOSTIP, NULL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building ddress using NULL Port failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)

/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for non-wrapped DP8 Address interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address,
											(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);   //Leave for the next test case.
		pwszExpectedURL = NULL;


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using Miscellaneous Hostname");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_KEY1 
						  L";" DPNA_KEY_PORT L"=" L"0") + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_KEY1
				L";" DPNA_KEY_PORT L"=" L"0");

		
		tr = pDP8AddressIP->DPA_BuildAddress(MISCELLANEOUS_KEY1, NULL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building address using Miscellaneous emote Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from Build Address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using Default Port");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" L"localhost" 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" L"localhost"
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
		tr = pDP8AddressIP->DPA_BuildAddress(L"localhost", DPNA_DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building ddress using Valid Port and Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);   //Leave for the next test case.
		pwszExpectedURL = NULL;



		
/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using Default Port");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		tr = pDP8AddressIP->DPA_BuildAddress(L"localhost", DPNA_DPNSVR_PORT);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Building locked address using Valid Port and Address didn't return NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Address using Default Port");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
						  L";" DPNA_KEY_HOSTNAME L"=" L"localhost" 
						  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_HOSTNAME L"=" L"localhost"
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		
		tr = pDP8AddressIP->DPA_BuildAddress(L"localhost", DPNA_DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building ddress using Valid Port and Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = NULL;

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting size of URL did not return BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if 


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get the URL from the Address Structure set from BuildAddress.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof(WCHAR));

		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting URL with correct size failed!", 0);
			THROW_TESTRESULT;
		} // end if

		//Create the address string to compare it with.
		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(pwszExpectedURL);   //Leave for the next test case.
		pwszExpectedURL = NULL;





/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

/* XBOX - Interfaces are merged on Xbox, don't need to query
		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Free URL strings");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE

	SAFE_LOCALFREE(pwszExpectedURL);
	SAFE_LOCALFREE(pwszURL);

/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPBuildAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""








#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetAddress()"
//==================================================================================
// ParmVExec_IPGetAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.12 - IP GetAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData = NULL;
	DWORD							dwSubOutputDataSize = NULL;
*/

	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	WCHAR*							pwszAddr = NULL;
	DWORD							dwAddrLen = NULL;
	DWORD							dwExpectedAddrLen = NULL;
	
	USHORT							usPort = NULL;

	USHORT							usExpectedPort = NULL;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, NULL Address Pointer, Valid Length = 0, Val Port, no address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 0;

		tr = pDP8AddressIP->DPA_GetAddress(NULL, &dwAddrLen, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL address pointer didn't return expected BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, valid Address Pointer, NULL Length pointer, Val Port, no address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 0;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, NULL, &usPort);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL Length Pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, valid Address Pointer, valid Length = 0 , Port Pointer = NULL, no address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 0;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL Port Pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode Address - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwAddrLen = 0;
		dwExpectedAddrLen = 0;
		usPort = 0;
		pwszAddr = NULL;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen,&usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode Address - size didn't return expected error INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		
		// Make sure the size has not changed.
		if (dwAddrLen != 0)
		{
			DPTEST_FAIL(hLog, "Addr Size changed unexpected (%u)!", 1, dwAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		
		// Make sure the port has not changed.
		if (usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port changed unexpected (%u)!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the size has not changed.
		if (pwszAddr != 0)
		{
			DPTEST_FAIL(hLog, "Addr Pointer changed unexpected (%x)!", 1, pwszAddr);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		

		
		
/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query Interface for the non-IP version of the Address to Build URL from!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address, 
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object without IP  - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwAddrLen = 0;
		dwExpectedAddrLen = NULL;
		usPort = NULL;
		pwszAddr = NULL;

		tr = pDP8AddressIP->DPA_GetAddress(NULL, &dwAddrLen, &usPort);
		if (tr != DPNERR_INVALIDADDRESSFORMAT)
		{
			if(tr == DPNERR_INCOMPLETEADDRESS)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2906 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting set object without IP  - size didn't return expected error INVALIDREMOTEADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting Unicode Address)


		// Make sure the size has not changed.
		if (dwAddrLen != 0)
		{
			DPTEST_FAIL(hLog, "Addr Size changed unexpected (%u)!", 1, dwAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		
		// Make sure the port has not changed.
		if (usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port changed unexpected (%u)!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the size has not changed.
		if (pwszAddr != 0)
		{
			DPTEST_FAIL(hLog, "Addr Pointer changed unexpected (%x)!", 1, pwszAddr);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with TCPIP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
													  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCPIP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, NULL Address Pointer, valid Length = 100, valid Port valid remote address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 100;
		usPort = 0;

		tr = pDP8AddressIP->DPA_GetAddress(NULL, &dwAddrLen, &usPort);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL Address Pointer and size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if(usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port has changed %u!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}

		if(dwAddrLen != 100)
		{
			DPTEST_FAIL(hLog, "AddrLen has changed %u!", 1, dwAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using only the header & provider with TCPIP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  /*L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP*/
													  /*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCPIP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, NULL Address Pointer, valid Length = 100, valid Port valid remote address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 0;
		usPort = 0;

		tr = pDP8AddressIP->DPA_GetAddress(NULL, &dwAddrLen, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL Address Pointer and size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if(usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port has changed %u!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}

		if(dwAddrLen != 0)
		{
			DPTEST_FAIL(hLog, "AddrLen has changed %u!", 1, dwAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using only the header, TCPIP GUID, and host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
													  /*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCPIP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("GetAddress, NULL Address Pointer, length 0,  valid Port,  no port in remote address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwAddrLen = 0;
		usPort = 0;

		tr = pDP8AddressIP->DPA_GetAddress(NULL, &dwAddrLen, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Getting Address with NULL Address Pointer and size with no port in address didn't return expected error INVALIDREMOTEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if(usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port has changed %u!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}

		if(dwAddrLen != 0)
		{
			DPTEST_FAIL(hLog, "AddrLen has changed %u!", 1, dwAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		}
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using only the header, TCPIP GUID, and host");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
													  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCPIP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object with IP  - size, pass in ULONG Port Param.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwAddrLen = 0;
		dwExpectedAddrLen = wcslen(LOCALHOSTIP) + 1;
		usExpectedPort = DPNSVR_PORT_I; 
		usPort = NULL;
		pwszAddr = NULL;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, &usPort);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object with IP  - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode Address)


		// Make sure the size has not changed.
		if (dwAddrLen != dwExpectedAddrLen)
		{
			DPTEST_FAIL(hLog, "Addr Size changed unexpected (%u != %u)!", 2, dwAddrLen, dwExpectedAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		
		// Make sure the port has not changed.
		if (usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port changed unexpected (%u)!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the size has not changed.
		if (pwszAddr != 0)
		{
			DPTEST_FAIL(hLog, "Addr Pointer changed unexpected (%x)!", 1, pwszAddr);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Address URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszAddr, ((dwAddrLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszAddr + dwAddrLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, &usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwAddrLen != dwExpectedAddrLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!", 2, dwAddrLen, dwExpectedAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the Address retrieved is expected.
		if (wcscmp(pwszAddr, LOCALHOSTIP) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!", 2, pwszAddr, LOCALHOSTIP);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the Ulong Port retrieved is expected.
		if (usPort != usExpectedPort)
		{
			DPTEST_FAIL(hLog, "Port retrieved is unexpected (%u != %u)!", 2, usPort, usExpectedPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszAddr + dwAddrLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszAddr);
		pwszAddr = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
													  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object with Unknown Guid Addr  - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwAddrLen = 0;
		dwExpectedAddrLen = wcslen(LOCALHOSTIP) + 1;
		usExpectedPort = DPNSVR_PORT_I; 
		usPort = NULL;
		pwszAddr = NULL;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, &usPort);
		if (tr != DPNERR_INVALIDADDRESSFORMAT)
		{
			if(tr == DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2906 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting set object with Unknown Guid  INVALIDREMOTEADDRESS!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting Unicode Address)


		// Make sure the size has not changed.
		if (dwAddrLen != 0)
		{
			if(tr == DPNERR_BUFFERTOOSMALL)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2906 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Addr Size changed unexpected (%u != 0)!", 2, dwAddrLen);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (not expected size)
		
		// Make sure the port has not changed.
		if (usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port changed unexpected (%u)!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the size has not changed.
		if (pwszAddr != 0)
		{
			DPTEST_FAIL(hLog, "Addr Pointer changed unexpected (%x)!", 1, pwszAddr);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with TCPIP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_VALUE1
													  L";" DPNA_KEY_PORT L"=" L"128"
													  L";#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCPIP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)





/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object with IP  - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwAddrLen = 0;
		dwExpectedAddrLen = wcslen(MISCELLANEOUS_VALUE1) + 1;
		usExpectedPort = 128; 
		usPort = NULL;
		pwszAddr = NULL;

		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, &usPort);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object with IP  - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode Address)


		// Make sure the size has not changed.
		if (dwAddrLen != dwExpectedAddrLen)
		{
			DPTEST_FAIL(hLog, "Addr Size changed unexpected (%u != %u)!", 2, dwAddrLen, dwExpectedAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		
		// Make sure the port has not changed.
		if (usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port changed unexpected (%u)!", 1, usPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the size has not changed.
		if (pwszAddr != 0)
		{
			DPTEST_FAIL(hLog, "Addr Pointer changed unexpected (%x)!", 1, pwszAddr);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Address URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszAddr, ((dwAddrLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszAddr + dwAddrLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->DPA_GetAddress(pwszAddr, &dwAddrLen, &usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwAddrLen != dwExpectedAddrLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!", 2, dwAddrLen, dwExpectedAddrLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the Address retrieved is expected.
		if (wcscmp(pwszAddr, MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!", 2, pwszAddr, MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the Port retrieved is expected.
		if (usPort != usExpectedPort)
		{
			DPTEST_FAIL(hLog, "Port retrieved is unexpected (%u != %u)!", 2, usPort, usExpectedPort);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszAddr + dwAddrLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszAddr);
		pwszAddr = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing main Unwrapped Maininterface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

/* XBOX - Interfaces are merged on Xbox, don't need to query
		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/
	SAFE_LOCALFREE(pwszAddr);

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetAddress  
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPBuildLocalAddress()"
//==================================================================================
// ParmVExec_IPBuildLocalAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.13 - IP BuildLocalAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPBuildLocalAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	WCHAR*							pwszURL = NULL;
	WCHAR*							pwszExpectedURL = NULL;
	DWORD							dwURLLen = NULL;
	DWORD							dwExpectedURLLen = NULL;
	
	USHORT							usPort = NULL;
	USHORT							usExpectedPort = NULL;
	
	GUID							guidDevice;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query Interface for the non-IP version of the Address to Build URL from!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address, 
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with NULL GUID pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_BuildLocalAddress(NULL, usPort);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting object device with NULL GUID pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with NULL Port value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = GUID_UNKNOWN;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, NULL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting object device with NULL GUID value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with NULL Port value and NULL GUID value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = GUID_NULL;
		usPort = NULL;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting object device with NULL GUID value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with GUID_UNKNOWN");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = GUID_UNKNOWN;
		usPort = DPNSVR_PORT_I;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device with GUID_UNKNOWN failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = 0;

		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
									L";" DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID 
									L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwExpectedURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);

			
		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "GetURLW with 0 Buffersize didn't return BUFFERTOOSMALL", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)

		
		if(dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Expected (%u) and returned (%u) lengths are not the same.", 2, dwExpectedURLLen, dwURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			THROW_TESTRESULT;
		}

		
		if(pwszURL != NULL)
		{
			DPTEST_FAIL(hLog, "pwszURL should not be set with BUFFERTOOSMALL (%x)", 1, pwszURL);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!", 2, dwURLLen, dwExpectedURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the Address retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!", 2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with GUID_UNKNOWN");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = GUID_UNKNOWN;
		usPort = NULL;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device with GUID_UNKNOWN failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = 0;

		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
									L";" DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID 
									L";" DPNA_KEY_PORT L"=" L"0") + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwExpectedURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID
				L";" DPNA_KEY_PORT L"=" L"0");

			
		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "GetURLW with 0 Buffersize didn't return BUFFERTOOSMALL", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)

		
		if(dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Expected (%u) and returned (%u) lengths are not the same.", 2, dwExpectedURLLen, dwURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			THROW_TESTRESULT;
		}

		
		if(pwszURL != NULL)
		{
			DPTEST_FAIL(hLog, "pwszURL should not be set with BUFFERTOOSMALL (%x)", 1, pwszURL);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!", 2, dwURLLen, dwExpectedURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the Address retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!", 2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;




/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device on built object with CLSID_DP8SP_TCPIP while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = GUID_UNKNOWN;
		usPort = DPNSVR_PORT_I;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, usPort);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Setting device on built object with GUID_UNKNOWN while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with GUID_UNKNOWN");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		guidDevice = CLSID_DP8SP_TCPIP;
		usPort = DPNSVR_PORT_I;

		tr = pDP8AddressIP->DPA_BuildLocalAddress(&guidDevice, usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device with GUID_UNKNOWN failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwURLLen = 0;

		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID 
									L";" DPNA_KEY_DEVICE L"=" ENCODED_TCPIP_GUID 
									L";" DPNA_KEY_PORT L"=" DPNSVR_PORT) + 1;

		LOCALALLOC_OR_THROW(WCHAR*, pwszExpectedURL, dwExpectedURLLen * sizeof(WCHAR)); 
		
		wcscpy(pwszExpectedURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";"
				DPNA_KEY_DEVICE L"=" ENCODED_TCPIP_GUID
				L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);

			
		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "GetURLW with 0 Buffersize didn't return BUFFERTOOSMALL", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)

		
		if(dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Expected (%u) and returned (%u) lengths are not the same.", 2, dwExpectedURLLen, dwURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			THROW_TESTRESULT;
		}

		
		if(pwszURL != NULL)
		{
			DPTEST_FAIL(hLog, "pwszURL should not be set with BUFFERTOOSMALL (%x)", 1, pwszURL);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify the GUID_UNKNOWN Device Address!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8AddressIP->m_pDP8AddressIP->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!", 2, dwURLLen, dwExpectedURLLen);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the Address retrieved is expected.
		if (wcscmp(pwszURL, pwszExpectedURL) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!", 2, pwszURL, pwszExpectedURL);
			DPTEST_FAIL(hLog, "Xbox bug 2934 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		
		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		SAFE_LOCALFREE(pwszExpectedURL);
		pwszExpectedURL = NULL;






/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

/* XBOX - Interfaces are merged on Xbox, don't need to query
		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


		
	SAFE_LOCALFREE(pwszURL);
	SAFE_LOCALFREE(pwszExpectedURL);

/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPBuildLocalDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""



#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_IPGetLocalAddress()"
//==================================================================================
// ParmVExec_IPBuildLocalAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.2.1.14 - IP GetLocalAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_IPGetLocalAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	
	PWRAPDP8ADDRESSIP				pDP8AddressIP = NULL;
/* XBOX - Interfaces are merged on Xbox, don't need to query
	PDIRECTPLAY8ADDRESS				pNonwrappedMainDP8Address = NULL;
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/


	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;
	
	USHORT							usPort = NULL;
	USHORT							usExpectedPort = NULL;
	
	GUID							guidDevice;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressIP = new CWrapDP8AddressIP(hLog);
		if (pDP8AddressIP == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8AddressIP->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with NULL GUID*.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(NULL, &usPort);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting NULL Address with NULL GUID* didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)
*/

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with NULL Port*.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting NULL Address with NULL Port* didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)
*/
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with NULL Address, valid params.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Getting NULL Address with Valid Params didn't return expected error INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)

		
/* XBOX - Interfaces are merged on Xbox, don't need to query
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Query Interface for the non-IP version of the Address to Build URL from!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8Address, 
												(PVOID*) &pNonwrappedMainDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  /*L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP*/
													  /*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with just header and provider in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "No port address didn't return expected error INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID
													  /*L";" DPNA_KEY_PORT L"=" DPNSVR_PORT*/);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with header and provider in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPNERR_INCOMPLETEADDRESS)
		{
			DPTEST_FAIL(hLog, "Header and provider address didn't return expected error INCOMPLETEADDRESS!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & unknown provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID
													  L";" DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID
													  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with UNKNOWN provider GUID.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPNERR_INVALIDADDRESSFORMAT)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 2906 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Header and provider address didn't return expected error INVALIDADDRESSFORMAT!: 0x%08x", 1, tr);
				THROW_TESTRESULT;
			}
		} // end if (failed setting device)

		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID
													  L";" DPNA_KEY_PORT L"=" DPNSVR_PORT);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with header, provider and port in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Header, provider, and port failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(guidDevice != GUID_UNKNOWN)
		{
			DPTEST_FAIL(hLog, "GUID retrieved is unexpected (%u != %u)!", 2,guidDevice, GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(usPort != DPNSVR_PORT_I)
		{
			DPTEST_FAIL(hLog, "Port retrieved is unexpected (%u != %u)!", 2,usPort, DPNSVR_PORT_I);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)


/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with header, provider and port in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Header, provider, and port failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(guidDevice != GUID_UNKNOWN)
		{
			DPTEST_FAIL(hLog, "GUID retrieved is unexpected (%u != %u)!", 2,guidDevice, GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(usPort != DPNSVR_PORT_I)
		{
			DPTEST_FAIL(hLog, "Port retrieved is unexpected (%u != %u)!", 2,usPort, DPNSVR_PORT_I);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->m_pDP8AddressIP->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_HOSTNAME L"=" LOCALHOSTIP
													  L";" DPNA_KEY_DEVICE L"=" ENCODED_TCPIP_GUID
													  L";" DPNA_KEY_PORT L"=" L"0"
													  L";#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting device with header, provider and port in address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		usPort = NULL;

		tr = pDP8AddressIP->DPA_GetLocalAddress(&guidDevice, &usPort);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Header, provider, and port failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(guidDevice != CLSID_DP8SP_TCPIP)
		{
			DPTEST_FAIL(hLog, "GUID retrieved is unexpected (%u != %u)!", 2,guidDevice, CLSID_DP8SP_TCPIP);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)

		//Verify the Device Guid that was returned.
		if(usPort != 0)
		{
			DPTEST_FAIL(hLog, "Port retrieved is unexpected (%u != %u)!", 2,usPort, 0);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed setting device)

/* XBOX - IDirectPlay8AddressInternal not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

/* XBOX - Interfaces are merged on Xbox, don't need to query
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedMainDP8Address->Release();
		pNonwrappedMainDP8Address = NULL;
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressIP->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


		
	SAFE_LOCALFREE(pwszURL);

/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - Interfaces are merged on Xbox, don't need to query
	SAFE_RELEASE(pNonwrappedMainDP8Address);
*/
/* XBOX - IDirectPlay8AddressInternal not supported
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8AddressIP != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8AddressIP);
*/
		delete (pDP8AddressIP);
		pDP8AddressIP = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_IPGetLocalAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvaddr.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "wrapbase.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Global vars to gather return data from Threads.
//==================================================================================
struct	ThreadResult
{
	HRESULT			hrThreadResult;
	char			szTestDescript[256];
	char			szResultDescript[256];
};




//==================================================================================
// Defines
//==================================================================================

// Makes sure nobody touched the memory when they weren't supposed to.
#define DONT_TOUCH_MEMORY_PATTERN	0xBADAB00F

#define BUFFERPADDING_SIZE			64


//==================================================================================
// Defines
//==================================================================================
#define FAKE_TCPIPADDRESS	L"nonexistentmachine"
#define FAKE_TCPIPADDRESS_A	"nonexistentmachine"


//==================================================================================
// Constants and defines for URLs
//==================================================================================
// Note this GUID must match GUID_UNKNOWN (see guids.h)
#define ENCODED_UNKNOWN_GUID		L"%7BFDFEFF00-FBFC-F9FA-F8F7-F6F5F4F3F2F1%7D"
#define ENCODED_UNKNOWN_GUID_A		 "%7BFDFEFF00-FBFC-F9FA-F8F7-F6F5F4F3F2F1%7D"


#define ENCODED_TCPIP_GUID			L"%7BEBFE7BA0-628D-11D2-AE0F-006097B01411%7D"
#define ENCODED_TCPIP_GUID_A		 "%7BEBFE7BA0-628D-11D2-AE0F-006097B01411%7D"


// This is data that won't have to be encoded to be stored in an URL.
#define NO_ENCODE_DATA				L"noencodedata"
#define NO_ENCODE_DATA_A			 "noencodedata"

// This is data that will have to be encoded to be stored in an URL.
#define MUST_ENCODE_DATA			L"please en{ode\tdata\n"
#define MUST_ENCODE_DATA_A			 "please en{ode\tdata\n"

#define ENCODED_MUST_ENCODE_DATA	L"please%20en%7Bode%09data%0A"
#define ENCODED_MUST_ENCODE_DATA_A	 "please%20en%7Bode%09data%0A"


#define MISCELLANEOUS_KEY1			L"misckey1"
#define MISCELLANEOUS_KEY1_A		 "misckey1"
#define MISCELLANEOUS_KEY2			L"misckey2"
#define MISCELLANEOUS_KEY2_A		 "misckey2"

#define MISCELLANEOUS_VALUE1		L"miscvalue1"
#define MISCELLANEOUS_VALUE1_A		 "miscvalue1"
#define MISCELLANEOUS_VALUE2		L"miscvalue2"
#define MISCELLANEOUS_VALUE2_A		 "miscvalue2"



#define BINARYDATA_KEY				L"binkey"
#define BINARYDATA_KEY_A			 "binkey"

const BYTE		c_abBinaryData[16] = {0xEE, 0xBE, 0xEE, 0xBE,
										0x0F, 0xB0, 0x0F, 0xB0,
										0xAC, 0xAC, 0xAC, 0xAC,
										0xCE, 0xFA, 0x11, 0xD0};

#define ENCODED_BINARYDATA			L"%EE%BE%EE%BE%0F%B0%0F%B0%AC%AC%AC%AC%CE%FA%11%D0"
#define ENCODED_BINARYDATA_A		 "%EE%BE%EE%BE%0F%B0%0F%B0%AC%AC%AC%AC%CE%FA%11%D0"




//==================================================================================
// Prototypes
//==================================================================================
//HRESULT CreateInterface_Addr(HANDLE hLog);
//HRESULT ParmVExec_BQI(HANDLE hLog);
HRESULT ParmVExec_BBuildW(HANDLE hLog);
HRESULT ParmVExec_BBuildA(HANDLE hLog);
HRESULT ParmVExec_BDuplicate(HANDLE hLog);
HRESULT ParmVExec_BSetEqual(HANDLE hLog);
HRESULT ParmVExec_BIsEqual(HANDLE hLog);
HRESULT ParmVExec_BClear(HANDLE hLog);
HRESULT ParmVExec_BGetURLW(HANDLE hLog);
HRESULT ParmVExec_BGetURLA(HANDLE hLog);
HRESULT ParmVExec_BGetSP(HANDLE hLog);
HRESULT ParmVExec_BGetUserData(HANDLE hLog);
HRESULT ParmVExec_BSetSP(HANDLE hLog);
HRESULT ParmVExec_BSetUserData(HANDLE hLog);
HRESULT ParmVExec_BGetNumComponents(HANDLE hLog);
HRESULT ParmVExec_BGetByName(HANDLE hLog);
HRESULT ParmVExec_BGetByIndex(HANDLE hLog);
HRESULT ParmVExec_BAdd(HANDLE hLog);
HRESULT ParmVExec_BGetDevice(HANDLE hLog);
HRESULT ParmVExec_BSetDevice(HANDLE hLog);
//HRESULT ParmVExec_BLockUnlock(HANDLE hLog);
//HRESULT ParmVExec_BBuildDPADDR(HANDLE hLog);

//Seperate thread that is used to make sure coinit is not being called before DirectPlay8Create.
//HRESULT AddressingCreateThread(PVOID thrVoid);


/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmV_LoadTestTable()"
//==================================================================================
// ParmV_LoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.1			Parameter validation tests
//				2.1.1		Base interface parameter validation tests
//				2.1.1.1		Base CreateDplay8Address parameter validation
//				2.1.1.2		Base QueryInterface parameter validation
//				2.1.1.3		Base BuildFromURLW parameter validation
//				2.1.1.4		Base BuildFromURLA parameter validation
//				2.1.1.5		Base Duplicate parameter validation
//				2.1.1.6		Base Set Equal parameter validation
//				2.1.1.7		Base Is Equal parameter validation
//				2.1.1.8		Base Clear parameter validation
//				2.1.1.9		Base GetURLW parameter validation
//				2.1.1.10	Base GetURLW parameter validation
//				2.1.1.11	Base GetSP parameter validation
//				2.1.1.12	Base GetUserData parameter validation
//				2.1.1.13	Base SetSP parameter validation
//				2.1.1.14	Base SetUserData parameter validation
//				2.1.1.15	Base GetNumComponents parameter validation
//				2.1.1.16	Base GetComponentByName parameter validation
//				2.1.1.17	Base GetComponentByIndex parameter validation
//				2.1.1.18	Base AddComponent parameter validation
//				2.1.1.19	Base GetDevice parameter validation
//				2.1.1.20	Base SetDevice parameter validation
//				2.1.1.21	Base Lock and UnLock parameter validation
//				2.1.1.22	Base Build From DPlay4 Addr parameter validation
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmV_LoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	HRESULT				hr = S_OK;
	PTNTESTTABLEGROUP	pParmVTests = NULL;
	PTNTESTTABLEGROUP	pSubGroup = NULL;
	TNTESTCASEPROCS		procs;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1		Parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	pParmVTests = pTNlttd->pBase->NewGroup("2.1", "Parameter validation tests");
	if (pParmVTests == NULL)
	{
		DPTEST_FAIL(hLog, "Couldn't create a new grouping!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't create a new grouping)



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.1	Base interface parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

	pSubGroup = pParmVTests->NewGroup("2.1.1", "Base interface parameter validation tests");
	if (pSubGroup == NULL)
	{
		DPTEST_FAIL(hLog, "Couldn't create a new subgrouping!", 0);
		hr = E_FAIL;
		goto DONE;
	} // end if (couldn't create a new subgrouping)


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = CreateInterface_Addr;

	hr = pSubGroup->AddTest(
	"2.1.1.1",	"CreateDplay8Address Interface parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BQI;

	hr = pSubGroup->AddTest(
	"2.1.1.2",	"Base QueryInterface parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BBuildW;

	hr = pSubGroup->AddTest(
	"2.1.1.3",	"Base BuildFromURLW parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BBuildA;

	hr = pSubGroup->AddTest(
	"2.1.1.4",	"Base BuildFromURLW parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BDuplicate;

	hr = pSubGroup->AddTest(
	"2.1.1.5",	"Base Duplicate parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BSetEqual;

	hr = pSubGroup->AddTest(
	"2.1.1.6",	"Base Set Equal parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BIsEqual;

	hr = pSubGroup->AddTest(
	"2.1.1.7",	"Base Is Equal parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BClear;

	hr = pSubGroup->AddTest(
	"2.1.1.8",	"Base Clear parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetURLW;

	hr = pSubGroup->AddTest(
	"2.1.1.9",	"Base GetURLW parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetURLA;

	hr = pSubGroup->AddTest(
	"2.1.1.10",	"Base GetURLA parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	
	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetSP;

	hr = pSubGroup->AddTest(
	"2.1.1.11",	"Base GetSP parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetUserData;

	hr = pSubGroup->AddTest(
	"2.1.1.12",	"Base GetUserData parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BSetSP;

	hr = pSubGroup->AddTest(
	"2.1.1.13",	"Base SetSP parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BSetUserData;

	hr = pSubGroup->AddTest(
	"2.1.1.14",	"Base SetUserData parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetNumComponents;

	hr = pSubGroup->AddTest(
	"2.1.1.15",	"Base GetNumComponents parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetByName;

	hr = pSubGroup->AddTest(
	"2.1.1.16",	"Base GetComponentByName parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetByIndex;

	hr = pSubGroup->AddTest(
	"2.1.1.17",	"Base GetComponentByIndex parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BAdd;

	hr = pSubGroup->AddTest(
	"2.1.1.18",	"Base AddComponent parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BGetDevice;

	hr = pSubGroup->AddTest(
	"2.1.1.19",	"Base GetDevice parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;


	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BSetDevice;

	hr = pSubGroup->AddTest(
	"2.1.1.20",	"Base SetDevice parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BLockUnlock;

	hr = pSubGroup->AddTest(
	"2.1.1.21",	"Base Lock and Unlock parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

	ZeroMemory(&procs, sizeof (TNTESTCASEPROCS));
	procs.dwSize = sizeof (TNTESTCASEPROCS);
	procs.pfnExecCase = ParmVExec_BBuildDPADDR;

	hr = pSubGroup->AddTest(
	"2.1.1.22",	"Base Lock and Unlock parameter validation",
			1, TNTCO_API | TNTCO_STRESS | TNTCO_SCENARIO | TNTCO_DONTSAVERESULTS,
			&procs, 0, NULL);
	if (hr != S_OK)
		goto DONE;

DONE:

	return (hr);
} // ParmVLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/

/* XBOX - Manually creating address objects, this function isn't required
//==================================================================================
// Create Address Interface
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.1 - CreateDirectPlay8Address Parameter Validation 
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: DPN_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT CreateInterface_Addr(HANDLE hLog)
{
	CTNSystemResult						sr;
	CTNTestResult						tr;
	
	HANDLE								hThreadHandle = NULL;
	DWORD								dwThreadID = NULL;
	
	ThreadResult						thrCreateApp;						

	BEGIN_TESTCASE
	{	
		//Initialize the thread result structure.
		thrCreateApp.hrThreadResult = DPN_OK;
		thrCreateApp.szTestDescript[0] = '\n';
		thrCreateApp.szResultDescript[0] = '\n';
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a new thread to ensure we are not calling CoInitialize!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		//Need to Throw this on another thread to ensure LobbyCreate works without CoInitialize.
		hThreadHandle = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)AddressingCreateThread,
										 (PVOID)&thrCreateApp, NULL, &dwThreadID);  

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Wait for the Application thread we just created!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		if(WaitForSingleObject(hThreadHandle, 60000) != WAIT_OBJECT_0)
		{
			DPTEST_FAIL(hLog, "Valid Create did not return within 60 seconds.", 0);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Check the results from the thread that was just run!");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION(thrCreateApp.szTestDescript);
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		if(thrCreateApp.hrThreadResult != DPN_OK)
		{
			//Print the results from the thread run.
			tr = thrCreateApp.hrThreadResult;
			DPTEST_FAIL(hLog, thrCreateApp.szResultDescript, 0);
			THROW_TESTRESULT;
		}
		
		//Dummy if that is put in to avoid compiler issue without calling Throw_SystemResult
		TESTSECTION_IF(0)
		{
			THROW_SYSTEMRESULT;
		}
		TESTSECTION_ENDIF

		FINAL_SUCCESS;
	}
	END_TESTCASE

//Cleanup:
		
	if(hThreadHandle)
	{
		CloseHandle(hThreadHandle);
	}

	return (sr);
}
*/

/* XBOX - Manually creating address objects, this function isn't required
//==================================================================================
// AddressingCreateThread
//----------------------------------------------------------------------------------
//
// Description: Addressing Thread used verify AddressCreate 
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: DPN_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT AddressingCreateThread(PVOID thrVoid)
{
	HRESULT								hr = DPN_OK;
	PDIRECTPLAY8ADDRESS					pDPAddr	= NULL;

	ThreadResult*						thrResult = (ThreadResult*)thrVoid;

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	strcpy(thrResult->szTestDescript, "DirectPlay8AddressCreate of IUnknown Interface");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	hr = DirectPlay8AddressCreate(&IID_IUnknown,
									(PVOID*)&pDPAddr,
									NULL);

	if(hr != DPNERR_INVALIDPARAM)
	{
		strcpy(thrResult->szResultDescript, "Create of IUnknown did not return INVALIDPARAM.");
		thrResult->hrThreadResult = hr;
		goto Cleanup;
	} // end if (failed executing sub test case)

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	strcpy(thrResult->szTestDescript, "DirectPlay8AddressCreate of GUID_NULL Interface");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	hr = DirectPlay8AddressCreate(&GUID_NULL,
									(PVOID*)&pDPAddr,
									NULL);
	if(hr != DPNERR_INVALIDPARAM)
	{
		strcpy(thrResult->szResultDescript, "Create of NULL GUID did not return DPNERR_INVALIDPARAM.");
		thrResult->hrThreadResult = hr;
		goto Cleanup;
	} // end if (failed executing sub test case)

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	strcpy(thrResult->szTestDescript, "Valid DirectPlay8AddressCreate");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	hr = DirectPlay8AddressCreate(&IID_IDirectPlay8Address,
								  (PVOID*)&pDPAddr,
								  NULL);

	if(hr != DPN_OK)
	{
		strcpy(thrResult->szResultDescript, "Valid Create did not return DPN_OK.");
		thrResult->hrThreadResult = hr;
		goto Cleanup;
	} // end if (failed executing sub test case)

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	strcpy(thrResult->szTestDescript, "Build from Unicode URL just the header.");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	hr = pDPAddr->BuildFromURLW(DPNA_HEADER);
	if (hr != DPN_OK)
	{
		strcpy(thrResult->szResultDescript, "Building from Unicode URL using header failed.");
		thrResult->hrThreadResult = hr;
		goto Cleanup;
	} // end if (failed building from W URL)

	
	//We were successful ... set hr = DPN_OK
	strcpy(thrResult->szTestDescript, "Addressing App Create Tests finished successfully.");
	strcpy(thrResult->szResultDescript, "Addressing App Create Tests finished successfully.");
	thrResult->hrThreadResult = DPN_OK;

Cleanup:

	if(pDPAddr != NULL)
	{
		pDPAddr->Release();
		pDPAddr = NULL;
	}
	
	return hr;
}
*/



/* XBOX - QueryInterface not available
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BQI()"
//==================================================================================
// ParmVExec_BQI
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.2 - Base QueryInterface parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BQI(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	PWRAPDP8ADDRESS					pDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
	IUnknown*						pUnknown = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_CCIWRAP));
		pDP8Address = ((PTOD_ABASICS_CCIWRAP) pvSubOutputData)->pDP8Address;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8Address, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8Address, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with IID_IDirectPlay8Address and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for GUID_NULL, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(GUID_NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with GUID_NULL and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for unknown GUID, NULL dest pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(GUID_UNKNOWN, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Querying with unknown GUID and NULL ptr didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8Address,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressIP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressIP,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIP didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;

#pragma TODO(seanwh, "QI for these interfaces has not been implemented yet!")
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressIPX");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressIPX,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIPX failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressIPX didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressModem");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressModem,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressModem failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressModem didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8AddressSerial");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressSerial,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressSerial failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8AddressSerial didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for GUID_NULL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(GUID_NULL, (PVOID*) &pUnknown);
		if (tr != DPNERR_NOINTERFACE)
		{
			DPTEST_FAIL(hLog, "Querying for GUID_NULL didn't return expected error NOINTERFACE!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown != NULL)
		{
			DPTEST_FAIL(hLog, "Querying for invalid interface returned an interface pointer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (got a pointer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for garbage GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(GUID_UNKNOWN, (PVOID*) &pUnknown);
		if (tr != DPNERR_NOINTERFACE)
		{
			DPTEST_FAIL(hLog, "Querying for unknown GUID didn't return expected error NOINTERFACE!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown != NULL)
		{
			DPTEST_FAIL(hLog, "Querying for invalid interface returned an interface pointer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (got a pointer)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pDP8AddressInternal == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for IID_IDirectPlay8Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8Address,
											(PVOID*) &pUnknown);
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)

		if (pUnknown == NULL)
		{
			DPTEST_FAIL(hLog, "Querying for IID_IDirectPlay8Address didn't return pointer!", 0);
			SETTHROW_TESTRESULT(E_NOINTERFACE);
		} // end if (didn't get pointer)

		pUnknown->Release();
		pUnknown = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_RELEASEWRAP));
		((PTID_ABASICS_RELEASEWRAP) pvSubInputData)->pDP8Address = pDP8Address;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.2.1", pvSubInputData,
												sizeof (TID_ABASICS_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8Address = NULL;


		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);

	if (pUnknown != NULL)
	{
		pUnknown->Release();
		pUnknown = NULL;
	} // end if (have random interface)

	if (pDP8Address != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BQI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BBuildW()"
//==================================================================================
// ParmVExec_BBuildW
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.3 - Base BuildFromURLW parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BBuildW(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/

	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;

	WCHAR							wszTempString[256];
	DWORD							dwSizeofTempString = NULL;
	
	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;
	
	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8AddressCreate for another unwrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pNonwrappedDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "DirectPlay8AddressCreate for another unwrapped interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed creating address)

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
*/

#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using invalid pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW((WCHAR*) 0x00000666);
		if (tr != DPNERR_INVALIDSTRING)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using invalid pointer didn't return expected error INVALIDSTRING!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using empty string");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(L"");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using invalid pointer didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using provider key name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_KEY_PROVIDER);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using provider key name didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider key name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider key name didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with no value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with no value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with invalid value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=NOT_A_GUID");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with invalid value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with TCP/IP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with TCP/IP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID - double equal sign");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"==" ENCODED_UNKNOWN_GUID);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID - double equal sign didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using provider with unknown GUID & header");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID DPNA_HEADER);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using provider with unknown GUID & header didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID and semicolon");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID and semicolon didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, no ';' no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L"#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, no ';' no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// This is invalid because there's extra crap not part of the guid

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID + extraneous junk");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L"extraneousjunk");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID + extraneous junk didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// This is invalid because there's extra crap not part of the guid

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, extraneous junk + provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" L"extraneousjunk" ENCODED_UNKNOWN_GUID);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, extraneous junk + provider with unknown GUID didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		


		// This is invalid because there's extra crap not part of the guid and
		// the header vs value is off

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, no separator, misc key & value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, no separator, misc key & value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, provider with TCP/IP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, provider with TCP/IP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, misc key & value, provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, misc key & value, provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, misc key & must encode value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MUST_ENCODE_DATA);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, misc key & must encode value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, DPNA_VALUE_TCPIPPROVIDER & miscellaneous key and value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER 
											L"=" DPNA_VALUE_TCPIPPROVIDER
											L";" MISCELLANEOUS_KEY1 
											L"=" MISCELLANEOUS_VALUE1); 
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, DPNA_VALUE_TCPIPPROVIDER & miscellaneous key and value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
	

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting size of Unicode URL built using header, DPNA_VALUE_TCPIPPROVIDER & miscellaneous key and value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wcscpy(wszTempString, 
			   DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L"\0");
		
		dwSizeofTempString = (wcslen(wszTempString)+1);

		dwURLLen = 0;

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			DPTEST_FAIL(hLog, "Xbox bug 1879 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify URL that we created using DPNA_VALUE_TCPIPPROVIDER");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			DPTEST_FAIL(hLog, "Xbox bug 1879 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, wszTempString) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, wszTempString);
			DPTEST_FAIL(hLog, "Xbox bug 1879 occurred!", 0);
			fPassed = FALSE;
//			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;


//XBox bug, repo code to verify that the PC version of DirectPlay is not the issue.
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wsprintfW(wszTempString, L"%sblahblah=sdfkjsadfhksjadhfkjhsdfjhsfsdhf", DPNA_HEADER);
		//wcscpy(pwszURL, L"%sblahblah=sdfkjsadfhksjadhfkjhsdfjhsfsdhf", DPNA_HEADER);
    
		tr = pNonwrappedDP8Address->BuildFromURLW(wszTempString);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal our address object to a wrapped object.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SetEqual Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting size of Unicode URL built using header, followed by junk info and junk value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofTempString = (wcslen(wszTempString)+1);

		dwURLLen = 0;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify URL that we created using DPNA_VALUE_TCPIPPROVIDER");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, wszTempString) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, wszTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object to a smaller string");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wsprintfW(wszTempString, L"%smark=meme", DPNA_HEADER );
		//wcscpy(pwszURL, L"%sblahblah=sdfkjsadfhksjadhfkjhsdfjhsfsdhf", DPNA_HEADER);
    
		tr = pNonwrappedDP8Address->BuildFromURLW(wszTempString);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal our address object to a wrapped object.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SetEqual Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting size of Unicode URL built using header, followed by junk info and junk value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofTempString = (wcslen(wszTempString)+1);

		dwURLLen = 0;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Verify URL that we created using DPNA_VALUE_TCPIPPROVIDER");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwSizeofTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, wszTempString) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, wszTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		
/* End of XBox bug case. */
		

/* XBOX - DPNA_VALUE_IPXPROVIDER doesn't exist on Xbox
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, DPNA_VALUE_IPXPROVIDER & miscellaneous key and value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER 
											L"=" DPNA_VALUE_IPXPROVIDER
											L";" MISCELLANEOUS_KEY1 
											L"=" MISCELLANEOUS_VALUE1); 
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, DPNA_VALUE_IPXPROVIDER & miscellaneous key and value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
*/

/* XBOX - DPNA_VALUE_MODEMPROVIDER doesn't exist on Xbox
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, DPNA_VALUE_MODEMPROVIDER & miscellaneous key and value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER 
											L"=" DPNA_VALUE_MODEMPROVIDER
											L";" MISCELLANEOUS_KEY1 
											L"=" MISCELLANEOUS_VALUE1); 
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, DPNA_VALUE_MODEMPROVIDER & miscellaneous key and value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
*/

/* XBOX - DPNA_VALUE_SERIALPROVIDER doesn't exist on Xbox
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, DPNA_VALUE_SERIALPROVIDER & miscellaneous key and value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER 
											L"=" DPNA_VALUE_SERIALPROVIDER
											L";" MISCELLANEOUS_KEY1 
											L"=" MISCELLANEOUS_VALUE1); 
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, DPNA_VALUE_SERIALPROVIDER & miscellaneous key and value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing non-wrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_RELEASE(pNonwrappedDP8Address);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BBuildW
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BBuildA()"
//==================================================================================
// ParmVExec_BBuildA
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.4 - Base BuildFromURLA parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BBuildA(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
*/



#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using invalid pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA((char*)0x00000666);
		if (tr != DPNERR_INVALIDSTRING)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using invalid pointer didn't return expected error INVALIDSTRING!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using empty string");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA("");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using invalid pointer didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using provider key name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_KEY_PROVIDER_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using provider key name didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider key name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider key name didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with no value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with no value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with invalid value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=NOT_A_GUID");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with invalid value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with TCP/IP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_TCPIP_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with TCP/IP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID - double equal sign");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "==" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID - double equal sign didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using provider with unknown GUID & header");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A DPNA_HEADER_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using provider with unknown GUID & header didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID and semicolon");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID and semicolon didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, no ';' no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A "#" NO_ENCODE_DATA_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, no ';' no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";#" NO_ENCODE_DATA_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// This is invalid because there's extra crap not part of the guid

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID + extraneous junk");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A "extraneousjunk");
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID + extraneous junk didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// This is invalid because there's extra crap not part of the guid

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, extraneous junk + provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" "extraneousjunk" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, extraneous junk + provider with unknown GUID didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)

		


		// This is invalid because there's extra crap not part of the guid and
		// the header vs value is off

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, no separator, misc key & value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, no separator, misc key & value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, misc key & value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";" MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, misc key & value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, provider with TCP/IP GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";" DPNA_KEY_PROVIDER_A "=" ENCODED_TCPIP_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, provider with TCP/IP GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, misc key & value, provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A ";" DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, misc key & value, provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, misc key & must encode value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MUST_ENCODE_DATA_A);
		if (tr != DPNERR_INVALIDURL)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, misc key & must encode value didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, misc key & value while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";" MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, misc key & value while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header, provider with unknown GUID, misc key & value unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A ";" MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header, provider with unknown GUID, misc key & value unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BBuildA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BDuplicate()"
//==================================================================================
// ParmVExec_BDuplicate
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.5 - Base Duplicate parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BDuplicate(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;
	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Duplicate(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Duplicating using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating without object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating without object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)



		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating with object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)

		DPTEST_TRACE(hLog, "Got duplicate object at %x.", 1, pNonwrappedDP8Address);




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pNonwrappedDP8Address->GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pNonwrappedDP8Address->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building original object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pNonwrappedDP8Address->GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// We're done with the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;







/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Duplicate(&pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Duplicating with object being set while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Didn't get a valid object pointer returned!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)



		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_RELEASE(pNonwrappedDP8Address);
	SAFE_LOCALFREE(pwszURL);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BDuplicate
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BSetEqual()"
//==================================================================================
// ParmVExec_BSetEqual
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.6 - Base Set Equal parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BSetEqual(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;
	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetEqual(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "SetEqual using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual to object without being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "SetEqual without object being set didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address != NULL)
		{
			DPTEST_FAIL(hLog, "Data returned with invalid object pointer!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8AddressCreate for another unwrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pNonwrappedDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "DirectPlay8AddressCreate for another unwrapped interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed creating address)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal from an Empty Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Empty Object to an Empty Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal from pass in Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Valid Object to an Empty Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SetEqual main object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;


		/* Pass in a smaller URL in the SetEqual API. */

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object to just a header");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal from pass in Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Valid Object to an Empty Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SetEqual main object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER) + 1;

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		
		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Equal Object and overwrite current Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Set Equal from an Valid Object to overwrite Object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting SetEqual main object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) + 1;

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting duplicate object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;


/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "SetEqual with object being set while locked didn't return DPNERR_NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)



		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("SetEqual after object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetEqual(pNonwrappedDP8Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "SetEqual after object being locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

		// We don't care about the copy, release it

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing Nonwrapped object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_RELEASE(pNonwrappedDP8Address);
	SAFE_LOCALFREE(pwszURL);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BSetEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BIsEqual()"
//==================================================================================
// ParmVExec_BIsEqual
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.7 - Base Is Equal parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BIsEqual(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	PDIRECTPLAY8ADDRESS				pNonwrappedDP8Address = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_IsEqual(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "IsEqual using NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual to object without being created");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "IsEqual without object being set didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address != NULL)
		{
			DPTEST_FAIL(hLog, "Data returned with invalid object pointer!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8AddressCreate for another unwrapped interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pNonwrappedDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "DirectPlay8AddressCreate for another unwrapped interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed creating address)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from an Empty Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Is Equal from an Empty Object to an Empty Object did not return DPNSUCCESS_EQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our passed in address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pNonwrappedDP8Address->BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an Empty Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to an Empty Object didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Set Data in our main address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building main Address from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an equal Set Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to a Same set Object didn't return DPNSUCCESS_EQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-building original object from Unicode URL using header & misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building passed in object from Unicode URL using header & misc key 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Is Equal from pass in Object to an different Set Object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual from an Valid Object to a Dirrerent set Object didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed duplicating)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Object pointer cleared when being set with Empty Address Object!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("IsEqual with object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_IsEqual(pNonwrappedDP8Address);
		if (tr != DPNSUCCESS_NOTEQUAL)
		{
			DPTEST_FAIL(hLog, "IsEqual with object being set while locked didn't return DPNSUCCESS_NOTEQUAL!", 0);
			THROW_TESTRESULT;
		} // end if (failed IsEqual)

		if (pNonwrappedDP8Address == NULL)
		{
			DPTEST_FAIL(hLog, "Passed in object was set to NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (didn't get an item back)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing duplicate");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pNonwrappedDP8Address->Release();
		pNonwrappedDP8Address = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_RELEASE(pNonwrappedDP8Address);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BIsEqual
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BClear()"
//==================================================================================
// ParmVExec_BClear
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.8 - Base Clear parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BClear(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing without object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing without object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing with object being set");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing with object being set failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing without object being set while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Clearing without object being set while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)

	return (sr);
} // ParmVExec_BClear
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetURLW()"
//==================================================================================
// ParmVExec_BGetURLW
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.9 - Base GetURLW parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetURLW(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Unicode URL with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetURLW(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Unicode URL with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		
		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, DPNA_HEADER);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, to verify size of buffer is reduced.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, DPNA_HEADER);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, ((dwURLLen * sizeof (WCHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pwszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pwszURL);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetURLW
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetURLA()"
//==================================================================================
// ParmVExec_BGetURLA
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.10 - Base GetURLA parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetURLA(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	CHAR*							pszURL = NULL;
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Ansi URL with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetURLA(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting Ansi URL with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A) + 1;

		tr = pDP8Address->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		
		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting non-set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL, DPNA_HEADER_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) + 1;

		tr = pDP8Address->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Ansi URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A) + 1;

		tr = pDP8Address->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Ansi URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting Ansi URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Ansi URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A MISCELLANEOUS_KEY1_A "=" MISCELLANEOUS_VALUE1_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Ansi URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLA(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Ansi URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from A URL)




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Unicode URL - size while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = strlen(DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) + 1;

		tr = pDP8Address->DPA_GetURLA(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL - size while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object Ansi URL while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(CHAR*, pszURL, ((dwURLLen * sizeof (CHAR)) + BUFFERPADDING_SIZE));

		FillWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);


		tr = pDP8Address->DPA_GetURLA(pszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Ansi URL while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the size is still correct/expected.
		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "Size retrieved is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		// Make sure the URL retrieved is expected.
		if (strcmp(pszURL, DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pszURL,
				DPNA_HEADER_A DPNA_KEY_PROVIDER_A "=" ENCODED_UNKNOWN_GUID_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(pszURL + dwURLLen, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pszURL);
		pszURL = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pszURL);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetURLA
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetSP()"
//==================================================================================
// ParmVExec_BGetSP
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.11 - Base GetSP parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetSP(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	GUID							guidSP;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object SP with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetSP(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting non-set object SP with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting SP)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object SP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		guidSP = GUID_UNKNOWN;

		tr = pDP8Address->DPA_GetSP(&guidSP);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting non-set object SP didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting SP)

		if (memcmp(&guidSP, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "SP GUID memory was stomped (%g != %g)!",
				2, &guidSP, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (didn't get expected GUID)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object SP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&guidSP, sizeof (GUID));

		tr = pDP8Address->DPA_GetSP(&guidSP);
		if (tr != DPN_OK)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting set object SP failed!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting SP)

		if (memcmp(&guidSP, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Didn't get expected SP GUID (%g != %g)!",
					2, &guidSP, &GUID_UNKNOWN);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (didn't get expected GUID)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object SP while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&guidSP, sizeof (GUID));

		tr = pDP8Address->DPA_GetSP(&guidSP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object SP while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting SP)

		if (memcmp(&guidSP, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected SP GUID (%g != %g)!",
				2, &guidSP, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetSP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetUserData()"
//==================================================================================
// ParmVExec_BGetUserData
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.12 - Base GetUserData parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetUserData(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	PVOID							pvUserData = NULL;
	DWORD							dwDataSize;
	DWORD							dwExpectedDataSize;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting user data with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetUserData(NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting user data with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;

		tr = pDP8Address->DPA_GetUserData(NULL, &dwDataSize);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting non-set object user data didn't return DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be empty.
		if (dwDataSize != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get 0 size for buffer!", 1, dwDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not 0 size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;

		tr = pDP8Address->DPA_GetUserData(NULL, &dwDataSize);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer didn't return DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be empty.
		if (dwDataSize != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get 0 size for buffer!", 1, dwDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not 0 size)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, no-encode user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";#" NO_ENCODE_DATA);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, no-encode user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;
		dwExpectedDataSize = strlen(NO_ENCODE_DATA_A);

		tr = pDP8Address->DPA_GetUserData(NULL, &dwDataSize);

		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be exactly enough to hold the special string.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Retrieved unexpected size for buffer (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvUserData, dwDataSize + BUFFERPADDING_SIZE);

		FillWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Address->DPA_GetUserData(pvUserData, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object user data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Size shouldn't have changed.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Size for buffer was unexpectedly changed (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)

		// Make sure we got the expected data back out.
		if (memcmp(pvUserData, NO_ENCODE_DATA_A, dwDataSize) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected user data (%u bytes of data at %x != \"%s\"!",
				3, dwDataSize, pvUserData, NO_ENCODE_DATA_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected user data)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pvUserData);
		pvUserData = NULL;




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data with NULL buffer while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataSize = 0;
		dwExpectedDataSize = strlen(NO_ENCODE_DATA_A);

		tr = pDP8Address->DPA_GetUserData(NULL, &dwDataSize);

		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object user data with NULL buffer while locked didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Should be exactly enough to hold the special string.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Retrieved unexpected size for buffer (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object user data while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvUserData, dwDataSize + BUFFERPADDING_SIZE);

		FillWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Address->DPA_GetUserData(pvUserData, &dwDataSize);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object user data while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting user data)

		// Size shouldn't have changed.
		if (dwDataSize != dwExpectedDataSize)
		{
			DPTEST_FAIL(hLog, "Size for buffer was unexpectedly changed (%u != %u)!",
				2, dwDataSize, dwExpectedDataSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected data size)

		// Make sure we got the expected data back out.
		if (memcmp(pvUserData, NO_ENCODE_DATA_A, dwDataSize) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected user data (%u bytes of data at %x != \"%s\"!",
				3, dwDataSize, pvUserData, NO_ENCODE_DATA_A);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected user data)

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((LPBYTE) pvUserData) + dwDataSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pvUserData);
		pvUserData = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pvUserData);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BSetSP()"
//==================================================================================
// ParmVExec_BSetSP
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.13 - Base SetSP parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BSetSP(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetSP(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			if(tr == DPN_OK)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Setting object SP with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed setting SP)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP with GUID_UNKNOWN");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetSP(&GUID_UNKNOWN);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting SP with GUID_UNKNOWN failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting SP)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP on built object with CLSID_DP8SP_TCPIP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting SP on built object with CLSID_DP8SP_TCPIP failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting SP)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP on built object with CLSID_DP8SP_TCPIP while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Setting SP on built object with CLSID_DP8SP_TCPIP while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting SP)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting SP on built object with CLSID_DP8SP_TCPIP unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting SP on built object with CLSID_DP8SP_TCPIP unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting SP)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BSetSP
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BSetUserData()"
//==================================================================================
// ParmVExec_BSetUserData
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.14 - Base SetUserData parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BSetUserData(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with NULL pointer and 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with NULL pointer and 0 size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with NULL pointer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NULL, 666);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting user data with NULL pointer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)
*/



#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		/*
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with invalid pointer and 0 size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData((PVOID) 0x00000666, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with invalid pointer and 0 size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with invalid pointer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData((PVOID) 0x00000666, 666);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting user data with invalid pointer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with no-encode data and zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NO_ENCODE_DATA_A, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with no-encode data and zero size failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data with no-encode data");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NO_ENCODE_DATA_A,
										strlen(NO_ENCODE_DATA_A));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data with no-encode data failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data back to nothing");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data to nothing while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NULL, 0);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting user data back to nothing unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetUserData(NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting user data back to nothing unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting user data)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BSetUserData
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetNumComponents()"
//==================================================================================
// ParmVExec_BGetNumComponents
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.15 - Base GetNumComponents parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetNumComponents(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	DWORD							dwNumComponents;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetNumComponents(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting num components with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components for unset object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 666;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are no components.
		if (dwNumComponents != 0)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 0 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 0 components)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & provider with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & provider with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there is 1 component.
		if (dwNumComponents != 1)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 1 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 1 component)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are 2 components.
		if (dwNumComponents != 2)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 2 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 2 components)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, misc key & value 1, misc key & value 2");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" MISCELLANEOUS_KEY2 L"=" MISCELLANEOUS_VALUE2);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, misc key & value 1, misc key & value 2 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are 2 components.
		if (dwNumComponents != 2)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 2 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 2 components)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value 1, misc key & value 2");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" MISCELLANEOUS_KEY2 L"=" MISCELLANEOUS_VALUE2);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value 1, misc key & value 2 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are 3 components.
		if (dwNumComponents != 3)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 3 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 3 components)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value 1, misc key & value 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value 1, misc key & value 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components for unset object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are 2 components.
		if (dwNumComponents != 2)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 2 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 2 components)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting num components while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNumComponents = 0;

		tr = pDP8Address->DPA_GetNumComponents(&dwNumComponents);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting num components while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting num components)

		// Make sure we are told that there are 2 components.
		if (dwNumComponents != 2)
		{
			DPTEST_FAIL(hLog, "Num components retrieved isn't 2 (it's %u)!",
				1, dwNumComponents);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get 2 components)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetNumComponents
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetByName()"
//==================================================================================
// ParmVExec_BGetByName
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.16 - Base GetComponentByName parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetByName(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	DWORD							dwBufferSize;
	DWORD							dwExpectedBufferSize;
	DWORD							dwDataType;
	PVOID							pvBuffer = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetComponentByName(NULL, NULL, NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name with NULL name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(NULL, NULL, &dwBufferSize, &dwDataType);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name with NULL name didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either buffer size (%u != 0) or buffer type (%u != 666) was set!",
				2, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name with NULL size pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(DPNA_KEY_PROVIDER, NULL,
												NULL, &dwDataType);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name with NULL size pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwDataType != 666)
		{
			DPTEST_FAIL(hLog, "Buffer type was set (%u != 666)!", 1, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name with NULL type pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;

		tr = pDP8Address->DPA_GetComponentByName(DPNA_KEY_PROVIDER, NULL,
												&dwBufferSize, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name with NULL type pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size was set (%u != 0)!", 1, dwBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name with non-set object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY1, NULL,
												&dwBufferSize, &dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name with non-set object didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either buffer size (%u != 0) or buffer type (%u != 666) was set!",
				2, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by non-existent Unicode name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY2, NULL,
												&dwBufferSize, &dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component by non-existent Unicode name didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either buffer size (%u != 0) or buffer type (%u != 666) was set!",
				2, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - provider - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwExpectedBufferSize = sizeof (GUID);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(DPNA_KEY_PROVIDER, NULL,
												&dwBufferSize, &dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - provider - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_GUID)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - provider");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwBufferSize);

		tr = pDP8Address->DPA_GetComponentByName(DPNA_KEY_PROVIDER, pvBuffer,
												&dwBufferSize, &dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - provider failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_GUID)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the data is correct
		if (memcmp(pvBuffer, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected GUID (%g != %g)!",
				2, pvBuffer, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - misc key 1 - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwExpectedBufferSize = (wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY1, NULL,
												&dwBufferSize, &dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - misc key - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - misc key 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwBufferSize);

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY1, pvBuffer,
												&dwBufferSize, &dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - misc key failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the data is correct
		if (wcscmp((WCHAR*) pvBuffer, MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected string (\"%S\" != \"%S\")!",
				2, pvBuffer, MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - misc key 1 while locked - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwExpectedBufferSize = (wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY1, NULL,
												&dwBufferSize, &dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - misc key 1 while locked - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component by Unicode name - misc key 1 while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwBufferSize);

		tr = pDP8Address->DPA_GetComponentByName(MISCELLANEOUS_KEY1, pvBuffer,
												&dwBufferSize, &dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component by Unicode name - misc key 1 while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the data is correct
		if (wcscmp((WCHAR*) pvBuffer, MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected string (\"%S\" != \"%S\")!",
				2, pvBuffer, MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pvBuffer);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetByName
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetByIndex()"
//==================================================================================
// ParmVExec_BGetByIndex
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.17 - Base GetComponentByIndex parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetByIndex(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	DWORD							dwNameLen;
	DWORD							dwExpectedNameLen;
	DWORD							dwBufferSize;
	DWORD							dwExpectedBufferSize;
	DWORD							dwDataType;
	WCHAR*							pwszName = NULL;
	PVOID							pvBuffer = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 with NULL pointers");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, NULL, NULL, NULL, NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 with NULL pointers didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 with NULL name len");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, NULL,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 with NULL name len didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either buffer size (%u != 0) or buffer type (%u != 666) was set!",
				2, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 with NULL buffer size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, &dwNameLen,
												NULL, NULL,
												&dwDataType);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 with NULL buffer size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) or buffer type (%u != 666) was set!",
				2, dwNameLen, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 with NULL data type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 with NULL buffer size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0))
		{
			DPTEST_FAIL(hLog, "Either name (%u != 0) or buffer size (%u != 0) was set!",
				2, dwNameLen, dwBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 on non-set object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 on non-set object didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) buffer size (%u != 0) or buffer type (%u != 666) was set!",
				3, dwNameLen, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 1 on non-set object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(1, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component W 1 on non-set object didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) buffer size (%u != 0) or buffer type (%u != 666) was set!",
				3, dwNameLen, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W DPNA_INDEX_INVALID on non-set object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(DPNA_INDEX_INVALID, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component W DPNA_INDEX_INVALID on non-set object didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) buffer size (%u != 0) or buffer type (%u != 666) was set!",
				3, dwNameLen, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header, provider with unknown GUID, misc key & value 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header, provider with unknown GUID, misc key & value 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 2");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(2, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component W 2 didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) buffer size (%u != 0) or buffer type (%u != 666) was set!",
				3, dwNameLen, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W DPNA_INDEX_INVALID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwBufferSize = 0;
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(DPNA_INDEX_INVALID, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			DPTEST_FAIL(hLog, "Getting component W DPNA_INDEX_INVALID didn't return expected error DOESNOTEXIST!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if ((dwNameLen != 0) || (dwBufferSize != 0) || (dwDataType != 666))
		{
			DPTEST_FAIL(hLog, "Either name len (%u != 0) buffer size (%u != 0) or buffer type (%u != 666) was set!",
				3, dwNameLen, dwBufferSize, dwDataType);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (parameter value was altered)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0 - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwExpectedNameLen = wcslen(DPNA_KEY_PROVIDER) + 1;
		dwBufferSize = 0;
		dwExpectedBufferSize = sizeof (GUID);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(0, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Received unexpected name length (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_GUID)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszName, dwNameLen * sizeof (WCHAR));
		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwExpectedBufferSize);

		tr = pDP8Address->DPA_GetComponentByIndex(0, pwszName, &dwNameLen,
												pvBuffer, &dwBufferSize,
												&dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component W 0 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Name length changed (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_GUID)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_GUID);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the name is correct
		if (wcscmp(pwszName, DPNA_KEY_PROVIDER) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected name (\"%S\" != \"%S\")!",
				2, pwszName, DPNA_KEY_PROVIDER);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name)

		// Make sure the data is correct
		if (memcmp(pvBuffer, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected GUID (%g != %g)!",
				2, pvBuffer, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;
		SAFE_LOCALFREE(pwszName);
		pwszName = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 1 - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwExpectedNameLen = wcslen(MISCELLANEOUS_KEY1) + 1;
		dwBufferSize = 0;
		dwExpectedBufferSize = (wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(1, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component W 1 - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Received unexpected name length (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 1");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszName, dwNameLen * sizeof (WCHAR));
		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwExpectedBufferSize);

		tr = pDP8Address->DPA_GetComponentByIndex(1, pwszName, &dwNameLen,
												pvBuffer, &dwBufferSize,
												&dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component W 1 failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Name length changed (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the name is correct
		if (wcscmp(pwszName, MISCELLANEOUS_KEY1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected name (\"%S\" != \"%S\")!",
				2, pwszName, MISCELLANEOUS_KEY1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name)

		// Make sure the data is correct
		if (wcscmp((WCHAR*) pvBuffer, MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected data (\"%S\" != \"%S\")!",
				2, pvBuffer, MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;
		SAFE_LOCALFREE(pwszName);
		pwszName = NULL;





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 1 while locked - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwNameLen = 0;
		dwExpectedNameLen = wcslen(MISCELLANEOUS_KEY1) + 1;
		dwBufferSize = 0;
		dwExpectedBufferSize = (wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR);
		dwDataType = 666;

		tr = pDP8Address->DPA_GetComponentByIndex(1, NULL, &dwNameLen,
												NULL, &dwBufferSize,
												&dwDataType);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting component W 1 while locked - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Received unexpected name length (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Received unexpected buffer size (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Recieved unexpected buffer type (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting component W 1 while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszName, dwNameLen * sizeof (WCHAR));
		LOCALALLOC_OR_THROW(PVOID, pvBuffer, dwExpectedBufferSize);

		tr = pDP8Address->DPA_GetComponentByIndex(1, pwszName, &dwNameLen,
												pvBuffer, &dwBufferSize,
												&dwDataType);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting component W 1 while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting component by name W)

		if (dwNameLen != dwExpectedNameLen)
		{
			DPTEST_FAIL(hLog, "Name length changed (%u != %u)!",
				2, dwNameLen, dwExpectedNameLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name len)

		if (dwBufferSize != dwExpectedBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size changed (%u != %u)!",
				2, dwBufferSize, dwExpectedBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected size)

		if (dwDataType != DPNA_DATATYPE_STRING)
		{
			DPTEST_FAIL(hLog, "Buffer type changed (%u != %u)!",
				2, dwDataType, DPNA_DATATYPE_STRING);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected data type)

		// Make sure the name is correct
		if (wcscmp(pwszName, MISCELLANEOUS_KEY1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected name (\"%S\" != \"%S\")!",
				2, pwszName, MISCELLANEOUS_KEY1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected name)

		// Make sure the data is correct
		if (wcscmp((WCHAR*) pvBuffer, MISCELLANEOUS_VALUE1) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected data (\"%S\" != \"%S\")!",
				2, pvBuffer, MISCELLANEOUS_VALUE1);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)

		SAFE_LOCALFREE(pvBuffer);
		pvBuffer = NULL;
		SAFE_LOCALFREE(pwszName);
		pwszName = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pvBuffer);
	SAFE_LOCALFREE(pwszName);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetByIndex
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BAdd()"
//==================================================================================
// ParmVExec_BAdd
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.18 - Base AddComponent parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BAdd(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	DWORD							dwURLLen;
	DWORD							dwExpectedURLLen;
	WCHAR*							pwszURL = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W with NULL pointers, 0 size, 0 type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(NULL, NULL, 0, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Adding component W with NULL pointers, 0 size, 0 type didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W with no data, 0 type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1, NULL, 0, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Adding component W with no data, 0 type didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W with 0 type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Adding component W with 0 type didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W provider with GUID type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(DPNA_KEY_PROVIDER,
											&GUID_UNKNOWN,
											sizeof (GUID),
											DPNA_DATATYPE_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W provider with GUID type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W provider with binary type");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(BINARYDATA_KEY,
											&c_abBinaryData,
											sizeof (c_abBinaryData),
											DPNA_DATATYPE_BINARY);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W provider with binary type failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "URL length is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected length)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof (WCHAR));

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "URL length changed (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected length)
		

		// Make sure the URL we have is what we should have gotten.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected URL (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" MISCELLANEOUS_VALUE1 L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected URL)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W with string that must be encoded, same key name");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MUST_ENCODE_DATA,
											(wcslen(MUST_ENCODE_DATA) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string that must be encoded, same key name failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwURLLen = 0;
		dwExpectedURLLen = wcslen(DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" ENCODED_MUST_ENCODE_DATA L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA) + 1;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "URL length is unexpected (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected length)
		



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Retrieving Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, dwURLLen * sizeof (WCHAR));

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Retrieving Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		if (dwURLLen != dwExpectedURLLen)
		{
			DPTEST_FAIL(hLog, "URL length changed (%u != %u)!",
				2, dwURLLen, dwExpectedURLLen);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected length)
		

		// Make sure the URL we have is what we should have gotten.
		if (wcscmp(pwszURL, DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" ENCODED_MUST_ENCODE_DATA L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected URL (\"%S\" != \"%S\")!",
				2, pwszURL,
				DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" MISCELLANEOUS_KEY1 L"=" ENCODED_MUST_ENCODE_DATA L";" BINARYDATA_KEY L"=" ENCODED_BINARYDATA);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected URL)

		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;




/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Adding component W misc key with string type unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_AddComponent(MISCELLANEOUS_KEY1,
											MISCELLANEOUS_VALUE1,
											(wcslen(MISCELLANEOUS_VALUE1) + 1) * sizeof (WCHAR),
											DPNA_DATATYPE_STRING);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Adding component W with string type unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed adding component W)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/
	SAFE_LOCALFREE(pwszURL);

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BAdd
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BGetDevice()"
//==================================================================================
// ParmVExec_BGetDevice
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.19 - Base GetDevice parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BGetDevice(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/
	GUID							guidDevice;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object device with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_GetDevice(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting non-set object device with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting device)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting non-set object device");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		guidDevice = GUID_UNKNOWN;

		tr = pDP8Address->DPA_GetDevice(&guidDevice);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting non-set object device didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting device)

		if (memcmp(&guidDevice, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "Device GUID memory was stomped (%g != %g)!",
				2, &guidDevice, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (didn't get expected GUID)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & device with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & device with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object device");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&guidDevice, sizeof (GUID));

		tr = pDP8Address->DPA_GetDevice(&guidDevice);
		if (tr != DPN_OK)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Getting set object device failed!", 0);
				THROW_TESTRESULT;
			}
		} // end if (failed getting device)

		if (memcmp(&guidDevice, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Didn't get expected device GUID (%g != %g)!",
					2, &guidDevice, &GUID_UNKNOWN);
				SETTHROW_TESTRESULT(ERROR_NO_MATCH);
			}
		} // end if (didn't get expected GUID)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting set object device while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&guidDevice, sizeof (GUID));

		tr = pDP8Address->DPA_GetDevice(&guidDevice);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object device while locked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting device)

		if (memcmp(&guidDevice, &GUID_UNKNOWN, sizeof (GUID)) != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get expected device GUID (%g != %g)!",
				2, &guidDevice, &GUID_UNKNOWN);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (didn't get expected GUID)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BGetDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BSetDevice()"
//==================================================================================
// ParmVExec_BSetDevice
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.20 - Base SetDevice parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BSetDevice(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
/* XBOX - No input and output data
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
*/
	PWRAPDP8ADDRESS					pDP8Address = NULL;
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;
*/



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Address = new CWrapDP8Address(hLog);
		if (pDP8Address == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Address->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with NULL pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetDevice(NULL);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting object device with NULL pointer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device with GUID_UNKNOWN");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetDevice(&GUID_UNKNOWN);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device with GUID_UNKNOWN failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from Unicode URL using header & device with unknown GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromURLW(DPNA_HEADER DPNA_KEY_DEVICE L"=" ENCODED_UNKNOWN_GUID);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using header & device with unknown GUID failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device on built object with CLSID_DP8SP_TCPIP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetDevice(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device on built object with CLSID_DP8SP_TCPIP failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)





/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device on built object with CLSID_DP8SP_TCPIP while locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetDevice(&CLSID_DP8SP_TCPIP);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Setting device on built object with CLSID_DP8SP_TCPIP while locked didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting device on built object with CLSID_DP8SP_TCPIP unlocked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_SetDevice(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting device on built object with CLSID_DP8SP_TCPIP unlocked failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed setting device)
*/



/* XBOX - IDirectPlay8AddressInternal doesn't exist
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Peer object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Address);
		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


/* XBOX - No input and output data
	SAFE_LOCALFREE(pvSubInputData);
*/
/* XBOX - IDirectPlay8AddressInternal doesn't exist
	SAFE_RELEASE(pDP8AddressInternal);
*/

	if (pDP8Address != NULL)
	{
		// Ignore error
/* XBOX - No address list used
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
*/
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BSetDevice
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







/* XBOX - IDirectPlay8AddressInternal doesn't exist
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BLockUnlock()"
//==================================================================================
// ParmVExec_BLockUnlock
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.21 - Base Lock and UnLock parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BLockUnlock(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	PWRAPDP8ADDRESS					pDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_CCIWRAP));
		pDP8Address = ((PTOD_ABASICS_CCIWRAP) pvSubOutputData)->pDP8Address;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking object that's not locked");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Unlocking address object didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Clearing object didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Clearing object didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Clearing object didn't return expected error NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Clearing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_Clear();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Clearing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed clearing object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_RELEASEWRAP));
		((PTID_ABASICS_RELEASEWRAP) pvSubInputData)->pDP8Address = pDP8Address;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.2.1", pvSubInputData,
												sizeof (TID_ABASICS_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);

	if (pDP8Address != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BLockUnlock
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





/* XBOX - BuildFromDPADDR not supported
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVExec_BBuildFromDPADDR()"
//==================================================================================
// ParmVExec_BBuildFromDPADDR
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.22 - Base BuilfFromDPADDRESS parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVExec_BBuildDPADDR(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PTNRESULT						pSubResult;
	PVOID							pvSubInputData = NULL;
	PVOID							pvSubOutputData;
	DWORD							dwSubOutputDataSize;
	PWRAPDP8ADDRESS					pDP8Address = NULL;
	PDIRECTPLAY8ADDRESSINTERNAL		pDP8AddressInternal = NULL;

	LPDIRECTPLAYLOBBY2				lpDPLobby2 = NULL; // may be cast to a 2A version

	WCHAR							wszTempString[256];
	DWORD							dwSizeofTempString = NULL;
	LPVOID							lpDP4Address = NULL;
	DWORD							dwSizeofDP4Address = NULL;

	WCHAR*							pwszURL = NULL;
	DWORD							dwURLLen = NULL;

	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.1.1", NULL, 0,
												1, pTNecd->iTesterNum);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:CCIWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.1.1",
									"Creating DirectPlay8Address object failed!");

		// Otherwise get the object created.
		CHECKANDGET_SUBOUTPUTDATA(pSubResult,
									pvSubOutputData,
									dwSubOutputDataSize,
									sizeof (TOD_ABASICS_CCIWRAP));
		pDP8Address = ((PTOD_ABASICS_CCIWRAP) pvSubOutputData)->pDP8Address;


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("BuildDPAddress, NULL Addr, NULL Size.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromDPADDRESS(NULL, NULL);
		if(tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Pass in NULL Addr and Size didn't return expected error DPNERR_INVALIDPARAM!",0);
			THROW_TESTRESULT;
		}

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("BuildDPAddress, NULL Addr, value in size.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofTempString = 16;

		tr = pDP8Address->DPA_BuildFromDPADDRESS(NULL, dwSizeofTempString);
		if(tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Pass in NULL Addr and valid Size didn't return expected error DPNERR_INVALIDPOINTER!",0);
			THROW_TESTRESULT;
		}

		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("BuildDPAddress, Valid Address, NULL size.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wcscpy(wszTempString,L"");
		dwSizeofTempString = wcslen(wszTempString) * sizeof(WCHAR);

		tr = pDP8Address->DPA_BuildFromDPADDRESS(wszTempString, NULL);
		if(tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Pass in Valid Addr and NULL(0) size didn't return expected INVALIDPARAM!",0);
			THROW_TESTRESULT;
		}


#pragma BUGBUG(vanceo, "Figure out how to work around windbg still breaking on this")
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building from URL using invalid pointer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_BuildFromDPADDRESS((void*) 0x00000666, NULL);
		if (tr != DPNERR_INVALIDSTRING)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using invalid pointer didn't return expected error INVALIDSTRING!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building using empty string");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wcscpy(wszTempString,L"");
		dwSizeofTempString = (wcslen(wszTempString)+1) * sizeof(WCHAR);

		tr = pDP8Address->DPA_BuildFromDPADDRESS(wszTempString, dwSizeofTempString);
		if (tr != DPNERR_INVALIDADDRESSFORMAT)
		{
			DPTEST_FAIL(hLog, "Building from Unicode URL using invalid pointer didn't return expected error INVALIDURL!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		

		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a DirectPlay4Lobby object to get address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		// We need a temporary lobby object, so create one.
		sr = CoCreateInstance(CLSID_DirectPlayLobby, NULL, CLSCTX_INPROC_SERVER,
								IID_IDirectPlayLobby2, (LPVOID*) (&lpDPLobby2));
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create instance of IDirectPlayLobby2!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get size for a DirectPlay4Lobby Address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofDP4Address = 0;    //Start with a zero size buffer.
		tr = lpDPLobby2->CreateAddress(CLSID_DP8SP_TCPIP,
									   DPAID_INet,
									   FAKE_TCPIPADDRESS_A,
									   strlen(FAKE_TCPIPADDRESS_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address didn't return DPERR_BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a DirectPlay4Lobby Address with valid buffer.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PVOID, lpDP4Address, dwSizeofDP4Address);
		
		tr = lpDPLobby2->CreateAddress(CLSID_DP8SP_TCPIP,
									   DPAID_INet,
									   FAKE_TCPIPADDRESS_A,
									   strlen(FAKE_TCPIPADDRESS_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address with valid buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building using DP4 Created Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromDPADDRESS(lpDP4Address, dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building Address from valid DPlay4 Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting DPlay8 Address  object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wcscpy(wszTempString, 
			   DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_TCPIP_GUID L";" DPNA_KEY_HOSTNAME L"=" FAKE_TCPIPADDRESS L"\0");
		
		dwSizeofTempString = (wcslen(wszTempString)+1);

		dwURLLen = 0;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
		
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "URL Return size does not equal the expected size.", 0);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed getting Unicode URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting DPlay8 Address object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, (dwURLLen * sizeof (WCHAR)));

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, wszTempString) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, wszTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		
		
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;
		
		SAFE_LOCALFREE(lpDP4Address);
		lpDP4Address = NULL;
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get size for a DirectPlay4Lobby Address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofDP4Address = 0;    //Start with a zero size buffer.
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address didn't return DPERR_BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a DirectPlay4Lobby Address with valid buffer.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PVOID, lpDP4Address, dwSizeofDP4Address);
		
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address with valid buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)


		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building using DP4 Created Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromDPADDRESS(lpDP4Address, dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building Address from valid DPlay4 Address failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed building from W URL)

		
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting DPlay8 Address  object Unicode URL - size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		wcscpy(wszTempString, 
			   DPNA_HEADER DPNA_KEY_PROVIDER L"=" ENCODED_UNKNOWN_GUID L";" DPNA_KEY_HOSTNAME L"=" MISCELLANEOUS_VALUE1 L"\0");
		
		dwSizeofTempString = (wcslen(wszTempString)+1);

		dwURLLen = 0;

		tr = pDP8Address->DPA_GetURLW(NULL, &dwURLLen);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL - size didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)
		
		if (dwURLLen != dwSizeofTempString)
		{
			DPTEST_FAIL(hLog, "URL Return size does not equal the expected size.", 0);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (failed getting Unicode URL)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting DPlay8 Address object Unicode URL");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(WCHAR*, pwszURL, (dwURLLen * sizeof (WCHAR)));

		tr = pDP8Address->DPA_GetURLW(pwszURL, &dwURLLen);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting set object Unicode URL failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed getting Unicode URL)

		// Make sure the URL retrieved is expected.
		if (wcscmp(pwszURL, wszTempString) != 0)
		{
			DPTEST_FAIL(hLog, "URL retrieved is unexpected (\"%S\" != \"%S\")!",
				2, pwszURL, wszTempString);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (not expected size)
		

		//Free the URL String
		SAFE_LOCALFREE(pwszURL);
		pwszURL = NULL;

		//Free the DPlay4 Object
		SAFE_LOCALFREE(lpDP4Address);
		lpDP4Address = NULL;

	
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Querying for internal interface");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->DPA_QueryInterface(IID_IDirectPlay8AddressInternal,
											(PVOID*) &pDP8AddressInternal);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Querying for internal interface failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed querying for interface)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Locking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->Lock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Locking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed locking address object)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get size for a DirectPlay4Lobby Address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofDP4Address = 0;    //Start with a zero size buffer.
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address didn't return DPERR_BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a DirectPlay4Lobby Address with valid buffer.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PVOID, lpDP4Address, dwSizeofDP4Address);
		
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address with valid buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building using DP4 Created Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromDPADDRESS(lpDP4Address, dwSizeofDP4Address);
		if (tr != DPNERR_NOTALLOWED)
		{
			DPTEST_FAIL(hLog, "Building Locked Address from valid DPlay4 didn't return NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building)

		
		SAFE_LOCALFREE(lpDP4Address);
		lpDP4Address = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Unlocking address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressInternal->UnLock();
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Unlocking address object failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed unlocking address object)


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Get size for a DirectPlay4Lobby Address.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		dwSizeofDP4Address = 0;    //Start with a zero size buffer.
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address didn't return DPERR_BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Create a DirectPlay4Lobby Address with valid buffer.");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		LOCALALLOC_OR_THROW(PVOID, lpDP4Address, dwSizeofDP4Address);
		
		tr = lpDPLobby2->CreateAddress(GUID_UNKNOWN,
									   DPAID_INet,
									   MISCELLANEOUS_VALUE1_A,
									   strlen(MISCELLANEOUS_VALUE1_A) + 1,
									   lpDP4Address,
									   &dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Create DirectPlay4 Address with valid buffer failed!", 0);
			THROW_TESTRESULT;
		} // end if (failed executing sub test case)

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Building using DP4 Created Address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		tr = pDP8Address->DPA_BuildFromDPADDRESS(lpDP4Address, dwSizeofDP4Address);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Building Locked Address from valid DPlay4 didn't return NOTALLOWED!", 0);
			THROW_TESTRESULT;
		} // end if (failed building)

		
		SAFE_LOCALFREE(lpDP4Address);
		lpDP4Address = NULL;


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Release the Locked Internal address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		pDP8AddressInternal->Release();
		pDP8AddressInternal = NULL;

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay4 Lobby interface and release address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		lpDPLobby2->Release();
		lpDPLobby2 = NULL;
	
		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PVOID, pvSubInputData, sizeof (TID_ABASICS_RELEASEWRAP));
		((PTID_ABASICS_RELEASEWRAP) pvSubInputData)->pDP8Address = pDP8Address;

		sr = pTNecd->pExecutor->ExecSubTestCase("1.1.2.1", pvSubInputData,
												sizeof (TID_ABASICS_RELEASEWRAP),
												1, pTNecd->iTesterNum);

		LocalFree(pvSubInputData);
		pvSubInputData = NULL;

		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't execute sub test case API:Basics:ReleaseWrap!", 0);
			THROW_SYSTEMRESULT;
		} // end if (failed executing sub test case)

		GETSUBRESULT_AND_FAILIFFAILED(pSubResult, "1.1.2.1",
									"Releasing DirectPlay8Address object failed!");

		pDP8Address = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	SAFE_LOCALFREE(pvSubInputData);
	SAFE_RELEASE(pDP8AddressInternal);
	SAFE_RELEASE(lpDPLobby2);


	if (pDP8Address != NULL)
	{
		// Ignore error
		g_pDP8AddressesList->RemoveFirstReference(pDP8Address);
		delete (pDP8Address);
		pDP8Address = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVExec_BBuildFromDPADDR
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvalidation.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCompareAppDesc()"
//==================================================================================
// ParmVCompareAppDesc
//----------------------------------------------------------------------------------
//
// Description: Makes sure the two application desc structures are essentially the
//				same.
//
// Arguments:
//	PDPN_APPLICATION_DESC pdpnadCompare		Pointer to app desc to compare.
//	PDPN_APPLICATION_DESC pdpnadExpected	Pointer to app desc to use as reference.
//
// Returns: DPN_OK if they match, a test result error code otherwise.
//==================================================================================
HRESULT ParmVCompareAppDesc(HANDLE hLog, PDPN_APPLICATION_DESC pdpnadCompare, PDPN_APPLICATION_DESC pdpnadExpected)
{
	// Compare the size.
	if (pdpnadCompare->dwSize != sizeof (DPN_APPLICATION_DESC))
	{
		DPTEST_TRACE(hLog, "Application desc size is wrong (%u != %u)!",
			2, pdpnadCompare->dwSize, sizeof (DPN_APPLICATION_DESC));
		return (ERROR_NO_MATCH);
	} // end if (size differs)


	// Compare the flags.
	if (pdpnadCompare->dwFlags != pdpnadExpected->dwFlags)
	{
		DPTEST_TRACE(hLog, "Application desc flags are wrong (%x != %x)!",
			2, pdpnadCompare->dwFlags, pdpnadExpected->dwFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Can't compare instance GUID, but we can make sure it's not GUID_NULL.
	if (IsZero(&pdpnadCompare->guidApplication, sizeof (GUID)))
	{
		DPTEST_TRACE(hLog, "Application desc instance GUID was not filled in!", 0);
		return (ERROR_NO_DATA);
	} // end if (no instance GUID)


	// Compare the app GUID.
	if (memcmp(&pdpnadCompare->guidApplication, &pdpnadExpected->guidApplication, sizeof (GUID)) != 0)
	{
		DPTEST_TRACE(hLog, "Application desc app GUID is wrong (%g != %g)!",
			2, &pdpnadCompare->guidApplication, &pdpnadExpected->guidApplication);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Compare the max players.
	if (pdpnadCompare->dwMaxPlayers != pdpnadExpected->dwMaxPlayers)
	{
		DPTEST_TRACE(hLog, "Application desc max players is wrong (%u != %u)!",
			2, pdpnadCompare->dwMaxPlayers, pdpnadExpected->dwMaxPlayers);
		return (ERROR_NO_MATCH);
	} // end if (max players differs)


	// We only expect one player.
	if (pdpnadCompare->dwCurrentPlayers != pdpnadExpected->dwCurrentPlayers)
	{
		DPTEST_TRACE(hLog, "Application desc current players is unexpected (%u != 1)!",
			1, pdpnadCompare->dwCurrentPlayers);
		return (ERROR_NO_MATCH);
	} // end if (current players unexpected)


	// Compare the session name.
	if (pdpnadExpected->pwszSessionName != NULL)
	{
		if (pdpnadCompare->pwszSessionName != NULL)
		{
			if (wcscmp(pdpnadCompare->pwszSessionName, pdpnadExpected->pwszSessionName) != 0)
			{
				DPTEST_TRACE(hLog, "Application desc session name is wrong (\"%S\"!= \"%S\")!",
					2, pdpnadCompare->pwszSessionName, pdpnadExpected->pwszSessionName);
				return (ERROR_NO_MATCH);
			} // end if (name differs)
		} // end if (received session name)
		else
		{
			DPTEST_TRACE(hLog, "Application desc session name (\"%S\") was not returned!",
				1, pdpnadExpected->pwszSessionName);
			return (ERROR_NO_MATCH);
		} // end if (no name specified)
	} // end if (gave session name)
	else
	{
		if (pdpnadCompare->pwszSessionName != NULL)
		{
			DPTEST_TRACE(hLog, "Unexpected application desc session name was returned (\"%S\")!",
				1, pdpnadCompare->pwszSessionName);
			return (ERROR_NO_MATCH);
		} // end if (name returned)
	} // end else (didn't specify session name)


	// Compare the password.
	if (pdpnadExpected->pwszPassword != NULL)
	{
		if (pdpnadCompare->pwszPassword != NULL)
		{
			if (wcscmp(pdpnadCompare->pwszPassword, pdpnadExpected->pwszPassword) != 0)
			{
				DPTEST_TRACE(hLog, "Application desc password is wrong (\"%S\"!= \"%S\")!",
					2, pdpnadCompare->pwszPassword, pdpnadExpected->pwszPassword);
				return (ERROR_NO_MATCH);
			} // end if (password differs)
		} // end if (received password)
		else
		{
			DPTEST_TRACE(hLog, "Application desc password (\"%S\") was not returned!",
				1, pdpnadExpected->pwszPassword);
			return (ERROR_NO_MATCH);
		} // end if (no password specified)
	} // end if (gave password)
	else
	{
		if (pdpnadCompare->pwszPassword != NULL)
		{
			DPTEST_TRACE(hLog, "Unexpected application desc password was returned (\"%S\")!",
				1, pdpnadCompare->pwszPassword);
			return (ERROR_NO_MATCH);
		} // end if (password returned)
	} // end else (didn't specify password)


	// Reserved data is not allowed or expected.
	if ((pdpnadCompare->pvReservedData != NULL) || (pdpnadCompare->dwReservedDataSize != 0))
	{
		DPTEST_TRACE(hLog, "Application desc reserved data was returned (ptr %x, size %u)!",
			2, pdpnadCompare->pvReservedData, pdpnadCompare->dwReservedDataSize);
		return (ERROR_NO_MATCH);
	} // end if (reserved data returned)


	// Compare the application reserved data.
	if (pdpnadExpected->pvApplicationReservedData != NULL)
	{
		if ((pdpnadCompare->pvApplicationReservedData != NULL) &&
			(pdpnadCompare->dwApplicationReservedDataSize == pdpnadExpected->dwApplicationReservedDataSize))
		{
			if (memcmp(pdpnadCompare->pvApplicationReservedData, pdpnadExpected->pvApplicationReservedData, pdpnadCompare->dwApplicationReservedDataSize) != 0)
			{
				DPTEST_TRACE(hLog, "Application desc app reserved data is wrong (%u byte data at \"%x\"!= data at \"%x\")!",
					3, pdpnadCompare->dwApplicationReservedDataSize,
					pdpnadCompare->pvApplicationReservedData,
					pdpnadExpected->pvApplicationReservedData);
				return (ERROR_NO_MATCH);
			} // end if (app reserved data differs)
		} // end if (received app reserved data)
		else
		{
			DPTEST_TRACE(hLog, "Application desc app reserved data (data \"%x\", size %u) was not returned, data ptr was %x and size was %u!",
				4, pdpnadExpected->pvApplicationReservedData,
				pdpnadExpected->dwApplicationReservedDataSize,
				pdpnadCompare->pvApplicationReservedData,
				pdpnadCompare->dwApplicationReservedDataSize);
			return (ERROR_NO_MATCH);
		} // end if (no app reserved data specified)
	} // end if (gave app reserved data)
	else
	{
		if ((pdpnadCompare->pvApplicationReservedData != NULL) ||
			(pdpnadCompare->dwApplicationReservedDataSize != 0))
		{
			DPTEST_TRACE(hLog, "Unexpected application desc app reserved data was returned (data \"%x\", size = %u)!",
				2, pdpnadCompare->pvApplicationReservedData,
				pdpnadCompare->dwApplicationReservedDataSize);
			return (ERROR_NO_MATCH);
		} // end if (app reserved data returned)
	} // end else (didn't specify app reserved data)

	return (DPN_OK);
} // ParmVCompareAppDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCompareGroupInfo()"
//==================================================================================
// ParmVCompareGroupInfo
//----------------------------------------------------------------------------------
//
// Description: Makes sure the two group info structures are essentially the same.
//
// Arguments:
//	PDPN_GROUP_INFO pdpngiCompare	Pointer to group info to compare.
//	PDPN_GROUP_INFO pdpngiExpected	Pointer to group info to use as reference.
//
// Returns: DPN_OK if they match, a test result error code otherwise.
//==================================================================================
HRESULT ParmVCompareGroupInfo(HANDLE hLog,
							  PDPN_GROUP_INFO pdpngiCompare,
							  PDPN_GROUP_INFO pdpngiExpected)
{
	// Compare the size.
	if (pdpngiCompare->dwSize != sizeof (DPN_GROUP_INFO))
	{
		DPTEST_TRACE(hLog, "Group info size is wrong (%u != %u)!",
			2, pdpngiCompare->dwSize, sizeof (DPN_GROUP_INFO));
		return (ERROR_NO_MATCH);
	} // end if (size differs)


	// Compare the info flags.
	if (pdpngiCompare->dwInfoFlags != pdpngiExpected->dwInfoFlags)
	{
		DPTEST_TRACE(hLog, "Group info info flags are wrong (%x != %x)!",
			2, pdpngiCompare->dwInfoFlags, pdpngiExpected->dwInfoFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Compare the name.
	if (pdpngiExpected->pwszName != NULL)
	{
		if (pdpngiCompare->pwszName != NULL)
		{
			if (wcscmp(pdpngiCompare->pwszName, pdpngiExpected->pwszName) != 0)
			{
				DPTEST_TRACE(hLog, "Group info name is wrong (\"%S\"!= \"%S\")!",
					2, pdpngiCompare->pwszName, pdpngiExpected->pwszName);
				return (ERROR_NO_MATCH);
			} // end if (name differs)
		} // end if (received group info name)
		else
		{
			DPTEST_TRACE(hLog, "Group info name (\"%S\") was not returned!",
				1, pdpngiExpected->pwszName);
			return (ERROR_NO_MATCH);
		} // end if (no name specified)
	} // end if (gave group info name)
	else
	{
		if (pdpngiCompare->pwszName != NULL)
		{
			DPTEST_TRACE(hLog, "Unexpected group info name was returned (\"%S\")!",
				1, pdpngiCompare->pwszName);
			return (ERROR_NO_MATCH);
		} // end if (name returned)
	} // end else (didn't specify group info name)


	// Compare the data.
	if (pdpngiExpected->pvData != NULL)
	{
		if ((pdpngiCompare->pvData != NULL) &&
			(pdpngiCompare->dwDataSize == pdpngiExpected->dwDataSize))
		{
			if (memcmp(pdpngiCompare->pvData, pdpngiExpected->pvData, pdpngiCompare->dwDataSize) != 0)
			{
				DPTEST_TRACE(hLog, "Group info data is wrong (%u byte data at \"%x\"!= data at \"%x\")!",
					3, pdpngiCompare->dwDataSize, pdpngiCompare->pvData,
					pdpngiExpected->pvData);
				return (ERROR_NO_MATCH);
			} // end if (group info data differs)
		} // end if (received group info data)
		else
		{
			DPTEST_TRACE(hLog, "Group info data (data \"%x\", size %u) was not returned, data ptr was %x and size was %u!",
				4, pdpngiExpected->pvData, pdpngiExpected->dwDataSize,
				pdpngiCompare->pvData, pdpngiCompare->dwDataSize);
			return (ERROR_NO_MATCH);
		} // end if (no group info data specified)
	} // end if (gave group info data)
	else
	{
		if ((pdpngiCompare->pvData != NULL) || (pdpngiCompare->dwDataSize != 0))
		{
			DPTEST_TRACE(hLog, "Unexpected group info data was returned (data \"%x\", size = %u)!",
				2, pdpngiCompare->pvData, pdpngiCompare->dwDataSize);
			return (ERROR_NO_MATCH);
		} // end if (group info data returned)
	} // end else (didn't specify group info data)


	// Compare the group flags.
	if (pdpngiCompare->dwGroupFlags != pdpngiExpected->dwGroupFlags)
	{
		DPTEST_TRACE(hLog, "Group info group flags are wrong (%x != %x)!",
			2, pdpngiCompare->dwGroupFlags, pdpngiExpected->dwGroupFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	return (DPN_OK);
} // ParmVCompareGroupInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVComparePlayerInfo()"
//==================================================================================
// ParmVComparePlayerInfo
//----------------------------------------------------------------------------------
//
// Description: Makes sure the two player info structures are essentially the same.
//
// Arguments:
//	PDPN_PLAYER_INFO pdpnpiCompare		Pointer to player info to compare.
//	PDPN_PLAYER_INFO pdpnpiExpected		Pointer to player info to use as reference.
//
// Returns: DPN_OK if they match, a test result error code otherwise.
//==================================================================================
HRESULT ParmVComparePlayerInfo(HANDLE hLog,
							   PDPN_PLAYER_INFO pdpnpiCompare,
							   PDPN_PLAYER_INFO pdpnpiExpected)
{
	// Compare the size.
	if (pdpnpiCompare->dwSize != sizeof (DPN_PLAYER_INFO))
	{
		DPTEST_TRACE(hLog, "Player info size is wrong (%u != %u)!",
			2, pdpnpiCompare->dwSize, sizeof (DPN_PLAYER_INFO));
		return (ERROR_NO_MATCH);
	} // end if (size differs)


	// Compare the info flags.
	if (pdpnpiCompare->dwInfoFlags != pdpnpiExpected->dwInfoFlags)
	{
		DPTEST_TRACE(hLog, "Player info info flags are wrong (%x != %x)!",
			2, pdpnpiCompare->dwInfoFlags, pdpnpiExpected->dwInfoFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Compare the name.
	if (pdpnpiExpected->pwszName != NULL)
	{
		if (pdpnpiCompare->pwszName != NULL)
		{
			if (wcscmp(pdpnpiCompare->pwszName, pdpnpiExpected->pwszName) != 0)
			{
				DPTEST_TRACE(hLog, "Player info name is wrong (\"%S\"!= \"%S\")!",
					2, pdpnpiCompare->pwszName, pdpnpiExpected->pwszName);
				return (ERROR_NO_MATCH);
			} // end if (name differs)
		} // end if (received player info name)
		else
		{
			DPTEST_TRACE(hLog, "Player info name (\"%S\") was not returned!",
				1, pdpnpiExpected->pwszName);
			return (ERROR_NO_MATCH);
		} // end if (no name specified)
	} // end if (gave player info name)
	else
	{
		if (pdpnpiCompare->pwszName != NULL)
		{
			DPTEST_TRACE(hLog, "Unexpected player info name was returned (\"%S\")!",
				1, pdpnpiCompare->pwszName);
			return (ERROR_NO_MATCH);
		} // end if (name returned)
	} // end else (didn't specify player info name)


	// Compare the data.
	if (pdpnpiExpected->pvData != NULL)
	{
		if ((pdpnpiCompare->pvData != NULL) &&
			(pdpnpiCompare->dwDataSize == pdpnpiExpected->dwDataSize))
		{
			if (memcmp(pdpnpiCompare->pvData, pdpnpiExpected->pvData, pdpnpiCompare->dwDataSize) != 0)
			{
				DPTEST_TRACE(hLog, "Player info data is wrong (%u byte data at \"%x\"!= data at \"%x\")!",
					3, pdpnpiCompare->dwDataSize, pdpnpiCompare->pvData,
					pdpnpiExpected->pvData);
				return (ERROR_NO_MATCH);
			} // end if (v info data differs)
		} // end if (received player info data)
		else
		{
			DPTEST_TRACE(hLog, "Player info data (data \"%x\", size %u) was not returned, data ptr was %x and size was %u!",
				4, pdpnpiExpected->pvData, pdpnpiExpected->dwDataSize,
				pdpnpiCompare->pvData, pdpnpiCompare->dwDataSize);
			return (ERROR_NO_MATCH);
		} // end if (no player info data specified)
	} // end if (gave player info data)
	else
	{
		if ((pdpnpiCompare->pvData != NULL) || (pdpnpiCompare->dwDataSize != 0))
		{
			DPTEST_TRACE(hLog, "Unexpected player info data was returned (data \"%x\", size = %u)!",
				2, pdpnpiCompare->pvData, pdpnpiCompare->dwDataSize);
			return (ERROR_NO_MATCH);
		} // end if (player info data returned)
	} // end else (didn't specify player info data)


	// Compare the player flags.
	if (pdpnpiCompare->dwPlayerFlags != pdpnpiExpected->dwPlayerFlags)
	{
		DPTEST_TRACE(hLog, "Player info group flags are wrong (%x != %x)!",
			2, pdpnpiCompare->dwPlayerFlags, pdpnpiExpected->dwPlayerFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	return (DPN_OK);
} // ParmVComparePlayerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCreatePeerHost()"
//==================================================================================
// ParmVCreatePeerHost
//----------------------------------------------------------------------------------
//
// Description: Creates a new CWrapDP8Peer object that is hosting based on the given
//				message handler and application description.  The first hosting
//				address can optionally also be returned.
//
// Arguments:
//	PFNDPNMESSAGEHANDLER pfn				Message handler to use.
//	PVOID pvContext							Pointer to context for message handler.
//	PDPN_APPLICATION_DESC pdpnad			Pointer to application desc to use when
//											hosting the session
//	PWRAPDP8PEER* ppDP8PeerHost				Place to store pointer to CWrapDP8Peer
//											object created.
//	PVOID pvPlayerContext					Player context for local host player.
//	PDIRECTPLAY8ADDRESS* ppDP8AddressHost	Optional place to store pointer to first
//											address the object is hosting on.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVCreatePeerHost(HANDLE hLog,
							PFNDPNMESSAGEHANDLER pfn,
							PVOID pvContext,
							PDPN_APPLICATION_DESC pdpnad,
							PVOID pvPlayerContext,
							PWRAPDP8PEER* ppDP8PeerHost,
							PDIRECTPLAY8ADDRESS* ppDP8AddressHost)
{
	HRESULT					hr;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	DWORD					dwNumAddresses = 0;



	if ((*ppDP8PeerHost) != NULL)
	{
		DPTEST_TRACE(hLog, "Already have peer object (%x)!", 1, (*ppDP8PeerHost));
		return (ERROR_INVALID_PARAMETER);
	} // end if (already have object)


	(*ppDP8PeerHost) = new CWrapDP8Peer(hLog);
	if ((*ppDP8PeerHost) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)


	hr = (*ppDP8PeerHost)->CoCreate();
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "CoCreating DP8Peer object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)


	hr = (*ppDP8PeerHost)->DP8P_Initialize(pvContext, pfn, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Initializing DP8Peer object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)



	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);
	if (hr != S_OK)
	{
		DPTEST_TRACE(hLog, "Couldn't DirectPlay8AddressCreate host DirectPlay8Address object!", 0);
		goto ERROR_EXIT;
	} // end if (DirectPlay8AddressCreate failed)


//	hr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);
// BUGBUG - modified for Xbox version
//	hr = pDP8AddressDevice->SetSP();
//	if (hr != S_OK)
//	{
//		DPTEST_TRACE(hLog, "Couldn't set DirectPlay8Address SP!", 0);
//		goto ERROR_EXIT;
//	} // end if (set SP failed)

	hr = (*ppDP8PeerHost)->DP8P_Host(pdpnad, &pDP8AddressDevice, 1, NULL, NULL,
									pvPlayerContext, 0);
	if (hr != DPN_OK)
	{
		DPTEST_TRACE(hLog, "Hosting failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)

	pDP8AddressDevice->Release();
	pDP8AddressDevice = NULL;

	// If the caller wants an address, give one to him.
	if (ppDP8AddressHost != NULL)
	{
		// Ignore error
		hr = (*ppDP8PeerHost)->DP8P_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);


		paDP8HostAddresses = (PDIRECTPLAY8ADDRESS*) MemAlloc(dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));
		if (paDP8HostAddresses == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)


		hr = (*ppDP8PeerHost)->DP8P_GetLocalHostAddresses(paDP8HostAddresses,
														&dwNumAddresses,
														0);
		if (hr != DPN_OK)
		{
			DPTEST_TRACE(hLog, "Getting local addresses failed!", 0);
			goto ERROR_EXIT;
		} // end if (getting addresses failed)


		// Move the first address to the caller's pointer.
		(*ppDP8AddressHost) = paDP8HostAddresses[0];
		paDP8HostAddresses[0] = NULL;


		// Release all the other addresses.
		while (dwNumAddresses > 1)
		{
			dwNumAddresses--;
			paDP8HostAddresses[dwNumAddresses]->Release();
			paDP8HostAddresses[dwNumAddresses] = NULL;
		} // end while (more addresses)


		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (caller wants address)

	return (DPN_OK);


ERROR_EXIT:


	if (paDP8HostAddresses != NULL)
	{
		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (allocated address array)

	if (pDP8AddressDevice != NULL)
	{
		pDP8AddressDevice->Release();
		pDP8AddressDevice = NULL;
	} // end if (allocated address object)

	if ((*ppDP8PeerHost) != NULL)
	{
		delete (*ppDP8PeerHost);
		(*ppDP8PeerHost) = NULL;
	} // end if (have wrapper object)

	return (hr);
} // ParmVCreatePeerHost
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCreateAndConnectClient()"
//==================================================================================
// ParmVCreateAndConnectClient
//----------------------------------------------------------------------------------
//
// Description: Creates a new CWrapDP8Server object that is hosting based on the
//				given message handler and application description.  The first
//				hosting address can optionally also be returned.
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//	PFNDPNMESSAGEHANDLER pfn		Message handler to use.
//	PVOID pvContext					Pointer to context for message handler.
//	PWRAPDP8SERVER pDP8Server		Pointer to server object to connect to.
//	PDPN_APPLICATION_DESC pdpnad	Pointer to application desc to use when
//									connecting to the session
//	HANDLE hClientCreatedEvent		Handle to event that will be set when client's
//									CREATE_PLAYER is indicated on the server.
//	PWRAPDP8CLIENT* ppDP8Client		Place to store pointer to CWrapDP8Client object
//									created.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVCreateAndConnectClient(HANDLE hLog,
									PFNDPNMESSAGEHANDLER pfn,
									PVOID pvContext,
									PWRAPDP8SERVER pDP8Server,
									PDPN_APPLICATION_DESC pdpnad,
									HANDLE hClientCreatedEvent,
									PWRAPDP8CLIENT* ppDP8Client)
{
	HRESULT					hr;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	DWORD					dwNumAddresses = 0;
	DP_DOWORKLIST			DoWorkList;
	DPNHANDLE				hAsyncOp;



	if ((*ppDP8Client) != NULL)
	{
		DPTEST_FAIL(hLog, "Already have client object (%x)!", 1, (*ppDP8Client));
		return (ERROR_INVALID_PARAMETER);
	} // end if (already have object)


	(*ppDP8Client) = new CWrapDP8Client(hLog);
	if ((*ppDP8Client) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)


	hr = (*ppDP8Client)->CoCreate();
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "CoCreating DP8Client object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)


	hr = (*ppDP8Client)->DP8C_Initialize(pvContext, pfn, 0);
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "Initializing DP8Client object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)



	// Ignore error
	pDP8Server->DP8S_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);


	paDP8HostAddresses = (PDIRECTPLAY8ADDRESS*) MemAlloc(dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));
	if (paDP8HostAddresses == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate memory)


	hr = pDP8Server->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
												&dwNumAddresses,
												0);
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "Getting local addresses failed!", 0);
		goto ERROR_EXIT;
	} // end if (getting addresses failed)


	// Connect using the first address returned.
	hr = (*ppDP8Client)->DP8C_Connect(pdpnad,
									paDP8HostAddresses[0],
									NULL,
									NULL,
									NULL,
									NULL,
									0,
									NULL,
									&hAsyncOp,
									0);

	if((hr != DPNSUCCESS_PENDING) && (hr != DPN_OK))
	{
		DPTEST_FAIL(hLog, "Connecting to host failed!", 0);
		goto ERROR_EXIT;
	} // end if (connecting failed)


	// Release all the addresses.
	while (dwNumAddresses > 0)
	{
		dwNumAddresses--;
		paDP8HostAddresses[dwNumAddresses]->Release();
		paDP8HostAddresses[dwNumAddresses] = NULL;
	} // end while (more addresses)


	MemFree(paDP8HostAddresses);
	paDP8HostAddresses = NULL;



	//
	// Make sure the client connection is fully notified on the server.
	//
	// NOTE: We're using the control layer WaitForEventOrCancel function which
	// returns a system result, which we'll return directly from this function.
	// Everyone who currently calls this function will remap it to a test result.
	// We can't use the THROW_TESTRESULT/THROW_SYSTEMRESULT macros to differentiate
	// because those don't work outside a BEGIN_TESTCASE-END_TESTCASE pair.
	//
	// We shouldn't be failing anyway, but I wanted to be clear about the price
	// we're paying for not making this a subtest case.
	//

	memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
	DoWorkList.fTrackDoWorkTimes = FALSE;
	DoWorkList.dwNumClients = 1;
	DoWorkList.dwNumServers = 1;
	DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
	DoWorkList.apDP8Clients[0] = (*ppDP8Client)->m_pDP8Client;
	DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
	DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

	if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, hClientCreatedEvent))
	{
		DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
		goto ERROR_EXIT;
	}

	MemFree(DoWorkList.apDP8Clients);
	MemFree(DoWorkList.apDP8Servers);

	// The client should be connected, and it should be safe for the server to
	// refer to his ID.
	

	return (DPN_OK);


ERROR_EXIT:


	if (paDP8HostAddresses != NULL)
	{
		// Release the addresses, if any.
		if (paDP8HostAddresses[0] != NULL)
		{
			while (dwNumAddresses > 0)
			{
				dwNumAddresses--;
				paDP8HostAddresses[dwNumAddresses]->Release();
				paDP8HostAddresses[dwNumAddresses] = NULL;
			} // end while (more addresses)
		} // end if (any addresses)

		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (allocated address array)

	if ((*ppDP8Client) != NULL)
	{
		delete (*ppDP8Client);
		(*ppDP8Client) = NULL;
	} // end if (have wrapper object)

	return (hr);
} // ParmVCreateAndConnectClient
#undef DEBUG_SECTION
#define DEBUG_SECTION	""




#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVCreateServer()"
//==================================================================================
// ParmVCreateServer
//----------------------------------------------------------------------------------
//
// Description: Creates a new CWrapDP8Server object that is hosting based on the
//				given message handler and application description.  The first
//				hosting address can optionally also be returned.
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//	PFNDPNMESSAGEHANDLER pfn				Message handler to use.
//	PVOID pvContext							Pointer to context for message handler.
//	PDPN_APPLICATION_DESC pdpnad			Pointer to application desc to use when
//											hosting the session
//	DPNID* pdpnidPlayerContext				Pointer to player context, which will
//											also be used to store the server's
//											player ID from the CREATE_PLAYER
//											indication.  
//	PWRAPDP8SERVER* ppDP8Server				Place to store pointer to CWrapDP8Server
//											object created.
//	PDIRECTPLAY8ADDRESS* ppDP8AddressHost	Optional place to store pointer to first
//											address the object is hosting on.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVCreateServer(HANDLE hLog,
						PFNDPNMESSAGEHANDLER pfn,
						PVOID pvContext,
						PDPN_APPLICATION_DESC pdpnad,
						DPNID* pdpnidPlayerContext,
						PWRAPDP8SERVER* ppDP8Server,
						PDIRECTPLAY8ADDRESS* ppDP8AddressHost)
{
	HRESULT					hr;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	PDIRECTPLAY8ADDRESS*	paDP8HostAddresses = NULL;
	DWORD					dwNumAddresses = 0;



	if ((*ppDP8Server) != NULL)
	{
		DPTEST_FAIL(hLog, "Already have server object (%x)!", 1, (*ppDP8Server));
		return (ERROR_INVALID_PARAMETER);
	} // end if (already have object)


	(*ppDP8Server) = new CWrapDP8Server(hLog);
	if ((*ppDP8Server) == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto ERROR_EXIT;
	} // end if (couldn't allocate object)


	hr = (*ppDP8Server)->CoCreate();
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "CoCreating DP8Server object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)


	hr = (*ppDP8Server)->DP8S_Initialize(pvContext, pfn, 0);
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "Initializing DP8Server object failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)



	hr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressDevice, NULL);
	if (hr != S_OK)
	{
		DPTEST_FAIL(hLog, "Couldn't create host DirectPlay8Address object!", 0);
		goto ERROR_EXIT;
	} // end if (create failed)


	hr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != S_OK)
	{
		DPTEST_FAIL(hLog, "Couldn't set DirectPlay8Address SP!", 0);
		goto ERROR_EXIT;
	} // end if (set SP failed)


	hr = (*ppDP8Server)->DP8S_Host(pdpnad, &pDP8AddressDevice, 1, NULL, NULL,
									pdpnidPlayerContext, 0);
	if (hr != DPN_OK)
	{
		DPTEST_FAIL(hLog, "Hosting failed!", 0);
		goto ERROR_EXIT;
	} // end if (function failed)

	if ((*pdpnidPlayerContext) == 0)
	{
		DPTEST_FAIL(hLog, "Player ID not set (CREATE_PLAYER not indicated?)!", 0);
		hr = ERROR_NO_DATA;
		goto ERROR_EXIT;
	} // end if (player ID not set)

	pDP8AddressDevice->Release();
	pDP8AddressDevice = NULL;


	// If the caller wants an address, give one to him.
	if (ppDP8AddressHost != NULL)
	{
		// Ignore error
		(*ppDP8Server)->DP8S_GetLocalHostAddresses(NULL, &dwNumAddresses, 0);


		paDP8HostAddresses = (PDIRECTPLAY8ADDRESS*) MemAlloc(dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS));
		if (paDP8HostAddresses == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		} // end if (couldn't allocate memory)


		hr = (*ppDP8Server)->DP8S_GetLocalHostAddresses(paDP8HostAddresses,
														&dwNumAddresses,
														0);
		if (hr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting local addresses failed!", 0);
			goto ERROR_EXIT;
		} // end if (getting addresses failed)


		// Move the first address to the caller's pointer.
		(*ppDP8AddressHost) = paDP8HostAddresses[0];
		paDP8HostAddresses[0] = NULL;


		// Release all the other addresses.
		while (dwNumAddresses > 1)
		{
			dwNumAddresses--;
			paDP8HostAddresses[dwNumAddresses]->Release();
			paDP8HostAddresses[dwNumAddresses] = NULL;
		} // end while (more addresses)


		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (caller wants address)


	return (DPN_OK);


ERROR_EXIT:


	if (paDP8HostAddresses != NULL)
	{
		MemFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	} // end if (allocated address array)

	if (pDP8AddressDevice != NULL)
	{
		pDP8AddressDevice->Release();
		pDP8AddressDevice = NULL;
	} // end if (allocated address object)

	if ((*ppDP8Server) != NULL)
	{
		delete (*ppDP8Server);
		(*ppDP8Server) = NULL;
	} // end if (have wrapper object)

	// Reset this, just in case.
	(*pdpnidPlayerContext) = 0;

	return (hr);
} // ParmVCreateServer
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVNoMessagesDPNMessageHandler()"
//==================================================================================
// ParmVNoMessagesDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVNoMessagesDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	DPTEST_TRACE(NULL, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
		1, dwMsgType);
	DEBUGBREAK();

	return (E_NOTIMPL);
} // ParmVNoMessagesDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""


#undef DEBUG_SECTION
#define DEBUG_SECTION	"StringCmpAToU()"
//==================================================================================
// StringCmpAToU
//----------------------------------------------------------------------------------
//
// Description: Performs similar to strcmp, except the first string is Unicode, and
//				it returns TRUE if they match (case insensitive, if specified),
//				FALSE otherwise.
//
// Arguments:
//	HANDLE hLog					Handle to logging subsystem
//	WCHAR* wszUnicodeString		Unicode string to compare.
//	char* szANSIString			ANSI string to compare.
//	BOOL fMatchCase				Whether case matters or not.
//
// Returns: Returns TRUE if they match, FALSE otherwise.
//==================================================================================
BOOL StringCmpAToU(HANDLE hLog, WCHAR* wszUnicodeString, char* szANSIString, BOOL fMatchCase)
{
	BOOL	fResult = FALSE;
	int		i;
	WCHAR*	pwszANSIAsUnicode = NULL;
	WCHAR*	pwszUnicodeLwr = NULL;
	WCHAR*	pwcCurrent1 = NULL;
	WCHAR*	pwcCurrent2 = NULL;



	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1, NULL, 0);
	if (i <= 0)
	{
		DPTEST_FAIL(hLog, "Couldn't get size of ANSI string in Unicode!  %u", 1, GetLastError());

		goto DONE;
	} // end if (couldn't convert string)


	pwszANSIAsUnicode = (WCHAR*) MemAlloc(i * sizeof (WCHAR));
	if (pwszANSIAsUnicode == NULL)
	{
		goto DONE;
	} // end if (couldn't allocate memory)
	ZeroMemory(pwszANSIAsUnicode, i * sizeof (WCHAR));

	i = MultiByteToWideChar(CP_ACP, 0, szANSIString, -1, pwszANSIAsUnicode, i);
	if (i <= 0)
	{
		DPTEST_FAIL(hLog, "Couldn't convert string to Unicode!  %u", 1, GetLastError());

		goto DONE;
	} // end if (the function failed)


	// Make strings lower case for case-insensitive matching, if requested
	if (! fMatchCase)
	{
		_wcslwr(pwszANSIAsUnicode);

		pwszUnicodeLwr = (WCHAR*) MemAlloc((wcslen(wszUnicodeString) + 1) * sizeof (WCHAR));
		if (pwszUnicodeLwr == NULL)
		{
			goto DONE;
		} // end if (couldn't allocate memory)
		wcscpy(pwszUnicodeLwr, wszUnicodeString);
		_wcslwr(pwszUnicodeLwr);
	} // end if (case insensitive)

	// Compare the strings
	fResult = ((wcscmp((fMatchCase ? wszUnicodeString : pwszUnicodeLwr),
				pwszANSIAsUnicode)) == 0) ? TRUE : FALSE;


DONE:

	if (pwszANSIAsUnicode != NULL)
	{
		MemFree(pwszANSIAsUnicode);
		pwszANSIAsUnicode = NULL;
	} // end if (allocated string)

	if (pwszUnicodeLwr != NULL)
	{
		MemFree(pwszUnicodeLwr);
		pwszUnicodeLwr = NULL;
	} // end if (allocated string)

	return (fResult);
} // StringCmpAToU
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

#undef DEBUG_SECTION
#define DEBUG_SECTION	"ClearDoWorkList()"
//==================================================================================
// ClearDoWorkList
//----------------------------------------------------------------------------------
//
// Description: Releases any buffers allocated inside the DoWorkList
//
// Arguments:
//	DP_DOWORKLIST		*pDoWorkList		DoWorkList structure to be cleared
//
// Returns: nothing
//==================================================================================
VOID ClearDoWorkList(DP_DOWORKLIST *pDoWorkList)
{
	if(pDoWorkList->apDP8Clients)
	{
		MemFree(pDoWorkList->apDP8Clients);
		pDoWorkList->apDP8Clients = NULL;
	}

	if(pDoWorkList->apDP8Servers)
	{
		MemFree(pDoWorkList->apDP8Servers);
		pDoWorkList->apDP8Servers = NULL;
	}

	if(pDoWorkList->apDP8Peers)
	{
		MemFree(pDoWorkList->apDP8Peers);
		pDoWorkList->apDP8Peers = NULL;
	}

	if(pDoWorkList->apdwClientCallbackTimes)
	{
		MemFree(pDoWorkList->apdwClientCallbackTimes);
		pDoWorkList->apdwClientCallbackTimes = NULL;
	}

	if(pDoWorkList->apdwServerCallbackTimes)
	{
		MemFree(pDoWorkList->apdwServerCallbackTimes);
		pDoWorkList->apdwServerCallbackTimes = NULL;
	}

	if(pDoWorkList->apdwPeerCallbackTimes)
	{
		MemFree(pDoWorkList->apdwPeerCallbackTimes);
		pDoWorkList->apdwPeerCallbackTimes = NULL;
	}

	return;
} // StringCmpAToU
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\parmvserver.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#include "macros.h"
#include "parmvalidation.h"

using namespace DPlayCoreNamespace;

namespace DPlayCoreNamespace {

//==================================================================================
// Structures
//==================================================================================
typedef struct tagPARMVSGETSENDQINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVSGETSENDQINFOCONTEXT, * PPARMVSGETSENDQINFOCONTEXT;

typedef struct tagPARMVSGETAPPDESCCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVSGETAPPDESCCONTEXT, * PPARMVSGETAPPDESCCONTEXT;

typedef struct tagPARMVSSETSERVERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fCanGetServerInfoUpdate; // whether the server info indication can arrive or not
	BOOL					fGotServerInfoUpdate; // whether the server info indication did arrive
	HANDLE					hGotServerInfoUpdateEvent; // event to set when server info message is received
	PWRAPDP8CLIENT			pDP8Client; // pointer to DP8Client wrapper object to use
	WCHAR*					pwszExpectedServerInfoName; // expected client info name
	PVOID*					pvExpectedServerInfoData; // expected server info data
	DWORD					dwExpectedServerInfoDataSize; // expected server info data size
	DWORD					dwExpectedServerInfoPlayerFlags; // expected server info player flags
} PARMVSSETSERVERINFOCONTEXT, * PPARMVSSETSERVERINFOCONTEXT;

typedef struct tagPARMVSGETCLIENTINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVSGETCLIENTINFOCONTEXT, * PPARMVSGETCLIENTINFOCONTEXT;

typedef struct tagPARMVSGETCLIENTADDRESSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fServer; // whether this is the server context or not
	DPNID					dpnidServer; // ID of server player (server only)
	DPNID					dpnidClient; // ID of client player (server only)
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	HANDLE					hClientCreatedEvent; // event to set when CREATE_PLAYER for client arrives on host
} PARMVSGETCLIENTADDRESSCONTEXT, * PPARMVSGETCLIENTADDRESSCONTEXT;




//==================================================================================
// Prototypes
//==================================================================================
HRESULT ParmVServerExec_CreateQI(HANDLE hLog);
HRESULT ParmVServerExec_Init(HANDLE hLog);
HRESULT ParmVServerExec_EnumSPs(HANDLE hLog);
HRESULT ParmVServerExec_Cancel(HANDLE hLog);
HRESULT ParmVServerExec_GetSendQInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetAppDesc(HANDLE hLog);
HRESULT ParmVServerExec_SetServerInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetClientInfo(HANDLE hLog);
HRESULT ParmVServerExec_GetClientAddress(HANDLE hLog);
//HRESULT ParmVServerExec_GetLHostAddresses(HANDLE hLog);
//HRESULT ParmVServerExec_SetAppDesc(HANDLE hLog);
//HRESULT ParmVServerExec_Host(HANDLE hLog);
//HRESULT ParmVServerExec_SendTo(HANDLE hLog);
//HRESULT ParmVServerExec_CreateGroup(HANDLE hLog);
//HRESULT ParmVServerExec_DestroyGroup(HANDLE hLog);
//HRESULT ParmVServerExec_AddPlayerToGroup(HANDLE hLog);
//HRESULT ParmVServerExec_RemovePlayerFromGroup(HANDLE hLog);
//HRESULT ParmVServerExec_SetGroupInfo(HANDLE hLog);
//HRESULT ParmVServerExec_GetGroupInfo(HANDLE hLog);
//HRESULT ParmVServerExec_EnumPlayersAndGroups(HANDLE hLog);
//HRESULT ParmVServerExec_EnumGroupMembers(HANDLE hLog);
//HRESULT ParmVServerExec_Close(HANDLE hLog);
//HRESULT ParmVServerExec_DestroyClient(HANDLE hLog);
//HRESULT ParmVServerExec_Return(HANDLE hLog);
//HRESULT ParmVServerExec_GetPlayerContext(HANDLE hLog);
//HRESULT ParmVServerExec_GetGroupContext(HANDLE hLog);
//HRESULT ParmVServerExec_GetCaps(HANDLE hLog);
//HRESULT ParmVServerExec_SetCaps(HANDLE hLog);
//HRESULT ParmVServerExec_SetSPCaps(HANDLE hLog);
//HRESULT ParmVServerExec_GetSPCaps(HANDLE hLog);
//HRESULT ParmVServerExec_GetConnInfo(HANDLE hLog);
//HRESULT ParmVServerExec_RegLobby(HANDLE hLog);



HRESULT ParmVSGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVSGetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVSSetServerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVSGetClientInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);
HRESULT ParmVSGetClientAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg);





/*
#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerLoadTestTable()"
//==================================================================================
// ParmVServerLoadTestTable
//----------------------------------------------------------------------------------
//
// Description: Loads all the possible tests into the table passed in:
//				2.1.2		Server interface parameter validation tests
//				2.1.2.1		Server DirectPlay8Create and QueryInterface parameter validation
//				2.1.2.2		Server Initialize parameter validation
//				2.1.2.3		Server EnumServiceProviders parameter validation
//				2.1.2.4		Server CancelAsyncOperation parameter validation
//				2.1.2.5		Server GetSendQueueInfo parameter validation
//				2.1.2.6		Server GetApplicationDesc parameter validation
//				2.1.2.7		Server SetServerInfo parameter validation
//				2.1.2.8		Server GetClientInfo parameter validation
//				2.1.2.9		Server GetClientAddress parameter validation
//
// Arguments:
//	PTNLOADTESTTABLEDATA pTNlttd	Pointer to data to use when loading the tests.
//
// Returns: S_OK if successful, error code otherwise.
//==================================================================================
HRESULT ParmVServerLoadTestTable(PTNLOADTESTTABLEDATA pTNlttd)
{
	PTNTESTTABLEGROUP	pSubGroup;
	TNADDTESTDATA		tnatd;



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2	Server interface parameter validation tests
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	NEWSUBGROUP(pTNlttd->pBase,
				"2.1.2", "Server interface parameter validation tests",
				&pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.1	Server DirectPlay8Create and QueryInterface parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.1";
	tnatd.pszName			= "Server DirectPlay8Create and QueryInterface parameter validation";
	tnatd.pszDescription	= "Server DirectPlay8Create and QueryInterface parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_CreateQI;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.2	Server Initialize parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.2";
	tnatd.pszName			= "Server Initialize parameter validation";
	tnatd.pszDescription	= "Server Initialize parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_Init;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.3	Server EnumServiceProviders parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.3";
	tnatd.pszName			= "Server EnumServiceProviders parameter validation";
	tnatd.pszDescription	= "Server EnumServiceProviders parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_EnumSPs;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.4	Server CancelAsyncOperation parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.4";
	tnatd.pszName			= "Server CancelAsyncOperation parameter validation";
	tnatd.pszDescription	= "Server CancelAsyncOperation parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_Cancel;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.5	Server GetSendQueueInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.5";
	tnatd.pszName			= "Server GetSendQueueInfo parameter validation";
	tnatd.pszDescription	= "Server GetSendQueueInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_GetSendQInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.6	Server GetApplication parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.6";
	tnatd.pszName			= "Server GetApplication parameter validation";
	tnatd.pszDescription	= "Server GetApplication parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_GetAppDesc;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.7	Server SetServerInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.7";
	tnatd.pszName			= "Server SetServerInfo parameter validation";
	tnatd.pszDescription	= "Server SetServerInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_SetServerInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.8	Server GetClientInfo parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.8";
	tnatd.pszName			= "Server GetClientInfo parameter validation";
	tnatd.pszDescription	= "Server GetClientInfo parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_GetClientInfo;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);



	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// 2.1.2.9	Server GetClientAddress parameter validation
	//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	ZeroMemory(&tnatd, sizeof (TNADDTESTDATA));
	tnatd.dwSize			= sizeof (TNADDTESTDATA);
	tnatd.pszCaseID			= "2.1.2.9";
	tnatd.pszName			= "Server GetClientAddress parameter validation";
	tnatd.pszDescription	= "Server GetClientAddress parameter validation";
	tnatd.pszInputDataHelp	= NULL;

	tnatd.iNumMachines		= 1;
	tnatd.dwOptionFlags		= TNTCO_API | TNTCO_STRESS | TNTCO_PICKY
								| TNTCO_TOPLEVELTEST | TNTCO_SUBTEST
								| TNTCO_DONTSAVERESULTS;

	tnatd.pfnCanRun			= NULL;
	tnatd.pfnGetInputData	= NULL;
	tnatd.pfnExecCase		= ParmVServerExec_GetClientAddress;
	tnatd.pfnWriteData		= NULL;
	tnatd.pfnFilterSuccess	= NULL;

	tnatd.paGraphs			= NULL;
	tnatd.dwNumGraphs		= 0;

	ADDTESTTOGROUP(&tnatd, pSubGroup);


	return (S_OK);
} // ParmVServerLoadTestTable
#undef DEBUG_SECTION
#define DEBUG_SECTION	""
*/





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_CreateQI()"
//==================================================================================
// ParmVServerExec_CreateQI
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.1 - Server DirectPlay8Create and QueryInterface parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_CreateQI(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8SERVER			pDP8Server = NULL;


	BEGIN_TESTCASE
	{
		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("DirectPlay8Creating a DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = DirectPlay8Create(IID_IDirectPlay8Server, (LPVOID *) &pDP8Server->m_pDP8Server, NULL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "DirectPlay8Creating a DirectPlay8Server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't DirectPlay8Create)

		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;


		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	return (sr);
} // ParmVServerExec_CreateQI
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_Init()"
//==================================================================================
// ParmVServerExec_Init
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.2 - Server Initialize parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_Init(HANDLE hLog)
{
	CTNSystemResult		sr;
	CTNTestResult		tr;
	PWRAPDP8SERVER		pDP8Server = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, handler, 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_Initialize(pDP8Server->m_pDP8Server, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, handler, 0 flags using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, handler, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, handler, 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with 0 flags again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPNERR_ALREADYINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags again didn't return expected error ALREADYINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Re-initializing with 0 flags after init and close");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Re-initializing with 0 flags after init and close failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)


	return (sr);
} // ParmVServerExec_Init
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_EnumSPs()"
//==================================================================================
// ParmVServerExec_EnumSPs
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.3 - Server EnumServiceProviders parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_EnumSPs(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8SERVER				pDP8Server = NULL;
	DWORD						dwSPBufferSize;
	DWORD						dwExpectedSPBufferSize;
	DWORD						dwNumSPs;
	DWORD						dwExpectedNumSPs;
	PDPN_SERVICE_PROVIDER_INFO	pdpnspi = NULL;



	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_EnumServiceProviders(pDP8Server->m_pDP8Server,
													NULL, NULL, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)
*/

		dwNumSPs = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, NULL size, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, NULL, &dwNumSPs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, NULL size, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, NULL count, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, NULL count, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)
*/

		dwSPBufferSize = 0;
		dwNumSPs = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and invalid flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/


		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with NULL context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with NULL context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		// We expect to see at least the IP Service Provider.  We could technically
		// make sure there's room for the string, too, but that would have to be
		// localized.
		dwExpectedSPBufferSize = sizeof (DPN_SERVICE_PROVIDER_INFO);
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, non-zero size, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 12345;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero size, and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 12345)
		{
			DPTEST_FAIL(hLog, "Buffer size modified (%u != 12345)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size modified)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, non-zero count, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = above;
		dwNumSPs = 12345;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero count, and 0 flags didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = above;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size smaller than expected (%u <= %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs < 1)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u < 1)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating service providers with NULL GUIDs, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDPN_SERVICE_PROVIDER_INFO, pdpnspi,
							dwSPBufferSize + BUFFERPADDING_SIZE);

		FillWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		// Expect to get the same values again
		dwExpectedSPBufferSize = dwSPBufferSize;
		dwExpectedNumSPs = dwNumSPs;

		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(NULL, NULL, pdpnspi, &dwSPBufferSize,
												&dwNumSPs, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Enumerating service providers with NULL GUIDs, and 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != dwExpectedNumSPs)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u != %u)!",
				2, dwNumSPs, dwExpectedNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)

#pragma TODO(vanceo, "Verify TCP/IP is in results")

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pdpnspi);
		pdpnspi = NULL;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating invalid SP GUID devices");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&GUID_UNKNOWN, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_DOESNOTEXIST)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating invalid SP GUID devices didn't return expected error DOESNOTEXIST!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != 0)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != 0)!", 1, dwSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 0)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 0)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with invalid app GUID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		//dwExpectedSPBufferSize = ?;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_TCPIP, &GUID_UNKNOWN,
												NULL, &dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with invalid app GUID didn't return expected error BUFFERTOOSMALL!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		/*
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, NULL,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		/*
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating TCP/IP devices with NULL GUIDs, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		LOCALALLOC_OR_THROW(PDPN_SERVICE_PROVIDER_INFO, pdpnspi,
							dwSPBufferSize + BUFFERPADDING_SIZE);

		FillWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE,
					DONT_TOUCH_MEMORY_PATTERN);

		// Expect to get the same values again
		dwExpectedSPBufferSize = dwSPBufferSize;
		dwExpectedNumSPs = dwNumSPs;

		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, pdpnspi,
												&dwSPBufferSize, &dwNumSPs, 0);
		if (tr != DPN_OK)
		{
			if(tr == DPNERR_UNSUPPORTED)
			{
				DPTEST_FAIL(hLog, "Xbox bug 1557 occurred!", 0);
				fPassed = FALSE;
			}
			else
			{
				DPTEST_FAIL(hLog, "Enumerating TCP/IP devices with NULL GUIDs, and 0 flags failed!", 0);
				THROW_TESTRESULT;
			}
		} // end if (couldn't enum service providers)

		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != dwExpectedNumSPs)
		{
			DPTEST_FAIL(hLog, "Number of SPs not expected (%u != %u)!",
				2, dwNumSPs, dwExpectedNumSPs);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (count not expected)

#pragma TODO(vanceo, "Verify results")

		// Make sure the buffer wasn't overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnspi) + dwSPBufferSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "Data was written beyond end of buffer!", 0);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (not still filled with pattern)

		SAFE_LOCALFREE(pdpnspi);
		pdpnspi = NULL;




/* XBOX - IPX not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating IPX devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_IPX, NULL, NULL,
													&dwSPBufferSize, &dwNumSPs, 0);

		// If IPX is not installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating IPX devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



/* XBOX - MODEM not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating modem devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_MODEM, NULL, NULL,
													&dwSPBufferSize, &dwNumSPs, 0);

		// If there aren't any modems installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating modem devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



/* XBOX - SERIAL not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Enumerating serial devices with NULL GUIDs, NULL buffer, and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSPBufferSize = 0;
		//dwExpectedSPBufferSize = ?;
		dwNumSPs = 0;

		tr = pDP8Server->DP8S_EnumServiceProviders(&CLSID_DP8SP_SERIAL, NULL, NULL,
													&dwSPBufferSize, &dwNumSPs, 0);

		// If there aren't any modems installed, then this will return UNSUPPORTED.
		if ((tr != DPNERR_BUFFERTOOSMALL) && (tr != DPNERR_UNSUPPORTED))
		{
			DPTEST_FAIL(hLog, "Enumerating serial devices with NULL GUIDs, NULL buffer, and 0 flags didn't return expected error BUFFERTOOSMALL or UNSUPPORTED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't enum service providers)

#pragma TODO(vanceo, "What do we expect?")
		if (dwSPBufferSize != dwExpectedSPBufferSize)
		{
			DPTEST_FAIL(hLog, "Buffer size not expected (%u != %u)!",
				2, dwSPBufferSize, dwExpectedSPBufferSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size not expected)

		if (dwNumSPs != 4)
		{
			DPTEST_FAIL(hLog, "Number of SPs modified (%u != 4)!", 1, dwNumSPs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (count modified)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_LOCALFREE(pdpnspi);


	return (sr);
} // ParmVServerExec_EnumSPs
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_Cancel()"
//==================================================================================
// ParmVServerExec_Cancel
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.4 - Server CancelAsyncOperation parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_Cancel(HANDLE hLog)
{
	CTNSystemResult			sr;
	CTNTestResult			tr;
	PWRAPDP8SERVER			pDP8Server = NULL;
	//PARMVSCANCELCONTEXT		context;
	PDIRECTPLAY8ADDRESS		pDP8AddressHost = NULL;
	PDIRECTPLAY8ADDRESS		pDP8AddressDevice = NULL;
	//DPN_APPLICATION_DESC	dpnad;
	HOSTENT *pHostent;
	WCHAR szLocalIPAddress[16];
	CHAR szLocalMacAddress[16], *szAnsiLocalIPAddress = NULL;


	//ZeroMemory(&context, sizeof (PARMVSCANCELCONTEXT));


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating host DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8AddressHost, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create host DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting host DirectPlay8Address SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set host DirectPlay8Address SP!", 0);
			THROW_TESTRESULT;
		} // end if (set SP failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Duplicating host DirectPlay8Address for a device address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8AddressHost->Duplicate(&pDP8AddressDevice);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate host DirectPlay8Address for a device address!", 0);
			THROW_TESTRESULT;
		} // end if (duplicate failed)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting remote address hostname to local machine");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// In order to run these tests, need to get the local address information
		// Start by getting the Mac address
		if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		// Then get the IP address
		pHostent = NULL;
		if((pHostent = gethostbyname(szLocalMacAddress)) == NULL)
		{
			xLog(hLog, XLL_FAIL, "Couldn't retrieve IP information for local host");
			SETTHROW_TESTRESULT(E_FAIL);
		}
		
		szAnsiLocalIPAddress = inet_ntoa(*((IN_ADDR *)pHostent->h_addr));

		// Extract the IP address from the hostent stucture
		mbstowcs(szLocalIPAddress, szAnsiLocalIPAddress, strlen(szAnsiLocalIPAddress));
		szLocalIPAddress[strlen(szAnsiLocalIPAddress)] = 0;

		tr = pDP8AddressHost->AddComponent(DPNA_KEY_HOSTNAME,
											szLocalIPAddress,
											(wcslen(szLocalIPAddress) + 1) * sizeof(WCHAR),
											DPNA_DATATYPE_STRING);

		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't set remote address hostname to local machine!", 0);
			THROW_TESTRESULT;
		} // end if (add component failed)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling async operation with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_CancelAsyncOperation(pDP8Server->m_pDP8Server, NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling async operation with NULL and 0 flags using C++ macro didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling async operation with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_CancelAsyncOperation(NULL, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling async operation with NULL and 0 flags didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing with context, 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		//tr = pDP8Server->DP8S_Initialize(&context, ParmVSCancelDPNMessageHandler, 0);
		tr = pDP8Server->DP8S_Initialize(NULL, ParmVNoMessagesDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing with context, 0 flags failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling invalid handle with 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_CancelAsyncOperation(0xABABABAB, 0);
		if (tr != DPNERR_INVALIDHANDLE)
		{
			DPTEST_FAIL(hLog, "Cancelling invalid handle with 0 flags didn't return expected error INVALIDHANDLE!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Cancelling NULL handle with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_CancelAsyncOperation(NULL, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Cancelling NULL handle with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cancel async operation)
*/


#pragma TODO(vanceo, "Cancel send")





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_RELEASE(pDP8AddressHost);
	SAFE_RELEASE(pDP8AddressDevice);


	return (sr);
} // ParmVServerExec_Cancel
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_GetSendQInfo()"
//==================================================================================
// ParmVServerExec_GetSendQInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.5 - Server GetSendQueueInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_GetSendQInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	DWORD						dwNumMsgs = 666;
	DWORD						dwNumBytes = 666;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PARMVSGETSENDQINFOCONTEXT	servercontext;
	PARMVSGETSENDQINFOCONTEXT	clientcontext;



	ZeroMemory(&servercontext, sizeof (PARMVSGETSENDQINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVSGETSENDQINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0s using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_GetSendQueueInfo(pDP8Server->m_pDP8Server, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0s using C++ macro didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with all NULLs and 0s");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with all NULLs and 0s didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting send queue info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting send queue info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing server object with host context");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		servercontext.hLog = hLog;

		tr = pDP8Server->DP8S_Initialize(&servercontext,
										ParmVSGetSendQInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing server object with host context failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting send queue info without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_SERVER_GETSENDQINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Server->DP8S_Host(&dpnad,
									&pDP8Address,
									1,
									NULL,
									NULL,
									&(servercontext.dpnidServer),
									0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

#pragma TODO(vanceo, "Make sure host address object hasn't changed")

		// Make sure we got the create player message.
		if (servercontext.dpnidServer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(0, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for 0 didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for invalid player ID");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo((DPNID) 0x666, &dwNumMsgs, &dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for invalid player ID didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info for local player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidServer, &dwNumMsgs,
											&dwNumBytes, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting send queue info for local player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 666)
		{
			DPTEST_FAIL(hLog, "Num msgs was changed (%u != 666)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was touched)

		if (dwNumBytes != 666)
		{
			DPTEST_FAIL(hLog, "Num bytes was changed (%u != 666)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was touched)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating and connecting new client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		clientcontext.fConnectCanComplete = TRUE;

		clientcontext.hLog = hLog;

		tr = ParmVCreateAndConnectClient(hLog,
										ParmVSGetSendQInfoDPNMessageHandler,
										&clientcontext,
										pDP8Server,
										&dpnad,
										servercontext.hClientCreatedEvent,
										&pDP8Client);

		clientcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating and connecting client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create and connect client)

		CloseHandle(servercontext.hClientCreatedEvent);
		servercontext.hClientCreatedEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient, &dwNumMsgs,
												&dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of client with NULL num msgs");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumBytes = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient, NULL,
												&dwNumBytes, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of client with NULL num msgs failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting send queue info of client with NULL num bytes");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification value.
		dwNumMsgs = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient, &dwNumMsgs,
												NULL, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting send queue info of client with NULL num bytes failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting low priority send queue info of client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_LOW);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting low priority send queue info of client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting normal priority send queue info of client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_NORMAL);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting normal priority send queue info of client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting high priority send queue info of client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient,
											&dwNumMsgs, &dwNumBytes,
											DPNGETSENDQUEUEINFO_PRIORITY_HIGH);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting high priority send queue info of client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting all priority send queues' info of client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Reset the modification values.
		dwNumMsgs = 666;
		dwNumBytes = 666;

		tr = pDP8Server->DP8S_GetSendQueueInfo(servercontext.dpnidClient,
											&dwNumMsgs, &dwNumBytes,
											(DPNGETSENDQUEUEINFO_PRIORITY_LOW | DPNGETSENDQUEUEINFO_PRIORITY_NORMAL | DPNGETSENDQUEUEINFO_PRIORITY_HIGH));
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting all priority send queues' info of client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get send queue info)

		if (dwNumMsgs != 0)
		{
			DPTEST_FAIL(hLog, "Num msgs was not expected (%u != 0)!", 1, dwNumMsgs);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num msgs was unexpected)

		if (dwNumBytes != 0)
		{
			DPTEST_FAIL(hLog, "Num bytes was not expected (%u != 0)!", 1, dwNumBytes);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (num bytes was unexpected)






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);


	return (sr);
} // ParmVServerExec_GetSendQInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_GetAppDesc()"
//==================================================================================
// ParmVServerExec_GetAppDesc
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.6 - Server GetApplication parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_GetAppDesc(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PDIRECTPLAY8ADDRESS			pDP8AddressCompare = NULL;
	PDPN_APPLICATION_DESC		pdpnad = NULL;
	DWORD						dwSize = 0;
	DWORD						dwExpectedSize;
	PARMVSGETAPPDESCCONTEXT		servercontext;
	PARMVSGETAPPDESCCONTEXT		clientcontext;



	ZeroMemory(&servercontext, sizeof (PARMVSGETAPPDESCCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVSGETAPPDESCCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_GetApplicationDesc(pDP8Server->m_pDP8Server, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer and invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer and invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		servercontext.hLog = hLog;

		tr = pDP8Server->DP8S_Initialize(&servercontext,
										ParmVSGetAppDescDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer without a connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer without a connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->Duplicate(&pDP8AddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)

		

		
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_SERVER_GETAPPDESC;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Server->DP8S_Host(&dpnad,
									&pDP8Address,
									1,
									NULL,
									NULL,
									&(servercontext.dpnidServer),
									0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8Address->IsEqual(pDP8AddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8Address, pDP8AddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (servercontext.dpnidServer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_APPLICATION_DESC);

		tr = pDP8Server->DP8S_GetApplicationDesc(NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting app desc with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		LOCALALLOC_OR_THROW(PDPN_APPLICATION_DESC, pdpnad,
							dwSize + BUFFERPADDING_SIZE);

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc using buffer with app desc size of 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnad->dwSize = 0;


		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting app desc using buffer with app desc size of 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnad->dwSize != 0) ||
			(! IsFilledWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc using buffer with app desc size too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC) + 1;


		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting app desc using buffer with app desc size too large didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnad->dwSize != (sizeof (DPN_APPLICATION_DESC) + 1)) ||
			(! IsFilledWithDWord((((PBYTE) pdpnad) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC);

		dpnad.dwCurrentPlayers = 1; // there will be one player when the app desc is retrieved


		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc with extra buffer size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		dwSize += BUFFERPADDING_SIZE;

		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating and connecting new client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		clientcontext.fConnectCanComplete = TRUE;

		clientcontext.hLog = hLog;

		tr = ParmVCreateAndConnectClient(hLog,
										ParmVSGetAppDescDPNMessageHandler,
										&clientcontext,
										pDP8Server,
										&dpnad,
										servercontext.hClientCreatedEvent,
										&pDP8Client);

		clientcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating and connecting client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create and connect client)

		CloseHandle(servercontext.hClientCreatedEvent);
		servercontext.hClientCreatedEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting app desc again");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnad->dwSize = sizeof (DPN_APPLICATION_DESC);

		dpnad.dwCurrentPlayers = 2; // there will be two players when the app desc is retrieved


		FillWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE,
						DONT_TOUCH_MEMORY_PATTERN);

		tr = pDP8Server->DP8S_GetApplicationDesc(pdpnad, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting app desc again failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get app desc)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.
		tr = ParmVCompareAppDesc(hLog, pdpnad, &dpnad);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing application desc buffer %x with expected %x failed!",
				2, pdpnad, &dpnad);
			THROW_TESTRESULT;
		} // end if (failed comparison)


		// Check for buffer overrun.
		if (! IsFilledWithDWord(((PBYTE) pdpnad) + dwSize, BUFFERPADDING_SIZE, DONT_TOUCH_MEMORY_PATTERN))
		{
			DPTEST_FAIL(hLog, "The %u byte app desc buffer (at %x) was overrun!",
				2, dwSize, pdpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_LOCALFREE(pdpnad);
	SAFE_RELEASE(pDP8Address);
	SAFE_RELEASE(pDP8AddressCompare);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);


	return (sr);
} // ParmVServerExec_GetAppDesc
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_SetServerInfo()"
//==================================================================================
// ParmVServerExec_SetServerInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.7 - Server SetServerInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_SetServerInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PARMVSSETSERVERINFOCONTEXT	servercontext;
	PARMVSSETSERVERINFOCONTEXT	clientcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	DPN_PLAYER_INFO				dpnpi;
	DPN_PLAYER_INFO				dpnpiCompare;
	DPNHANDLE					dpnhSetServerInfo;
	DP_DOWORKLIST				DoWorkList;

	ZeroMemory(&DoWorkList, sizeof(DP_DOWORKLIST));

	ZeroMemory(&servercontext, sizeof (PARMVSSETSERVERINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVSSETSERVERINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)





/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info with all NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_SetServerInfo(pDP8Server->m_pDP8Server,
										NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting server info with all NULLs and 0 flags using C++ macro didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info with all NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(NULL, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting server info with all NULLs and 0 flags didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)
*/

		dpnhSetServerInfo = (DPNHANDLE) 0x666;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info with NULL player info structure");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(NULL, NULL, &dpnhSetServerInfo, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Setting server info with NULL player info structure didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (dpnhSetServerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		//dpnpi.dwInfoFlags = 0;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		//dpnpi.dwPlayerFlags = 0;

		CopyMemory(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO));

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info with NULL async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting server info with NULL async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Setting server info with invalid flags structure didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetServerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info synchronously with async op handle");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo,
											DPNSETPEERINFO_SYNC);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Setting server info synchronously with async op handle didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetServerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Setting server info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetServerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		servercontext.hLog = hLog;

		tr = pDP8Server->DP8S_Initialize(&servercontext,
										ParmVSSetServerInfoDPNMessageHandler,
										0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting server info prior to connection failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetServerInfo != (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "Async handle was modified (%x != 0x666)!",
				1, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (handle was set)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_SERVER_SETSERVERINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Server->DP8S_Host(&dpnad,
									&pDP8Address,
									1,
									NULL,
									NULL,
									&(servercontext.dpnidServer),
									0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (servercontext.dpnidServer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "No local message")
		/*
		// Expect the server info message and async op completion.
		servercontext.fCanGetServerInfoUpdate = TRUE;
		//servercontext.pwszExpectedServerInfoName = NULL;
		//servercontext.pvExpectedServerInfoData = NULL;
		//servercontext.dwExpectedServerInfoDataSize = 0;
		servercontext.dwExpectedServerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;
		*/
		CREATEEVENT_OR_THROW(servercontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		servercontext.fAsyncOpCanComplete = TRUE;


		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting server info didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (memcmp(&dpnpiCompare, &dpnpi, sizeof (DPN_PLAYER_INFO)) != 0)
		{
			DPTEST_FAIL(hLog, "Player info structure was modified (structure at %x != structure at %x)!",
				2, &dpnpiCompare, &dpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (player info changed)

		if (dpnhSetServerInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetServerInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

#pragma BUGBUG(vanceo, "No local message")
		// The server info message should have arrived by now.
		//servercontext.fCanGetServerInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		servercontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! servercontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (servercontext.dpnhCompletedAsyncOp != dpnhSetServerInfo)
		{
			DPTEST_FAIL(hLog, "Set server info completed with different async op handle (%x != %x)!",
				2, servercontext.dpnhCompletedAsyncOp, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		servercontext.fAsyncOpCompleted = FALSE;
		CloseHandle(servercontext.hAsyncOpCompletedEvent);
		servercontext.hAsyncOpCompletedEvent = NULL;


#pragma BUGBUG(vanceo, "No local message")
		/*
		// Make sure we got the server info message.
		if (! servercontext.fGotServerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get server info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get server info)

		// Reset the context.
		servercontext.fGotServerInfoUpdate = FALSE;
		*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating and connecting new client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		clientcontext.fConnectCanComplete = TRUE;

		clientcontext.hLog = hLog;

		tr = ParmVCreateAndConnectClient(hLog,
										ParmVSSetServerInfoDPNMessageHandler,
										&clientcontext,
										pDP8Server,
										&dpnad,
										servercontext.hClientCreatedEvent,
										&(clientcontext.pDP8Client));

		clientcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating and connecting client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create and connect client)

		CloseHandle(servercontext.hClientCreatedEvent);
		servercontext.hClientCreatedEvent = NULL;






/* XBOX - SYNC operations not supported
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info synchronously");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#pragma BUGBUG(vanceo, "No local message")
		// Expect the server info message on the server.
		servercontext.fCanGetServerInfoUpdate = TRUE;
		//servercontext.pwszExpectedServerInfoName = NULL;
		//servercontext.pvExpectedServerInfoData = NULL;
		//servercontext.dwExpectedServerInfoDataSize = 0;
		//servercontext.dwExpectedServerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;

		// Expect the server info message on the client.
		clientcontext.fCanGetServerInfoUpdate = TRUE;
		//clientcontext.pwszExpectedServerInfoName = NULL;
		//clientcontext.pvExpectedServerInfoData = NULL;
		//clientcontext.dwExpectedServerInfoDataSize = 0;
		clientcontext.dwExpectedServerInfoPlayerFlags = DPNPLAYER_HOST;
		CREATEEVENT_OR_THROW(clientcontext.hGotServerInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, NULL, DPNSETSERVERINFO_SYNC);

#pragma BUGBUG(vanceo, "No local message")
		// The server info message should have arrived by now.
		//servercontext.fCanGetServerInfoUpdate = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting server info synchronously failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

#pragma BUGBUG(vanceo, "No local message")
		// Make sure we got the server info message.
		if (! servercontext.fGotServerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get server info message on server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get server info)

		// Reset the context.
		servercontext.fGotServerInfoUpdate = FALSE;




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for server info to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = clientcontext.pDP8Client;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 240000, clientcontext.hGotServerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird server info indications.
		clientcontext.fCanGetServerInfoUpdate = FALSE;

#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! clientcontext.fGotServerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get server info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get server info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(clientcontext.hGotServerInfoUpdateEvent);
		clientcontext.hGotServerInfoUpdateEvent = NULL;
		clientcontext.fGotServerInfoUpdate = FALSE;
*/





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting server info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dpnhSetServerInfo = (DPNHANDLE) 0x666;

#pragma BUGBUG(vanceo, "No local message")
		/*
		// Expect the server info message and async op completion on the server.
		servercontext.fCanGetServerInfoUpdate = TRUE;
		//servercontext.pwszExpectedServerInfoName = NULL;
		//servercontext.pvExpectedServerInfoData = NULL;
		//servercontext.dwExpectedServerInfoDataSize = 0;
		//servercontext.dwExpectedServerInfoPlayerFlags = DPNPLAYER_LOCAL | DPNPLAYER_HOST;
		*/
		CREATEEVENT_OR_THROW(servercontext.hAsyncOpCompletedEvent,
							NULL, FALSE, FALSE, NULL);
		servercontext.fAsyncOpCanComplete = TRUE;

		// Expect the server info message on the client.
		clientcontext.fCanGetServerInfoUpdate = TRUE;
		CREATEEVENT_OR_THROW(clientcontext.hGotServerInfoUpdateEvent,
							NULL, FALSE, FALSE, NULL);
		//clientcontext.pwszExpectedServerInfoName = NULL;
		//clientcontext.pvExpectedServerInfoData = NULL;
		//clientcontext.dwExpectedServerInfoDataSize = 0;
		//clientcontext.dwExpectedServerInfoPlayerFlags = DPNPLAYER_HOST;

		tr = pDP8Server->DP8S_SetServerInfo(&dpnpi, NULL, &dpnhSetServerInfo, 0);
		if (tr != (HRESULT) DPNSUCCESS_PENDING)
		{
			DPTEST_FAIL(hLog, "Setting server info didn't return expected PENDING success code!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set server info)

		if (dpnhSetServerInfo == (DPNHANDLE) 0x666)
		{
			DPTEST_FAIL(hLog, "No async operation handle was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (handle was not set)

		if (dpnhSetServerInfo == NULL)
		{
			DPTEST_FAIL(hLog, "Async operation handle returned is NULL!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		} // end if (handle was set to NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for async op to complete on server");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = clientcontext.pDP8Client->m_pDP8Client;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, servercontext.hAsyncOpCompletedEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

#pragma BUGBUG(vanceo, "No local message")
		// The server info message should have arrived by now.
		//servercontext.fCanGetServerInfoUpdate = FALSE;

		// Prevent any weird async op completions.
		servercontext.fAsyncOpCanComplete = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! servercontext.fAsyncOpCompleted)
		{
			DPTEST_FAIL(hLog, "Didn't get async op completion!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get async op completion)
#endif // DEBUG

		// Make sure the completion indicated the same op handle that we were
		// returned.
		if (servercontext.dpnhCompletedAsyncOp != dpnhSetServerInfo)
		{
			DPTEST_FAIL(hLog, "Set server info completed with different async op handle (%x != %x)!",
				2, servercontext.dpnhCompletedAsyncOp, dpnhSetServerInfo);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (async op handle is wrong)

		// Reset the context.
		servercontext.fAsyncOpCompleted = FALSE;
		CloseHandle(servercontext.hAsyncOpCompletedEvent);
		servercontext.hAsyncOpCompletedEvent = NULL;


#pragma BUGBUG(vanceo, "No local message")
		/*
		// Make sure we got the server info message.
		if (! servercontext.fGotServerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get server info message!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get server info)

		// Reset the context.
		servercontext.fGotServerInfoUpdate = FALSE;
		*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Waiting for server info to be indicated on client");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		memset(&DoWorkList, 0, sizeof(DP_DOWORKLIST));
		DoWorkList.fTrackDoWorkTimes = FALSE;
		DoWorkList.dwNumClients = 1;
		DoWorkList.apDP8Clients = (PDIRECTPLAY8CLIENT *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Clients[0] = clientcontext.pDP8Client->m_pDP8Client;
		DoWorkList.dwNumServers = 1;
		DoWorkList.apDP8Servers = (PDIRECTPLAY8SERVER *) MemAlloc(sizeof(LPVOID) * 1);
		DoWorkList.apDP8Servers[0] = pDP8Server->m_pDP8Server;

		if(!PollUntilEventSignalled(hLog, &DoWorkList, 60000, clientcontext.hGotServerInfoUpdateEvent))
		{
			DPTEST_FAIL(hLog, "Polling for asynchronous operation failed!", 0);
			SETTHROW_TESTRESULT(E_FAIL);
		}

		ClearDoWorkList(&DoWorkList);

		// Prevent any weird server info indications.
		clientcontext.fCanGetServerInfoUpdate = FALSE;


#ifdef DEBUG
		// Make sure we got the indication (how else would we get here?).
		if (! clientcontext.fGotServerInfoUpdate)
		{
			DPTEST_FAIL(hLog, "Didn't get server info indication!?  DEBUGBREAK()-ing.", 0);
			DEBUGBREAK();
		} // end if (didn't get server info indication)
#endif // DEBUG

		// Reset the context.
		CloseHandle(clientcontext.hGotServerInfoUpdateEvent);
		clientcontext.hGotServerInfoUpdateEvent = NULL;
		clientcontext.fGotServerInfoUpdate = FALSE;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = clientcontext.pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = clientcontext.pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (clientcontext.pDP8Client);
		clientcontext.pDP8Client = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (clientcontext.pDP8Client != NULL)
	{
		delete (clientcontext.pDP8Client);
		clientcontext.pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hAsyncOpCompletedEvent);
	SAFE_CLOSEHANDLE(clientcontext.hGotServerInfoUpdateEvent);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);
	ClearDoWorkList(&DoWorkList);

	return (sr);
} // ParmVServerExec_SetServerInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_GetClientInfo()"
//==================================================================================
// ParmVServerExec_GetClientInfo
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.8 - Server SetClientInfo parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_GetClientInfo(HANDLE hLog)
{
	CTNSystemResult				sr;
	CTNTestResult				tr;
	PWRAPDP8SERVER				pDP8Server = NULL;
	PWRAPDP8CLIENT				pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS			pDP8Address = NULL;
	PARMVSGETCLIENTINFOCONTEXT	servercontext;
	PARMVSGETCLIENTINFOCONTEXT	clientcontext;
	DPN_APPLICATION_DESC		dpnad;
	DPN_APPLICATION_DESC		dpnadCompare;
	PDPN_PLAYER_INFO			pdpnpi = NULL;
	DPN_PLAYER_INFO				dpnpi;
	DWORD						dwSize;
	DWORD						dwExpectedSize;



	ZeroMemory(&servercontext, sizeof (PARMVSGETCLIENTINFOCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVSGETCLIENTINFOCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8Address, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client 0 info with NULLs and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_GetClientInfo(pDP8Server->m_pDP8Server, 0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client 0 info with NULLs and 0 flags using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client 0 info with NULLs and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo(0, NULL, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client 0 info with NULLs and 0 flags didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info with NULL buffer and non-zero size");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwSize = 666;

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Server->DP8S_GetClientInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting client info with NULL buffer and non-zero size didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 666)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 666)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size was touched)
*/

		dwSize = 0;

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo((DPNID) 0x666, NULL, &dwSize, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting client info with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting client info before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		servercontext.hLog = hLog;

		tr = pDP8Server->DP8S_Initialize(&servercontext,
										ParmVSGetClientInfoDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting client info prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_SERVER_GETCLIENTINFO;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Server->DP8S_Host(&dpnad,
									&pDP8Address,
									1,
									NULL,
									NULL,
									&(servercontext.dpnidServer),
									0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		// Make sure we got the create player message.
		if (servercontext.dpnidServer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info for invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo((DPNID) 0x666, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client info for invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info for local player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientInfo(servercontext.dpnidServer, NULL, &dwSize, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client info for local player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != 0)
		{
			DPTEST_FAIL(hLog, "Size was changed (%u != 0)!", 1, dwSize);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (size is not 0)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating and connecting new client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		clientcontext.fConnectCanComplete = TRUE;

		clientcontext.hLog = hLog;

		tr = ParmVCreateAndConnectClient(hLog,
										ParmVSGetClientInfoDPNMessageHandler,
										&clientcontext,
										pDP8Server,
										&dpnad,
										servercontext.hClientCreatedEvent,
										&pDP8Client);

		clientcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating and connecting client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create and connect client)

		CloseHandle(servercontext.hClientCreatedEvent);
		servercontext.hClientCreatedEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		dwExpectedSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Server->DP8S_GetClientInfo(servercontext.dpnidClient, NULL, &dwSize, 0);
		if (tr != DPNERR_BUFFERTOOSMALL)
		{
			DPTEST_FAIL(hLog, "Getting client info with NULL buffer didn't return expected error BUFFERTOOSMALL!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size was not expected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		LOCALALLOC_OR_THROW(PDPN_PLAYER_INFO, pdpnpi, dwSize + BUFFERPADDING_SIZE);

		FillWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)),
						(dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE),
						DONT_TOUCH_MEMORY_PATTERN);

/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info with player info size of 0");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnpi->dwSize = 0;


		tr = pDP8Server->DP8S_GetClientInfo(servercontext.dpnidClient, pdpnpi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting client info using buffer with player info size of 0 didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnpi->dwSize != 0) ||
			(! IsFilledWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte player info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/



/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info with player info size too large");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO) + 1;

		tr = pDP8Server->DP8S_GetClientInfo(servercontext.dpnidClient, pdpnpi, &dwSize, 0);
		if (tr != DPNERR_INVALIDPARAM)
		{
			DPTEST_FAIL(hLog, "Getting client info using buffer with player info size too large didn't return expected error INVALIDPARAM!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)

		// Make sure the buffer was not modified or overrun.
		if ((pdpnpi->dwSize != (sizeof (DPN_PLAYER_INFO) + 1)) ||
			(! IsFilledWithDWord((((PBYTE) pdpnpi) + sizeof (DWORD)), (dwSize - sizeof (DWORD) + BUFFERPADDING_SIZE), DONT_TOUCH_MEMORY_PATTERN)))
		{
			DPTEST_FAIL(hLog, "The %u byte player info buffer (at %x) was modified or overrun!",
				2, dwSize, pdpnpi);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (buffer was overrun)
*/




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client info");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

		tr = pDP8Server->DP8S_GetClientInfo(servercontext.dpnidClient, pdpnpi, &dwSize, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting client info failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client info)

		if (dwSize != dwExpectedSize)
		{
			DPTEST_FAIL(hLog, "Size returned was unexpected (%u != %u)!", 2, dwSize, dwExpectedSize);
			SETTHROW_TESTRESULT(ERROR_NO_MATCH);
		} // end if (size is not expected)


		// Make sure the structure returned was expected.

		ZeroMemory(&dpnpi, sizeof (DPN_PLAYER_INFO));
		dpnpi.dwSize = sizeof (DPN_PLAYER_INFO);
		dpnpi.dwInfoFlags = DPNINFO_NAME | DPNINFO_DATA;
		//dpnpi.pwszName = NULL;
		//dpnpi.pvData = NULL;
		//dpnpi.dwDataSize = 0;
		//dpnpi.dwPlayerFlags = 0;

		tr = ParmVComparePlayerInfo(hLog, pdpnpi, &dpnpi);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Comparing player info buffer %x with expected %x failed!",
				2, pdpnpi, &dpnpi);
			THROW_TESTRESULT;
		} // end if (failed comparison)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_LOCALFREE(pdpnpi);
	SAFE_RELEASE(pDP8Address);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);


	return (sr);
} // ParmVServerExec_GetClientInfo
#undef DEBUG_SECTION
#define DEBUG_SECTION	""





#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVServerExec_GetClientAddress()"
//==================================================================================
// ParmVServerExec_GetClientAddress
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.2.9 - Server GetClientAddress parameter validation
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Expected input data: None.
//
// Output data: None.
//
// Dynamic variables set: None.
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT ParmVServerExec_GetClientAddress(HANDLE hLog)
{
	CTNSystemResult					sr;
	CTNTestResult					tr;
	PWRAPDP8SERVER					pDP8Server = NULL;
	PWRAPDP8CLIENT					pDP8Client = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddress = NULL;
	PDIRECTPLAY8ADDRESS				pDP8HostAddressCompare = NULL;
	PDIRECTPLAY8ADDRESS				pDP8ReturnedAddress = NULL;
	PARMVSGETCLIENTADDRESSCONTEXT	servercontext;
	PARMVSGETCLIENTADDRESSCONTEXT	clientcontext;
	DPN_APPLICATION_DESC			dpnad;
	DPN_APPLICATION_DESC			dpnadCompare;



	ZeroMemory(&servercontext, sizeof (PARMVSGETCLIENTADDRESSCONTEXT));
	servercontext.fServer = TRUE;

	ZeroMemory(&clientcontext, sizeof (PARMVSGETCLIENTADDRESSCONTEXT));
	//clientcontext.fServer = FALSE;


	BEGIN_TESTCASE
	{
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		pDP8Server = new CWrapDP8Server(hLog);
		if (pDP8Server == NULL)
		{
			SETTHROW_SYSTEMRESULT(E_OUTOFMEMORY);
		} // end if (couldn't allocate object)

		tr = pDP8Server->CoCreate();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't CoCreate DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't cocreate)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating DirectPlay8Address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		sr = DirectPlay8AddressCreate(IID_IDirectPlay8Address, (LPVOID *) &pDP8HostAddress, NULL);
		if (sr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't create DirectPlay8Address object!", 0);
			THROW_SYSTEMRESULT;
		} // end if (create failed)



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Setting address object's SP to TCP/IP");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8HostAddress->SetSP(&CLSID_DP8SP_TCPIP);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Setting address object's SP to TCP/IP failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't set SP)




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client 0 address with NULL and 0 flags using C++ macro");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = IDirectPlay8Server_GetClientAddress(pDP8Server->m_pDP8Server, 0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client 0 address with NULL and 0 flags using C++ macro didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client 0 address with NULL and 0 flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress(0, NULL, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client 0 address with NULL and 0 flags didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client address with NULL buffer");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		// Use 0x666 to avoid DPlay's player ID == 0 check.
		tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x666, NULL, 0);
		if (tr != DPNERR_INVALIDPOINTER)
		{
			DPTEST_FAIL(hLog, "Getting client address with NULL buffer didn't return expected error INVALIDPOINTER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)
*/




/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client address with invalid flags");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0x666);
		if (tr != DPNERR_INVALIDFLAGS)
		{
			DPTEST_FAIL(hLog, "Getting client address with invalid flags didn't return expected error INVALIDFLAGS!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/


/* XBOX - Now RIPs instead of returning an error
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client address before initialization");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_UNINITIALIZED)
		{
			DPTEST_FAIL(hLog, "Getting client address before initialization didn't return expected error UNINITIALIZED!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)
*/



		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Initializing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		servercontext.hLog = hLog;

		tr = pDP8Server->DP8S_Initialize(&servercontext,
										ParmVSGetClientAddressDPNMessageHandler, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Initializing server object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't initialize)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client address prior to connection");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_NOCONNECTION)
		{
			DPTEST_FAIL(hLog, "Getting client address prior to connection didn't return expected error NOCONNECTION!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Saving device address object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8HostAddress->Duplicate(&pDP8HostAddressCompare);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't duplicate device address object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't duplicate device address object)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Hosting session");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		ZeroMemory(&dpnad, sizeof (DPN_APPLICATION_DESC));
		dpnad.dwSize = sizeof (DPN_APPLICATION_DESC);
		dpnad.dwFlags = DPNSESSION_CLIENT_SERVER;
		//dpnad.guidInstance = GUID_NULL;
		dpnad.guidApplication = GUID_PARMV_SERVER_GETCLIENTADDRESS;
		//dpnad.dwMaxPlayers = 0;
		//dpnad.dwCurrentPlayers = 0;
		//dpnad.pwszSessionName = NULL;
		//dpnad.pwszPassword = NULL;
		//dpnad.pvReservedData = NULL;
		//dpnad.dwReservedDataSize = 0;
		//dpnad.pvApplicationReservedData = NULL;
		//dpnad.dwApplicationReservedDataSize = 0;

		// Save what we're passing in to make sure it's not touched.
		CopyMemory(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC));

		tr = pDP8Server->DP8S_Host(&dpnad,
									&pDP8HostAddress,
									1,
									NULL,
									NULL,
									&(servercontext.dpnidServer),
									0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't start hosting session!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't host)

		if (memcmp(&dpnadCompare, &dpnad, sizeof (DPN_APPLICATION_DESC)) != 0)
		{
			DPTEST_FAIL(hLog, "Application desc structure was modified (structure at %x != structure at %x)!",
				2, &dpnadCompare, &dpnad);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (app desc changed)

		tr = pDP8HostAddress->IsEqual(pDP8HostAddressCompare);
		if (tr != DPNSUCCESS_EQUAL)
		{
			DPTEST_FAIL(hLog, "Device address object was modified (0x%08x != 0x%08x)!",
				2, pDP8HostAddress, pDP8HostAddressCompare);
			THROW_TESTRESULT;
		} // end if (addresses aren't equal)

		// Make sure we got the create player message.
		if (servercontext.dpnidServer == 0)
		{
			DPTEST_FAIL(hLog, "Didn't get CREATE_PLAYER indication!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get create player)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client address for invalid player");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress((DPNID) 0x666, &pDP8ReturnedAddress, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting client address for invalid player didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting local server's address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress(servercontext.dpnidServer,
												&pDP8ReturnedAddress, 0);
		if (tr != DPNERR_INVALIDPLAYER)
		{
			DPTEST_FAIL(hLog, "Getting local server's address didn't return expected error INVALIDPLAYER!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress != NULL)
		{
			DPTEST_FAIL(hLog, "Address was changed (%u != NULL)!", 1, pDP8ReturnedAddress);
			SETTHROW_TESTRESULT(ERROR_ARENA_TRASHED);
		} // end if (address is not NULL)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Creating and connecting new client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		CREATEEVENT_OR_THROW(servercontext.hClientCreatedEvent,
							NULL, FALSE, FALSE, NULL);

		clientcontext.fConnectCanComplete = TRUE;

		clientcontext.hLog = hLog;

		tr = ParmVCreateAndConnectClient(hLog,
										ParmVSGetClientAddressDPNMessageHandler,
										&clientcontext,
										pDP8Server,
										&dpnad,
										servercontext.hClientCreatedEvent,
										&pDP8Client);

		clientcontext.fConnectCanComplete = FALSE;

		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Creating and connecting client failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't create and connect client)

		CloseHandle(servercontext.hClientCreatedEvent);
		servercontext.hClientCreatedEvent = NULL;





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Getting client's address");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_GetClientAddress(servercontext.dpnidClient,
												&pDP8ReturnedAddress, 0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Getting client's address failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't get client address)

		if (pDP8ReturnedAddress == NULL)
		{
			DPTEST_FAIL(hLog, "No address was returned!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (no address returned)



#pragma TODO(vanceo, "Validate the address")
		DPTEST_TRACE(hLog, "Client's address = 0x%08x", 1, pDP8ReturnedAddress);





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->DP8C_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing client object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)



		// Technically we should wait to make sure the host saw the client go away
		// as expected but that's more hassle than it's worth.  Just make sure he's
		// gone after Close() has returned.




		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Closing server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->DP8S_Close(0);
		if (tr != DPN_OK)
		{
			DPTEST_FAIL(hLog, "Closing host object failed!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't close)

		// Make sure we got the destroy player messages.
		if (servercontext.dpnidServer != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for server!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)

		if (servercontext.dpnidClient != 0)
		{
			DPTEST_FAIL(hLog, "Didn't get DESTROY_PLAYER indication for client!", 0);
			SETTHROW_TESTRESULT(ERROR_NO_DATA);
		} // end if (didn't get destroy player)





		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing hosting DirectPlay8Client object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Client->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release hosting DirectPlay8Client object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Client);
		pDP8Client = NULL;






		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		TEST_SECTION("Releasing DirectPlay8Server object");
		// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

		tr = pDP8Server->Release();
		if (tr != S_OK)
		{
			DPTEST_FAIL(hLog, "Couldn't release DirectPlay8Server object!", 0);
			THROW_TESTRESULT;
		} // end if (couldn't release object)

		delete (pDP8Server);
		pDP8Server = NULL;



		FINAL_SUCCESS;
	}
	END_TESTCASE


	if (pDP8Client != NULL)
	{
		delete (pDP8Client);
		pDP8Client = NULL;
	} // end if (have client object)

	if (pDP8Server != NULL)
	{
		delete (pDP8Server);
		pDP8Server = NULL;
	} // end if (have server object)

	SAFE_RELEASE(pDP8HostAddress);
	SAFE_RELEASE(pDP8HostAddressCompare);
	SAFE_RELEASE(pDP8ReturnedAddress);
	SAFE_CLOSEHANDLE(servercontext.hClientCreatedEvent);

	return (sr);
} // ParmVServerExec_GetClientAddress
#undef DEBUG_SECTION
#define DEBUG_SECTION	""







#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVSGetSendQInfoDPNMessageHandler()"
//==================================================================================
// ParmVSGetSendQInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVSGetSendQInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVSGETSENDQINFOCONTEXT	pContext = (PPARMVSGETSENDQINFOCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

/* Now that connects must be async, this callback must accept async handles
			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)
*/

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVSGetSendQInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVSGetAppDescDPNMessageHandler()"
//==================================================================================
// ParmVSGetAppDescDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVSGetAppDescDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPARMVSGETAPPDESCCONTEXT	pContext = (PPARMVSGETAPPDESCCONTEXT) pvContext;
	BOOL						fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

/* Now that connects must be async, this callback must accept async handles
			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)
*/

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVSGetAppDescDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVSSetServerInfoDPNMessageHandler()"
//==================================================================================
// ParmVSSetServerInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVSSetServerInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVSSETSERVERINFOCONTEXT		pContext = (PPARMVSSETSERVERINFOCONTEXT) pvContext;
	PDPN_PLAYER_INFO				pdpnpi = NULL;
	DWORD							dwSize = 0;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

/* Now that connects must be async, this callback must accept async handles
			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)
*/

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		case DPN_MSGID_SERVER_INFO:
			PDPNMSG_SERVER_INFO		pServerInfoMsg;


			pServerInfoMsg = (PDPNMSG_SERVER_INFO) pvMsg;

#pragma WAITFORDEVFIX(vanceo, ?, ?, "Ummmmmmmmmmmmmmmmmmmm message is meaningless!??")
			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_SERVER_INFO", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pServerInfoMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidServer = %u/%x", 2, pServerInfoMsg->dpnidServer, pServerInfoMsg->dpnidServer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pServerInfoMsg->pvPlayerContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetServerInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_SERVER_INFO!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the indication.
			if (pServerInfoMsg->dwSize != sizeof (DPNMSG_SERVER_INFO))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_SERVER_INFO is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pServerInfoMsg->dwSize, sizeof (DPNMSG_SERVER_INFO));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pServerInfoMsg->dpnidServer != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Server ID is not 0 (%u/%x)!  DEBUGBREAK()-ing.",
					2, pServerInfoMsg->dpnidServer, pServerInfoMsg->dpnidServer);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player ID is available)

			if (pServerInfoMsg->pvPlayerContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is not NULL (%x)!  DEBUGBREAK()-ing.",
					1, pServerInfoMsg->pvPlayerContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (player context is wrong)


			// Retrieve the server info.
			if (! pContext->fServer)
			{
				hr = pContext->pDP8Client->DP8C_GetServerInfo(NULL, &dwSize, 0);
				if (hr != DPNERR_BUFFERTOOSMALL)
				{
					DPTEST_TRACE(pContext->hLog, "Getting server info size didn't return expected error BUFFERTOOSMALL!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);
					DEBUGBREAK();
					goto DONE;
				} // end if (couldn't get server info)

				pdpnpi = (PDPN_PLAYER_INFO) MemAlloc(dwSize);
				if (pdpnpi == NULL)
				{
					hr = E_OUTOFMEMORY;
					goto DONE;
				} // end if (couldn't allocate memory)

				pdpnpi->dwSize = sizeof (DPN_PLAYER_INFO);

				hr = pContext->pDP8Client->DP8C_GetServerInfo(pdpnpi, &dwSize, 0);
				if (hr != DPN_OK)
				{
					DPTEST_TRACE(pContext->hLog, "Getting server info failed!  DEBUGBREAK()-ing.  0x%08x",
						1, hr);
					DEBUGBREAK();
					goto DONE;
				} // end if (couldn't get server info)

				// Validate the server info.
				if (pdpnpi->dwSize != sizeof (DPN_PLAYER_INFO))
				{
					DPTEST_TRACE(pContext->hLog, "Player info structure size modified (%u != %u)!  DEBUGBREAK()-ing.",
						2, pdpnpi->dwSize, sizeof (DPN_PLAYER_INFO));
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player structure size modified)

				if (pdpnpi->dwInfoFlags != (DPNINFO_NAME | DPNINFO_DATA))
				{
					DPTEST_TRACE(pContext->hLog, "Player info info flags don't match expected (%x != %x)!  DEBUGBREAK()-ing.",
						2, pdpnpi->dwInfoFlags, (DPNINFO_NAME | DPNINFO_DATA));
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player info info flags unexpected)

				if (pContext->pwszExpectedServerInfoName == NULL)
				{
					if (pdpnpi->pwszName != NULL)
					{
						DPTEST_TRACE(pContext->hLog, "Player info contains an unexpected name string \"%S\"!  DEBUGBREAK()-ing.",
							1, pdpnpi->pwszName);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (name was returned)
				} // end if (no name is expected)
				else
				{
					if ((pdpnpi->pwszName == NULL) ||
						(wcscmp(pdpnpi->pwszName, pContext->pwszExpectedServerInfoName) != 0))
					{
						DPTEST_TRACE(pContext->hLog, "Player info name string doesn't match expected (\"%S\" != \"%S\")!  DEBUGBREAK()-ing.",
							2, pdpnpi->pwszName, pContext->pwszExpectedServerInfoName);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (player info name doesn't match)
				} // end else (name is expected)

				if (pContext->pvExpectedServerInfoData == NULL)
				{
					if (pdpnpi->pvData != NULL)
					{
						DPTEST_TRACE(pContext->hLog, "Player info contains unexpected data %x (size = %u)!  DEBUGBREAK()-ing.",
							2, pdpnpi->pvData, pdpnpi->dwDataSize);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (name was returned)
				} // end if (no name is expected)
				else
				{
					if ((pdpnpi->pvData == NULL) ||
						(pdpnpi->dwDataSize != pContext->dwExpectedServerInfoDataSize) ||
						(memcmp(pdpnpi->pvData, pContext->pvExpectedServerInfoData, pdpnpi->dwDataSize) != 0))
					{
						DPTEST_TRACE(pContext->hLog, "Player info data doesn't match expected (%u bytes at %x != %u bytes at %x)!  DEBUGBREAK()-ing.",
							4, pdpnpi->pvData,
							pdpnpi->dwDataSize,
							pContext->pvExpectedServerInfoData,
							pContext->dwExpectedServerInfoDataSize);
						DEBUGBREAK();
						hr = E_FAIL;
						goto DONE;
					} // end if (player data doesn't match)
				} // end else (name is expected)

				if (pdpnpi->dwPlayerFlags != DPNPLAYER_HOST)
				{
					DPTEST_TRACE(pContext->hLog, "Player info player flags don't match expected (%x != DPNPLAYER_HOST)!  DEBUGBREAK()-ing.",
						2, pdpnpi->dwPlayerFlags, DPNPLAYER_HOST);
					DEBUGBREAK();
					hr = E_FAIL;
					goto DONE;
				} // end if (player info player flags unexpected)
			} // end if (not server)


			// Make sure this isn't a double indication.
			if (pContext->fGotServerInfoUpdate)
			{
				DPTEST_TRACE(pContext->hLog, "Server info update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotServerInfoUpdate = TRUE;

			if (! SetEvent(pContext->hGotServerInfoUpdateEvent))
			{
				hr = GetLastError();
				DPTEST_TRACE(pContext->hLog, "Couldn't set got server info update event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hGotServerInfoUpdateEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				hr = E_FAIL;
				goto DONE;
			} // end if (couldn't set event)
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	SAFE_LOCALFREE(pdpnpi);

	return (hr);
} // ParmVSSetServerInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVSGetClientInfoDPNMessageHandler()"
//==================================================================================
// ParmVSGetClientInfoDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVSGetClientInfoDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVSGETCLIENTINFOCONTEXT		pContext = (PPARMVSGETCLIENTINFOCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

/* Now that connects must be async, this callback must accept async handles
			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)
*/

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVSGetClientInfoDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""






#undef DEBUG_SECTION
#define DEBUG_SECTION	"ParmVSGetClientAddressDPNMessageHandler()"
//==================================================================================
// ParmVSGetClientAddressDPNMessageHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT ParmVSGetClientAddressDPNMessageHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT							hr = DPN_OK;
	PPARMVSGETCLIENTADDRESSCONTEXT	pContext = (PPARMVSGETCLIENTADDRESSCONTEXT) pvContext;
	BOOL							fSetEvent = FALSE;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			DPTEST_TRACE(pContext->hLog, "    pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			DPTEST_TRACE(pContext->hLog, "    hResultCode = 0x%08x", 1, pConnectCompleteMsg->hResultCode);
			DPTEST_TRACE(pContext->hLog, "    pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				DPTEST_TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

/* Now that connects must be async, this callback must accept async handles
			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong op handle)
*/

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  0x%08x",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				hr = pConnectCompleteMsg->hResultCode;
				goto DONE;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				DPTEST_TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting CREATE_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting create player on client)


			// Validate the indication.
			if (pCreatePlayerMsg->dwSize != sizeof (DPNMSG_CREATE_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_CREATE_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreatePlayerMsg->dwSize, sizeof (DPNMSG_CREATE_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pCreatePlayerMsg->pvPlayerContext == NULL)
			{
				// Assume this is the remote player being created.  Store the
				// player context.
				pCreatePlayerMsg->pvPlayerContext = &(pContext->dpnidClient);
				fSetEvent = TRUE;
			} // end if (context is not set yet)


			// Make sure this isn't a duplicate message.
			if (*((DPNID*) pCreatePlayerMsg->pvPlayerContext) != 0)
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate CREATE_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pCreatePlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Save the player ID.
			*((DPNID*) pCreatePlayerMsg->pvPlayerContext) = pCreatePlayerMsg->dpnidPlayer;


			// Now set the event, if we're supposed too.
			if (fSetEvent)
			{
				if (! SetEvent(pContext->hClientCreatedEvent))
				{
					hr = GetLastError();
					DPTEST_TRACE(pContext->hLog, "Couldn't set client created event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hClientCreatedEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					goto DONE;
				} // end if (couldn't set event)
			} // end if (should set the event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    dwReason = %x", 1, pDestroyPlayerMsg->dwReason);


			// Make sure this isn't a client.
			if (! pContext->fServer)
			{
				DPTEST_TRACE(pContext->hLog, "Getting DESTROY_PLAYER on client (msg = %x)!?  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (getting destroy player on client)


			// Validate the indication.
			if (pDestroyPlayerMsg->dwSize != sizeof (DPNMSG_DESTROY_PLAYER))
			{
				DPTEST_TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_PLAYER is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwSize, sizeof (DPNMSG_DESTROY_PLAYER));
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (size incorrect)

			if (pDestroyPlayerMsg->pvPlayerContext == NULL)
			{
				DPTEST_TRACE(pContext->hLog, "Player context is NULL!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (context is wrong)

			if (pDestroyPlayerMsg->dwReason != DPNDESTROYPLAYERREASON_NORMAL)
			{
				DPTEST_TRACE(pContext->hLog, "Player destruction reason is unexpected (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyPlayerMsg->dwReason, DPNDESTROYPLAYERREASON_NORMAL);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (reason is wrong)


			// Make sure this isn't a duplicate or bogus message.
			if ((*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) == 0) ||
				(pDestroyPlayerMsg->dpnidPlayer != *((DPNID*) pDestroyPlayerMsg->pvPlayerContext)))
			{
				DPTEST_TRACE(pContext->hLog, "Got duplicate or unexpected DESTROY_PLAYER (msg = %x)!  DEBUGBREAK()-ing.",
					1, pDestroyPlayerMsg);
				DEBUGBREAK();
				hr = E_FAIL;
				goto DONE;
			} // end if (already have ID)

			// Clear the player ID.
			*((DPNID*) pDestroyPlayerMsg->pvPlayerContext) = 0;
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			DPTEST_TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			DPTEST_TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			DPTEST_TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			DPTEST_TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			DPTEST_TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			DPTEST_TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			DPTEST_TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			DPTEST_TRACE(pContext->hLog, "    pAddressPlayer = 0x%08x", 1, pIndicateConnectMsg->pAddressPlayer);
			DPTEST_TRACE(pContext->hLog, "    pAddressDevice = 0x%08x", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			DPTEST_TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)


DONE:

	return (hr);
} // ParmVSGetClientAddressDPNMessageHandler
#undef DEBUG_SECTION
#define DEBUG_SECTION	""

} // namespace DPlayCoreNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\directx\dplay\core\client\pparams.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "dptest.h"
#define BAD_PARAM_TESTS

#define DEBUGBREAK() { _asm int 3 }

//==================================================================================
// Callback contexts
//==================================================================================
typedef struct tagPEERCANCELCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	HANDLE					hConnectCompleteEvent; // event to set when connect completes
	DPNHANDLE				dpnhExpectedAsyncOp; // the expected handle of the completing connect
	HRESULT					hrExpectedResult; // the expected result code of the connect completion
	BOOL					fCompleted; // whether the connect has completed or not
} PEERCANCELCONTEXT, * PPEERCANCELCONTEXT;

typedef struct tagPEERCONNECTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect completion
	BOOL					fCompleted; // whether the connect has completed or not
	HANDLE					hConnectCompleteEvent; // event to set when connect completes
} PEERCONNECTCONTEXT, * PPEERCONNECTCONTEXT;

typedef struct tagPEERSENDTOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fSendCanComplete; // whether the send can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the completed send
	HRESULT					hrExpectedResult; // the expected result code of the send completion
	BOOL					fSendCompleted; // whether the send has completed or not
	HANDLE					hSendCompleteEvent; // event to set when send completes
	BOOL					fCanReceive; // whether a (the) receive is allowed or not
	DWORD					dwExpectedReceiveSize; // expected size of the received message
	BOOL					fReceived; // whether the receive has arrived or not
	HANDLE					hReceiveEvent; // event to set when message is received
} PEERSENDTOCONTEXT, * PPEERSENDTOCONTEXT;

typedef struct tagPEERGETSENDQINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
} PEERGETSENDQINFOCONTEXT, * PPEERGETSENDQINFOCONTEXT;

typedef struct tagPEERHOSTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	DWORD					dwUnused; // ??????????
} PEERHOSTCONTEXT, * PPEERHOSTCONTEXT;

typedef struct tagPEERSETAPPDESCCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fCanGetAppDescUpdate; // whether the app desc message can arrive or not
	BOOL					fGotAppDescUpdate; // whether the app desc message has arrived or not
	HANDLE					hGotAppDescUpdateEvent; // event to set when app desc message is received
} PEERSETAPPDESCCONTEXT, * PPEERSETAPPDESCCONTEXT;

typedef struct tagPEERCREATEGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroupCreated; // the DPNID of the group created
	HANDLE					hGotCreateGroupEvent; // event to set when create group indication is received
} PEERCREATEGROUPCONTEXT, * PPEERCREATEGROUPCONTEXT;

typedef struct tagPEERDESTROYGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetDestroyGroup; // whether the destroy group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy group indication is received
} PEERDESTROYGROUPCONTEXT, * PPEERDESTROYGROUPCONTEXT;

typedef struct tagPEERADDTOGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
} PEERADDTOGROUPCONTEXT, * PPEERADDTOGROUPCONTEXT;

typedef struct tagPEERREMOVEFROMGROUPCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	BOOL					fCanGetRemoveFromGroup; // whether the remove player from group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto/removefrom group indication is received
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
	BOOL					fGotRemoveFromGroup; // whether the remove player from group indication did arrive
} PEERREMOVEFROMGROUPCONTEXT, * PPEERREMOVEFROMGROUPCONTEXT;

typedef struct tagPEERSETGROUPINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	HRESULT					hrExpectedResult; // the expected result code of the connect/group creation
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	BOOL					fCanGetGroupInfo; // whether the add player to group indication can arrive or not
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fGotGroupInfo; // whether the add player to group indication did arrive
} PEERSETGROUPINFOCONTEXT, * PPEERSETGROUPINFOCONTEXT;

typedef struct tagPEERGETGROUPINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PEERGETGROUPINFOCONTEXT, * PPEERGETGROUPINFOCONTEXT;

typedef struct tagPEERENUMPANDGCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PEERENUMPANDGCONTEXT, * PPEERENUMPANDGCONTEXT;

typedef struct tagPEERENUMGROUPMEMBERSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidExpectedPlayer; // the DPNID of the player being added
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
	BOOL					fCanGetAddToGroup; // whether the add player to group indication can arrive or not
	BOOL					fGotAddToGroup; // whether the add player to group indication did arrive
} PEERENUMGROUPMEMBERSCONTEXT, * PPEERENUMGROUPMEMBERSCONTEXT;

typedef struct tagPEERSETPEERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	HANDLE					hAsyncOpCompletedEvent; // event to set when async op completes
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fCanGetPeerInfoUpdate; // whether the peer info indication can arrive or not
	BOOL					fGotPeerInfoUpdate; // whether the peer info indication did arrive
	HANDLE					hGotPeerInfoUpdateEvent; // event to set when peer info message is received
} PEERSETPEERINFOCONTEXT, * PPEERSETPEERINFOCONTEXT;

typedef struct tagPEERGETPEERINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
} PEERGETPEERINFOCONTEXT, * PPEERGETPEERINFOCONTEXT;

typedef struct tagPEERCLOSECONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
} PEERCLOSECONTEXT, * PPEERCLOSECONTEXT;

typedef struct tagPEERENUMHOSTSCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					afAsyncOpCanComplete[2]; // whether the async op completion can arrive or not
	BOOL					afAsyncOpCompleted[2]; // whether the async op has completed or not
	DPNHANDLE				adpnhCompletedAsyncOp[2]; // the handle of the asynchronous operation given in the completion
	HRESULT					ahrExpectedResult[2]; // the expected result code of the async op
	HANDLE					ahAsyncOpCompletedEvent[2]; // event to set when async op completes
	PDIRECTPLAY8ADDRESS		apExpectedDP8AddressSender[2]; // expected address of sender
	PDIRECTPLAY8ADDRESS		apExpectedDP8AddressDevice[2]; // expected address of device
	BOOL					afCanGetResponses[2]; // are queries allowed
	DWORD					dwNumQueries; // number of queries received
	DWORD					adwNumResponses[2]; // number of responses received
} PEERENUMHOSTSCONTEXT, * PPEERENUMHOSTSCONTEXT;

typedef struct tagPEERDESTROYPEERCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
	BOOL					fExpectTerminateSession; // whether the terminate session message is allowed or not
	BOOL					fGotTerminateSession; // whether the terminate session message arrived or not
} PEERDESTROYPEERCONTEXT, * PPEERDESTROYPEERCONTEXT;

typedef struct tagPEERRETURNCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fExpectReceive; // whether receives are allowed or not
	DPNHANDLE				dpnhBuffer; // handle to buffer kept
	HANDLE					hReceivedMsgEvent; // handle to event to set when message arrives
} PEERRETURNCONTEXT, * PPEERRETURNCONTEXT;

typedef struct tagPEERGETPLAYERCONTEXTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
} PEERGETPLAYERCONTEXTCONTEXT, * PPEERGETPLAYERCONTEXTCONTEXT;

typedef struct tagPEERGETGROUPCONTEXTCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	BOOL					fCanGetCreateGroup; // whether the create group indication can arrive or not
	DPNID					dpnidExpectedGroupOwner; // expected group owner DPNID
	DPNID					dpnidGroup; // the DPNID of the group created/to be destroyed
	HANDLE					hGotGroupMsgEvent; // event to set when create/destroy/addto group indication is received
} PEERGETGROUPCONTEXTCONTEXT, * PPEERGETGROUPCONTEXTCONTEXT;

typedef struct tagPEERGETCONNINFOCONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
} PEERGETCONNINFOCONTEXT, * PPEERGETCONNINFOCONTEXT;

typedef struct tagPEERTERMINATECONTEXT
{
	HANDLE					hLog; // Handle to logging subsystem
	BOOL					afExpectCreatePlayer[2]; // whether create player messages are allowed or not
	DPNID					adpnidPlayers[2]; // IDs of the players
	BOOL					fConnectCanComplete; // whether the connect can complete or not
	BOOL					fConnectCompleted; // whether the connect has completed or not
	DPNHANDLE				dpnhCompletedAsyncOp; // the handle of the asynchronous operation given in the completion
	BOOL					fAsyncOpCanComplete; // whether the async op completion can arrive or not
	BOOL					fAsyncOpCompleted; // whether the async op has completed or not
	BOOL					afExpectDestroyPlayer[2]; // whether destroy players are allowed or not
	DWORD					dwNumDestroyPlayersRemaining; // number of destroy player messages that should happen
	HANDLE					hLastPlayerMsgEvent; // event to set when last create/destroy player expected arrives
	BOOL					fExpectTerminateSession; // whether the terminate session message is allowed or not
	BOOL					fGotTerminateSession; // whether the terminate session message arrived or not
} PEERTERMINATECONTEXT, * PPEERTERMINATECONTEXT;

//==================================================================================
// Helper functions
//==================================================================================

//==================================================================================
// TRACE
//----------------------------------------------------------------------------------
//
// Description: Wrapper for the logging stuff that was imported from testnet
//
// Arguments:
//	INT nLogLevel						Indicates level to log message as
//	LPCTSTR szFormat					Buffer that contains the format string
//	INT nNumArgs						Indicates the number of variable arguments present
//
// Returns: nothing
//==================================================================================
void WINAPI TRACE(HANDLE hLog, LPCSTR szFormat, INT nNumArgs ...) {
	CHAR szBuffer[1024] = "";
	va_list pArgs; 

	va_start(pArgs, nNumArgs);
	
	if(!hLog)
	{
		vsprintf(szBuffer, szFormat, pArgs);
		DbgPrint(szBuffer);
	}
	else
		xLog_va(hLog, XLL_INFO, szFormat, pArgs);
	
	va_end(pArgs);
}

//==================================================================================
// PeerCreateHost
//----------------------------------------------------------------------------------
//
// Description: Creates a new DirectPlay8Peer object that is hosting based on the
//				given message handler and application description.  The first hosting
//				address can optionally also be returned.
//
// Arguments:
//	HANDLE hLog								Handle to logging subsystem
//	PFNDPNMESSAGEHANDLER pfn				Message handler to use.
//	PVOID pvContext							Pointer to context for message handler.
//	PDPN_APPLICATION_DESC pdpnad			Pointer to application desc to use when
//											hosting the session
//	PDIRECTPLAY8PEER* ppPeerHost			Place to store pointer to DirectPlay8Peer
//											interface created
//	PVOID pvPlayerContext					Player context for local host player.
//	PDIRECTPLAY8ADDRESS* ppDP8AddressHost	Optional place to store pointer to first
//											address the object is hosting on.
//
// Returns: DPN_OK if successful, error code otherwise.
//==================================================================================
HRESULT PeerCreateHost(HANDLE hLog,
							PFNDPNMESSAGEHANDLER pfn,
							PVOID pvContext,
							PDPN_APPLICATION_DESC pdpnad,
							PDIRECTPLAY8PEER* ppPeerHost,
							PVOID pvPlayerContext,
							PDIRECTPLAY8ADDRESS* ppDP8AddressHost)
{
	PDIRECTPLAY8ADDRESS pDP8AddressDevice = NULL;
	PDIRECTPLAY8ADDRESS* paDP8HostAddresses = NULL;
	HRESULT hr;
	LPVOID pVoice
	DWORD dwNumAddresses = 0;

	// Verify parameters
	if ((*ppPeerHost) != NULL)
	{
		xLog(hLog, XLL_INFO, "Already have peer object (%x)!", (*ppPeerHost));
		return (ERROR_INVALID_PARAMETER);
	}

	// Create the DirectPlay8Peer
	hr = DirectPlay8PeerCreate(ppPeerHost, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_INFO, "Failed with %u", hr);
		goto ERROR_EXIT;
	}
	else
		xLog(hLog, XLL_INFO, "Returned S_OK successfully");

	// Initialize the peer with the given callback function
	hr = (*ppPeerHost)->Initialize(pvContext, pfn, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_INFO, "Initializing DP8Peer object failed!");
		goto ERROR_EXIT;
	}

	// Create the device address
	hr = DirectPlay8AddressCreate(&pDP8AddressDevice)
	if (hr != S_OK)
	{
		xLog(hLog, XLL_INFO, "Couldn't CoCreate host DirectPlay8Address object!");
		goto ERROR_EXIT;
	}

	// Set the device service provider to TCP
	hr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_INFO, "Couldn't set DirectPlay8Address SP!");
		goto ERROR_EXIT;
	}

	// Start hosting a session with the given application description and player context
	hr = (*ppPeerHost)->Host(pdpnad, &pDP8AddressDevice, 1, NULL, NULL, pvPlayerContext, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_INFO, "Hosting failed!");
		goto ERROR_EXIT;
	}

	// Get rid of the address
	pDP8AddressDevice->Release();
	pDP8AddressDevice = NULL;

	// If the caller wants an address, give one to him.
	if (ppDP8AddressHost != NULL)
	{
		// Ignore error
		(*ppPeerHost)->GetLocalHostAddresses(NULL, &dwNumAddresses, 0);

		paDP8HostAddresses = (PDIRECTPLAY8ADDRESS*) LocalAlloc(LPTR, (dwNumAddresses * sizeof (PDIRECTPLAY8ADDRESS)));
		if (paDP8HostAddresses == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto ERROR_EXIT;
		}


		hr = (*ppPeerHost)->GetLocalHostAddresses(paDP8HostAddresses, &dwNumAddresses, 0);
		if (hr != DPN_OK)
		{
			xLog(hLog, XLL_INFO, "Getting local addresses failed!");
			goto ERROR_EXIT;
		}

		// Move the first address to the caller's pointer.
		(*ppDP8AddressHost) = paDP8HostAddresses[0];
		paDP8HostAddresses[0] = NULL;


		// Release all the other addresses.
		while (dwNumAddresses > 1)
		{
			dwNumAddresses--;
			paDP8HostAddresses[dwNumAddresses]->Release();
			paDP8HostAddresses[dwNumAddresses] = NULL;
		}


		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	}


	return (DPN_OK);


ERROR_EXIT:


	if (paDP8HostAddresses != NULL)
	{
		LocalFree(paDP8HostAddresses);
		paDP8HostAddresses = NULL;
	}

	if (pDP8AddressDevice != NULL)
	{
		pDP8AddressDevice->Release();
		pDP8AddressDevice = NULL;
	}

	if ((*ppPeerHost) != NULL)
	{
		delete (*ppPeerHost);
		(*ppPeerHost) = NULL;
	}

	return (hr);
}

//==================================================================================
// PeerCompareAppDesc
//----------------------------------------------------------------------------------
//
// Description: Makes sure the two application desc structures are essentially the
//				same.
//
// Arguments:
//	HANDLE hLog								Handle to event logging subsystem
//	PDPN_APPLICATION_DESC pdpnadCompare		Pointer to app desc to compare.
//	PDPN_APPLICATION_DESC pdpnadExpected	Pointer to app desc to use as reference.
//
// Returns: DPN_OK if they match, a test result error code otherwise.
//==================================================================================
HRESULT PeerCompareAppDesc(HANDLE hLog, PDPN_APPLICATION_DESC pdpnadCompare, PDPN_APPLICATION_DESC pdpnadExpected)
{
	// Compare the size.
	if (pdpnadCompare->dwSize != sizeof (DPN_APPLICATION_DESC))
	{
		TRACE(hLog, "Application desc size is wrong (%u != %u)!",
			2, pdpnadCompare->dwSize, sizeof (DPN_APPLICATION_DESC));
		return (ERROR_NO_MATCH);
	} // end if (size differs)


	// Compare the flags.
	if (pdpnadCompare->dwFlags != pdpnadExpected->dwFlags)
	{
		TRACE(hLog, "Application desc flags are wrong (%x != %x)!",
			2, pdpnadCompare->dwFlags, pdpnadExpected->dwFlags);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Can't compare instance GUID, but we can make sure it's not GUID_NULL.
	if (IsZero(&pdpnadCompare->guidApplication, sizeof (GUID)))
	{
		TRACE(hLog, "Application desc instance GUID was not filled in!", 0);
		return (ERROR_NO_DATA);
	} // end if (no instance GUID)


	// Compare the app GUID.
	if (memcmp(&pdpnadCompare->guidApplication, &pdpnadExpected->guidApplication, sizeof (GUID)) != 0)
	{
		TRACE(hLog, "Application desc app GUID is wrong (%g != %g)!",
			2, &pdpnadCompare->guidApplication, &pdpnadExpected->guidApplication);
		return (ERROR_NO_MATCH);
	} // end if (flags differ)


	// Compare the max players.
	if (pdpnadCompare->dwMaxPlayers != pdpnadExpected->dwMaxPlayers)
	{
		TRACE(hLog, "Application desc max players is wrong (%u != %u)!",
			2, pdpnadCompare->dwMaxPlayers, pdpnadExpected->dwMaxPlayers);
		return (ERROR_NO_MATCH);
	} // end if (max players differs)


	// We only expect one player.
	if (pdpnadCompare->dwCurrentPlayers != 1)
	{
		TRACE(hLog, "Application desc current players is unexpected (%u != 1)!",
			1, pdpnadCompare->dwCurrentPlayers);
		return (ERROR_NO_MATCH);
	} // end if (current players unexpected)


	// Compare the session name.
	if (pdpnadExpected->pwszSessionName != NULL)
	{
		if (pdpnadCompare->pwszSessionName != NULL)
		{
			if (wcscmp(pdpnadCompare->pwszSessionName, pdpnadExpected->pwszSessionName) != 0)
			{
				TRACE(hLog, "Application desc session name is wrong (\"%S\"!= \"%S\")!",
					2, pdpnadCompare->pwszSessionName, pdpnadExpected->pwszSessionName);
				return (ERROR_NO_MATCH);
			} // end if (name differs)
		} // end if (received session name)
		else
		{
			TRACE(hLog, "Application desc session name (\"%S\") was not returned!",
				1, pdpnadExpected->pwszSessionName);
			return (ERROR_NO_MATCH);
		} // end if (no name specified)
	} // end if (gave session name)
	else
	{
		if (pdpnadCompare->pwszSessionName != NULL)
		{
			TRACE(hLog, "Unexpected application desc session name was returned (\"%S\")!",
				1, pdpnadCompare->pwszSessionName);
			return (ERROR_NO_MATCH);
		} // end if (name returned)
	} // end else (didn't specify session name)


	// Compare the password.
	if (pdpnadExpected->pwszPassword != NULL)
	{
		if (pdpnadCompare->pwszPassword != NULL)
		{
			if (wcscmp(pdpnadCompare->pwszPassword, pdpnadExpected->pwszPassword) != 0)
			{
				TRACE(hLog, "Application desc password is wrong (\"%S\"!= \"%S\")!",
					2, pdpnadCompare->pwszPassword, pdpnadExpected->pwszPassword);
				return (ERROR_NO_MATCH);
			} // end if (password differs)
		} // end if (received password)
		else
		{
			TRACE(hLog, "Application desc password (\"%S\") was not returned!",
				1, pdpnadExpected->pwszPassword);
			return (ERROR_NO_MATCH);
		} // end if (no password specified)
	} // end if (gave password)
	else
	{
		if (pdpnadCompare->pwszPassword != NULL)
		{
			TRACE(hLog, "Unexpected application desc password was returned (\"%S\")!",
				1, pdpnadCompare->pwszPassword);
			return (ERROR_NO_MATCH);
		} // end if (password returned)
	} // end else (didn't specify password)


	// Reserved data is not allowed or expected.
	if ((pdpnadCompare->pvReservedData != NULL) || (pdpnadCompare->dwReservedDataSize != 0))
	{
		TRACE(hLog, "Application desc reserved data was returned (ptr %x, size %u)!",
			2, pdpnadCompare->pvReservedData, pdpnadCompare->dwReservedDataSize);
		return (ERROR_NO_MATCH);
	} // end if (reserved data returned)


	// Compare the application reserved data.
	if (pdpnadExpected->pvApplicationReservedData != NULL)
	{
		if ((pdpnadCompare->pvApplicationReservedData != NULL) &&
			(pdpnadCompare->dwApplicationReservedDataSize == pdpnadExpected->dwApplicationReservedDataSize))
		{
			if (memcmp(pdpnadCompare->pvApplicationReservedData, pdpnadExpected->pvApplicationReservedData, pdpnadCompare->dwApplicationReservedDataSize) != 0)
			{
				TRACE(hLog, "Application desc app reserved data is wrong (%u byte data at \"%x\"!= data at \"%x\")!",
					3, pdpnadCompare->dwApplicationReservedDataSize,
					pdpnadCompare->pvApplicationReservedData,
					pdpnadExpected->pvApplicationReservedData);
				return (ERROR_NO_MATCH);
			} // end if (app reserved data differs)
		} // end if (received app reserved data)
		else
		{
			TRACE(hLog, "Application desc app reserved data (data \"%x\", size %u) was not returned, data ptr was %x and size was %u!",
				4, pdpnadExpected->pvApplicationReservedData,
				pdpnadExpected->dwApplicationReservedDataSize,
				pdpnadCompare->pvApplicationReservedData,
				pdpnadCompare->dwApplicationReservedDataSize);
			return (ERROR_NO_MATCH);
		} // end if (no app reserved data specified)
	} // end if (gave app reserved data)
	else
	{
		if ((pdpnadCompare->pvApplicationReservedData != NULL) ||
			(pdpnadCompare->dwApplicationReservedDataSize != 0))
		{
			TRACE(hLog, "Unexpected application desc app reserved data was returned (data \"%x\", size = %u)!",
				2, pdpnadCompare->pvApplicationReservedData,
				pdpnadCompare->dwApplicationReservedDataSize);
			return (ERROR_NO_MATCH);
		} // end if (app reserved data returned)
	} // end else (didn't specify app reserved data)

	return (DPN_OK);
}

//==================================================================================
// Callback functions
//==================================================================================

//==================================================================================
// PeerNoMessagesHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: always returns E_FAIL
//==================================================================================
HRESULT PeerNoMessagesHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	TRACE(NULL, "Got unexpected message type %x!  DEBUGBREAK()-ing.",1, dwMsgType);
	DEBUGBREAK();

	return (E_NOTIMPL);
}

//==================================================================================
// PeerCancelHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerCancelHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPEERCANCELCONTEXT		pContext = (PPEERCANCELCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->hAsyncOp != pContext->dpnhExpectedAsyncOp)
			{
				TRACE(pContext->hLog, "Connect completed with wrong async op handle (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hAsyncOp, pContext->dpnhExpectedAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->pvUserContext != pContext->hConnectCompleteEvent)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvUserContext,
					pContext->hConnectCompleteEvent);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			if (pConnectCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				TRACE(pContext->hLog, "Connect completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				break;
			} // end if (unexpected result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Make sure this isn't a double completion.
			if (pContext->fCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fCompleted = TRUE;

			if (! SetEvent(pContext->hConnectCompleteEvent))
			{
				hr = GetLastError();
				TRACE(pContext->hLog, "Couldn't set connect completion event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hConnectCompleteEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerConnectHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerConnectHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPEERCONNECTCONTEXT		pContext = (PPEERCONNECTCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				TRACE(pContext->hLog, "Connect completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pConnectCompleteMsg->hAsyncOp;

			if (pContext->hConnectCompleteEvent != NULL)
			{
				if (! SetEvent(pContext->hConnectCompleteEvent))
				{
					hr = GetLastError();
					TRACE(pContext->hLog, "Couldn't set connect completion event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hConnectCompleteEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's an event to set)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerNewPlayerHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerNewPlayerHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT		hr = DPN_OK;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(NULL, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(NULL, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(NULL, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(NULL, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(NULL, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(NULL, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(NULL, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(NULL, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			TRACE(NULL, "DPN_MSGID_INDICATE_CONNECT", 0);
			TRACE(NULL, "     dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			TRACE(NULL, "     pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			TRACE(NULL, "     dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			TRACE(NULL, "     pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			TRACE(NULL, "     dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			TRACE(NULL, "     pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			TRACE(NULL, "     pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			TRACE(NULL, "     pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			TRACE(NULL, "     pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);
		  break;

		default:
			TRACE(NULL, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerSendToHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerSendToHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT					hr = DPN_OK;
	PPEERSENDTOCONTEXT		pContext = (PPEERSENDTOCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_RECEIVE:
			PDPNMSG_RECEIVE		pReceiveMsg;


			pReceiveMsg = (PDPNMSG_RECEIVE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_RECEIVE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pReceiveMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidSender = %u/%x", 2, pReceiveMsg->dpnidSender, pReceiveMsg->dpnidSender);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pReceiveMsg->pvPlayerContext);
			TRACE(pContext->hLog, "     pReceiveData = %x", 1, pReceiveMsg->pReceiveData);
			TRACE(pContext->hLog, "     dwReceiveDataSize = %u", 1, pReceiveMsg->dwReceiveDataSize);
			TRACE(pContext->hLog, "     hBufferHandle = %x", 1, pReceiveMsg->hBufferHandle);


			// Make sure we expect the receive.
			if (! pContext->fCanReceive)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_RECEIVE (%x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the receive.
			if (pReceiveMsg->dwSize != sizeof (DPNMSG_RECEIVE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_RECEIVE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwSize, sizeof (DPNMSG_RECEIVE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

#pragma TODO(vanceo, "Validate player ID")

			if (pReceiveMsg->pvPlayerContext != NULL)
			{
				TRACE(pContext->hLog, "Receive indicated with wrong player context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg->pvPlayerContext);
				DEBUGBREAK();
				break;
			} // end if (player context incorrect)

			if (pReceiveMsg->pReceiveData == NULL)
			{
				TRACE(pContext->hLog, "Receive indicated with NULL data pointer!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (receive buffer invalid)

			if (pReceiveMsg->dwReceiveDataSize != pContext->dwExpectedReceiveSize)
			{
				TRACE(pContext->hLog, "Receive indicated with wrong size (%u != %u)!  DEBUGBREAK()-ing.",
					2, pReceiveMsg->dwReceiveDataSize, pContext->dwExpectedReceiveSize);
				DEBUGBREAK();
				break;
			} // end if (wrong buffer size)

#pragma TODO(vanceo, "Validate buffer")


			if (pReceiveMsg->hBufferHandle == NULL)
			{
				TRACE(pContext->hLog, "Receive indicated with NULL buffer handle!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (buffer handle invalid)



			// Make sure this isn't a double receive.
			if (pContext->fReceived)
			{
				TRACE(pContext->hLog, "Receive indicated twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pReceiveMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the receive came in.
			pContext->fReceived = TRUE;

			if (! SetEvent(pContext->hReceiveEvent))
			{
				hr = GetLastError();
				TRACE(pContext->hLog, "Couldn't set receive event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hReceiveEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_SEND_COMPLETE:
			PDPNMSG_SEND_COMPLETE	pSendCompleteMsg;


			pSendCompleteMsg = (PDPNMSG_SEND_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_SEND_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pSendCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pSendCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pSendCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pSendCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     dwSendTime = %u", 1, pSendCompleteMsg->dwSendTime);


			// Make sure we expect the completion.
			if (! pContext->fSendCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_SEND_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pSendCompleteMsg->dwSize != sizeof (DPNMSG_SEND_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_SEND_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pSendCompleteMsg->dwSize, sizeof (DPNMSG_SEND_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pSendCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Send completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pSendCompleteMsg->hResultCode != pContext->hrExpectedResult)
			{
				TRACE(pContext->hLog, "Send completed with wrong error code (%x != %x)!  DEBUGBREAK()-ing.",
					2, pSendCompleteMsg->hResultCode, pContext->hrExpectedResult);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)



			// Make sure this isn't a double completion.
			if (pContext->fSendCompleted)
			{
				TRACE(pContext->hLog, "Send completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pSendCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fSendCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pSendCompleteMsg->hAsyncOp;

			if (pContext->hSendCompleteEvent != NULL)
			{
				if (! SetEvent(pContext->hSendCompleteEvent))
				{
					hr = GetLastError();
					TRACE(pContext->hLog, "Couldn't set send completion event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hSendCompleteEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's an event to set)
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerGetSendQInfoHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerGetSendQInfoHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPEERGETSENDQINFOCONTEXT	pContext = (PPEERGETSENDQINFOCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;
			
			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);

			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			TRACE(pContext->hLog, "    pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			TRACE(pContext->hLog, "    pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerHostHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerHostHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT				hr = DPN_OK;
	PPEERHOSTCONTEXT	pContext = (PPEERHOSTCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerSetAppDescHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerSetAppDescHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPEERSETAPPDESCCONTEXT		pContext = (PPEERSETAPPDESCCONTEXT) pvContext;

	switch (dwMsgType)
	{
		case DPN_MSGID_APPLICATION_DESC:
			// Make sure we expect the indication.
			if (! pContext->fCanGetAppDescUpdate)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_APPLICATION_DESC!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Make sure this isn't a double indication.
			if (pContext->fGotAppDescUpdate)
			{
				TRACE(pContext->hLog, "App desc update was indicated twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->fGotAppDescUpdate = TRUE;

			if (! SetEvent(pContext->hGotAppDescUpdateEvent))
			{
				hr = GetLastError();
				TRACE(pContext->hLog, "Couldn't set got app desc update event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hGotAppDescUpdateEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			TRACE(pContext->hLog, "    pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			TRACE(pContext->hLog, "    pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerCreateGroupHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerCreateGroupHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPEERCREATEGROUPCONTEXT		pContext = (PPEERCREATEGROUPCONTEXT) pvContext;

	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreateGroupMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			TRACE(pContext->hLog, "     dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			TRACE(pContext->hLog, "     pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				break;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroupCreated != 0)
			{
				TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroupCreated = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotCreateGroupEvent != NULL)
			{
				if (! SetEvent(pContext->hGotCreateGroupEvent))
				{
					hr = GetLastError();
					TRACE(pContext->hLog, "Couldn't set got create group event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotCreateGroupEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's a create group event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			TRACE(pContext->hLog, "     pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			TRACE(pContext->hLog, "     dwReason = %u", 1, pDestroyGroupMsg->dwReason);

#pragma TODO(vanceo, "Handle/validate destroy group")
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			TRACE(pContext->hLog, "    pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			TRACE(pContext->hLog, "    pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// PeerCreateGroupHandler
//----------------------------------------------------------------------------------
//
// Description: Callback that DirectPlay8 will use to notify us of events.
//
// Arguments:
//	PVOID pvContext		Pointer to context specified when this handler was
//						specified.
//	DWORD dwMsgType		Type of message being indicated.
//	PVOID pvMsg			Depends on type of message.
//
// Returns: depends on message (usually DPN_OK).
//==================================================================================
HRESULT PeerCreateGroupHandler(PVOID pvContext, DWORD dwMsgType, PVOID pvMsg)
{
	HRESULT						hr = DPN_OK;
	PPEERDESTROYGROUPCONTEXT	pContext = (PPEERDESTROYGROUPCONTEXT) pvContext;


	switch (dwMsgType)
	{
		case DPN_MSGID_ASYNC_OP_COMPLETE:
			PDPNMSG_ASYNC_OP_COMPLETE	pAsyncOpCompleteMsg;


			pAsyncOpCompleteMsg = (PDPNMSG_ASYNC_OP_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_ASYNC_OP_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pAsyncOpCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pAsyncOpCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pAsyncOpCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pAsyncOpCompleteMsg->hResultCode);


			// Make sure we expect the completion.
			if (! pContext->fAsyncOpCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_ASYNC_OP_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pAsyncOpCompleteMsg->dwSize != sizeof (DPNMSG_ASYNC_OP_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_ASYNC_OP_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pAsyncOpCompleteMsg->dwSize, sizeof (DPNMSG_ASYNC_OP_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pAsyncOpCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Async op completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pAsyncOpCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Async op completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pAsyncOpCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)


			// Make sure this isn't a double completion.
			if (pContext->fAsyncOpCompleted)
			{
				TRACE(pContext->hLog, "Async op completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pAsyncOpCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fAsyncOpCompleted = TRUE;

			// Remember the async op handle for comparison by the main thread.
			pContext->dpnhCompletedAsyncOp = pAsyncOpCompleteMsg->hAsyncOp;

			if (! SetEvent(pContext->hAsyncOpCompletedEvent))
			{
				hr = GetLastError();
				TRACE(pContext->hLog, "Couldn't set async op completed event (%x)!  DEBUGBREAK()-ing.",
					1, pContext->hAsyncOpCompletedEvent);

				DEBUGBREAK();

				if (hr == S_OK)
					hr = E_FAIL;

				break;
			} // end if (couldn't set event)
		  break;

		case DPN_MSGID_CONNECT_COMPLETE:
			PDPNMSG_CONNECT_COMPLETE	pConnectCompleteMsg;


			pConnectCompleteMsg = (PDPNMSG_CONNECT_COMPLETE) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CONNECT_COMPLETE", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pConnectCompleteMsg->dwSize);
			TRACE(pContext->hLog, "     hAsyncOp = %x", 1, pConnectCompleteMsg->hAsyncOp);
			TRACE(pContext->hLog, "     pvUserContext = %x", 1, pConnectCompleteMsg->pvUserContext);
			TRACE(pContext->hLog, "     hResultCode = %e", 1, pConnectCompleteMsg->hResultCode);
			TRACE(pContext->hLog, "     pvApplicationReplyData = %x", 1, pConnectCompleteMsg->pvApplicationReplyData);
			TRACE(pContext->hLog, "     dwApplicationReplyDataSize = %u", 1, pConnectCompleteMsg->dwApplicationReplyDataSize);


			// Make sure we expect the completion.
			if (! pContext->fConnectCanComplete)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CONNECT_COMPLETE (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the completion.
			if (pConnectCompleteMsg->dwSize != sizeof (DPNMSG_CONNECT_COMPLETE))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CONNECT_COMPLETE is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->dwSize, sizeof (DPNMSG_CONNECT_COMPLETE));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pConnectCompleteMsg->hAsyncOp != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with an async op handle (%x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->hAsyncOp);
				DEBUGBREAK();
				break;
			} // end if (wrong op handle)

			if (pConnectCompleteMsg->pvUserContext != NULL)
			{
				TRACE(pContext->hLog, "Connect completed with wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg->pvUserContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pConnectCompleteMsg->hResultCode != DPN_OK)
			{
				TRACE(pContext->hLog, "Connect completed with failure!  DEBUGBREAK()-ing.  %e",
					1, pConnectCompleteMsg->hResultCode);
				DEBUGBREAK();
				break;
			} // end if (wrong result code)

			if ((pConnectCompleteMsg->pvApplicationReplyData != NULL) ||
				(pConnectCompleteMsg->dwApplicationReplyDataSize != 0))
			{
				TRACE(pContext->hLog, "Connect completed with unexpected reply data (ptr %x != NULL or size %u != 0)!  DEBUGBREAK()-ing.",
					2, pConnectCompleteMsg->pvApplicationReplyData,
					pConnectCompleteMsg->dwApplicationReplyDataSize);
				DEBUGBREAK();
				break;
			} // end if (unexpected reply data)


			// Make sure this isn't a double completion.
			if (pContext->fConnectCompleted)
			{
				TRACE(pContext->hLog, "Connect completed twice (msg = %x)!  DEBUGBREAK()-ing.",
					1, pConnectCompleteMsg);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the completion came in.
			pContext->fConnectCompleted = TRUE;
		  break;

		case DPN_MSGID_CREATE_GROUP:
			PDPNMSG_CREATE_GROUP	pCreateGroupMsg;


			pCreateGroupMsg = (PDPNMSG_CREATE_GROUP) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_GROUP", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreateGroupMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidGroup = %u/%x", 2, pCreateGroupMsg->dpnidGroup, pCreateGroupMsg->dpnidGroup);
			TRACE(pContext->hLog, "     dpnidOwner = %u/%x", 2, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner);
			TRACE(pContext->hLog, "     pvGroupContext = %x", 1, pCreateGroupMsg->pvGroupContext);


			// Make sure we expect the indication.
			if (! pContext->fCanGetCreateGroup)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_CREATE_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)

			// Validate the message.
			if (pCreateGroupMsg->dwSize != sizeof (DPNMSG_CREATE_GROUP))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_CREATE_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pCreateGroupMsg->dwSize, sizeof (DPNMSG_CREATE_GROUP));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pCreateGroupMsg->dpnidGroup == 0)
			{
				TRACE(pContext->hLog, "Group created got invalid ID of 0!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (group ID is 0)

			if (pCreateGroupMsg->dpnidOwner != pContext->dpnidExpectedGroupOwner)
			{
				TRACE(pContext->hLog, "Group owner was wrong (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pCreateGroupMsg->dpnidOwner, pCreateGroupMsg->dpnidOwner,
					pContext->dpnidExpectedGroupOwner, pContext->dpnidExpectedGroupOwner);
				DEBUGBREAK();
				break;
			} // end if (group owner is wrong)

			if (pCreateGroupMsg->pvGroupContext != NULL)
			{
				TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pCreateGroupMsg->pvGroupContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)



			// Make sure this isn't a double indication.
			if (pContext->dpnidGroup != 0)
			{
				TRACE(pContext->hLog, "Got create group twice!  DEBUGBREAK()-ing.", 0);
				DEBUGBREAK();
				break;
			} // end if (double completion)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = pCreateGroupMsg->dpnidGroup;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_CREATE_PLAYER:
			PDPNMSG_CREATE_PLAYER	pCreatePlayerMsg;


			pCreatePlayerMsg = (PDPNMSG_CREATE_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_CREATE_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pCreatePlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pCreatePlayerMsg->dpnidPlayer, pCreatePlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pCreatePlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate CREATE_PLAYER")
		  break;

		case DPN_MSGID_DESTROY_GROUP:
			PDPNMSG_DESTROY_GROUP	pDestroyGroupMsg;


			pDestroyGroupMsg = (PDPNMSG_DESTROY_GROUP) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_GROUP", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyGroupMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidGroup = %u/%x", 2, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup);
			TRACE(pContext->hLog, "     pvGroupContext = %x", 1, pDestroyGroupMsg->pvGroupContext);
			TRACE(pContext->hLog, "     dwReason = %u", 1, pDestroyGroupMsg->dwReason);


			// Make sure we expect the indication.
			if (! pContext->fCanGetDestroyGroup)
			{
				TRACE(pContext->hLog, "Got unexpected DPN_MSGID_DESTROY_GROUP (at %x)!  DEBUGBREAK()-ing.",
					1, pDestroyGroupMsg);
				DEBUGBREAK();
				break;
			} // end if (message unexpected)


			// Validate the message.
			if (pDestroyGroupMsg->dwSize != sizeof (DPNMSG_DESTROY_GROUP))
			{
				TRACE(pContext->hLog, "Size of DPNMSG_DESTROY_GROUP is incorrect (%u != %u)!  DEBUGBREAK()-ing.",
					2, pDestroyGroupMsg->dwSize, sizeof (DPNMSG_DESTROY_GROUP));
				DEBUGBREAK();
				break;
			} // end if (size incorrect)

			if (pDestroyGroupMsg->dpnidGroup != pContext->dpnidGroup)
			{
				TRACE(pContext->hLog, "Group being destroy has wrong ID (%u/%x != %u/%x)!  DEBUGBREAK()-ing.",
					4, pDestroyGroupMsg->dpnidGroup, pDestroyGroupMsg->dpnidGroup,
					pContext->dpnidGroup, pContext->dpnidGroup);
				DEBUGBREAK();
				break;
			} // end if (group ID is wrong)

			if (pDestroyGroupMsg->pvGroupContext != NULL)
			{
				TRACE(pContext->hLog, "Group has wrong context (%x != NULL)!  DEBUGBREAK()-ing.",
					1, pDestroyGroupMsg->pvGroupContext);
				DEBUGBREAK();
				break;
			} // end if (wrong context)

			if (pDestroyGroupMsg->dwReason != DPNDESTROYGROUPREASON_NORMAL)
			{
				TRACE(pContext->hLog, "Reason group being destroyed is wrong (%x != %x)!  DEBUGBREAK()-ing.",
					2, pDestroyGroupMsg->dwReason, DPNDESTROYGROUPREASON_NORMAL);
				DEBUGBREAK();
				break;
			} // end if (reason is wrong)

			// Alert the test case that the indication came in.
			pContext->dpnidGroup = 0;

			if (pContext->hGotGroupMsgEvent != NULL)
			{
				if (! SetEvent(pContext->hGotGroupMsgEvent))
				{
					hr = GetLastError();
					TRACE(pContext->hLog, "Couldn't set got group msg event (%x)!  DEBUGBREAK()-ing.",
						1, pContext->hGotGroupMsgEvent);

					DEBUGBREAK();

					if (hr == S_OK)
						hr = E_FAIL;

					break;
				} // end if (couldn't set event)
			} // end if (there's a group msg event)
		  break;

		case DPN_MSGID_DESTROY_PLAYER:
			PDPNMSG_DESTROY_PLAYER	pDestroyPlayerMsg;


			pDestroyPlayerMsg = (PDPNMSG_DESTROY_PLAYER) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_DESTROY_PLAYER", 0);
			TRACE(pContext->hLog, "     dwSize = %u", 1, pDestroyPlayerMsg->dwSize);
			TRACE(pContext->hLog, "     dpnidPlayer = %u/%x", 2, pDestroyPlayerMsg->dpnidPlayer, pDestroyPlayerMsg->dpnidPlayer);
			TRACE(pContext->hLog, "     pvPlayerContext = %x", 1, pDestroyPlayerMsg->pvPlayerContext);

#pragma TODO(vanceo, "Validate DPN_MSGID_DESTROY_PLAYER")
		  break;

		case DPN_MSGID_INDICATE_CONNECT:
			PDPNMSG_INDICATE_CONNECT	pIndicateConnectMsg;


			pIndicateConnectMsg = (PDPNMSG_INDICATE_CONNECT) pvMsg;

			TRACE(pContext->hLog, "DPN_MSGID_INDICATE_CONNECT", 0);
			TRACE(pContext->hLog, "    dwSize = %u", 1, pIndicateConnectMsg->dwSize);
			TRACE(pContext->hLog, "    pvUserConnectData = %x", 1, pIndicateConnectMsg->pvUserConnectData);
			TRACE(pContext->hLog, "    dwUserConnectDataSize = %u", 1, pIndicateConnectMsg->dwUserConnectDataSize);
			TRACE(pContext->hLog, "    pvReplyData = %x", 1, pIndicateConnectMsg->pvReplyData);
			TRACE(pContext->hLog, "    dwReplyDataSize = %u", 1, pIndicateConnectMsg->dwReplyDataSize);
			TRACE(pContext->hLog, "    pvReplyContext = %x", 1, pIndicateConnectMsg->pvReplyContext);
			TRACE(pContext->hLog, "    pvPlayerContext = %x", 1, pIndicateConnectMsg->pvPlayerContext);
			TRACE(pContext->hLog, "    pAddressPlayer = %a", 1, pIndicateConnectMsg->pAddressPlayer);
			TRACE(pContext->hLog, "    pAddressDevice = %a", 1, pIndicateConnectMsg->pAddressDevice);

#pragma TODO(vanceo, "Validate DPN_MSGID_INDICATE_CONNECT")
		  break;

		default:
			TRACE(pContext->hLog, "Got unexpected message type %x!  DEBUGBREAK()-ing.",
				1, dwMsgType);
			DEBUGBREAK();
			hr = E_NOTIMPL;
		  break;
	} // end switch (on message type)

	return (hr);
}

//==================================================================================
// Test case functions
//==================================================================================

//==================================================================================
// PeerParamsDPCreateTests
//----------------------------------------------------------------------------------
//
// Description: Function that executes the test case(s):
//				2.1.1.1 - Peer DirectPlay8Create parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsDPCreateTests(HANDLE hLog)
{
	HRESULT	hr;
	LPVOID pPeer, pVoice;

#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "DirectPlay8PeerCreate with both pointers NULL"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8PeerCreate with both pointers null");
	
	hr = DirectPlay8PeerCreate(NULL, NULL);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "Didn't fail with expected error INVALIDPOINTER!");
	else
		xLog(hLog, XLL_PASS, "Returned INVALIDPOINTER successfully");

	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "DirectPlay8PeerCreate with voice pointer NULL"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8PeerCreate with voice pointer null");
	
	pPeer = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, NULL);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Didn't fail with expected error INVALIDPOINTER!");
		((PDIRECTPLAY8PEER) pPeer)->Release();
	}
	else
		xLog(hLog, XLL_PASS, "Returned INVALIDPOINTER successfully");

	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "DirectPlay8PeerCreate with peer pointer NULL"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8PeerCreate with peer pointer null");

	pVoice = NULL
	hr = DirectPlay8PeerCreate(NULL, &pVoice);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Didn't fail with expected error INVALIDPOINTER!");
		// TODO - Need to release the voice pointer
	}
	else
		xLog(hLog, XLL_PASS, "Returned INVALIDPOINTER successfully");

	xEndVariation(hLog);

#endif // BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "DirectPlay8PeerCreate with both pointers valid");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8PeerCreate with peer pointer null");

	pPeer = pVoice = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Failed with %u", hr);
	else
	{
		xLog(hLog, XLL_PASS, "Returned S_OK successfully");
		((PDIRECTPLAY8PEER) pPeer)->Release();
	}

	xEndVariation(hLog);
		
	return TRUE;
}

//==================================================================================
// PeerParamsInitTests
//----------------------------------------------------------------------------------
//
// Description: Function that executes the test case(s):
//				2.1.1.2 - Peer Initialize parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsInitTests(HANDLE hLog)
{
	PDIRECTPLAY8PEER pPeer;
	HRESULT	hr;
	LPVOID pVoice;
	BOOL fSuccess = TRUE;
	
	// Creating DirectPlay8Peer object
	pPeer = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8PeerCreate returned S_OK successfully");

#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with NULL context, handler, 0 flags using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with NULL context, handler, 0 flags using C++ macro");

	hr = IDirectPlay8Peer_Initialize(pPeer, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Initialize didn't fail with expected error INVALIDPOINTER!");

		// This peer interface is tainted now, release it and get a new one before moving on to the next test
		pPeer ? pPeer->Release() : 0;
		pPeer = NULL;

		// TODO - release the voice pointer

		if((hr = DirectPlay8PeerCreate(&pPeer, &pVoice)) != S_OK)
		{
			xEndVariation(hLog);
			
			xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
			fSuccess = FALSE;
			goto Exit;
		}
	}
	else
		xLog(hLog, XLL_PASS, "Initialize returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with NULL context, handler, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with NULL context, handler, 0 flags");
	
	hr = pPeer->Initialize(NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Initialize didn't fail with expected error INVALIDPOINTER!");

		// This peer interface is tainted now, release it and get a new one before moving on to the next test
		pPeer ? pPeer->Release() : 0;
		pPeer = NULL;

		// TODO - release the voice pointer

		if((hr = DirectPlay8PeerCreate(&pPeer, &pVoice)) != S_OK)
		{
			xEndVariation(hLog);

			xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
			fSuccess = FALSE;
			goto Exit;
		}
	}
	else
		xLog(hLog, XLL_PASS, "Initialize returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);

#endif // BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with NULL context, invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with NULL context, invalid flags");
	
	hr = pPeer->Initialize(NULL, PeerNoMessagesHandler, 0x666);
	if (hr != DPNERR_INVALIDFLAGS)
	{
		xLog(hLog, XLL_FAIL, "Initialize didn't fail with expected error INVALIDPOINTER!");

		// This peer interface is tainted now, release it and get a new one before moving on to the next test
		pPeer ? pPeer->Release() : 0;
		pPeer = NULL;

		// TODO - release the voice pointer

		if((hr = DirectPlay8PeerCreate(&pPeer, &pVoice)) != S_OK)
		{
			xEndVariation(hLog);

			xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
			fSuccess = FALSE;
			goto Exit;
		}
	}
	else
		xLog(hLog, XLL_PASS, "Initialize returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with 0 flags using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with 0 flags using C++ macro");

	hr = IDirectPlay8Peer_Initialize(pPeer, NULL, PeerNoMessagesHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing object using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Close using C++ macro");
	
	hr = IDirectPlay8Peer_Close(pPeer, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with 0 flags");
	
	hr = pPeer->Initialize(NULL, PeerNoMessagesHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with 0 flags again"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with 0 flags again");
	
	hr = pPeer->Initialize(NULL, PeerNoMessagesHandler, 0);
	if (hr != DPNERR_ALREADYINITIALIZED)
		xLog(hLog, XLL_FAIL, "Initialize didn't fail with expected error ALREADYINITIALIZED!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned ALREADYINITIALIZED successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Close after initializing");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Re-initializing with 0 flags after init and close"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Initialize with 0 flags after init and close");
	
	hr = pPeer->Initialize(NULL, PeerNoMessagesHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");	
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Close after third initialization");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Releasing DirectPlay8Peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Release after three init and closes");
	
	hr = pPeer->Release();
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Release didn't succeed with expected return S_OK!");
	else
		xLog(hLog, XLL_PASS, "Release returned S_OK successfully");
	pPeer = NULL;

	xEndVariation(hLog);	
	
Exit:

	// Release the peer interface if we haven't already
	if(pPeer)
	{
		pPeer->Release();
		pPeer = NULL;
	}

	// TODO - Need to release the voice interface as well

	return fSuccess;
}

//==================================================================================
// PeerParamsEnumSPTests
//----------------------------------------------------------------------------------
//
// Description: Callback that executes the test case(s):
//				2.1.1.3 - Peer EnumServiceProviders parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsEnumSPTests(HANDLE hLog)
{
	PDPN_SERVICE_PROVIDER_INFO	pSPInfo;
	PDIRECTPLAY8PEER pPeer;
	HRESULT	hr;
	LPVOID pVoice;
	DWORD dwNumSPs, dwSPBufferSize, dwExpectedNumSPs, dwExpectedSPBufferSize;
	BOOL fSuccess = TRUE;
	
	// Creating DirectPlay8Peer object
	pPeer = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8PeerCreate returned S_OK successfully");
	
	
#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with all NULLs and 0 flags using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with all NULLs and 0 flags using C++ macro");

	hr = IDirectPlay8Peer_EnumServiceProviders(pPeer, NULL, NULL, NULL, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPOINTER!");
	else
		xLog(hLog, XLL_PASS, "EnumSP returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with all NULLs and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with all NULLs and 0 flags");
	
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPOINTER!");
	else
		xLog(hLog, XLL_PASS, "EnumSP returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, NULL size, and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, NULL size, and 0 flags");
	
	dwNumSPs = 0;
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, NULL, &dwNumSPs, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPOINTER!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned INVALIDPOINTER successfully");

		if (dwNumSPs != 0)
			xLog(hLog, XLL_FAIL, "Number of SPs modified (%u != 0)!", dwNumSPs);
		else
			xLog(hLog, XLL_PASS, "Number of SPs wasn't modified");
	}
		
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, NULL count, and 0 flags");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, NULL count, and 0 flags");
	
	dwSPBufferSize = 0;
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, NULL, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPOINTER!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned INVALIDPOINTER successfully");

		if (dwSPBufferSize != 0)
			xLog(hLog, XLL_FAIL, "Buffer size modified (%u != 0)!", dwNumSPs);
		else
			xLog(hLog, XLL_PASS, "Buffer size wasn't modified");
	}
		
	xEndVariation(hLog);	
	
#endif // BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, and invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, and invalid flags");
	
	dwSPBufferSize = 0;
	dwNumSPs = 0;
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, &dwNumSPs, 0x666);
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDFLAGS!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned INVALIDFLAGS successfully");

		if (dwSPBufferSize != 0)
			xLog(hLog, XLL_FAIL, "Buffer size modified (%u != 0)!", dwSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size wasn't modified");
			if(dwNumSPs != 0)
				xLog(hLog, XLL_FAIL, "Number of SPs modified (%u != 0)!", dwNumSPs);
			else
				xLog(hLog, XLL_PASS, "Number of SPs wasn't modified");
		}
	}
		
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Initializing with NULL context, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP-Initialize with NULL context, 0 flags");
	
	hr = pPeer->Initialize(NULL, PeerNoMessagesHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");	

	xEndVariation(hLog);	

#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero size, and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, non-zero size, and 0 flags");
	
	dwSPBufferSize = 12345;
	dwNumSPs = 0;
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPOINTER!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned INVALIDPOINTER successfully");

		if (dwSPBufferSize != 12345)
			xLog(hLog, XLL_FAIL, "Buffer size modified (%u != 12345)!", dwSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size wasn't modified");
			if(dwNumSPs != 0)
				xLog(hLog, XLL_FAIL, "Number of SPs modified (%u != 0)!", dwNumSPs);
			else
				xLog(hLog, XLL_PASS, "Number of SPs wasn't modified");
		}
	}

	xEndVariation(hLog);	
	
#endif // BAD_PARAM_TESTS
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, and 0 flags");
	
	dwSPBufferSize = 0;
	// We expect to see at least the IP Service Provider.  We could technically
	// make sure there's room for the string, too, but that would have to be
	// localized.
	dwExpectedSPBufferSize = sizeof (DPN_SERVICE_PROVIDER_INFO);
	dwNumSPs = 0;
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPNERR_BUFFERTOOSMALL)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error BUFFERTOOSMALL!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned BUFFERTOOSMALL successfully");

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
			xLog(hLog, XLL_FAIL, "Buffer size smaller than expected (%u <= %u)!", dwSPBufferSize, dwExpectedSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size wasn't smaller than expected");
			if(dwNumSPs < 1)
				xLog(hLog, XLL_FAIL, "Number of SPs not expected (%u < 1)!", dwNumSPs);
			else
				xLog(hLog, XLL_PASS, "Number of SPs matches expected amount");
		}
	}
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, NULL buffer, non-zero count, and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, non-zero count, and 0 flags");
	
	dwSPBufferSize = 0;
	// We expect to see at least the IP Service Provider.  We could technically
	// make sure there's room for the string, too, but that would have to be
	// localized.
	dwExpectedSPBufferSize = sizeof (DPN_SERVICE_PROVIDER_INFO);
	dwNumSPs = 12345;
	
	hr = pPeer->EnumServiceProviders(NULL, NULL, NULL, &dwSPBufferSize,
		&dwNumSPs, 0);
	if (hr != DPNERR_BUFFERTOOSMALL)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error BUFFERTOOSMALL!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned BUFFERTOOSMALL successfully");

		if (dwSPBufferSize <= dwExpectedSPBufferSize)
			xLog(hLog, XLL_FAIL, "Buffer size smaller than expected (%u <= %u)!", dwSPBufferSize, dwExpectedSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size wasn't smaller than expected");
			if(dwNumSPs < 1)
				xLog(hLog, XLL_FAIL, "Number of SPs not expected (%u < 1)!", dwNumSPs);
			else
				xLog(hLog, XLL_PASS, "Number of SPs matches expected amount");
		}
	}
		
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating service providers with NULL GUIDs, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with NULL GUIDs, NULL buffer, non-zero count, and 0 flags");

	pSPInfo = NULL;
	pSPInfo = (PDPN_SERVICE_PROVIDER_INFO) LocalAlloc(LPTR, dwSPBufferSize + 64);
	if(!pSPInfo)
	{
		xLog(hLog, XLL_FAIL, "Couldn't allocate service provider buffer");
		fSuccess = FALSE;
		goto Exit;
	}
	memset(pSPInfo, 0xBA, dwSPBufferSize + 64);
	
	// Expect to get the same values again
	dwExpectedSPBufferSize = dwSPBufferSize;
	dwExpectedNumSPs = dwNumSPs;
	dwNumSPs = 0;
	
	hr = pPeer->EnumServiceProviders(NULL, NULL, pSPInfo, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "EnumSP didn't succeed with expected return DPN_OK!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned DPN_OK successfully");

		if (dwSPBufferSize != dwExpectedSPBufferSize)
			xLog(hLog, XLL_FAIL, "Buffer size not expected (%u != %u)!", dwSPBufferSize, dwExpectedSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size matches expected amount");
			if(dwNumSPs != dwExpectedNumSPs)
				xLog(hLog, XLL_FAIL, "Number of SPs not expected (%u != %u)!", dwNumSPs, dwExpectedNumSPs);
			else
			{
				xLog(hLog, XLL_INFO, "Number of SPs matches expected amount");
				if (*((PBYTE) pSPInfo) + dwSPBufferSize) != 0xBA)
					xLog(hLog, XLL_FAIL, "EnumSP wrote beyond end of buffer");
				else
					xLog(hLog, XLL_PASS, "EnumSP didn't write beyond end of buffer");
			}
		}
	}

	// TODO - Verify TCP/IP is in results
	
	LocalFree(pSPInfo);
	pSPInfo = NULL;
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating invalid SP GUID devices");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP with invalid SP GUID device");
	
	dwSPBufferSize = 0;
	dwNumSPs = 0;
	
	hr = pPeer->EnumServiceProviders(&DPTEST_GUID_UNKNOWN, NULL, NULL, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPNERR_DOESNOTEXIST)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error DOESNOTEXIST!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned DOESNOTEXIST successfully");

		if (dwSPBufferSize != 0)
			xLog(hLog, XLL_FAIL, "Buffer size not expected (%u != 0)!", dwSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size matches expected amount");
			if(dwNumSPs != 0)
				xLog(hLog, XLL_FAIL, "Number of SPs not expected (%u != 0)!", dwNumSPs);
			else
				xLog(hLog, XLL_PASS, "Number of SPs matches expected amount");
		}
	}
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating TCP/IP devices with invalid app GUID");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP TCP/IP devices with invalid app GUID");
	
	dwSPBufferSize = 0;
	dwNumSPs = 0;
	
	hr = pPeer->EnumServiceProviders(&CLSID_DP8SP_TCPIP, &DPTEST_GUID_UNKNOWN,	NULL, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error INVALIDPARAM!");
	else
		xLog(hLog, XLL_PASS, "EnumSP returned INVALIDPARAM successfully");

	// TODO - What do we really expect here?

	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP TCP/IP devices with NULL GUIDs, NULL buffer, and 0 flags");
	
	dwSPBufferSize = 0;
	dwNumSPs = 0;
	
	hr = pPeer->EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, NULL, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPNERR_BUFFERTOOSMALL)
		xLog(hLog, XLL_FAIL, "EnumSP didn't fail with expected error BUFFERTOOSMALL!");
	else
		xLog(hLog, XLL_PASS, "EnumSP returned BUFFERTOOSMALL successfully");
	
	// TODO - What size do we expect?

	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Enumerating TCP/IP devices with NULL GUIDs, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: EnumSP TCP/IP devices with NULL GUIDs, 0 flags");

	pSPInfo = NULL;
	pSPInfo = (PDPN_SERVICE_PROVIDER_INFO) LocalAlloc(LPTR, dwSPBufferSize + 64);
	if(!pSPInfo)
	{
		xLog(hLog, XLL_FAIL, "Couldn't allocate service provider buffer");
		fSuccess = FALSE;
		goto Exit;
	}
	memset(pSPInfo, 0xBA, dwSPBufferSize + 64);
	
	// Expect to get the same values again
	dwExpectedSPBufferSize = dwSPBufferSize;
	dwExpectedNumSPs = dwNumSPs;
	dwNumSPs = 0;

	hr = pPeer->EnumServiceProviders(&CLSID_DP8SP_TCPIP, NULL, pSPInfo, &dwSPBufferSize, &dwNumSPs, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "EnumSP didn't succeed with expected return DPN_OK!");
	else
	{
		xLog(hLog, XLL_INFO, "EnumSP returned DPN_OK successfully");

		if (dwSPBufferSize != dwExpectedSPBufferSize)
			xLog(hLog, XLL_FAIL, "Buffer size not expected (%u != %u)!", dwSPBufferSize, dwExpectedSPBufferSize);
		else
		{
			xLog(hLog, XLL_INFO, "Buffer size matches expected amount");
			if(dwNumSPs != dwExpectedNumSPs)
				xLog(hLog, XLL_FAIL, "Number of SPs not expected (%u != %u)!", dwNumSPs, dwExpectedNumSPs);
			else
			{
				xLog(hLog, XLL_INFO, "Number of SPs matches expected amount");
				if (*((PBYTE) pSPInfo) + dwSPBufferSize) != 0xBA)
					xLog(hLog, XLL_FAIL, "EnumSP wrote beyond end of buffer");
				else
					xLog(hLog, XLL_PASS, "EnumSP didn't write beyond end of buffer");
			}
		}
	}

	// TODO - Verify TCP/IP is in results
	
	LocalFree(pSPInfo);
	pSPInfo = NULL;
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Close after EnumSP tests");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Releasing DirectPlay8Peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Release after EnumSP tests");
	
	hr = pPeer->Release();
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Release didn't succeed with expected return S_OK!");
	else
		xLog(hLog, XLL_PASS, "Release returned S_OK successfully");
	pPeer = NULL;

	xEndVariation(hLog);	
	
Exit:

	// Release the peer interface if we haven't already
	if(pPeer)
	{
		pPeer->Release();
		pPeer = NULL;
	}

	// TODO - Need to release the voice interface as well

	return fSuccess;
}

//==================================================================================
// PeerParamsCancelTests
//----------------------------------------------------------------------------------
//
// Description: Function that executes the test case(s):
//				2.1.1.4 - Peer CancelAsyncOperation parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsCancelTests(HANDLE hLog)
{
	PDPN_SERVICE_PROVIDER_INFO	pSPInfo;
	DPN_APPLICATION_DESC dpAppDesc;
	PDIRECTPLAY8ADDRESS	pDP8AddressHost;
	PDIRECTPLAY8ADDRESS	pDP8AddressDevice;
	PEERCANCELCONTEXT context;
	PDIRECTPLAY8PEER pPeer;
	HRESULT	hr;
	HOSTENT *pHostent;
	LPVOID pVoice;
	WCHAR szLocalIPAddress[16];
	CHAR szLocalMacAddress[16];
	BOOL fSuccess = TRUE;

	ZeroMemory(&context, sizeof (PEERCANCELCONTEXT));
	
	// Creating DirectPlay8Peer object
	pPeer = pVoice = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8PeerCreate returned S_OK successfully");	
	
	// Creating DirectPlay8Address object
	hr = DirectPlay8AddressCreate(&pDP8AddressHost);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8AddressCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8AddressCreate returned S_OK successfully");		
	
	// Setting host DirectPlay8Address SP to TCP/IP
	hr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "SetSP failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "SetSP returned DPN_OK successfully");	
	
	// Duplicating host DirectPlay8Address for a device address
	hr = pDP8AddressHost->Duplicate(&pDP8AddressDevice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Duplicate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "Duplicate returned S_OK successfully");	
	
	// In order to run these tests, need to get the local address information
	// Start by getting the Mac address
	if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
	{
		xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
		fSuccess = FALSE;
		goto Exit;
	}

	// Then get the IP address
	pHostent = NULL;
	if((pHostent = gethostbyname(szLocalMacAddress)) == NULL)
	{
		xLog(hLog, XLL_FAIL, "Couldn't retrieve IP information for local host");
		fSuccess = FALSE;
		goto Exit;
	}

	// Extract the IP address from the hostent stucture
	mbstowcs(szLocalIPAddress, pHostent->h_addr, strlen(pHostent->h_addr));
	szLocalIPAddress[strlen(pHostent->h_addr)] = 0;

	// Setting remote address hostname to local machine
	hr = pDP8AddressHost->AddComponent(DPNA_KEY_HOSTNAME, szLocalIPAddress, (wcslen(szLocalIPAddress) + 1), DPNA_DATATYPE_STRING);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Couldn't set remote address hostname to local machine!", hr);
		fSuccess = FALSE;
		goto Exit;
	}

	// Finally, we're ready to run the tests.
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling async operation with NULL and 0 flags using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync with NULL and 0 flags using C++ macro");

	hr = IDirectPlay8Peer_CancelAsyncOperation(pPeer, NULL, 0);
	if (hr != DPNERR_INVALIDHANDLE)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDHANDLE!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDHANDLE successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling async operation with NULL and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync with NULL and 0 flags using C++ macro");
	
	hr = pPeer->CancelAsyncOperation(NULL, 0);
	if (hr != DPNERR_INVALIDHANDLE)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDHANDLE!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDHANDLE successfully");
	
	xEndVariation(hLog);

	// Next tests require peer object to be initialized
	// Initializing with context, 0 flags
	
	context.hLog = hLog;

	hr = pPeer->Initialize(&context, PeerCancelHandler, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "Initializing with context, 0 flags failed!");
		fSuccess = FALSE;
		goto Exit;
	}
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Starting async connect to self which would eventually complete with failure"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync starting first failing async connect to self");
	
	if(!(context.hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
	{
		xEndVariation(hLog);

		xLog(hLog, XLL_FAIL, "Couldn't create event for cancel context", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CANCEL;
	
	context.dpnhExpectedAsyncOp = (DPNHANDLE) 0x666;
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, pDP8AddressDevice, NULL, NULL, NULL, 0,NULL,
		context.hConnectCompleteEvent, &(context.dpnhExpectedAsyncOp), 0);
	if (hr != (HRESULT) DPNSUCCESS_PENDING)
		xLog(hLog, XLL_FAIL, "Couldn't start async connect to self which would eventually complete with failure!");
	else
	{
		xLog(hLog, XLL_INFO, "Started async connect to self which would eventually complete with failure.");
		if (context.dpnhExpectedAsyncOp == (DPNHANDLE) 0x666)
			xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
		else
		{
			xLog(hLog, XLL_INFO, "Async operation handle was modified");
			if (context.dpnhExpectedAsyncOp == NULL)
				xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle appears to have been set correctly");
		}
	}
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling invalid handle with 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync invalid handle with 0 flags");
	
	hr = pPeer->CancelAsyncOperation(0xABABABAB, 0);
	if (hr != DPNERR_INVALIDHANDLE)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDHANDLE!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDHANDLE successfully");

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling null connect handle with invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync null connect handle with invalid flags");
	
	hr = pPeer->CancelAsyncOperation(NULL, 0x666);
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDFLAGS!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDFLAGS successfully");

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling valid connect handle with CONNECT flag"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync valid connect handle with CONNECT flags");
	
	hr = pPeer->CancelAsyncOperation(context.dpnhExpectedAsyncOp, DPNCANCEL_CONNECT);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDPARAM!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDPARAM successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling valid connect handle with ALL_OPERATIONS flag"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync valid connect handle with ALL_OPERATIONS flags");
	
	hr = pPeer->CancelAsyncOperation(context.dpnhExpectedAsyncOp, DPNCANCEL_ALL_OPERATIONS);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't fail with expected error INVALIDPARAM!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned INVALIDPARAM successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling valid connect handle" 
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync valid connect handle");
	
	// Allow the connect to complete.
	context.hrExpectedResult = DPNERR_USERCANCEL;
	context.fConnectCanComplete = TRUE;
	
	hr = pPeer->CancelAsyncOperation(context.dpnhExpectedAsyncOp, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Waiting for cancelled connect to complete"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync wait for first connection to complete");
	
	if(WaitForSingleObject(&context.hConnectCompleteEvent, 60000) != WAIT_OBJECT_0)
		xLog(hLog, XLL_FAIL, "Cancelled connection didn't complete within 60 seconds!");
	else
	{
		xLog(hLog, XLL_INFO, "Cancelled connection callback signalled");

		if (! context.fCompleted)
			xLog(hLog, XLL_FAIL, "Cancelling connect didn't cause it to complete!");
		else
			xLog(hLog, XLL_PASS, "Cancelled connect reported completion!");
	}

	// Prevent any wierd connects from completing.
	context.fConnectCanComplete = FALSE;
	
	// Reset the context.
	context.dpnhExpectedAsyncOp = (DPNHANDLE) 0x666;
	context.fCompleted = FALSE;

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Starting async connect to self which would eventually complete with failure"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync starting second failing async connect to self");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CANCEL;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, pDP8AddressDevice, NULL, NULL, NULL, 0, NULL, 
		context.hConnectCompleteEvent, &(context.dpnhExpectedAsyncOp), 0);
	if (hr != (HRESULT) DPNSUCCESS_PENDING)
		xLog(hLog, XLL_FAIL, "Couldn't start async connect to self which would eventually complete with failure!");
	else
	{
		xLog(hLog, XLL_INFO, "Started async connect to self which would eventually complete with failure.");
		if (context.dpnhExpectedAsyncOp == (DPNHANDLE) 0x666)
			xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
		else
		{
			xLog(hLog, XLL_INFO, "Async operation handle was modified");
			if (context.dpnhExpectedAsyncOp == NULL)
				xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle appears to have been set correctly");
		}
	}
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling ENUMs"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync ENUMs");
	
	hr = pPeer->CancelAsyncOperation(NULL, DPNCANCEL_ENUM);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't succeed with expected return DPN_OK");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned DPN_OK successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Cancelling CONNECTs"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync CONNECTs");
	
	// Allow the connect to complete.
	context.hrExpectedResult = DPNERR_USERCANCEL;
	context.fConnectCanComplete = TRUE;
	
	hr = pPeer->CancelAsyncOperation(NULL, DPNCANCEL_CONNECT);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't succeed with expected return DPN_OK");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned DPN_OK successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Waiting for cancelled connect to complete"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync wait for first connection to complete");
	
	if(WaitForSingleObject(&context.hConnectCompleteEvent, 60000) != WAIT_OBJECT_0)
		xLog(hLog, XLL_FAIL, "Cancelled connection didn't complete within 60 seconds!");
	else
	{
		xLog(hLog, XLL_INFO, "Cancelled connection callback signalled");

		if (! context.fCompleted)
			xLog(hLog, XLL_FAIL, "Cancelling connect didn't cause it to complete!");
		else
			xLog(hLog, XLL_PASS, "Cancelled connect reported completion!");
	}

	// Prevent any wierd connects from completing.
	context.fConnectCanComplete = FALSE;
	
	// Reset the context.
	context.dpnhExpectedAsyncOp = (DPNHANDLE) 0x666;
	context.fCompleted = FALSE;
	
	// Reset the context.
	CloseHandle(context.hConnectCompleteEvent);
	context.hConnectCompleteEvent = NULL;

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: CancelAsync close after CancelAsync tests");

	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "CancelAsync didn't succeed with expected return DPN_OK");
	else
		xLog(hLog, XLL_PASS, "CancelAsync returned DPN_OK successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Releasing DirectPlay8Peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Release after EnumSP tests");
	
	hr = pPeer->Release();
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Release didn't succeed with expected return S_OK!");
	else
		xLog(hLog, XLL_PASS, "Release returned S_OK successfully");
	pPeer = NULL;

	xEndVariation(hLog);	

Exit:

	// Release the peer interface if we haven't already
	if(pPeer)
	{
		pPeer->Release();
		pPeer = NULL;
	}

	// TODO - Need to release the voice interface as well

	return fSuccess;
}

//==================================================================================
// PeerParamsConnectTests
//----------------------------------------------------------------------------------
//
// Description: Function that executes the test case(s):
//				2.1.1.5 - Peer Connect parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsConnectTests(HANDLE hLog)
{
	DPN_APPLICATION_DESC dpAppDesc, dpAppDescCompare;
	PDIRECTPLAY8ADDRESS	pDP8AddressHost, pDP8AddressDevice;
	PEERCONNECTCONTEXT context;
	PDIRECTPLAY8PEER pPeer, pPeerHost;
	DPNHANDLE dpnhConnect = 0x666, dpnhDuplicate = 0x666;
	HOSTENT *pHostent;
	HRESULT	hr;
	LPVOID pVoice;
	WCHAR szLocalIPAddress[16];
	CHAR szLocalMacAddress[16];
	BOOL fSuccess = TRUE;

	ZeroMemory(&context, sizeof (PEERCONNECTCONTEXT));
	
	// Creating DirectPlay8Peer object
	pPeer = pVoice = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8PeerCreate returned S_OK successfully");	
	
	// Creating DirectPlay8Address object for host
	hr = DirectPlay8AddressCreate(&pDP8AddressHost);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8AddressCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8AddressCreate (pDP8AddressHost) returned S_OK successfully");		
	

	// Creating DirectPlay8Address object for device
	hr = DirectPlay8AddressCreate(&pDP8AddressDevice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8AddressCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8AddressCreate (pDP8AddressDevice) returned S_OK successfully");		

	// Finally, we're ready to run the tests.

#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with all NULLs and 0 flags using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with all NULLs and 0 flags using C++ macro");
	
	hr = IDirectPlay8Peer_Connect(pPeer, NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPOINTER!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
		xLog(hLog, XLL_PASS, "Connect returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with all NULLs and 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with all NULLs and 0 flags");
	
	hr = pPeer->Connect(NULL, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPOINTER!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
		xLog(hLog, XLL_PASS, "Connect returned INVALIDPOINTER successfully");
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with NULL app desc"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with NULL app desc");
	
	hr = pPeer->Connect(NULL, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPOINTER!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPOINTER successfully");
		if (dpnhConnect != (DPNHANDLE) 0x666)
			xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
		else
			xLog(hLog, XLL_PASS, "Async operation handle wasn't modified.");
	}
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with app desc of 0 size"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with app desc of 0 size");
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;

	// Save what we're passing in to make sure it's not touched.
	CopyMemory(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPARAM!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPARAM successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with app desc of too-large size"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with app desc of too-large size");
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC) + 1;
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;

	dpnhConnect = 0x666;
	
	// Save what we're passing in to make sure it's not touched.
	CopyMemory(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPARAM!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPARAM successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with app desc using invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with app desc using invalid flags");
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.dwFlags = 0x666;
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	// Save what we're passing in to make sure it's not touched.
	CopyMemory(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPARAM!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPARAM successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);
		  
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with NULL host address"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with NULL host address");
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;

	// Save what we're passing in to make sure it's not touched.
	CopyMemory(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	
	hr = pPeer->Connect(&dpAppDesc, NULL, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDHOSTADDRESS)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDHOSTADDRESS!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDHOSTADDRESS successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with empty host address, NULL device address"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with empty host address, NULL device address");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;

	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDHOSTADDRESS)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDHOSTADDRESS!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDHOSTADDRESS successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);
	
#endif // BAD_PARAM_TESTS

	// Next tests require address object to be set for TCP/IP
	// Setting host DirectPlay8Address SP to TCP/IP
	hr = pDP8AddressHost->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "SetSP failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "SetSP returned DPN_OK successfully");	

#ifdef BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with non-NULL security desc");
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with non-NULL security desc");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, (PDPN_SECURITY_DESC) ((DWORD_PTR) 0xABABABAB),
		NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPOINTER!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPOINTER successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with non-NULL security credentials"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with non-NULL security credentials");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, (PDPN_SECURITY_CREDENTIALS) ((DWORD_PTR) 0xABABABAB),
		NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDPOINTER)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPOINTER!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPOINTER successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting asynchronously with NULL async op handle"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with NULL async op handle");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPARAM!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPARAM successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
			xLog(hLog, XLL_PASS, "Application desc structure wasn't modified.");
	}

	xEndVariation(hLog);	
	
#endif // BAD_PARAM_TESTS

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting synchronously with async op handle"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect synchronously with async op handle");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, DPNCONNECT_SYNC);
	if (hr != DPNERR_INVALIDPARAM)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDPARAM!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDPARAM successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with invalid flags");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;

	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0x666);
	if (hr != DPNERR_INVALIDFLAGS)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDFLAGS!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDFLAGS successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting without being initialized"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect without being initialized");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_UNINITIALIZED)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error UNINITIALIZED!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned UNINITIALIZED successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}
	
	xEndVariation(hLog);

	// Next tests require peer object to be initialized
	// Initializing with context, 0 flags
	
	context.hLog = hLog;

	hr = pPeer->Initialize(&context, PeerConnectHandler, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "Initializing with context, 0 flags failed!");
		fSuccess = FALSE;
		goto Exit;
	}
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting with SP-only host address, empty device address"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect with SP-only host address, empty device address");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, pDP8AddressDevice, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_INVALIDDEVICEADDRESS)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error INVALIDDEVICEADDRESS!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();

	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned INVALIDDEVICEADDRESS successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}
	
	xEndVariation(hLog);	

	// In order to run these tests, need to get the local address information
	// Start by getting the Mac address
	if(gethostname(szLocalMacAddress, sizeof(szLocalMacAddress)))
	{
		xLog(hLog, XLL_FAIL, "Couldn't retrieve local Mac address");
		fSuccess = FALSE;
		goto Exit;
	}

	// Then get the IP address
	pHostent = NULL;
	if((pHostent = gethostbyname(szLocalMacAddress)) == NULL)
	{
		xLog(hLog, XLL_FAIL, "Couldn't retrieve IP information for local host");
		fSuccess = FALSE;
		goto Exit;
	}

	// Extract the IP address from the hostent stucture
	mbstowcs(szLocalIPAddress, pHostent->h_addr, strlen(pHostent->h_addr));
	szLocalIPAddress[strlen(pHostent->h_addr)] = 0;

	// Setting remote address hostname to local machine
	hr = pDP8AddressHost->AddComponent(DPNA_KEY_HOSTNAME, szLocalIPAddress, (wcslen(szLocalIPAddress) + 1), DPNA_DATATYPE_STRING);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Couldn't set remote address hostname to local machine!", hr);
		fSuccess = FALSE;
		goto Exit;
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Starting async connect to self which would eventually complete with failure"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect failing async to self");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != (HRESULT) DPNSUCCESS_PENDING)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't succeed with expected return DPNSUCCESS_PENDING!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned DPNSUCCESS_PENDING successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect == (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle wasn't modified!");
			else
			{
				xLog(hLog, XLL_INFO, "Async operation handle was modified");
				if (dpnhConnect == NULL)
					xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
				else
					xLog(hLog, XLL_PASS, "Async operation handle appears to have been set correctly");
			}
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Trying another async connect with one still pending"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect already pending");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhDuplicate = 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhDuplicate, 0);
	if (hr != DPNERR_CONNECTING)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error CONNECTING!");

		// This peer interface is tainted now, release it and get a new one before moving on to the next test
		pPeer ? pPeer->Release() : 0;
		pPeer = NULL;

		// TODO - release the voice pointer

		xEndVariation(hLog);

		// We're pretty much screwed at this point.  Original connect call might have been mucked up by the
		// second connect call that returned success when it shouldn't have.
		fSuccess = FALSE;
		goto Exit;
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned CONNECTING successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhDuplicate != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	// This part is based on the assumption that we'll be able to run the previous test (Connect already pending)
	// before the earlier test (Connect failing async to self) completes asynchronously

	if(!(context.hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
	{
		xEndVariation(hLog);

		xLog(hLog, XLL_FAIL, "Couldn't create event for cancel context", hr);
		fSuccess = FALSE;
		goto Exit;
	}

	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Waiting for async connect to fail (this may take some time)"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect wait for async connect to fail");

	context.hrExpectedResult = DPNERR_NORESPONSE;
	context.fConnectCanComplete = TRUE;
	
	if(WaitForSingleObject(&context.hConnectCompleteEvent, 60000) != WAIT_OBJECT_0)
		xLog(hLog, XLL_FAIL, "Connection didn't complete within 60 seconds!");
	else
	{
		xLog(hLog, XLL_INFO, "Connection callback signalled");
		if (! context.fCompleted)
			xLog(hLog, XLL_FAIL, "Didn't receive a connection completion indication!");
		else
		{
			xLog(hLog, XLL_INFO, "Received a connection completion indication.");
			if (context.dpnhCompletedAsyncOp != dpnhConnect)
				xLog(hLog, XLL_FAIL, "Connection completed with different async op handle (%x != %x)",
				context.dpnhCompletedAsyncOp, dpnhConnect);
			else
				xLog(hLog, XLL_PASS, "Connection completed with correct async op handle");
		}
	}

	// Prevent any wierd connects from completing.
	context.fConnectCanComplete = FALSE;

	// Reset connection context
	CloseHandle(context.hConnectCompleteEvent);
	context.hConnectCompleteEvent = NULL;
	context.fCompleted = FALSE;

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Synchronously connecting to self without a host (this may take some time)"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect to self synchornously without a host");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	// Even though it's synchronous, we'll still get a completion.  The async op
	// handle will be NULL, though.
	context.hrExpectedResult = DPNERR_NORESPONSE;
	context.fConnectCanComplete = TRUE;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, DPNCONNECT_SYNC);
	
	// Prevent connects from completing.
	context.fConnectCanComplete = FALSE;
	
	if (hr != DPNERR_NORESPONSE)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error NORESPONSE!");
		
		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned NORESPONSE successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (! context.fCompleted)
				xLog(hLog, XLL_FAIL, "Didn't receive a connection completion indication!");
			else
			{
				xLog(hLog, XLL_INFO, "Cancelled connect reported completion!");
				if (context.dpnhCompletedAsyncOp != NULL)
					xLog(hLog, XLL_FAIL, "Connection completed with an async op handle (%x)", context.dpnhCompletedAsyncOp);
				else
					xLog(hLog, XLL_PASS, "Connection completed without correct async op handle");
			}
		}
	}
	
	xEndVariation(hLog);	

	// Reset the context.
	context.fCompleted = FALSE;

	// Setting host DirectPlay8Address SP to TCP/IP
	hr = pDP8AddressDevice->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "SetSP failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Hosting session"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect hosting session");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	hr = pPeer->Host(&dpAppDesc, &pDP8AddressDevice, 1, NULL, NULL, NULL, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "Host didn't succeed with expected return DPN_OK!");
		// This peer interface is tainted now, release it and get a new one before moving on to the next test
		pPeer ? pPeer->Release() : 0;
		pPeer = NULL;

		// TODO - release the voice pointer

		xEndVariation(hLog);

		// We're pretty much screwed at this point.  Since host doesn't seem to be working, our remaining tests
		// won't be valid.
		fSuccess = FALSE;
		goto Exit;
	}
	else
	{
		xLog(hLog, XLL_INFO, "Host returned DPN_OK successfully");
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
			xLog(hLog, XLL_PASS, "Application desc structure wasn't modified.");
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting when already hosting"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect when already hosting");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = (DPNHANDLE) 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_ALREADYCONNECTED)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error ALREADYCONNECTED!");
		
		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned ALREADYCONNECTED successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect closing after connection attempt");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Re-initializing peer object with context, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect re-init with context, 0 flags");
	
	context.hLog = hLog;

	hr = pPeer->Initialize(&context, PeerConnectHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");
	
	xEndVariation(hLog);	
	
	pDP8AddressHost->Release();
	pDP8AddressHost = NULL;

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Creating new peer host object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect create peer host object");

	hr = PeerCreateHost(hLog, PeerNewPlayerHandler, NULL, &dpAppDesc, &pDP8PeerHost, NULL, &pDP8AddressHost);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "PeerCreateHost didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "PeerCreateHost returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// Create an event to signal when the connection is complete
	if(!(context.hConnectCompleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL))
	{
		xLog(hLog, XLL_FAIL, "Couldn't create event for cancel context", hr);
		fSuccess = FALSE;
		goto Exit;
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Starting async connect to local peer"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect async to local peer");
	
	context.hrExpectedResult = DPN_OK;
	context.fConnectCanComplete = TRUE;
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = (DPNHANDLE) 0x666;

	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != (HRESULT) DPNSUCCESS_PENDING)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't succeed with expected return DPNSUCCESS_PENDING!");

		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned DPNSUCCESS_PENDING successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect == (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle wasn't modified!");
			else
			{
				xLog(hLog, XLL_INFO, "Async operation handle was modified");
				if (dpnhConnect == NULL)
					xLog(hLog, XLL_FAIL, "No async operation handle was returned!");
				else
					xLog(hLog, XLL_PASS, "Async operation handle appears to have been set correctly");
			}
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	//"Waiting for async connect to succeed"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect wait for local peer async connect to succeed");

	if(WaitForSingleObject(&context.hConnectCompleteEvent, 60000) != WAIT_OBJECT_0)
		xLog(hLog, XLL_FAIL, "Connection didn't complete within 60 seconds!");
	else
	{
		xLog(hLog, XLL_INFO, "Connection callback signalled");
		if (! context.fCompleted)
			xLog(hLog, XLL_FAIL, "Didn't receive a connection completion indication!");
		else
		{
			xLog(hLog, XLL_INFO, "Received a connection completion indication.");
			if (context.dpnhCompletedAsyncOp != dpnhConnect)
				xLog(hLog, XLL_FAIL, "Connection completed with different async op handle (%x != %x)",
				context.dpnhCompletedAsyncOp, dpnhConnect);
			else
				xLog(hLog, XLL_PASS, "Connection completed with correct async op handle");
		}
	}

	// Prevent any wierd connects from completing.
	context.fConnectCanComplete = FALSE;

	// Reset the context.
	CloseHandle(context.hConnectCompleteEvent);
	context.hConnectCompleteEvent = NULL;
	context.fCompleted = FALSE;

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting when already connected"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect when already successfully connected");
	
	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_CONNECT;
	
	dpnhConnect = (DPNHANDLE) 0x666;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, &dpnhConnect, 0);
	if (hr != DPNERR_ALREADYCONNECTED)
	{
		xLog(hLog, XLL_FAIL, "Connect didn't fail with expected error ALREADYCONNECTED!");
		
		// We'll try to continue later tests by closing any connection we somehow managed to create here.
		pPeer->Close();
	}
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned ALREADYCONNECTED successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (dpnhConnect != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified!");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect closing after successful connection attempt");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Re-initializing peer object with context, 0 flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect second re-init with context, 0 flags");
	
	context.hLog = hLog;

	hr = pPeer->Initialize(&context, PeerConnectHandler, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Initialize didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Initialize returned DPN_OK successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Connecting synchronously"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect synchronously to local peer host");
	
	// Even though it's synchronous, we'll still get a completion.  The async op
	// handle will be NULL, though.
	context.hrExpectedResult = DPN_OK;
	context.fConnectCanComplete = TRUE;
	
	hr = pPeer->Connect(&dpAppDesc, pDP8AddressHost, NULL, NULL, NULL, NULL, 0, NULL, NULL, NULL, DPNCONNECT_SYNC);

	// Prevent any weird connects from completing.
	context.fConnectCanComplete = FALSE;
	
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Connect didn't succeed with expected return DPN_OK!");
	else
	{
		xLog(hLog, XLL_INFO, "Connect returned DPN_OK successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Application desc structure wasn't modified.");
			if (! context.fCompleted)
				xLog(hLog, XLL_FAIL, "Didn't receive a connection completion indication!");
			else
			{
				xLog(hLog, XLL_INFO, "Received a connection completion indication.");
				if (context.dpnhCompletedAsyncOp != NULL)
					xLog(hLog, XLL_FAIL, "Connection completed with an async op handle (%x != %x)",
					context.dpnhCompletedAsyncOp, dpnhConnect);
				else
					xLog(hLog, XLL_PASS, "Connection completed without a async op handle");
			}
		}
	}
	
	// Reset the context.
	context.fCompleted = FALSE;
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect closing after successful synchronous connection attempt");
	
	hr = pPeer->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Closing host object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect closing host after multiple connection attempts");
	
	hr = pPeerHost->Close(0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Close didn't succeed with expected return DPN_OK!");
	else
		xLog(hLog, XLL_PASS, "Close returned DPN_OK successfully");
	
	xEndVariation(hLog);

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Releasing hosting DirectPlay8Peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect release host after connection tests");
	
	hr = pPeerHost->Release();
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Release didn't succeed with expected return S_OK!");
	else
		xLog(hLog, XLL_PASS, "Release returned S_OK successfully");
	pPeer = NULL;

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Releasing DirectPlay8Peer object"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: Connect release peer after connection tests");
	
	hr = pPeer->Release();
	if (hr != S_OK)
		xLog(hLog, XLL_FAIL, "Release didn't succeed with expected return S_OK!");
	else
		xLog(hLog, XLL_PASS, "Release returned S_OK successfully");
	pPeer = NULL;

	xEndVariation(hLog);	
	
Exit:

	// Release the peer interface if we haven't already
	if(pPeer)
	{
		pPeer->Release();
		pPeer = NULL;
	}

	// Release the peer interface if we haven't already
	if(pPeerHost)
	{
		pPeerHost->Release();
		pPeerHost = NULL;
	}

	// Release the peer interface if we haven't already
	if(pDP8AddressHost)
	{
		pDP8AddressHost->Release();
		pDP8AddressHost = NULL;
	}

	// Release the address if we haven't already
	if(pDP8AddressDevice)
	{
		pDP8AddressDevice->Release();
		pDP8AddressDevice = NULL;
	}

	// TODO - Need to release the voice interface as well

	return fSuccess;
}

//==================================================================================
// PeerParamsSendToTests
//----------------------------------------------------------------------------------
//
// Description: Function that executes the test case(s):
//				2.1.1.6 - Peer SendTo parameter validation
//
// Arguments:
//	HANDLE	hLog	Handle to the logging subsystem
//
// Returns: TRUE if the test completed, FALSE if some error condition prevents
//          the running of further tests
//==================================================================================
BOOL PeerParamsSendToTests(HANDLE hLog)
{
	DPN_APPLICATION_DESC dpAppDesc, dpAppDescCompare;
	PDIRECTPLAY8ADDRESS	pDP8Address;
	PEERSENDTOCONTEXT context;
	PDIRECTPLAY8PEER pPeer;
	DPN_BUFFER_DESC dpnbd, dpnbdCompare;
	DPNHANDLE dpnhSendTo = (DPNHANDLE) 0x666;
	HRESULT	hr;
	LPVOID pVoice;
	BOOL fSuccess = TRUE;
	
	ZeroMemory(&dpnbd, sizeof (DPN_BUFFER_DESC));
	ZeroMemory(&context, sizeof (PARMVPSENDTOCONTEXT));
	
	// Allocate a 1 meg buffer.
	dpnbd.pBufferData = (PBYTE) LocalAlloc(LPTR, 1 * 1024 * 1024);
	if(!dpnbd.pBufferData)
	{
		xLog(hLog, XLL_FAIL, "Couldn't allocate send-to buffer");
		fSuccess = FALSE;
		goto Exit;
	}
	
	// Initialize buffer size to 1 byte
	dpnbd.dwBufferSize = 1;
	
	// Creating DirectPlay8Peer object
	pPeer = pVoice = NULL;
	hr = DirectPlay8PeerCreate(&pPeer, &pVoice);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8PeerCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8PeerCreate returned S_OK successfully");	
	
	// Creating DirectPlay8Address object for host
	hr = DirectPlay8AddressCreate(&pDP8Address);
	if (hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "DirectPlay8AddressCreate failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "DirectPlay8AddressCreate (pDP8Address) returned S_OK successfully");		

	// Next tests require address object to be set for TCP/IP
	// Setting host DirectPlay8Address SP to TCP/IP
	hr = pDP8Address->SetSP(&CLSID_DP8SP_TCPIP);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "SetSP failed with %u", hr);
		fSuccess = FALSE;
		goto Exit;
	}
	else
		xLog(hLog, XLL_INFO, "SetSP returned DPN_OK successfully");	


#ifdef BAD_PARAM_TESTS
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	//"Sending to 0 with all NULLs and 0s using C++ macro"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo 0 with all NULLs and 0s using C++ macro");
	
	hr = IDirectPlay8Peer_SendTo(pPeer, 0, NULL, 0, 0, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPARAM!");
	else
		xLog(hLog, XLL_PASS, "SendTo returned INVALIDPARAM successfully");
	
	xEndVariation(hLog);	
	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	//"Sending to 0 with all NULLs and 0s"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo 0 with all NULLs and 0s");
	
	hr = pPeer->SendTo(0, NULL, 0, 0, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPARAM!");
	else
		xLog(hLog, XLL_PASS, "SendTo returned INVALIDPARAM successfully");
	
	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending asynchronously to AllPlayersGroup with NULL buffer desc"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with NULL buffer desc");
	
	dpnhSendTo = (DPNHANDLE) 0x666;

	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, NULL, 1, 0, NULL, &dpnhSendTo, 0);
	if (hr != DPNERR_INVALIDPOINTER)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPOINTER!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDPOINTER successfully");

		if (dpnhSendTo != (DPNHANDLE) 0x666)
			xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
		else
			xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
	}
	
	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending asynchronously to AllPlayersGroup with 0 buffer desc count"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with 0 buffer desc count");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;

	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 0, 0, NULL, &dpnhSendTo, 0);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPARAM!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDPARAM successfully");

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending asynchronously to AllPlayersGroup with NULL async handle"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with NULL async handle");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	
	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, NULL, 0);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPARAM!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDPARAM successfully");

		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
			xLog(hLog, XLL_PASS, "Buffer desc structure wasn't modified");
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending synchronously to AllPlayersGroup with async handle"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo synchronously to AllPlayersGroup with async handle");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;

	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_SYNC);
	if (hr != DPNERR_INVALIDPARAM)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDPARAM!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDPARAM successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	

#endif // BAD_PARAM_TESTS	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup with invalid flags"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with invalid flags");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;

	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, 0x666000);
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDFLAGS!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDFLAGS successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup with NOCOPY and NOCOMPLETE"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with NOCOPY and NOCOMPLETE");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;
	
	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, (DPNSEND_NOCOPY | DPNSEND_NOCOMPLETE));
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDFLAGS!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDFLAGS successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup with only COMPLETEONPROCESS"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with only COMPLETEONPROCESS");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;
		
	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_COMPLETEONPROCESS);
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDFLAGS!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDFLAGS successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup with PRIORITY_LOW and PRIORITY_HIGH"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with PRIORITY_LOW and PRIORITY_HIGH");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;
	
	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, (DPNSEND_PRIORITY_LOW | DPNSEND_PRIORITY_HIGH));
	if (hr != DPNERR_INVALIDFLAGS)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error INVALIDFLAGS!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned INVALIDFLAGS successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup with NOCOPY when uninitialized"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup with NOCOPY when uninitialized");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;
	
	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, DPNSEND_NOCOPY);
	if (hr != DPNERR_UNINITIALIZED)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error UNINITIALIZED!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned UNINITIALIZED successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	


	// Next tests require peer object to be initialized
	// Initializing with context, 0 flags

	context.hLog = hLog;

	hr = pPeer->Initialize(&context, PeerSendToHandler, 0);
	if (hr != DPN_OK)
	{
		xLog(hLog, XLL_FAIL, "Initializing with context, 0 flags failed!");
		fSuccess = FALSE;
		goto Exit;
	}

	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Sending to AllPlayersGroup without a connection"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo AllPlayersGroup without a connection");

	CopyMemory(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC));
	dpnhSendTo = (DPNHANDLE) 0x666;

	hr = pPeer->SendTo(DPNID_ALL_PLAYERS_GROUP, &dpnbd, 1, 0, NULL, &dpnhSendTo, 0);
	if (hr != DPNERR_NOCONNECTION)
		xLog(hLog, XLL_FAIL, "SendTo didn't fail with expected error NOCONNECTION!");
	else
	{
		xLog(hLog, XLL_INFO, "SendTo returned NOCONNECTION successfully");
		
		if (memcmp(&dpnbdCompare, &dpnbd, sizeof (DPN_BUFFER_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Buffer desc structure was modified!");
		else
		{
			xLog(hLog, XLL_INFO, "Buffer desc structure wasn't modified");

			if (dpnhSendTo != (DPNHANDLE) 0x666)
				xLog(hLog, XLL_FAIL, "Async operation handle was modified!");
			else
				xLog(hLog, XLL_PASS, "Async operation handle wasn't modified");
		}
	}

	xEndVariation(hLog);	
	
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	// "Hosting session"
	// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
	xStartVariation(hLog, "DirectPlay8Peer: SendTo start hosting session");

	ZeroMemory(&dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	dpAppDesc.dwSize = sizeof (DPN_APPLICATION_DESC);
	dpAppDesc.guidApplication = GUID_PEER_SENDTO;

	CopyMemory(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC));
	
	hr = pPeer->Host(&dpAppDesc, &pDP8Address, 1, NULL, NULL, NULL, 0);
	if (hr != DPN_OK)
		xLog(hLog, XLL_FAIL, "Host didn't succeed with expected return DPN_OK!");
	else
	{
		xLog(hLog, XLL_INFO, "Host returned DPN_OK successfully");
		
		if (memcmp(&dpAppDescCompare, &dpAppDesc, sizeof (DPN_APPLICATION_DESC)) != 0)
			xLog(hLog, XLL_FAIL, "Application desc structure was modified!");
		else
			xLog(hLog, XLL_PASS, "Application desc