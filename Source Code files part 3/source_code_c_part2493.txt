NG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sBIT after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
   {
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sBIT chunk");
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT))
   {
      png_warning(png_ptr, "Duplicate sBIT chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 3;
   else
      truelen = (png_size_t)png_ptr->channels;

   if (length != truelen)
   {
      png_warning(png_ptr, "Incorrect sBIT chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
   {
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[1];
      png_ptr->sig_bit.blue = buf[2];
      png_ptr->sig_bit.alpha = buf[3];
   }
   else
   {
      png_ptr->sig_bit.gray = buf[0];
      png_ptr->sig_bit.red = buf[0];
      png_ptr->sig_bit.green = buf[0];
      png_ptr->sig_bit.blue = buf[0];
      png_ptr->sig_bit.alpha = buf[1];
   }
   png_set_sBIT(png_ptr, info_ptr, &(png_ptr->sig_bit));
}
#endif

#if defined(PNG_READ_cHRM_SUPPORTED)
void /* PRIVATE */
png_handle_cHRM(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[4];
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
#endif
   png_fixed_point int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
      int_y_green, int_x_blue, int_y_blue;

   png_debug(1, "in png_handle_cHRM\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before cHRM");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid cHRM after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Missing PLTE before cHRM");

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_cHRM)
#if defined(PNG_READ_sRGB_SUPPORTED)
      && !(info_ptr->valid & PNG_INFO_sRGB)
#endif
      )
   {
      png_warning(png_ptr, "Duplicate cHRM chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 32)
   {
      png_warning(png_ptr, "Incorrect cHRM chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   int_x_white = (png_fixed_point)png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   int_y_white = (png_fixed_point)png_get_uint_32(buf);

   if (int_x_white > 80000L || int_y_white > 80000L ||
      int_x_white + int_y_white > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM white point");
      png_crc_finish(png_ptr, 24);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   int_x_red = (png_fixed_point)png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   int_y_red = (png_fixed_point)png_get_uint_32(buf);

   if (int_x_red > 80000L || int_y_red > 80000L ||
      int_x_red + int_y_red > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM red point");
      png_crc_finish(png_ptr, 16);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   int_x_green = (png_fixed_point)png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   int_y_green = (png_fixed_point)png_get_uint_32(buf);

   if (int_x_green > 80000L || int_y_green > 80000L ||
      int_x_green + int_y_green > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM green point");
      png_crc_finish(png_ptr, 8);
      return;
   }

   png_crc_read(png_ptr, buf, 4);
   int_x_blue = (png_fixed_point)png_get_uint_32(buf);

   png_crc_read(png_ptr, buf, 4);
   int_y_blue = (png_fixed_point)png_get_uint_32(buf);

   if (int_x_blue > 80000L || int_y_blue > 80000L ||
      int_x_blue + int_y_blue > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM blue point");
      png_crc_finish(png_ptr, 0);
      return;
   }
#ifdef PNG_FLOATING_POINT_SUPPORTED
   white_x = (float)int_x_white / (float)100000.0;
   white_y = (float)int_y_white / (float)100000.0;
   red_x   = (float)int_x_red   / (float)100000.0;
   red_y   = (float)int_y_red   / (float)100000.0;
   green_x = (float)int_x_green / (float)100000.0;
   green_y = (float)int_y_green / (float)100000.0;
   blue_x  = (float)int_x_blue  / (float)100000.0;
   blue_y  = (float)int_y_blue  / (float)100000.0;
#endif

#if defined(PNG_READ_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      {
      if (abs(int_x_white - 31270L) > 1000 ||
          abs(int_y_white - 32900L) > 1000 ||
          abs(  int_x_red - 64000L) > 1000 ||
          abs(  int_y_red - 33000L) > 1000 ||
          abs(int_x_green - 30000L) > 1000 ||
          abs(int_y_green - 60000L) > 1000 ||
          abs( int_x_blue - 15000L) > 1000 ||
          abs( int_y_blue -  6000L) > 1000)
         {

            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
#ifdef PNG_FLOATING_POINT_SUPPORTED
            fprintf(stderr,"wx=%f, wy=%f, rx=%f, ry=%f\n",
               white_x, white_y, red_x, red_y);
            fprintf(stderr,"gx=%f, gy=%f, bx=%f, by=%f\n",
               green_x, green_y, blue_x, blue_y);
#else
            fprintf(stderr,"wx=%ld, wy=%ld, rx=%ld, ry=%ld\n",
               int_x_white, int_y_white, int_x_red, int_y_red);
            fprintf(stderr,"gx=%ld, gy=%ld, bx=%ld, by=%ld\n",
               int_x_green, int_y_green, int_x_blue, int_y_blue);
#endif
#endif /* PNG_NO_CONSOLE_IO */
         }
         png_crc_finish(png_ptr, 0);
         return;
      }
#endif /* PNG_READ_sRGB_SUPPORTED */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   png_set_cHRM(png_ptr, info_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_cHRM_fixed(png_ptr, info_ptr,
      int_x_white, int_y_white, int_x_red, int_y_red, int_x_green,
      int_y_green, int_x_blue, int_y_blue);
#endif
   if (png_crc_finish(png_ptr, 0))
      return;
}
#endif

#if defined(PNG_READ_sRGB_SUPPORTED)
void /* PRIVATE */
png_handle_sRGB(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   int intent;
   png_byte buf[1];

   png_debug(1, "in png_handle_sRGB\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sRGB");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sRGB after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place sRGB chunk");

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sRGB))
   {
      png_warning(png_ptr, "Duplicate sRGB chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 1)
   {
      png_warning(png_ptr, "Incorrect sRGB chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 1);
   if (png_crc_finish(png_ptr, 0))
      return;

   intent = buf[0];
   /* check for bad intent */
   if (intent >= PNG_sRGB_INTENT_LAST)
   {
      png_warning(png_ptr, "Unknown sRGB intent");
      return;
   }

#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_READ_GAMMA_SUPPORTED)
   if ((info_ptr->valid & PNG_INFO_gAMA))
   {
   int igamma;
#ifdef PNG_FIXED_POINT_SUPPORTED
      igamma=(int)info_ptr->int_gamma;
#else
#  ifdef PNG_FLOATING_POINT_SUPPORTED
      igamma=(int)(info_ptr->gamma * 100000.);
#  endif
#endif
#if 0 && defined(PNG_cHRM_SUPPORTED) && !defined(PNG_FIXED_POINT_SUPPORTED)
/* We need to define these here because they aren't in png.h */
   png_fixed_point int_x_white;
   png_fixed_point int_y_white;
   png_fixed_point int_x_red;
   png_fixed_point int_y_red;
   png_fixed_point int_x_green;
   png_fixed_point int_y_green;
   png_fixed_point int_x_blue;
   png_fixed_point int_y_blue;
#endif
      if(igamma < 45000L || igamma > 46000L)
      {
         png_warning(png_ptr,
           "Ignoring incorrect gAMA value when sRGB is also present");
#ifndef PNG_NO_CONSOLE_IO
#  ifdef PNG_FIXED_POINT_SUPPORTED
         fprintf(stderr,"incorrect gamma=(%d/100000)\n",(int)png_ptr->int_gamma);
#  else
#    ifdef PNG_FLOATING_POINT_SUPPORTED
         fprintf(stderr,"incorrect gamma=%f\n",png_ptr->gamma);
#    endif
#  endif
#endif
      }
   }
#endif /* PNG_READ_gAMA_SUPPORTED */

#ifdef PNG_READ_cHRM_SUPPORTED
#ifdef PNG_FIXED_POINT_SUPPORTED
   if (info_ptr->valid & PNG_INFO_cHRM)
      if (abs(info_ptr->int_x_white - 31270L) > 1000 ||
          abs(info_ptr->int_y_white - 32900L) > 1000 ||
          abs(  info_ptr->int_x_red - 64000L) > 1000 ||
          abs(  info_ptr->int_y_red - 33000L) > 1000 ||
          abs(info_ptr->int_x_green - 30000L) > 1000 ||
          abs(info_ptr->int_y_green - 60000L) > 1000 ||
          abs( info_ptr->int_x_blue - 15000L) > 1000 ||
          abs( info_ptr->int_y_blue -  6000L) > 1000)
         {
            png_warning(png_ptr,
              "Ignoring incorrect cHRM value when sRGB is also present");
         }
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_READ_cHRM_SUPPORTED */

   png_set_sRGB_gAMA_and_cHRM(png_ptr, info_ptr, intent);
}
#endif /* PNG_READ_sRGB_SUPPORTED */

#if defined(PNG_READ_iCCP_SUPPORTED)
void /* PRIVATE */
png_handle_iCCP(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
/* Note: this does not properly handle chunks that are > 64K under DOS */
{
   png_charp chunkdata;
   png_byte compression_type;
   png_charp profile;
   png_uint_32 skip = 0;
   png_uint_32 profile_size = 0;
   png_uint_32 profile_length = 0;
   png_size_t slength, prefix_length, data_length;

   png_debug(1, "in png_handle_iCCP\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before iCCP");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid iCCP after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->mode & PNG_HAVE_PLTE)
      /* Should be an error, but we can cope with it */
      png_warning(png_ptr, "Out of place iCCP chunk");

   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_iCCP))
   {
      png_warning(png_ptr, "Duplicate iCCP chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "iCCP chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, chunkdata);
      return;
   }

   chunkdata[slength] = 0x00;

   for (profile = chunkdata; *profile; profile++)
      /* empty loop to find end of name */ ;

   ++profile;

   /* there should be at least one zero (the compression type byte)
      following the separator, and we should be on it  */
   if ( profile >= chunkdata + slength)
   {
      png_free(png_ptr, chunkdata);
      png_warning(png_ptr, "Malformed iCCP chunk");
      return;
   }

   /* compression_type should always be zero */
   compression_type = *profile++;
   if (compression_type)
   {
      png_warning(png_ptr, "Ignoring nonzero compression type in iCCP chunk");
      compression_type=0x00;  /* Reset it to zero (libpng-1.0.6 through 1.0.8
                                 wrote nonzero) */
   }

   prefix_length = profile - chunkdata;
   chunkdata = png_decompress_chunk(png_ptr, compression_type, chunkdata,
                                    slength, prefix_length, &data_length);

   profile_length = data_length - prefix_length;

   /* Check the profile_size recorded in the first 32 bits of the ICC profile */
   profile_size = ((*(chunkdata+prefix_length))<<24) |
                  ((*(chunkdata+prefix_length+1))<<16) |
                  ((*(chunkdata+prefix_length+2))<< 8) |
                  ((*(chunkdata+prefix_length+3))    );

   if(profile_size < profile_length)
      profile_length = profile_size;

   if(profile_size > profile_length)
   {
      png_warning(png_ptr, "Ignoring truncated iCCP profile.\n");
      return;
   }

   png_set_iCCP(png_ptr, info_ptr, chunkdata, compression_type,
                chunkdata + prefix_length, profile_length);
   png_free(png_ptr, chunkdata);
}
#endif /* PNG_READ_iCCP_SUPPORTED */

#if defined(PNG_READ_sPLT_SUPPORTED)
void /* PRIVATE */
png_handle_sPLT(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
/* Note: this does not properly handle chunks that are > 64K under DOS */
{
   png_bytep chunkdata;
   png_bytep entry_start;
   png_sPLT_t new_palette;
#ifdef PNG_NO_POINTER_INDEXING
   png_sPLT_entryp pp;
#endif
   int data_length, entry_size, i;
   png_uint_32 skip = 0;
   png_size_t slength;

   png_debug(1, "in png_handle_sPLT\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sPLT");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sPLT after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "sPLT chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   chunkdata = (png_bytep)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, chunkdata);
      return;
   }

   chunkdata[slength] = 0x00;

   for (entry_start = chunkdata; *entry_start; entry_start++)
      /* empty loop to find end of name */ ;
   ++entry_start;

   /* a sample depth should follow the separator, and we should be on it  */
   if (entry_start > chunkdata + slength)
   {
      png_free(png_ptr, chunkdata);
      png_warning(png_ptr, "malformed sPLT chunk");
      return;
   }

   new_palette.depth = *entry_start++;
   entry_size = (new_palette.depth == 8 ? 6 : 10);
   data_length = (slength - (entry_start - chunkdata));

   /* integrity-check the data length */
   if (data_length % entry_size)
   {
      png_free(png_ptr, chunkdata);
      png_warning(png_ptr, "sPLT chunk has bad length");
      return;
   }

   new_palette.nentries = data_length / entry_size;
   new_palette.entries = (png_sPLT_entryp)png_malloc(
       png_ptr, new_palette.nentries * sizeof(png_sPLT_entry));

#ifndef PNG_NO_POINTER_INDEXING
   for (i = 0; i < new_palette.nentries; i++)
   {
      png_sPLT_entryp pp = new_palette.entries + i;

      if (new_palette.depth == 8)
      {
          pp->red = *entry_start++;
          pp->green = *entry_start++;
          pp->blue = *entry_start++;
          pp->alpha = *entry_start++;
      }
      else
      {
          pp->red   = png_get_uint_16(entry_start); entry_start += 2;
          pp->green = png_get_uint_16(entry_start); entry_start += 2;
          pp->blue  = png_get_uint_16(entry_start); entry_start += 2;
          pp->alpha = png_get_uint_16(entry_start); entry_start += 2;
      }
      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#else
   pp = new_palette.entries;
   for (i = 0; i < new_palette.nentries; i++)
   {

      if (new_palette.depth == 8)
      {
          pp[i].red   = *entry_start++;
          pp[i].green = *entry_start++;
          pp[i].blue  = *entry_start++;
          pp[i].alpha = *entry_start++;
      }
      else
      {
          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
      }
      pp->frequency = png_get_uint_16(entry_start); entry_start += 2;
   }
#endif

   /* discard all chunk data except the name and stash that */
   new_palette.name = (png_charp)chunkdata;

   png_set_sPLT(png_ptr, info_ptr, &new_palette, 1);

   png_free(png_ptr, chunkdata);
   png_free(png_ptr, new_palette.entries);
}
#endif /* PNG_READ_sPLT_SUPPORTED */

#if defined(PNG_READ_tRNS_SUPPORTED)
void /* PRIVATE */
png_handle_tRNS(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte	readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_tRNS\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tRNS");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid tRNS after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS))
   {
      png_warning(png_ptr, "Duplicate tRNS chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (!(png_ptr->mode & PNG_HAVE_PLTE))
      {
         /* Should be an error, but we can cope with it */
         png_warning(png_ptr, "Missing PLTE before tRNS");
      }
      else if (length > (png_uint_32)png_ptr->num_palette)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }
      if (length == 0)
      {
         png_warning(png_ptr, "Zero length tRNS chunk");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, readbuf, (png_size_t)length);
      png_ptr->num_trans = (png_uint_16)length;
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_byte buf[6];

      if (length != 6)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, buf, (png_size_t)length);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.red = png_get_uint_16(buf);
      png_ptr->trans_values.green = png_get_uint_16(buf + 2);
      png_ptr->trans_values.blue = png_get_uint_16(buf + 4);
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_byte buf[6];

      if (length != 2)
      {
         png_warning(png_ptr, "Incorrect tRNS chunk length");
         png_crc_finish(png_ptr, length);
         return;
      }

      png_crc_read(png_ptr, buf, 2);
      png_ptr->num_trans = 1;
      png_ptr->trans_values.gray = png_get_uint_16(buf);
   }
   else
   {
      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_crc_finish(png_ptr, 0))
      return;

   png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr->num_trans,
      &(png_ptr->trans_values));
}
#endif

#if defined(PNG_READ_bKGD_SUPPORTED)
void /* PRIVATE */
png_handle_bKGD(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_size_t truelen;
   png_byte buf[6];

   png_debug(1, "in png_handle_bKGD\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before bKGD");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid bKGD after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&
            !(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before bKGD");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD))
   {
      png_warning(png_ptr, "Duplicate bKGD chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      truelen = 1;
   else if (png_ptr->color_type & PNG_COLOR_MASK_COLOR)
      truelen = 6;
   else
      truelen = 2;

   if (length != truelen)
   {
      png_warning(png_ptr, "Incorrect bKGD chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, truelen);
   if (png_crc_finish(png_ptr, 0))
      return;

   /* We convert the index value into RGB components so that we can allow
    * arbitrary RGB values for background when we have transparency, and
    * so it is easy to determine the RGB values of the background color
    * from the info_ptr struct. */
   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
   {
      png_ptr->background.index = buf[0];
      if(info_ptr->num_palette)
      {
          if(buf[0] > info_ptr->num_palette)
          {
             png_warning(png_ptr, "Incorrect bKGD chunk index value");
             return;
          }
          png_ptr->background.red =
             (png_uint_16)png_ptr->palette[buf[0]].red;
          png_ptr->background.green =
             (png_uint_16)png_ptr->palette[buf[0]].green;
          png_ptr->background.blue =
             (png_uint_16)png_ptr->palette[buf[0]].blue;
      }
   }
   else if (!(png_ptr->color_type & PNG_COLOR_MASK_COLOR)) /* GRAY */
   {
      png_ptr->background.red =
      png_ptr->background.green =
      png_ptr->background.blue =
      png_ptr->background.gray = png_get_uint_16(buf);
   }
   else
   {
      png_ptr->background.red = png_get_uint_16(buf);
      png_ptr->background.green = png_get_uint_16(buf + 2);
      png_ptr->background.blue = png_get_uint_16(buf + 4);
   }

   png_set_bKGD(png_ptr, info_ptr, &(png_ptr->background));
}
#endif

#if defined(PNG_READ_hIST_SUPPORTED)
void /* PRIVATE */
png_handle_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   int num, i;
   png_uint_16	readbuf[PNG_MAX_PALETTE_LENGTH];

   png_debug(1, "in png_handle_hIST\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before hIST");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid hIST after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (!(png_ptr->mode & PNG_HAVE_PLTE))
   {
      png_warning(png_ptr, "Missing PLTE before hIST");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST))
   {
      png_warning(png_ptr, "Duplicate hIST chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   num = (int)length / 2 ;
   if (num != png_ptr->num_palette)
   {
      png_warning(png_ptr, "Incorrect hIST chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   for (i = 0; i < num; i++)
   {
      png_byte buf[2];

      png_crc_read(png_ptr, buf, 2);
      readbuf[i] = png_get_uint_16(buf);
   }

   if (png_crc_finish(png_ptr, 0))
      return;

   png_set_hIST(png_ptr, info_ptr, readbuf);
}
#endif

#if defined(PNG_READ_pHYs_SUPPORTED)
void /* PRIVATE */
png_handle_pHYs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_uint_32 res_x, res_y;
   int unit_type;

   png_debug(1, "in png_handle_pHYs\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pHYs");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pHYs after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs))
   {
      png_warning(png_ptr, "Duplicate pHYs chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect pHYs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   res_x = png_get_uint_32(buf);
   res_y = png_get_uint_32(buf + 4);
   unit_type = buf[8];
   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
}
#endif

#if defined(PNG_READ_oFFs_SUPPORTED)
void /* PRIVATE */
png_handle_oFFs(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[9];
   png_int_32 offset_x, offset_y;
   int unit_type;

   png_debug(1, "in png_handle_oFFs\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before oFFs");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid oFFs after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs))
   {
      png_warning(png_ptr, "Duplicate oFFs chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (length != 9)
   {
      png_warning(png_ptr, "Incorrect oFFs chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 9);
   if (png_crc_finish(png_ptr, 0))
      return;

   offset_x = png_get_int_32(buf);
   offset_y = png_get_int_32(buf + 4);
   unit_type = buf[8];
   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
}
#endif

#if defined(PNG_READ_pCAL_SUPPORTED)
/* read the pCAL chunk (described in the PNG Extensions document) */
void /* PRIVATE */
png_handle_pCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_charp purpose;
   png_int_32 X0, X1;
   png_byte type, nparams;
   png_charp buf, units, endptr;
   png_charpp params;
   png_size_t slength;
   int i;

   png_debug(1, "in png_handle_pCAL\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before pCAL");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid pCAL after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL))
   {
      png_warning(png_ptr, "Duplicate pCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_debug1(2, "Allocating and reading pCAL chunk data (%lu bytes)\n",
      length + 1);
   purpose = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)purpose, slength);

   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, purpose);
      return;
   }

   purpose[slength] = 0x00; /* null terminate the last string */

   png_debug(3, "Finding end of pCAL purpose string\n");
   for (buf = purpose; *buf; buf++)
      /* empty loop */ ;

   endptr = purpose + slength;

   /* We need to have at least 12 bytes after the purpose string
      in order to get the parameter information. */
   if (endptr <= buf + 12)
   {
      png_warning(png_ptr, "Invalid pCAL data");
      png_free(png_ptr, purpose);
      return;
   }

   png_debug(3, "Reading pCAL X0, X1, type, nparams, and units\n");
   X0 = png_get_int_32((png_bytep)buf+1);
   X1 = png_get_int_32((png_bytep)buf+5);
   type = buf[9];
   nparams = buf[10];
   units = buf + 11;

   png_debug(3, "Checking pCAL equation type and number of parameters\n");
   /* Check that we have the right number of parameters for known
      equation types. */
   if ((type == PNG_EQUATION_LINEAR && nparams != 2) ||
       (type == PNG_EQUATION_BASE_E && nparams != 3) ||
       (type == PNG_EQUATION_ARBITRARY && nparams != 3) ||
       (type == PNG_EQUATION_HYPERBOLIC && nparams != 4))
   {
      png_warning(png_ptr, "Invalid pCAL parameters for equation type");
      png_free(png_ptr, purpose);
      return;
   }
   else if (type >= PNG_EQUATION_LAST)
   {
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");
   }

   for (buf = units; *buf; buf++)
      /* Empty loop to move past the units string. */ ;

   png_debug(3, "Allocating pCAL parameters array\n");
   params = (png_charpp)png_malloc(png_ptr, (png_uint_32)(nparams
      *sizeof(png_charp))) ;

   /* Get pointers to the start of each parameter string. */
   for (i = 0; i < (int)nparams; i++)
   {
      buf++; /* Skip the null string terminator from previous parameter. */

      png_debug1(3, "Reading pCAL parameter %d\n", i);
      for (params[i] = buf; *buf != 0x00 && buf <= endptr; buf++)
         /* Empty loop to move past each parameter string */ ;

      /* Make sure we haven't run out of data yet */
      if (buf > endptr)
      {
         png_warning(png_ptr, "Invalid pCAL data");
         png_free(png_ptr, purpose);
         png_free(png_ptr, params);
         return;
      }
   }

   png_set_pCAL(png_ptr, info_ptr, purpose, X0, X1, type, nparams,
      units, params);

   png_free(png_ptr, purpose);
   png_free(png_ptr, params);
}
#endif

#if defined(PNG_READ_sCAL_SUPPORTED)
/* read the sCAL chunk */
void /* PRIVATE */
png_handle_sCAL(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_charp buffer, ep;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   double width, height;
   png_charp vp;
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_charp swidth, sheight;
#endif
#endif
   png_size_t slength;

   png_debug(1, "in png_handle_sCAL\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before sCAL");
   else if (png_ptr->mode & PNG_HAVE_IDAT)
   {
      png_warning(png_ptr, "Invalid sCAL after IDAT");
      png_crc_finish(png_ptr, length);
      return;
   }
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL))
   {
      png_warning(png_ptr, "Duplicate sCAL chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_debug1(2, "Allocating and reading sCAL chunk data (%lu bytes)\n",
      length + 1);
   buffer = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)buffer, slength);

   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, buffer);
      return;
   }

   buffer[slength] = 0x00; /* null terminate the last string */

   ep = buffer + 1;        /* skip unit byte */

#ifdef PNG_FLOATING_POINT_SUPPORTED
   width = strtod(ep, &vp);
   if (*vp)
   {
       png_warning(png_ptr, "malformed width string in sCAL chunk");
       return;
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   swidth = (png_charp)png_malloc(png_ptr, png_strlen(ep) + 1);
   png_memcpy(swidth, ep, (png_size_t)png_strlen(ep));
#endif
#endif

   for (ep = buffer; *ep; ep++)
      /* empty loop */ ;
   ep++;

#ifdef PNG_FLOATING_POINT_SUPPORTED
   height = strtod(ep, &vp);
   if (*vp)
   {
       png_warning(png_ptr, "malformed height string in sCAL chunk");
       return;
   }
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   sheight = (png_charp)png_malloc(png_ptr, png_strlen(ep) + 1);
   png_memcpy(sheight, ep, (png_size_t)png_strlen(ep));
#endif
#endif

   if (buffer + slength < ep
#ifdef PNG_FLOATING_POINT_SUPPORTED
      || width <= 0. || height <= 0.
#endif
      )
   {
      png_warning(png_ptr, "Invalid sCAL data");
      png_free(png_ptr, buffer);
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
      png_free(png_ptr, swidth);
      png_free(png_ptr, sheight);
#endif
      return;
   }


#ifdef PNG_FLOATING_POINT_SUPPORTED
   png_set_sCAL(png_ptr, info_ptr, buffer[0], width, height);
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_set_sCAL_s(png_ptr, info_ptr, buffer[0], swidth, sheight);
#endif
#endif

   png_free(png_ptr, buffer);
#if defined(PNG_FIXED_POINT_SUPPORTED) && !defined(PNG_FLOATING_POINT_SUPPORTED)
   png_free(png_ptr, swidth);
   png_free(png_ptr, sheight);
#endif
}
#endif

#if defined(PNG_READ_tIME_SUPPORTED)
void /* PRIVATE */
png_handle_tIME(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_byte buf[7];
   png_time mod_time;

   png_debug(1, "in png_handle_tIME\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Out of place tIME chunk");
   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME))
   {
      png_warning(png_ptr, "Duplicate tIME chunk");
      png_crc_finish(png_ptr, length);
      return;
   }

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

   if (length != 7)
   {
      png_warning(png_ptr, "Incorrect tIME chunk length");
      png_crc_finish(png_ptr, length);
      return;
   }

   png_crc_read(png_ptr, buf, 7);
   if (png_crc_finish(png_ptr, 0))
      return;

   mod_time.second = buf[6];
   mod_time.minute = buf[5];
   mod_time.hour = buf[4];
   mod_time.day = buf[3];
   mod_time.month = buf[2];
   mod_time.year = png_get_uint_16(buf);

   png_set_tIME(png_ptr, info_ptr, &mod_time);
}
#endif

#if defined(PNG_READ_tEXt_SUPPORTED)
/* Note: this does not properly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_tEXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp key;
   png_charp text;
   png_uint_32 skip = 0;
   png_size_t slength;

   png_debug(1, "in png_handle_tEXt\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before tEXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   if (length > (png_uint_32)65535L)
   {
      png_warning(png_ptr, "tEXt chunk too large to fit in memory");
      skip = length - (png_uint_32)65535L;
      length = (png_uint_32)65535L;
   }
#endif

   key = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)key, slength);

   if (png_crc_finish(png_ptr, skip))
   {
      png_free(png_ptr, key);
      return;
   }

   key[slength] = 0x00;

   for (text = key; *text; text++)
      /* empty loop to find end of key */ ;

   if (text != key + slength)
      text++;

   text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
   text_ptr->compression = PNG_TEXT_COMPRESSION_NONE;
   text_ptr->key = key;
#ifdef PNG_iTXt_SUPPORTED
   text_ptr->lang = NULL;
   text_ptr->lang_key = NULL;
   text_ptr->itxt_length = 0;
#endif
   text_ptr->text = text;
   text_ptr->text_length = png_strlen(text);

   png_set_text(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, key);
   png_free(png_ptr, text_ptr);
}
#endif

#if defined(PNG_READ_zTXt_SUPPORTED)
/* note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_zTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp chunkdata;
   png_charp text;
   int comp_type;
   png_size_t slength, prefix_len, data_len;

   png_debug(1, "in png_handle_zTXt\n");
   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before zTXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   /* We will no doubt have problems with chunks even half this size, but
      there is no hard and fast rule to tell us where to stop. */
   if (length > (png_uint_32)65535L)
   {
     png_warning(png_ptr,"zTXt chunk too large to fit in memory");
     png_crc_finish(png_ptr, length);
     return;
   }
#endif

   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
     slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, chunkdata);
      return;
   }

   chunkdata[slength] = 0x00;

   for (text = chunkdata; *text; text++)
      /* empty loop */ ;

   /* zTXt must have some text after the chunkdataword */
   if (text == chunkdata + slength)
   {
      comp_type = PNG_TEXT_COMPRESSION_NONE;
      png_warning(png_ptr, "Zero length zTXt chunk");
   }
   else
   {
       comp_type = *(++text);
       if (comp_type != PNG_TEXT_COMPRESSION_zTXt)
       {
          png_warning(png_ptr, "Unknown compression type in zTXt chunk");
          comp_type = PNG_TEXT_COMPRESSION_zTXt;
       }
       text++;        /* skip the compression_method byte */
   }
   prefix_len = text - chunkdata;

   chunkdata = (png_charp)png_decompress_chunk(png_ptr, comp_type, chunkdata,
                                    (png_size_t)length, prefix_len, &data_len);

   text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
   text_ptr->compression = comp_type;
   text_ptr->key = chunkdata;
#ifdef PNG_iTXt_SUPPORTED
   text_ptr->lang = NULL;
   text_ptr->lang_key = NULL;
   text_ptr->itxt_length = 0;
#endif
   text_ptr->text = chunkdata + prefix_len;
   text_ptr->text_length = data_len;

   png_set_text(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
   png_free(png_ptr, chunkdata);
}
#endif

#if defined(PNG_READ_iTXt_SUPPORTED)
/* note: this does not correctly handle chunks that are > 64K under DOS */
void /* PRIVATE */
png_handle_iTXt(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_textp text_ptr;
   png_charp chunkdata;
   png_charp key, lang, text, lang_key;
   int comp_flag;
   int comp_type = 0;
   png_size_t slength, prefix_len, data_len;

   png_debug(1, "in png_handle_iTXt\n");

   if (!(png_ptr->mode & PNG_HAVE_IHDR))
      png_error(png_ptr, "Missing IHDR before iTXt");

   if (png_ptr->mode & PNG_HAVE_IDAT)
      png_ptr->mode |= PNG_AFTER_IDAT;

#ifdef PNG_MAX_MALLOC_64K
   /* We will no doubt have problems with chunks even half this size, but
      there is no hard and fast rule to tell us where to stop. */
   if (length > (png_uint_32)65535L)
   {
     png_warning(png_ptr,"iTXt chunk too large to fit in memory");
     png_crc_finish(png_ptr, length);
     return;
   }
#endif

   chunkdata = (png_charp)png_malloc(png_ptr, length + 1);
   slength = (png_size_t)length;
   png_crc_read(png_ptr, (png_bytep)chunkdata, slength);
   if (png_crc_finish(png_ptr, 0))
   {
      png_free(png_ptr, chunkdata);
      return;
   }

   chunkdata[slength] = 0x00;

   for (lang = chunkdata; *lang; lang++)
      /* empty loop */ ;
   lang++;        /* skip NUL separator */

   /* iTXt must have a language tag (possibly empty), two compression bytes,
      translated keyword (possibly empty), and possibly some text after the
      keyword */

   if (lang >= chunkdata + slength)
   {
      comp_flag = PNG_TEXT_COMPRESSION_NONE;
      png_warning(png_ptr, "Zero length iTXt chunk");
   }
   else
   {
       comp_flag = *lang++;
       comp_type = *lang++;
   }

   for (lang_key = lang; *lang_key; lang_key++)
      /* empty loop */ ;
   lang_key++;        /* skip NUL separator */

   for (text = lang_key; *text; text++)
      /* empty loop */ ;
   text++;        /* skip NUL separator */

   prefix_len = text - chunkdata;

   key=chunkdata;
   if (comp_flag)
       chunkdata = png_decompress_chunk(png_ptr, comp_type, chunkdata,
          (size_t)length, prefix_len, &data_len);
   else
       data_len=png_strlen(chunkdata + prefix_len);
   text_ptr = (png_textp)png_malloc(png_ptr, (png_uint_32)sizeof(png_text));
   text_ptr->compression = (int)comp_flag + 1;
   text_ptr->lang_key = chunkdata+(lang_key-key);
   text_ptr->lang = chunkdata+(lang-key);
   text_ptr->itxt_length = data_len;
   text_ptr->text_length = 0;
   text_ptr->key = chunkdata;
   text_ptr->text = chunkdata + prefix_len;

   png_set_text(png_ptr, info_ptr, text_ptr, 1);

   png_free(png_ptr, text_ptr);
   png_free(png_ptr, chunkdata);
}
#endif

/* This function is called when we haven't found a handler for a
   chunk.  If there isn't a problem with the chunk itself (ie bad
   chunk name, CRC, or a critical chunk), the chunk is silently ignored
   -- unless the PNG_FLAG_UNKNOWN_CHUNKS_SUPPORTED flag is on in which
   case it will be saved away to be written out later. */
void /* PRIVATE */
png_handle_unknown(png_structp png_ptr, png_infop info_ptr, png_uint_32 length)
{
   png_uint_32 skip = 0;

   png_debug(1, "in png_handle_unknown\n");

   if (png_ptr->mode & PNG_HAVE_IDAT)
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_IDAT;
#endif
      if (png_memcmp(png_ptr->chunk_name, png_IDAT, 4))  /* not an IDAT */
         png_ptr->mode |= PNG_AFTER_IDAT;
   }

   png_check_chunk_name(png_ptr, png_ptr->chunk_name);

   if (!(png_ptr->chunk_name[0] & 0x20))
   {
#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
      if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
           HANDLE_CHUNK_ALWAYS
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
           && png_ptr->read_user_chunk_fn == NULL
#endif
        )
#endif
          png_chunk_error(png_ptr, "unknown critical chunk");
   }

#if defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
   if (png_ptr->flags & PNG_FLAG_KEEP_UNKNOWN_CHUNKS)
   {
       png_unknown_chunk chunk;

#ifdef PNG_MAX_MALLOC_64K
       if (length > (png_uint_32)65535L)
       {
           png_warning(png_ptr, "unknown chunk too large to fit in memory");
           skip = length - (png_uint_32)65535L;
           length = (png_uint_32)65535L;
       }
#endif
       png_strcpy((png_charp)chunk.name, (png_charp)png_ptr->chunk_name);
       chunk.data = (png_bytep)png_malloc(png_ptr, length);
       chunk.size = (png_size_t)length;
       png_crc_read(png_ptr, (png_bytep)chunk.data, length);
#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
       if(png_ptr->read_user_chunk_fn != NULL)
       {
          /* callback to user unknown chunk handler */
          if ((*(png_ptr->read_user_chunk_fn)) (png_ptr, &chunk) <= 0)
          {
             if (!(png_ptr->chunk_name[0] & 0x20))
                if(png_handle_as_unknown(png_ptr, png_ptr->chunk_name) !=
                     HANDLE_CHUNK_ALWAYS)
                   png_chunk_error(png_ptr, "unknown critical chunk");
             png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
          }
       }
       else
#endif
          png_set_unknown_chunks(png_ptr, info_ptr, &chunk, 1);
       png_free(png_ptr, chunk.data);
   }
   else
#endif
      skip = length;

   png_crc_finish(png_ptr, skip);

#if !defined(PNG_READ_USER_CHUNKS_SUPPORTED)
   if (info_ptr == NULL)
     /* quiet compiler warnings about unused info_ptr */ ;
#endif
}

/* This function is called to verify that a chunk name is valid.
   This function can't have the "critical chunk check" incorporated
   into it, since in the future we will need to be able to call user
   functions to handle unknown critical chunks after we check that
   the chunk name itself is valid. */

#define isnonalpha(c) ((c) < 41 || (c) > 122 || ((c) > 90 && (c) < 97))

void /* PRIVATE */
png_check_chunk_name(png_structp png_ptr, png_bytep chunk_name)
{
   png_debug(1, "in png_check_chunk_name\n");
   if (isnonalpha(chunk_name[0]) || isnonalpha(chunk_name[1]) ||
       isnonalpha(chunk_name[2]) || isnonalpha(chunk_name[3]))
   {
      png_chunk_error(png_ptr, "invalid chunk type");
   }
}

/* Combines the row recently read in with the existing pixels in the
   row.  This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined,
   a zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.  If
   you want all pixels to be combined, pass 0xff (255) in mask.  */
#ifndef PNG_HAVE_ASSEMBLER_COMBINE_ROW
void /* PRIVATE */
png_combine_row(png_structp png_ptr, png_bytep row, int mask)
{
   png_debug(1,"in png_combine_row\n");
   if (mask == 0xff)
   {
      png_memcpy(row, png_ptr->row_buf + 1,
         (png_size_t)((png_ptr->width *
         png_ptr->row_info.pixel_depth + 7) >> 3));
   }
   else
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_inc, s_start, s_end;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x01;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x03;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            int s_start, s_end, s_inc;
            int m = 0x80;
            int shift;
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            int value;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
         default:
         {
            png_bytep sp = png_ptr->row_buf + 1;
            png_bytep dp = row;
            png_size_t pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
            png_uint_32 i;
            png_uint_32 row_width = png_ptr->width;
            png_byte m = 0x80;


            for (i = 0; i < row_width; i++)
            {
               if (m & mask)
               {
                  png_memcpy(dp, sp, pixel_bytes);
               }

               sp += pixel_bytes;
               dp += pixel_bytes;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }
      }
   }
}
#endif /* !PNG_HAVE_ASSEMBLER_COMBINE_ROW */

#ifdef PNG_READ_INTERLACING_SUPPORTED
#ifndef PNG_HAVE_ASSEMBLER_READ_INTERLACE   /* else in pngvcrd.c, pnggccrd.c */
/* OLD pre-1.0.9 interface:
void png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
   png_uint_32 transformations)
 */
void /* PRIVATE */
png_do_read_interlace(png_structp png_ptr)
{
   png_row_infop row_info = &(png_ptr->row_info);
   png_bytep row = png_ptr->row_buf + 1;
   int pass = png_ptr->pass;
   png_uint_32 transformations = png_ptr->transformations;
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */
   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1,"in png_do_read_interlace (stock C version)\n");
   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 3);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 3);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_byte v;
            png_uint_32 i;
            int j;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
                sshift = (int)((row_info->width + 7) & 0x07);
                dshift = (int)((final_width + 7) & 0x07);
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }
            else
#endif
            {
                sshift = 7 - (int)((row_info->width + 7) & 0x07);
                dshift = 7 - (int)((final_width + 7) & 0x07);
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }

            for (i = 0; i < row_info->width; i++)
            {
               v = (png_byte)((*sp >> sshift) & 0x01);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 2:
         {
            png_bytep sp = row + (png_uint_32)((row_info->width - 1) >> 2);
            png_bytep dp = row + (png_uint_32)((final_width - 1) >> 2);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            int jstop = png_pass_inc[pass];
            png_uint_32 i;

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
               dshift = (int)(((final_width + 3) & 0x03) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x03);
               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         case 4:
         {
            png_bytep sp = row + (png_size_t)((row_info->width - 1) >> 1);
            png_bytep dp = row + (png_size_t)((final_width - 1) >> 1);
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;
            int jstop = png_pass_inc[pass];

#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
               dshift = (int)(((final_width + 1) & 0x01) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v = (png_byte)((*sp >> sshift) & 0xf);
               int j;

               for (j = 0; j < jstop; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }
         default:
         {
            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
            png_bytep sp = row + (png_size_t)(row_info->width - 1) * pixel_bytes;
            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;

            int jstop = png_pass_inc[pass];
            png_uint_32 i;

            for (i = 0; i < row_info->width; i++)
            {
               png_byte v[8];
               int j;

               png_memcpy(v, sp, pixel_bytes);
               for (j = 0; j < jstop; j++)
               {
                  png_memcpy(dp, v, pixel_bytes);
                  dp -= pixel_bytes;
               }
               sp -= pixel_bytes;
            }
            break;
         }
      }
      row_info->width = final_width;
      row_info->rowbytes = ((final_width *
         (png_uint_32)row_info->pixel_depth + 7) >> 3);
   }
#if !defined(PNG_READ_PACKSWAP_SUPPORTED)
   /* silence compiler warning */
   if (transformations)
      return;
#endif
}
#endif /* !PNG_HAVE_ASSEMBLER_READ_INTERLACE */
#endif /* PNG_READ_INTERLACING_SUPPORTED */

#ifndef PNG_HAVE_ASSEMBLER_READ_FILTER_ROW
void /* PRIVATE */
png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep row,
   png_bytep prev_row, int filter)
{
   png_debug(1, "in png_read_filter_row\n");
   png_debug2(2,"row = %lu, filter = %d\n", png_ptr->row_number, filter);
   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;
      case PNG_FILTER_VALUE_SUB:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_bytep rp = row + bpp;
         png_bytep lp = row;

         for (i = bpp; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_UP:
      {
         png_uint_32 i;
         png_uint_32 istop = row_info->rowbytes;
         png_bytep rp = row;
         png_bytep pp = prev_row;

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_AVG:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop = row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               ((int)(*pp++) / 2 )) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)
         {
            *rp = (png_byte)(((int)(*rp) +
               (int)(*pp++ + *lp++) / 2 ) & 0xff);
            rp++;
         }
         break;
      }
      case PNG_FILTER_VALUE_PAETH:
      {
         png_uint_32 i;
         png_bytep rp = row;
         png_bytep pp = prev_row;
         png_bytep lp = row;
         png_bytep cp = prev_row;
         png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
         png_uint_32 istop=row_info->rowbytes - bpp;

         for (i = 0; i < bpp; i++)
         {
            *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
            rp++;
         }

         for (i = 0; i < istop; i++)   /* use leftover rp,pp */
         {
            int a, b, c, pa, pb, pc, p;

            a = *lp++;
            b = *pp++;
            c = *cp++;

            p = b - c;
            pc = a - c;

#ifdef PNG_USE_ABS
            pa = abs(p);
            pb = abs(pc);
            pc = abs(p + pc);
#else
            pa = p < 0 ? -p : p;
            pb = pc < 0 ? -pc : pc;
            pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

            /*
               if (pa <= pb && pa <= pc)
                  p = a;
               else if (pb <= pc)
                  p = b;
               else
                  p = c;
             */

            p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

            *rp = (png_byte)(((int)(*rp) + p) & 0xff);
            rp++;
         }
         break;
      }
      default:
         png_warning(png_ptr, "Ignoring bad adaptive filter type");
         *row=0;
         break;
   }
}
#endif /* !PNG_HAVE_ASSEMBLER_READ_FILTER_ROW */

void /* PRIVATE */
png_read_finish_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* start of interlace block in the y direction */
   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* offset to next interlace block in the y direction */
   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   png_debug(1, "in png_read_finish_row\n");
   png_ptr->row_number++;
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);
      do
      {
         png_ptr->pass++;
         if (png_ptr->pass >= 7)
            break;
         png_ptr->iwidth = (png_ptr->width +
            png_pass_inc[png_ptr->pass] - 1 -
            png_pass_start[png_ptr->pass]) /
            png_pass_inc[png_ptr->pass];
            png_ptr->irowbytes = ((png_ptr->iwidth *
               (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;

         if (!(png_ptr->transformations & PNG_INTERLACE))
         {
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (!(png_ptr->num_rows))
               continue;
         }
         else  /* if (png_ptr->transformations & PNG_INTERLACE) */
            break;
      } while (png_ptr->iwidth == 0);

      if (png_ptr->pass < 7)
         return;
   }

   if (!(png_ptr->flags & PNG_FLAG_ZLIB_FINISHED))
   {
#ifdef PNG_USE_LOCAL_ARRAYS
      PNG_IDAT;
#endif
      char extra;
      int ret;

      png_ptr->zstream.next_out = (Byte *)&extra;
      png_ptr->zstream.avail_out = (uInt)1;
      for(;;)
      {
         if (!(png_ptr->zstream.avail_in))
         {
            while (!png_ptr->idat_size)
            {
               png_byte chunk_length[4];

               png_crc_finish(png_ptr, 0);

               png_read_data(png_ptr, chunk_length, 4);
               png_ptr->idat_size = png_get_uint_32(chunk_length);

               png_reset_crc(png_ptr);
               png_crc_read(png_ptr, png_ptr->chunk_name, 4);
               if (png_memcmp(png_ptr->chunk_name, (png_bytep)png_IDAT, 4))
                  png_error(png_ptr, "Not enough image data");

            }
            png_ptr->zstream.avail_in = (uInt)png_ptr->zbuf_size;
            png_ptr->zstream.next_in = png_ptr->zbuf;
            if (png_ptr->zbuf_size > png_ptr->idat_size)
               png_ptr->zstream.avail_in = (uInt)png_ptr->idat_size;
            png_crc_read(png_ptr, png_ptr->zbuf, png_ptr->zstream.avail_in);
            png_ptr->idat_size -= png_ptr->zstream.avail_in;
         }
         ret = inflate(&png_ptr->zstream, Z_PARTIAL_FLUSH);
         if (ret == Z_STREAM_END)
         {
            if (!(png_ptr->zstream.avail_out) || png_ptr->zstream.avail_in ||
               png_ptr->idat_size)
               png_error(png_ptr, "Extra compressed data");
            png_ptr->mode |= PNG_AFTER_IDAT;
            png_ptr->flags |= PNG_FLAG_ZLIB_FINISHED;
            break;
         }
         if (ret != Z_OK)
            png_error(png_ptr, png_ptr->zstream.msg ? png_ptr->zstream.msg :
                      "Decompression Error");

         if (!(png_ptr->zstream.avail_out))
            png_error(png_ptr, "Extra compressed data");

      }
      png_ptr->zstream.avail_out = 0;
   }

   if (png_ptr->idat_size || png_ptr->zstream.avail_in)
      png_error(png_ptr, "Extra compression data");

   inflateReset(&png_ptr->zstream);

   png_ptr->mode |= PNG_AFTER_IDAT;
}

void /* PRIVATE */
png_read_start_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   const int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* start of interlace block in the y direction */
   const int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* offset to next interlace block in the y direction */
   const int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   int max_pixel_depth;
   png_uint_32 row_bytes;

   png_debug(1, "in png_read_start_row\n");
   png_ptr->zstream.avail_in = 0;
   png_init_read_transformations(png_ptr);
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
      else
         png_ptr->num_rows = png_ptr->height;

      png_ptr->iwidth = (png_ptr->width +
         png_pass_inc[png_ptr->pass] - 1 -
         png_pass_start[png_ptr->pass]) /
         png_pass_inc[png_ptr->pass];

         row_bytes = ((png_ptr->iwidth *
            (png_uint_32)png_ptr->pixel_depth + 7) >> 3) +1;
         png_ptr->irowbytes = (png_size_t)row_bytes;
         if((png_uint_32)png_ptr->irowbytes != row_bytes)
            png_error(png_ptr, "Rowbytes overflow in png_read_start_row");
   }
   else
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->iwidth = png_ptr->width;
      png_ptr->irowbytes = png_ptr->rowbytes + 1;
   }
   max_pixel_depth = png_ptr->pixel_depth;

#if defined(PNG_READ_PACK_SUPPORTED)
   if ((png_ptr->transformations & PNG_PACK) && png_ptr->bit_depth < 8)
      max_pixel_depth = 8;
#endif

#if defined(PNG_READ_EXPAND_SUPPORTED)
   if (png_ptr->transformations & PNG_EXPAND)
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      {
         if (png_ptr->num_trans)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 24;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth < 8)
            max_pixel_depth = 8;
         if (png_ptr->num_trans)
            max_pixel_depth *= 2;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (png_ptr->num_trans)
         {
            max_pixel_depth *= 4;
            max_pixel_depth /= 3;
         }
      }
   }
#endif

#if defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & (PNG_FILLER))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         max_pixel_depth = 32;
      else if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY)
      {
         if (max_pixel_depth <= 8)
            max_pixel_depth = 16;
         else
            max_pixel_depth = 32;
      }
      else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
      {
         if (max_pixel_depth <= 32)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
   }
#endif

#if defined(PNG_READ_GRAY_TO_RGB_SUPPORTED)
   if (png_ptr->transformations & PNG_GRAY_TO_RGB)
   {
      if (
#if defined(PNG_READ_EXPAND_SUPPORTED)
        (png_ptr->num_trans && (png_ptr->transformations & PNG_EXPAND)) ||
#endif
#if defined(PNG_READ_FILLER_SUPPORTED)
        (png_ptr->transformations & (PNG_FILLER)) ||
#endif
        png_ptr->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         if (max_pixel_depth <= 16)
            max_pixel_depth = 32;
         else
            max_pixel_depth = 64;
      }
      else
      {
         if (max_pixel_depth <= 8)
           {
             if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
               max_pixel_depth = 32;
             else
               max_pixel_depth = 24;
           }
         else if (png_ptr->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            max_pixel_depth = 64;
         else
            max_pixel_depth = 48;
      }
   }
#endif

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) && \
defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   if(png_ptr->transformations & PNG_USER_TRANSFORM)
     {
       int user_pixel_depth=png_ptr->user_transform_depth*
         png_ptr->user_transform_channels;
       if(user_pixel_depth > max_pixel_depth)
         max_pixel_depth=user_pixel_depth;
     }
#endif

   /* align the width on the next larger 8 pixels.  Mainly used
      for interlacing */
   row_bytes = ((png_ptr->width + 7) & ~((png_uint_32)7));
   /* calculate the maximum bytes needed, adding a byte and a pixel
      for safety's sake */
   row_bytes = ((row_bytes * (png_uint_32)max_pixel_depth + 7) >> 3) +
      1 + ((max_pixel_depth + 7) >> 3);
#ifdef PNG_MAX_MALLOC_64K
   if (row_bytes > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, row_bytes);
   png_ptr->row_buf_size = row_bytes;

#ifdef PNG_MAX_MALLOC_64K
   if ((png_uint_32)png_ptr->rowbytes + 1 > (png_uint_32)65536L)
      png_error(png_ptr, "This image requires a row greater than 64KB");
#endif
   png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)(
      png_ptr->rowbytes + 1));

   png_memset_check(png_ptr, png_ptr->prev_row, 0, png_ptr->rowbytes + 1);

   png_debug1(3, "width = %lu,\n", png_ptr->width);
   png_debug1(3, "height = %lu,\n", png_ptr->height);
   png_debug1(3, "iwidth = %lu,\n", png_ptr->iwidth);
   png_debug1(3, "num_rows = %lu\n", png_ptr->num_rows);
   png_debug1(3, "rowbytes = %lu,\n", png_ptr->rowbytes);
   png_debug1(3, "irowbytes = %lu,\n", png_ptr->irowbytes);

   png_ptr->flags |= PNG_FLAG_ROW_INIT;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngset.c ===
/* pngset.c - storage of image information into info struct
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * The functions here are used during reads to store data from the file
 * into the info struct, and during writes to store application data
 * into the info struct for writing into the file.  This abstracts the
 * info struct and allows us to change the structure in the future.
 */

#define PNG_INTERNAL
#include "png.h"

#if defined(PNG_bKGD_SUPPORTED)
void PNGAPI
png_set_bKGD(png_structp png_ptr, png_infop info_ptr, png_color_16p background)
{
   png_debug1(1, "in %s storage function\n", "bKGD");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_memcpy(&(info_ptr->background), background, sizeof(png_color_16));
   info_ptr->valid |= PNG_INFO_bKGD;
}
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_cHRM(png_structp png_ptr, png_infop info_ptr,
   double white_x, double white_y, double red_x, double red_y,
   double green_x, double green_y, double blue_x, double blue_y)
{
   png_debug1(1, "in %s storage function\n", "cHRM");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_white = (float)white_x;
   info_ptr->y_white = (float)white_y;
   info_ptr->x_red   = (float)red_x;
   info_ptr->y_red   = (float)red_y;
   info_ptr->x_green = (float)green_x;
   info_ptr->y_green = (float)green_y;
   info_ptr->x_blue  = (float)blue_x;
   info_ptr->y_blue  = (float)blue_y;
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_x_white = (png_fixed_point)(white_x*100000.+0.5);
   info_ptr->int_y_white = (png_fixed_point)(white_y*100000.+0.5);
   info_ptr->int_x_red   = (png_fixed_point)(red_x*100000.+0.5);
   info_ptr->int_y_red   = (png_fixed_point)(red_y*100000.+0.5);
   info_ptr->int_x_green = (png_fixed_point)(green_x*100000.+0.5);
   info_ptr->int_y_green = (png_fixed_point)(green_y*100000.+0.5);
   info_ptr->int_x_blue  = (png_fixed_point)(blue_x*100000.+0.5);
   info_ptr->int_y_blue  = (png_fixed_point)(blue_y*100000.+0.5);
#endif
   info_ptr->valid |= PNG_INFO_cHRM;
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_cHRM_fixed(png_structp png_ptr, png_infop info_ptr,
   png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
   png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
   png_fixed_point blue_x, png_fixed_point blue_y)
{
   png_debug1(1, "in %s storage function\n", "cHRM");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->int_x_white = white_x;
   info_ptr->int_y_white = white_y;
   info_ptr->int_x_red   = red_x;
   info_ptr->int_y_red   = red_y;
   info_ptr->int_x_green = green_x;
   info_ptr->int_y_green = green_y;
   info_ptr->int_x_blue  = blue_x;
   info_ptr->int_y_blue  = blue_y;
#ifdef PNG_FLOATING_POINT_SUPPORTED
   info_ptr->x_white = (float)(white_x/100000.);
   info_ptr->y_white = (float)(white_y/100000.);
   info_ptr->x_red   = (float)(red_x/100000.);
   info_ptr->y_red   = (float)(red_y/100000.);
   info_ptr->x_green = (float)(green_x/100000.);
   info_ptr->y_green = (float)(green_y/100000.);
   info_ptr->x_blue  = (float)(blue_x/100000.);
   info_ptr->y_blue  = (float)(blue_y/100000.);
#endif
   info_ptr->valid |= PNG_INFO_cHRM;
}
#endif
#endif

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_gAMA(png_structp png_ptr, png_infop info_ptr, double file_gamma)
{
   png_debug1(1, "in %s storage function\n", "gAMA");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->gamma = (float)file_gamma;
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_gamma = (int)(file_gamma*100000.+.5);
#endif
   info_ptr->valid |= PNG_INFO_gAMA;
   if(file_gamma == 0.0)
      png_warning(png_ptr, "Setting gamma=0");
}
#endif
void PNGAPI
png_set_gAMA_fixed(png_structp png_ptr, png_infop info_ptr, png_fixed_point
   int_gamma)
{
   png_debug1(1, "in %s storage function\n", "gAMA");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

#ifdef PNG_FLOATING_POINT_SUPPORTED
   info_ptr->gamma = (float)(int_gamma/100000.);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   info_ptr->int_gamma = int_gamma;
#endif
   info_ptr->valid |= PNG_INFO_gAMA;
   if(int_gamma == 0)
      png_warning(png_ptr, "Setting gamma=0");
}
#endif

#if defined(PNG_hIST_SUPPORTED)
void PNGAPI
png_set_hIST(png_structp png_ptr, png_infop info_ptr, png_uint_16p hist)
{
   int	i;

   png_debug1(1, "in %s storage function\n", "hIST");
   if (png_ptr == NULL || info_ptr == NULL)
      return;
   if (info_ptr->num_palette == 0)
   {
       png_warning(png_ptr,
          "Palette size 0, hIST allocation skipped.");
       return;
   }

#ifdef PNG_FREE_ME_SUPPORTED
   png_free_data(png_ptr, info_ptr, PNG_FREE_HIST, 0);
#endif
   png_ptr->hist = (png_uint_16p)png_malloc(png_ptr,
      (png_uint_32)(info_ptr->num_palette * sizeof (png_uint_16)));

   for (i = 0; i < info_ptr->num_palette; i++)
       png_ptr->hist[i] = hist[i];
   info_ptr->hist = png_ptr->hist;
   info_ptr->valid |= PNG_INFO_hIST;

#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_HIST;
#else
   png_ptr->flags |= PNG_FLAG_FREE_HIST;
#endif
}
#endif

void PNGAPI
png_set_IHDR(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 width, png_uint_32 height, int bit_depth,
   int color_type, int interlace_type, int compression_type,
   int filter_type)
{
   int rowbytes_per_pixel;
   png_debug1(1, "in %s storage function\n", "IHDR");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /* check for width and height valid values */
   if (width == 0 || height == 0)
      png_error(png_ptr, "Image width or height is zero in IHDR");
   if (width > PNG_MAX_UINT || height > PNG_MAX_UINT)
      png_error(png_ptr, "Invalid image size in IHDR");

   /* check other values */
   if (bit_depth != 1 && bit_depth != 2 && bit_depth != 4 &&
      bit_depth != 8 && bit_depth != 16)
      png_error(png_ptr, "Invalid bit depth in IHDR");

   if (color_type < 0 || color_type == 1 ||
      color_type == 5 || color_type > 6)
      png_error(png_ptr, "Invalid color type in IHDR");

   if (((color_type == PNG_COLOR_TYPE_PALETTE) && bit_depth > 8) ||
       ((color_type == PNG_COLOR_TYPE_RGB ||
         color_type == PNG_COLOR_TYPE_GRAY_ALPHA ||
         color_type == PNG_COLOR_TYPE_RGB_ALPHA) && bit_depth < 8))
      png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");

   if (interlace_type >= PNG_INTERLACE_LAST)
      png_error(png_ptr, "Unknown interlace method in IHDR");

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_error(png_ptr, "Unknown compression method in IHDR");

#if defined(PNG_MNG_FEATURES_SUPPORTED)
   /* Accept filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not read a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&png_ptr->mng_features_permitted)
      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream\n");
   if(filter_type != PNG_FILTER_TYPE_BASE)
   {
     if(!((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
        (filter_type == PNG_INTRAPIXEL_DIFFERENCING) &&
        ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
        (color_type == PNG_COLOR_TYPE_RGB || 
         color_type == PNG_COLOR_TYPE_RGB_ALPHA)))
        png_error(png_ptr, "Unknown filter method in IHDR");
     if(png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)
        png_warning(png_ptr, "Invalid filter method in IHDR");
   }
#else
   if(filter_type != PNG_FILTER_TYPE_BASE)
      png_error(png_ptr, "Unknown filter method in IHDR");
#endif

   info_ptr->width = width;
   info_ptr->height = height;
   info_ptr->bit_depth = (png_byte)bit_depth;
   info_ptr->color_type =(png_byte) color_type;
   info_ptr->compression_type = (png_byte)compression_type;
   info_ptr->filter_type = (png_byte)filter_type;
   info_ptr->interlace_type = (png_byte)interlace_type;
   if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      info_ptr->channels = 1;
   else if (info_ptr->color_type & PNG_COLOR_MASK_COLOR)
      info_ptr->channels = 3;
   else
      info_ptr->channels = 1;
   if (info_ptr->color_type & PNG_COLOR_MASK_ALPHA)
      info_ptr->channels++;
   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);

   /* check for overflow */
   rowbytes_per_pixel = (info_ptr->pixel_depth + 7) >> 3;
   if (( width > PNG_MAX_UINT/rowbytes_per_pixel))
   {
      png_warning(png_ptr,
         "Width too large to process image data; rowbytes will overflow.");
      info_ptr->rowbytes = (png_size_t)0;
   }
   else
      info_ptr->rowbytes = (info_ptr->width * info_ptr->pixel_depth + 7) >> 3;
}

#if defined(PNG_oFFs_SUPPORTED)
void PNGAPI
png_set_oFFs(png_structp png_ptr, png_infop info_ptr,
   png_int_32 offset_x, png_int_32 offset_y, int unit_type)
{
   png_debug1(1, "in %s storage function\n", "oFFs");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_offset = offset_x;
   info_ptr->y_offset = offset_y;
   info_ptr->offset_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_oFFs;
}
#endif

#if defined(PNG_pCAL_SUPPORTED)
void PNGAPI
png_set_pCAL(png_structp png_ptr, png_infop info_ptr,
   png_charp purpose, png_int_32 X0, png_int_32 X1, int type, int nparams,
   png_charp units, png_charpp params)
{
   png_uint_32 length;
   int i;

   png_debug1(1, "in %s storage function\n", "pCAL");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   length = png_strlen(purpose) + 1;
   png_debug1(3, "allocating purpose for info (%lu bytes)\n", length);
   info_ptr->pcal_purpose = (png_charp)png_malloc(png_ptr, length);
   png_memcpy(info_ptr->pcal_purpose, purpose, (png_size_t)length);

   png_debug(3, "storing X0, X1, type, and nparams in info\n");
   info_ptr->pcal_X0 = X0;
   info_ptr->pcal_X1 = X1;
   info_ptr->pcal_type = (png_byte)type;
   info_ptr->pcal_nparams = (png_byte)nparams;

   length = png_strlen(units) + 1;
   png_debug1(3, "allocating units for info (%lu bytes)\n", length);
   info_ptr->pcal_units = (png_charp)png_malloc(png_ptr, length);
   png_memcpy(info_ptr->pcal_units, units, (png_size_t)length);

   info_ptr->pcal_params = (png_charpp)png_malloc(png_ptr,
      (png_uint_32)((nparams + 1) * sizeof(png_charp)));

   info_ptr->pcal_params[nparams] = NULL;

   for (i = 0; i < nparams; i++)
   {
      length = png_strlen(params[i]) + 1;
      png_debug2(3, "allocating parameter %d for info (%lu bytes)\n", i, length);
      info_ptr->pcal_params[i] = (png_charp)png_malloc(png_ptr, length);
      png_memcpy(info_ptr->pcal_params[i], params[i], (png_size_t)length);
   }

   info_ptr->valid |= PNG_INFO_pCAL;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PCAL;
#endif
}
#endif

#if defined(PNG_READ_sCAL_SUPPORTED) || defined(PNG_WRITE_sCAL_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
void PNGAPI
png_set_sCAL(png_structp png_ptr, png_infop info_ptr,
             int unit, double width, double height)
{
   png_debug1(1, "in %s storage function\n", "sCAL");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->scal_unit = (png_byte)unit;
   info_ptr->scal_pixel_width = width;
   info_ptr->scal_pixel_height = height;

   info_ptr->valid |= PNG_INFO_sCAL;
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
void PNGAPI
png_set_sCAL_s(png_structp png_ptr, png_infop info_ptr,
             int unit, png_charp swidth, png_charp sheight)
{
   png_uint_32 length;

   png_debug1(1, "in %s storage function\n", "sCAL");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->scal_unit = (png_byte)unit;

   length = png_strlen(swidth) + 1;
   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
   info_ptr->scal_s_width = (png_charp)png_malloc(png_ptr, length);
   png_memcpy(info_ptr->scal_s_width, swidth, (png_size_t)length);

   length = png_strlen(sheight) + 1;
   png_debug1(3, "allocating unit for info (%d bytes)\n", length);
   info_ptr->scal_s_height = (png_charp)png_malloc(png_ptr, length);
   png_memcpy(info_ptr->scal_s_height, sheight, (png_size_t)length);

   info_ptr->valid |= PNG_INFO_sCAL;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_SCAL;
#endif
}
#endif
#endif
#endif

#if defined(PNG_pHYs_SUPPORTED)
void PNGAPI
png_set_pHYs(png_structp png_ptr, png_infop info_ptr,
   png_uint_32 res_x, png_uint_32 res_y, int unit_type)
{
   png_debug1(1, "in %s storage function\n", "pHYs");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->x_pixels_per_unit = res_x;
   info_ptr->y_pixels_per_unit = res_y;
   info_ptr->phys_unit_type = (png_byte)unit_type;
   info_ptr->valid |= PNG_INFO_pHYs;
}
#endif

void PNGAPI
png_set_PLTE(png_structp png_ptr, png_infop info_ptr,
   png_colorp palette, int num_palette)
{

   png_debug1(1, "in %s storage function\n", "PLTE");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   /*
    * It may not actually be necessary to set png_ptr->palette here;
    * we do it for backward compatibility with the way the png_handle_tRNS
    * function used to do the allocation.
    */
#ifdef PNG_FREE_ME_SUPPORTED
   png_free_data(png_ptr, info_ptr, PNG_FREE_PLTE, 0);
#endif
   png_ptr->palette = (png_colorp)png_zalloc(png_ptr, (uInt)num_palette,
      sizeof (png_color));
   png_memcpy(png_ptr->palette, palette, num_palette * sizeof (png_color));
   info_ptr->palette = png_ptr->palette;
   info_ptr->num_palette = png_ptr->num_palette = (png_uint_16)num_palette;

#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_PLTE;
#else
   png_ptr->flags |= PNG_FLAG_FREE_PLTE;
#endif

   info_ptr->valid |= PNG_INFO_PLTE;
}

#if defined(PNG_sBIT_SUPPORTED)
void PNGAPI
png_set_sBIT(png_structp png_ptr, png_infop info_ptr,
   png_color_8p sig_bit)
{
   png_debug1(1, "in %s storage function\n", "sBIT");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_memcpy(&(info_ptr->sig_bit), sig_bit, sizeof (png_color_8));
   info_ptr->valid |= PNG_INFO_sBIT;
}
#endif

#if defined(PNG_sRGB_SUPPORTED)
void PNGAPI
png_set_sRGB(png_structp png_ptr, png_infop info_ptr, int intent)
{
   png_debug1(1, "in %s storage function\n", "sRGB");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   info_ptr->srgb_intent = (png_byte)intent;
   info_ptr->valid |= PNG_INFO_sRGB;
}

void PNGAPI
png_set_sRGB_gAMA_and_cHRM(png_structp png_ptr, png_infop info_ptr,
   int intent)
{
#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float file_gamma;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_fixed_point int_file_gamma;
#endif
#endif
#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
   float white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y;
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   png_fixed_point int_white_x, int_white_y, int_red_x, int_red_y, int_green_x,
      int_green_y, int_blue_x, int_blue_y;
#endif
#endif
   png_debug1(1, "in %s storage function\n", "sRGB_gAMA_and_cHRM");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   png_set_sRGB(png_ptr, info_ptr, intent);

#if defined(PNG_gAMA_SUPPORTED)
#ifdef PNG_FLOATING_POINT_SUPPORTED
   file_gamma = (float).45455;
   png_set_gAMA(png_ptr, info_ptr, file_gamma);
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
   int_file_gamma = 45455L;
   png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
#endif
#endif

#if defined(PNG_cHRM_SUPPORTED)
#ifdef PNG_FIXED_POINT_SUPPORTED
   int_white_x = 31270L;
   int_white_y = 32900L;
   int_red_x   = 64000L;
   int_red_y   = 33000L;
   int_green_x = 30000L;
   int_green_y = 60000L;
   int_blue_x  = 15000L;
   int_blue_y  =  6000L;

   png_set_cHRM_fixed(png_ptr, info_ptr,
      int_white_x, int_white_y, int_red_x, int_red_y, int_green_x, int_green_y,
      int_blue_x, int_blue_y);
#endif
#ifdef PNG_FLOATING_POINT_SUPPORTED
   white_x = (float).3127;
   white_y = (float).3290;
   red_x   = (float).64;
   red_y   = (float).33;
   green_x = (float).30;
   green_y = (float).60;
   blue_x  = (float).15;
   blue_y  = (float).06;

   png_set_cHRM(png_ptr, info_ptr,
      white_x, white_y, red_x, red_y, green_x, green_y, blue_x, blue_y);
#endif
#endif
}
#endif


#if defined(PNG_iCCP_SUPPORTED)
void PNGAPI
png_set_iCCP(png_structp png_ptr, png_infop info_ptr,
             png_charp name, int compression_type,
             png_charp profile, png_uint_32 proflen)
{
   png_charp new_iccp_name;
   png_charp new_iccp_profile;

   png_debug1(1, "in %s storage function\n", "iCCP");
   if (png_ptr == NULL || info_ptr == NULL || name == NULL || profile == NULL)
      return;

   new_iccp_name = (png_charp)png_malloc(png_ptr, png_strlen(name)+1);
   png_strcpy(new_iccp_name, name);
   new_iccp_profile = (png_charp)png_malloc(png_ptr, proflen);
   png_memcpy(new_iccp_profile, profile, (png_size_t)proflen);

   png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, 0);

   info_ptr->iccp_proflen = proflen;
   info_ptr->iccp_name = new_iccp_name;
   info_ptr->iccp_profile = new_iccp_profile;
   /* Compression is always zero but is here so the API and info structure
    * does not have to change if we introduce multiple compression types */
   info_ptr->iccp_compression = (png_byte)compression_type;
#ifdef PNG_FREE_ME_SUPPORTED
   info_ptr->free_me |= PNG_FREE_ICCP;
#endif
   info_ptr->valid |= PNG_INFO_iCCP;
}
#endif

#if defined(PNG_TEXT_SUPPORTED)
void PNGAPI
png_set_text(png_structp png_ptr, png_infop info_ptr, png_textp text_ptr,
   int num_text)
{
   int i;

   png_debug1(1, "in %s storage function\n", (png_ptr->chunk_name[0] == '\0' ?
      "text" : (png_const_charp)png_ptr->chunk_name));

   if (png_ptr == NULL || info_ptr == NULL || num_text == 0)
      return;

   /* Make sure we have enough space in the "text" array in info_struct
    * to hold all of the incoming text_ptr objects.
    */
   if (info_ptr->num_text + num_text > info_ptr->max_text)
   {
      if (info_ptr->text != NULL)
      {
         png_textp old_text;
         int old_max;

         old_max = info_ptr->max_text;
         info_ptr->max_text = info_ptr->num_text + num_text + 8;
         old_text = info_ptr->text;
         info_ptr->text = (png_textp)png_malloc(png_ptr,
            (png_uint_32)(info_ptr->max_text * sizeof (png_text)));
         png_memcpy(info_ptr->text, old_text, (png_size_t)(old_max *
            sizeof(png_text)));
         png_free(png_ptr, old_text);
      }
      else
      {
         info_ptr->max_text = num_text + 8;
         info_ptr->num_text = 0;
         info_ptr->text = (png_textp)png_malloc(png_ptr,
            (png_uint_32)(info_ptr->max_text * sizeof (png_text)));
#ifdef PNG_FREE_ME_SUPPORTED
         info_ptr->free_me |= PNG_FREE_TEXT;
#endif
      }
      png_debug1(3, "allocated %d entries for info_ptr->text\n",
         info_ptr->max_text);
   }
   for (i = 0; i < num_text; i++)
   {
      png_size_t text_length,key_len;
      png_size_t lang_len,lang_key_len;
      png_textp textp = &(info_ptr->text[info_ptr->num_text]);

      if (text_ptr[i].key == NULL)
          continue;

      key_len = png_strlen(text_ptr[i].key);

      if(text_ptr[i].compression <= 0)
      {
        lang_len = 0;
        lang_key_len = 0;
      }
      else
#ifdef PNG_iTXt_SUPPORTED
      {
        /* set iTXt data */
        if (text_ptr[i].key != NULL)
          lang_len = png_strlen(text_ptr[i].lang);
        else
          lang_len = 0;
        if (text_ptr[i].lang_key != NULL)
          lang_key_len = png_strlen(text_ptr[i].lang_key);
        else
          lang_key_len = 0;
      }
#else
      {
        png_warning(png_ptr, "iTXt chunk not supported.");
        continue;
      }
#endif

      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
      {
         text_length = 0;
#ifdef PNG_iTXt_SUPPORTED
         if(text_ptr[i].compression > 0)
            textp->compression = PNG_ITXT_COMPRESSION_NONE;
         else
#endif
            textp->compression = PNG_TEXT_COMPRESSION_NONE;
      }
      else
      {
         text_length = png_strlen(text_ptr[i].text);
         textp->compression = text_ptr[i].compression;
      }

      textp->key = (png_charp)png_malloc(png_ptr,
         (png_uint_32)(key_len + text_length + lang_len + lang_key_len + 4));
      png_debug2(2, "Allocated %d bytes at %x in png_set_text\n",
         key_len + lang_len + lang_key_len + text_length + 4, (int)textp->key);

      png_memcpy(textp->key, text_ptr[i].key,
         (png_size_t)(key_len));
      *(textp->key+key_len) = '\0';
#ifdef PNG_iTXt_SUPPORTED
      if (text_ptr[i].compression > 0)
      {
         textp->lang=textp->key + key_len + 1;
         png_memcpy(textp->lang, text_ptr[i].lang, lang_len);
         *(textp->lang+lang_len) = '\0';
         textp->lang_key=textp->lang + lang_len + 1;
         png_memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
         *(textp->lang_key+lang_key_len) = '\0';
         textp->text=textp->lang_key + lang_key_len + 1;
      }
      else
#endif
      {
#ifdef PNG_iTXt_SUPPORTED
         textp->lang=(png_charp)NULL;
         textp->lang_key=(png_charp)NULL;
#endif
         textp->text=textp->key + key_len + 1;
      }
      if(text_length)
         png_memcpy(textp->text, text_ptr[i].text,
            (png_size_t)(text_length));
      *(textp->text+text_length) = '\0';

#ifdef PNG_iTXt_SUPPORTED
      if(textp->compression > 0)
      {
         textp->text_length = 0;
         textp->itxt_length = text_length;
      }
      else
#endif
      {
         textp->text_length = text_length;
#ifdef PNG_iTXt_SUPPORTED
         textp->itxt_length = 0;
#endif
      }
      info_ptr->text[info_ptr->num_text]= *textp;
      info_ptr->num_text++;
      png_debug1(3, "transferred text chunk %d\n", info_ptr->num_text);
   }
}
#endif

#if defined(PNG_tIME_SUPPORTED)
void PNGAPI
png_set_tIME(png_structp png_ptr, png_infop info_ptr, png_timep mod_time)
{
   png_debug1(1, "in %s storage function\n", "tIME");
   if (png_ptr == NULL || info_ptr == NULL ||
       (png_ptr->mode & PNG_WROTE_tIME))
      return;

   png_memcpy(&(info_ptr->mod_time), mod_time, sizeof (png_time));
   info_ptr->valid |= PNG_INFO_tIME;
}
#endif

#if defined(PNG_tRNS_SUPPORTED)
void PNGAPI
png_set_tRNS(png_structp png_ptr, png_infop info_ptr,
   png_bytep trans, int num_trans, png_color_16p trans_values)
{
   png_debug1(1, "in %s storage function\n", "tRNS");
   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if (trans != NULL)
   {
       /*
	* It may not actually be necessary to set png_ptr->trans here;
	* we do it for backward compatibility with the way the png_handle_tRNS
	* function used to do the allocation.
	*/
#ifdef PNG_FREE_ME_SUPPORTED
       png_free_data(png_ptr, info_ptr, PNG_FREE_TRNS, 0);
#endif
       png_ptr->trans = info_ptr->trans = (png_bytep)png_malloc(png_ptr,
           num_trans);
       png_memcpy(info_ptr->trans, trans, num_trans);
#ifdef PNG_FREE_ME_SUPPORTED
       info_ptr->free_me |= PNG_FREE_TRNS;
#else
       png_ptr->flags |= PNG_FLAG_FREE_TRNS;
#endif
   }

   if (trans_values != NULL)
   {
      png_memcpy(&(info_ptr->trans_values), trans_values,
         sizeof(png_color_16));
      if (num_trans == 0)
        num_trans = 1;
   }
   info_ptr->num_trans = (png_uint_16)num_trans;
   info_ptr->valid |= PNG_INFO_tRNS;
}
#endif

#if defined(PNG_sPLT_SUPPORTED)
void PNGAPI
png_set_sPLT(png_structp png_ptr,
             png_infop info_ptr, png_sPLT_tp entries, int nentries)
{
    png_sPLT_tp np;
    int i;

    np = (png_sPLT_tp)png_malloc(png_ptr,
        (info_ptr->splt_palettes_num + nentries) * sizeof(png_sPLT_t));

    png_memcpy(np, info_ptr->splt_palettes,
           info_ptr->splt_palettes_num * sizeof(png_sPLT_t));
    png_free(png_ptr, info_ptr->splt_palettes);
    info_ptr->splt_palettes=NULL;

    for (i = 0; i < nentries; i++)
    {
        png_sPLT_tp to = np + info_ptr->splt_palettes_num + i;
        png_sPLT_tp from = entries + i;

        to->name = (png_charp)png_malloc(png_ptr,
            png_strlen(from->name) + 1);
        png_strcpy(to->name, from->name);
        to->entries = (png_sPLT_entryp)png_malloc(png_ptr,
            from->nentries * sizeof(png_sPLT_t));
        png_memcpy(to->entries, from->entries,
            from->nentries * sizeof(png_sPLT_t));
        to->nentries = from->nentries;
        to->depth = from->depth;
    }

    info_ptr->splt_palettes = np;
    info_ptr->splt_palettes_num += nentries;
    info_ptr->valid |= PNG_INFO_sPLT;
#ifdef PNG_FREE_ME_SUPPORTED
    info_ptr->free_me |= PNG_FREE_SPLT;
#endif
}
#endif /* PNG_sPLT_SUPPORTED */

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
void PNGAPI
png_set_unknown_chunks(png_structp png_ptr,
   png_infop info_ptr, png_unknown_chunkp unknowns, int num_unknowns)
{
    png_unknown_chunkp np;
    int i;

    if (png_ptr == NULL || info_ptr == NULL || num_unknowns == 0)
        return;

    np = (png_unknown_chunkp)png_malloc(png_ptr,
        (info_ptr->unknown_chunks_num + num_unknowns) *
        sizeof(png_unknown_chunk));

    png_memcpy(np, info_ptr->unknown_chunks,
           info_ptr->unknown_chunks_num * sizeof(png_unknown_chunk));
    png_free(png_ptr, info_ptr->unknown_chunks);
    info_ptr->unknown_chunks=NULL;

    for (i = 0; i < num_unknowns; i++)
    {
        png_unknown_chunkp to = np + info_ptr->unknown_chunks_num + i;
        png_unknown_chunkp from = unknowns + i;

        png_strcpy((png_charp)to->name, (png_charp)from->name);
        to->data = (png_bytep)png_malloc(png_ptr, from->size);
        png_memcpy(to->data, from->data, from->size);
        to->size = from->size;

        /* note our location in the read or write sequence */
        to->location = (png_byte)(png_ptr->mode & 0xff);
    }

    info_ptr->unknown_chunks = np;
    info_ptr->unknown_chunks_num += num_unknowns;
#ifdef PNG_FREE_ME_SUPPORTED
    info_ptr->free_me |= PNG_FREE_UNKN;
#endif
}
void PNGAPI
png_set_unknown_chunk_location(png_structp png_ptr, png_infop info_ptr,
   int chunk, int location)
{
   if(png_ptr != NULL && info_ptr != NULL && chunk >= 0 && chunk <
         (int)info_ptr->unknown_chunks_num)
      info_ptr->unknown_chunks[chunk].location = (png_byte)location;
}
#endif

#if defined(PNG_READ_EMPTY_PLTE_SUPPORTED) || \
    defined(PNG_WRITE_EMPTY_PLTE_SUPPORTED)
void PNGAPI
png_permit_empty_plte (png_structp png_ptr, int empty_plte_permitted)
{
   /* This function is deprecated in favor of png_permit_mng_features()
      and will be removed from libpng-2.0.0 */
   png_debug(1, "in png_permit_empty_plte, DEPRECATED.\n");
   if (png_ptr == NULL)
      return;
   png_ptr->mng_features_permitted = (png_byte)
     ((png_ptr->mng_features_permitted & (~(PNG_FLAG_MNG_EMPTY_PLTE))) |
     ((empty_plte_permitted & PNG_FLAG_MNG_EMPTY_PLTE)));
}
#endif

#if defined(PNG_MNG_FEATURES_SUPPORTED)
png_uint_32 PNGAPI
png_permit_mng_features (png_structp png_ptr, png_uint_32 mng_features)
{
   png_debug(1, "in png_permit_mng_features\n");
   if (png_ptr == NULL)
      return (png_uint_32)0;
   png_ptr->mng_features_permitted =
     (png_byte)(mng_features & PNG_ALL_MNG_FEATURES);
   return (png_uint_32)png_ptr->mng_features_permitted;
}
#endif

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
void PNGAPI
png_set_keep_unknown_chunks(png_structp png_ptr, int keep, png_bytep
   chunk_list, int num_chunks)
{
    png_bytep new_list, p;
    int i, old_num_chunks;
    if (num_chunks == 0)
    {
      if(keep == HANDLE_CHUNK_ALWAYS || keep == HANDLE_CHUNK_IF_SAFE)
        png_ptr->flags |= PNG_FLAG_KEEP_UNKNOWN_CHUNKS;
      else
        png_ptr->flags &= ~PNG_FLAG_KEEP_UNKNOWN_CHUNKS;

      if(keep == HANDLE_CHUNK_ALWAYS)
        png_ptr->flags |= PNG_FLAG_KEEP_UNSAFE_CHUNKS;
      else
        png_ptr->flags &= ~PNG_FLAG_KEEP_UNSAFE_CHUNKS;
      return;
    }
    if (chunk_list == NULL)
      return;
    old_num_chunks=png_ptr->num_chunk_list;
    new_list=(png_bytep)png_malloc(png_ptr,5*(num_chunks+old_num_chunks));
    if(png_ptr->chunk_list != NULL)
    {
       png_memcpy(new_list, png_ptr->chunk_list, 5*old_num_chunks);
       png_free(png_ptr, png_ptr->chunk_list);
       png_ptr->chunk_list=NULL;
    }
    png_memcpy(new_list+5*old_num_chunks, chunk_list, 5*num_chunks);
    for (p=new_list+5*old_num_chunks+4, i=0; i<num_chunks; i++, p+=5)
       *p=(png_byte)keep;
    png_ptr->num_chunk_list=old_num_chunks+num_chunks;
    png_ptr->chunk_list=new_list;
#ifdef PNG_FREE_ME_SUPPORTED
    png_ptr->free_me |= PNG_FREE_LIST;
#endif
}
#endif

#if defined(PNG_READ_USER_CHUNKS_SUPPORTED)
void PNGAPI
png_set_read_user_chunk_fn(png_structp png_ptr, png_voidp user_chunk_ptr,
   png_user_chunk_ptr read_user_chunk_fn)
{
   png_debug(1, "in png_set_read_user_chunk_fn\n");
   png_ptr->read_user_chunk_fn = read_user_chunk_fn;
   png_ptr->user_chunk_ptr = user_chunk_ptr;
}
#endif

#if defined(PNG_INFO_IMAGE_SUPPORTED)
void PNGAPI
png_set_rows(png_structp png_ptr, png_infop info_ptr, png_bytepp row_pointers)
{
   png_debug1(1, "in %s storage function\n", "rows");

   if (png_ptr == NULL || info_ptr == NULL)
      return;

   if(info_ptr->row_pointers && (info_ptr->row_pointers != row_pointers))
      png_free_data(png_ptr, info_ptr, PNG_FREE_ROWS, 0);
   info_ptr->row_pointers = row_pointers;
   if(row_pointers)
      info_ptr->valid |= PNG_INFO_IDAT;
}
#endif

void PNGAPI
png_set_compression_buffer_size(png_structp png_ptr, png_uint_32 size)
{
    if(png_ptr->zbuf)
       png_free(png_ptr, png_ptr->zbuf);
    png_ptr->zbuf_size = (png_size_t)size;
    png_ptr->zbuf = (png_bytep)png_malloc(png_ptr, size);
    png_ptr->zstream.next_out = png_ptr->zbuf;
    png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
}

void PNGAPI
png_set_invalid(png_structp png_ptr, png_infop info_ptr, int mask)
{
   if (png_ptr && info_ptr)
      info_ptr->valid &= ~(mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngrio.c ===
/* pngrio.c - functions for data input
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all input.  Users who need
 * special handling are expected to write a function that has the same
 * arguments as this and performs a similar function, but that possibly
 * has a different input method.  Note that you shouldn't change this
 * function, but rather write a replacement function and then make
 * libpng use it at run time with png_set_read_fn(...).
 */

#define PNG_INTERNAL
#include "png.h"

/* Read the data from whatever input you are using.  The default routine
   reads from a file pointer.  Note that this routine sometimes gets called
   with very small lengths, so you should implement some kind of simple
   buffering if you are using unbuffered reads.  This should never be asked
   to read more then 64K on a 16 bit machine. */
void /* PRIVATE */
png_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_debug1(4,"reading %d bytes\n", length);
   if (png_ptr->read_data_fn != NULL)
      (*(png_ptr->read_data_fn))(png_ptr, data, length);
   else
      png_error(png_ptr, "Call to NULL read function");
}

#if !defined(PNG_NO_STDIO)
/* This is the function that does the actual reading of data.  If you are
   not reading from a standard C stream, you should create a replacement
   read_data function and use it at run time with png_set_read_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void /* PRIVATE */
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_size_t check;

   /* fread() returns 0 on error, so it is OK to store this in a png_size_t
    * instead of an int, which is what fread() actually returns.
    */
#if defined(_WIN32_WCE)
   if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
      check = 0;
#else
   check = (png_size_t)fread(data, (png_size_t)1, length,
      (png_FILE_p)png_ptr->io_ptr);
#endif

   if (check != length)
      png_error(png_ptr, "Read Error");
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void /* PRIVATE */
png_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   int check;
   png_byte *n_data;
   png_FILE_p io_ptr;

   /* Check if data really is near. If so, use usual code. */
   n_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)n_data == data)
   {
#if defined(_WIN32_WCE)
      if ( !ReadFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
         check = 0;
#else
      check = fread(n_data, 1, length, io_ptr);
#endif
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t read, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         read = MIN(NEAR_BUF_SIZE, remaining);
#if defined(_WIN32_WCE)
         if ( !ReadFile((HANDLE)(io_ptr), buf, read, &err, NULL) )
            err = 0;
#else
         err = fread(buf, (png_size_t)1, read, io_ptr);
#endif
         png_memcpy(data, buf, read); /* copy far buffer to near buffer */
         if(err != read)
            break;
         else
            check += err;
         data += read;
         remaining -= read;
      }
      while (remaining != 0);
   }
   if ((png_uint_32)check != (png_uint_32)length)
      png_error(png_ptr, "read Error");
}
#endif
#endif

/* This function allows the application to supply a new input function
   for libpng if standard C streams aren't being used.

   This function takes as its arguments:
   png_ptr      - pointer to a png input data structure
   io_ptr       - pointer to user supplied structure containing info about
                  the input functions.  May be NULL.
   read_data_fn - pointer to a new input function that takes as its
                  arguments a pointer to a png_struct, a pointer to
                  a location where input data can be stored, and a 32-bit
                  unsigned int that is the number of bytes to be read.
                  To exit and output any fatal error messages the new write
                  function should call png_error(png_ptr, "Error msg"). */
void PNGAPI
png_set_read_fn(png_structp png_ptr, png_voidp io_ptr,
   png_rw_ptr read_data_fn)
{
   png_ptr->io_ptr = io_ptr;

#if !defined(PNG_NO_STDIO)
   if (read_data_fn != NULL)
      png_ptr->read_data_fn = read_data_fn;
   else
      png_ptr->read_data_fn = png_default_read_data;
#else
   png_ptr->read_data_fn = read_data_fn;
#endif

   /* It is an error to write to a read device */
   if (png_ptr->write_data_fn != NULL)
   {
      png_ptr->write_data_fn = NULL;
      png_warning(png_ptr,
         "It's an error to set both read_data_fn and write_data_fn in the ");
      png_warning(png_ptr,
         "same structure.  Resetting write_data_fn to NULL.");
   }

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
   png_ptr->output_flush_fn = NULL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngtrans.c ===
/* pngtrans.c - transforms the data in a row (used by both readers and writers)
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* turn on BGR-to-RGB mapping */
void PNGAPI
png_set_bgr(png_structp png_ptr)
{
   png_debug(1, "in png_set_bgr\n");
   png_ptr->transformations |= PNG_BGR;
}
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* turn on 16 bit byte swapping */
void PNGAPI
png_set_swap(png_structp png_ptr)
{
   png_debug(1, "in png_set_swap\n");
   if (png_ptr->bit_depth == 16)
      png_ptr->transformations |= PNG_SWAP_BYTES;
}
#endif

#if defined(PNG_READ_PACK_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
/* turn on pixel packing */
void PNGAPI
png_set_packing(png_structp png_ptr)
{
   png_debug(1, "in png_set_packing\n");
   if (png_ptr->bit_depth < 8)
   {
      png_ptr->transformations |= PNG_PACK;
      png_ptr->usr_bit_depth = 8;
   }
}
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
/* turn on packed pixel swapping */
void PNGAPI
png_set_packswap(png_structp png_ptr)
{
   png_debug(1, "in png_set_packswap\n");
   if (png_ptr->bit_depth < 8)
      png_ptr->transformations |= PNG_PACKSWAP;
}
#endif

#if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
void PNGAPI
png_set_shift(png_structp png_ptr, png_color_8p true_bits)
{
   png_debug(1, "in png_set_shift\n");
   png_ptr->transformations |= PNG_SHIFT;
   png_ptr->shift = *true_bits;
}
#endif

#if defined(PNG_READ_INTERLACING_SUPPORTED) || \
    defined(PNG_WRITE_INTERLACING_SUPPORTED)
int PNGAPI
png_set_interlace_handling(png_structp png_ptr)
{
   png_debug(1, "in png_set_interlace handling\n");
   if (png_ptr->interlaced)
   {
      png_ptr->transformations |= PNG_INTERLACE;
      return (7);
   }

   return (1);
}
#endif

#if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
/* Add a filler byte on read, or remove a filler or alpha byte on write.
 * The filler type has changed in v0.95 to allow future 2-byte fillers
 * for 48-bit input data, as well as to avoid problems with some compilers
 * that don't like bytes as parameters.
 */
void PNGAPI
png_set_filler(png_structp png_ptr, png_uint_32 filler, int filler_loc)
{
   png_debug(1, "in png_set_filler\n");
   png_ptr->transformations |= PNG_FILLER;
   png_ptr->filler = (png_byte)filler;
   if (filler_loc == PNG_FILLER_AFTER)
      png_ptr->flags |= PNG_FLAG_FILLER_AFTER;
   else
      png_ptr->flags &= ~PNG_FLAG_FILLER_AFTER;

   /* This should probably go in the "do_filler" routine.
    * I attempted to do that in libpng-1.0.1a but that caused problems
    * so I restored it in libpng-1.0.2a
   */

   if (png_ptr->color_type == PNG_COLOR_TYPE_RGB)
   {
      png_ptr->usr_channels = 4;
   }

   /* Also I added this in libpng-1.0.2a (what happens when we expand
    * a less-than-8-bit grayscale to GA? */

   if (png_ptr->color_type == PNG_COLOR_TYPE_GRAY && png_ptr->bit_depth >= 8)
   {
      png_ptr->usr_channels = 2;
   }
}
#endif

#if defined(PNG_READ_SWAP_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
void PNGAPI
png_set_swap_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_swap_alpha\n");
   png_ptr->transformations |= PNG_SWAP_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_ALPHA_SUPPORTED) || \
    defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
void PNGAPI
png_set_invert_alpha(png_structp png_ptr)
{
   png_debug(1, "in png_set_invert_alpha\n");
   png_ptr->transformations |= PNG_INVERT_ALPHA;
}
#endif

#if defined(PNG_READ_INVERT_SUPPORTED) || defined(PNG_WRITE_INVERT_SUPPORTED)
void PNGAPI
png_set_invert_mono(png_structp png_ptr)
{
   png_debug(1, "in png_set_invert_mono\n");
   png_ptr->transformations |= PNG_INVERT_MONO;
}

/* invert monochrome grayscale data */
void /* PRIVATE */
png_do_invert(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_invert\n");
   if (row_info->bit_depth == 1 &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->color_type == PNG_COLOR_TYPE_GRAY)
   {
      png_bytep rp = row;
      png_uint_32 i;
      png_uint_32 istop = row_info->rowbytes;

      for (i = 0; i < istop; i++)
      {
         *rp = (png_byte)(~(*rp));
         rp++;
      }
   }
}
#endif

#if defined(PNG_READ_SWAP_SUPPORTED) || defined(PNG_WRITE_SWAP_SUPPORTED)
/* swaps byte order on 16 bit depth images */
void /* PRIVATE */
png_do_swap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_swap\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->bit_depth == 16)
   {
      png_bytep rp = row;
      png_uint_32 i;
      png_uint_32 istop= row_info->width * row_info->channels;

      for (i = 0; i < istop; i++, rp += 2)
      {
         png_byte t = *rp;
         *rp = *(rp + 1);
         *(rp + 1) = t;
      }
   }
}
#endif

#if defined(PNG_READ_PACKSWAP_SUPPORTED)||defined(PNG_WRITE_PACKSWAP_SUPPORTED)
static png_byte onebppswaptable[256] = {
   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
};

static png_byte twobppswaptable[256] = {
   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
};

static png_byte fourbppswaptable[256] = {
   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
};

/* swaps pixel packing order within bytes */
void /* PRIVATE */
png_do_packswap(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_packswap\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       row_info->bit_depth < 8)
   {
      png_bytep rp, end, table;

      end = row + row_info->rowbytes;

      if (row_info->bit_depth == 1)
         table = onebppswaptable;
      else if (row_info->bit_depth == 2)
         table = twobppswaptable;
      else if (row_info->bit_depth == 4)
         table = fourbppswaptable;
      else
         return;

      for (rp = row; rp < end; rp++)
         *rp = table[*rp];
   }
}
#endif /* PNG_READ_PACKSWAP_SUPPORTED or PNG_WRITE_PACKSWAP_SUPPORTED */

#if defined(PNG_WRITE_FILLER_SUPPORTED) || \
    defined(PNG_READ_STRIP_ALPHA_SUPPORTED)
/* remove filler or alpha byte(s) */
void /* PRIVATE */
png_do_strip_filler(png_row_infop row_info, png_bytep row, png_uint_32 flags)
{
   png_debug(1, "in png_do_strip_filler\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
/*
      if (row_info->color_type == PNG_COLOR_TYPE_RGB ||
          row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
*/
      png_bytep sp=row;
      png_bytep dp=row;
      png_uint_32 row_width=row_info->width;
      png_uint_32 i;

      if (row_info->channels == 4)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from RGBX or RGBA to RGB */
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               dp+=3; sp+=4;
               for (i = 1; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp++;
               }
            }
            /* This converts from XRGB or ARGB to RGB */
            else
            {
               for (i = 0; i < row_width; i++)
               {
                  sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 24;
            row_info->rowbytes = row_width * 3;
         }
         else /* if (row_info->bit_depth == 16) */
         {
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               /* This converts from RRGGBBXX or RRGGBBAA to RRGGBB */
               sp += 8; dp += 6;
               for (i = 1; i < row_width; i++)
               {
                  /* This could be (although png_memcpy is probably slower):
                  png_memcpy(dp, sp, 6);
                  sp += 8;
                  dp += 6;
                  */

                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp += 2;
               }
            }
            else
            {
               /* This converts from XXRRGGBB or AARRGGBB to RRGGBB */
               for (i = 0; i < row_width; i++)
               {
                  /* This could be (although png_memcpy is probably slower):
                  png_memcpy(dp, sp, 6);
                  sp += 8;
                  dp += 6;
                  */

                  sp+=2;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 48;
            row_info->rowbytes = row_width * 6;
         }
         row_info->channels = 3;
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
      }
/*
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY ||
               row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
*/
      else if (row_info->channels == 2)
      {
         if (row_info->bit_depth == 8)
         {
            /* This converts from GX or GA to G */
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               for (i = 0; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  sp++;
               }
            }
            /* This converts from XG or AG to G */
            else
            {
               for (i = 0; i < row_width; i++)
               {
                  sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 8;
            row_info->rowbytes = row_width;
         }
         else /* if (row_info->bit_depth == 16) */
         {
            if (flags & PNG_FLAG_FILLER_AFTER)
            {
               /* This converts from GGXX or GGAA to GG */
               sp += 4; dp += 2;
               for (i = 1; i < row_width; i++)
               {
                  *dp++ = *sp++;
                  *dp++ = *sp++;
                  sp += 2;
               }
            }
            else
            {
               /* This converts from XXGG or AAGG to GG */
               for (i = 0; i < row_width; i++)
               {
                  sp += 2;
                  *dp++ = *sp++;
                  *dp++ = *sp++;
               }
            }
            row_info->pixel_depth = 16;
            row_info->rowbytes = row_width * 2;
         }
         row_info->channels = 1;
         row_info->color_type &= ~PNG_COLOR_MASK_ALPHA;
      }
   }
}
#endif

#if defined(PNG_READ_BGR_SUPPORTED) || defined(PNG_WRITE_BGR_SUPPORTED)
/* swaps red and blue bytes within a pixel */
void /* PRIVATE */
png_do_bgr(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_bgr\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 3)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 4)
            {
               png_byte save = *rp;
               *rp = *(rp + 2);
               *(rp + 2) = save;
            }
         }
      }
      else if (row_info->bit_depth == 16)
      {
         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 6)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
         {
            png_bytep rp;
            png_uint_32 i;

            for (i = 0, rp = row; i < row_width; i++, rp += 8)
            {
               png_byte save = *rp;
               *rp = *(rp + 4);
               *(rp + 4) = save;
               save = *(rp + 1);
               *(rp + 1) = *(rp + 5);
               *(rp + 5) = save;
            }
         }
      }
   }
}
#endif /* PNG_READ_BGR_SUPPORTED or PNG_WRITE_BGR_SUPPORTED */

#if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED) || \
    defined(PNG_LEGACY_SUPPORTED)
void PNGAPI
png_set_user_transform_info(png_structp png_ptr, png_voidp
   user_transform_ptr, int user_transform_depth, int user_transform_channels)
{
   png_debug(1, "in png_set_user_transform_info\n");
#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   png_ptr->user_transform_ptr = user_transform_ptr;
   png_ptr->user_transform_depth = (png_byte)user_transform_depth;
   png_ptr->user_transform_channels = (png_byte)user_transform_channels;
#else
   if(user_transform_ptr || user_transform_depth || user_transform_channels)
      png_warning(png_ptr,
        "This version of libpng does not support user transform info");
#endif
}
#endif

/* This function returns a pointer to the user_transform_ptr associated with
 * the user transform functions.  The application should free any memory
 * associated with this pointer before png_write_destroy and png_read_destroy
 * are called.
 */
png_voidp PNGAPI
png_get_user_transform_ptr(png_structp png_ptr)
{
#if defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
   return ((png_voidp)png_ptr->user_transform_ptr);
#else
   if(png_ptr)
     return (NULL);
   return (NULL);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngvcrd.c ===
/* pngvcrd.c - mixed C/assembler version of utilities to read a PNG file
 *
 * For Intel x86 CPU and Microsoft Visual C++ compiler
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * Copyright (c) 1998, Intel Corporation
 *
 * Contributed by Nirav Chhatrapati, Intel Corporation, 1998
 * Interface to libpng contributed by Gilles Vollant, 1999
 * Debugging and cleanup by Greg Roelofs, 2000, 2001
 *
 * In png_do_read_interlace() in libpng versions 1.0.3a through 1.0.4d,
 * a sign error in the post-MMX cleanup code for each pixel_depth resulted
 * in bad pixels at the beginning of some rows of some images, and also
 * (due to out-of-range memory reads and writes) caused heap corruption
 * when compiled with MSVC 6.0.  The error was fixed in version 1.0.4e.
 *
 * [png_read_filter_row_mmx_avg() bpp == 2 bugfix, GRR 20000916]
 *
 */

#define PNG_INTERNAL
#include "png.h"

#if defined(PNG_ASSEMBLER_CODE_SUPPORTED) && defined(PNG_USE_PNGVCRD)

static int mmx_supported=2;


int PNGAPI
png_mmx_support(void)
{
  int mmx_supported_local = 0;
  _asm {
    push ebx          //CPUID will trash these
    push ecx
    push edx
    pushfd            //Save Eflag to stack
    pop eax           //Get Eflag from stack into eax
    mov ecx, eax      //Make another copy of Eflag in ecx
    xor eax, 0x200000 //Toggle ID bit in Eflag [i.e. bit(21)]
    push eax          //Save modified Eflag back to stack

    popfd             //Restored modified value back to Eflag reg
    pushfd            //Save Eflag to stack
    pop eax           //Get Eflag from stack
    xor eax, ecx      //Compare the new Eflag with the original Eflag
    jz NOT_SUPPORTED  //If the same, CPUID instruction is not supported,
                      //skip following instructions and jump to
                      //NOT_SUPPORTED label

    xor eax, eax      //Set eax to zero

    _asm _emit 0x0f   //CPUID instruction  (two bytes opcode)
    _asm _emit 0xa2

    cmp eax, 1        //make sure eax return non-zero value
    jl NOT_SUPPORTED  //If eax is zero, mmx not supported

    xor eax, eax      //set eax to zero
    inc eax           //Now increment eax to 1.  This instruction is
                      //faster than the instruction "mov eax, 1"

    _asm _emit 0x0f   //CPUID instruction
    _asm _emit 0xa2

    and edx, 0x00800000  //mask out all bits but mmx bit(24)
    cmp edx, 0        // 0 = mmx not supported
    jz  NOT_SUPPORTED // non-zero = Yes, mmx IS supported

    mov  mmx_supported_local, 1  //set return value to 1

NOT_SUPPORTED:
    mov  eax, mmx_supported_local  //move return value to eax
    pop edx          //CPUID trashed these
    pop ecx
    pop ebx
  }

  //mmx_supported_local=0; // test code for force don't support MMX
  //printf("MMX : %u (1=MMX supported)\n",mmx_supported_local);

  mmx_supported = mmx_supported_local;
  return mmx_supported_local;
}

/* Combines the row recently read in with the previous row.
   This routine takes care of alpha and transparency if requested.
   This routine also handles the two methods of progressive display
   of interlaced images, depending on the mask value.
   The mask value describes which pixels are to be combined with
   the row.  The pattern always repeats every 8 pixels, so just 8
   bits are needed.  A one indicates the pixel is to be combined; a
   zero indicates the pixel is to be skipped.  This is in addition
   to any alpha or transparency value associated with the pixel.  If
   you want all pixels to be combined, pass 0xff (255) in mask.  */

/* Use this routine for x86 platform - uses faster MMX routine if machine
   supports MMX */

void /* PRIVATE */
png_combine_row(png_structp png_ptr, png_bytep row, int mask)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1,"in png_combine_row_asm\n");

   if (mmx_supported == 2) {
       png_mmx_support();
   }

   if (mask == 0xff)
   {
      png_memcpy(row, png_ptr->row_buf + 1,
       (png_size_t)((png_ptr->width * png_ptr->row_info.pixel_depth + 7) >> 3));
   }
   /* GRR:  add "else if (mask == 0)" case?
    *       or does png_combine_row() not even get called in that case? */
   else
   {
      switch (png_ptr->row_info.pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            int s_inc, s_start, s_end;
            int m;
            int shift;
            png_uint_32 i;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
                s_start = 0;
                s_end = 7;
                s_inc = 1;
            }
            else
#endif
            {
                s_start = 7;
                s_end = 0;
                s_inc = -1;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  int value;

                  value = (*sp >> shift) & 0x1;
                  *dp &= (png_byte)((0x7f7f >> (7 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;

               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }
            else
#endif
            {
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }

            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0x3;
                  *dp &= (png_byte)((0x3f3f >> (6 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            int s_start, s_end, s_inc;
            int m;
            int shift;
            png_uint_32 i;
            int value;

            sp = png_ptr->row_buf + 1;
            dp = row;
            m = 0x80;
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (png_ptr->transformations & PNG_PACKSWAP)
            {
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }
            else
#endif
            {
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            shift = s_start;

            for (i = 0; i < png_ptr->width; i++)
            {
               if (m & mask)
               {
                  value = (*sp >> shift) & 0xf;
                  *dp &= (png_byte)((0xf0f >> (4 - shift)) & 0xff);
                  *dp |= (png_byte)(value << shift);
               }

               if (shift == s_end)
               {
                  shift = s_start;
                  sp++;
                  dp++;
               }
               else
                  shift += s_inc;
               if (m == 1)
                  m = 0x80;
               else
                  m >>= 1;
            }
            break;
         }

         case 8:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int m;
            int diff, unmask;

            __int64 mask0=0x0102040810204080;

            if ( mmx_supported )
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;
               m = 0x80;
               unmask = ~mask;
               len  = png_ptr->width &~7;  //reduce to multiple of 8
               diff = png_ptr->width & 7;  //amount lost

               _asm
               {
                  movd       mm7, unmask   //load bit pattern
                  psubb      mm6,mm6       //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7       //fill register with 8 masks

                  movq       mm0,mask0

                  pand       mm0,mm7       //nonzero if keep byte
                  pcmpeqb    mm0,mm6       //zeros->1s, v versa

                  mov        ecx,len       //load length of line (pixels)
                  mov        esi,srcptr    //load source
                  mov        ebx,dstptr    //load dest
                  cmp        ecx,0         //lcr
                  je         mainloop8end

mainloop8:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  pandn      mm6,[ebx]
                  por        mm4,mm6
                  movq       [ebx],mm4

                  add        esi,8         //inc by 8 bytes processed
                  add        ebx,8
                  sub        ecx,8         //dec by 8 pixels processed

                  ja         mainloop8
mainloop8end:

                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end8

                  mov        edx,mask
                  sal        edx,24        //make low byte the high byte

secondloop8:
                  sal        edx,1         //move high bit to CF
                  jnc        skip8         //if CF = 0
                  mov        al,[esi]
                  mov        [ebx],al
skip8:
                  inc        esi
                  inc        ebx

                  dec        ecx
                  jnz        secondloop8
end8:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  if (pixel_bytes > (png_size_t)(final_val-i))
                    pixel_bytes = (png_size_t)(final_val-i);
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 8 bpp

         case 16:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;
            __int64 mask1=0x0101020204040808,
                    mask0=0x1010202040408080;

            if ( mmx_supported )
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;

               unmask = ~mask;
               len     = (png_ptr->width)&~7;
               diff = (png_ptr->width)&7;
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1

                  pand       mm0,mm7
                  pand       mm1,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest
                  cmp        ecx,0             //lcr
                  jz         mainloop16end

mainloop16:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4

                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  add        esi,16            //inc by 16 bytes processed
                  add        ebx,16
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop16

mainloop16end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end16

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop16:
                  sal        edx,1             //move high bit to CF
                  jnc        skip16            //if CF = 0
                  mov        ax,[esi]
                  mov        [ebx],ax
skip16:
                  add        esi,2
                  add        ebx,2

                  dec        ecx
                  jnz        secondloop16
end16:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  if (pixel_bytes > (png_size_t)(final_val-i))
                    pixel_bytes = (png_size_t)(final_val-i);
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 16 bpp

         case 24:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask2=0x0101010202020404,  //24bpp
                    mask1=0x0408080810101020,
                    mask0=0x2020404040808080;

            srcptr = png_ptr->row_buf + 1;
            dstptr = row;

            unmask = ~mask;
            len     = (png_ptr->width)&~7;
            diff = (png_ptr->width)&7;

            if ( mmx_supported )
            {
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest
                  cmp        ecx,0
                  jz         mainloop24end

mainloop24:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4


                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm4,mm2
                  movq       mm7,[ebx+16]
                  pandn      mm4,mm7
                  por        mm6,mm4
                  movq       [ebx+16],mm6

                  add        esi,24            //inc by 24 bytes processed
                  add        ebx,24
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop24

mainloop24end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end24

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop24:
                  sal        edx,1             //move high bit to CF
                  jnc        skip24            //if CF = 0
                  mov        ax,[esi]
                  mov        [ebx],ax
                  xor        eax,eax
                  mov        al,[esi+2]
                  mov        [ebx+2],al
skip24:
                  add        esi,3
                  add        ebx,3

                  dec        ecx
                  jnz        secondloop24

end24:
                  emms
               }
            }
            else /* mmx not supported - use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  if (pixel_bytes > (png_size_t)(final_val-i))
                    pixel_bytes = (png_size_t)(final_val-i);
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 24 bpp

         case 32:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask3=0x0101010102020202,  //32bpp
                    mask2=0x0404040408080808,
                    mask1=0x1010101020202020,
                    mask0=0x4040404080808080;

            srcptr = png_ptr->row_buf + 1;
            dstptr = row;

            unmask = ~mask;
            len     = (png_ptr->width)&~7;
            diff = (png_ptr->width)&7;

            if ( mmx_supported )
            {
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2
                  movq       mm3,mask3

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7
                  pand       mm3,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6
                  pcmpeqb    mm3,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest

                  cmp        ecx,0             //lcr
                  jz         mainloop32end

mainloop32:
                  movq       mm4,[esi]
                  pand       mm4,mm0
                  movq       mm6,mm0
                  movq       mm7,[ebx]
                  pandn      mm6,mm7
                  por        mm4,mm6
                  movq       [ebx],mm4

                  movq       mm5,[esi+8]
                  pand       mm5,mm1
                  movq       mm7,mm1
                  movq       mm6,[ebx+8]
                  pandn      mm7,mm6
                  por        mm5,mm7
                  movq       [ebx+8],mm5

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm4,mm2
                  movq       mm7,[ebx+16]
                  pandn      mm4,mm7
                  por        mm6,mm4
                  movq       [ebx+16],mm6

                  movq       mm7,[esi+24]
                  pand       mm7,mm3
                  movq       mm5,mm3
                  movq       mm4,[ebx+24]
                  pandn      mm5,mm4
                  por        mm7,mm5
                  movq       [ebx+24],mm7

                  add        esi,32            //inc by 32 bytes processed
                  add        ebx,32
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop32

mainloop32end:
                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end32

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte
secondloop32:
                  sal        edx,1             //move high bit to CF
                  jnc        skip32            //if CF = 0
                  mov        eax,[esi]
                  mov        [ebx],eax
skip32:
                  add        esi,4
                  add        ebx,4

                  dec        ecx
                  jnz        secondloop32

end32:
                  emms
               }
            }
            else /* mmx _not supported - Use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  if (pixel_bytes > (png_size_t)(final_val-i))
                    pixel_bytes = (png_size_t)(final_val-i);
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 32 bpp

         case 48:
         {
            png_bytep srcptr;
            png_bytep dstptr;
            png_uint_32 len;
            int unmask, diff;

            __int64 mask5=0x0101010101010202,
                    mask4=0x0202020204040404,
                    mask3=0x0404080808080808,
                    mask2=0x1010101010102020,
                    mask1=0x2020202040404040,
                    mask0=0x4040808080808080;

            if ( mmx_supported )
            {
               srcptr = png_ptr->row_buf + 1;
               dstptr = row;

               unmask = ~mask;
               len     = (png_ptr->width)&~7;
               diff = (png_ptr->width)&7;
               _asm
               {
                  movd       mm7, unmask       //load bit pattern
                  psubb      mm6,mm6           //zero mm6
                  punpcklbw  mm7,mm7
                  punpcklwd  mm7,mm7
                  punpckldq  mm7,mm7           //fill register with 8 masks

                  movq       mm0,mask0
                  movq       mm1,mask1
                  movq       mm2,mask2
                  movq       mm3,mask3
                  movq       mm4,mask4
                  movq       mm5,mask5

                  pand       mm0,mm7
                  pand       mm1,mm7
                  pand       mm2,mm7
                  pand       mm3,mm7
                  pand       mm4,mm7
                  pand       mm5,mm7

                  pcmpeqb    mm0,mm6
                  pcmpeqb    mm1,mm6
                  pcmpeqb    mm2,mm6
                  pcmpeqb    mm3,mm6
                  pcmpeqb    mm4,mm6
                  pcmpeqb    mm5,mm6

                  mov        ecx,len           //load length of line
                  mov        esi,srcptr        //load source
                  mov        ebx,dstptr        //load dest

                  cmp        ecx,0
                  jz         mainloop48end

mainloop48:
                  movq       mm7,[esi]
                  pand       mm7,mm0
                  movq       mm6,mm0
                  pandn      mm6,[ebx]
                  por        mm7,mm6
                  movq       [ebx],mm7

                  movq       mm6,[esi+8]
                  pand       mm6,mm1
                  movq       mm7,mm1
                  pandn      mm7,[ebx+8]
                  por        mm6,mm7
                  movq       [ebx+8],mm6

                  movq       mm6,[esi+16]
                  pand       mm6,mm2
                  movq       mm7,mm2
                  pandn      mm7,[ebx+16]
                  por        mm6,mm7
                  movq       [ebx+16],mm6

                  movq       mm7,[esi+24]
                  pand       mm7,mm3
                  movq       mm6,mm3
                  pandn      mm6,[ebx+24]
                  por        mm7,mm6
                  movq       [ebx+24],mm7

                  movq       mm6,[esi+32]
                  pand       mm6,mm4
                  movq       mm7,mm4
                  pandn      mm7,[ebx+32]
                  por        mm6,mm7
                  movq       [ebx+32],mm6

                  movq       mm7,[esi+40]
                  pand       mm7,mm5
                  movq       mm6,mm5
                  pandn      mm6,[ebx+40]
                  por        mm7,mm6
                  movq       [ebx+40],mm7

                  add        esi,48            //inc by 32 bytes processed
                  add        ebx,48
                  sub        ecx,8             //dec by 8 pixels processed

                  ja         mainloop48
mainloop48end:

                  mov        ecx,diff
                  cmp        ecx,0
                  jz         end48

                  mov        edx,mask
                  sal        edx,24            //make low byte the high byte

secondloop48:
                  sal        edx,1             //move high bit to CF
                  jnc        skip48            //if CF = 0
                  mov        eax,[esi]
                  mov        [ebx],eax
skip48:
                  add        esi,4
                  add        ebx,4

                  dec        ecx
                  jnz        secondloop48

end48:
                  emms
               }
            }
            else /* mmx _not supported - Use modified C routine */
            {
               register unsigned int incr1, initial_val, final_val;
               png_size_t pixel_bytes;
               png_uint_32 i;
               register int disp = png_pass_inc[png_ptr->pass];
               int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};

               pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
               srcptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
                  pixel_bytes;
               dstptr = row + offset_table[png_ptr->pass]*pixel_bytes;
               initial_val = offset_table[png_ptr->pass]*pixel_bytes;
               final_val = png_ptr->width*pixel_bytes;
               incr1 = (disp)*pixel_bytes;
               for (i = initial_val; i < final_val; i += incr1)
               {
                  if (pixel_bytes > (png_size_t)(final_val-i))
                    pixel_bytes = (png_size_t)(final_val-i);
                  png_memcpy(dstptr, srcptr, pixel_bytes);
                  srcptr += incr1;
                  dstptr += incr1;
               }
            } /* end of else */

            break;
         }       // end 48 bpp

         default:
         {
            png_bytep sptr;
            png_bytep dp;
            png_size_t pixel_bytes;
            int offset_table[7] = {0, 4, 0, 2, 0, 1, 0};
            unsigned int i;
            register int disp = png_pass_inc[png_ptr->pass];  // get the offset
            register unsigned int incr1, initial_val, final_val;

            pixel_bytes = (png_ptr->row_info.pixel_depth >> 3);
            sptr = png_ptr->row_buf + 1 + offset_table[png_ptr->pass]*
               pixel_bytes;
            dp = row + offset_table[png_ptr->pass]*pixel_bytes;
            initial_val = offset_table[png_ptr->pass]*pixel_bytes;
            final_val = png_ptr->width*pixel_bytes;
            incr1 = (disp)*pixel_bytes;
            for (i = initial_val; i < final_val; i += incr1)
            {
               if (pixel_bytes > (png_size_t)(final_val-i))
                 pixel_bytes = (png_size_t)(final_val-i);
               png_memcpy(dp, sptr, pixel_bytes);
               sptr += incr1;
               dp += incr1;
            }
            break;
         }
      } /* end switch (png_ptr->row_info.pixel_depth) */
   } /* end if (non-trivial mask) */

} /* end png_combine_row() */


#if defined(PNG_READ_INTERLACING_SUPPORTED)

void /* PRIVATE */
png_do_read_interlace(png_structp png_ptr)
{
   png_row_infop row_info = &(png_ptr->row_info);
   png_bytep row = png_ptr->row_buf + 1;
   int pass = png_ptr->pass;
   png_uint_32 transformations = png_ptr->transformations;
#ifdef PNG_USE_LOCAL_ARRAYS
   const int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1,"in png_do_read_interlace\n");

   if (mmx_supported == 2) {
       png_mmx_support();
   }

   if (row != NULL && row_info != NULL)
   {
      png_uint_32 final_width;

      final_width = row_info->width * png_pass_inc[pass];

      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_byte v;
            png_uint_32 i;
            int j;

            sp = row + (png_size_t)((row_info->width - 1) >> 3);
            dp = row + (png_size_t)((final_width - 1) >> 3);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (int)((row_info->width + 7) & 7);
               dshift = (int)((final_width + 7) & 7);
               s_start = 7;
               s_end = 0;
               s_inc = -1;
            }
            else
#endif
            {
               sshift = 7 - (int)((row_info->width + 7) & 7);
               dshift = 7 - (int)((final_width + 7) & 7);
               s_start = 0;
               s_end = 7;
               s_inc = 1;
            }

            for (i = row_info->width; i; i--)
            {
               v = (png_byte)((*sp >> sshift) & 0x1);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x7f7f >> (7 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 2:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 2);
            dp = row + (png_size_t)((final_width - 1) >> 2);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 3) & 3) << 1);
               dshift = (png_size_t)(((final_width + 3) & 3) << 1);
               s_start = 6;
               s_end = 0;
               s_inc = -2;
            }
            else
#endif
            {
               sshift = (png_size_t)((3 - ((row_info->width + 3) & 3)) << 1);
               dshift = (png_size_t)((3 - ((final_width + 3) & 3)) << 1);
               s_start = 0;
               s_end = 6;
               s_inc = 2;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0x3);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0x3f3f >> (6 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         case 4:
         {
            png_bytep sp, dp;
            int sshift, dshift;
            int s_start, s_end, s_inc;
            png_uint_32 i;

            sp = row + (png_size_t)((row_info->width - 1) >> 1);
            dp = row + (png_size_t)((final_width - 1) >> 1);
#if defined(PNG_READ_PACKSWAP_SUPPORTED)
            if (transformations & PNG_PACKSWAP)
            {
               sshift = (png_size_t)(((row_info->width + 1) & 1) << 2);
               dshift = (png_size_t)(((final_width + 1) & 1) << 2);
               s_start = 4;
               s_end = 0;
               s_inc = -4;
            }
            else
#endif
            {
               sshift = (png_size_t)((1 - ((row_info->width + 1) & 1)) << 2);
               dshift = (png_size_t)((1 - ((final_width + 1) & 1)) << 2);
               s_start = 0;
               s_end = 4;
               s_inc = 4;
            }

            for (i = row_info->width; i; i--)
            {
               png_byte v;
               int j;

               v = (png_byte)((*sp >> sshift) & 0xf);
               for (j = 0; j < png_pass_inc[pass]; j++)
               {
                  *dp &= (png_byte)((0xf0f >> (4 - dshift)) & 0xff);
                  *dp |= (png_byte)(v << dshift);
                  if (dshift == s_end)
                  {
                     dshift = s_start;
                     dp--;
                  }
                  else
                     dshift += s_inc;
               }
               if (sshift == s_end)
               {
                  sshift = s_start;
                  sp--;
               }
               else
                  sshift += s_inc;
            }
            break;
         }

         default:         // This is the place where the routine is modified
         {
            __int64 const4 = 0x0000000000FFFFFF;
            // __int64 const5 = 0x000000FFFFFF0000;  // unused...
            __int64 const6 = 0x00000000000000FF;
            png_bytep sptr, dp;
            png_uint_32 i;
            png_size_t pixel_bytes;
            int width = row_info->width;

            pixel_bytes = (row_info->pixel_depth >> 3);

            sptr = row + (width - 1) * pixel_bytes;
            dp = row + (final_width - 1) * pixel_bytes;
            // New code by Nirav Chhatrapati - Intel Corporation
            // sign fix by GRR
            // NOTE:  there is NO MMX code for 48-bit and 64-bit images

            // use MMX routine if machine supports it
            if ( mmx_supported )
            {
               if (pixel_bytes == 3)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     _asm
                     {
                        mov esi, sptr
                        mov edi, dp
                        mov ecx, width
                        sub edi, 21   // (png_pass_inc[pass] - 1)*pixel_bytes
loop_pass0:
                        movd mm0, [esi]     ; X X X X X v2 v1 v0
                        pand mm0, const4    ; 0 0 0 0 0 v2 v1 v0
                        movq mm1, mm0       ; 0 0 0 0 0 v2 v1 v0
                        psllq mm0, 16       ; 0 0 0 v2 v1 v0 0 0
                        movq mm2, mm0       ; 0 0 0 v2 v1 v0 0 0
                        psllq mm0, 24       ; v2 v1 v0 0 0 0 0 0
                        psrlq mm1, 8        ; 0 0 0 0 0 0 v2 v1
                        por mm0, mm2        ; v2 v1 v0 v2 v1 v0 0 0
                        por mm0, mm1        ; v2 v1 v0 v2 v1 v0 v2 v1
                        movq mm3, mm0       ; v2 v1 v0 v2 v1 v0 v2 v1
                        psllq mm0, 16       ; v0 v2 v1 v0 v2 v1 0 0
                        movq mm4, mm3       ; v2 v1 v0 v2 v1 v0 v2 v1
                        punpckhdq mm3, mm0  ; v0 v2 v1 v0 v2 v1 v0 v2
                        movq [edi+16] , mm4
                        psrlq mm0, 32       ; 0 0 0 0 v0 v2 v1 v0
                        movq [edi+8] , mm3
                        punpckldq mm0, mm4  ; v1 v0 v2 v1 v0 v2 v1 v0
                        sub esi, 3
                        movq [edi], mm0
                        sub edi, 24
                        //sub esi, 3
                        dec ecx
                        jnz loop_pass0
                        EMMS
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     _asm
                     {
                        mov esi, sptr
                        mov edi, dp
                        mov ecx, width
                        sub edi, 9   // (png_pass_inc[pass] - 1)*pixel_bytes
loop_pass2:
                        movd mm0, [esi]     ; X X X X X v2 v1 v0
                        pand mm0, const4    ; 0 0 0 0 0 v2 v1 v0
                        movq mm1, mm0       ; 0 0 0 0 0 v2 v1 v0
                        psllq mm0, 16       ; 0 0 0 v2 v1 v0 0 0
                        movq mm2, mm0       ; 0 0 0 v2 v1 v0 0 0
                        psllq mm0, 24       ; v2 v1 v0 0 0 0 0 0
                        psrlq mm1, 8        ; 0 0 0 0 0 0 v2 v1
                        por mm0, mm2        ; v2 v1 v0 v2 v1 v0 0 0
                        por mm0, mm1        ; v2 v1 v0 v2 v1 v0 v2 v1
                        movq [edi+4], mm0   ; move to memory
                        psrlq mm0, 16       ; 0 0 v2 v1 v0 v2 v1 v0
                        movd [edi], mm0     ; move to memory
                        sub esi, 3
                        sub edi, 12
                        dec ecx
                        jnz loop_pass2
                        EMMS
                     }
                  }
                  else if (width) /* && ((pass == 4) || (pass == 5)) */
                  {
                     int width_mmx = ((width >> 1) << 1) - 8;
                     if (width_mmx < 0)
                         width_mmx = 0;
                     width -= width_mmx;        // 8 or 9 pix, 24 or 27 bytes
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 3
                           sub edi, 9
loop_pass4:
                           movq mm0, [esi]     ; X X v2 v1 v0 v5 v4 v3
                           movq mm7, mm0       ; X X v2 v1 v0 v5 v4 v3
                           movq mm6, mm0       ; X X v2 v1 v0 v5 v4 v3
                           psllq mm0, 24       ; v1 v0 v5 v4 v3 0 0 0
                           pand mm7, const4    ; 0 0 0 0 0 v5 v4 v3
                           psrlq mm6, 24       ; 0 0 0 X X v2 v1 v0
                           por mm0, mm7        ; v1 v0 v5 v4 v3 v5 v4 v3
                           movq mm5, mm6       ; 0 0 0 X X v2 v1 v0
                           psllq mm6, 8        ; 0 0 X X v2 v1 v0 0
                           movq [edi], mm0     ; move quad to memory
                           psrlq mm5, 16       ; 0 0 0 0 0 X X v2
                           pand mm5, const6    ; 0 0 0 0 0 0 0 v2
                           por mm6, mm5        ; 0 0 X X v2 v1 v0 v2
                           movd [edi+8], mm6   ; move double to memory
                           sub esi, 6
                           sub edi, 12
                           sub ecx, 2
                           jnz loop_pass4
                           EMMS
                        }
                     }

                     sptr -= width_mmx*3;
                     dp -= width_mmx*6;
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;

                        png_memcpy(v, sptr, 3);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           png_memcpy(dp, v, 3);
                           dp -= 3;
                        }
                        sptr -= 3;
                     }
                  }
               } /* end of pixel_bytes == 3 */

               else if (pixel_bytes == 1)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 31
                           sub esi, 3
loop1_pass0:
                           movd mm0, [esi]     ; X X X X v0 v1 v2 v3
                           movq mm1, mm0       ; X X X X v0 v1 v2 v3
                           punpcklbw mm0, mm0  ; v0 v0 v1 v1 v2 v2 v3 v3
                           movq mm2, mm0       ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpcklwd mm0, mm0  ; v2 v2 v2 v2 v3 v3 v3 v3
                           movq mm3, mm0       ; v2 v2 v2 v2 v3 v3 v3 v3
                           punpckldq mm0, mm0  ; v3 v3 v3 v3 v3 v3 v3 v3
                           punpckhdq mm3, mm3  ; v2 v2 v2 v2 v2 v2 v2 v2
                           movq [edi], mm0     ; move to memory v3
                           punpckhwd mm2, mm2  ; v0 v0 v0 v0 v1 v1 v1 v1
                           movq [edi+8], mm3   ; move to memory v2
                           movq mm4, mm2       ; v0 v0 v0 v0 v1 v1 v1 v1
                           punpckldq mm2, mm2  ; v1 v1 v1 v1 v1 v1 v1 v1
                           punpckhdq mm4, mm4  ; v0 v0 v0 v0 v0 v0 v0 v0
                           movq [edi+16], mm2  ; move to memory v1
                           movq [edi+24], mm4  ; move to memory v0
                           sub esi, 4
                           sub edi, 32
                           sub ecx, 4
                           jnz loop1_pass0
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*8;
                     for (i = width; i; i--)
                     {
                        int j;

                       /* I simplified this part in version 1.0.4e
                        * here and in several other instances where
                        * pixel_bytes == 1  -- GR-P
                        *
                        * Original code:
                        *
                        * png_byte v[8];
                        * png_memcpy(v, sptr, pixel_bytes);
                        * for (j = 0; j < png_pass_inc[pass]; j++)
                        * {
                        *    png_memcpy(dp, v, pixel_bytes);
                        *    dp -= pixel_bytes;
                        * }
                        * sptr -= pixel_bytes;
                        *
                        * Replacement code is in the next three lines:
                        */

                        for (j = 0; j < png_pass_inc[pass]; j++)
                           *dp-- = *sptr;
                        sptr--;
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 2) << 2);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 15
                           sub esi, 3
loop1_pass2:
                           movd mm0, [esi]     ; X X X X v0 v1 v2 v3
                           punpcklbw mm0, mm0  ; v0 v0 v1 v1 v2 v2 v3 v3
                           movq mm1, mm0       ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpcklwd mm0, mm0  ; v2 v2 v2 v2 v3 v3 v3 v3
                           punpckhwd mm1, mm1  ; v0 v0 v0 v0 v1 v1 v1 v1
                           movq [edi], mm0     ; move to memory v2 and v3
                           sub esi, 4
                           movq [edi+8], mm1   ; move to memory v1     and v0
                           sub edi, 16
                           sub ecx, 4
                           jnz loop1_pass2
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*4;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        sptr --;
                     }
                  }
                  else if (width) /* && ((pass == 4) || (pass == 5))) */
                  {
                     int width_mmx = ((width >> 3) << 3);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub edi, 15
                           sub esi, 7
loop1_pass4:
                           movq mm0, [esi]     ; v0 v1 v2 v3 v4 v5 v6 v7
                           movq mm1, mm0       ; v0 v1 v2 v3 v4 v5 v6 v7
                           punpcklbw mm0, mm0  ; v4 v4 v5 v5 v6 v6 v7 v7
                           //movq mm1, mm0     ; v0 v0 v1 v1 v2 v2 v3 v3
                           punpckhbw mm1, mm1  ;v0 v0 v1 v1 v2 v2 v3 v3
                           movq [edi+8], mm1   ; move to memory v0 v1 v2 and v3
                           sub esi, 8
                           movq [edi], mm0     ; move to memory v4 v5 v6 and v7
                           //sub esi, 4
                           sub edi, 16
                           sub ecx, 8
                           jnz loop1_pass4
                           EMMS
                        }
                     }

                     sptr -= width_mmx;
                     dp -= width_mmx*2;
                     for (i = width; i; i--)
                     {
                        int j;

                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           *dp-- = *sptr;
                        }
                        sptr --;
                     }
                  }
               } /* end of pixel_bytes == 1 */

               else if (pixel_bytes == 2)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1);
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 30
loop2_pass0:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           movq mm1, mm0          ; v1 v0 v1 v0 v3 v2 v3 v2
                           punpckldq mm0, mm0     ; v3 v2 v3 v2 v3 v2 v3 v2
                           punpckhdq mm1, mm1     ; v1 v0 v1 v0 v1 v0 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi + 16], mm1
                           movq [edi + 24], mm1
                           sub esi, 4
                           sub edi, 32
                           sub ecx, 2
                           jnz loop2_pass0
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);            // sign fixed
                     dp -= (width_mmx*16 - 2);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 14
loop2_pass2:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           movq mm1, mm0          ; v1 v0 v1 v0 v3 v2 v3 v2
                           punpckldq mm0, mm0     ; v3 v2 v3 v2 v3 v2 v3 v2
                           punpckhdq mm1, mm1     ; v1 v0 v1 v0 v1 v0 v1 v0
                           movq [edi], mm0
                           sub esi, 4
                           movq [edi + 8], mm1
                           //sub esi, 4
                           sub edi, 16
                           sub ecx, 2
                           jnz loop2_pass2
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);            // sign fixed
                     dp -= (width_mmx*8 - 2);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
                  else if (width)  // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 2
                           sub edi, 6
loop2_pass4:
                           movd mm0, [esi]        ; X X X X v1 v0 v3 v2
                           punpcklwd mm0, mm0     ; v1 v0 v1 v0 v3 v2 v3 v2
                           sub esi, 4
                           movq [edi], mm0
                           sub edi, 8
                           sub ecx, 2
                           jnz loop2_pass4
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*2 - 2);            // sign fixed
                     dp -= (width_mmx*4 - 2);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 2;
                        png_memcpy(v, sptr, 2);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 2;
                           png_memcpy(dp, v, 2);
                        }
                     }
                  }
               } /* end of pixel_bytes == 2 */

               else if (pixel_bytes == 4)
               {
                  if (((pass == 0) || (pass == 1)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 60
loop4_pass0:
                           movq mm0, [esi]        ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0          ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0     ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1     ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi + 16], mm0
                           movq [edi + 24], mm0
                           movq [edi+32], mm1
                           movq [edi + 40], mm1
                           movq [edi+ 48], mm1
                           sub esi, 8
                           movq [edi + 56], mm1
                           sub edi, 64
                           sub ecx, 2
                           jnz loop4_pass0
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);            // sign fixed
                     dp -= (width_mmx*32 - 4);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }
                  else if (((pass == 2) || (pass == 3)) && width)
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 28
loop4_pass2:
                           movq mm0, [esi]      ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0        ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0   ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1   ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           movq [edi + 8], mm0
                           movq [edi+16], mm1
                           movq [edi + 24], mm1
                           sub esi, 8
                           sub edi, 32
                           sub ecx, 2
                           jnz loop4_pass2
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);            // sign fixed
                     dp -= (width_mmx*16 - 4);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }
                  else if (width)  // pass == 4 or 5
                  {
                     int width_mmx = ((width >> 1) << 1) ;
                     width -= width_mmx;
                     if (width_mmx)
                     {
                        _asm
                        {
                           mov esi, sptr
                           mov edi, dp
                           mov ecx, width_mmx
                           sub esi, 4
                           sub edi, 12
loop4_pass4:
                           movq mm0, [esi]      ; v3 v2 v1 v0 v7 v6 v5 v4
                           movq mm1, mm0        ; v3 v2 v1 v0 v7 v6 v5 v4
                           punpckldq mm0, mm0   ; v7 v6 v5 v4 v7 v6 v5 v4
                           punpckhdq mm1, mm1   ; v3 v2 v1 v0 v3 v2 v1 v0
                           movq [edi], mm0
                           sub esi, 8
                           movq [edi + 8], mm1
                           sub edi, 16
                           sub ecx, 2
                           jnz loop4_pass4
                           EMMS
                        }
                     }

                     sptr -= (width_mmx*4 - 4);          // sign fixed
                     dp -= (width_mmx*8 - 4);            // sign fixed
                     for (i = width; i; i--)
                     {
                        png_byte v[8];
                        int j;
                        sptr -= 4;
                        png_memcpy(v, sptr, 4);
                        for (j = 0; j < png_pass_inc[pass]; j++)
                        {
                           dp -= 4;
                           png_memcpy(dp, v, 4);
                        }
                     }
                  }

               } /* end of pixel_bytes == 4 */

               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, 6);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, 6);
                        dp -= 6;
                     }
                     sptr -= 6;
                  }
               } /* end of pixel_bytes == 6 */

               else
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr-= pixel_bytes;
                  }
               }
            } /* end of mmx_supported */

            else /* MMX not supported:  use modified C code - takes advantage
                  * of inlining of png_memcpy for a constant */
            {
               if (pixel_bytes == 1)
               {
                  for (i = width; i; i--)
                  {
                     int j;
                     for (j = 0; j < png_pass_inc[pass]; j++)
                        *dp-- = *sptr;
                     sptr--;
                  }
               }
               else if (pixel_bytes == 3)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 2)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 4)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else if (pixel_bytes == 6)
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }
               else
               {
                  for (i = width; i; i--)
                  {
                     png_byte v[8];
                     int j;
                     png_memcpy(v, sptr, pixel_bytes);
                     for (j = 0; j < png_pass_inc[pass]; j++)
                     {
                        png_memcpy(dp, v, pixel_bytes);
                        dp -= pixel_bytes;
                     }
                     sptr -= pixel_bytes;
                  }
               }

            } /* end of MMX not supported */
            break;
         }
      } /* end switch (row_info->pixel_depth) */

      row_info->width = final_width;
      row_info->rowbytes = ((final_width *
         (png_uint_32)row_info->pixel_depth + 7) >> 3);
   }

}

#endif /* PNG_READ_INTERLACING_SUPPORTED */


// These variables are utilized in the functions below.  They are declared
// globally here to ensure alignment on 8-byte boundaries.

union uAll {
   __int64 use;
   double  align;
} LBCarryMask = {0x0101010101010101},
  HBClearMask = {0x7f7f7f7f7f7f7f7f},
  ActiveMask, ActiveMask2, ActiveMaskEnd, ShiftBpp, ShiftRem;


// Optimized code for PNG Average filter decoder
void /* PRIVATE */
png_read_filter_row_mmx_avg(png_row_infop row_info, png_bytep row
                            , png_bytep prev_row)
{
   int bpp;
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   //png_uint_32 len;
   int diff;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes; // # of bytes to filter
   _asm {
         // Init address pointers and offset
         mov edi, row          // edi ==> Avg(x)
         xor ebx, ebx          // ebx ==> x
         mov edx, edi
         mov esi, prev_row           // esi ==> Prior(x)
         sub edx, bpp          // edx ==> Raw(x-bpp)

         xor eax, eax
         // Compute the Raw value for the first bpp bytes
         //    Raw(x) = Avg(x) + (Prior(x)/2)
davgrlp:
         mov al, [esi + ebx]   // Load al with Prior(x)
         inc ebx
         shr al, 1             // divide by 2
         add al, [edi+ebx-1]   // Add Avg(x); -1 to offset inc ebx
         cmp ebx, bpp
         mov [edi+ebx-1], al    // Write back Raw(x);
                            // mov does not affect flags; -1 to offset inc ebx
         jb davgrlp
         // get # of bytes to alignment
         mov diff, edi         // take start of row
         add diff, ebx         // add bpp
         add diff, 0xf         // add 7 + 8 to incr past alignment boundary
         and diff, 0xfffffff8  // mask to alignment boundary
         sub diff, edi         // subtract from start ==> value ebx at alignment
         jz davggo
         // fix alignment
         // Compute the Raw value for the bytes upto the alignment boundary
         //    Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
         xor ecx, ecx
davglp1:
         xor eax, eax
         mov cl, [esi + ebx]        // load cl with Prior(x)
         mov al, [edx + ebx]  // load al with Raw(x-bpp)
         add ax, cx
         inc ebx
         shr ax, 1            // divide by 2
         add al, [edi+ebx-1]  // Add Avg(x); -1 to offset inc ebx
         cmp ebx, diff              // Check if at alignment boundary
         mov [edi+ebx-1], al        // Write back Raw(x);
                            // mov does not affect flags; -1 to offset inc ebx
         jb davglp1               // Repeat until at alignment boundary
davggo:
         mov eax, FullLength
         mov ecx, eax
         sub eax, ebx          // subtract alignment fix
         and eax, 0x00000007   // calc bytes over mult of 8
         sub ecx, eax          // drop over bytes from original length
         mov MMXLength, ecx
   } // end _asm block
   // Now do the math for the rest of the row
   switch ( bpp )
   {
      case 3:
      {
         ActiveMask.use  = 0x0000000000ffffff;
         ShiftBpp.use = 24;    // == 3 * 8
         ShiftRem.use = 40;    // == 64 - 24
         _asm {
            // Re-init address pointers and offset
            movq mm7, ActiveMask
            mov ebx, diff      // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row       // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row        // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                               // (we correct position in loop below)
davg3lp:
            movq mm0, [edi + ebx]      // Load mm0 with Avg(x)
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            psrlq mm2, ShiftRem      // Correct position Raw(x-bpp) data
            movq mm1, [esi + ebx]    // Load mm1 with Prior(x)
            movq mm6, mm7
            pand mm3, mm1      // get lsb for each prev_row byte
            psrlq mm1, 1       // divide prev_row bytes by 2
            pand  mm1, mm4     // clear invalid bit 7 of each byte
            paddb mm0, mm1     // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3      // now use mm1 for getting LBCarrys
            pand mm1, mm2      // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1       // divide raw bytes by 2
            pand  mm2, mm4     // clear invalid bit 7 of each byte
            paddb mm2, mm1     // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6      // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover bytes 3-5
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
            movq mm1, mm3        // now use mm1 for getting LBCarrys
            pand mm1, mm2      // get LBCarrys for each byte where both
                               // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1       // divide raw bytes by 2
            pand  mm2, mm4     // clear invalid bit 7 of each byte
            paddb mm2, mm1     // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6      // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2     // add (Raw/2) + LBCarrys to Avg for each Active
                               //  byte

            // Add 3rd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover the last two
                                 // bytes
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
                              // Data only needs to be shifted once here to
                              // get the correct x-bpp offset.
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 2 bytes to add to Avg
            add ebx, 8
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte

            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Move updated Raw(x) to use as Raw(x-bpp) for next loop
            cmp ebx, MMXLength
            movq mm2, mm0     // mov updated Raw(x) to mm2
            jb davg3lp
         } // end _asm block
      }
      break;

      case 6:
      case 4:
      case 7:
      case 5:
      {
         ActiveMask.use  = 0xffffffffffffffff;  // use shift below to clear
                                                // appropriate inactive bytes
         ShiftBpp.use = bpp << 3;
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm {
            movq mm4, HBClearMask
            // Re-init address pointers and offset
            mov ebx, diff       // ebx ==> x = offset to alignment boundary
            // Load ActiveMask and clear all bytes except for 1st active group
            movq mm7, ActiveMask
            mov edi, row         // edi ==> Avg(x)
            psrlq mm7, ShiftRem
            mov esi, prev_row    // esi ==> Prior(x)
            movq mm6, mm7
            movq mm5, LBCarryMask
            psllq mm6, ShiftBpp  // Create mask for 2nd active group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                                 // (we correct position in loop below)
davg4lp:
            movq mm0, [edi + ebx]
            psrlq mm2, ShiftRem  // shift data to position correctly
            movq mm1, [esi + ebx]
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            pand mm3, mm1     // get lsb for each prev_row byte
            psrlq mm1, 1      // divide prev_row bytes by 2
            pand  mm1, mm4    // clear invalid bit 7 of each byte
            paddb mm0, mm1    // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm7     // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm2, mm0     // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
            add ebx, 8
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2    // add (Raw/2) + LBCarrys to Avg for each Active
                              // byte
            cmp ebx, MMXLength
            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Prep Raw(x-bpp) for next loop
            movq mm2, mm0     // mov updated Raws to mm2
            jb davg4lp
         } // end _asm block
      }
      break;
      case 2:
      {
         ActiveMask.use  = 0x000000000000ffff;
         ShiftBpp.use = 16;   // == 2 * 8     [BUGFIX]
         ShiftRem.use = 48;   // == 64 - 16   [BUGFIX]
         _asm {
            // Load ActiveMask
            movq mm7, ActiveMask
            // Re-init address pointers and offset
            mov ebx, diff     // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row      // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row  // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                              // (we correct position in loop below)
davg2lp:
            movq mm0, [edi + ebx]
            psrlq mm2, ShiftRem  // shift data to position correctly   [BUGFIX]
            movq mm1, [esi + ebx]
            // Add (Prev_row/2) to Average
            movq mm3, mm5
            pand mm3, mm1     // get lsb for each prev_row byte
            psrlq mm1, 1      // divide prev_row bytes by 2
            pand  mm1, mm4    // clear invalid bit 7 of each byte
            movq mm6, mm7
            paddb mm0, mm1    // add (Prev_row/2) to Avg for each byte
            // Add 1st active group (Raw(x-bpp)/2) to Average with LBCarry
            movq mm1, mm3     // now use mm1 for getting LBCarrys
            pand mm1, mm2     // get LBCarrys for each byte where both
                              // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1      // divide raw bytes by 2
            pand  mm2, mm4    // clear invalid bit 7 of each byte
            paddb mm2, mm1    // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6     // Leave only Active Group 1 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte
            // Add 2nd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp // shift the mm6 mask to cover bytes 2 & 3
            movq mm2, mm0       // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
            movq mm1, mm3       // now use mm1 for getting LBCarrys
            pand mm1, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm2, mm1      // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6       // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            // Add rdd active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp // shift the mm6 mask to cover bytes 4 & 5
            movq mm2, mm0       // mov updated Raws to mm2
            psllq mm2, ShiftBpp // shift data to position correctly
                                // Data only needs to be shifted once here to
                                // get the correct x-bpp offset.
            movq mm1, mm3       // now use mm1 for getting LBCarrys
            pand mm1, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm2, mm1      // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6       // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            // Add 4th active group (Raw(x-bpp)/2) to Average with LBCarry
            psllq mm6, ShiftBpp  // shift the mm6 mask to cover bytes 6 & 7
            movq mm2, mm0        // mov updated Raws to mm2
            psllq mm2, ShiftBpp  // shift data to position correctly
                                 // Data only needs to be shifted once here to
                                 // get the correct x-bpp offset.
            add ebx, 8
            movq mm1, mm3    // now use mm1 for getting LBCarrys
            pand mm1, mm2    // get LBCarrys for each byte where both
                             // lsb's were == 1 (Only valid for active group)
            psrlq mm2, 1     // divide raw bytes by 2
            pand  mm2, mm4   // clear invalid bit 7 of each byte
            paddb mm2, mm1   // add LBCarrys to (Raw(x-bpp)/2) for each byte
            pand mm2, mm6    // Leave only Active Group 2 bytes to add to Avg
            paddb mm0, mm2 // add (Raw/2) + LBCarrys to Avg for each Active byte

            cmp ebx, MMXLength
            // Now ready to write back to memory
            movq [edi + ebx - 8], mm0
            // Prep Raw(x-bpp) for next loop
            movq mm2, mm0    // mov updated Raws to mm2
            jb davg2lp
        } // end _asm block
      }
      break;

      case 1:                 // bpp == 1
      {
         _asm {
            // Re-init address pointers and offset
            mov ebx, diff     // ebx ==> x = offset to alignment boundary
            mov edi, row      // edi ==> Avg(x)
            cmp ebx, FullLength  // Test if offset at end of array
            jnb davg1end
            // Do Paeth decode for remaining bytes
            mov esi, prev_row    // esi ==> Prior(x)
            mov edx, edi
            xor ecx, ecx         // zero ecx before using cl & cx in loop below
            sub edx, bpp         // edx ==> Raw(x-bpp)
davg1lp:
            // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
            xor eax, eax
            mov cl, [esi + ebx]  // load cl with Prior(x)
            mov al, [edx + ebx]  // load al with Raw(x-bpp)
            add ax, cx
            inc ebx
            shr ax, 1            // divide by 2
            add al, [edi+ebx-1]  // Add Avg(x); -1 to offset inc ebx
            cmp ebx, FullLength  // Check if at end of array
            mov [edi+ebx-1], al  // Write back Raw(x);
                         // mov does not affect flags; -1 to offset inc ebx
            jb davg1lp
davg1end:
         } // end _asm block
      }
      return;

      case 8:             // bpp == 8
      {
         _asm {
            // Re-init address pointers and offset
            mov ebx, diff           // ebx ==> x = offset to alignment boundary
            movq mm5, LBCarryMask
            mov edi, row            // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov esi, prev_row       // esi ==> Prior(x)
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm2, [edi + ebx - 8]  // Load previous aligned 8 bytes
                                // (NO NEED to correct position in loop below)
davg8lp:
            movq mm0, [edi + ebx]
            movq mm3, mm5
            movq mm1, [esi + ebx]
            add ebx, 8
            pand mm3, mm1       // get lsb for each prev_row byte
            psrlq mm1, 1        // divide prev_row bytes by 2
            pand mm3, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm1, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm3      // add LBCarrys to Avg for each byte
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm1      // add (Prev_row/2) to Avg for each byte
            paddb mm0, mm2      // add (Raw/2) to Avg for each byte
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm0
            movq mm2, mm0       // reuse as Raw(x-bpp)
            jb davg8lp
        } // end _asm block
      }
      break;
      default:                  // bpp greater than 8
      {
        _asm {
            movq mm5, LBCarryMask
            // Re-init address pointers and offset
            mov ebx, diff       // ebx ==> x = offset to alignment boundary
            mov edi, row        // edi ==> Avg(x)
            movq mm4, HBClearMask
            mov edx, edi
            mov esi, prev_row   // esi ==> Prior(x)
            sub edx, bpp        // edx ==> Raw(x-bpp)
davgAlp:
            movq mm0, [edi + ebx]
            movq mm3, mm5
            movq mm1, [esi + ebx]
            pand mm3, mm1       // get lsb for each prev_row byte
            movq mm2, [edx + ebx]
            psrlq mm1, 1        // divide prev_row bytes by 2
            pand mm3, mm2       // get LBCarrys for each byte where both
                                // lsb's were == 1
            psrlq mm2, 1        // divide raw bytes by 2
            pand  mm1, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm3      // add LBCarrys to Avg for each byte
            pand  mm2, mm4      // clear invalid bit 7 of each byte
            paddb mm0, mm1      // add (Prev_row/2) to Avg for each byte
            add ebx, 8
            paddb mm0, mm2      // add (Raw/2) to Avg for each byte
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm0
            jb davgAlp
        } // end _asm block
      }
      break;
   }                         // end switch ( bpp )

   _asm {
         // MMX acceleration complete now do clean-up
         // Check if any remaining bytes left to decode
         mov ebx, MMXLength    // ebx ==> x = offset bytes remaining after MMX
         mov edi, row          // edi ==> Avg(x)
         cmp ebx, FullLength   // Test if offset at end of array
         jnb davgend
         // Do Paeth decode for remaining bytes
         mov esi, prev_row     // esi ==> Prior(x)
         mov edx, edi
         xor ecx, ecx          // zero ecx before using cl & cx in loop below
         sub edx, bpp          // edx ==> Raw(x-bpp)
davglp2:
         // Raw(x) = Avg(x) + ((Raw(x-bpp) + Prior(x))/2)
         xor eax, eax
         mov cl, [esi + ebx]   // load cl with Prior(x)
         mov al, [edx + ebx]   // load al with Raw(x-bpp)
         add ax, cx
         inc ebx
         shr ax, 1              // divide by 2
         add al, [edi+ebx-1]    // Add Avg(x); -1 to offset inc ebx
         cmp ebx, FullLength    // Check if at end of array
         mov [edi+ebx-1], al    // Write back Raw(x);
                          // mov does not affect flags; -1 to offset inc ebx
         jb davglp2
davgend:
         emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Paeth filter decoder
void /* PRIVATE */
png_read_filter_row_mmx_paeth(png_row_infop row_info, png_bytep row,
                              png_bytep prev_row)
{
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   //png_uint_32 len;
   int bpp;
   int diff;
   //int ptemp;
   int patemp, pbtemp, pctemp;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes; // # of bytes to filter
   _asm
   {
         xor ebx, ebx        // ebx ==> x offset
         mov edi, row
         xor edx, edx        // edx ==> x-bpp offset
         mov esi, prev_row
         xor eax, eax

         // Compute the Raw value for the first bpp bytes
         // Note: the formula works out to be always
         //   Paeth(x) = Raw(x) + Prior(x)      where x < bpp
dpthrlp:
         mov al, [edi + ebx]
         add al, [esi + ebx]
         inc ebx
         cmp ebx, bpp
         mov [edi + ebx - 1], al
         jb dpthrlp
         // get # of bytes to alignment
         mov diff, edi         // take start of row
         add diff, ebx         // add bpp
         xor ecx, ecx
         add diff, 0xf         // add 7 + 8 to incr past alignment boundary
         and diff, 0xfffffff8  // mask to alignment boundary
         sub diff, edi         // subtract from start ==> value ebx at alignment
         jz dpthgo
         // fix alignment
dpthlp1:
         xor eax, eax
         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]   // load Prior(x) into al
         mov cl, [esi + edx]   // load Prior(x-bpp) into cl
         sub eax, ecx          // subtract Prior(x-bpp)
         mov patemp, eax       // Save pav for later use
         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]   // load Raw(x-bpp) into al
         sub eax, ecx          // subtract Prior(x-bpp)
         mov ecx, eax
         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp       // pcv = pav + pbv
         // pc = abs(pcv)
         test eax, 0x80000000
         jz dpthpca
         neg eax               // reverse sign of neg values
dpthpca:
         mov pctemp, eax       // save pc for later use
         // pb = abs(pbv)
         test ecx, 0x80000000
         jz dpthpba
         neg ecx               // reverse sign of neg values
dpthpba:
         mov pbtemp, ecx       // save pb for later use
         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000
         jz dpthpaa
         neg eax               // reverse sign of neg values
dpthpaa:
         mov patemp, eax       // save pa for later use
         // test if pa <= pb
         cmp eax, ecx
         jna dpthabb
         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc
         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth
dpthbbc:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]   // load Prior(x) into cl
         jmp dpthpaeth
dpthabb:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc
         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth
dpthabc:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthpaeth:
         inc ebx
         inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
         add [edi + ebx - 1], cl
         cmp ebx, diff
         jb dpthlp1
dpthgo:
         mov ecx, FullLength
         mov eax, ecx
         sub eax, ebx          // subtract alignment fix
         and eax, 0x00000007   // calc bytes over mult of 8
         sub ecx, eax          // drop over bytes from original length
         mov MMXLength, ecx
   } // end _asm block
   // Now do the math for the rest of the row
   switch ( bpp )
   {
      case 3:
      {
         ActiveMask.use = 0x0000000000ffffff;
         ActiveMaskEnd.use = 0xffff000000000000;
         ShiftBpp.use = 24;    // == bpp(3) * 8
         ShiftRem.use = 40;    // == 64 - 24
         _asm
         {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dpth3lp:
            psrlq mm1, ShiftRem     // shift last 3 bytes to 1st 3 bytes
            movq mm2, [esi + ebx]   // load b=Prior(x)
            punpcklbw mm1, mm0      // Unpack High bytes of a
            movq mm3, [esi+ebx-8]   // Prep c=Prior(x-bpp) bytes
            punpcklbw mm2, mm0      // Unpack High bytes of b
            psrlq mm3, ShiftRem     // shift last 3 bytes to 1st 3 bytes
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0      // Unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx]   // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            movq mm2, mm3           // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]  // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0      // Unpack High bytes of c
            movq [edi + ebx], mm7   // write back updated value
            movq mm1, mm7           // Now mm1 will be used as Raw(x-bpp)
            // Now do Paeth for 2nd set of bytes (3-5)
            psrlq mm2, ShiftBpp     // load b=Prior(x) step 2
            punpcklbw mm1, mm0      // Unpack High bytes of a
            pxor mm7, mm7
            punpcklbw mm2, mm0      // Unpack High bytes of b
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            psubw mm5, mm3
            psubw mm4, mm3
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) =
            //       pav + pbv = pbv + pav
            movq mm6, mm5
            paddw mm6, mm4

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm5       // Create mask pbv bytes < 0
            pcmpgtw mm7, mm4       // Create mask pav bytes < 0
            pand mm0, mm5          // Only pbv bytes < 0 in mm0
            pand mm7, mm4          // Only pav bytes < 0 in mm7
            psubw mm5, mm0
            psubw mm4, mm7
            psubw mm5, mm0
            psubw mm4, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            movq mm2, [esi + ebx]  // load b=Prior(x)
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, mm2           // load c=Prior(x-bpp) step 1
            pand mm7, ActiveMask
            punpckhbw mm2, mm0      // Unpack High bytes of b
            psllq mm7, ShiftBpp     // Shift bytes to 2nd group of 3 bytes
             // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            paddb mm7, [edi + ebx]  // add Paeth predictor with Raw(x)
            psllq mm3, ShiftBpp     // load c=Prior(x-bpp) step 2
            movq [edi + ebx], mm7   // write back updated value
            movq mm1, mm7
            punpckhbw mm3, mm0      // Unpack High bytes of c
            psllq mm1, ShiftBpp     // Shift bytes
                                    // Now mm1 will be used as Raw(x-bpp)
            // Now do Paeth for 3rd, and final, set of bytes (6-7)
            pxor mm7, mm7
            punpckhbw mm1, mm0      // Unpack High bytes of a
            psubw mm4, mm3
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            pxor mm0, mm0
            paddw mm6, mm5

            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            pandn mm0, mm1
            pandn mm7, mm4
            paddw mm0, mm2
            paddw mm7, mm5
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6    // pab > pc?
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm1, mm1
            packuswb mm1, mm7
            // Step ebx to next set of 8 bytes and repeat loop til done
            add ebx, 8
            pand mm1, ActiveMaskEnd
            paddb mm1, [edi + ebx - 8] // add Paeth predictor with Raw(x)

            cmp ebx, MMXLength
            pxor mm0, mm0              // pxor does not affect flags
            movq [edi + ebx - 8], mm1  // write back updated value
                                 // mm1 will be used as Raw(x-bpp) next loop
                           // mm3 ready to be used as Prior(x-bpp) next loop
            jb dpth3lp
         } // end _asm block
      }
      break;

      case 6:
      case 7:
      case 5:
      {
         ActiveMask.use  = 0x00000000ffffffff;
         ActiveMask2.use = 0xffffffff00000000;
         ShiftBpp.use = bpp << 3;    // == bpp * 8
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm
         {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
            pxor mm0, mm0
dpth6lp:
            // Must shift to position Raw(x-bpp) data
            psrlq mm1, ShiftRem
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes
            punpcklbw mm1, mm0      // Unpack Low bytes of a
            movq mm2, [esi + ebx]   // load b=Prior(x)
            punpcklbw mm2, mm0      // Unpack Low bytes of b
            // Must shift to position Prior(x-bpp) data
            psrlq mm3, ShiftRem
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0      // Unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4    // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4       // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5    // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5       // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6    // Create mask pcv bytes < 0
            pand mm0, mm6       // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5    // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6    // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx - 8]  // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            psrlq mm3, ShiftRem
            movq mm2, [esi + ebx]      // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            movq mm6, mm2
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, [edi+ebx-8]
            psllq mm6, ShiftBpp
            movq mm5, mm7
            psrlq mm1, ShiftRem
            por mm3, mm6
            psllq mm5, ShiftBpp
            punpckhbw mm3, mm0         // Unpack High bytes of c
            por mm1, mm5
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack High bytes of b
            punpckhbw mm1, mm0         // Unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6           // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            jb dpth6lp
         } // end _asm block
      }
      break;

      case 4:
      {
         ActiveMask.use  = 0x00000000ffffffff;
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]    // Only time should need to read
                                     //  a=Raw(x-bpp) bytes
dpth4lp:
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]    // read c=Prior(x-bpp) bytes
            punpckhbw mm1, mm0       // Unpack Low bytes of a
            movq mm2, [esi + ebx]    // load b=Prior(x)
            punpcklbw mm2, mm0       // Unpack High bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpckhbw mm3, mm0       // Unpack High bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi + ebx]      // load c=Prior(x-bpp)
            pand mm7, ActiveMask
            movq mm2, mm3              // load b=Prior(x) step 1
            paddb mm7, [edi + ebx]     // add Paeth predictor with Raw(x)
            punpcklbw mm3, mm0         // Unpack High bytes of c
            movq [edi + ebx], mm7      // write back updated value
            movq mm1, mm7              // Now mm1 will be used as Raw(x-bpp)
            // Do second set of 4 bytes
            punpckhbw mm2, mm0         // Unpack Low bytes of b
            punpcklbw mm1, mm0         // Unpack Low bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                                // mm1 will be used as Raw(x-bpp) next loop
            jb dpth4lp
         } // end _asm block
      }
      break;
      case 8:                          // bpp == 8
      {
         ActiveMask.use  = 0x00000000ffffffff;
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, prev_row
            pxor mm0, mm0
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]      // Only time should need to read
                                       //  a=Raw(x-bpp) bytes
dpth8lp:
            // Do first set of 4 bytes
            movq mm3, [esi+ebx-8]      // read c=Prior(x-bpp) bytes
            punpcklbw mm1, mm0         // Unpack Low bytes of a
            movq mm2, [esi + ebx]      // load b=Prior(x)
            punpcklbw mm2, mm0         // Unpack Low bytes of b
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            punpcklbw mm3, mm0         // Unpack Low bytes of c
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            paddw mm7, mm3
            pxor mm0, mm0
            packuswb mm7, mm1
            movq mm3, [esi+ebx-8]    // read c=Prior(x-bpp) bytes
            pand mm7, ActiveMask
            movq mm2, [esi + ebx]    // load b=Prior(x)
            paddb mm7, [edi + ebx]   // add Paeth predictor with Raw(x)
            punpckhbw mm3, mm0       // Unpack High bytes of c
            movq [edi + ebx], mm7    // write back updated value
            movq mm1, [edi+ebx-8]    // read a=Raw(x-bpp) bytes

            // Do second set of 4 bytes
            punpckhbw mm2, mm0       // Unpack High bytes of b
            punpckhbw mm1, mm0       // Unpack High bytes of a
            // pav = p - a = (a + b - c) - a = b - c
            movq mm4, mm2
            // pbv = p - b = (a + b - c) - b = a - c
            movq mm5, mm1
            psubw mm4, mm3
            pxor mm7, mm7
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            movq mm6, mm4
            psubw mm5, mm3
            // pa = abs(p-a) = abs(pav)
            // pb = abs(p-b) = abs(pbv)
            // pc = abs(p-c) = abs(pcv)
            pcmpgtw mm0, mm4       // Create mask pav bytes < 0
            paddw mm6, mm5
            pand mm0, mm4          // Only pav bytes < 0 in mm7
            pcmpgtw mm7, mm5       // Create mask pbv bytes < 0
            psubw mm4, mm0
            pand mm7, mm5          // Only pbv bytes < 0 in mm0
            psubw mm4, mm0
            psubw mm5, mm7
            pxor mm0, mm0
            pcmpgtw mm0, mm6       // Create mask pcv bytes < 0
            pand mm0, mm6          // Only pav bytes < 0 in mm7
            psubw mm5, mm7
            psubw mm6, mm0
            //  test pa <= pb
            movq mm7, mm4
            psubw mm6, mm0
            pcmpgtw mm7, mm5       // pa > pb?
            movq mm0, mm7
            // use mm7 mask to merge pa & pb
            pand mm5, mm7
            // use mm0 mask copy to merge a & b
            pand mm2, mm0
            pandn mm7, mm4
            pandn mm0, mm1
            paddw mm7, mm5
            paddw mm0, mm2
            //  test  ((pa <= pb)? pa:pb) <= pc
            pcmpgtw mm7, mm6       // pab > pc?
            pxor mm1, mm1
            pand mm3, mm7
            pandn mm7, mm0
            pxor mm1, mm1
            paddw mm7, mm3
            pxor mm0, mm0
            // Step ex to next set of 8 bytes and repeat loop til done
            add ebx, 8
            packuswb mm1, mm7
            paddb mm1, [edi + ebx - 8]     // add Paeth predictor with Raw(x)
            cmp ebx, MMXLength
            movq [edi + ebx - 8], mm1      // write back updated value
                            // mm1 will be used as Raw(x-bpp) next loop
            jb dpth8lp
         } // end _asm block
      }
      break;

      case 1:                // bpp = 1
      case 2:                // bpp = 2
      default:               // bpp > 8
      {
         _asm {
            mov ebx, diff
            cmp ebx, FullLength
            jnb dpthdend
            mov edi, row
            mov esi, prev_row
            // Do Paeth decode for remaining bytes
            mov edx, ebx
            xor ecx, ecx        // zero ecx before using cl & cx in loop below
            sub edx, bpp        // Set edx = ebx - bpp
dpthdlp:
            xor eax, eax
            // pav = p - a = (a + b - c) - a = b - c
            mov al, [esi + ebx]        // load Prior(x) into al
            mov cl, [esi + edx]        // load Prior(x-bpp) into cl
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov patemp, eax                 // Save pav for later use
            xor eax, eax
            // pbv = p - b = (a + b - c) - b = a - c
            mov al, [edi + edx]        // load Raw(x-bpp) into al
            sub eax, ecx                 // subtract Prior(x-bpp)
            mov ecx, eax
            // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
            add eax, patemp                 // pcv = pav + pbv
            // pc = abs(pcv)
            test eax, 0x80000000
            jz dpthdpca
            neg eax                     // reverse sign of neg values
dpthdpca:
            mov pctemp, eax             // save pc for later use
            // pb = abs(pbv)
            test ecx, 0x80000000
            jz dpthdpba
            neg ecx                     // reverse sign of neg values
dpthdpba:
            mov pbtemp, ecx             // save pb for later use
            // pa = abs(pav)
            mov eax, patemp
            test eax, 0x80000000
            jz dpthdpaa
            neg eax                     // reverse sign of neg values
dpthdpaa:
            mov patemp, eax             // save pa for later use
            // test if pa <= pb
            cmp eax, ecx
            jna dpthdabb
            // pa > pb; now test if pb <= pc
            cmp ecx, pctemp
            jna dpthdbbc
            // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth
dpthdbbc:
            // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
            mov cl, [esi + ebx]        // load Prior(x) into cl
            jmp dpthdpaeth
dpthdabb:
            // pa <= pb; now test if pa <= pc
            cmp eax, pctemp
            jna dpthdabc
            // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
            mov cl, [esi + edx]  // load Prior(x-bpp) into cl
            jmp dpthdpaeth
dpthdabc:
            // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
            mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthdpaeth:
            inc ebx
            inc edx
            // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
            add [edi + ebx - 1], cl
            cmp ebx, FullLength
            jb dpthdlp
dpthdend:
         } // end _asm block
      }
      return;                   // No need to go further with this one
   }                         // end switch ( bpp )
   _asm
   {
         // MMX acceleration complete now do clean-up
         // Check if any remaining bytes left to decode
         mov ebx, MMXLength
         cmp ebx, FullLength
         jnb dpthend
         mov edi, row
         mov esi, prev_row
         // Do Paeth decode for remaining bytes
         mov edx, ebx
         xor ecx, ecx         // zero ecx before using cl & cx in loop below
         sub edx, bpp         // Set edx = ebx - bpp
dpthlp2:
         xor eax, eax
         // pav = p - a = (a + b - c) - a = b - c
         mov al, [esi + ebx]  // load Prior(x) into al
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         sub eax, ecx         // subtract Prior(x-bpp)
         mov patemp, eax      // Save pav for later use
         xor eax, eax
         // pbv = p - b = (a + b - c) - b = a - c
         mov al, [edi + edx]  // load Raw(x-bpp) into al
         sub eax, ecx         // subtract Prior(x-bpp)
         mov ecx, eax
         // pcv = p - c = (a + b - c) -c = (a - c) + (b - c) = pav + pbv
         add eax, patemp      // pcv = pav + pbv
         // pc = abs(pcv)
         test eax, 0x80000000
         jz dpthpca2
         neg eax              // reverse sign of neg values
dpthpca2:
         mov pctemp, eax      // save pc for later use
         // pb = abs(pbv)
         test ecx, 0x80000000
         jz dpthpba2
         neg ecx              // reverse sign of neg values
dpthpba2:
         mov pbtemp, ecx      // save pb for later use
         // pa = abs(pav)
         mov eax, patemp
         test eax, 0x80000000
         jz dpthpaa2
         neg eax              // reverse sign of neg values
dpthpaa2:
         mov patemp, eax      // save pa for later use
         // test if pa <= pb
         cmp eax, ecx
         jna dpthabb2
         // pa > pb; now test if pb <= pc
         cmp ecx, pctemp
         jna dpthbbc2
         // pb > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2
dpthbbc2:
         // pb <= pc; Raw(x) = Paeth(x) + Prior(x)
         mov cl, [esi + ebx]        // load Prior(x) into cl
         jmp dpthpaeth2
dpthabb2:
         // pa <= pb; now test if pa <= pc
         cmp eax, pctemp
         jna dpthabc2
         // pa > pc; Raw(x) = Paeth(x) + Prior(x-bpp)
         mov cl, [esi + edx]  // load Prior(x-bpp) into cl
         jmp dpthpaeth2
dpthabc2:
         // pa <= pc; Raw(x) = Paeth(x) + Raw(x-bpp)
         mov cl, [edi + edx]  // load Raw(x-bpp) into cl
dpthpaeth2:
         inc ebx
         inc edx
         // Raw(x) = (Paeth(x) + Paeth_Predictor( a, b, c )) mod 256
         add [edi + ebx - 1], cl
         cmp ebx, FullLength
         jb dpthlp2
dpthend:
         emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Sub filter decoder
void /* PRIVATE */
png_read_filter_row_mmx_sub(png_row_infop row_info, png_bytep row)
{
   //int test;
   int bpp;
   png_uint_32 FullLength;
   png_uint_32 MMXLength;
   int diff;

   bpp = (row_info->pixel_depth + 7) >> 3; // Get # bytes per pixel
   FullLength  = row_info->rowbytes - bpp; // # of bytes to filter
   _asm {
        mov edi, row
        mov esi, edi               // lp = row
        add edi, bpp               // rp = row + bpp
        xor eax, eax
        // get # of bytes to alignment
        mov diff, edi               // take start of row
        add diff, 0xf               // add 7 + 8 to incr past
                                        // alignment boundary
        xor ebx, ebx
        and diff, 0xfffffff8        // mask to alignment boundary
        sub diff, edi               // subtract from start ==> value
                                        //  ebx at alignment
        jz dsubgo
        // fix alignment
dsublp1:
        mov al, [esi+ebx]
        add [edi+ebx], al
        inc ebx
        cmp ebx, diff
        jb dsublp1
dsubgo:
        mov ecx, FullLength
        mov edx, ecx
        sub edx, ebx                  // subtract alignment fix
        and edx, 0x00000007           // calc bytes over mult of 8
        sub ecx, edx                  // drop over bytes from length
        mov MMXLength, ecx
   } // end _asm block

   // Now do the math for the rest of the row
   switch ( bpp )
   {
        case 3:
        {
         ActiveMask.use  = 0x0000ffffff000000;
         ShiftBpp.use = 24;       // == 3 * 8
         ShiftRem.use  = 40;      // == 64 - 24
         _asm {
            mov edi, row
            movq mm7, ActiveMask  // Load ActiveMask for 2nd active byte group
            mov esi, edi              // lp = row
            add edi, bpp          // rp = row + bpp
            movq mm6, mm7
            mov ebx, diff
            psllq mm6, ShiftBpp   // Move mask in mm6 to cover 3rd active
                                  // byte group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub3lp:
            psrlq mm1, ShiftRem   // Shift data for adding 1st bpp bytes
                          // no need for mask; shift clears inactive bytes
            // Add 1st active group
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0         // mov updated Raws to mm1
            psllq mm1, ShiftBpp   // shift data to position correctly
            pand mm1, mm7         // mask to use only 2nd active group
            paddb mm0, mm1
            // Add 3rd active group
            movq mm1, mm0         // mov updated Raws to mm1
            psllq mm1, ShiftBpp   // shift data to position correctly
            pand mm1, mm6         // mask to use only 3rd active group
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0     // Write updated Raws back to array
            // Prep for doing 1st add at top of loop
            movq mm1, mm0
            jb dsub3lp
         } // end _asm block
      }
      break;

      case 1:
      {
         // Placed here just in case this is a duplicate of the
         // non-MMX code for the SUB filter in png_read_filter_row below
         //
         //         png_bytep rp;
         //         png_bytep lp;
         //         png_uint_32 i;
         //         bpp = (row_info->pixel_depth + 7) >> 3;
         //         for (i = (png_uint_32)bpp, rp = row + bpp, lp = row;
         //            i < row_info->rowbytes; i++, rp++, lp++)
         //      {
         //            *rp = (png_byte)(((int)(*rp) + (int)(*lp)) & 0xff);
         //      }
         _asm {
            mov ebx, diff
            mov edi, row
            cmp ebx, FullLength
            jnb dsub1end
            mov esi, edi          // lp = row
            xor eax, eax
            add edi, bpp      // rp = row + bpp
dsub1lp:
            mov al, [esi+ebx]
            add [edi+ebx], al
            inc ebx
            cmp ebx, FullLength
            jb dsub1lp
dsub1end:
         } // end _asm block
      }
      return;

      case 6:
      case 7:
      case 4:
      case 5:
      {
         ShiftBpp.use = bpp << 3;
         ShiftRem.use = 64 - ShiftBpp.use;
         _asm {
            mov edi, row
            mov ebx, diff
            mov esi, edi               // lp = row
            add edi, bpp           // rp = row + bpp
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub4lp:
            psrlq mm1, ShiftRem // Shift data for adding 1st bpp bytes
                          // no need for mask; shift clears inactive bytes
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0          // mov updated Raws to mm1
            psllq mm1, ShiftBpp    // shift data to position correctly
                                   // there is no need for any mask
                                   // since shift clears inactive bits/bytes
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0
            movq mm1, mm0          // Prep for doing 1st add at top of loop
            jb dsub4lp
         } // end _asm block
      }
      break;

      case 2:
      {
         ActiveMask.use  = 0x00000000ffff0000;
         ShiftBpp.use = 16;       // == 2 * 8
         ShiftRem.use = 48;       // == 64 - 16
         _asm {
            movq mm7, ActiveMask  // Load ActiveMask for 2nd active byte group
            mov ebx, diff
            movq mm6, mm7
            mov edi, row
            psllq mm6, ShiftBpp     // Move mask in mm6 to cover 3rd active
                                    //  byte group
            mov esi, edi            // lp = row
            movq mm5, mm6
            add edi, bpp            // rp = row + bpp
            psllq mm5, ShiftBpp     // Move mask in mm5 to cover 4th active
                                    //  byte group
            // PRIME the pump (load the first Raw(x-bpp) data set
            movq mm1, [edi+ebx-8]
dsub2lp:
            // Add 1st active group
            psrlq mm1, ShiftRem     // Shift data for adding 1st bpp bytes
                                    // no need for mask; shift clears inactive
                                    //  bytes
            movq mm0, [edi+ebx]
            paddb mm0, mm1
            // Add 2nd active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm7           // mask to use only 2nd active group
            paddb mm0, mm1
            // Add 3rd active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm6           // mask to use only 3rd active group
            paddb mm0, mm1
            // Add 4th active group
            movq mm1, mm0           // mov updated Raws to mm1
            psllq mm1, ShiftBpp     // shift data to position correctly
            pand mm1, mm5           // mask to use only 4th active group
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0   // Write updated Raws back to array
            movq mm1, mm0           // Prep for doing 1st add at top of loop
            jb dsub2lp
         } // end _asm block
      }
      break;
      case 8:
      {
         _asm {
            mov edi, row
            mov ebx, diff
            mov esi, edi            // lp = row
            add edi, bpp            // rp = row + bpp
            mov ecx, MMXLength
            movq mm7, [edi+ebx-8]   // PRIME the pump (load the first
                                    // Raw(x-bpp) data set
            and ecx, 0x0000003f     // calc bytes over mult of 64
dsub8lp:
            movq mm0, [edi+ebx]     // Load Sub(x) for 1st 8 bytes
            paddb mm0, mm7
            movq mm1, [edi+ebx+8]   // Load Sub(x) for 2nd 8 bytes
            movq [edi+ebx], mm0    // Write Raw(x) for 1st 8 bytes
                                   // Now mm0 will be used as Raw(x-bpp) for
                                   // the 2nd group of 8 bytes.  This will be
                                   // repeated for each group of 8 bytes with
                                   // the 8th group being used as the Raw(x-bpp)
                                   // for the 1st group of the next loop.
            paddb mm1, mm0
            movq mm2, [edi+ebx+16]  // Load Sub(x) for 3rd 8 bytes
            movq [edi+ebx+8], mm1   // Write Raw(x) for 2nd 8 bytes
            paddb mm2, mm1
            movq mm3, [edi+ebx+24]  // Load Sub(x) for 4th 8 bytes
            movq [edi+ebx+16], mm2  // Write Raw(x) for 3rd 8 bytes
            paddb mm3, mm2
            movq mm4, [edi+ebx+32]  // Load Sub(x) for 5th 8 bytes
            movq [edi+ebx+24], mm3  // Write Raw(x) for 4th 8 bytes
            paddb mm4, mm3
            movq mm5, [edi+ebx+40]  // Load Sub(x) for 6th 8 bytes
            movq [edi+ebx+32], mm4  // Write Raw(x) for 5th 8 bytes
            paddb mm5, mm4
            movq mm6, [edi+ebx+48]  // Load Sub(x) for 7th 8 bytes
            movq [edi+ebx+40], mm5  // Write Raw(x) for 6th 8 bytes
            paddb mm6, mm5
            movq mm7, [edi+ebx+56]  // Load Sub(x) for 8th 8 bytes
            movq [edi+ebx+48], mm6  // Write Raw(x) for 7th 8 bytes
            add ebx, 64
            paddb mm7, mm6
            cmp ebx, ecx
            movq [edi+ebx-8], mm7   // Write Raw(x) for 8th 8 bytes
            jb dsub8lp
            cmp ebx, MMXLength
            jnb dsub8lt8
dsub8lpA:
            movq mm0, [edi+ebx]
            add ebx, 8
            paddb mm0, mm7
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0   // use -8 to offset early add to ebx
            movq mm7, mm0           // Move calculated Raw(x) data to mm1 to
                                    // be the new Raw(x-bpp) for the next loop
            jb dsub8lpA
dsub8lt8:
         } // end _asm block
      }
      break;

      default:                // bpp greater than 8 bytes
      {
         _asm {
            mov ebx, diff
            mov edi, row
            mov esi, edi           // lp = row
            add edi, bpp           // rp = row + bpp
dsubAlp:
            movq mm0, [edi+ebx]
            movq mm1, [esi+ebx]
            add ebx, 8
            paddb mm0, mm1
            cmp ebx, MMXLength
            movq [edi+ebx-8], mm0  // mov does not affect flags; -8 to offset
                                   //  add ebx
            jb dsubAlp
         } // end _asm block
      }
      break;

   } // end switch ( bpp )

   _asm {
        mov ebx, MMXLength
        mov edi, row
        cmp ebx, FullLength
        jnb dsubend
        mov esi, edi               // lp = row
        xor eax, eax
        add edi, bpp               // rp = row + bpp
dsublp2:
        mov al, [esi+ebx]
        add [edi+ebx], al
        inc ebx
        cmp ebx, FullLength
        jb dsublp2
dsubend:
        emms             // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}

// Optimized code for PNG Up filter decoder
void /* PRIVATE */
png_read_filter_row_mmx_up(png_row_infop row_info, png_bytep row,
   png_bytep prev_row)
{
   png_uint_32 len;
   len  = row_info->rowbytes;       // # of bytes to filter
   _asm {
      mov edi, row
      // get # of bytes to alignment
      mov ecx, edi
      xor ebx, ebx
      add ecx, 0x7
      xor eax, eax
      and ecx, 0xfffffff8
      mov esi, prev_row
      sub ecx, edi
      jz dupgo
      // fix alignment
duplp1:
      mov al, [edi+ebx]
      add al, [esi+ebx]
      inc ebx
      cmp ebx, ecx
      mov [edi + ebx-1], al  // mov does not affect flags; -1 to offset inc ebx
      jb duplp1
dupgo:
      mov ecx, len
      mov edx, ecx
      sub edx, ebx                  // subtract alignment fix
      and edx, 0x0000003f           // calc bytes over mult of 64
      sub ecx, edx                  // drop over bytes from length
      // Unrolled loop - use all MMX registers and interleave to reduce
      // number of branch instructions (loops) and reduce partial stalls
duploop:
      movq mm1, [esi+ebx]
      movq mm0, [edi+ebx]
      movq mm3, [esi+ebx+8]
      paddb mm0, mm1
      movq mm2, [edi+ebx+8]
      movq [edi+ebx], mm0
      paddb mm2, mm3
      movq mm5, [esi+ebx+16]
      movq [edi+ebx+8], mm2
      movq mm4, [edi+ebx+16]
      movq mm7, [esi+ebx+24]
      paddb mm4, mm5
      movq mm6, [edi+ebx+24]
      movq [edi+ebx+16], mm4
      paddb mm6, mm7
      movq mm1, [esi+ebx+32]
      movq [edi+ebx+24], mm6
      movq mm0, [edi+ebx+32]
      movq mm3, [esi+ebx+40]
      paddb mm0, mm1
      movq mm2, [edi+ebx+40]
      movq [edi+ebx+32], mm0
      paddb mm2, mm3
      movq mm5, [esi+ebx+48]
      movq [edi+ebx+40], mm2
      movq mm4, [edi+ebx+48]
      movq mm7, [esi+ebx+56]
      paddb mm4, mm5
      movq mm6, [edi+ebx+56]
      movq [edi+ebx+48], mm4
      add ebx, 64
      paddb mm6, mm7
      cmp ebx, ecx
      movq [edi+ebx-8], mm6 // (+56)movq does not affect flags;
                                     // -8 to offset add ebx
      jb duploop

      cmp edx, 0                     // Test for bytes over mult of 64
      jz dupend


      // 2 lines added by lcreeve@netins.net
      // (mail 11 Jul 98 in png-implement list)
      cmp edx, 8 //test for less than 8 bytes
      jb duplt8


      add ecx, edx
      and edx, 0x00000007           // calc bytes over mult of 8
      sub ecx, edx                  // drop over bytes from length
      jz duplt8
      // Loop using MMX registers mm0 & mm1 to update 8 bytes simultaneously
duplpA:
      movq mm1, [esi+ebx]
      movq mm0, [edi+ebx]
      add ebx, 8
      paddb mm0, mm1
      cmp ebx, ecx
      movq [edi+ebx-8], mm0 // movq does not affect flags; -8 to offset add ebx
      jb duplpA
      cmp edx, 0            // Test for bytes over mult of 8
      jz dupend
duplt8:
      xor eax, eax
      add ecx, edx          // move over byte count into counter
      // Loop using x86 registers to update remaining bytes
duplp2:
      mov al, [edi + ebx]
      add al, [esi + ebx]
      inc ebx
      cmp ebx, ecx
      mov [edi + ebx-1], al // mov does not affect flags; -1 to offset inc ebx
      jb duplp2
dupend:
      // Conversion of filtered row completed
      emms          // End MMX instructions; prep for possible FP instrs.
   } // end _asm block
}


// Optimized png_read_filter_row routines
void /* PRIVATE */
png_read_filter_row(png_structp png_ptr, png_row_infop row_info, png_bytep
   row, png_bytep prev_row, int filter)
{
#ifdef PNG_DEBUG
   char filnm[10];
#endif

   if (mmx_supported == 2) {
       png_mmx_support();
   }

#ifdef PNG_DEBUG
   png_debug(1, "in png_read_filter_row\n");
   switch (filter)
   {
      case 0: sprintf(filnm, "none");
         break;
      case 1: sprintf(filnm, "sub-%s", "MMX");
         break;
      case 2: sprintf(filnm, "up-%s", "MMX");
         break;
      case 3: sprintf(filnm, "avg-%s", "MMX");
         break;
      case 4: sprintf(filnm, "Paeth-%s", "MMX");
         break;
      default: sprintf(filnm, "unknw");
         break;
   }
   png_debug2(0,"row=%5d, %s, ", png_ptr->row_number, filnm);
   png_debug2(0, "pd=%2d, b=%d, ", (int)row_info->pixel_depth,
      (int)((row_info->pixel_depth + 7) >> 3));
   png_debug1(0,"len=%8d, ", row_info->rowbytes);
#endif /* PNG_DEBUG */

   switch (filter)
   {
      case PNG_FILTER_VALUE_NONE:
         break;

      case PNG_FILTER_VALUE_SUB:
      {
         if (
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_sub(row_info, row);
         }
         else
         {
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_bytep rp = row + bpp;
            png_bytep lp = row;

            for (i = bpp; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*lp++)) & 0xff);
               rp++;
            }
         }
         break;
      }

      case PNG_FILTER_VALUE_UP:
      {
         if (
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_up(row_info, row, prev_row);
         }
         else
         {
            png_uint_32 i;
            png_uint_32 istop = row_info->rowbytes;
            png_bytep rp = row;
            png_bytep pp = prev_row;

            for (i = 0; i < istop; ++i)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
               rp++;
            }
         }
         break;
      }

      case PNG_FILTER_VALUE_AVG:
      {
         if (
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_avg(row_info, row, prev_row);
         }
         else
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop = row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++) >> 1)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)
            {
               *rp = (png_byte)(((int)(*rp) +
                  ((int)(*pp++ + *lp++) >> 1)) & 0xff);
               rp++;
            }
         }
         break;
      }

      case PNG_FILTER_VALUE_PAETH:
      {
         if (
             (row_info->pixel_depth >= PNG_MMX_BITDEPTH_THRESHOLD_DEFAULT) &&
             (row_info->rowbytes >= PNG_MMX_ROWBYTES_THRESHOLD_DEFAULT))
         {
            png_read_filter_row_mmx_paeth(row_info, row, prev_row);
         }
         else
         {
            png_uint_32 i;
            png_bytep rp = row;
            png_bytep pp = prev_row;
            png_bytep lp = row;
            png_bytep cp = prev_row;
            png_uint_32 bpp = (row_info->pixel_depth + 7) >> 3;
            png_uint_32 istop=row_info->rowbytes - bpp;

            for (i = 0; i < bpp; i++)
            {
               *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
               rp++;
            }

            for (i = 0; i < istop; i++)   // use leftover rp,pp
            {
               int a, b, c, pa, pb, pc, p;

               a = *lp++;
               b = *pp++;
               c = *cp++;

               p = b - c;
               pc = a - c;

#ifdef PNG_USE_ABS
               pa = abs(p);
               pb = abs(pc);
               pc = abs(p + pc);
#else
               pa = p < 0 ? -p : p;
               pb = pc < 0 ? -pc : pc;
               pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

               /*
                  if (pa <= pb && pa <= pc)
                     p = a;
                  else if (pb <= pc)
                     p = b;
                  else
                     p = c;
                */

               p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

               *rp = (png_byte)(((int)(*rp) + p) & 0xff);
               rp++;
            }
         }
         break;
      }

      default:
         png_warning(png_ptr, "Ignoring bad row filter type");
         *row=0;
         break;
   }
}

#endif /* PNG_ASSEMBLER_CODE_SUPPORTED && PNG_USE_PNGVCRD */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngwrite.c ===
/* pngwrite.c - general routines to write a PNG file
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

/* get internal access to png.h */
#define PNG_INTERNAL
#include "png.h"
#ifdef PNG_WRITE_SUPPORTED

/* Writes all the PNG information.  This is the suggested way to use the
 * library.  If you have a new chunk to add, make a function to write it,
 * and put it in the correct location here.  If you want the chunk written
 * after the image data, put it in png_write_end().  I strongly encourage
 * you to supply a PNG_INFO_ flag, and check info_ptr->valid before writing
 * the chunk, as that will keep the code from breaking if you want to just
 * write a plain PNG file.  If you have long comments, I suggest writing
 * them in png_write_end(), and compressing them.
 */
void PNGAPI
png_write_info_before_PLTE(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_write_info_before_PLTE\n");
   if (!(png_ptr->mode & PNG_WROTE_INFO_BEFORE_PLTE))
   {
   png_write_sig(png_ptr); /* write PNG signature */
#if defined(PNG_MNG_FEATURES_SUPPORTED)
   if((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE)&&(png_ptr->mng_features_permitted))
   {
      png_warning(png_ptr,"MNG features are not allowed in a PNG datastream\n");
      png_ptr->mng_features_permitted=0;
   }
#endif
   /* write IHDR information. */
   png_write_IHDR(png_ptr, info_ptr->width, info_ptr->height,
      info_ptr->bit_depth, info_ptr->color_type, info_ptr->compression_type,
      info_ptr->filter_type,
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
      info_ptr->interlace_type);
#else
      0);
#endif
   /* the rest of these check to see if the valid field has the appropriate
      flag set, and if it does, writes the chunk. */
#if defined(PNG_WRITE_gAMA_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_gAMA)
   {
#  ifdef PNG_FLOATING_POINT_SUPPORTED
      png_write_gAMA(png_ptr, info_ptr->gamma);
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
      png_write_gAMA_fixed(png_ptr, info_ptr->int_gamma);
#  endif
#endif
   }
#endif
#if defined(PNG_WRITE_sRGB_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sRGB)
      png_write_sRGB(png_ptr, (int)info_ptr->srgb_intent);
#endif
#if defined(PNG_WRITE_iCCP_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_iCCP)
      png_write_iCCP(png_ptr, info_ptr->iccp_name, PNG_COMPRESSION_TYPE_BASE,
                     info_ptr->iccp_profile, (int)info_ptr->iccp_proflen);
#endif
#if defined(PNG_WRITE_sBIT_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sBIT)
      png_write_sBIT(png_ptr, &(info_ptr->sig_bit), info_ptr->color_type);
#endif
#if defined(PNG_WRITE_cHRM_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_cHRM)
   {
#ifdef PNG_FLOATING_POINT_SUPPORTED
      png_write_cHRM(png_ptr,
         info_ptr->x_white, info_ptr->y_white,
         info_ptr->x_red, info_ptr->y_red,
         info_ptr->x_green, info_ptr->y_green,
         info_ptr->x_blue, info_ptr->y_blue);
#else
#  ifdef PNG_FIXED_POINT_SUPPORTED
      png_write_cHRM_fixed(png_ptr,
         info_ptr->int_x_white, info_ptr->int_y_white,
         info_ptr->int_x_red, info_ptr->int_y_red,
         info_ptr->int_x_green, info_ptr->int_y_green,
         info_ptr->int_x_blue, info_ptr->int_y_blue);
#  endif
#endif
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   if (info_ptr->unknown_chunks_num)
   {
       png_unknown_chunk *up;

       png_debug(5, "writing extra chunks\n");

       for (up = info_ptr->unknown_chunks;
            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
            up++)
       {
         int keep=png_handle_as_unknown(png_ptr, up->name);
         if (keep != HANDLE_CHUNK_NEVER &&
            up->location && (!(up->location & PNG_HAVE_PLTE)) &&
            ((up->name[3] & 0x20) || keep == HANDLE_CHUNK_ALWAYS ||
            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
         {
            png_write_chunk(png_ptr, up->name, up->data, up->size);
         }
       }
   }
#endif
      png_ptr->mode |= PNG_WROTE_INFO_BEFORE_PLTE;
   }
}

void PNGAPI
png_write_info(png_structp png_ptr, png_infop info_ptr)
{
#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
   int i;
#endif

   png_debug(1, "in png_write_info\n");

   png_write_info_before_PLTE(png_ptr, info_ptr);

   if (info_ptr->valid & PNG_INFO_PLTE)
      png_write_PLTE(png_ptr, info_ptr->palette,
         (png_uint_32)info_ptr->num_palette);
   else if (info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
      png_error(png_ptr, "Valid palette required for paletted images\n");

#if defined(PNG_WRITE_tRNS_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_tRNS)
      {
#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
         /* invert the alpha channel (in tRNS) */
         if ((png_ptr->transformations & PNG_INVERT_ALPHA) &&
            info_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         {
            int j;
            for (j=0; j<(int)info_ptr->num_trans; j++)
               info_ptr->trans[j] = (png_byte)(255 - info_ptr->trans[j]);
         }
#endif
      png_write_tRNS(png_ptr, info_ptr->trans, &(info_ptr->trans_values),
         info_ptr->num_trans, info_ptr->color_type);
      }
#endif
#if defined(PNG_WRITE_bKGD_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_bKGD)
      png_write_bKGD(png_ptr, &(info_ptr->background), info_ptr->color_type);
#endif
#if defined(PNG_WRITE_hIST_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_hIST)
      png_write_hIST(png_ptr, info_ptr->hist, info_ptr->num_palette);
#endif
#if defined(PNG_WRITE_oFFs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_oFFs)
      png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
         info_ptr->offset_unit_type);
#endif
#if defined(PNG_WRITE_pCAL_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pCAL)
      png_write_pCAL(png_ptr, info_ptr->pcal_purpose, info_ptr->pcal_X0,
         info_ptr->pcal_X1, info_ptr->pcal_type, info_ptr->pcal_nparams,
         info_ptr->pcal_units, info_ptr->pcal_params);
#endif
#if defined(PNG_WRITE_sCAL_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sCAL)
#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
      png_write_sCAL(png_ptr, (int)info_ptr->scal_unit,
          info_ptr->scal_pixel_width, info_ptr->scal_pixel_height);
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
      png_write_sCAL_s(png_ptr, (int)info_ptr->scal_unit,
          info_ptr->scal_s_width, info_ptr->scal_s_height);
#else
      png_warning(png_ptr,
          "png_write_sCAL not supported; sCAL chunk not written.\n");
#endif
#endif
#endif
#if defined(PNG_WRITE_pHYs_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_pHYs)
      png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
         info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
#endif
#if defined(PNG_WRITE_tIME_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_tIME)
   {
      png_write_tIME(png_ptr, &(info_ptr->mod_time));
      png_ptr->mode |= PNG_WROTE_tIME;
   }
#endif
#if defined(PNG_WRITE_sPLT_SUPPORTED)
   if (info_ptr->valid & PNG_INFO_sPLT)
     for (i = 0; i < (int)info_ptr->splt_palettes_num; i++)
       png_write_sPLT(png_ptr, info_ptr->splt_palettes + i);
#endif
#if defined(PNG_WRITE_TEXT_SUPPORTED)
   /* Check to see if we need to write text chunks */
   for (i = 0; i < info_ptr->num_text; i++)
   {
      png_debug2(2, "Writing header text chunk %d, type %d\n", i,
         info_ptr->text[i].compression);
      /* an internationalized chunk? */
      if (info_ptr->text[i].compression > 0)
      {
#if defined(PNG_WRITE_iTXt_SUPPORTED)
          /* write international chunk */
          png_write_iTXt(png_ptr,
                         info_ptr->text[i].compression,
                         info_ptr->text[i].key,
                         info_ptr->text[i].lang,
                         info_ptr->text[i].lang_key,
                         info_ptr->text[i].text);
#else
          png_warning(png_ptr, "Unable to write international text\n");
#endif
          /* Mark this chunk as written */
          info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
      }
      /* If we want a compressed text chunk */
      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
      {
#if defined(PNG_WRITE_zTXt_SUPPORTED)
         /* write compressed chunk */
         png_write_zTXt(png_ptr, info_ptr->text[i].key,
            info_ptr->text[i].text, 0,
            info_ptr->text[i].compression);
#else
         png_warning(png_ptr, "Unable to write compressed text\n");
#endif
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
      }
      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
      {
#if defined(PNG_WRITE_tEXt_SUPPORTED)
         /* write uncompressed chunk */
         png_write_tEXt(png_ptr, info_ptr->text[i].key,
                         info_ptr->text[i].text,
                         0);
#else
         png_warning(png_ptr, "Unable to write uncompressed text\n");
#endif
         /* Mark this chunk as written */
         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
      }
   }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   if (info_ptr->unknown_chunks_num)
   {
       png_unknown_chunk *up;

       png_debug(5, "writing extra chunks\n");

       for (up = info_ptr->unknown_chunks;
            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
            up++)
       {
         int keep=png_handle_as_unknown(png_ptr, up->name);
         if (keep != HANDLE_CHUNK_NEVER &&
            up->location && (up->location & PNG_HAVE_PLTE) &&
            !(up->location & PNG_HAVE_IDAT) &&
            ((up->name[3] & 0x20) || keep == HANDLE_CHUNK_ALWAYS ||
            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
         {
            png_write_chunk(png_ptr, up->name, up->data, up->size);
         }
       }
   }
#endif
}

/* Writes the end of the PNG file.  If you don't want to write comments or
 * time information, you can pass NULL for info.  If you already wrote these
 * in png_write_info(), do not write them again here.  If you have long
 * comments, I suggest writing them here, and compressing them.
 */
void PNGAPI
png_write_end(png_structp png_ptr, png_infop info_ptr)
{
   png_debug(1, "in png_write_end\n");
   if (!(png_ptr->mode & PNG_HAVE_IDAT))
      png_error(png_ptr, "No IDATs written into file");

   /* see if user wants us to write information chunks */
   if (info_ptr != NULL)
   {
#if defined(PNG_WRITE_TEXT_SUPPORTED)
      int i; /* local index variable */
#endif
#if defined(PNG_WRITE_tIME_SUPPORTED)
      /* check to see if user has supplied a time chunk */
      if ((info_ptr->valid & PNG_INFO_tIME) &&
         !(png_ptr->mode & PNG_WROTE_tIME))
         png_write_tIME(png_ptr, &(info_ptr->mod_time));
#endif
#if defined(PNG_WRITE_TEXT_SUPPORTED)
      /* loop through comment chunks */
      for (i = 0; i < info_ptr->num_text; i++)
      {
         png_debug2(2, "Writing trailer text chunk %d, type %d\n", i,
            info_ptr->text[i].compression);
         /* an internationalized chunk? */
         if (info_ptr->text[i].compression > 0)
         {
#if defined(PNG_WRITE_iTXt_SUPPORTED)
             /* write international chunk */
             png_write_iTXt(png_ptr,
                         info_ptr->text[i].compression,
                         info_ptr->text[i].key,
                         info_ptr->text[i].lang,
                         info_ptr->text[i].lang_key,
                         info_ptr->text[i].text);
#else
             png_warning(png_ptr, "Unable to write international text\n");
#endif
             /* Mark this chunk as written */
             info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
         }
         else if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
         {
#if defined(PNG_WRITE_zTXt_SUPPORTED)
            /* write compressed chunk */
            png_write_zTXt(png_ptr, info_ptr->text[i].key,
               info_ptr->text[i].text, 0,
               info_ptr->text[i].compression);
#else
            png_warning(png_ptr, "Unable to write compressed text\n");
#endif
            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
         }
         else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
         {
#if defined(PNG_WRITE_tEXt_SUPPORTED)
            /* write uncompressed chunk */
            png_write_tEXt(png_ptr, info_ptr->text[i].key,
               info_ptr->text[i].text, 0);
#else
            png_warning(png_ptr, "Unable to write uncompressed text\n");
#endif

            /* Mark this chunk as written */
            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
         }
      }
#endif
#if defined(PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED)
   if (info_ptr->unknown_chunks_num)
   {
       png_unknown_chunk *up;

       png_debug(5, "writing extra chunks\n");

       for (up = info_ptr->unknown_chunks;
            up < info_ptr->unknown_chunks + info_ptr->unknown_chunks_num;
            up++)
       {
         int keep=png_handle_as_unknown(png_ptr, up->name);
         if (keep != HANDLE_CHUNK_NEVER &&
            up->location && (up->location & PNG_AFTER_IDAT) &&
            ((up->name[3] & 0x20) || keep == HANDLE_CHUNK_ALWAYS ||
            (png_ptr->flags & PNG_FLAG_KEEP_UNSAFE_CHUNKS)))
         {
            png_write_chunk(png_ptr, up->name, up->data, up->size);
         }
       }
   }
#endif
   }

   png_ptr->mode |= PNG_AFTER_IDAT;

   /* write end of PNG file */
   png_write_IEND(png_ptr);
#if 0
/* This flush, added in libpng-1.0.8,  causes some applications to crash
   because they do not set png_ptr->output_flush_fn */
   png_flush(png_ptr);
#endif
}

#if defined(PNG_WRITE_tIME_SUPPORTED)
#if !defined(_WIN32_WCE)
/* "time.h" functions are not supported on WindowsCE */
void PNGAPI
png_convert_from_struct_tm(png_timep ptime, struct tm FAR * ttime)
{
   png_debug(1, "in png_convert_from_struct_tm\n");
   ptime->year = (png_uint_16)(1900 + ttime->tm_year);
   ptime->month = (png_byte)(ttime->tm_mon + 1);
   ptime->day = (png_byte)ttime->tm_mday;
   ptime->hour = (png_byte)ttime->tm_hour;
   ptime->minute = (png_byte)ttime->tm_min;
   ptime->second = (png_byte)ttime->tm_sec;
}

void PNGAPI
png_convert_from_time_t(png_timep ptime, time_t ttime)
{
   struct tm *tbuf;

   png_debug(1, "in png_convert_from_time_t\n");
   tbuf = gmtime(&ttime);
   png_convert_from_struct_tm(ptime, tbuf);
}
#endif
#endif

/* Initialize png_ptr structure, and allocate any memory needed */
png_structp PNGAPI
png_create_write_struct(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn)
{
#ifdef PNG_USER_MEM_SUPPORTED
   return (png_create_write_struct_2(user_png_ver, error_ptr, error_fn,
      warn_fn, NULL, NULL, NULL));
}

/* Alternate initialize png_ptr structure, and allocate any memory needed */
png_structp PNGAPI
png_create_write_struct_2(png_const_charp user_png_ver, png_voidp error_ptr,
   png_error_ptr error_fn, png_error_ptr warn_fn, png_voidp mem_ptr,
   png_malloc_ptr malloc_fn, png_free_ptr free_fn)
{
#endif /* PNG_USER_MEM_SUPPORTED */
   png_structp png_ptr;
#ifdef PNG_SETJMP_SUPPORTED
#ifdef USE_FAR_KEYWORD
   jmp_buf jmpbuf;
#endif
#endif
   int i;
   png_debug(1, "in png_create_write_struct\n");
#ifdef PNG_USER_MEM_SUPPORTED
   if ((png_ptr = (png_structp)png_create_struct_2(PNG_STRUCT_PNG,
      (png_malloc_ptr)malloc_fn)) == NULL)
#else
   if ((png_ptr = (png_structp)png_create_struct(PNG_STRUCT_PNG)) == NULL)
#endif /* PNG_USER_MEM_SUPPORTED */
   {
      return ((png_structp)NULL);
   }

#ifdef PNG_SETJMP_SUPPORTED
#ifdef USE_FAR_KEYWORD
   if (setjmp(jmpbuf))
#else
   if (setjmp(png_ptr->jmpbuf))
#endif
   {
      png_free(png_ptr, png_ptr->zbuf);
      png_ptr->zbuf=NULL;
      png_destroy_struct(png_ptr);
      return ((png_structp)NULL);
   }
#ifdef USE_FAR_KEYWORD
   png_memcpy(png_ptr->jmpbuf,jmpbuf,sizeof(jmp_buf));
#endif
#endif

#ifdef PNG_USER_MEM_SUPPORTED
   png_set_mem_fn(png_ptr, mem_ptr, malloc_fn, free_fn);
#endif /* PNG_USER_MEM_SUPPORTED */
   png_set_error_fn(png_ptr, error_ptr, error_fn, warn_fn);

   i=0;
   do
   {
     if(user_png_ver[i] != png_libpng_ver[i])
        png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
   } while (png_libpng_ver[i++]);

   if (png_ptr->flags & PNG_FLAG_LIBRARY_MISMATCH)
   {
     /* Libpng 0.90 and later are binary incompatible with libpng 0.89, so
      * we must recompile any applications that use any older library version.
      * For versions after libpng 1.0, we will be compatible, so we need
      * only check the first digit.
      */
     if (user_png_ver == NULL || user_png_ver[0] != png_libpng_ver[0] ||
         (user_png_ver[0] == '0' && user_png_ver[2] < '9'))
     {
        png_error(png_ptr,
           "Incompatible libpng version in application and library");
     }

     /* Libpng 1.0.6 was not binary compatible, due to insertion of the
        info_ptr->free_me member.  Note to maintainer: this test can be
        removed from version 2.0.0 and beyond because the previous test
        would have already rejected it. */

     if (user_png_ver[4] == '6' && user_png_ver[2] == '0' &&
         user_png_ver[0] == '1' && user_png_ver[5] == '\0')
     {
        png_error(png_ptr,
           "Application must be recompiled; version 1.0.6 was incompatible");
     }
   }

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);

   png_set_write_fn(png_ptr, NULL, NULL, NULL);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
      1, NULL, NULL);
#endif

   return ((png_structp)png_ptr);
}

/* Initialize png_ptr structure, and allocate any memory needed */
#undef png_write_init
void PNGAPI
png_write_init(png_structp png_ptr)
{
   /* We only come here via pre-1.0.7-compiled applications */
   png_write_init_2(png_ptr, "1.0.0", 10000, 10000);
}

void PNGAPI
png_write_init_2(png_structp png_ptr, png_const_charp user_png_ver,
   png_size_t png_struct_size, png_size_t png_info_size)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp; /* to save current jump buffer */
#endif
   int i = 0;
   do
   {
     if (user_png_ver[i] != png_libpng_ver[i])
     {
#ifdef PNG_LEGACY_SUPPORTED
       png_ptr->flags |= PNG_FLAG_LIBRARY_MISMATCH;
#else
       png_ptr->error_fn=(png_error_ptr)NULL;
       png_error(png_ptr,
       "Application uses deprecated png_write_init() and must be recompiled.");
#endif
     }
   } while (png_libpng_ver[i++]);

   if (sizeof(png_struct) > png_struct_size ||
      sizeof(png_info) > png_info_size)
     {
       png_ptr->error_fn=(png_error_ptr)NULL;
       png_error(png_ptr,
      "Application and library have different sized structs. Please recompile.");
     }

   png_debug(1, "in png_write_init_2\n");

#ifdef PNG_SETJMP_SUPPORTED
   /* save jump buffer and error functions */
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));
#endif

   /* reset all variables to 0 */
   png_memset(png_ptr, 0, sizeof (png_struct));

#ifdef PNG_SETJMP_SUPPORTED
   /* restore jump buffer */
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));
#endif

   /* initialize zbuf - compression buffer */
   png_ptr->zbuf_size = PNG_ZBUF_SIZE;
   png_ptr->zbuf = (png_bytep)png_malloc(png_ptr,
      (png_uint_32)png_ptr->zbuf_size);
   png_set_write_fn(png_ptr, NULL, NULL, NULL);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_set_filter_heuristics(png_ptr, PNG_FILTER_HEURISTIC_DEFAULT,
      1, NULL, NULL);
#endif
}

/* Write a few rows of image data.  If the image is interlaced,
 * either you will have to write the 7 sub images, or, if you
 * have called png_set_interlace_handling(), you will have to
 * "write" the image seven times.
 */
void PNGAPI
png_write_rows(png_structp png_ptr, png_bytepp row,
   png_uint_32 num_rows)
{
   png_uint_32 i; /* row counter */
   png_bytepp rp; /* row pointer */

   png_debug(1, "in png_write_rows\n");
   /* loop through the rows */
   for (i = 0, rp = row; i < num_rows; i++, rp++)
   {
      png_write_row(png_ptr, *rp);
   }
}

/* Write the image.  You only need to call this function once, even
 * if you are writing an interlaced image.
 */
void PNGAPI
png_write_image(png_structp png_ptr, png_bytepp image)
{
   png_uint_32 i; /* row index */
   int pass, num_pass; /* pass variables */
   png_bytepp rp; /* points to current row */

   png_debug(1, "in png_write_image\n");
#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* intialize interlace handling.  If image is not interlaced,
      this will set pass to 1 */
   num_pass = png_set_interlace_handling(png_ptr);
#else
   num_pass = 1;
#endif
   /* loop through passes */
   for (pass = 0; pass < num_pass; pass++)
   {
      /* loop through image */
      for (i = 0, rp = image; i < png_ptr->height; i++, rp++)
      {
         png_write_row(png_ptr, *rp);
      }
   }
}

/* called by user to write a row of image data */
void PNGAPI
png_write_row(png_structp png_ptr, png_bytep row)
{
   png_debug2(1, "in png_write_row (row %ld, pass %d)\n",
      png_ptr->row_number, png_ptr->pass);
   /* initialize transformations and other stuff if first time */
   if (png_ptr->row_number == 0 && png_ptr->pass == 0)
   {
   /* check for transforms that have been set but were defined out */
#if !defined(PNG_WRITE_INVERT_SUPPORTED) && defined(PNG_READ_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_warning(png_ptr, "PNG_WRITE_INVERT_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_FILLER_SUPPORTED) && defined(PNG_READ_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_warning(png_ptr, "PNG_WRITE_FILLER_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_PACKSWAP_SUPPORTED) && defined(PNG_READ_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_warning(png_ptr, "PNG_WRITE_PACKSWAP_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_PACK_SUPPORTED) && defined(PNG_READ_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_warning(png_ptr, "PNG_WRITE_PACK_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_SHIFT_SUPPORTED) && defined(PNG_READ_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_warning(png_ptr, "PNG_WRITE_SHIFT_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_BGR_SUPPORTED) && defined(PNG_READ_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_warning(png_ptr, "PNG_WRITE_BGR_SUPPORTED is not defined.");
#endif
#if !defined(PNG_WRITE_SWAP_SUPPORTED) && defined(PNG_READ_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_warning(png_ptr, "PNG_WRITE_SWAP_SUPPORTED is not defined.");
#endif

      png_write_start_row(png_ptr);
   }

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* if interlaced and not interested in row, return */
   if (png_ptr->interlaced && (png_ptr->transformations & PNG_INTERLACE))
   {
      switch (png_ptr->pass)
      {
         case 0:
            if (png_ptr->row_number & 0x07)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 1:
            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 2:
            if ((png_ptr->row_number & 0x07) != 4)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 3:
            if ((png_ptr->row_number & 0x03) || png_ptr->width < 3)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 4:
            if ((png_ptr->row_number & 0x03) != 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 5:
            if ((png_ptr->row_number & 0x01) || png_ptr->width < 2)
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
         case 6:
            if (!(png_ptr->row_number & 0x01))
            {
               png_write_finish_row(png_ptr);
               return;
            }
            break;
      }
   }
#endif

   /* set up row info for transformations */
   png_ptr->row_info.color_type = png_ptr->color_type;
   png_ptr->row_info.width = png_ptr->usr_width;
   png_ptr->row_info.channels = png_ptr->usr_channels;
   png_ptr->row_info.bit_depth = png_ptr->usr_bit_depth;
   png_ptr->row_info.pixel_depth = (png_byte)(png_ptr->row_info.bit_depth *
      png_ptr->row_info.channels);

   png_ptr->row_info.rowbytes = ((png_ptr->row_info.width *
      (png_uint_32)png_ptr->row_info.pixel_depth + 7) >> 3);

   png_debug1(3, "row_info->color_type = %d\n", png_ptr->row_info.color_type);
   png_debug1(3, "row_info->width = %lu\n", png_ptr->row_info.width);
   png_debug1(3, "row_info->channels = %d\n", png_ptr->row_info.channels);
   png_debug1(3, "row_info->bit_depth = %d\n", png_ptr->row_info.bit_depth);
   png_debug1(3, "row_info->pixel_depth = %d\n", png_ptr->row_info.pixel_depth);
   png_debug1(3, "row_info->rowbytes = %lu\n", png_ptr->row_info.rowbytes);

   /* Copy user's row into buffer, leaving room for filter byte. */
   png_memcpy_check(png_ptr, png_ptr->row_buf + 1, row,
      png_ptr->row_info.rowbytes);

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
   /* handle interlacing */
   if (png_ptr->interlaced && png_ptr->pass < 6 &&
      (png_ptr->transformations & PNG_INTERLACE))
   {
      png_do_write_interlace(&(png_ptr->row_info),
         png_ptr->row_buf + 1, png_ptr->pass);
      /* this should always get caught above, but still ... */
      if (!(png_ptr->row_info.width))
      {
         png_write_finish_row(png_ptr);
         return;
      }
   }
#endif

   /* handle other transformations */
   if (png_ptr->transformations)
      png_do_write_transformations(png_ptr);

#if defined(PNG_MNG_FEATURES_SUPPORTED)
   /* Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
      (png_ptr->filter_type == PNG_INTRAPIXEL_DIFFERENCING))
   {
      /* Intrapixel differencing */
      png_do_write_intrapixel(&(png_ptr->row_info), png_ptr->row_buf + 1);
   }
#endif

   /* Find a filter if necessary, filter the row and write it out. */
   png_write_find_filter(png_ptr, &(png_ptr->row_info));

   if (png_ptr->write_row_fn != NULL)
      (*(png_ptr->write_row_fn))(png_ptr, png_ptr->row_number, png_ptr->pass);
}

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
/* Set the automatic flush interval or 0 to turn flushing off */
void PNGAPI
png_set_flush(png_structp png_ptr, int nrows)
{
   png_debug(1, "in png_set_flush\n");
   png_ptr->flush_dist = (nrows < 0 ? 0 : nrows);
}

/* flush the current output buffers now */
void PNGAPI
png_write_flush(png_structp png_ptr)
{
   int wrote_IDAT;

   png_debug(1, "in png_write_flush\n");
   /* We have already written out all of the data */
   if (png_ptr->row_number >= png_ptr->num_rows)
     return;

   do
   {
      int ret;

      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_SYNC_FLUSH);
      wrote_IDAT = 0;

      /* check for compression errors */
      if (ret != Z_OK)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      if (!(png_ptr->zstream.avail_out))
      {
         /* write the IDAT and reset the zlib output buffer */
         png_write_IDAT(png_ptr, png_ptr->zbuf,
                        png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         wrote_IDAT = 1;
      }
   } while(wrote_IDAT == 1);

   /* If there is any data left to be output, write it into a new IDAT */
   if (png_ptr->zbuf_size != png_ptr->zstream.avail_out)
   {
      /* write the IDAT and reset the zlib output buffer */
      png_write_IDAT(png_ptr, png_ptr->zbuf,
                     png_ptr->zbuf_size - png_ptr->zstream.avail_out);
      png_ptr->zstream.next_out = png_ptr->zbuf;
      png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   }
   png_ptr->flush_rows = 0;
   png_flush(png_ptr);
}
#endif /* PNG_WRITE_FLUSH_SUPPORTED */

/* free all memory used by the write */
void PNGAPI
png_destroy_write_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr)
{
   png_structp png_ptr = NULL;
   png_infop info_ptr = NULL;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn = NULL;
#endif

   png_debug(1, "in png_destroy_write_struct\n");
   if (png_ptr_ptr != NULL)
   {
      png_ptr = *png_ptr_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
      free_fn = png_ptr->free_fn;
#endif
   }

   if (info_ptr_ptr != NULL)
      info_ptr = *info_ptr_ptr;

   if (info_ptr != NULL)
   {
      png_free_data(png_ptr, info_ptr, PNG_FREE_ALL, -1);

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
      if (png_ptr->num_chunk_list)
      {
         png_free(png_ptr, png_ptr->chunk_list);
         png_ptr->chunk_list=NULL;
         png_ptr->num_chunk_list=0;
      }
#endif

#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)info_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)info_ptr);
#endif
      *info_ptr_ptr = (png_infop)NULL;
   }

   if (png_ptr != NULL)
   {
      png_write_destroy(png_ptr);
#ifdef PNG_USER_MEM_SUPPORTED
      png_destroy_struct_2((png_voidp)png_ptr, free_fn);
#else
      png_destroy_struct((png_voidp)png_ptr);
#endif
      *png_ptr_ptr = (png_structp)NULL;
   }
}


/* Free any memory used in png_ptr struct (old method) */
void /* PRIVATE */
png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf tmp_jmp; /* save jump buffer */
#endif
   png_error_ptr error_fn;
   png_error_ptr warning_fn;
   png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_free_ptr free_fn;
#endif

   png_debug(1, "in png_write_destroy\n");
   /* free any memory zlib uses */
   deflateEnd(&png_ptr->zstream);

   /* free our memory.  png_free checks NULL for us. */
   png_free(png_ptr, png_ptr->zbuf);
   png_free(png_ptr, png_ptr->row_buf);
   png_free(png_ptr, png_ptr->prev_row);
   png_free(png_ptr, png_ptr->sub_row);
   png_free(png_ptr, png_ptr->up_row);
   png_free(png_ptr, png_ptr->avg_row);
   png_free(png_ptr, png_ptr->paeth_row);

#if defined(PNG_TIME_RFC1123_SUPPORTED)
   png_free(png_ptr, png_ptr->time_buffer);
#endif

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif

#ifdef PNG_SETJMP_SUPPORTED
   /* reset structure */
   png_memcpy(tmp_jmp, png_ptr->jmpbuf, sizeof (jmp_buf));
#endif

   error_fn = png_ptr->error_fn;
   warning_fn = png_ptr->warning_fn;
   error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   free_fn = png_ptr->free_fn;
#endif

   png_memset(png_ptr, 0, sizeof (png_struct));

   png_ptr->error_fn = error_fn;
   png_ptr->warning_fn = warning_fn;
   png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
   png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
   png_memcpy(png_ptr->jmpbuf, tmp_jmp, sizeof (jmp_buf));
#endif
}

/* Allow the application to select one or more row filters to use. */
void PNGAPI
png_set_filter(png_structp png_ptr, int method, int filters)
{
   png_debug(1, "in png_set_filter\n");
#if defined(PNG_MNG_FEATURES_SUPPORTED)
   if((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
      (method == PNG_INTRAPIXEL_DIFFERENCING))
         method = PNG_FILTER_TYPE_BASE;
#endif
   if (method == PNG_FILTER_TYPE_BASE)
   {
      switch (filters & (PNG_ALL_FILTERS | 0x07))
      {
         case 5:
         case 6:
         case 7: png_warning(png_ptr, "Unknown row filter for method 0");
         case PNG_FILTER_VALUE_NONE:  png_ptr->do_filter=PNG_FILTER_NONE; break;
         case PNG_FILTER_VALUE_SUB:   png_ptr->do_filter=PNG_FILTER_SUB;  break;
         case PNG_FILTER_VALUE_UP:    png_ptr->do_filter=PNG_FILTER_UP;   break;
         case PNG_FILTER_VALUE_AVG:   png_ptr->do_filter=PNG_FILTER_AVG;  break;
         case PNG_FILTER_VALUE_PAETH: png_ptr->do_filter=PNG_FILTER_PAETH;break;
         default: png_ptr->do_filter = (png_byte)filters; break;
      }

      /* If we have allocated the row_buf, this means we have already started
       * with the image and we should have allocated all of the filter buffers
       * that have been selected.  If prev_row isn't already allocated, then
       * it is too late to start using the filters that need it, since we
       * will be missing the data in the previous row.  If an application
       * wants to start and stop using particular filters during compression,
       * it should start out with all of the filters, and then add and
       * remove them after the start of compression.
       */
      if (png_ptr->row_buf != NULL)
      {
         if ((png_ptr->do_filter & PNG_FILTER_SUB) && png_ptr->sub_row == NULL)
         {
            png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
              (png_ptr->rowbytes + 1));
            png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
         }

         if ((png_ptr->do_filter & PNG_FILTER_UP) && png_ptr->up_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Up filter after starting");
               png_ptr->do_filter &= ~PNG_FILTER_UP;
            }
            else
            {
               png_ptr->up_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
            }
         }

         if ((png_ptr->do_filter & PNG_FILTER_AVG) && png_ptr->avg_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Average filter after starting");
               png_ptr->do_filter &= ~PNG_FILTER_AVG;
            }
            else
            {
               png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
            }
         }

         if ((png_ptr->do_filter & PNG_FILTER_PAETH) &&
             png_ptr->paeth_row == NULL)
         {
            if (png_ptr->prev_row == NULL)
            {
               png_warning(png_ptr, "Can't add Paeth filter after starting");
               png_ptr->do_filter &= (png_byte)(~PNG_FILTER_PAETH);
            }
            else
            {
               png_ptr->paeth_row = (png_bytep)png_malloc(png_ptr,
                  (png_ptr->rowbytes + 1));
               png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
            }
         }

         if (png_ptr->do_filter == PNG_NO_FILTERS)
            png_ptr->do_filter = PNG_FILTER_NONE;
      }
   }
   else
      png_error(png_ptr, "Unknown custom filter method");
}

/* This allows us to influence the way in which libpng chooses the "best"
 * filter for the current scanline.  While the "minimum-sum-of-absolute-
 * differences metric is relatively fast and effective, there is some
 * question as to whether it can be improved upon by trying to keep the
 * filtered data going to zlib more consistent, hopefully resulting in
 * better compression.
 */
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)      /* GRR 970116 */
void PNGAPI
png_set_filter_heuristics(png_structp png_ptr, int heuristic_method,
   int num_weights, png_doublep filter_weights,
   png_doublep filter_costs)
{
   int i;

   png_debug(1, "in png_set_filter_heuristics\n");
   if (heuristic_method >= PNG_FILTER_HEURISTIC_LAST)
   {
      png_warning(png_ptr, "Unknown filter heuristic method");
      return;
   }

   if (heuristic_method == PNG_FILTER_HEURISTIC_DEFAULT)
   {
      heuristic_method = PNG_FILTER_HEURISTIC_UNWEIGHTED;
   }

   if (num_weights < 0 || filter_weights == NULL ||
      heuristic_method == PNG_FILTER_HEURISTIC_UNWEIGHTED)
   {
      num_weights = 0;
   }

   png_ptr->num_prev_filters = (png_byte)num_weights;
   png_ptr->heuristic_method = (png_byte)heuristic_method;

   if (num_weights > 0)
   {
      if (png_ptr->prev_filters == NULL)
      {
         png_ptr->prev_filters = (png_bytep)png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_byte) * num_weights));

         /* To make sure that the weighting starts out fairly */
         for (i = 0; i < num_weights; i++)
         {
            png_ptr->prev_filters[i] = 255;
         }
      }

      if (png_ptr->filter_weights == NULL)
      {
         png_ptr->filter_weights = (png_uint_16p)png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_uint_16) * num_weights));

         png_ptr->inv_filter_weights = (png_uint_16p)png_malloc(png_ptr,
            (png_uint_32)(sizeof(png_uint_16) * num_weights));
         for (i = 0; i < num_weights; i++)
         {
            png_ptr->inv_filter_weights[i] =
            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
         }
      }

      for (i = 0; i < num_weights; i++)
      {
         if (filter_weights[i] < 0.0)
         {
            png_ptr->inv_filter_weights[i] =
            png_ptr->filter_weights[i] = PNG_WEIGHT_FACTOR;
         }
         else
         {
            png_ptr->inv_filter_weights[i] =
               (png_uint_16)((double)PNG_WEIGHT_FACTOR*filter_weights[i]+0.5);
            png_ptr->filter_weights[i] =
               (png_uint_16)((double)PNG_WEIGHT_FACTOR/filter_weights[i]+0.5);
         }
      }
   }

   /* If, in the future, there are other filter methods, this would
    * need to be based on png_ptr->filter.
    */
   if (png_ptr->filter_costs == NULL)
   {
      png_ptr->filter_costs = (png_uint_16p)png_malloc(png_ptr,
         (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));

      png_ptr->inv_filter_costs = (png_uint_16p)png_malloc(png_ptr,
         (png_uint_32)(sizeof(png_uint_16) * PNG_FILTER_VALUE_LAST));

      for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
      {
         png_ptr->inv_filter_costs[i] =
         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
      }
   }

   /* Here is where we set the relative costs of the different filters.  We
    * should take the desired compression level into account when setting
    * the costs, so that Paeth, for instance, has a high relative cost at low
    * compression levels, while it has a lower relative cost at higher
    * compression settings.  The filter types are in order of increasing
    * relative cost, so it would be possible to do this with an algorithm.
    */
   for (i = 0; i < PNG_FILTER_VALUE_LAST; i++)
   {
      if (filter_costs == NULL || filter_costs[i] < 0.0)
      {
         png_ptr->inv_filter_costs[i] =
         png_ptr->filter_costs[i] = PNG_COST_FACTOR;
      }
      else if (filter_costs[i] >= 1.0)
      {
         png_ptr->inv_filter_costs[i] =
            (png_uint_16)((double)PNG_COST_FACTOR / filter_costs[i] + 0.5);
         png_ptr->filter_costs[i] =
            (png_uint_16)((double)PNG_COST_FACTOR * filter_costs[i] + 0.5);
      }
   }
}
#endif /* PNG_WRITE_WEIGHTED_FILTER_SUPPORTED */

void PNGAPI
png_set_compression_level(png_structp png_ptr, int level)
{
   png_debug(1, "in png_set_compression_level\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_LEVEL;
   png_ptr->zlib_level = level;
}

void PNGAPI
png_set_compression_mem_level(png_structp png_ptr, int mem_level)
{
   png_debug(1, "in png_set_compression_mem_level\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL;
   png_ptr->zlib_mem_level = mem_level;
}

void PNGAPI
png_set_compression_strategy(png_structp png_ptr, int strategy)
{
   png_debug(1, "in png_set_compression_strategy\n");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_STRATEGY;
   png_ptr->zlib_strategy = strategy;
}

void PNGAPI
png_set_compression_window_bits(png_structp png_ptr, int window_bits)
{
   if (window_bits > 15)
      png_warning(png_ptr, "Only compression windows <= 32k supported by PNG");
   else if (window_bits < 8)
      png_warning(png_ptr, "Only compression windows >= 256 supported by PNG");
#ifndef WBITS_8_OK
   /* avoid libpng bug with 256-byte windows */
   if (window_bits == 8)
     {
       png_warning(png_ptr, "Compression window is being reset to 512");
       window_bits=9;
     }
#endif
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS;
   png_ptr->zlib_window_bits = window_bits;
}

void PNGAPI
png_set_compression_method(png_structp png_ptr, int method)
{
   png_debug(1, "in png_set_compression_method\n");
   if (method != 8)
      png_warning(png_ptr, "Only compression method 8 is supported by PNG");
   png_ptr->flags |= PNG_FLAG_ZLIB_CUSTOM_METHOD;
   png_ptr->zlib_method = method;
}

void PNGAPI
png_set_write_status_fn(png_structp png_ptr, png_write_status_ptr write_row_fn)
{
   png_ptr->write_row_fn = write_row_fn;
}

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
void PNGAPI
png_set_write_user_transform_fn(png_structp png_ptr, png_user_transform_ptr
   write_user_transform_fn)
{
   png_debug(1, "in png_set_write_user_transform_fn\n");
   png_ptr->transformations |= PNG_USER_TRANSFORM;
   png_ptr->write_user_transform_fn = write_user_transform_fn;
}
#endif


#if defined(PNG_INFO_IMAGE_SUPPORTED)
void PNGAPI
png_write_png(png_structp png_ptr, png_infop info_ptr,
              int transforms, voidp params)
{
#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
   /* invert the alpha channel from opacity to transparency */
   if (transforms & PNG_TRANSFORM_INVERT_ALPHA)
       png_set_invert_alpha(png_ptr);
#endif

   /* Write the file header information. */
   png_write_info(png_ptr, info_ptr);

   /* ------ these transformations don't touch the info structure ------- */

#if defined(PNG_WRITE_INVERT_SUPPORTED)
   /* invert monochrome pixels */
   if (transforms & PNG_TRANSFORM_INVERT_MONO)
       png_set_invert_mono(png_ptr);
#endif

#if defined(PNG_WRITE_SHIFT_SUPPORTED)
   /* Shift the pixels up to a legal bit depth and fill in
    * as appropriate to correctly scale the image.
    */
   if ((transforms & PNG_TRANSFORM_SHIFT)
               && (info_ptr->valid & PNG_INFO_sBIT))
       png_set_shift(png_ptr, &info_ptr->sig_bit);
#endif

#if defined(PNG_WRITE_PACK_SUPPORTED)
   /* pack pixels into bytes */
   if (transforms & PNG_TRANSFORM_PACKING)
       png_set_packing(png_ptr);
#endif

#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
   /* swap location of alpha bytes from ARGB to RGBA */
   if (transforms & PNG_TRANSFORM_SWAP_ALPHA)
       png_set_swap_alpha(png_ptr);
#endif

#if defined(PNG_WRITE_FILLER_SUPPORTED)
   /* Get rid of filler (OR ALPHA) bytes, pack XRGB/RGBX/ARGB/RGBA into
    * RGB (4 channels -> 3 channels). The second parameter is not used.
    */
   if (transforms & PNG_TRANSFORM_STRIP_FILLER)
       png_set_filler(png_ptr, 0, PNG_FILLER_BEFORE);
#endif

#if defined(PNG_WRITE_BGR_SUPPORTED)
   /* flip BGR pixels to RGB */
   if (transforms & PNG_TRANSFORM_BGR)
       png_set_bgr(png_ptr);
#endif

#if defined(PNG_WRITE_SWAP_SUPPORTED)
   /* swap bytes of 16-bit files to most significant byte first */
   if (transforms & PNG_TRANSFORM_SWAP_ENDIAN)
       png_set_swap(png_ptr);
#endif

#if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
   /* swap bits of 1, 2, 4 bit packed pixel formats */
   if (transforms & PNG_TRANSFORM_PACKSWAP)
       png_set_packswap(png_ptr);
#endif

   /* ----------------------- end of transformations ------------------- */

   /* write the bits */
   if (info_ptr->valid & PNG_INFO_IDAT)
       png_write_image(png_ptr, info_ptr->row_pointers);

   /* It is REQUIRED to call this to finish writing the rest of the file */
   png_write_end(png_ptr, info_ptr);

   if(transforms == 0 || params == NULL)
      /* quiet compiler warnings */ return;
}
#endif
#endif /* PNG_WRITE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngwutil.c ===
/* pngwutil.c - utilities to write a PNG file
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"
#ifdef PNG_WRITE_SUPPORTED

/* Place a 32-bit number into a buffer in PNG byte order.  We work
 * with unsigned numbers for convenience, although one supported
 * ancillary chunk uses signed (two's complement) numbers.
 */
void /* PRIVATE */
png_save_uint_32(png_bytep buf, png_uint_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}

#if defined(PNG_WRITE_pCAL_SUPPORTED)
/* The png_save_int_32 function assumes integers are stored in two's
 * complement format.  If this isn't the case, then this routine needs to
 * be modified to write data in two's complement format.
 */
void /* PRIVATE */
png_save_int_32(png_bytep buf, png_int_32 i)
{
   buf[0] = (png_byte)((i >> 24) & 0xff);
   buf[1] = (png_byte)((i >> 16) & 0xff);
   buf[2] = (png_byte)((i >> 8) & 0xff);
   buf[3] = (png_byte)(i & 0xff);
}
#endif

/* Place a 16-bit number into a buffer in PNG byte order.
 * The parameter is declared unsigned int, not png_uint_16,
 * just to avoid potential problems on pre-ANSI C compilers.
 */
void /* PRIVATE */
png_save_uint_16(png_bytep buf, unsigned int i)
{
   buf[0] = (png_byte)((i >> 8) & 0xff);
   buf[1] = (png_byte)(i & 0xff);
}

/* Write a PNG chunk all at once.  The type is an array of ASCII characters
 * representing the chunk name.  The array must be at least 4 bytes in
 * length, and does not need to be null terminated.  To be safe, pass the
 * pre-defined chunk names here, and if you need a new one, define it
 * where the others are defined.  The length is the length of the data.
 * All the data must be present.  If that is not possible, use the
 * png_write_chunk_start(), png_write_chunk_data(), and png_write_chunk_end()
 * functions instead.
 */
void PNGAPI
png_write_chunk(png_structp png_ptr, png_bytep chunk_name,
   png_bytep data, png_size_t length)
{
   png_write_chunk_start(png_ptr, chunk_name, (png_uint_32)length);
   png_write_chunk_data(png_ptr, data, length);
   png_write_chunk_end(png_ptr);
}

/* Write the start of a PNG chunk.  The type is the chunk type.
 * The total_length is the sum of the lengths of all the data you will be
 * passing in png_write_chunk_data().
 */
void PNGAPI
png_write_chunk_start(png_structp png_ptr, png_bytep chunk_name,
   png_uint_32 length)
{
   png_byte buf[4];
   png_debug2(0, "Writing %s chunk (%lu bytes)\n", chunk_name, length);

   /* write the length */
   png_save_uint_32(buf, length);
   png_write_data(png_ptr, buf, (png_size_t)4);

   /* write the chunk name */
   png_write_data(png_ptr, chunk_name, (png_size_t)4);
   /* reset the crc and run it over the chunk name */
   png_reset_crc(png_ptr);
   png_calculate_crc(png_ptr, chunk_name, (png_size_t)4);
}

/* Write the data of a PNG chunk started with png_write_chunk_start().
 * Note that multiple calls to this function are allowed, and that the
 * sum of the lengths from these calls *must* add up to the total_length
 * given to png_write_chunk_start().
 */
void PNGAPI
png_write_chunk_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   /* write the data, and run the CRC over it */
   if (data != NULL && length > 0)
   {
      png_calculate_crc(png_ptr, data, length);
      png_write_data(png_ptr, data, length);
   }
}

/* Finish a chunk started with png_write_chunk_start(). */
void PNGAPI
png_write_chunk_end(png_structp png_ptr)
{
   png_byte buf[4];

   /* write the crc */
   png_save_uint_32(buf, png_ptr->crc);

   png_write_data(png_ptr, buf, (png_size_t)4);
}

/* Simple function to write the signature.  If we have already written
 * the magic bytes of the signature, or more likely, the PNG stream is
 * being embedded into another stream and doesn't need its own signature,
 * we should call png_set_sig_bytes() to tell libpng how many of the
 * bytes have already been written.
 */
void /* PRIVATE */
png_write_sig(png_structp png_ptr)
{
   png_byte png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10};
   /* write the rest of the 8 byte signature */
   png_write_data(png_ptr, &png_signature[png_ptr->sig_bytes],
      (png_size_t)8 - png_ptr->sig_bytes);
   if(png_ptr->sig_bytes < 3)
      png_ptr->mode |= PNG_HAVE_PNG_SIGNATURE;
}

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_iCCP_SUPPORTED)
/*
 * This pair of functions encapsulates the operation of (a) compressing a
 * text string, and (b) issuing it later as a series of chunk data writes.
 * The compression_state structure is shared context for these functions
 * set up by the caller in order to make the whole mess thread-safe.
 */

typedef struct
{
    char *input;   /* the uncompressed input data */
    int input_len;   /* its length */
    int num_output_ptr; /* number of output pointers used */
    int max_output_ptr; /* size of output_ptr */
    png_charpp output_ptr; /* array of pointers to output */
} compression_state;

/* compress given text into storage in the png_ptr structure */
static int /* PRIVATE */
png_text_compress(png_structp png_ptr,
        png_charp text, png_size_t text_len, int compression,
        compression_state *comp)
{
   int ret;

   comp->num_output_ptr = comp->max_output_ptr = 0;
   comp->output_ptr = NULL;
   comp->input = NULL;

   /* we may just want to pass the text right through */
   if (compression == PNG_TEXT_COMPRESSION_NONE)
   {
       comp->input = text;
       comp->input_len = text_len;
       return((int)text_len);
   }

   if (compression >= PNG_TEXT_COMPRESSION_LAST)
   {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
      char msg[50];
      sprintf(msg, "Unknown compression type %d", compression);
      png_warning(png_ptr, msg);
#else
      png_warning(png_ptr, "Unknown compression type");
#endif
   }

   /* We can't write the chunk until we find out how much data we have,
    * which means we need to run the compressor first and save the
    * output.  This shouldn't be a problem, as the vast majority of
    * comments should be reasonable, but we will set up an array of
    * malloc'd pointers to be sure.
    *
    * If we knew the application was well behaved, we could simplify this
    * greatly by assuming we can always malloc an output buffer large
    * enough to hold the compressed text ((1001 * text_len / 1000) + 12)
    * and malloc this directly.  The only time this would be a bad idea is
    * if we can't malloc more than 64K and we have 64K of random input
    * data, or if the input string is incredibly large (although this
    * wouldn't cause a failure, just a slowdown due to swapping).
    */

   /* set up the compression buffers */
   png_ptr->zstream.avail_in = (uInt)text_len;
   png_ptr->zstream.next_in = (Bytef *)text;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = (Bytef *)png_ptr->zbuf;

   /* this is the same compression loop as in png_write_row() */
   do
   {
      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      if (ret != Z_OK)
      {
         /* error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
      /* check to see if we need more room */
      if (!png_ptr->zstream.avail_out && png_ptr->zstream.avail_in)
      {
         /* make sure the output array has room */
         if (comp->num_output_ptr >= comp->max_output_ptr)
         {
            int old_max;

            old_max = comp->max_output_ptr;
            comp->max_output_ptr = comp->num_output_ptr + 4;
            if (comp->output_ptr != NULL)
            {
               png_charpp old_ptr;

               old_ptr = comp->output_ptr;
               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(comp->max_output_ptr * sizeof (png_charpp)));
               png_memcpy(comp->output_ptr, old_ptr, old_max
                  * sizeof (png_charp));
               png_free(png_ptr, old_ptr);
            }
            else
               comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                  (png_uint_32)(comp->max_output_ptr * sizeof (png_charp)));
         }

         /* save the data */
         comp->output_ptr[comp->num_output_ptr] = (png_charp)png_malloc(png_ptr,
            (png_uint_32)png_ptr->zbuf_size);
         png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
            png_ptr->zbuf_size);
         comp->num_output_ptr++;

         /* and reset the buffer */
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         png_ptr->zstream.next_out = png_ptr->zbuf;
      }
   /* continue until we don't have any more to compress */
   } while (png_ptr->zstream.avail_in);

   /* finish the compression */
   do
   {
      /* tell zlib we are finished */
      ret = deflate(&png_ptr->zstream, Z_FINISH);

      if (ret == Z_OK)
      {
         /* check to see if we need more room */
         if (!(png_ptr->zstream.avail_out))
         {
            /* check to make sure our output array has room */
            if (comp->num_output_ptr >= comp->max_output_ptr)
            {
               int old_max;

               old_max = comp->max_output_ptr;
               comp->max_output_ptr = comp->num_output_ptr + 4;
               if (comp->output_ptr != NULL)
               {
                  png_charpp old_ptr;

                  old_ptr = comp->output_ptr;
                  /* This could be optimized to realloc() */
                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                     (png_uint_32)(comp->max_output_ptr * sizeof (png_charpp)));
                  png_memcpy(comp->output_ptr, old_ptr,
                       old_max * sizeof (png_charp));
                  png_free(png_ptr, old_ptr);
               }
               else
                  comp->output_ptr = (png_charpp)png_malloc(png_ptr,
                     (png_uint_32)(comp->max_output_ptr * sizeof (png_charp)));
            }

            /* save off the data */
            comp->output_ptr[comp->num_output_ptr] =
               (png_charp)png_malloc(png_ptr, (png_uint_32)png_ptr->zbuf_size);
            png_memcpy(comp->output_ptr[comp->num_output_ptr], png_ptr->zbuf,
               png_ptr->zbuf_size);
            comp->num_output_ptr++;

            /* and reset the buffer pointers */
            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
            png_ptr->zstream.next_out = png_ptr->zbuf;
         }
      }
      else if (ret != Z_STREAM_END)
      {
         /* we got an error */
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
   } while (ret != Z_STREAM_END);

   /* text length is number of buffers plus last buffer */
   text_len = png_ptr->zbuf_size * comp->num_output_ptr;
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
      text_len += png_ptr->zbuf_size - (png_size_t)png_ptr->zstream.avail_out;

   return((int)text_len);
}

/* ship the compressed text out via chunk writes */
static void /* PRIVATE */
png_write_compressed_data_out(png_structp png_ptr, compression_state *comp)
{
   int i;

   /* handle the no-compression case */
   if (comp->input)
   {
       png_write_chunk_data(png_ptr, (png_bytep)comp->input, comp->input_len);
       return;
   }

   /* write saved output buffers, if any */
   for (i = 0; i < comp->num_output_ptr; i++)
   {
      png_write_chunk_data(png_ptr,(png_bytep)comp->output_ptr[i],
         png_ptr->zbuf_size);
      png_free(png_ptr, comp->output_ptr[i]);
      comp->output_ptr[i]=NULL;
   }
   if (comp->max_output_ptr != 0)
      png_free(png_ptr, comp->output_ptr);
      comp->output_ptr=NULL;
   /* write anything left in zbuf */
   if (png_ptr->zstream.avail_out < (png_uint_32)png_ptr->zbuf_size)
      png_write_chunk_data(png_ptr, png_ptr->zbuf,
         png_ptr->zbuf_size - png_ptr->zstream.avail_out);

   /* reset zlib for another zTXt/iTXt or the image data */
   deflateReset(&png_ptr->zstream);

}
#endif

/* Write the IHDR chunk, and update the png_struct with the necessary
 * information.  Note that the rest of this code depends upon this
 * information being correct.
 */
void /* PRIVATE */
png_write_IHDR(png_structp png_ptr, png_uint_32 width, png_uint_32 height,
   int bit_depth, int color_type, int compression_type, int filter_type,
   int interlace_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IHDR;
#endif
   png_byte buf[13]; /* buffer to store the IHDR info */

   png_debug(1, "in png_write_IHDR\n");
   /* Check that we have valid input data from the application info */
   switch (color_type)
   {
      case PNG_COLOR_TYPE_GRAY:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8:
            case 16: png_ptr->channels = 1; break;
            default: png_error(png_ptr,"Invalid bit depth for grayscale image");
         }
         break;
      case PNG_COLOR_TYPE_RGB:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGB image");
         png_ptr->channels = 3;
         break;
      case PNG_COLOR_TYPE_PALETTE:
         switch (bit_depth)
         {
            case 1:
            case 2:
            case 4:
            case 8: png_ptr->channels = 1; break;
            default: png_error(png_ptr, "Invalid bit depth for paletted image");
         }
         break;
      case PNG_COLOR_TYPE_GRAY_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for grayscale+alpha image");
         png_ptr->channels = 2;
         break;
      case PNG_COLOR_TYPE_RGB_ALPHA:
         if (bit_depth != 8 && bit_depth != 16)
            png_error(png_ptr, "Invalid bit depth for RGBA image");
         png_ptr->channels = 4;
         break;
      default:
         png_error(png_ptr, "Invalid image color type specified");
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid compression type specified");
      compression_type = PNG_COMPRESSION_TYPE_BASE;
   }

   /* Write filter_method 64 (intrapixel differencing) only if
    * 1. Libpng was compiled with PNG_MNG_FEATURES_SUPPORTED and
    * 2. Libpng did not write a PNG signature (this filter_method is only
    *    used in PNG datastreams that are embedded in MNG datastreams) and
    * 3. The application called png_permit_mng_features with a mask that
    *    included PNG_FLAG_MNG_FILTER_64 and
    * 4. The filter_method is 64 and
    * 5. The color_type is RGB or RGBA
    */
   if (
#if defined(PNG_MNG_FEATURES_SUPPORTED)
      !((png_ptr->mng_features_permitted & PNG_FLAG_MNG_FILTER_64) &&
      ((png_ptr->mode&PNG_HAVE_PNG_SIGNATURE) == 0) &&
      (color_type == PNG_COLOR_TYPE_RGB || 
       color_type == PNG_COLOR_TYPE_RGB_ALPHA) &&
      (filter_type == PNG_INTRAPIXEL_DIFFERENCING)) &&
#endif
      filter_type != PNG_FILTER_TYPE_BASE)
   {
      png_warning(png_ptr, "Invalid filter type specified");
      filter_type = PNG_FILTER_TYPE_BASE;
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   if (interlace_type != PNG_INTERLACE_NONE &&
      interlace_type != PNG_INTERLACE_ADAM7)
   {
      png_warning(png_ptr, "Invalid interlace type specified");
      interlace_type = PNG_INTERLACE_ADAM7;
   }
#else
   interlace_type=PNG_INTERLACE_NONE;
#endif

   /* save off the relevent information */
   png_ptr->bit_depth = (png_byte)bit_depth;
   png_ptr->color_type = (png_byte)color_type;
   png_ptr->interlaced = (png_byte)interlace_type;
   png_ptr->filter_type = (png_byte)filter_type;
   png_ptr->width = width;
   png_ptr->height = height;

   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
   png_ptr->rowbytes = ((width * (png_size_t)png_ptr->pixel_depth + 7) >> 3);
   /* set the usr info, so any transformations can modify it */
   png_ptr->usr_width = png_ptr->width;
   png_ptr->usr_bit_depth = png_ptr->bit_depth;
   png_ptr->usr_channels = png_ptr->channels;

   /* pack the header information into the buffer */
   png_save_uint_32(buf, width);
   png_save_uint_32(buf + 4, height);
   buf[8] = (png_byte)bit_depth;
   buf[9] = (png_byte)color_type;
   buf[10] = (png_byte)compression_type;
   buf[11] = (png_byte)filter_type;
   buf[12] = (png_byte)interlace_type;

   /* write the chunk */
   png_write_chunk(png_ptr, (png_bytep)png_IHDR, buf, (png_size_t)13);

   /* initialize zlib with PNG info */
   png_ptr->zstream.zalloc = png_zalloc;
   png_ptr->zstream.zfree = png_zfree;
   png_ptr->zstream.opaque = (voidpf)png_ptr;
   if (!(png_ptr->do_filter))
   {
      if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE ||
         png_ptr->bit_depth < 8)
         png_ptr->do_filter = PNG_FILTER_NONE;
      else
         png_ptr->do_filter = PNG_ALL_FILTERS;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_STRATEGY))
   {
      if (png_ptr->do_filter != PNG_FILTER_NONE)
         png_ptr->zlib_strategy = Z_FILTERED;
      else
         png_ptr->zlib_strategy = Z_DEFAULT_STRATEGY;
   }
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_LEVEL))
      png_ptr->zlib_level = Z_DEFAULT_COMPRESSION;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_MEM_LEVEL))
      png_ptr->zlib_mem_level = 8;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_WINDOW_BITS))
      png_ptr->zlib_window_bits = 15;
   if (!(png_ptr->flags & PNG_FLAG_ZLIB_CUSTOM_METHOD))
      png_ptr->zlib_method = 8;
   deflateInit2(&png_ptr->zstream, png_ptr->zlib_level,
      png_ptr->zlib_method, png_ptr->zlib_window_bits,
      png_ptr->zlib_mem_level, png_ptr->zlib_strategy);
   png_ptr->zstream.next_out = png_ptr->zbuf;
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;

   png_ptr->mode = PNG_HAVE_IHDR;
}

/* write the palette.  We are careful not to trust png_color to be in the
 * correct order for PNG, so people can redefine it to any convenient
 * structure.
 */
void /* PRIVATE */
png_write_PLTE(png_structp png_ptr, png_colorp palette, png_uint_32 num_pal)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_PLTE;
#endif
   png_uint_32 i;
   png_colorp pal_ptr;
   png_byte buf[3];

   png_debug(1, "in png_write_PLTE\n");
   if ((
#if defined(PNG_MNG_FEATURES_SUPPORTED) || \
    defined (PNG_WRITE_EMPTY_PLTE_SUPPORTED)
        !(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE) &&
#endif
        num_pal == 0) || num_pal > 256)
     {
       if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)
         {
           png_error(png_ptr, "Invalid number of colors in palette");
         }
       else
         {
           png_warning(png_ptr, "Invalid number of colors in palette");
           return;
         }
   }

   png_ptr->num_palette = (png_uint_16)num_pal;
   png_debug1(3, "num_palette = %d\n", png_ptr->num_palette);

   png_write_chunk_start(png_ptr, (png_bytep)png_PLTE, num_pal * 3);
#ifndef PNG_NO_POINTER_INDEXING
   for (i = 0, pal_ptr = palette; i < num_pal; i++, pal_ptr++)
   {
      buf[0] = pal_ptr->red;
      buf[1] = pal_ptr->green;
      buf[2] = pal_ptr->blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }
#else
   /* This is a little slower but some buggy compilers need to do this instead */
   pal_ptr=palette;
   for (i = 0; i < num_pal; i++)
   {
      buf[0] = pal_ptr[i].red;
      buf[1] = pal_ptr[i].green;
      buf[2] = pal_ptr[i].blue;
      png_write_chunk_data(png_ptr, buf, (png_size_t)3);
   }
#endif
   png_write_chunk_end(png_ptr);
   png_ptr->mode |= PNG_HAVE_PLTE;
}

/* write an IDAT chunk */
void /* PRIVATE */
png_write_IDAT(png_structp png_ptr, png_bytep data, png_size_t length)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IDAT;
#endif
   png_debug(1, "in png_write_IDAT\n");
   png_write_chunk(png_ptr, (png_bytep)png_IDAT, data, length);
   png_ptr->mode |= PNG_HAVE_IDAT;
}

/* write an IEND chunk */
void /* PRIVATE */
png_write_IEND(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_IEND;
#endif
   png_debug(1, "in png_write_IEND\n");
   png_write_chunk(png_ptr, (png_bytep)png_IEND, NULL, (png_size_t)0);
   png_ptr->mode |= PNG_HAVE_IEND;
}

#if defined(PNG_WRITE_gAMA_SUPPORTED)
/* write a gAMA chunk */
#ifdef PNG_FLOATING_POINT_SUPPORTED
void /* PRIVATE */
png_write_gAMA(png_structp png_ptr, double file_gamma)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_gAMA;
#endif
   png_uint_32 igamma;
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA\n");
   /* file_gamma is saved in 1/100,000ths */
   igamma = (png_uint_32)(file_gamma * 100000.0 + 0.5);
   png_save_uint_32(buf, igamma);
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_gAMA_fixed(png_structp png_ptr, png_fixed_point file_gamma)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_gAMA;
#endif
   png_byte buf[4];

   png_debug(1, "in png_write_gAMA\n");
   /* file_gamma is saved in 1/100,000ths */
   png_save_uint_32(buf, file_gamma);
   png_write_chunk(png_ptr, (png_bytep)png_gAMA, buf, (png_size_t)4);
}
#endif
#endif

#if defined(PNG_WRITE_sRGB_SUPPORTED)
/* write a sRGB chunk */
void /* PRIVATE */
png_write_sRGB(png_structp png_ptr, int srgb_intent)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sRGB;
#endif
   png_byte buf[1];

   png_debug(1, "in png_write_sRGB\n");
   if(srgb_intent >= PNG_sRGB_INTENT_LAST)
         png_warning(png_ptr,
            "Invalid sRGB rendering intent specified");
   buf[0]=(png_byte)srgb_intent;
   png_write_chunk(png_ptr, (png_bytep)png_sRGB, buf, (png_size_t)1);
}
#endif

#if defined(PNG_WRITE_iCCP_SUPPORTED)
/* write an iCCP chunk */
void /* PRIVATE */
png_write_iCCP(png_structp png_ptr, png_charp name, int compression_type,
   png_charp profile, int profile_len)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_iCCP;
#endif
   png_size_t name_len;
   png_charp new_name;
   compression_state comp;

   png_debug(1, "in png_write_iCCP\n");
   if (name == NULL || (name_len = png_check_keyword(png_ptr, name,
      &new_name)) == 0)
   {
      png_warning(png_ptr, "Empty keyword in iCCP chunk");
      return;
   }

   if (compression_type != PNG_COMPRESSION_TYPE_BASE)
      png_warning(png_ptr, "Unknown compression type in iCCP chunk");

   if (profile == NULL)
      profile_len = 0;

   if (profile_len)
       profile_len = png_text_compress(png_ptr, profile, (png_size_t)profile_len,
          PNG_COMPRESSION_TYPE_BASE, &comp);

   /* make sure we include the NULL after the name and the compression type */
   png_write_chunk_start(png_ptr, (png_bytep)png_iCCP,
          (png_uint_32)name_len+profile_len+2);
   new_name[name_len+1]=0x00;
   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 2);

   if (profile_len)
      png_write_compressed_data_out(png_ptr, &comp);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_name);
}
#endif

#if defined(PNG_WRITE_sPLT_SUPPORTED)
/* write a sPLT chunk */
void /* PRIVATE */
png_write_sPLT(png_structp png_ptr, png_sPLT_tp spalette)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sPLT;
#endif
   png_size_t name_len;
   png_charp new_name;
   png_byte entrybuf[10];
   int entry_size = (spalette->depth == 8 ? 6 : 10);
   int palette_size = entry_size * spalette->nentries;
   png_sPLT_entryp ep;
#ifdef PNG_NO_POINTER_INDEXING
   int i;
#endif

   png_debug(1, "in png_write_sPLT\n");
   if (spalette->name == NULL || (name_len = png_check_keyword(png_ptr,
      spalette->name, &new_name))==0)
   {
      png_warning(png_ptr, "Empty keyword in sPLT chunk");
      return;
   }

   /* make sure we include the NULL after the name */
   png_write_chunk_start(png_ptr, (png_bytep)png_sPLT,
          (png_uint_32)(name_len + 2 + palette_size));
   png_write_chunk_data(png_ptr, (png_bytep)new_name, name_len + 1);
   png_write_chunk_data(png_ptr, (png_bytep)&spalette->depth, 1);

   /* loop through each palette entry, writing appropriately */
#ifndef PNG_NO_POINTER_INDEXING
   for (ep = spalette->entries; ep<spalette->entries+spalette->nentries; ep++)
   {
       if (spalette->depth == 8)
       {
           entrybuf[0] = (png_byte)ep->red;
           entrybuf[1] = (png_byte)ep->green;
           entrybuf[2] = (png_byte)ep->blue;
           entrybuf[3] = (png_byte)ep->alpha;
           png_save_uint_16(entrybuf + 4, ep->frequency);
       }
       else
       {
           png_save_uint_16(entrybuf + 0, ep->red);
           png_save_uint_16(entrybuf + 2, ep->green);
           png_save_uint_16(entrybuf + 4, ep->blue);
           png_save_uint_16(entrybuf + 6, ep->alpha);
           png_save_uint_16(entrybuf + 8, ep->frequency);
       }
       png_write_chunk_data(png_ptr, entrybuf, entry_size);
   }
#else
   ep=spalette->entries;
   for (i=0; i>spalette->nentries; i++)
   {
       if (spalette->depth == 8)
       {
           entrybuf[0] = (png_byte)ep[i].red;
           entrybuf[1] = (png_byte)ep[i].green;
           entrybuf[2] = (png_byte)ep[i].blue;
           entrybuf[3] = (png_byte)ep[i].alpha;
           png_save_uint_16(entrybuf + 4, ep[i].frequency);
       }
       else
       {
           png_save_uint_16(entrybuf + 0, ep[i].red);
           png_save_uint_16(entrybuf + 2, ep[i].green);
           png_save_uint_16(entrybuf + 4, ep[i].blue);
           png_save_uint_16(entrybuf + 6, ep[i].alpha);
           png_save_uint_16(entrybuf + 8, ep[i].frequency);
       }
       png_write_chunk_data(png_ptr, entrybuf, entry_size);
   }
#endif

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_name);
}
#endif

#if defined(PNG_WRITE_sBIT_SUPPORTED)
/* write the sBIT chunk */
void /* PRIVATE */
png_write_sBIT(png_structp png_ptr, png_color_8p sbit, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sBIT;
#endif
   png_byte buf[4];
   png_size_t size;

   png_debug(1, "in png_write_sBIT\n");
   /* make sure we don't depend upon the order of PNG_COLOR_8 */
   if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_byte maxbits;

      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
                png_ptr->usr_bit_depth);
      if (sbit->red == 0 || sbit->red > maxbits ||
          sbit->green == 0 || sbit->green > maxbits ||
          sbit->blue == 0 || sbit->blue > maxbits)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->red;
      buf[1] = sbit->green;
      buf[2] = sbit->blue;
      size = 3;
   }
   else
   {
      if (sbit->gray == 0 || sbit->gray > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[0] = sbit->gray;
      size = 1;
   }

   if (color_type & PNG_COLOR_MASK_ALPHA)
   {
      if (sbit->alpha == 0 || sbit->alpha > png_ptr->usr_bit_depth)
      {
         png_warning(png_ptr, "Invalid sBIT depth specified");
         return;
      }
      buf[size++] = sbit->alpha;
   }

   png_write_chunk(png_ptr, (png_bytep)png_sBIT, buf, size);
}
#endif

#if defined(PNG_WRITE_cHRM_SUPPORTED)
/* write the cHRM chunk */
#ifdef PNG_FLOATING_POINT_SUPPORTED
void /* PRIVATE */
png_write_cHRM(png_structp png_ptr, double white_x, double white_y,
   double red_x, double red_y, double green_x, double green_y,
   double blue_x, double blue_y)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_cHRM;
#endif
   png_byte buf[32];
   png_uint_32 itemp;

   png_debug(1, "in png_write_cHRM\n");
   /* each value is saved in 1/100,000ths */
   if (white_x < 0 || white_x > 0.8 || white_y < 0 || white_y > 0.8 ||
       white_x + white_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM white point specified");
#if !defined(PNG_NO_CONSOLE_IO)
      fprintf(stderr,"white_x=%f, white_y=%f\n",white_x, white_y);
#endif
      return;
   }
   itemp = (png_uint_32)(white_x * 100000.0 + 0.5);
   png_save_uint_32(buf, itemp);
   itemp = (png_uint_32)(white_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 4, itemp);

   if (red_x < 0 || red_x > 0.8 || red_y < 0 || red_y > 0.8 ||
       red_x + red_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM red point specified");
      return;
   }
   itemp = (png_uint_32)(red_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 8, itemp);
   itemp = (png_uint_32)(red_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 12, itemp);

   if (green_x < 0 || green_x > 0.8 || green_y < 0 || green_y > 0.8 ||
       green_x + green_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM green point specified");
      return;
   }
   itemp = (png_uint_32)(green_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 16, itemp);
   itemp = (png_uint_32)(green_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 20, itemp);

   if (blue_x < 0 || blue_x > 0.8 || blue_y < 0 || blue_y > 0.8 ||
       blue_x + blue_y > 1.0)
   {
      png_warning(png_ptr, "Invalid cHRM blue point specified");
      return;
   }
   itemp = (png_uint_32)(blue_x * 100000.0 + 0.5);
   png_save_uint_32(buf + 24, itemp);
   itemp = (png_uint_32)(blue_y * 100000.0 + 0.5);
   png_save_uint_32(buf + 28, itemp);

   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
}
#endif
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_cHRM_fixed(png_structp png_ptr, png_fixed_point white_x,
   png_fixed_point white_y, png_fixed_point red_x, png_fixed_point red_y,
   png_fixed_point green_x, png_fixed_point green_y, png_fixed_point blue_x,
   png_fixed_point blue_y)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_cHRM;
#endif
   png_byte buf[32];

   png_debug(1, "in png_write_cHRM\n");
   /* each value is saved in 1/100,000ths */
   if (white_x > 80000L || white_y > 80000L || white_x + white_y > 100000L)
   {
      png_warning(png_ptr, "Invalid fixed cHRM white point specified");
#if !defined(PNG_NO_CONSOLE_IO)
      fprintf(stderr,"white_x=%ld, white_y=%ld\n",white_x, white_y);
#endif
      return;
   }
   png_save_uint_32(buf, white_x);
   png_save_uint_32(buf + 4, white_y);

   if (red_x > 80000L || red_y > 80000L || red_x + red_y > 100000L)
   {
      png_warning(png_ptr, "Invalid cHRM fixed red point specified");
      return;
   }
   png_save_uint_32(buf + 8, red_x);
   png_save_uint_32(buf + 12, red_y);

   if (green_x > 80000L || green_y > 80000L || green_x + green_y > 100000L)
   {
      png_warning(png_ptr, "Invalid fixed cHRM green point specified");
      return;
   }
   png_save_uint_32(buf + 16, green_x);
   png_save_uint_32(buf + 20, green_y);

   if (blue_x > 80000L || blue_y > 80000L || blue_x + blue_y > 100000L)
   {
      png_warning(png_ptr, "Invalid fixed cHRM blue point specified");
      return;
   }
   png_save_uint_32(buf + 24, blue_x);
   png_save_uint_32(buf + 28, blue_y);

   png_write_chunk(png_ptr, (png_bytep)png_cHRM, buf, (png_size_t)32);
}
#endif
#endif

#if defined(PNG_WRITE_tRNS_SUPPORTED)
/* write the tRNS chunk */
void /* PRIVATE */
png_write_tRNS(png_structp png_ptr, png_bytep trans, png_color_16p tran,
   int num_trans, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tRNS;
#endif
   png_byte buf[6];

   png_debug(1, "in png_write_tRNS\n");
   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (num_trans <= 0 || num_trans > (int)png_ptr->num_palette)
      {
         png_warning(png_ptr,"Invalid number of transparent colors specified");
         return;
      }
      /* write the chunk out as it is */
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, trans, (png_size_t)num_trans);
   }
   else if (color_type == PNG_COLOR_TYPE_GRAY)
   {
      /* one 16 bit value */
      png_save_uint_16(buf, tran->gray);
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)2);
   }
   else if (color_type == PNG_COLOR_TYPE_RGB)
   {
      /* three 16 bit values */
      png_save_uint_16(buf, tran->red);
      png_save_uint_16(buf + 2, tran->green);
      png_save_uint_16(buf + 4, tran->blue);
      png_write_chunk(png_ptr, (png_bytep)png_tRNS, buf, (png_size_t)6);
   }
   else
   {
      png_warning(png_ptr, "Can't write tRNS with an alpha channel");
   }
}
#endif

#if defined(PNG_WRITE_bKGD_SUPPORTED)
/* write the background chunk */
void /* PRIVATE */
png_write_bKGD(png_structp png_ptr, png_color_16p back, int color_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_bKGD;
#endif
   png_byte buf[6];

   png_debug(1, "in png_write_bKGD\n");
   if (color_type == PNG_COLOR_TYPE_PALETTE)
   {
      if (
#if defined(PNG_MNG_FEATURES_SUPPORTED) || \
    defined (PNG_WRITE_EMPTY_PLTE_SUPPORTED)
          (png_ptr->num_palette ||
          (!(png_ptr->mng_features_permitted & PNG_FLAG_MNG_EMPTY_PLTE))) &&
#endif
         back->index > png_ptr->num_palette)
      {
         png_warning(png_ptr, "Invalid background palette index");
         return;
      }
      buf[0] = back->index;
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)1);
   }
   else if (color_type & PNG_COLOR_MASK_COLOR)
   {
      png_save_uint_16(buf, back->red);
      png_save_uint_16(buf + 2, back->green);
      png_save_uint_16(buf + 4, back->blue);
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)6);
   }
   else
   {
      png_save_uint_16(buf, back->gray);
      png_write_chunk(png_ptr, (png_bytep)png_bKGD, buf, (png_size_t)2);
   }
}
#endif

#if defined(PNG_WRITE_hIST_SUPPORTED)
/* write the histogram */
void /* PRIVATE */
png_write_hIST(png_structp png_ptr, png_uint_16p hist, int num_hist)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_hIST;
#endif
   int i;
   png_byte buf[3];

   png_debug(1, "in png_write_hIST\n");
   if (num_hist > (int)png_ptr->num_palette)
   {
      png_debug2(3, "num_hist = %d, num_palette = %d\n", num_hist,
         png_ptr->num_palette);
      png_warning(png_ptr, "Invalid number of histogram entries specified");
      return;
   }

   png_write_chunk_start(png_ptr, (png_bytep)png_hIST, (png_uint_32)(num_hist * 2));
   for (i = 0; i < num_hist; i++)
   {
      png_save_uint_16(buf, hist[i]);
      png_write_chunk_data(png_ptr, buf, (png_size_t)2);
   }
   png_write_chunk_end(png_ptr);
}
#endif

#if defined(PNG_WRITE_TEXT_SUPPORTED) || defined(PNG_WRITE_pCAL_SUPPORTED) || \
    defined(PNG_WRITE_iCCP_SUPPORTED) || defined(PNG_WRITE_sPLT_SUPPORTED)
/* Check that the tEXt or zTXt keyword is valid per PNG 1.0 specification,
 * and if invalid, correct the keyword rather than discarding the entire
 * chunk.  The PNG 1.0 specification requires keywords 1-79 characters in
 * length, forbids leading or trailing whitespace, multiple internal spaces,
 * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
 *
 * The new_key is allocated to hold the corrected keyword and must be freed
 * by the calling routine.  This avoids problems with trying to write to
 * static keywords without having to have duplicate copies of the strings.
 */
png_size_t /* PRIVATE */
png_check_keyword(png_structp png_ptr, png_charp key, png_charpp new_key)
{
   png_size_t key_len;
   png_charp kp, dp;
   int kflag;
   int kwarn=0;

   png_debug(1, "in png_check_keyword\n");
   *new_key = NULL;

   if (key == NULL || (key_len = png_strlen(key)) == 0)
   {
      png_warning(png_ptr, "zero length keyword");
      return ((png_size_t)0);
   }

   png_debug1(2, "Keyword to be checked is '%s'\n", key);

   *new_key = (png_charp)png_malloc(png_ptr, (png_uint_32)(key_len + 2));
 
   /* Replace non-printing characters with a blank and print a warning */
   for (kp = key, dp = *new_key; *kp != '\0'; kp++, dp++)
   {
      if (*kp < 0x20 || (*kp > 0x7E && (png_byte)*kp < 0xA1))
      {
#if !defined(PNG_NO_STDIO) && !defined(_WIN32_WCE)
         char msg[40];

         sprintf(msg, "invalid keyword character 0x%02X", *kp);
         png_warning(png_ptr, msg);
#else
         png_warning(png_ptr, "invalid character in keyword");
#endif
         *dp = ' ';
      }
      else
      {
         *dp = *kp;
      }
   }
   *dp = '\0';

   /* Remove any trailing white space. */
   kp = *new_key + key_len - 1;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "trailing spaces removed from keyword");

      while (*kp == ' ')
      {
        *(kp--) = '\0';
        key_len--;
      }
   }

   /* Remove any leading white space. */
   kp = *new_key;
   if (*kp == ' ')
   {
      png_warning(png_ptr, "leading spaces removed from keyword");

      while (*kp == ' ')
      {
        kp++;
        key_len--;
      }
   }

   png_debug1(2, "Checking for multiple internal spaces in '%s'\n", kp);

   /* Remove multiple internal spaces. */
   for (kflag = 0, dp = *new_key; *kp != '\0'; kp++)
   {
      if (*kp == ' ' && kflag == 0)
      {
         *(dp++) = *kp;
         kflag = 1;
      }
      else if (*kp == ' ')
      {
         key_len--;
         kwarn=1;
      }
      else
      {
         *(dp++) = *kp;
         kflag = 0;
      }
   }
   *dp = '\0';
   if(kwarn)
      png_warning(png_ptr, "extra interior spaces removed from keyword");

   if (key_len == 0)
   {
      png_free(png_ptr, *new_key);
      *new_key=NULL;
      png_warning(png_ptr, "Zero length keyword");
   }

   if (key_len > 79)
   {
      png_warning(png_ptr, "keyword length must be 1 - 79 characters");
      new_key[79] = '\0';
      key_len = 79;
   }

   return (key_len);
}
#endif

#if defined(PNG_WRITE_tEXt_SUPPORTED)
/* write a tEXt chunk */
void /* PRIVATE */
png_write_tEXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tEXt;
#endif
   png_size_t key_len;
   png_charp new_key;

   png_debug(1, "in png_write_tEXt\n");
   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in tEXt chunk");
      return;
   }

   if (text == NULL || *text == '\0')
      text_len = 0;
   else
      text_len = png_strlen(text);

   /* make sure we include the 0 after the key */
   png_write_chunk_start(png_ptr, (png_bytep)png_tEXt, (png_uint_32)key_len+text_len+1);
   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    */
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);
   if (text_len)
      png_write_chunk_data(png_ptr, (png_bytep)text, text_len);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_key);
}
#endif

#if defined(PNG_WRITE_zTXt_SUPPORTED)
/* write a compressed text chunk */
void /* PRIVATE */
png_write_zTXt(png_structp png_ptr, png_charp key, png_charp text,
   png_size_t text_len, int compression)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_zTXt;
#endif
   png_size_t key_len;
   char buf[1];
   png_charp new_key;
   compression_state comp;

   png_debug(1, "in png_write_zTXt\n");

   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in zTXt chunk");
      return;
   }

   if (text == NULL || *text == '\0' || compression==PNG_TEXT_COMPRESSION_NONE)
   {
      png_write_tEXt(png_ptr, new_key, text, (png_size_t)0);
      png_free(png_ptr, new_key);
      return;
   }

   text_len = png_strlen(text);

   png_free(png_ptr, new_key);

   /* compute the compressed data; do it now for the length */
   text_len = png_text_compress(png_ptr, text, text_len, compression,
       &comp);

   /* write start of chunk */
   png_write_chunk_start(png_ptr, (png_bytep)png_zTXt, (png_uint_32)
      (key_len+text_len+2));
   /* write key */
   png_write_chunk_data(png_ptr, (png_bytep)key, key_len + 1);
   buf[0] = (png_byte)compression;
   /* write compression */
   png_write_chunk_data(png_ptr, (png_bytep)buf, (png_size_t)1);
   /* write the compressed data */
   png_write_compressed_data_out(png_ptr, &comp);

   /* close the chunk */
   png_write_chunk_end(png_ptr);
}
#endif

#if defined(PNG_WRITE_iTXt_SUPPORTED)
/* write an iTXt chunk */
void /* PRIVATE */
png_write_iTXt(png_structp png_ptr, int compression, png_charp key,
    png_charp lang, png_charp lang_key, png_charp text)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_iTXt;
#endif
   png_size_t lang_len, key_len, lang_key_len, text_len;
   png_charp new_lang, new_key;
   png_byte cbuf[2];
   compression_state comp;

   png_debug(1, "in png_write_iTXt\n");

   if (key == NULL || (key_len = png_check_keyword(png_ptr, key, &new_key))==0)
   {
      png_warning(png_ptr, "Empty keyword in iTXt chunk");
      return;
   }
   if (lang == NULL || (lang_len = png_check_keyword(png_ptr, lang,
      &new_lang))==0)
   {
      png_warning(png_ptr, "Empty language field in iTXt chunk");
      return;
   }
   lang_key_len = png_strlen(lang_key);
   text_len = png_strlen(text);

   if (text == NULL || *text == '\0')
      text_len = 0;

   /* compute the compressed data; do it now for the length */
   text_len = png_text_compress(png_ptr, text, text_len, compression-2,
      &comp);

   /* make sure we include the compression flag, the compression byte,
    * and the NULs after the key, lang, and lang_key parts */

   png_write_chunk_start(png_ptr, (png_bytep)png_iTXt,
          (png_uint_32)(
        5 /* comp byte, comp flag, terminators for key, lang and lang_key */
        + key_len
        + lang_len
        + lang_key_len
        + text_len));

   /*
    * We leave it to the application to meet PNG-1.0 requirements on the
    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
    * The NUL character is forbidden by PNG-1.0 through PNG-1.2 and ISO PNG.
    */
   png_write_chunk_data(png_ptr, (png_bytep)new_key, key_len + 1);

   /* set the compression flag */
   if (compression == PNG_ITXT_COMPRESSION_NONE || \
       compression == PNG_TEXT_COMPRESSION_NONE)
       cbuf[0] = 0;
   else /* compression == PNG_ITXT_COMPRESSION_zTXt */
       cbuf[0] = 1;
   /* set the compression method */
   cbuf[1] = 0;
   png_write_chunk_data(png_ptr, cbuf, 2);

   png_write_chunk_data(png_ptr, (png_bytep)new_lang, lang_len + 1);
   png_write_chunk_data(png_ptr, (png_bytep)lang_key, lang_key_len+1);
   png_write_chunk_data(png_ptr, '\0', 1);

   png_write_compressed_data_out(png_ptr, &comp);

   png_write_chunk_end(png_ptr);
   png_free(png_ptr, new_key);
   png_free(png_ptr, new_lang);
}
#endif

#if defined(PNG_WRITE_oFFs_SUPPORTED)
/* write the oFFs chunk */
void /* PRIVATE */
png_write_oFFs(png_structp png_ptr, png_uint_32 x_offset,
   png_uint_32 y_offset,
   int unit_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_oFFs;
#endif
   png_byte buf[9];

   png_debug(1, "in png_write_oFFs\n");
   if (unit_type >= PNG_OFFSET_LAST)
      png_warning(png_ptr, "Unrecognized unit type for oFFs chunk");

   png_save_uint_32(buf, x_offset);
   png_save_uint_32(buf + 4, y_offset);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, (png_bytep)png_oFFs, buf, (png_size_t)9);
}
#endif

#if defined(PNG_WRITE_pCAL_SUPPORTED)
/* write the pCAL chunk (described in the PNG extensions document) */
void /* PRIVATE */
png_write_pCAL(png_structp png_ptr, png_charp purpose, png_int_32 X0,
   png_int_32 X1, int type, int nparams, png_charp units, png_charpp params)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_pCAL;
#endif
   png_size_t purpose_len, units_len, total_len;
   png_uint_32p params_len;
   png_byte buf[10];
   png_charp new_purpose;
   int i;

   png_debug1(1, "in png_write_pCAL (%d parameters)\n", nparams);
   if (type >= PNG_EQUATION_LAST)
      png_warning(png_ptr, "Unrecognized equation type for pCAL chunk");

   purpose_len = png_check_keyword(png_ptr, purpose, &new_purpose) + 1;
   png_debug1(3, "pCAL purpose length = %d\n", purpose_len);
   units_len = png_strlen(units) + (nparams == 0 ? 0 : 1);
   png_debug1(3, "pCAL units length = %d\n", units_len);
   total_len = purpose_len + units_len + 10;

   params_len = (png_uint_32p)png_malloc(png_ptr, (png_uint_32)(nparams
      *sizeof(png_uint_32)));

   /* Find the length of each parameter, making sure we don't count the
      null terminator for the last parameter. */
   for (i = 0; i < nparams; i++)
   {
      params_len[i] = png_strlen(params[i]) + (i == nparams - 1 ? 0 : 1);
      png_debug2(3, "pCAL parameter %d length = %lu\n", i, params_len[i]);
      total_len += (png_size_t)params_len[i];
   }

   png_debug1(3, "pCAL total length = %d\n", total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_pCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)new_purpose, purpose_len);
   png_save_int_32(buf, X0);
   png_save_int_32(buf + 4, X1);
   buf[8] = (png_byte)type;
   buf[9] = (png_byte)nparams;
   png_write_chunk_data(png_ptr, buf, (png_size_t)10);
   png_write_chunk_data(png_ptr, (png_bytep)units, (png_size_t)units_len);

   png_free(png_ptr, new_purpose);

   for (i = 0; i < nparams; i++)
   {
      png_write_chunk_data(png_ptr, (png_bytep)params[i],
         (png_size_t)params_len[i]);
   }

   png_free(png_ptr, params_len);
   png_write_chunk_end(png_ptr);
}
#endif

#if defined(PNG_WRITE_sCAL_SUPPORTED)
/* write the sCAL chunk */
#if defined(PNG_FLOATING_POINT_SUPPORTED) && !defined(PNG_NO_STDIO)
void /* PRIVATE */
png_write_sCAL(png_structp png_ptr, int unit, double width,double height)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sCAL;
#endif
   png_size_t total_len;
   char wbuf[32], hbuf[32];

   png_debug(1, "in png_write_sCAL\n");

#if defined(_WIN32_WCE)
/* sprintf() function is not supported on WindowsCE */
   {
      wchar_t wc_buf[32];
      swprintf(wc_buf, TEXT("%12.12e"), width);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, wbuf, 32, NULL, NULL);
      swprintf(wc_buf, TEXT("%12.12e"), height);
      WideCharToMultiByte(CP_ACP, 0, wc_buf, -1, hbuf, 32, NULL, NULL);
   }
#else
   sprintf(wbuf, "%12.12e", width);
   sprintf(hbuf, "%12.12e", height);
#endif
   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);

   png_debug1(3, "sCAL total length = %d\n", total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)&unit, 1);
   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));

   png_write_chunk_end(png_ptr);
}
#else
#ifdef PNG_FIXED_POINT_SUPPORTED
void /* PRIVATE */
png_write_sCAL_s(png_structp png_ptr, int unit, png_charp width,
   png_charp height)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_sCAL;
#endif
   png_size_t total_len;
   char wbuf[32], hbuf[32];

   png_debug(1, "in png_write_sCAL_s\n");

   png_strcpy(wbuf,(const char *)width);
   png_strcpy(hbuf,(const char *)height);
   total_len = 1 + png_strlen(wbuf)+1 + png_strlen(hbuf);

   png_debug1(3, "sCAL total length = %d\n", total_len);
   png_write_chunk_start(png_ptr, (png_bytep)png_sCAL, (png_uint_32)total_len);
   png_write_chunk_data(png_ptr, (png_bytep)&unit, 1);
   png_write_chunk_data(png_ptr, (png_bytep)wbuf, png_strlen(wbuf)+1);
   png_write_chunk_data(png_ptr, (png_bytep)hbuf, png_strlen(hbuf));

   png_write_chunk_end(png_ptr);
}
#endif
#endif
#endif

#if defined(PNG_WRITE_pHYs_SUPPORTED)
/* write the pHYs chunk */
void /* PRIVATE */
png_write_pHYs(png_structp png_ptr, png_uint_32 x_pixels_per_unit,
   png_uint_32 y_pixels_per_unit,
   int unit_type)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_pHYs;
#endif
   png_byte buf[9];

   png_debug(1, "in png_write_pHYs\n");
   if (unit_type >= PNG_RESOLUTION_LAST)
      png_warning(png_ptr, "Unrecognized unit type for pHYs chunk");

   png_save_uint_32(buf, x_pixels_per_unit);
   png_save_uint_32(buf + 4, y_pixels_per_unit);
   buf[8] = (png_byte)unit_type;

   png_write_chunk(png_ptr, (png_bytep)png_pHYs, buf, (png_size_t)9);
}
#endif

#if defined(PNG_WRITE_tIME_SUPPORTED)
/* Write the tIME chunk.  Use either png_convert_from_struct_tm()
 * or png_convert_from_time_t(), or fill in the structure yourself.
 */
void /* PRIVATE */
png_write_tIME(png_structp png_ptr, png_timep mod_time)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   PNG_tIME;
#endif
   png_byte buf[7];

   png_debug(1, "in png_write_tIME\n");
   if (mod_time->month  > 12 || mod_time->month  < 1 ||
       mod_time->day    > 31 || mod_time->day    < 1 ||
       mod_time->hour   > 23 || mod_time->second > 60)
   {
      png_warning(png_ptr, "Invalid time specified for tIME chunk");
      return;
   }

   png_save_uint_16(buf, mod_time->year);
   buf[2] = mod_time->month;
   buf[3] = mod_time->day;
   buf[4] = mod_time->hour;
   buf[5] = mod_time->minute;
   buf[6] = mod_time->second;

   png_write_chunk(png_ptr, (png_bytep)png_tIME, buf, (png_size_t)7);
}
#endif

/* initializes the row writing capability of libpng */
void /* PRIVATE */
png_write_start_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* start of interlace block in the y direction */
   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* offset to next interlace block in the y direction */
   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   png_size_t buf_size;

   png_debug(1, "in png_write_start_row\n");
   buf_size = (png_size_t)(((png_ptr->width * png_ptr->usr_channels *
                            png_ptr->usr_bit_depth + 7) >> 3) + 1);

   /* set up row buffer */
   png_ptr->row_buf = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
   png_ptr->row_buf[0] = PNG_FILTER_VALUE_NONE;

   /* set up filtering buffer, if using this filter */
   if (png_ptr->do_filter & PNG_FILTER_SUB)
   {
      png_ptr->sub_row = (png_bytep)png_malloc(png_ptr,
         (png_ptr->rowbytes + 1));
      png_ptr->sub_row[0] = PNG_FILTER_VALUE_SUB;
   }

   /* We only need to keep the previous row if we are using one of these. */
   if (png_ptr->do_filter & (PNG_FILTER_AVG | PNG_FILTER_UP | PNG_FILTER_PAETH))
   {
     /* set up previous row buffer */
      png_ptr->prev_row = (png_bytep)png_malloc(png_ptr, (png_uint_32)buf_size);
      png_memset(png_ptr->prev_row, 0, buf_size);

      if (png_ptr->do_filter & PNG_FILTER_UP)
      {
         png_ptr->up_row = (png_bytep )png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->up_row[0] = PNG_FILTER_VALUE_UP;
      }

      if (png_ptr->do_filter & PNG_FILTER_AVG)
      {
         png_ptr->avg_row = (png_bytep)png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->avg_row[0] = PNG_FILTER_VALUE_AVG;
      }

      if (png_ptr->do_filter & PNG_FILTER_PAETH)
      {
         png_ptr->paeth_row = (png_bytep )png_malloc(png_ptr,
            (png_ptr->rowbytes + 1));
         png_ptr->paeth_row[0] = PNG_FILTER_VALUE_PAETH;
      }
   }

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* if interlaced, we need to set up width and height of pass */
   if (png_ptr->interlaced)
   {
      if (!(png_ptr->transformations & PNG_INTERLACE))
      {
         png_ptr->num_rows = (png_ptr->height + png_pass_yinc[0] - 1 -
            png_pass_ystart[0]) / png_pass_yinc[0];
         png_ptr->usr_width = (png_ptr->width + png_pass_inc[0] - 1 -
            png_pass_start[0]) / png_pass_inc[0];
      }
      else
      {
         png_ptr->num_rows = png_ptr->height;
         png_ptr->usr_width = png_ptr->width;
      }
   }
   else
#endif
   {
      png_ptr->num_rows = png_ptr->height;
      png_ptr->usr_width = png_ptr->width;
   }
   png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
   png_ptr->zstream.next_out = png_ptr->zbuf;
}

/* Internal use only.  Called when finished processing a row of data. */
void /* PRIVATE */
png_write_finish_row(png_structp png_ptr)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};

   /* start of interlace block in the y direction */
   int png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};

   /* offset to next interlace block in the y direction */
   int png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
#endif

   int ret;

   png_debug(1, "in png_write_finish_row\n");
   /* next row */
   png_ptr->row_number++;

   /* see if we are done */
   if (png_ptr->row_number < png_ptr->num_rows)
      return;

#ifdef PNG_WRITE_INTERLACING_SUPPORTED
   /* if interlaced, go to next pass */
   if (png_ptr->interlaced)
   {
      png_ptr->row_number = 0;
      if (png_ptr->transformations & PNG_INTERLACE)
      {
         png_ptr->pass++;
      }
      else
      {
         /* loop until we find a non-zero width or height pass */
         do
         {
            png_ptr->pass++;
            if (png_ptr->pass >= 7)
               break;
            png_ptr->usr_width = (png_ptr->width +
               png_pass_inc[png_ptr->pass] - 1 -
               png_pass_start[png_ptr->pass]) /
               png_pass_inc[png_ptr->pass];
            png_ptr->num_rows = (png_ptr->height +
               png_pass_yinc[png_ptr->pass] - 1 -
               png_pass_ystart[png_ptr->pass]) /
               png_pass_yinc[png_ptr->pass];
            if (png_ptr->transformations & PNG_INTERLACE)
               break;
         } while (png_ptr->usr_width == 0 || png_ptr->num_rows == 0);

      }

      /* reset the row above the image for the next pass */
      if (png_ptr->pass < 7)
      {
         if (png_ptr->prev_row != NULL)
            png_memset(png_ptr->prev_row, 0,
               (png_size_t) (((png_uint_32)png_ptr->usr_channels *
               (png_uint_32)png_ptr->usr_bit_depth *
               png_ptr->width + 7) >> 3) + 1);
         return;
      }
   }
#endif

   /* if we get here, we've just written the last row, so we need
      to flush the compressor */
   do
   {
      /* tell the compressor we are done */
      ret = deflate(&png_ptr->zstream, Z_FINISH);
      /* check for an error */
      if (ret == Z_OK)
      {
         /* check to see if we need more room */
         if (!(png_ptr->zstream.avail_out))
         {
            png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
            png_ptr->zstream.next_out = png_ptr->zbuf;
            png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
         }
      }
      else if (ret != Z_STREAM_END)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }
   } while (ret != Z_STREAM_END);

   /* write any extra space */
   if (png_ptr->zstream.avail_out < png_ptr->zbuf_size)
   {
      png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size -
         png_ptr->zstream.avail_out);
   }

   deflateReset(&png_ptr->zstream);
}

#if defined(PNG_WRITE_INTERLACING_SUPPORTED)
/* Pick out the correct pixels for the interlace pass.
 * The basic idea here is to go through the row with a source
 * pointer and a destination pointer (sp and dp), and copy the
 * correct pixels for the pass.  As the row gets compacted,
 * sp will always be >= dp, so we should never overwrite anything.
 * See the default: case for the easiest code to understand.
 */
void /* PRIVATE */
png_do_write_interlace(png_row_infop row_info, png_bytep row, int pass)
{
#ifdef PNG_USE_LOCAL_ARRAYS
   /* arrays to facilitate easy interlacing - use pass (0 - 6) as index */

   /* start of interlace block */
   int png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};

   /* offset to next interlace block */
   int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
#endif

   png_debug(1, "in png_do_write_interlace\n");
   /* we don't have to do anything on the last pass (6) */
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL && pass < 6)
#else
   if (pass < 6)
#endif
   {
      /* each pixel depth is handled separately */
      switch (row_info->pixel_depth)
      {
         case 1:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            d = 0;
            shift = 7;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 3);
               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 7;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift--;

            }
            if (shift != 7)
               *dp = (png_byte)d;
            break;
         }
         case 2:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 6;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 2);
               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 6;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 2;
            }
            if (shift != 6)
                   *dp = (png_byte)d;
            break;
         }
         case 4:
         {
            png_bytep sp;
            png_bytep dp;
            int shift;
            int d;
            int value;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            dp = row;
            shift = 4;
            d = 0;
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               sp = row + (png_size_t)(i >> 1);
               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
               d |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp++ = (png_byte)d;
                  d = 0;
               }
               else
                  shift -= 4;
            }
            if (shift != 4)
               *dp = (png_byte)d;
            break;
         }
         default:
         {
            png_bytep sp;
            png_bytep dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            png_size_t pixel_bytes;

            /* start at the beginning */
            dp = row;
            /* find out how many bytes each pixel takes up */
            pixel_bytes = (row_info->pixel_depth >> 3);
            /* loop through the row, only looking at the pixels that
               matter */
            for (i = png_pass_start[pass]; i < row_width;
               i += png_pass_inc[pass])
            {
               /* find out where the original pixel is */
               sp = row + (png_size_t)i * pixel_bytes;
               /* move the pixel */
               if (dp != sp)
                  png_memcpy(dp, sp, pixel_bytes);
               /* next pixel */
               dp += pixel_bytes;
            }
            break;
         }
      }
      /* set new row width */
      row_info->width = (row_info->width +
         png_pass_inc[pass] - 1 -
         png_pass_start[pass]) /
         png_pass_inc[pass];
         row_info->rowbytes = ((row_info->width *
            row_info->pixel_depth + 7) >> 3);
   }
}
#endif

/* This filters the row, chooses which filter to use, if it has not already
 * been specified by the application, and then writes the row out with the
 * chosen filter.
 */
#define PNG_MAXSUM (~((png_uint_32)0) >> 1)
#define PNG_HISHIFT 10
#define PNG_LOMASK ((png_uint_32)0xffffL)
#define PNG_HIMASK ((png_uint_32)(~PNG_LOMASK >> PNG_HISHIFT))
void /* PRIVATE */
png_write_find_filter(png_structp png_ptr, png_row_infop row_info)
{
   png_bytep prev_row, best_row, row_buf;
   png_uint_32 mins, bpp;
   png_byte filter_to_do = png_ptr->do_filter;
   png_uint_32 row_bytes = row_info->rowbytes;
#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   int num_p_filters = (int)png_ptr->num_prev_filters;
#endif

   png_debug(1, "in png_write_find_filter\n");
   /* find out how many bytes offset each pixel is */
   bpp = (row_info->pixel_depth + 7) / 8;

   prev_row = png_ptr->prev_row;
   best_row = row_buf = png_ptr->row_buf;
   mins = PNG_MAXSUM;

   /* The prediction method we use is to find which method provides the
    * smallest value when summing the absolute values of the distances
    * from zero, using anything >= 128 as negative numbers.  This is known
    * as the "minimum sum of absolute differences" heuristic.  Other
    * heuristics are the "weighted minimum sum of absolute differences"
    * (experimental and can in theory improve compression), and the "zlib
    * predictive" method (not implemented yet), which does test compressions
    * of lines using different filter methods, and then chooses the
    * (series of) filter(s) that give minimum compressed data size (VERY
    * computationally expensive).
    *
    * GRR 980525:  consider also
    *   (1) minimum sum of absolute differences from running average (i.e.,
    *       keep running sum of non-absolute differences & count of bytes)
    *       [track dispersion, too?  restart average if dispersion too large?]
    *  (1b) minimum sum of absolute differences from sliding average, probably
    *       with window size <= deflate window (usually 32K)
    *   (2) minimum sum of squared differences from zero or running average
    *       (i.e., ~ root-mean-square approach)
    */


   /* We don't need to test the 'no filter' case if this is the only filter
    * that has been chosen, as it doesn't actually do anything to the data.
    */
   if ((filter_to_do & PNG_FILTER_NONE) &&
       filter_to_do != PNG_FILTER_NONE)
   {
      png_bytep rp;
      png_uint_32 sum = 0;
      png_uint_32 i;
      int v;

      for (i = 0, rp = row_buf + 1; i < row_bytes; i++, rp++)
      {
         v = *rp;
         sum += (v < 128) ? v : 256 - v;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         png_uint_32 sumhi, sumlo;
         int j;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK; /* Gives us some footroom */

         /* Reduce the sum if we match any of the previous rows */
         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         /* Factor in the cost of this filter (this is here for completeness,
          * but it makes no sense to have a "cost" for the NONE filter, as
          * it has the minimum possible computational cost - none).
          */
         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_NONE]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif
      mins = sum;
   }

   /* sub filter */
   if (filter_to_do == PNG_FILTER_SUB)
   /* it's the only filter so no testing is needed */
   {
      png_bytep rp, lp, dp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         *dp = *rp;
      }
      for (lp = row_buf + 1; i < row_bytes;
         i++, rp++, lp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
      }
      best_row = png_ptr->sub_row;
   }

   else if (filter_to_do & PNG_FILTER_SUB)
   {
      png_bytep rp, dp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      /* We temporarily increase the "minimum sum" by the factor we
       * would reduce the sum of this filter, so that we can do the
       * early exit comparison without scaling the sum each time.
       */
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->sub_row + 1; i < bpp;
           i++, rp++, dp++)
      {
         v = *dp = *rp;

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_info->rowbytes;
         i++, rp++, lp++, dp++)
      {
         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_SUB)
            {
               sumlo = (sumlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_SUB]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->sub_row;
      }
   }

   /* up filter */
   if (filter_to_do == PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 i;

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes;
           i++, rp++, pp++, dp++)
      {
         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
      }
      best_row = png_ptr->up_row;
   }

   else if (filter_to_do & PNG_FILTER_UP)
   {
      png_bytep rp, dp, pp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;


#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->up_row + 1,
           pp = prev_row + 1; i < row_bytes; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_UP)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_UP]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->up_row;
      }
   }

   /* avg filter */
   if (filter_to_do == PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2))
                 & 0xff);
      }
      best_row = png_ptr->avg_row;
   }

   else if (filter_to_do & PNG_FILTER_AVG)
   {
      png_bytep rp, dp, pp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_AVG)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->avg_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }
      for (lp = row_buf + 1; i < row_bytes; i++)
      {
         v = *dp++ =
          (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_NONE)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_AVG]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         mins = sum;
         best_row = png_ptr->avg_row;
      }
   }

   /* Paeth filter */
   if (filter_to_do == PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 i;
      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

         p = b - c;
         pc = a - c;

#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif

         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;

         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
      }
      best_row = png_ptr->paeth_row;
   }

   else if (filter_to_do & PNG_FILTER_PAETH)
   {
      png_bytep rp, dp, pp, cp, lp;
      png_uint_32 sum = 0, lmins = mins;
      png_uint_32 i;
      int v;

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 lmhi, lmlo;
         lmlo = lmins & PNG_LOMASK;
         lmhi = (lmins >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               lmlo = (lmlo * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               lmhi = (lmhi * png_ptr->inv_filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         lmlo = (lmlo * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         lmhi = (lmhi * png_ptr->inv_filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (lmhi > PNG_HIMASK)
            lmins = PNG_MAXSUM;
         else
            lmins = (lmhi << PNG_HISHIFT) + lmlo;
      }
#endif

      for (i = 0, rp = row_buf + 1, dp = png_ptr->paeth_row + 1,
           pp = prev_row + 1; i < bpp; i++)
      {
         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);

         sum += (v < 128) ? v : 256 - v;
      }

      for (lp = row_buf + 1, cp = prev_row + 1; i < row_bytes; i++)
      {
         int a, b, c, pa, pb, pc, p;

         b = *pp++;
         c = *cp++;
         a = *lp++;

#ifndef PNG_SLOW_PAETH
         p = b - c;
         pc = a - c;
#ifdef PNG_USE_ABS
         pa = abs(p);
         pb = abs(pc);
         pc = abs(p + pc);
#else
         pa = p < 0 ? -p : p;
         pb = pc < 0 ? -pc : pc;
         pc = (p + pc) < 0 ? -(p + pc) : p + pc;
#endif
         p = (pa <= pb && pa <=pc) ? a : (pb <= pc) ? b : c;
#else /* PNG_SLOW_PAETH */
         p = a + b - c;
         pa = abs(p - a);
         pb = abs(p - b);
         pc = abs(p - c);
         if (pa <= pb && pa <= pc)
            p = a;
         else if (pb <= pc)
            p = b;
         else
            p = c;
#endif /* PNG_SLOW_PAETH */

         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);

         sum += (v < 128) ? v : 256 - v;

         if (sum > lmins)  /* We are already worse, don't continue. */
            break;
      }

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
      if (png_ptr->heuristic_method == PNG_FILTER_HEURISTIC_WEIGHTED)
      {
         int j;
         png_uint_32 sumhi, sumlo;
         sumlo = sum & PNG_LOMASK;
         sumhi = (sum >> PNG_HISHIFT) & PNG_HIMASK;

         for (j = 0; j < num_p_filters; j++)
         {
            if (png_ptr->prev_filters[j] == PNG_FILTER_VALUE_PAETH)
            {
               sumlo = (sumlo * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
               sumhi = (sumhi * png_ptr->filter_weights[j]) >>
                  PNG_WEIGHT_SHIFT;
            }
         }

         sumlo = (sumlo * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;
         sumhi = (sumhi * png_ptr->filter_costs[PNG_FILTER_VALUE_PAETH]) >>
            PNG_COST_SHIFT;

         if (sumhi > PNG_HIMASK)
            sum = PNG_MAXSUM;
         else
            sum = (sumhi << PNG_HISHIFT) + sumlo;
      }
#endif

      if (sum < mins)
      {
         best_row = png_ptr->paeth_row;
      }
   }

   /* Do the actual writing of the filtered row data from the chosen filter. */

   png_write_filtered_row(png_ptr, best_row);

#if defined(PNG_WRITE_WEIGHTED_FILTER_SUPPORTED)
   /* Save the type of filter we picked this time for future calculations */
   if (png_ptr->num_prev_filters > 0)
   {
      int j;
      for (j = 1; j < num_p_filters; j++)
      {
         png_ptr->prev_filters[j] = png_ptr->prev_filters[j - 1];
      }
      png_ptr->prev_filters[j] = best_row[0];
   }
#endif
}


/* Do the actual writing of a previously filtered row. */
void /* PRIVATE */
png_write_filtered_row(png_structp png_ptr, png_bytep filtered_row)
{
   png_debug(1, "in png_write_filtered_row\n");
   png_debug1(2, "filter = %d\n", filtered_row[0]);
   /* set up the zlib input buffer */

   png_ptr->zstream.next_in = filtered_row;
   png_ptr->zstream.avail_in = (uInt)png_ptr->row_info.rowbytes + 1;
   /* repeat until we have compressed all the data */
   do
   {
      int ret; /* return of zlib */

      /* compress the data */
      ret = deflate(&png_ptr->zstream, Z_NO_FLUSH);
      /* check for compression errors */
      if (ret != Z_OK)
      {
         if (png_ptr->zstream.msg != NULL)
            png_error(png_ptr, png_ptr->zstream.msg);
         else
            png_error(png_ptr, "zlib error");
      }

      /* see if it is time to write another IDAT */
      if (!(png_ptr->zstream.avail_out))
      {
         /* write the IDAT and reset the zlib output buffer */
         png_write_IDAT(png_ptr, png_ptr->zbuf, png_ptr->zbuf_size);
         png_ptr->zstream.next_out = png_ptr->zbuf;
         png_ptr->zstream.avail_out = (uInt)png_ptr->zbuf_size;
      }
   /* repeat until all data has been compressed */
   } while (png_ptr->zstream.avail_in);

   /* swap the current and previous rows */
   if (png_ptr->prev_row != NULL)
   {
      png_bytep tptr;

      tptr = png_ptr->prev_row;
      png_ptr->prev_row = png_ptr->row_buf;
      png_ptr->row_buf = tptr;
   }

   /* finish row - updates counters and flushes zlib if last row */
   png_write_finish_row(png_ptr);

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
   png_ptr->flush_rows++;

   if (png_ptr->flush_dist > 0 &&
       png_ptr->flush_rows >= png_ptr->flush_dist)
   {
      png_write_flush(png_ptr);
   }
#endif
}
#endif /* PNG_WRITE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngwio.c ===
/* pngwio.c - functions for data output
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 *
 * This file provides a location for all output.  Users who need
 * special handling are expected to write functions that have the same
 * arguments as these and perform similar functions, but that possibly
 * use different output methods.  Note that you shouldn't change these
 * functions, but rather write replacement functions and then change
 * them at run time with png_set_write_fn(...).
 */

#define PNG_INTERNAL
#include "png.h"
#ifdef PNG_WRITE_SUPPORTED

/* Write the data to whatever output you are using.  The default routine
   writes to a file pointer.  Note that this routine sometimes gets called
   with very small lengths, so you should implement some kind of simple
   buffering if you are using unbuffered writes.  This should never be asked
   to write more than 64K on a 16 bit machine.  */

void /* PRIVATE */
png_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   if (png_ptr->write_data_fn != NULL )
      (*(png_ptr->write_data_fn))(png_ptr, data, length);
   else
      png_error(png_ptr, "Call to NULL write function");
}

#if !defined(PNG_NO_STDIO)
/* This is the function that does the actual writing of data.  If you are
   not writing to a standard C stream, you should create a replacement
   write_data function and use it at run time with png_set_write_fn(), rather
   than changing the library. */
#ifndef USE_FAR_KEYWORD
static void /* PRIVATE */
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;

#if defined(_WIN32_WCE)
   if ( !WriteFile((HANDLE)(png_ptr->io_ptr), data, length, &check, NULL) )
      check = 0;
#else
   check = fwrite(data, 1, length, (png_FILE_p)(png_ptr->io_ptr));
#endif
   if (check != length)
      png_error(png_ptr, "Write Error");
}
#else
/* this is the model-independent version. Since the standard I/O library
   can't handle far buffers in the medium and small models, we have to copy
   the data.
*/

#define NEAR_BUF_SIZE 1024
#define MIN(a,b) (a <= b ? a : b)

static void /* PRIVATE */
png_default_write_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
   png_uint_32 check;
   png_byte *near_data;  /* Needs to be "png_byte *" instead of "png_bytep" */
   png_FILE_p io_ptr;

   /* Check if data really is near. If so, use usual code. */
   near_data = (png_byte *)CVT_PTR_NOCHECK(data);
   io_ptr = (png_FILE_p)CVT_PTR(png_ptr->io_ptr);
   if ((png_bytep)near_data == data)
   {
#if defined(_WIN32_WCE)
      if ( !WriteFile(io_ptr, near_data, length, &check, NULL) )
         check = 0;
#else
      check = fwrite(near_data, 1, length, io_ptr);
#endif
   }
   else
   {
      png_byte buf[NEAR_BUF_SIZE];
      png_size_t written, remaining, err;
      check = 0;
      remaining = length;
      do
      {
         written = MIN(NEAR_BUF_SIZE, remaining);
         png_memcpy(buf, data, written); /* copy far buffer to near buffer */
#if defined(_WIN32_WCE)
         if ( !WriteFile(io_ptr, buf, written, &err, NULL) )
            err = 0;
#else
         err = fwrite(buf, 1, written, io_ptr);
#endif
         if (err != written)
            break;
         else
            check += err;
         data += written;
         remaining -= written;
      }
      while (remaining != 0);
   }
   if (check != length)
      png_error(png_ptr, "Write Error");
}

#endif
#endif

/* This function is called to output any data pending writing (normally
   to disk).  After png_flush is called, there should be no data pending
   writing in any buffers. */
#if defined(PNG_WRITE_FLUSH_SUPPORTED)
void /* PRIVATE */
png_flush(png_structp png_ptr)
{
   if (png_ptr->output_flush_fn != NULL)
      (*(png_ptr->output_flush_fn))(png_ptr);
}

#if !defined(PNG_NO_STDIO)
static void /* PRIVATE */
png_default_flush(png_structp png_ptr)
{
#if !defined(_WIN32_WCE)
   png_FILE_p io_ptr;
   io_ptr = (png_FILE_p)CVT_PTR((png_ptr->io_ptr));
   if (io_ptr != NULL)
      fflush(io_ptr);
#endif
}
#endif
#endif

/* This function allows the application to supply new output functions for
   libpng if standard C streams aren't being used.

   This function takes as its arguments:
   png_ptr       - pointer to a png output data structure
   io_ptr        - pointer to user supplied structure containing info about
                   the output functions.  May be NULL.
   write_data_fn - pointer to a new output function that takes as its
                   arguments a pointer to a png_struct, a pointer to
                   data to be written, and a 32-bit unsigned int that is
                   the number of bytes to be written.  The new write
                   function should call png_error(png_ptr, "Error msg")
                   to exit and output any fatal error messages.
   flush_data_fn - pointer to a new flush function that takes as its
                   arguments a pointer to a png_struct.  After a call to
                   the flush function, there should be no data in any buffers
                   or pending transmission.  If the output method doesn't do
                   any buffering of ouput, a function prototype must still be
                   supplied although it doesn't have to do anything.  If
                   PNG_WRITE_FLUSH_SUPPORTED is not defined at libpng compile
                   time, output_flush_fn will be ignored, although it must be
                   supplied for compatibility. */
void PNGAPI
png_set_write_fn(png_structp png_ptr, png_voidp io_ptr,
   png_rw_ptr write_data_fn, png_flush_ptr output_flush_fn)
{
   png_ptr->io_ptr = io_ptr;

#if !defined(PNG_NO_STDIO)
   if (write_data_fn != NULL)
      png_ptr->write_data_fn = write_data_fn;
   else
      png_ptr->write_data_fn = png_default_write_data;
#else
   png_ptr->write_data_fn = write_data_fn;
#endif

#if defined(PNG_WRITE_FLUSH_SUPPORTED)
#if !defined(PNG_NO_STDIO)
   if (output_flush_fn != NULL)
      png_ptr->output_flush_fn = output_flush_fn;
   else
      png_ptr->output_flush_fn = png_default_flush;
#else
   png_ptr->output_flush_fn = output_flush_fn;
#endif
#endif /* PNG_WRITE_FLUSH_SUPPORTED */

   /* It is an error to read while writing a png file */
   if (png_ptr->read_data_fn != NULL)
   {
      png_ptr->read_data_fn = NULL;
      png_warning(png_ptr,
         "Attempted to set both read_data_fn and write_data_fn in");
      png_warning(png_ptr,
         "the same structure.  Resetting read_data_fn to NULL.");
   }
}

#if defined(USE_FAR_KEYWORD)
#if defined(_MSC_VER)
void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
{
   void *near_ptr;
   void FAR *far_ptr;
   FP_OFF(near_ptr) = FP_OFF(ptr);
   far_ptr = (void FAR *)near_ptr;
   if(check != 0)
      if(FP_SEG(ptr) != FP_SEG(far_ptr))
         png_error(png_ptr,"segment lost in conversion");
   return(near_ptr);
}
#  else
void *png_far_to_near(png_structp png_ptr,png_voidp ptr, int check)
{
   void *near_ptr;
   void FAR *far_ptr;
   near_ptr = (void FAR *)ptr;
   far_ptr = (void FAR *)near_ptr;
   if(check != 0)
      if(far_ptr != ptr)
         png_error(png_ptr,"segment lost in conversion");
   return(near_ptr);
}
#   endif
#   endif
#endif /* PNG_WRITE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\PNG\pngwtran.c ===
/* pngwtran.c - transforms the data in a row for PNG writers
 *
 * libpng 1.0.11 - April 27, 2001
 * For conditions of distribution and use, see copyright notice in png.h
 * Copyright (c) 1998-2001 Glenn Randers-Pehrson
 * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 */

#define PNG_INTERNAL
#include "png.h"
#ifdef PNG_WRITE_SUPPORTED

/* Transform the data according to the user's wishes.  The order of
 * transformations is significant.
 */
void /* PRIVATE */
png_do_write_transformations(png_structp png_ptr)
{
   png_debug(1, "in png_do_write_transformations\n");

   if (png_ptr == NULL)
      return;

#if defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
   if (png_ptr->transformations & PNG_USER_TRANSFORM)
      if(png_ptr->write_user_transform_fn != NULL)
        (*(png_ptr->write_user_transform_fn)) /* user write transform function */
          (png_ptr,                    /* png_ptr */
           &(png_ptr->row_info),       /* row_info:     */
             /*  png_uint_32 width;          width of row */
             /*  png_uint_32 rowbytes;       number of bytes in row */
             /*  png_byte color_type;        color type of pixels */
             /*  png_byte bit_depth;         bit depth of samples */
             /*  png_byte channels;          number of channels (1-4) */
             /*  png_byte pixel_depth;       bits per pixel (depth*channels) */
           png_ptr->row_buf + 1);      /* start of pixel data for row */
#endif
#if defined(PNG_WRITE_FILLER_SUPPORTED)
   if (png_ptr->transformations & PNG_FILLER)
      png_do_strip_filler(&(png_ptr->row_info), png_ptr->row_buf + 1,
         png_ptr->flags);
#endif
#if defined(PNG_WRITE_PACKSWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_PACKSWAP)
      png_do_packswap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_PACK_SUPPORTED)
   if (png_ptr->transformations & PNG_PACK)
      png_do_pack(&(png_ptr->row_info), png_ptr->row_buf + 1,
         (png_uint_32)png_ptr->bit_depth);
#endif
#if defined(PNG_WRITE_SWAP_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_BYTES)
      png_do_swap(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_SHIFT_SUPPORTED)
   if (png_ptr->transformations & PNG_SHIFT)
      png_do_shift(&(png_ptr->row_info), png_ptr->row_buf + 1,
         &(png_ptr->shift));
#endif
#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_ALPHA)
      png_do_write_invert_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
   if (png_ptr->transformations & PNG_SWAP_ALPHA)
      png_do_write_swap_alpha(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_BGR_SUPPORTED)
   if (png_ptr->transformations & PNG_BGR)
      png_do_bgr(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
#if defined(PNG_WRITE_INVERT_SUPPORTED)
   if (png_ptr->transformations & PNG_INVERT_MONO)
      png_do_invert(&(png_ptr->row_info), png_ptr->row_buf + 1);
#endif
}

#if defined(PNG_WRITE_PACK_SUPPORTED)
/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
 * row_info bit depth should be 8 (one pixel per byte).  The channels
 * should be 1 (this only happens on grayscale and paletted images).
 */
void /* PRIVATE */
png_do_pack(png_row_infop row_info, png_bytep row, png_uint_32 bit_depth)
{
   png_debug(1, "in png_do_pack\n");
   if (row_info->bit_depth == 8 &&
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
      row_info->channels == 1)
   {
      switch ((int)bit_depth)
      {
         case 1:
         {
            png_bytep sp, dp;
            int mask, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            mask = 0x80;
            v = 0;

            for (i = 0; i < row_width; i++)
            {
               if (*sp != 0)
                  v |= mask;
               sp++;
               if (mask > 1)
                  mask >>= 1;
               else
               {
                  mask = 0x80;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
            }
            if (mask != 0x80)
               *dp = (png_byte)v;
            break;
         }
         case 2:
         {
            png_bytep sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 6;
            v = 0;
            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0x03);
               v |= (value << shift);
               if (shift == 0)
               {
                  shift = 6;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
               else
                  shift -= 2;
               sp++;
            }
            if (shift != 6)
               *dp = (png_byte)v;
            break;
         }
         case 4:
         {
            png_bytep sp, dp;
            int shift, v;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            sp = row;
            dp = row;
            shift = 4;
            v = 0;
            for (i = 0; i < row_width; i++)
            {
               png_byte value;

               value = (png_byte)(*sp & 0x0f);
               v |= (value << shift);

               if (shift == 0)
               {
                  shift = 4;
                  *dp = (png_byte)v;
                  dp++;
                  v = 0;
               }
               else
                  shift -= 4;

               sp++;
            }
            if (shift != 4)
               *dp = (png_byte)v;
            break;
         }
      }
      row_info->bit_depth = (png_byte)bit_depth;
      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
      row_info->rowbytes =
         ((row_info->width * row_info->pixel_depth + 7) >> 3);
   }
}
#endif

#if defined(PNG_WRITE_SHIFT_SUPPORTED)
/* Shift pixel values to take advantage of whole range.  Pass the
 * true number of bits in bit_depth.  The row should be packed
 * according to row_info->bit_depth.  Thus, if you had a row of
 * bit depth 4, but the pixels only had values from 0 to 7, you
 * would pass 3 as bit_depth, and this routine would translate the
 * data to 0 to 15.
 */
void /* PRIVATE */
png_do_shift(png_row_infop row_info, png_bytep row, png_color_8p bit_depth)
{
   png_debug(1, "in png_do_shift\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL &&
#else
   if (
#endif
      row_info->color_type != PNG_COLOR_TYPE_PALETTE)
   {
      int shift_start[4], shift_dec[4];
      int channels = 0;

      if (row_info->color_type & PNG_COLOR_MASK_COLOR)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->red;
         shift_dec[channels] = bit_depth->red;
         channels++;
         shift_start[channels] = row_info->bit_depth - bit_depth->green;
         shift_dec[channels] = bit_depth->green;
         channels++;
         shift_start[channels] = row_info->bit_depth - bit_depth->blue;
         shift_dec[channels] = bit_depth->blue;
         channels++;
      }
      else
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->gray;
         shift_dec[channels] = bit_depth->gray;
         channels++;
      }
      if (row_info->color_type & PNG_COLOR_MASK_ALPHA)
      {
         shift_start[channels] = row_info->bit_depth - bit_depth->alpha;
         shift_dec[channels] = bit_depth->alpha;
         channels++;
      }

      /* with low row depths, could only be grayscale, so one channel */
      if (row_info->bit_depth < 8)
      {
         png_bytep bp = row;
         png_uint_32 i;
         png_byte mask;
         png_uint_32 row_bytes = row_info->rowbytes;

         if (bit_depth->gray == 1 && row_info->bit_depth == 2)
            mask = 0x55;
         else if (row_info->bit_depth == 4 && bit_depth->gray == 3)
            mask = 0x11;
         else
            mask = 0xff;

         for (i = 0; i < row_bytes; i++, bp++)
         {
            png_uint_16 v;
            int j;

            v = *bp;
            *bp = 0;
            for (j = shift_start[0]; j > -shift_dec[0]; j -= shift_dec[0])
            {
               if (j > 0)
                  *bp |= (png_byte)((v << j) & 0xff);
               else
                  *bp |= (png_byte)((v >> (-j)) & mask);
            }
         }
      }
      else if (row_info->bit_depth == 8)
      {
         png_bytep bp = row;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (i = 0; i < istop; i++, bp++)
         {

            png_uint_16 v;
            int j;
            int c = (int)(i%channels);

            v = *bp;
            *bp = 0;
            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  *bp |= (png_byte)((v << j) & 0xff);
               else
                  *bp |= (png_byte)((v >> (-j)) & 0xff);
            }
         }
      }
      else
      {
         png_bytep bp;
         png_uint_32 i;
         png_uint_32 istop = channels * row_info->width;

         for (bp = row, i = 0; i < istop; i++)
         {
            int c = (int)(i%channels);
            png_uint_16 value, v;
            int j;

            v = (png_uint_16)(((png_uint_16)(*bp) << 8) + *(bp + 1));
            value = 0;
            for (j = shift_start[c]; j > -shift_dec[c]; j -= shift_dec[c])
            {
               if (j > 0)
                  value |= (png_uint_16)((v << j) & (png_uint_16)0xffff);
               else
                  value |= (png_uint_16)((v >> (-j)) & (png_uint_16)0xffff);
            }
            *bp++ = (png_byte)(value >> 8);
            *bp++ = (png_byte)(value & 0xff);
         }
      }
   }
}
#endif

#if defined(PNG_WRITE_SWAP_ALPHA_SUPPORTED)
void /* PRIVATE */
png_do_write_swap_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_swap_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This converts from ARGB to RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }
         /* This converts from AARRGGBB to RRGGBBAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This converts from AG to GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save;
            }
         }
         /* This converts from AAGG to GGAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               png_byte save[2];
               save[0] = *(sp++);
               save[1] = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = save[0];
               *(dp++) = save[1];
            }
         }
      }
   }
}
#endif

#if defined(PNG_WRITE_INVERT_ALPHA_SUPPORTED)
void /* PRIVATE */
png_do_write_invert_alpha(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_invert_alpha\n");
#if defined(PNG_USELESS_TESTS_SUPPORTED)
   if (row != NULL && row_info != NULL)
#endif
   {
      if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
      {
         /* This inverts the alpha channel in RGBA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;
            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
         /* This inverts the alpha channel in RRGGBBAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
      }
      else if (row_info->color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      {
         /* This inverts the alpha channel in GA */
         if (row_info->bit_depth == 8)
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
         /* This inverts the alpha channel in GGAA */
         else
         {
            png_bytep sp, dp;
            png_uint_32 i;
            png_uint_32 row_width = row_info->width;

            for (i = 0, sp = dp = row; i < row_width; i++)
            {
               *(dp++) = *(sp++);
               *(dp++) = *(sp++);
               *(dp++) = (png_byte)(255 - *(sp++));
               *(dp++) = (png_byte)(255 - *(sp++));
            }
         }
      }
   }
}
#endif

#if defined(PNG_MNG_FEATURES_SUPPORTED)
/* undoes intrapixel differencing  */
void /* PRIVATE */
png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
{
   png_debug(1, "in png_do_write_intrapixel\n");
   if (
#if defined(PNG_USELESS_TESTS_SUPPORTED)
       row != NULL && row_info != NULL &&
#endif
       (row_info->color_type & PNG_COLOR_MASK_COLOR))
   {
      int bytes_per_pixel;
      png_uint_32 row_width = row_info->width;
      if (row_info->bit_depth == 8)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 3;
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 4;
         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            *(rp)   = (png_byte)((*rp     - *(rp+1))&0xff);
            *(rp+2) = (png_byte)((*(rp+2) - *(rp+1))&0xff);
         }
      }
      else if (row_info->bit_depth == 16)
      {
         png_bytep rp;
         png_uint_32 i;

         if (row_info->color_type == PNG_COLOR_TYPE_RGB)
            bytes_per_pixel = 6;
         else if (row_info->color_type == PNG_COLOR_TYPE_RGB_ALPHA)
            bytes_per_pixel = 8;
         else
            return;

         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
         {
            png_uint_32 s0=*(rp  )<<8 | *(rp+1);
            png_uint_32 s1=*(rp+2)<<8 | *(rp+3);
            png_uint_32 s2=*(rp+4)<<8 | *(rp+5);
            png_uint_32 red=(s0-s1)&0xffff;
            png_uint_32 blue=(s2-s1)&0xffff;
            *(rp  ) = (png_byte)((red>>8)&0xff);
            *(rp+1) = (png_byte)(red&0xff);
            *(rp+4) = (png_byte)((blue>>8)&0xff);
            *(rp+5) = (png_byte)(blue&0xff);
         }
      }
   }
}
#endif /* PNG_MNG_FEATURES_SUPPORTED */
#endif /* PNG_WRITE_SUPPORTED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\adler32.c ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\compress.c ===
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\deflate.c ===
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

const char deflate_copyright[] =
   " deflate 1.1.3 Copyright 1995-1998 Jean-loup Gailly ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
local block_state deflate_slow   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

struct static_tree_desc_s {int dummy;}; /* for buggy compilers */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
			 Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
		  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int noheader = 0;
    static const char* my_version = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
	return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == Z_NULL) {
	strm->zalloc = zcalloc;
	strm->opaque = (voidpf)0;
    }
    if (strm->zfree == Z_NULL) strm->zfree = zcfree;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#ifdef FASTEST
    level = 1;
#endif

    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
        noheader = 1;
        windowBits = -windowBits;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->noheader = noheader;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt length = dictLength;
    uInt n;
    IPos hash_head = 0;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

    s = strm->state;
    strm->adler = adler32(strm->adler, dictionary, dictLength);

    if (length < MIN_MATCH) return Z_OK;
    if (length > MAX_DIST(s)) {
	length = MAX_DIST(s);
#ifndef USE_DICT_HEAD
	dictionary += dictLength - length; /* use the tail of the dictionary */
#endif
    }
    zmemcpy(s->window, dictionary, length);
    s->strstart = length;
    s->block_start = (long)length;

    /* Insert all strings in the hash table (except for the last two bytes).
     * s->lookahead stays null, so s->ins_h will be recomputed at the next
     * call of fill_window.
     */
    s->ins_h = s->window[0];
    UPDATE_HASH(s, s->ins_h, s->window[1]);
    for (n = 0; n <= length - MIN_MATCH; n++) {
	INSERT_STRING(s, n, hash_head);
    }
    if (hash_head) hash_head = 0;  /* to make compiler happy */
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    deflate_state *s;
    
    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->noheader < 0) {
        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
    }
    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
    strm->adler = 1;
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);
    lm_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if (func != configuration_table[level].func && strm->total_in != 0) {
	/* Flush the last buffer: */
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}   

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len = strm->state->pending;

    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, strm->state->pending_out, len);
    strm->next_out  += len;
    strm->state->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    strm->state->pending -= len;
    if (strm->state->pending == 0) {
        strm->state->pending_out = strm->state->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the zlib header */
    if (s->status == INIT_STATE) {

        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;

        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        s->status = BUSY_STATE;
        putShortMSB(s, header);

	/* Save the adler32 of the preset dictionary: */
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    /* Since avail_out is 0, deflate will be called again with
	     * more output space, but possibly with both pending and
	     * avail_in equal to zero. There won't be anything to do,
	     * but this is not an error situation so make sure we
	     * return OK instead of BUF_ERROR at next call of deflate:
             */
	    s->last_flush = -1;
	    return Z_OK;
	}

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
     */
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

	bstate = (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
	    }
	    return Z_OK;
	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	     * of deflate should use the same flush parameter to make sure
	     * that the flush is complete. So we don't have to output an
	     * empty block here, this will be done at next call. This also
	     * ensures that for a very small output buffer, we emit at most
	     * one empty block.
	     */
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->noheader) return Z_STREAM_END;

    /* Write the zlib trailer (adler32) */
    putShortMSB(s, (uInt)(strm->adler >> 16));
    putShortMSB(s, (uInt)(strm->adler & 0xffff));
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    s->noheader = -1; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE && status != BUSY_STATE &&
	status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    *dest = *source;

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    *ds = *ss;
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(strm, buf, size)
    z_streamp strm;
    Bytef *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    if (!strm->state->noheader) {
        strm->adler = adler32(strm->adler, strm->next_in, len);
    }
    zmemcpy(buf, strm->next_in, len);
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
#ifndef FASTEST
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}

#else /* FASTEST */
/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return len <= s->lookahead ? len : s->lookahead;
}
#endif /* FASTEST */
#endif /* ASMV */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
		start, match, length);
        do {
	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
	} while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            more = wsize;

        } else if (more == (unsigned)(-1)) {
            /* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */
            more--;

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        } else if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
	    n = s->hash_size;
	    p = &s->head[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
	    } while (--n);

	    n = wsize;
#ifndef FASTEST
	    p = &s->prev[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
		/* If n is not on any hash chain, prev[n] is garbage but
		 * its value will never be used.
		 */
	    } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) return;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead >= MIN_MATCH) {
            s->ins_h = s->window[s->strstart];
            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
		(ulg)((long)s->strstart - s->block_start), \
		(eof)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
		   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
	Assert(s->block_start >= 0L, "block gone");

	s->strstart += s->lookahead;
	s->lookahead = 0;

	/* Emit a stored block if pending_buf will be full: */
 	max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
	    /* strstart == 0 is possible when wraparound on 16-bit machine */
	    s->lookahead = (uInt)(s->strstart - max_start);
	    s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
	}
	/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
	}
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL; /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in hash table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++; 
            } else
#endif
	    {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++; 
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL;    /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
                 (s->match_length == MIN_MATCH &&
                  s->strstart - s->match_start > TOO_FAR))) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
			   s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
	    if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\deflate.h ===
/* deflate.h -- internal compression state
 * Copyright (C) 1995-1998 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _DEFLATE_H
#define _DEFLATE_H

#include "zutil.h"

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    int   pending;       /* nb of bytes in the pending buffer */
    int   noheader;      /* suppress zlib header and adler32 */
    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
    Byte  method;        /* STORED (for zip only) or DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to supress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    int last_eob_len;   /* bit length of EOB code for last block */

#ifdef DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

        /* in trees.c */
void _tr_init         OF((deflate_state *s));
int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
			  int eof));
void _tr_align        OF((deflate_state *s));
void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                          int eof));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch _length_code[];
  extern uch _dist_code[];
#else
  extern const uch _length_code[];
  extern const uch _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length) 
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp));

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */

extern int inflate_blocks_sync_point OF((
    inflate_blocks_statef *s));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infblock.c ===
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* Table for deflate from PKZIP's appnote.txt. */
local const uInt border[] = { /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_streamp z;
uLongf *c;
{
  if (c != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens);
  if (s->mode == CODES)
    inflate_codes_free(s->sub.decode.codes, z);
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
  Tracev((stderr, "inflate:   blocks reset\n"));
}


inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_streamp z;
check_func c;
uInt w;
{
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->hufts =
       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
  {
    ZFREE(z, s);
    return Z_NULL;
  }
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
  {
    ZFREE(z, s->hufts);
    ZFREE(z, s);
    return Z_NULL;
  }
  s->end = s->window + w;
  s->checkfn = c;
  s->mode = TYPE;
  Tracev((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, Z_NULL);
  return s;
}


int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input based on current state */
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
      switch (t >> 1)
      {
        case 0:                         /* stored */
          Tracev((stderr, "inflate:     stored block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          t = k & 7;                    /* go to byte boundary */
          DUMPBITS(t)
          s->mode = LENS;               /* get length of stored block */
          break;
        case 1:                         /* fixed */
          Tracev((stderr, "inflate:     fixed codes block%s\n",
                 s->last ? " (last)" : ""));
          {
            uInt bl, bd;
            inflate_huft *tl, *td;

            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
            if (s->sub.decode.codes == Z_NULL)
            {
              r = Z_MEM_ERROR;
              LEAVE
            }
          }
          DUMPBITS(3)
          s->mode = CODES;
          break;
        case 2:                         /* dynamic */
          Tracev((stderr, "inflate:     dynamic codes block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          s->mode = TABLE;
          break;
        case 3:                         /* illegal */
          DUMPBITS(3)
          s->mode = BAD;
          z->msg = (char*)"invalid block type";
          r = Z_DATA_ERROR;
          LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
      {
        s->mode = BAD;
        z->msg = (char*)"invalid stored block lengths";
        r = Z_DATA_ERROR;
        LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
      break;
    case STORED:
      if (n == 0)
        LEAVE
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
        break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
      {
        s->mode = BAD;
        z->msg = (char*)"too many length or distance symbols";
        r = Z_DATA_ERROR;
        LEAVE
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
        r = Z_MEM_ERROR;
        LEAVE
      }
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
        NEEDBITS(3)
        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
        DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
                             &s->sub.trees.tb, s->hufts, z);
      if (t != Z_OK)
      {
        ZFREE(z, s->sub.trees.blens);
        r = t;
        if (r == Z_DATA_ERROR)
          s->mode = BAD;
        LEAVE
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
    case DTREE:
      while (t = s->sub.trees.table,
             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
        inflate_huft *h;
        uInt i, j, c;

        t = s->sub.trees.bb;
        NEEDBITS(t)
        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
        t = h->bits;
        c = h->base;
        if (c < 16)
        {
          DUMPBITS(t)
          s->sub.trees.blens[s->sub.trees.index++] = c;
        }
        else /* c == 16..18 */
        {
          i = c == 18 ? 7 : c - 14;
          j = c == 18 ? 11 : 3;
          NEEDBITS(t + i)
          DUMPBITS(t)
          j += (uInt)b & inflate_mask[i];
          DUMPBITS(i)
          i = s->sub.trees.index;
          t = s->sub.trees.table;
          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
              (c == 16 && i < 1))
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
            z->msg = (char*)"invalid bit length repeat";
            r = Z_DATA_ERROR;
            LEAVE
          }
          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
          do {
            s->sub.trees.blens[i++] = c;
          } while (--j);
          s->sub.trees.index = i;
        }
      }
      s->sub.trees.tb = Z_NULL;
      {
        uInt bl, bd;
        inflate_huft *tl, *td;
        inflate_codes_statef *c;

        bl = 9;         /* must be <= 9 for lookahead assumptions */
        bd = 6;         /* must be <= 9 for lookahead assumptions */
        t = s->sub.trees.table;
        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
                                  s->hufts, z);
        ZFREE(z, s->sub.trees.blens);
        if (t != Z_OK)
        {
          if (t == (uInt)Z_DATA_ERROR)
            s->mode = BAD;
          r = t;
          LEAVE
        }
        Tracev((stderr, "inflate:       trees ok\n"));
        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
        {
          r = Z_MEM_ERROR;
          LEAVE
        }
        s->sub.decode.codes = c;
      }
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
        return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      LOAD
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      if (!s->last)
      {
        s->mode = TYPE;
        break;
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
        LEAVE
      s->mode = DONE;
    case DONE:
      r = Z_STREAM_END;
      LEAVE
    case BAD:
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


int inflate_blocks_free(s, z)
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_blocks_reset(s, z, Z_NULL);
  ZFREE(z, s->window);
  ZFREE(z, s->hufts);
  ZFREE(z, s);
  Tracev((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
}


void inflate_set_dictionary(s, d, n)
inflate_blocks_statef *s;
const Bytef *d;
uInt  n;
{
  zmemcpy(s->window, d, n);
  s->read = s->write = s->window + n;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
 * IN assertion: s != Z_NULL
 */
int inflate_blocks_sync_point(s)
inflate_blocks_statef *s;
{
  return s->mode == LENS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\gzio.c ===
/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_DEFLATE to avoid the compression code.
 */

/* @(#) $Id$ */

#include <stdio.h>

#include "zutil.h"

struct internal_state {int dummy;}; /* for buggy compilers */

#ifndef Z_BUFSIZE
#  ifdef MAXSEG_64K
#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
#  else
#    define Z_BUFSIZE 16384
#  endif
#endif
#ifndef Z_PRINTF_BUFSIZE
#  define Z_PRINTF_BUFSIZE 4096
#endif

#define ALLOC(size) malloc(size)
#define TRYFREE(p) {if (p) free(p);}

static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

typedef struct gz_stream {
    z_stream stream;
    int      z_err;   /* error code for last stream operation */
    int      z_eof;   /* set if end of input file */
    FILE     *file;   /* .gz file */
    Byte     *inbuf;  /* input buffer */
    Byte     *outbuf; /* output buffer */
    uLong    crc;     /* crc32 of uncompressed data */
    char     *msg;    /* error message */
    char     *path;   /* path name for debugging only */
    int      transparent; /* 1 if input file is not a .gz file */
    char     mode;    /* 'w' or 'r' */
    long     startpos; /* start of compressed data in file (header skipped) */
} gz_stream;


local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
local int do_flush        OF((gzFile file, int flush));
local int    get_byte     OF((gz_stream *s));
local void   check_header OF((gz_stream *s));
local int    destroy      OF((gz_stream *s));
local void   putLong      OF((FILE *file, uLong x));
local uLong  getLong      OF((gz_stream *s));

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open return NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/
local gzFile gz_open (path, mode, fd)
    const char *path;
    const char *mode;
    int  fd;
{
    int err;
    int level = Z_DEFAULT_COMPRESSION; /* compression level */
    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
    char *p = (char*)mode;
    gz_stream *s;
    char fmode[80]; /* copy of mode, without the compression level */
    char *m = fmode;

    if (!path || !mode) return Z_NULL;

    s = (gz_stream *)ALLOC(sizeof(gz_stream));
    if (!s) return Z_NULL;

    s->stream.zalloc = (alloc_func)0;
    s->stream.zfree = (free_func)0;
    s->stream.opaque = (voidpf)0;
    s->stream.next_in = s->inbuf = Z_NULL;
    s->stream.next_out = s->outbuf = Z_NULL;
    s->stream.avail_in = s->stream.avail_out = 0;
    s->file = NULL;
    s->z_err = Z_OK;
    s->z_eof = 0;
    s->crc = crc32(0L, Z_NULL, 0);
    s->msg = NULL;
    s->transparent = 0;

    s->path = (char*)ALLOC(strlen(path)+1);
    if (s->path == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    strcpy(s->path, path); /* do this early for debugging */

    s->mode = '\0';
    do {
        if (*p == 'r') s->mode = 'r';
        if (*p == 'w' || *p == 'a') s->mode = 'w';
        if (*p >= '0' && *p <= '9') {
	    level = *p - '0';
	} else if (*p == 'f') {
	  strategy = Z_FILTERED;
	} else if (*p == 'h') {
	  strategy = Z_HUFFMAN_ONLY;
	} else {
	    *m++ = *p; /* copy the mode */
	}
    } while (*p++ && m != fmode + sizeof(fmode));
    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
        err = Z_STREAM_ERROR;
#else
        err = deflateInit2(&(s->stream), level,
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
        /* windowBits is passed < 0 to suppress zlib header */

        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
#endif
        if (err != Z_OK || s->outbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    } else {
        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

        err = inflateInit2(&(s->stream), -MAX_WBITS);
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */
        if (err != Z_OK || s->inbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    }
    s->stream.avail_out = Z_BUFSIZE;

    errno = 0;
    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

    if (s->file == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    if (s->mode == 'w') {
        /* Write a very simple .gz header:
         */
        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
	s->startpos = 10L;
	/* We use 10L instead of ftell(s->file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * startpos anyway in write mode, so this initialization is not
         * necessary.
         */
    } else {
	check_header(s); /* skip the .gz header */
	s->startpos = (ftell(s->file) - s->stream.avail_in);
    }
    
    return (gzFile)s;
}

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/
gzFile ZEXPORT gzopen (path, mode)
    const char *path;
    const char *mode;
{
    return gz_open (path, mode, -1);
}

/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/
gzFile ZEXPORT gzdopen (fd, mode)
    int fd;
    const char *mode;
{
    char name[20];

    if (fd < 0) return (gzFile)Z_NULL;
    sprintf(name, "<fd:%d>", fd); /* for debugging */

    return gz_open (name, mode, fd);
}

/* ===========================================================================
 * Update the compression level and strategy
 */
int ZEXPORT gzsetparams (file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    /* Make room to allow flushing */
    if (s->stream.avail_out == 0) {

	s->stream.next_out = s->outbuf;
	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
	    s->z_err = Z_ERRNO;
	}
	s->stream.avail_out = Z_BUFSIZE;
    }

    return deflateParams (&(s->stream), level, strategy);
}

/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/
local int get_byte(s)
    gz_stream *s;
{
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
	errno = 0;
	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
	if (s->stream.avail_in == 0) {
	    s->z_eof = 1;
	    if (ferror(s->file)) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
}

/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s->err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created sucessfully;
       s->stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/
local void check_header(s)
    gz_stream *s;
{
    int method; /* method byte */
    int flags;  /* flags byte */
    uInt len;
    int c;

    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
    }
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
	s->z_err = Z_DATA_ERROR;
	return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
	len  =  (uInt)get_byte(s);
	len += ((uInt)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
	for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

 /* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */
local int destroy (s)
    gz_stream *s;
{
    int err = Z_OK;

    if (!s) return Z_STREAM_ERROR;

    TRYFREE(s->msg);

    if (s->stream.state != NULL) {
	if (s->mode == 'w') {
#ifdef NO_DEFLATE
	    err = Z_STREAM_ERROR;
#else
	    err = deflateEnd(&(s->stream));
#endif
	} else if (s->mode == 'r') {
	    err = inflateEnd(&(s->stream));
	}
    }
    if (s->file != NULL && fclose(s->file)) {
#ifdef ESPIPE
	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
#endif
	    err = Z_ERRNO;
    }
    if (s->z_err < 0) err = s->z_err;

    TRYFREE(s->inbuf);
    TRYFREE(s->outbuf);
    TRYFREE(s->path);
    TRYFREE(s);
    return err;
}

/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/
int ZEXPORT gzread (file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;
    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */

    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

    next_out = (Byte*)buf;
    s->stream.next_out = (Bytef*)buf;
    s->stream.avail_out = len;

    while (s->stream.avail_out != 0) {

	if (s->transparent) {
	    /* Copy first the lookahead bytes: */
	    uInt n = s->stream.avail_in;
	    if (n > s->stream.avail_out) n = s->stream.avail_out;
	    if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		next_out += n;
		s->stream.next_out = next_out;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	    }
	    if (s->stream.avail_out > 0) {
		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
					     s->file);
	    }
	    len -= s->stream.avail_out;
	    s->stream.total_in  += (uLong)len;
	    s->stream.total_out += (uLong)len;
            if (len == 0) s->z_eof = 1;
	    return (int)len;
	}
        if (s->stream.avail_in == 0 && !s->z_eof) {

            errno = 0;
            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
            if (s->stream.avail_in == 0) {
                s->z_eof = 1;
		if (ferror(s->file)) {
		    s->z_err = Z_ERRNO;
		    break;
		}
            }
            s->stream.next_in = s->inbuf;
        }
        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

	if (s->z_err == Z_STREAM_END) {
	    /* Check CRC and original size */
	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
	    start = s->stream.next_out;

	    if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	    } else {
	        (void)getLong(s);
                /* The uncompressed length returned by above getlong() may
                 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		    uLong total_in = s->stream.total_in;
		    uLong total_out = s->stream.total_out;

		    inflateReset(&(s->stream));
		    s->stream.total_in = total_in;
		    s->stream.total_out = total_out;
		    s->crc = crc32(0L, Z_NULL, 0);
		}
	    }
	}
	if (s->z_err != Z_OK || s->z_eof) break;
    }
    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

    return (int)(len - s->stream.avail_out);
}


/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/
int ZEXPORT gzgetc(file)
    gzFile file;
{
    unsigned char c;

    return gzread(file, &c, 1) == 1 ? c : -1;
}


/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    char *b = buf;
    if (buf == Z_NULL || len <= 0) return Z_NULL;

    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    *buf = '\0';
    return b == buf && len > 0 ? Z_NULL : b;
}


#ifndef NO_DEFLATE
/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/
int ZEXPORT gzwrite (file, buf, len)
    gzFile file;
    const voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.next_in = (Bytef*)buf;
    s->stream.avail_in = len;

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {

            s->stream.next_out = s->outbuf;
            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
                s->z_err = Z_ERRNO;
                break;
            }
            s->stream.avail_out = Z_BUFSIZE;
        }
        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
        if (s->z_err != Z_OK) break;
    }
    s->crc = crc32(s->crc, (const Bytef *)buf, len);

    return (int)(len - s->stream.avail_in);
}

/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/
#ifdef STDC
#include <stdarg.h>

int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}
#else /* not ANSI C */

int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}
#endif

/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned char cc = (unsigned char) c; /* required for big endian systems */

    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
}


/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/
int ZEXPORT gzputs(file, s)
    gzFile file;
    const char *s;
{
    return gzwrite(file, (char*)s, (unsigned)strlen(s));
}


/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/
local int do_flush (file, flush)
    gzFile file;
    int flush;
{
    uInt len;
    int done = 0;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.avail_in = 0; /* should be zero already anyway */

    for (;;) {
        len = Z_BUFSIZE - s->stream.avail_out;

        if (len != 0) {
            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
                s->z_err = Z_ERRNO;
                return Z_ERRNO;
            }
            s->stream.next_out = s->outbuf;
            s->stream.avail_out = Z_BUFSIZE;
        }
        if (done) break;
        s->z_err = deflate(&(s->stream), flush);

	/* Ignore the second of two consecutive flushes: */
	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
 
        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    }
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}

int ZEXPORT gzflush (file, flush)
     gzFile file;
     int flush;
{
    gz_stream *s = (gz_stream*)file;
    int err = do_flush (file, flush);

    if (err) return err;
    fflush(s->file);
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}
#endif /* NO_DEFLATE */

/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/
z_off_t ZEXPORT gzseek (file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || whence == SEEK_END ||
	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
	return -1L;
    }
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return -1L;
#else
	if (whence == SEEK_SET) {
	    offset -= s->stream.total_in;
	}
	if (offset < 0) return -1L;

	/* At this point, offset is the number of zero bytes to write. */
	if (s->inbuf == Z_NULL) {
	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
	    zmemzero(s->inbuf, Z_BUFSIZE);
	}
	while (offset > 0)  {
	    uInt size = Z_BUFSIZE;
	    if (offset < Z_BUFSIZE) size = (uInt)offset;

	    size = gzwrite(file, s->inbuf, size);
	    if (size == 0) return -1L;

	    offset -= size;
	}
	return (z_off_t)s->stream.total_in;
#endif
    }
    /* Rest of function is for reading only */

    /* compute absolute position */
    if (whence == SEEK_CUR) {
	offset += s->stream.total_out;
    }
    if (offset < 0) return -1L;

    if (s->transparent) {
	/* map to fseek */
	s->stream.avail_in = 0;
	s->stream.next_in = s->inbuf;
        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

	s->stream.total_in = s->stream.total_out = (uLong)offset;
	return offset;
    }

    /* For a negative seek, rewind and use positive seek */
    if ((uLong)offset >= s->stream.total_out) {
	offset -= s->stream.total_out;
    } else if (gzrewind(file) < 0) {
	return -1L;
    }
    /* offset is now the number of bytes to skip. */

    if (offset != 0 && s->outbuf == Z_NULL) {
	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    }
    while (offset > 0)  {
	int size = Z_BUFSIZE;
	if (offset < Z_BUFSIZE) size = (int)offset;

	size = gzread(file, s->outbuf, (uInt)size);
	if (size <= 0) return -1L;
	offset -= size;
    }
    return (z_off_t)s->stream.total_out;
}

/* ===========================================================================
     Rewinds input file. 
*/
int ZEXPORT gzrewind (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    if (s == NULL || s->mode != 'r') return -1;

    s->z_err = Z_OK;
    s->z_eof = 0;
    s->stream.avail_in = 0;
    s->stream.next_in = s->inbuf;
    s->crc = crc32(0L, Z_NULL, 0);
	
    if (s->startpos == 0) { /* not a compressed file */
	rewind(s->file);
	return 0;
    }

    (void) inflateReset(&s->stream);
    return fseek(s->file, s->startpos, SEEK_SET);
}

/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/
z_off_t ZEXPORT gztell (file)
    gzFile file;
{
    return gzseek(file, 0L, SEEK_CUR);
}

/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/
int ZEXPORT gzeof (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
}

/* ===========================================================================
   Outputs a long in LSB order to the given file
*/
local void putLong (file, x)
    FILE *file;
    uLong x;
{
    int n;
    for (n = 0; n < 4; n++) {
        fputc((int)(x & 0xff), file);
        x >>= 8;
    }
}

/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/
local uLong getLong (s)
    gz_stream *s;
{
    uLong x = (uLong)get_byte(s);
    int c;

    x += ((uLong)get_byte(s))<<8;
    x += ((uLong)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (file)
    gzFile file;
{
    int err;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
#else
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, s->stream.total_in);
#endif
    }
    return destroy((gz_stream*)file);
}

/* ===========================================================================
     Returns the error message for the last error which occured on the
   given compressed file. errnum is set to zlib error number. If an
   error occured in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char*  ZEXPORT gzerror (file, errnum)
    gzFile file;
    int *errnum;
{
    char *m;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
    return (const char*)s->msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infcodes.c ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
inflate_codes_mode;

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  inflate_codes_mode mode;      /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
z_streamp z;
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
#ifndef __TURBOC__ /* Turbo C bug for following expression */
      f = (uInt)(q - s->window) < c->sub.copy.dist ?
          s->end - (c->sub.copy.dist - (q - s->window)) :
          q - c->sub.copy.dist;
#else
      f = q - c->sub.copy.dist;
      if ((uInt)(q - s->window) < c->sub.copy.dist)
        f = s->end - (c->sub.copy.dist - (uInt)(q - s->window));
#endif
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      if (k > 7)        /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;            /* can always return one */
      }
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_streamp z;
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inffixed.h ===
/* inffixed.h -- table for decoding fixed codes
 * Generated automatically by the maketree.c program
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

local uInt fixed_bl = 9;
local uInt fixed_bd = 5;
local inflate_huft fixed_tl[] = {
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
  };
local inflate_huft fixed_td[] = {
    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
  };
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
  uInt base;            /* literal, length base, distance base,
                           or table offset */
};

/* Maximum size of dynamic tree.  The maximum found in a long but non-
   exhaustive search was 1004 huft structures (850 for length/literals
   and 154 for distances, the latter actually the result of an
   exhaustive search).  The actual maximum is not known, but the
   value below is more than safe. */
#define MANY 1440

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    z_streamp));                /* for memory allocation */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inflate.c ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

typedef enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
inflate_mode;

/* inflate private state */
struct internal_state {

  /* mode */
  inflate_mode  mode;   /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int ZEXPORT inflateReset(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
  Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}


int ZEXPORT inflateEnd(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Tracev((stderr, "inflate: end\n"));
  return Z_OK;
}


int ZEXPORT inflateInit2_(z, w, version, stream_size)
z_streamp z;
int w;
const char *version;
int stream_size;
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Tracev((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int ZEXPORT inflateInit_(z, version, stream_size)
z_streamp z;
const char *version;
int stream_size;
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int ZEXPORT inflate(z, f)
z_streamp z;
int f;
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
    return Z_STREAM_ERROR;
  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
        break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r == Z_OK)
        r = f;
      if (r != Z_STREAM_END)
        return r;
      r = f;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
z_streamp z;
const Bytef *dictionary;
uInt  dictLength;
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int ZEXPORT inflateSync(z)
z_streamp z;
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    static const Byte mark[4] = {0, 0, 0xff, 0xff};
    if (*p == mark[m])
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += p - z->next_in;
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
 * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
 * but removes the length bytes of the resulting empty stored block. When
 * decompressing, PPP checks that at the end of input packet, inflate is
 * waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
    return Z_STREAM_ERROR;
  return inflate_blocks_sync_point(z->state->blocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inffast.c ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            if ((uInt)(q - s->window) >= d)     /* offset before dest */
            {                                   /*  just copy */
              r = q - d;
              *q++ = *r++;  c--;        /* minimum count is three, */
              *q++ = *r++;  c--;        /*  so unroll loop a little */
            }
            else                        /* else offset after destination */
            {
              e = d - (uInt)(q - s->window); /* bytes from offset to end */
              r = s->end - e;           /* pointer to offset */
              if (c > e)                /* if source crosses, */
              {
                c -= e;                 /* copy to end of window */
                do {
                  *q++ = *r++;
                } while (--e);
                r = s->window;          /* copy rest from start of window */
              }
            }
            do {                        /* copy all or what's left */
              *q++ = *r++;
            } while (--c);
            break;
          }
          else if ((e & 64) == 0)
          {
            t += t->base;
            e = (t += ((uInt)b & inflate_mask[e]))->exop;
          }
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        t += t->base;
        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\inftrees.c ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

#if !defined(BUILDFIXED) && !defined(STDC)
#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
#endif

const char inflate_copyright[] =
   " inflate 1.1.3 Copyright 1995-1998 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    const uIntf *,      /* list of base values for non-simple codes */
    const uIntf *,      /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    inflate_huft *,     /* space for trees */
    uInt *,             /* hufts used in space */
    uIntf * ));         /* space for values */

/* Tables for deflate from PKZIP's appnote.txt. */
local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* see note #13 above about 258 */
local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local const uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */

local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
uInt n;                 /* number of codes (assumed <= 288) */
uInt s;                 /* number of simple-valued codes (0..s-1) */
const uIntf *d;         /* list of base values for non-simple codes */
const uIntf *e;         /* list of extra bits for non-simple codes */
inflate_huft * FAR *t;  /* result: starting table */
uIntf *m;               /* maximum lookup bits, returns actual */
inflate_huft *hp;       /* space for trees */
uInt *hn;               /* hufts used in space */
uIntf *v;               /* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of
   lengths), or Z_MEM_ERROR if not enough memory. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate new table */
        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
          return Z_MEM_ERROR;   /* not enough memory */
        u[h] = q = hp + *hn;
        *hn += z;

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          j = i >> (w - l);
          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
          u[h-1][j] = r;        /* connect to last table */
        }
        else
          *t = q;               /* first table is returned result */
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
      while ((i & mask) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
        mask = (1 << w) - 1;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(c, bb, tb, hp, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;
  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
                 tb, bb, hp, &hn, v);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR || *bb == 0)
  {
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  ZFREE(z, v);
  return r;
}


int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
uInt nl;                /* number of literal/length codes */
uInt nd;                /* number of distance codes */
uIntf *c;               /* that many (total) code lengths */
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  /* allocate work area */
  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;

  /* build literal/length tree */
  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
  if (r != Z_OK || *bl == 0)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
  }

  /* build distance tree */
  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
  if (r != Z_OK || (*bd == 0 && nl > 257))
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed distance tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      z->msg = (char*)"incomplete distance tree";
      r = Z_DATA_ERROR;
    }
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"empty distance tree with lengths";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
#endif
  }

  /* done */
  ZFREE(z, v);
  return Z_OK;
}


/* build fixed tables only once--keep them here */
#ifdef BUILDFIXED
local int fixed_built = 0;
#define FIXEDH 544      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;
#else
#include "inffixed.h"
#endif


int inflate_trees_fixed(bl, bd, tl, td, z)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
inflate_huft * FAR *tl;  /* literal/length tree result */
inflate_huft * FAR *td;  /* distance tree result */
z_streamp z;             /* for memory allocation */
{
#ifdef BUILDFIXED
  /* build fixed tables if not already */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    uInt f = 0;         /* number of hufts used in fixed_mem */
    uIntf *c;           /* length list for huft_build */
    uIntf *v;           /* work area for huft_build */

    /* allocate memory */
    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
      return Z_MEM_ERROR;
    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    {
      ZFREE(z, c);
      return Z_MEM_ERROR;
    }

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 9;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
               fixed_mem, &f, v);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
               fixed_mem, &f, v);

    /* done */
    ZFREE(z, v);
    ZFREE(z, c);
    fixed_built = 1;
  }
#endif
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infutil.c ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-1998 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  inflate_huft *hufts;  /* single malloc for tree space */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
extern uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\minigzip.c ===
/* minigzip.c -- simulate gzip using the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 * minigzip is a minimal implementation of the gzip utility. This is
 * only an example of using zlib and isn't meant to replace the
 * full-featured gzip. No attempt is made to deal with file systems
 * limiting names to 14 or 8+3 characters, etc... Error checking is
 * very limited. So use minigzip only for testing; use gzip for the
 * real thing. On MSDOS, use only on file names without extension
 * or in pipe mode.
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#ifdef USE_MMAP
#  include <sys/types.h>
#  include <sys/mman.h>
#  include <sys/stat.h>
#endif

#if defined(MSDOS) || defined(OS2) || defined(WIN32)
#  include <fcntl.h>
#  include <io.h>
#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#else
#  define SET_BINARY_MODE(file)
#endif

#ifdef VMS
#  define unlink delete
#  define GZ_SUFFIX "-gz"
#endif
#ifdef RISCOS
#  define unlink remove
#  define GZ_SUFFIX "-gz"
#  define fileno(file) file->__file
#endif
#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#  include <unix.h> /* for fileno */
#endif

#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
  extern int unlink OF((const char *));
#endif

#ifndef GZ_SUFFIX
#  define GZ_SUFFIX ".gz"
#endif
#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)

#define BUFLEN      16384
#define MAX_NAME_LEN 1024

#ifdef MAXSEG_64K
#  define local static
   /* Needed for systems with limitation on stack size. */
#else
#  define local
#endif

char *prog;

void error            OF((const char *msg));
void gz_compress      OF((FILE   *in, gzFile out));
#ifdef USE_MMAP
int  gz_compress_mmap OF((FILE   *in, gzFile out));
#endif
void gz_uncompress    OF((gzFile in, FILE   *out));
void file_compress    OF((char  *file, char *mode));
void file_uncompress  OF((char  *file));
int  main             OF((int argc, char *argv[]));

/* ===========================================================================
 * Display error message and exit
 */
void error(msg)
    const char *msg;
{
    fprintf(stderr, "%s: %s\n", prog, msg);
    exit(1);
}

/* ===========================================================================
 * Compress input to output then close both files.
 */

void gz_compress(in, out)
    FILE   *in;
    gzFile out;
{
    local char buf[BUFLEN];
    int len;
    int err;

#ifdef USE_MMAP
    /* Try first compressing with mmap. If mmap fails (minigzip used in a
     * pipe), use the normal fread loop.
     */
    if (gz_compress_mmap(in, out) == Z_OK) return;
#endif
    for (;;) {
        len = fread(buf, 1, sizeof(buf), in);
        if (ferror(in)) {
            perror("fread");
            exit(1);
        }
        if (len == 0) break;

        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
    }
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
}

#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */

/* Try compressing the input file at once using mmap. Return Z_OK if
 * if success, Z_ERRNO otherwise.
 */
int gz_compress_mmap(in, out)
    FILE   *in;
    gzFile out;
{
    int len;
    int err;
    int ifd = fileno(in);
    caddr_t buf;    /* mmap'ed buffer for the entire input file */
    off_t buf_len;  /* length of the input file */
    struct stat sb;

    /* Determine the size of the file, needed for mmap: */
    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
    buf_len = sb.st_size;
    if (buf_len <= 0) return Z_ERRNO;

    /* Now do the actual mmap: */
    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); 
    if (buf == (caddr_t)(-1)) return Z_ERRNO;

    /* Compress the whole file at once: */
    len = gzwrite(out, (char *)buf, (unsigned)buf_len);

    if (len != (int)buf_len) error(gzerror(out, &err));

    munmap(buf, buf_len);
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
    return Z_OK;
}
#endif /* USE_MMAP */

/* ===========================================================================
 * Uncompress input to output then close both files.
 */
void gz_uncompress(in, out)
    gzFile in;
    FILE   *out;
{
    local char buf[BUFLEN];
    int len;
    int err;

    for (;;) {
        len = gzread(in, buf, sizeof(buf));
        if (len < 0) error (gzerror(in, &err));
        if (len == 0) break;

        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
	    error("failed fwrite");
	}
    }
    if (fclose(out)) error("failed fclose");

    if (gzclose(in) != Z_OK) error("failed gzclose");
}


/* ===========================================================================
 * Compress the given file: create a corresponding .gz file and remove the
 * original.
 */
void file_compress(file, mode)
    char  *file;
    char  *mode;
{
    local char outfile[MAX_NAME_LEN];
    FILE  *in;
    gzFile out;

    strcpy(outfile, file);
    strcat(outfile, GZ_SUFFIX);

    in = fopen(file, "rb");
    if (in == NULL) {
        perror(file);
        exit(1);
    }
    out = gzopen(outfile, mode);
    if (out == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
        exit(1);
    }
    gz_compress(in, out);

    unlink(file);
}


/* ===========================================================================
 * Uncompress the given file and remove the original.
 */
void file_uncompress(file)
    char  *file;
{
    local char buf[MAX_NAME_LEN];
    char *infile, *outfile;
    FILE  *out;
    gzFile in;
    int len = strlen(file);

    strcpy(buf, file);

    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
        infile = file;
        outfile = buf;
        outfile[len-3] = '\0';
    } else {
        outfile = file;
        infile = buf;
        strcat(infile, GZ_SUFFIX);
    }
    in = gzopen(infile, "rb");
    if (in == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
        exit(1);
    }
    out = fopen(outfile, "wb");
    if (out == NULL) {
        perror(file);
        exit(1);
    }

    gz_uncompress(in, out);

    unlink(infile);
}


/* ===========================================================================
 * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]
 *   -d : decompress
 *   -f : compress with Z_FILTERED
 *   -h : compress with Z_HUFFMAN_ONLY
 *   -1 to -9 : compression level
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    int uncompr = 0;
    gzFile file;
    char outmode[20];

    strcpy(outmode, "wb6 ");

    prog = argv[0];
    argc--, argv++;

    while (argc > 0) {
      if (strcmp(*argv, "-d") == 0)
	uncompr = 1;
      else if (strcmp(*argv, "-f") == 0)
	outmode[3] = 'f';
      else if (strcmp(*argv, "-h") == 0)
	outmode[3] = 'h';
      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
	       (*argv)[2] == 0)
	outmode[2] = (*argv)[1];
      else
	break;
      argc--, argv++;
    }
    if (argc == 0) {
        SET_BINARY_MODE(stdin);
        SET_BINARY_MODE(stdout);
        if (uncompr) {
            file = gzdopen(fileno(stdin), "rb");
            if (file == NULL) error("can't gzdopen stdin");
            gz_uncompress(file, stdout);
        } else {
            file = gzdopen(fileno(stdout), outmode);
            if (file == NULL) error("can't gzdopen stdout");
            gz_compress(stdin, file);
        }
    } else {
        do {
            if (uncompr) {
                file_uncompress(*argv);
            } else {
                file_compress(*argv, outmode);
            }
        } while (argv++, --argc);
    }
    exit(0);
    return 0; /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\trees.c ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-1998 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
	    "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
	fprintf(header, "%2u%s", _dist_code[i],
		SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
	fprintf(header, "%2u%s", _length_code[i],
		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
	fprintf(header, "%1u%s", base_length[i],
		SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "%5u%s", base_dist[i],
		SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
        s->compressed_len += 10L;
#endif
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void _tr_flush_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (eof) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    ct_data *ltree; /* literal tree */
    ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(s)
    deflate_state *s;
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\trees.h ===
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char *z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#     include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  define fdopen(fd,type)  _fdopen(fd,type)
#endif


        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\uncompr.c ===
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.3, July 9th, 1998

  Copyright (C) 1995-1998 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.3"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\Image\ZLIB\zutil.c ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-1998 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zutil.h"

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char *z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int z_verbose = verbose;

void z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}


#ifndef HAVE_MEMCPY

void zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\wmv\graphics.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    graphics.cpp

Abstract:

    WMV playback sample application - graphics related functions

--*/

#include "..\XDemos.h"

//
// Vertical blank callback (runs at DPC level)
//
volatile DWORD VBlankCount;
VOID __cdecl VBlankCallback(DWORD vblankCount) {
    VBlankCount = vblankCount;
}

LONG TextureBufferQueue::refreshInterval;

VOID TextureBufferQueue::InitializeD3D()
{
    D3DDISPLAYMODE mode;
    HRESULT hr = g_pd3dDevice->GetDisplayMode(&mode);
    if (SUCCEEDED(hr) && mode.RefreshRate) {
        refreshInterval = 1000*10000 / mode.RefreshRate;
    } else {
        // Default to 16msecs
        refreshInterval = 16*10000;
    }
}

//
// Initialize the graphics playback module
//
BOOL TextureBufferQueue::Initialize()
{
    maxCount = MAX_TEXTURES;
    maxPacketSize = VideoInfo.dwHeight * VideoInfo.dwWidth * VideoInfo.dwOutputBitsPerPixel / 8;
    ASSERT(maxPacketSize % 4 == 0);

    g_pd3dDevice->Clear(0, NULL, D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER, 0, 1.0f, 0);
    g_pd3dDevice->Present(NULL, NULL, NULL, NULL);

    g_pd3dDevice->SetVerticalBlankCallback(VBlankCallback);
    g_pd3dDevice->EnableOverlay(TRUE);

    //
    // Create textures
    //
    for (INT i=0; i < MAX_TEXTURES; i++) {
        TexturePacket* pkt = &textures[i];
        
        HRESULT hr = g_pd3dDevice->CreateTexture(
                        VideoInfo.dwWidth,
                        VideoInfo.dwHeight,
                        0,
                        0,
                        D3DFMT_YUY2,
                        NULL,
                        &pkt->d3dtex);
        if (FAILED(hr))
		{
			return FALSE;
		}

        D3DLOCKED_RECT lockrect;
        hr = pkt->d3dtex->LockRect(0, &lockrect, NULL, 0);
        if (FAILED(hr))
		{
			return FALSE;
		}

        pkt->flags = PACKETFLAG_VIDEO;
        pkt->xmp.pvBuffer = lockrect.pBits;
        pkt->d3dtex->UnlockRect(0);

        freeList.AddTail(pkt);
    }

    discardedFrames = overlayBlocks = 0;
    return PacketQueue::Initialize();
}

//
// Process video frames
//
VOID TextureBufferQueue::Process()
{
    //
    // Retire any frames that have already been rendered:
    //  A frame in the busy queue can be freed if there is another frame after it
    //  and the current vblank count is >= the value in the later packet.
    //
    Packet* pkt;
    while ((pkt = busyList.head) != NULL) {
        Packet* next = pkt->next;
        if (next == NULL || (LONG) (VBlankCount - next->status) < 0)
            break;

        busyList.RemoveHead();
        freeList.AddTail(pkt);
    }

    #ifndef DONT_PLAY_VIDEO

    //
    // Render frames that're ready for display
    //
    while ((pkt = readyList.head) != NULL) {
        REFERENCE_TIME timediff = pkt->timestamp - CurrentPlayTime;

        if (timediff < -refreshInterval) {
            // The frame is too old, just discard it
            discardedFrames++;
            ReleaseFreePacket(readyList.RemoveHead());
        } else {
            if (timediff < refreshInterval) {
                // Forget it if there is another update pending
                if (!g_pd3dDevice->GetOverlayUpdateStatus()) {
                    overlayBlocks++;
                    return;
                }

                // Render the frame if it's time
                readyList.RemoveHead();

                RenderFrame((TexturePacket*) pkt);
                busyList.AddTail(pkt);
            }
            break;
        }
    }

    #else // DONT_PLAY_VIDEO

    while (!readyList.IsEmpty()) {
        freeList.AddTail(readyList.RemoveHead());
    }

    #endif // DONT_PLAY_VIDEO
}

//
// Stop graphics playback
//
VOID TextureBufferQueue::Shutdown()
{
    g_pd3dDevice->EnableOverlay(FALSE);

    // Wait for two vblanks
    DWORD vblanks = VBlankCount+2;
    while ((LONG) (VBlankCount - vblanks) < 0)
        ;

    if (discardedFrames) {
        VERBOSE("Discarded video frames: %d (%d)\n", discardedFrames, overlayBlocks);
    }

    while (!busyList.IsEmpty()) {
        freeList.AddTail(busyList.RemoveHead());
    }
}

//
// Render the frame
//
VOID TextureBufferQueue::RenderFrame(TexturePacket* pkt)
{
    RECT srcrect = { 0, 0, VideoInfo.dwWidth, VideoInfo.dwHeight };
    RECT dstrect = { 0, 0, SCREENWIDTH, SCREENHEIGHT };

    if (!FullScreenMode) {
        //
        // We need to adjust the destination rectangle and
        // possibly the source rectangle when in 1:1 mode. 
        //
        if (VideoInfo.dwWidth <= SCREENWIDTH) {
            // Horizontal centering
            dstrect.left = (SCREENWIDTH - VideoInfo.dwWidth) / 2;
            dstrect.right = dstrect.left + VideoInfo.dwWidth;
        } else {
            // Clipping
            srcrect.left = (VideoInfo.dwWidth - SCREENWIDTH) / 2;
            srcrect.right = srcrect.left + SCREENWIDTH;
        }

        if (VideoInfo.dwHeight <= SCREENHEIGHT) {
            // Vertical centering
            dstrect.top = (SCREENHEIGHT - VideoInfo.dwHeight) / 2;
            dstrect.bottom = dstrect.top + VideoInfo.dwHeight;
        } else {
            // Clipping
            srcrect.top = (VideoInfo.dwHeight - SCREENHEIGHT) / 2;
            srcrect.bottom = dstrect.top + SCREENHEIGHT;
        }
    }

    g_pd3dDevice->UpdateOverlay(
                (D3DSurface*) pkt->d3dtex,
                &srcrect,
                &dstrect,
                FALSE,
                0);

    // Retire this packet after two VBlank interrupts
    pkt->status = VBlankCount+2;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\wmv\wmvplay.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    wmvplay.cpp

Abstract:

    WMV playback sample application - main (decoder) thread

--*/

#include "..\XDemos.h"
#include <stdio.h>

WMVVIDEOINFO VideoInfo;
TextureBufferQueue* TextureQ;
WAVEFORMATEX AudioInfo;
SoundPacketQueue* SoundQ;
LPWMVDECODER wmvdecoder;
REFERENCE_TIME PlayDuration, Preroll;
REFERENCE_TIME StartPresentationTime, CurrentPlayTime;
REFERENCE_TIME StartingSeekPosition;
BOOL FullScreenMode = TRUE;
INT DecodingFlag = DECODING_IDLE;

//
// Process a decoded audio or video packet
//
VOID ProcessDecodedPacket(PacketQueue* pktq, Packet* pkt)
{
    if (pkt->completedSize) {
        UpdateDebugStats(pkt);

        if (pkt->timestamp < PlayDuration) {
            if (pkt->flags & PACKETFLAG_SOUND) {
                // NOTE: We ignore the sound timestamp here
                // and just assume the stream is continous.
                pkt->timestamp = 0;
            } else {
                pkt->timestamp = pkt->timestamp - StartingSeekPosition + StartPresentationTime;
            }

            pktq->ScheduleReadyPacket(pkt);
            return;
        }

        VERBOSE("Bogus timestamp: %c %d\n",
            (pkt->flags & PACKETFLAG_SOUND) ? 'a' : 'v',
            (LONG) (pkt->timestamp / 10000));
    }

    pktq->ReleaseFreePacket(pkt);
}

//
// Play a WMV file
//
bool PlayWMVFile(char *szFileName)
{
	bool bReturn = false;

    wmvdecoder = NULL;
    HRESULT hr = WmvCreateDecoder(
                    szFileName,
                    NULL,
                    WMVVIDEOFORMAT_YUY2,
                    NULL,
                    &wmvdecoder);
    if (FAILED(hr)) goto exit;

    hr = wmvdecoder->GetVideoInfo(&VideoInfo);
    if (hr == WMVERR_NO_VIDEO_STREAM) {
        // Audio only file - fake the video info
        memset(&VideoInfo, 0, sizeof(VideoInfo));
        VideoInfo.dwWidth = 160;
        VideoInfo.dwHeight = 120;
        VideoInfo.dwOutputBitsPerPixel = 16;
    } else if (FAILED(hr))
        goto exit;

    hr = wmvdecoder->GetAudioInfo(&AudioInfo);
    if (FAILED(hr)) goto exit;

    hr = wmvdecoder->GetPlayDuration(&PlayDuration, &Preroll);
    if (FAILED(hr)) goto exit;

    VERBOSE(
        "Movie info:\n"
        "  video %dx%dx%d %dbps\n"
        "  sound %dx%d-bit %dHz\n"
        "  play duration %d msecs\n"
        "  preroll %d msecs\n",
        VideoInfo.dwWidth,
        VideoInfo.dwHeight,
        VideoInfo.dwOutputBitsPerPixel,
        VideoInfo.dwBitsPerSecond,
        AudioInfo.nChannels,
        AudioInfo.wBitsPerSample,
        AudioInfo.nSamplesPerSec,
        (LONG) (PlayDuration / 10000),
        (LONG) (Preroll / 10000));

    /*if (StartingSeekPosition != 0) {
        REFERENCE_TIME seekpos = StartingSeekPosition;
        VERBOSE("Seeking to position: %d\n", (LONG) (seekpos / 10000));
        hr = wmvdecoder->Seek(&seekpos);
        VERBOSE("Actual position: %d\n", (LONG) (seekpos / 10000));
    }*/

    TextureQ = TextureBufferQueue::Create();
    SoundQ = SoundPacketQueue::Create();

	if (!TextureQ || !SoundQ)
	{
		goto exit;
	}
	else
	{
		bReturn = true;
	}

    DWORD starttick = GetTickCount();

    DecodingFlag = DECODING_INPROGRESS;
    SoundQ->GetTime(&StartPresentationTime);

    do {
        //
        // Update the current play time
        //
        SoundQ->GetTime(&CurrentPlayTime);

        //
        // Handle controller input
        //
		if (CheckForInput())
		{
			bReturn = true;
			g_dwNextButton = (DWORD)-1;
			break;
		}

        //
        // Keep decoding if there are both free sound and video packets available
        // NOTE: We don't decode more than 3 video frames per iteration.
        //
        INT videocnt = 0;

        while (DecodingInProgress() &&
               videocnt < 3 &&
               !SoundQ->freeList.IsEmpty() &&
               !TextureQ->freeList.IsEmpty()) {
            Packet* audiopkt = SoundQ->GetFreeListHead();
            Packet* videopkt = TextureQ->GetFreeListHead();

            hr = wmvdecoder->ProcessMultiple(&videopkt->xmp, &audiopkt->xmp);
            if (FAILED(hr)) {
                AbortDecoding();
				bReturn = false;
                break;
            }

            // Decoding has finished:
            //  we'll now wait until the sound playback is stopped
            if (hr == S_FALSE) {
                VERBOSE("Decoding completed\n");
                DecodingFlag = DECODING_COMPLETED;
            }

            ProcessDecodedPacket(SoundQ, audiopkt);

            if (videopkt->completedSize) videocnt++;
            ProcessDecodedPacket(TextureQ, videopkt);
        }

        //
        // Handle sound playback
        //
        SoundQ->Process();

        //
        // Handle video playback
        //
        TextureQ->Process();
    } while (DecodingInProgress() || !SoundQ->busyList.IsEmpty());

    VERBOSE("Decode / play time: %d msecs\n", GetTickCount() - starttick);

	if (SoundQ)
	{
		SoundQ->Shutdown();
		delete SoundQ;
		SoundQ = NULL;
	}

	if (TextureQ)
	{
		TextureQ->Shutdown();
		delete TextureQ;
		TextureQ = NULL;
	}

exit:
    if (FAILED(hr)) {
        VERBOSE("Decoding failed: %08x\n", hr);
        DecodingFlag = DECODING_COMPLETED;
    }

    if (wmvdecoder) {
        wmvdecoder->Release();
    }

	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\wmv\sound.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    sound.cpp

Abstract:

    WMV playback sample application - sound related functions

--*/

#include "..\XDemos.h"

BOOL SoundPacketQueue::Initialize()
{
    maxCount = MAX_SOUND_PACKETS;
    maxPacketSize = MAX_SAMPLES_PER_SOUND_PACKET * AudioInfo.nBlockAlign;

    DWORD pktsize = sizeof(Packet) + maxPacketSize;
    BYTE* buf = (BYTE*) malloc(pktsize * MAX_SOUND_PACKETS);
    if (!buf) return FALSE;

    packetArray = buf;
    for (LONG i=0; i < maxCount; i++) {
        Packet* pkt = (Packet*) (buf + i * pktsize);
        pkt->flags = PACKETFLAG_SOUND;
        pkt->xmp.pvBuffer = pkt + 1;
        freeList.AddTail(pkt);
    }

    if (!PacketQueue::Initialize())
        return FALSE;

    DSSTREAMDESC ddsd;
    memset(&ddsd, 0, sizeof(ddsd));
    ddsd.dwMaxAttachedPackets = MAX_SOUND_PACKETS;
    ddsd.lpwfxFormat = &AudioInfo;

    HRESULT hr = DirectSoundCreateStream(&ddsd, &soundStream);
    return SUCCEEDED(hr);
}

//
// Check if any of the actively playing sound packets are finished
//
BOOL SoundPacketQueue::RetireBusyList()
{
    #ifndef DONT_PLAY_SOUND
    DirectSoundDoWork();
    #endif

    Packet* pkt;
    while (pkt = busyList.head) {
        if (pkt->status == XMEDIAPACKET_STATUS_PENDING)
            return TRUE;

        busyList.RemoveHead();
        ReleaseFreePacket(pkt);
    }

    return FALSE;
}

//
// Process the sound packets
//
VOID SoundPacketQueue::Process()
{
    //
    // Check if any sound packets are ready to be scheduled
    //
    while (!readyList.IsEmpty()) {
        Packet* pkt = readyList.RemoveHead();

        #ifndef DONT_PLAY_SOUND
        soundStream->Process(&pkt->xmp, NULL);
        #else
        pkt->status = XMEDIAPACKET_STATUS_SUCCESS;
        #endif

        busyList.AddTail(pkt);
    }

    RetireBusyList();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XAudio\XAudio.cpp ===
#include "XAudio.h"

/****************************************************************************************************************
 *
 * FUNCTION:  xbGetHandle(void*, DWORD, DWORD)
 *
 * PURPOSE:	  This function returns handle to a sound effect for later use.
 *
 ****************************************************************************************************************/


void* __stdcall xbGetHandle(void* pvData, DWORD dwBufSiz, DWORD dwFlags)
{
	static int i = 0;

	//Sorry, only 256 different sound effects supported
	if(i > NUMHANDLES)
		return NULL;


	g_HandleTable[i].dwFlags	= dwFlags;
	g_HandleTable[i].dwBufSiz	= dwBufSiz;
	g_HandleTable[i].pvData		= pvData;

	if(dwFlags && THREEDSND)
	{	
		g_HandleTable[i].nID	= (g_SNDID3D%NUM3DSTRUCTS);
		g_SndArr[g_SNDID3D%NUM3DSTRUCTS].pvData = pvData;
		g_SNDID3D++;
	}else{
		g_HandleTable[i].nID	= (g_SNDID2D%NUM3DSTRUCTS);
		g_2DSndArr[g_SNDID2D%NUM3DSTRUCTS].pvData = pvData;
		g_SNDID2D++;
	}

	//Increment the counter

	return (void*)&(g_HandleTable[i++]);
}


/****************************************************************************************************************
 *
 * FUNCTION:  xbInitAudio(void)
 *
 * PURPOSE:	  This function will initialize my Sound Handle system, Listeners, etc.  Currently I will have 
 *			  NUMHANDLES handles available, and NUMSNDSTRUCTS actually able to be played at one time.  
 *			  The handle system will keep track of the Handle value as well as the actual sound data associated
 *			  with that handle.  The actual playing sounds will have more data available for them.
 *
 * USE:		  This should be called initially to 'start up' the sound system.  It should be around for the life
 *			  of the .xbe.  If clean up is needed, I have provided an xbUninitAudio() function-- although this
 *			  should not be necessary, as was recomended in the white binder given out at XFest.
 *
 ****************************************************************************************************************/


HRESULT __stdcall xbInitAudio()
{
	HRESULT			hr = S_OK;
	DSBUFFERDESC	bufDesc;
	DSBUFFERDESC	bufDesc2D;
	WAVEFORMATEX	waveFmt;

	//Initialize the counters
	g_SNDID3D = 0;
	g_SNDID2D = 0;

	//Create the DSound Interface... we can use this later, so keep it around for the life of the app

	hr = DirectSoundCreate(NULL,
						   &g_pDSnd,
						   NULL);


	assert(SUCCEEDED(hr));

	if(FAILED(hr))
		return hr; 	//We are in big trouble if this fails... pass back the DSound Error code

	//Set up the default wave format
	waveFmt.cbSize			= 0;				//Size of extra data;  PCM == 0 (no extra data)
	waveFmt.nChannels		= 1;				//One channel
	waveFmt.wBitsPerSample	= 16;				//We will always use 16;  8 sounds crappy
	waveFmt.nBlockAlign		= 2;				//Product of bits/sample & channels divided by 8
	waveFmt.nAvgBytesPerSec = 44100;			//Product of samples/sec & block align
    waveFmt.nSamplesPerSec  = 22050;
	waveFmt.wFormatTag		= WAVE_FORMAT_PCM;  //Use PCM for now



	//Set up the default Buffer Description
	bufDesc.dwBufferBytes = 0;
	bufDesc.dwFlags		  = DSBCAPS_CTRLVOLUME |//DSBCAPS_NOMEMORYALLOC |	//Derek says we don't need this flag; 0 buf size is sufficient 
							DSBCAPS_CTRL3D |			//3D sound buffer-- no Pan available
							DSBCAPS_CTRLFREQUENCY; //|		//JJBUG If we want to control the frequency, we *cannot* use fx... address this
							//DSBCAPS_CTRLFX; //JJBUG-- need XDK update

	bufDesc.dwSize		  = sizeof(DSBUFFERDESC);
	bufDesc.lpwfxFormat   = &waveFmt;

	//Set up the default 2D Buffer Description
	bufDesc2D.dwBufferBytes = 0;
	bufDesc2D.dwFlags		= DSBCAPS_CTRLVOLUME;//DSBCAPS_CTRLPAN |
							  DSBCAPS_CTRLFREQUENCY;
	bufDesc2D.dwSize		= sizeof(DSBUFFERDESC);
	bufDesc2D.lpwfxFormat	= &waveFmt;

	int i = 0;
	for(i = 0; i < NUMHANDLES; i++)
	{
		//Initialize the Handle table
		g_HandleTable[i].pvData				= NULL;
		g_HandleTable[i].nID				= INVALID;
		g_HandleTable[i].dwInConeAngle		= DS3D_DEFAULTCONEANGLE;
		g_HandleTable[i].dwOutConeAngle		= DS3D_DEFAULTCONEANGLE;
		g_HandleTable[i].lOuterVolume		= DSBVOLUME_MAX;
		g_HandleTable[i].lVolume			= DSBVOLUME_MAX;
		g_HandleTable[i].nID				= 0x0;
		g_HandleTable[i].pPosition.x		= 0;
		g_HandleTable[i].pPosition.y		= 0;
		g_HandleTable[i].pPosition.z		= 0;


		if(i < NUM3DSTRUCTS)
		{
			//Initialzie the Sound Struct Array
			g_SndArr[i].dwFlags			= 0x0;

			//Get a Buffer
			hr = g_pDSnd->CreateSoundBuffer(&bufDesc,
			  								&(g_SndArr[i].pBuffer),
											NULL);

			assert(SUCCEEDED(hr));
	
			//So we are screwed... uninit everything, and return failure
			if(FAILED(hr))
			{
				i -= 1; //Get the last successful allocation & roll back from there
				for(i; i >= 0; i--)
				{
					//Clean up
					g_SndArr[i].pBuffer->Release();
					g_SndArr[i].pBuffer = NULL;

					//And Clean up 2D...subtract 1, becaue the ith one hasn't been created yet.
					if((i - 1) >= 0)
					{
						g_2DSndArr[i-1].pBuffer->Release();
						g_2DSndArr[i-1].pBuffer = NULL;
					}
				}
				g_pDSnd->Release();
				g_pDSnd = NULL;

				return hr;
			}
		}

		//Get the 2D Handles taken care of as well
		if(i < NUM2DSTRUCTS)
		{
			hr = g_pDSnd->CreateSoundBuffer(&bufDesc2D,
											&(g_2DSndArr[i].pBuffer),
											NULL);

			assert(SUCCEEDED(hr));

			if(FAILED(hr))
			{
				for(i; i >=0; i--)
				{
					//CleanUp
					g_2DSndArr[i].pBuffer->Release();
					g_2DSndArr[i].pBuffer = NULL;

					//CleanUp 3D too
					g_SndArr[i].pBuffer->Release();
					g_SndArr[i].pBuffer = NULL;

				}
				g_pDSnd->Release();
				g_pDSnd = NULL;

				return hr;
			}
		}
				
				

	}

	//OK... So our Handle/Structure data is all nicely initialized;  so now set up the global listener stuff
	g_Listener.dwSize			= sizeof(DS3DLISTENER);
	g_Listener.flDistanceFactor = DISTANCE;		//# of meters in a vector unit JJBUG-- verify this w/ Ed
	g_Listener.flDopplerFactor	= DOPPLER;		//This is a multiple of real world doppler-- default is real world
	g_Listener.flRolloffFactor	= ROLLOFF;		//This is a multiple of real world roll off-- default is real world
	g_Listener.vOrientFront.x	= 0;			//Start off looking down the -Z axis
	g_Listener.vOrientFront.y	= 0;
	g_Listener.vOrientFront.z   = -1;
	g_Listener.vOrientTop.x		= 0;			//Up is positive Y axis
	g_Listener.vOrientTop.y     = 1;
	g_Listener.vOrientTop.z		= 0;
	g_Listener.vPosition.x		= 0;			//Origin is default
	g_Listener.vPosition.y		= 0;
	g_Listener.vPosition.z		= 0;
	g_Listener.vVelocity.x		= 0;			//Velocity is 0 at first
	g_Listener.vVelocity.y		= 0;
	g_Listener.vVelocity.z		= 0;

	return S_OK;


	//Apply these settings
	hr = g_pDSnd->SetAllParameters(&g_Listener,
							       DS3D_IMMEDIATE);

	assert(SUCCEEDED(hr));

    hr = DownloadScratch(g_pDSnd, "Add scratch file here");

	//Init the Streaming system
	InitStreams();

	//Init the Channel system
	InitChannels();
	
	return S_OK;
}


/**************************************************************************************************************
 *
 * FUNCTION:  xbPlaySound(SNDHANDLE)
 *
 * PURPOSE:	  This function plays a sound.
 *
 * USE:		  If this is the first time playing the sound, passing the data along with NULL for SNDHANDLE is 
 *			  sufficient.  If not, then passing a valid SNDHANDLE with a NULL void* is sufficient.
 *
 * ASSUMPTIONS:  I am assuming that for efficency sake, the caller will save my HANDLES that I generate, and when
 *				 playing the sound later on, I will have to do minimal adjustments, and this makes for the most
 *				 efficient playing of sounds.  The first time that the sound is played, the caller should pass
 *				 a pointer to NULL for the PSNDHANDLE, and a vaild void* pvData.  Any future calls to play that sound
 *				 need only pass the PSNDHANDLE that I filled in for the caller.  *If* all the sounds channels are 
 *				 currently in use, the system will stop the sound that is closest to finishing of the 32 playing.
 *
 **************************************************************************************************************/

HRESULT __stdcall xbPlaySound(void* pHandle, bool bObstruct)
{
	//Cast
	SNDHANDLE pHndl = (SNDHANDLE)pHandle;

	PHSOUND pSnd	= NULL;
	bool	bCache	= false;  //See if we need to set any values or not
	DWORD	dwTicks = 0x0;	  //# of ticks for this sound to play
	

	//This function doesn't do things that should be streamed
	if((pHndl->dwFlags & ISVOICE) || (pHndl->dwFlags & ISMUSIC))
		return E_FAIL;										//JJBUG-- Come up w/ Custom error codes for this stuff


	//If PSNDHANDLE != NULL, then it must be a valid handle
	if(NULL == pHndl)
		return E_FAIL;			//JJBUG-- Custom Error code
	

	//See if we have a valid Read pointer
	if(IsBadReadPtr(pHndl, sizeof(SNDHANDLE)))
		return E_FAIL;

	pSnd = SoundFromHandle(pHndl);

	//Set the format of the buffer...
	if(!((pHndl->dwFlags & BUFFER_MASK) == (pSnd->dwFlags & BUFFER_MASK)))
	{
		//Wosrt case...The format is different
		switch(pHndl->dwFlags & SAMPLE_MASK)
		{
		case TWOTWOKHZ:
			pSnd->pBuffer->SetFrequency(22100);
			break;
		case FORFORKHZ:
			pSnd->pBuffer->SetFrequency(44200);
			break;
		}

		switch(pHndl->dwFlags & FORMAT_MASK)
		{
		case PCM:
			break;
		case ADPCM:
			break;
		//There should be *NO* WMA sounds calling *this* function ever.
		case WMA:
			break;
		}
	}

	//Set the new flags & data
	pSnd->dwFlags = pHndl->dwFlags;
	pSnd->pvData  = pHndl->pvData;

	//PIII 733 -- 733Million Ticks/Second
	if(pHndl->dwFlags & TWOTWOKHZ)
		dwTicks = 733000000 * (pHndl->dwBufSiz)/(22050 * 2);
	else
		dwTicks = 733000000 * (pHndl->dwBufSiz)/(44100 * 2);
	//Set the new buffer data
	pSnd->pBuffer->SetBufferData(pHndl->pvData, pHndl->dwBufSiz);

	if(pSnd->dwFlags && RANDOM)
	{
		//JJBUG-- Apply the random effect to the buffer
	}

	//Apply changes... make sure that this buffer plays the sound the right way...
	DS3DBUFFER	dsChanges;
	HRESULT		hr;

	if(pSnd->dwFlags & THREEDSND)
	{
		dsChanges.dwInsideConeAngle = pHndl->dwInConeAngle;
		dsChanges.dwOutsideConeAngle= pHndl->dwOutConeAngle;
		dsChanges.dwSize			= sizeof(DS3DBUFFER);
		dsChanges.vVelocity.x		= pHndl->pVelocity.x;
		dsChanges.vVelocity.y		= pHndl->pVelocity.y;
		dsChanges.vVelocity.z		= pHndl->pVelocity.z;
		dsChanges.vPosition.x		= pHndl->pPosition.x;
		dsChanges.vPosition.y		= pHndl->pPosition.y;
		dsChanges.vPosition.z		= pHndl->pPosition.z;
		dsChanges.vConeOrientation.x= pHndl->vConeOrientation.x;
		dsChanges.vConeOrientation.y= pHndl->vConeOrientation.y;
		dsChanges.vConeOrientation.z= pHndl->vConeOrientation.z;
		dsChanges.dwMode			= DS3DMODE_HEADRELATIVE;//DS3DMODE_NORMAL;
		dsChanges.lConeOutsideVolume= pHndl->lOuterVolume;
		dsChanges.flMaxDistance		= DS3D_DEFAULTMAXDISTANCE;
		dsChanges.flMinDistance		= DS3D_DEFAULTMINDISTANCE;

		hr = pSnd->pBuffer->SetAllParameters(&dsChanges,DS3D_IMMEDIATE);

		assert(SUCCEEDED(hr));
	}

	//2D & 3D... make sure that the volume is correct
	pSnd->pBuffer->SetVolume(pHndl->lVolume);
	

	//Time stamp what the tick count will be when this is over.
	dwTicks += GetTickCount();
	pSnd->dwEndTime = dwTicks;

	if(pSnd->dwFlags & LOOPING)
		return pSnd->pBuffer->Play(0,0,DSBPLAY_LOOPING);
	else
		return pSnd->pBuffer->Play(0,0,0);
}


/*************************************************************************************************************
 *
 * FUNCTION: xbGetChannel()
 *
 * PURPOSE:  Returns a 3D sound channel that can have 2D sounds routed to it
 *
 * USE:		 Same as purpose
 *
 *************************************************************************************************************/

void* __stdcall xbGetChannel()
{
	int i = 0;
	for(i = 0; i < NUMCHANNELS; i++)
	{
		if(!(g_ChannelTable[i].nID))
		{
			//For channels, the ID determines if it is currently in use or not...
			g_ChannelTable[i].nID = 1;
			return (void*)&g_ChannelTable[i];
		}
	}

	//All Channels are currently in use
	return NULL;
}


/*************************************************************************************************************
 *
 * FUNCTION: xbFreeChannel(HCHANNEL)
 *
 * PURPOSE:  Returns a 3D sound channel that can have 2D sounds routed to it
 *
 * USE:		 Same as purpose
 *
 *************************************************************************************************************/

HRESULT __stdcall xbFreeChannel(void* hC)
{
	for(int i = 0; i < NUMCHANNELS; i++)
	{
		if(&g_ChannelTable[i] == hC)
		{
			//Mark it as Free
			g_ChannelTable[i].nID = 0;
			return S_OK;
		}
	}

	//This must have not been a channel pointer
	return E_FAIL;
}


HRESULT __stdcall InitChannels()
{
	DSBUFFERDESC bufDesc;
	WAVEFORMATEX waveFmt;
	HRESULT hr = S_OK;

	bufDesc.dwBufferBytes	= 0;
	bufDesc.dwFlags			= DSBCAPS_CTRL3D | DSBCAPS_MIXIN | DSBCAPS_CTRLVOLUME;
	bufDesc.dwSize			= sizeof(DSBUFFERDESC);
	bufDesc.lpwfxFormat		= &waveFmt;

	//Assume this for now...
	waveFmt.cbSize			= 0;				//Size of extra data;  PCM == 0 (no extra data)
	waveFmt.nChannels		= 1;				//One channel
	waveFmt.wBitsPerSample	= 16;				//We will always use 16;  8 sounds crappy
	waveFmt.nBlockAlign		= 2;				//Product of bits/sample & channels divided by 8
	waveFmt.nAvgBytesPerSec = 44100;			//Product of samples/sec & block align
    waveFmt.nSamplesPerSec  = 22050;
	waveFmt.wFormatTag		= WAVE_FORMAT_PCM;  //Use PCM for now


	int i = 0;
	for(i = 0; i < NUMCHANNELS; i++)
	{
		g_ChannelTable[i].dwBufSiz = 0;
		g_ChannelTable[i].dwInConeAngle = DS3D_DEFAULTCONEANGLE;
		g_ChannelTable[i].dwOutConeAngle= DS3D_DEFAULTCONEANGLE;
		g_ChannelTable[i].lOuterVolume	= DS3D_DEFAULTCONEOUTSIDEVOLUME;
		g_ChannelTable[i].lVolume		= DSBVOLUME_MAX;
		g_ChannelTable[i].nID			= 0;  //Not currently in use
		g_ChannelTable[i].pPosition.x	= 0;
		g_ChannelTable[i].pPosition.y	= 0;
		g_ChannelTable[i].pPosition.z	= 0;
		g_ChannelTable[i].pVelocity.x	= 0;
		g_ChannelTable[i].pVelocity.y	= 0;
		g_ChannelTable[i].pVelocity.z	= 0;
		g_ChannelTable[i].vConeOrientation.x = 0;
		g_ChannelTable[i].vConeOrientation.y = 0;
		g_ChannelTable[i].vConeOrientation.z = 0;
		hr = g_pDSnd->CreateSoundBuffer(&bufDesc,
								        ((IDirectSoundBuffer8**)(&g_ChannelTable[i].pvData)),
								        NULL);
		assert(SUCCEEDED(hr));
		if(FAILED(hr))
		{
			//This last one didn't work... so don't need to undo it
			i-=1;
			for(i; i >= 0; i--)
			{
				((IDirectSoundBuffer8*)(g_ChannelTable[i].pvData))->Release();
			}

			return E_FAIL;
		}

	}

	return S_OK;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbPlay3DSoundChannel(CHANNEL3D)
 *
 * PURPOSE:  Plays a buffer that has had multiple sounds routed to it
 *
 * USE:		 Same as purpose
 *
 *************************************************************************************************************/

HRESULT __stdcall xbPlay3DSoundChannel(HCHANNEL3D hChannel)
{

	SNDHANDLE pHndl = (SNDHANDLE)hChannel;

	//See if we have a valid Read pointer
	if(IsBadReadPtr(pHndl, sizeof(SNDSTRUCT)))
		return E_FAIL;


	//This function doesn't do things that should be streamed
	if((pHndl->dwFlags && ISVOICE) || (pHndl->dwFlags && ISMUSIC))
		return E_FAIL;

	if(pHndl->dwFlags & LOOPING)
		return ((IDirectSoundBuffer8*)(pHndl->pvData))->Play(0,0,DSBPLAY_LOOPING);
	else
		return ((IDirectSoundBuffer8*)(pHndl->pvData))->Play(0,0,0);


}

/*************************************************************************************************************
 *
 * FUNCTION: xbRoute2DSound(SNDHANDLE)
 *
 * PURPOSE:  Routes a 2D sound into a 3D buffer
 *
 * USE:		 Same as purpose
 *
 *************************************************************************************************************/
	
HRESULT __stdcall xbRoute2DSound(SNDHANDLE pHandle, HCHANNEL3D hChannel)
{
	SNDHANDLE pHndl	 = (SNDHANDLE)pHandle;
	SNDHANDLE pCHndl = (SNDHANDLE)hChannel;
	//See if we have a valid Read pointer
	if(IsBadReadPtr(pHndl, sizeof(SNDHANDLE)))
		return E_FAIL;


	//This function doesn't do things that should be streamed
	if((pHndl->dwFlags && ISVOICE) || (pHndl->dwFlags && ISMUSIC))
		return E_FAIL;


	PHSOUND pSnd   = SoundFromHandle(pHndl);

	//PHSOUND pSndCh = SoundFromHandle(pCHndl);

	if((NULL != pSnd) && (pCHndl != NULL))
	{
		//pSnd->pBuffer->SetOutputBuffer(pSndCh->pBuffer);
		return (((IDirectSoundBuffer8*)pCHndl->pvData)->Play(0,0,0));
	}

	return E_FAIL;
}


/*************************************************************************************************************
 *
 * FUNCTION: xbStopSound(SNDHANDLE)
 *
 * PURPOSE:  Stops a sound if it is currently playing
 *
 * USE:		 Same as purpose
 *
 *************************************************************************************************************/

HRESULT __stdcall xbStopSound(void* hSound)
{
	SNDHANDLE hSnd = (SNDHANDLE)hSound;

	HRESULT hr = S_OK;
	PHSOUND pSnd = NULL;

	//Not much we can do if we cannot stop a sound that is playing... but
	if(hSnd->dwFlags && THREEDSND)
	{
		if(hSnd->pvData == g_SndArr[hSnd->nID].pvData)
			g_SndArr[hSnd->nID].pBuffer->Stop();
	}else{
		if(hSnd->pvData == g_2DSndArr[hSnd->nID].pvData)
			g_SndArr[hSnd->nID].pBuffer->Stop();
	}

	return S_OK;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbSetVolume(SNDHANDLE, LONG)
 *
 * PURPOSE:  Changes the volume of a sound.
 *
 * USE:		 If the sound is currently playing, the volume changes immediately;  otherwise, the volume will get
 *			 set when it is next played.
 *
 *************************************************************************************************************/


HRESULT __stdcall xbSetVolume(void* hSound, LONG lVol)
{
	SNDHANDLE hSnd		= (SNDHANDLE)hSound;
	DWORD	  dwStatus	= 0x0;
	HRESULT hr			= S_OK;  //JJBUG-- initialize to a 'not currently playing error'
	
	//Set the volume on the sound buffer
	if(hSnd->pvData == g_SndArr[hSnd->nID].pvData)
	{
		//See if the sound is playing...
		hr = g_SndArr[hSnd->nID].pBuffer->GetStatus(&dwStatus);

		//Just assert for Debug purposes; doesn't really matter otherwise
		assert(SUCCEEDED(hr));
	
		if(dwStatus & DSBSTATUS_PLAYING)
		{
			hr = g_SndArr[hSnd->nID].pBuffer->SetVolume(lVol);
			//If this fails we want to know about in the debugger, otherwise, there is not
			//much else we can do
			assert(SUCCEEDED(hr));
		}
	}

	hSnd->lVolume		= lVol;

	return hr;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbSetConeOuterVolume(SNDHANDLE, LONG)
 *
 * PURPOSE:  Changes the Outer Cone Volume of a sound.
 *
 * USE:		 If the sound is currently playing, the outer cone volume changes immediately; otherwise, the volume will get
 *			 set when it is next played.
 *
 *************************************************************************************************************/

HRESULT __stdcall xbSetConeOuterVolume(void* hSound, LONG lVol)
{
	SNDHANDLE hSnd		= (SNDHANDLE)hSound;
	DWORD	  dwStatus	= 0x0;
	HRESULT hr			= S_OK;  //JJBUG-- initialize to a 'not currently playing error'

	hSnd->lOuterVolume	= lVol;

	//If it's not 3D we don't care
	if(!(hSnd->dwFlags & THREEDSND))
		return S_OK;

	if(hSnd->pvData == g_SndArr[hSnd->nID].pvData)
	{
		hr = g_SndArr[hSnd->nID].pBuffer->GetStatus(&dwStatus);

		//Just assert for Debug purposes; doesn't really matter otherwise
		assert(SUCCEEDED(hr));
	
		if(dwStatus & DSBSTATUS_PLAYING)
		{
			hr = g_SndArr[hSnd->nID].pBuffer->SetConeOutsideVolume(lVol,DS3D_IMMEDIATE);
			//If this fails we want to know about in the debugger, otherwise, there is not
			//much else we can do
			assert(SUCCEEDED(hr));
		}
	}

	return hr;
}




//JJBUG-- Finish this when the envelope generator API for XDK is in...
HRESULT __stdcall xbFadeVolume(void* hSound, LONG lVol, int nMilliSeconds)
{
	SNDHANDLE		hSnd		= (SNDHANDLE)hSound;

	HRESULT			hr			= S_OK;
	PHSOUND			pSnd		= NULL;
	DWORD			dwStatus	= 0x0;
/*	DSENVELOPEDESC	envDesc;
	DWORD			dwAttack	= 0x0;


	//Make sure it is currently cached..if not, it can't be playing so do nothing.
	if(hSnd->pvData == g_SndArr[hSnd->nID].pvData)
	{
		pSnd = &(g_SndArr[hSnd->nID]);

		//Make sure we have a buffer
		if(pSnd->pBuffer)
		{
			hr = pSnd->pBuffer->GetStatus(&dwStatus);

			//Make sure it is currently playing
			if(dwStatus && DSBSTATUS_PLAYING)
			{
				if(pSnd->dwFlags & TWOTWOKHZ)
				{
					dwAttack = 220500/32;  //samples per second divided by samples per frames gives us frames/second
				}else{
					dwAttack = 44100/32;
				}

				//Frames/second * Fade time / 1000 == # of sample frames to fade over
				dwAttack = (dwAttack * nMilliSeconds)/1000;

				envDesc.wEnvelopeDelay  = 0;		//Start Immediately
				envDesc.wEnvelopeAttack = 0;		//# of sample frames
				envDesc.wEnvelopeHold	= 0xfff;	//How many frames to 'hold' the envelope
				envDesc.wEnvelopeDecay	= dwDecay;	//# of sample frames
				envDesc.wEnvelopeSustain= 0;
				envDesc.wEnvelopeRelease= 0;

				//Use the envelope generator
				hr = pSnd->pBuffer->SetEG1(&envDesc);
			}

		}


	}
*/
	return hr;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbSet3DPosition(SNDHANDLE, Vector)
 *
 * PURPOSE:  Sets the position of a sound in 3D space
 *
 * USE:		 If the sound is currently playing, the position is set immediately.  Otherwise it will save that
 *			 positional data & apply it the next time the sound is played.
 *
 *************************************************************************************************************/


HRESULT __stdcall xbSet3DPosition(void* hSound, Vector v)
{
	SNDHANDLE hSnd	= (SNDHANDLE)hSound;

	HRESULT hr		= S_OK;
	PHSOUND pSnd	= &(g_SndArr[hSnd->nID]);
	DWORD	dwStatus= 0x0;

	if(hSnd->pvData == pSnd->pvData)
	{
		pSnd->pBuffer->GetStatus(&dwStatus);

		//See if it is playing
		if(dwStatus && DSBSTATUS_PLAYING)
		{
			hr = pSnd->pBuffer->SetPosition(v.x,v.y,v.z,DS3D_IMMEDIATE);
		}
	}

	hSnd->pPosition.x = v.x;
	hSnd->pPosition.y = v.y;
	hSnd->pPosition.z = v.z;

	return hr;
}



/*************************************************************************************************************
 *
 * FUNCTION: xbSet3DVelocity(SNDHANDLE, Vector)
 *
 * PURPOSE:  Sets the velocity of a sound in 3D space
 *
 * USE:		 If the sound is currently playing, the velocity is set immediately.  Otherwise it will save that
 *			 velocity data & apply it the next time the sound is played.
 *
 *************************************************************************************************************/


HRESULT __stdcall xbSet3DVelocity(void* hSound, Vector v)
{
	SNDHANDLE hSnd	= (SNDHANDLE)hSound;

	HRESULT hr		= S_OK;
	PHSOUND pSnd	= &(g_SndArr[hSnd->nID]);
	DWORD	dwStatus= 0x0;

	if(hSnd->pvData == pSnd->pvData)
	{
		pSnd->pBuffer->GetStatus(&dwStatus);

		//See if it is playing
		if(dwStatus && DSBSTATUS_PLAYING)
		{
			hr = pSnd->pBuffer->SetVelocity(v.x,v.y,v.z,DS3D_IMMEDIATE);
		}
	}

	hSnd->pVelocity.x = v.x;
	hSnd->pVelocity.y = v.y;
	hSnd->pVelocity.z = v.z;

	return hr;
}


/*************************************************************************************************************
 *
 * FUNCTION: xbSet3DCone(SNDHANDLE, float, float, float)
 *
 * PURPOSE:  Sets the Cone attributes of a sound in 3D space
 *
 * USE:		 If the sound is currently playing, the cone attributes is set immediately.  Otherwise it will save that
 *			 cone data & apply it the next time the sound is played.
 *
 *************************************************************************************************************/


HRESULT __stdcall xbSet3DCone(void* hSound, DWORD dwInsideAngle, DWORD dwOutsideAngle, Vector vOrientation, LONG lOuterVolume)
{
	SNDHANDLE hSnd	= (SNDHANDLE)hSound;

	HRESULT hr		= S_OK;
	PHSOUND pSnd	= &(g_SndArr[hSnd->nID]);
	DWORD	dwStatus= 0x0;

	if(hSnd->pvData == pSnd->pvData)
	{
		pSnd->pBuffer->GetStatus(&dwStatus);

		//See if it is playing
		if(dwStatus && DSBSTATUS_PLAYING)
		{
			hr = pSnd->pBuffer->SetConeAngles(dwInsideAngle, dwOutsideAngle,DS3D_IMMEDIATE);
			assert(SUCCEEDED(hr));
			hr = pSnd->pBuffer->SetConeOutsideVolume(lOuterVolume,DS3D_IMMEDIATE);
			assert(SUCCEEDED(hr));
			hr = pSnd->pBuffer->SetConeOrientation(vOrientation.x,vOrientation.y,vOrientation.z,DS3D_IMMEDIATE);
			assert(SUCCEEDED(hr));
		}
	}

	hSnd->dwInConeAngle		= dwInsideAngle;
	hSnd->dwOutConeAngle	= dwOutsideAngle;
	
	hSnd->vConeOrientation.x= vOrientation.x;
	hSnd->vConeOrientation.y= vOrientation.y;
	hSnd->vConeOrientation.z= vOrientation.z;

	hSnd->lOuterVolume		= lOuterVolume;

	return hr;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbIsSoundPlaying(void*,bool*)
 *
 * PURPOSE:  Tells the caller if a sound is currently playing
 *
 * USE:		 Same as purpose.
 *
 *************************************************************************************************************/


HRESULT __stdcall xbIsSoundPlaying(void* hSound, bool* bPlaying)
{
	SNDHANDLE hSnd	= (SNDHANDLE)hSound;

	PHSOUND pSnd	= &(g_SndArr[hSnd->nID]);
	DWORD	dwStatus= 0x0;

	if(hSnd->pvData == pSnd->pvData)
	{
		pSnd->pBuffer->GetStatus(&dwStatus);

		//See if it is playing
		if(dwStatus && DSBSTATUS_PLAYING)
			*bPlaying = true;
		else
			*bPlaying = false;
	}else{
		*bPlaying = false;
	}

	return S_OK;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbGetFlags(SNDHANDLE, DWORD*)
 *
 * PURPOSE:  Gets the flags that describe this sound
 *
 * USE:		 Use this to get information about the sound.
 *
 *************************************************************************************************************/
		

HRESULT __stdcall xbGetFlags(void* hSound, DWORD* dwFlags)
{
	SNDHANDLE hSnd = (SNDHANDLE)hSound;

	*dwFlags = 0x0;

	if(NULL == hSnd)
		return E_FAIL;

	if(IsBadReadPtr((void*)hSnd, sizeof(SNDSTRUCT)))
		return E_FAIL;

	*dwFlags = hSnd->dwFlags;

	return S_OK;
}

/*************************************************************************************************************
 *
 * FUNCTION: xbSetFlags(SNDHANDLE, DWORD)
 *
 * PURPOSE:  Sets the flags that describe this sound
 *
 * USE:		 Use this to change information about the sound (like whether it is gonna loop or not, randomize, etc...)
 *
 *************************************************************************************************************/
		

HRESULT __stdcall xbSetFlags(void* hSound, DWORD dwFlags)
{
	SNDHANDLE hSnd = (SNDHANDLE)hSound;
	
	if(NULL == hSnd)
		return E_FAIL;

	if(IsBadReadPtr((void*)hSnd, sizeof(SNDSTRUCT)))
		return E_FAIL;

	hSnd->dwFlags = dwFlags;

	return S_OK;
}


//JJBUG-- Waiting for an XDK update...
HRESULT __stdcall xbCreateFX(DWORD dwFXFlags)
{
	HRESULT hr = S_OK;
//	DWORD	dwMixBin;

	if(dwFXFlags & FXAMPMOD)
	{
		//g_pDSnd->CreateFX(1,&dwFXFlags,dwMixBin,NULL,NULL);

	}

	if(dwFXFlags & FXCHORUS)
	{

	}

	if(dwFXFlags & FXCOMPRESSOR)
	{

	}

	if(dwFXFlags & FXDISTORTION)
	{

	}

	if(dwFXFlags & FXECHO)
	{

	}

	if(dwFXFlags & FXFLANGER)
	{

	}

	if(dwFXFlags & FXREVERB)
	{

	}




	return hr;
}

//JJBUG-- Waiting for an XDK update...
HRESULT __stdcall xbDeleteFX(DWORD dwFlags)
{
	HRESULT hr = S_OK;


	return hr;

}

//JJBUG-- Waiting for an XDK update...
HRESULT __stdcall xbApplyFX(void* hSound, DWORD dwFlags)
{
	HRESULT hr = S_OK;

	
	return hr;
}

//Listener API

/**************************************************************************************************************
 *
 * LISTENER API FUNCTIONS
 *
 * This collection of functions is here to immediately change the position, velocity, and orientation of the
 * listener.
 *
 **************************************************************************************************************/

HRESULT __stdcall xbSetListenerPosition(Vector v)
{
	HRESULT hr = S_OK;

	hr = g_pDSnd->SetPosition(v.x,v.y,v.z, DS3D_IMMEDIATE);

	//Only change our data if we were successful changing it for real
	if(SUCCEEDED(hr))
	{
		g_Listener.vPosition.x = v.x;
		g_Listener.vPosition.y = v.y;
		g_Listener.vPosition.z = v.z;
	}

	return hr;
}


HRESULT __stdcall xbSetListenerOrientation(Vector vFront, Vector vUp)
{
	HRESULT hr = S_OK;

	hr = g_pDSnd->SetOrientation(vFront.x, vFront.y, vFront.z, vUp.x, vUp.y, vUp.z,DS3D_IMMEDIATE);

	//If we succeeded, then update
	if(SUCCEEDED(hr))
	{
		g_Listener.vOrientFront.x = vFront.x;
		g_Listener.vOrientFront.y = vFront.y;
		g_Listener.vOrientFront.z = vFront.z;
		g_Listener.vOrientTop.x = vUp.x;
		g_Listener.vOrientTop.y = vUp.y;
		g_Listener.vOrientTop.z = vUp.z;
	}

	return hr;
}

HRESULT __stdcall xbSetListenerVelocity(Vector v)
{
	HRESULT hr = S_OK;

	hr = g_pDSnd->SetVelocity(v.x,v.y,v.z,DS3D_IMMEDIATE);

	if(SUCCEEDED(hr))
	{
		g_Listener.vVelocity.x = v.x;
		g_Listener.vVelocity.y = v.y;
		g_Listener.vVelocity.z = v.z;
	}

	return hr;
}



//Internally used utility functions

/********************************************************************************************************************
 *
 * UTILITY FUNCTIONS:
 *
 * PHSOUND SoundFromHandle(PSNDHANDLE);
 *
 ********************************************************************************************************************/


//Given a Handle, this gives a pointer to the actual structure data
inline PHSOUND SoundFromHandle(SNDHANDLE pHndl)
{
	DWORD	dwStatus = 0x0;
	int		nCounter = pHndl->nID;
	DWORD	dwFinish = 0xffffffff;
	int		nIDLast	 = pHndl->nID;
	DWORD	dwCurTime= 0xffffffff;
	int		nIterate = 0x0;

	dwCurTime = GetTickCount();

	//3D Sound case
	if(pHndl->dwFlags && THREEDSND)
	{
		//See if the buffer is in use
		g_SndArr[nCounter].pBuffer->GetStatus(&dwStatus);
			
		//Get a valid buffer that is not in use...
		while(dwStatus & DSBSTATUS_PLAYING)
		{
			g_SndArr[++nCounter%NUM3DSTRUCTS].pBuffer->GetStatus(&dwStatus);
			if(dwFinish > (g_SndArr[nCounter%NUM3DSTRUCTS]).dwEndTime - dwCurTime)
			{
				//Keep track of which one is closest to finishing
				dwFinish = (g_SndArr[nCounter%NUM3DSTRUCTS]).dwEndTime - dwCurTime;
				nIDLast  = nCounter%NUM3DSTRUCTS;
			}

			if(nIterate++ > NUM3DSTRUCTS)
			{
				//They are all in use...Stop this sound as it is closest to finishing
				g_SndArr[nIDLast].pBuffer->Stop();
				pHndl->nID = nIDLast;
				return &g_SndArr[nIDLast];
			}
		}

		pHndl->nID = nCounter%NUM3DSTRUCTS;

		return &(g_SndArr[nCounter%NUM3DSTRUCTS]);
	}else{
		//2D Sound case
		g_2DSndArr[nCounter].pBuffer->GetStatus(&dwStatus);

		//Get a valid buffer that is not in use...
		while(dwStatus & DSBSTATUS_PLAYING)
		{
			g_2DSndArr[++nCounter%NUM2DSTRUCTS];
			if(dwFinish > (g_2DSndArr[nCounter%NUM2DSTRUCTS]).dwEndTime - dwCurTime)
			{
				dwFinish = (g_2DSndArr[nCounter%NUM2DSTRUCTS]).dwEndTime - dwCurTime;
				nIDLast  = nCounter%NUM2DSTRUCTS;
			}

			if(nIterate++ > NUM2DSTRUCTS)
			{
				//Stop this sound
				g_2DSndArr[nIDLast].pBuffer->Stop();
				pHndl->nID = nIDLast;
				return &g_2DSndArr[nIDLast];
			}
		}

		pHndl->nID = nCounter%NUM2DSTRUCTS;

		return &(g_2DSndArr[nCounter%NUM2DSTRUCTS]);
	}
}


int GetFreeStream()
{
	DWORD dwStatus = 0x0;

	for(int i = 0; i < NUMMUSICHANDLES; i++)
	{
		if(!(g_MusicArr[i].bPlaying))
			return i;
	}

	//There is no free Handle
	return -1;
}



HVOICE GetVoiceStream()
{
	DWORD dwStatus = 0x0;

	for(int i = 0; i < NUMVOICEHANDLES; i++)
	{
		if(!(g_VoiceArr[i].bPlaying))
			return &g_VoiceArr[i];
	}
	return NULL;
}


void InitStreams()
{
	int i = 0;

	//Init the counters
	g_MUSICCNT = 0;
	g_nVoiceCnt= 0;
	
	g_lMusicVol = DSBVOLUME_MAX;
	g_lVoiceVol = DSBVOLUME_MAX;

	//Init the internal music handles
	for(i = 0; i < NUMMUSICHANDLES; i++)
	{
		g_MusicArr[i].bPlaying			= false;
		ZeroMemory(g_MusicArr[i].adwPacketStatus, sizeof(DWORD) * FILESTRM_PACKET_COUNT);
		g_MusicArr[i].dwFileLength		= 0;
		ZeroMemory(g_MusicArr[i].pvRenderBuffer, FILESTRM_RENDER_PACKET_BYTES*FILESTRM_PACKET_COUNT);
		ZeroMemory(g_MusicArr[i].pvSourceBuffer, FILESTRM_SOURCE_PACKET_BYTES);
		g_MusicArr[i].pSourceFilter		= NULL;
		//g_MusicArr[i].pTransformFilter	= NULL;
		g_MusicArr[i].pRenderFilter		= NULL;
		ZeroMemory(g_MusicArr[i].szFileName, 256);
		g_MusicArr[i].dwFileProgress	= 0x0;
	}

	//Init the handles for streaming voices
	for(i = 0; i < NUMVOICEHANDLES; i++)
	{
		g_VoiceArr[i].bPlaying			= false;
		ZeroMemory(g_VoiceArr[i].adwPacketStatus, sizeof(DWORD) * FILESTRM_PACKET_COUNT);
		g_VoiceArr[i].dwFileLength		= 0;
		ZeroMemory(g_VoiceArr[i].pvRenderBuffer, FILESTRM_RENDER_PACKET_BYTES*FILESTRM_PACKET_COUNT);
		ZeroMemory(g_VoiceArr[i].pvSourceBuffer, FILESTRM_SOURCE_PACKET_BYTES);
		g_VoiceArr[i].pSourceFilter		= NULL;
		//g_VoiceArr[i].pTransformFilter	= NULL;
		g_VoiceArr[i].pRenderFilter		= NULL;
		ZeroMemory(g_VoiceArr[i].szFileName, 256);
		g_VoiceArr[i].dwFileProgress	= 0x0;
		g_VoiceArr[i].lVol				= g_lVoiceVol;
	}

	//Init the stream handles for the music
	for(i = 0; i < NUMSTREAMS; i++)
	{
		g_StreamArr[i].dwFlags = 0;
		g_StreamArr[i].nID	    = 0;
		ZeroMemory(g_StreamArr[i].szFileName, 256);
	}

	//Init our WMA stream
	g_WMAStream.lVol = g_lMusicVol;
	g_WMAStream.bPlaying = false;
	g_WMAStream.dwFlags = 0x0;
	g_WMAStream.hsRef	= NULL;
	g_WMAStream.m_dwBytesRead = 0x0;
	g_WMAStream.m_dwMaxBufferCount = 0x0;
	g_WMAStream.m_dwMinPacketSize  = 0x0;
	g_WMAStream.m_dwPacketSize	   = 0x0;
	g_WMAStream.m_dwPercentCompleted = 0x0;
	g_WMAStream.m_dwSourceLength	= 0x0;
	g_WMAStream.m_hOpenResult		= S_OK;
	g_WMAStream.m_pSourceXMO		= NULL;
	g_WMAStream.m_pTargetXMO		= NULL;
	ZeroMemory(g_WMAStream.m_pTransferBuffer,MAXBUFSIZE);
	ZeroMemory(g_WMAStream.m_pPacketContextPool,PACKET_CNT * sizeof(MEDIA_PACKET_CTX));

}


HSTREAM GetCurrentMusic()
{
	int i = 0;
	for(i = 0; i < NUMMUSICHANDLES; i++)
	{
		if(g_MusicArr[i].bPlaying)
			return g_MusicArr[i].hsRef;
	}

	if(g_WMAStream.bPlaying)
		return g_WMAStream.hsRef;
	else
		return NULL;
}


/********************************************************************************************************************
 *
 * Streaming Functions (Music & Voice System)
 *
 * MHANDLE xbGetStreamHandle(char*);											//JJBUG -- TODO
 * HRESULT xbIsStreamValid(MHANDLE);											//JJBUG -- TODO
 * HRESULT xbPlayMusic(MHANDLE);												//JJBUG -- TODO
 * HRESULT xbContinueMusic(MHANDLE);											//JJBUG -- TODO
 * HRESULT xbFlourishMusic(MHANDLE);											//JJBUG -- TODO
 * HRESULT xbStopMusic(MHANDLE);												//JJBUG -- TODO
 * HRESULT xbSetMusicRequestCallback(MHANDLE, void callBackFunc(MHANDLE));		//JJBUG -- TODO
 * HRESULT xbSetMusicContinueCallback(MHANDLE, void callBackFunc(MHANDLE));		//JJBUG -- TODO
 * HRESULT xbPlayVoiceStream(MHANDLE);											//JJBUG -- TODO
 *
 *********************************************************************************************************************/

/***************************************************************************************************************
 *
 * FUCNTION:  xbSetMusicRequestCallback(void (WINAPI*)(void*))
 *
 * PURPOSE:	  This function takes in a function pointer that will be the Music Request Callback.
 *
 ****************************************************************************************************************/


HRESULT __stdcall xbSetMusicRequestCallback(void (WINAPI* pFunc)(void* hM))
{
	g_pRequestFunc = pFunc;
	return S_OK;
}

/***************************************************************************************************************
 *
 * FUCNTION:  xbSetMusicContinueCallback(void (WINAPI*)(void*))
 *
 * PURPOSE:	  This function takes in a function pointer that will be the Music Continue Callback.
 *
 ****************************************************************************************************************/

HRESULT __stdcall xbSetMusicContinueCallback(void (WINAPI* pFunc)(void* hM))
{
	g_pContinueFunc = pFunc;
	return S_OK;
}


HRESULT __stdcall xbContinueMusic(void* hMusic)
{
	HSTREAM	hStream = GetCurrentMusic();
	if(hStream)
		xbStopMusic((void*)hStream);

	return xbPlayMusic(hMusic);
}

HRESULT __stdcall xbFlourishMusic(void* hMusic)
{
	HSTREAM hStream = GetCurrentMusic();
	if(hStream)
		xbStopMusic((void*)hStream);

	return xbPlayMusic(hMusic);
}



/***************************************************************************************************************
 *
 * FUCNTION:  xbGetMusicStream(const char*, DWORD)
 *
 * PURPOSE:	  This function takes in the file name of the music file to be streamed, and flags.  This function
 *			  will return which ever of the 2 handles is not currently playing.  Once a piece is done playing it
 *			  is invalid.  The assumption here is that there will not ever be > 2 pieces of music playing at the
 *			  same time.
 *
 ****************************************************************************************************************/


void* __stdcall xbGetMusicStream(const char* szFileName, DWORD dwFlags)
{
	HRESULT hr		 = 0x0;
	int		i		 = 0;
	DWORD	dwStatus = 0x0;

	if(g_MUSICCNT < NUMSTREAMS)
	{
		g_StreamArr[g_MUSICCNT].dwFlags = dwFlags;
		assert(strlen(szFileName) < 256);
		strcpy(g_StreamArr[g_MUSICCNT].szFileName, szFileName);
		return &(g_StreamArr[g_MUSICCNT++]);
	}else
		return NULL;
}

HRESULT __stdcall xbPlayMusic(void* hStr)
{
	HRESULT hr		= S_OK;
	HSTREAM hStream = HSTREAM(hStr);
	int nID			= GetFreeStream();

	//If this is a WMA, then we do something totally different for now... this will change once hardware ADPCM is in place
	if(hStream->dwFlags & WMA)
	{
		//Stop our current stream
		if(g_WMAStream.bPlaying)
		{
			g_WMAStream.bPlaying = false;
			g_WMAStream.m_pTargetXMO->Flush();
			g_WMAStream.m_pSourceXMO->Flush();
			g_WMAStream.m_pSourceXMO->Release();
			g_WMAStream.m_pSourceXMO = NULL;
		}
		g_WMAStream.m_dwPercentCompleted = 0;
		g_WMAStream.Initialize(hStream->szFileName);
		g_WMAStream.bPlaying = true;
		g_WMAStream.dwFlags  = hStream->dwFlags;
		g_WMAStream.hsRef	 = hStream;
		if(g_WMAStream.m_pTargetXMO)
			hr = ((LPDIRECTSOUNDSTREAM)g_WMAStream.m_pTargetXMO)->SetVolume(g_lMusicVol);

		return hr;
	}

	hStream->nID = nID;
	strcpy(g_MusicArr[nID].szFileName, hStream->szFileName);
	g_MusicArr[nID].hsRef = hStream;
	g_MusicArr[nID].bDone = false;
	g_MusicArr[nID].dwFlags = hStream->dwFlags;

	//Set the proper volume

	g_MusicArr[nID].lVol = g_lMusicVol;

	hr = InitStream(hStream->szFileName, &g_MusicArr[nID], hStream->dwFlags);

	return hr;
}

HRESULT __stdcall xbSetMusicVolume(LONG lVol)
{
	g_lMusicVol = lVol;
	return S_OK;
}

HRESULT __stdcall xbStopMusic(void* hStr)
{
	HSTREAM hStream = (HSTREAM)(hStr);

	//Make sure that we are stopping the right thing...
	//Special Case the WMA for now
	if(hStream->dwFlags & WMA)
	{
		g_WMAStream.bPlaying = false;
		g_WMAStream.m_pSourceXMO->Flush();
		g_WMAStream.m_pTargetXMO->Flush();
		return S_OK;
	}


	if(0 == strcmp(hStream->szFileName, g_MusicArr[hStream->nID].szFileName))
	{
		g_MusicArr[hStream->nID].bPlaying = false;
		g_MusicArr[hStream->nID].pRenderFilter->Flush();
	}

	return S_OK;
}

void* __stdcall xbPlayVoiceStream(char* szFileName, bool bDipMusic, PVOICE_INFO pVI, DWORD dwFlags)
{
	HVOICE hVoice	= GetVoiceStream();
	
	//Remember to raise the volume when the music is done...
	if(bDipMusic)
	{
		g_lDipVol = g_lMusicVol;
		xbSetMusicVolume(DSBVOLUME_MIN/5);
	}

	if(hVoice)
	{
		
		strcpy(hVoice->szFileName, szFileName);
		hVoice->hsRef = NULL;
		hVoice->bDone = false;
		hVoice->dwFlags = dwFlags;

		g_nVoiceCnt++;
		strcpy(hVoice->szFileName, szFileName);
		InitStream(szFileName, hVoice, dwFlags);
		hVoice->pRenderFilter->SetPosition(pVI->pPosition.x,pVI->pPosition.y,pVI->pPosition.z, DS3D_IMMEDIATE);
		hVoice->pRenderFilter->SetVelocity(pVI->pVelocity.x,pVI->pVelocity.y,pVI->pVelocity.z, DS3D_IMMEDIATE);
		hVoice->pRenderFilter->SetConeOutsideVolume(pVI->lOuterVolume,DS3D_IMMEDIATE);
		hVoice->pRenderFilter->SetConeOrientation(pVI->vConeOrientation.x,pVI->vConeOrientation.y,pVI->vConeOrientation.z,DS3D_IMMEDIATE);
		hVoice->pRenderFilter->SetConeAngles(pVI->dwInConeAngle,pVI->dwOutConeAngle,DS3D_IMMEDIATE);
		hVoice->pRenderFilter->SetVolume(g_lVoiceVol);
	}


	return (void*)hVoice;
}

HRESULT __stdcall xbPauseVoices()
{
	g_bVoicePause = true;
	return S_OK;

}

HRESULT __stdcall xbResumeVoices()
{
	g_bVoicePause = false;
	return S_OK;
}

HRESULT __stdcall xbPauseMusic()
{
	g_bMusicPause = true;
	return S_OK;
}

HRESULT __stdcall xbResumeMusic()
{
	g_bMusicPause = false;
	return S_OK;
}

HRESULT __stdcall xbPauseAllStreams()
{
	xbPauseVoices();
	xbPauseMusic();
	return S_OK;
}

HRESULT __stdcall xbResumeAllStreams()
{
	xbResumeVoices();
	xbResumeMusic();
	return S_OK;
}

HRESULT __stdcall xbSetVoicePostion(void* hv, Vector v)
{
	HVOICE hVoice = (HVOICE)hv;

	if(!(hVoice->bPlaying))
		return E_FAIL;

	return hVoice->pRenderFilter->SetPosition(v.x,v.y,v.z,DS3D_IMMEDIATE);
}

HRESULT __stdcall xbSetVoiceVelocity(void* hv, Vector v)
{
	HVOICE hVoice = (HVOICE)hv;
	
	if(!(hVoice->bPlaying))
		return E_FAIL;

	return hVoice->pRenderFilter->SetVelocity(v.x,v.y,v.z,DS3D_IMMEDIATE);
}

HRESULT __stdcall xbSetVoiceCone(void* hv ,DWORD dwIn ,DWORD dwOut,Vector vOrientation,LONG lOutVol)
{
	HVOICE hVoice = (HVOICE)hv;

	HRESULT hr	  = S_OK;

	//Make sure that it is currently playing
	if(!(hVoice->bPlaying))
		return E_FAIL;

	hr = hVoice->pRenderFilter->SetConeOutsideVolume(lOutVol,DS3D_IMMEDIATE);
	assert(SUCCEEDED(hr));

	hr = hVoice->pRenderFilter->SetConeAngles(dwIn,dwOut,DS3D_IMMEDIATE);
	assert(SUCCEEDED(hr));

	hr = hVoice->pRenderFilter->SetConeOrientation(vOrientation.x,vOrientation.y,vOrientation.z,DS3D_IMMEDIATE);
	assert(SUCCEEDED(hr));

	return hr;
}

void inline __stdcall VoiceDone()
{
	//If there are no more active voices, put the music back to whereit was
	if(--g_nVoiceCnt == 0)
		xbSetMusicVolume(g_lDipVol);
}
/**********************************************************************************************************
 *
 * FUNCTION:  xbProcess()
 *
 * PURPOSE:	  Call this in the Render loop to continue streaming anything that needs to be streamed.
 *
 **********************************************************************************************************/

HRESULT __stdcall xbProcess()
{
	
	int i = 0;
	DWORD dwPercentComplete = 0x0;
	HRESULT hr = S_OK;

	//If we have paused all streams, don't process anything
	if(g_bMusicPause && g_bVoicePause)
		return S_OK;


	if(!g_bVoicePause)
	{
		for(i = 0; i < NUMVOICEHANDLES; i++)
		{
			if(g_VoiceArr[i].bPlaying)
			{
				if(g_VoiceArr[i].bDone)
				{
					g_VoiceArr[i].pRenderFilter->Flush();
					g_VoiceArr[i].pSourceFilter->Flush();
					//g_VoiceArr[i].pTransformFilter->Flush();
					g_VoiceArr[i].bPlaying = false;
				}else{
					if(g_lVoiceVol != g_VoiceArr[i].lVol)
					{
						g_VoiceArr[i].pRenderFilter->SetVolume(g_lVoiceVol);
						g_VoiceArr[i].lVol = g_lVoiceVol;
					}

					hr = Process(&dwPercentComplete, &g_VoiceArr[i]);
					assert(SUCCEEDED(hr));
				}
			}
		}
	}


	if(!g_bMusicPause)
	{
		for(i = 0; i < NUMMUSICHANDLES; i++)
		{
			if(g_MusicArr[i].bPlaying)
			{
				if(g_MusicArr[i].bDone)
				{
					xbStopMusic(g_MusicArr[i].hsRef);
				}else{
					if(g_lMusicVol != g_MusicArr[i].lVol)
					{
						g_MusicArr[i].pRenderFilter->SetVolume(g_lMusicVol);
						g_MusicArr[i].lVol = g_lMusicVol;
					}

					hr = Process(&dwPercentComplete, &g_MusicArr[i]);
					assert(SUCCEEDED(hr));
				}
			}
		}


		if(g_WMAStream.bPlaying)
		{
			if( !FAILED(g_WMAStream.m_hOpenResult) ) 
			{
			
				// Instruct routine to poll the filter graph so completed packets can be
				// moved through the streaming chain.

				 //If the volume changed, change it!
				if(g_lMusicVol != g_WMAStream.lVol)
				{
					 ((IDirectSoundStream*)(g_WMAStream.m_pTargetXMO))->SetVolume(g_lMusicVol);
					g_WMAStream.lVol = g_lMusicVol;
				}

				if( FAILED( g_WMAStream.TransferData() ) )
					return E_FAIL;

			
				// Because of compression, we have to ask the filter how much
				// we've processed
				g_WMAStream.m_pSourceXMO->Seek(0,FILE_CURRENT,&g_WMAStream.m_dwBytesRead);

				if(100 == g_WMAStream.m_dwPercentCompleted)
				{
					xbStopMusic(g_WMAStream.hsRef);

					if(NULL != g_pContinueFunc)
						g_pContinueFunc(g_WMAStream.hsRef);
				}
			}
		}
	}

	return hr;
}


/////////////////////////////////THIS STUFF WAS TAKEN FROM A SAMPLE-- It is software ADPCM Decompression... it will go away////////////
//-----------------------------------------------------------------------------
// Debugging help
//-----------------------------------------------------------------------------
#define MY_ASSERT(x) if( !(x) ) _asm int 3;

BOOL g_bDoDebugChecks = TRUE;

//-----------------------------------------------------------------------------
// Name: Initialize()
// Desc: Initializes the wave file streaming subsystem.
//-----------------------------------------------------------------------------
HRESULT InitStream(const CHAR* strFileName, HMUSIC hMusic, DWORD dwFlags)
{
    LPCWAVEFORMATEX pwfxSourceFormat;
    WAVEFORMATEX    wfxRendererFormat;
    DSSTREAMDESC    dssd;
    HRESULT         hr;
    
    // Create the source (wave file) filter

	//Don't Leak Anything!
	if(hMusic->pSourceFilter)
	{
		hMusic->pSourceFilter->Release();
		hMusic->pSourceFilter = NULL;
	}

    hr = XWaveFileCreateMediaObject(strFileName, &pwfxSourceFormat, &hMusic->pSourceFilter);
    if(FAILED(hr))
        return hr;

    // The file we're opening needs to be IMA ADPCM
//    MY_ASSERT( WAVE_FORMAT_IMA_ADPCM == pwfxSourceFormat->wFormatTag );

    // Create the transform (ADPCM decompressor) filter

	//Don't Leak anything!
	//if(hMusic->pTransformFilter)
	//{
		//hMusic->pTransformFilter->Release();
		//hMusic->pTransformFilter = NULL;
	//}

    //hr = AdpcmCreateDecoder( (LPCIMAADPCMWAVEFORMAT)pwfxSourceFormat, 
    //                         &wfxRendererFormat, &hMusic->pTransformFilter );
    //if( FAILED(hr) )
    //    return hr;

    // Create the render (DirectSoundStream) filter
    ZeroMemory( &dssd, sizeof(dssd) );
    //dssd.dwSize               = sizeof(dssd);
    dssd.dwMaxAttachedPackets = FILESTRM_PACKET_COUNT;
    dssd.lpwfxFormat          = &wfxRendererFormat;
	dssd.dwFlags			  = DSBCAPS_CTRLVOLUME;

	if(hMusic->dwFlags & ISVOICE)
		dssd.dwFlags |= DSBCAPS_CTRL3D;

	if(hMusic->pRenderFilter)
	{
		hMusic->pRenderFilter->Release();
		hMusic->pRenderFilter = NULL;
	}

    hr = DirectSoundCreateStream(&dssd, &hMusic->pRenderFilter);
    if( FAILED(hr) )
        return hr;

	//Set the Volume
	hMusic->pRenderFilter->SetVolume(hMusic->lVol);

//    if( g_bDoDebugChecks )
//    {

//#ifdef DEBUG

        XMEDIAINFO xmi;

        // We expect the source filter to be synchronous and read-only, the
        // transform filter to be synchronous and read/write and the render
        // filter to be asynchronous write-only.  Assert that all of this 
        // is true and check the packet sizes for compatibility.

        hr = hMusic->pSourceFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE) );
        MY_ASSERT( !xmi.dwMaxLookahead );
        MY_ASSERT( !xmi.dwInputSize );
        MY_ASSERT( !(FILESTRM_SOURCE_PACKET_BYTES % xmi.dwOutputSize) );

        //hr = hMusic->pTransformFilter->GetInfo( &xmi );
        //if( FAILED(hr) )
        //    return hr;
        //MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE) );
        //MY_ASSERT( !xmi.dwMaxLookahead );
        //MY_ASSERT( !(FILESTRM_SOURCE_PACKET_BYTES % xmi.dwInputSize) );
//        MY_ASSERT( !(FILESTRM_RENDER_PACKET_BYTES % xmi.dwOutputSize) );

        hr = hMusic->pRenderFilter->GetInfo( &xmi );
        if( FAILED(hr) )
            return hr;
        MY_ASSERT( xmi.dwFlags == (XMO_STREAMF_WHOLE_SAMPLES | XMO_STREAMF_FIXED_SAMPLE_SIZE | XMO_STREAMF_INPUT_ASYNC) );
        MY_ASSERT( FILESTRM_RENDER_PACKET_BYTES * FILESTRM_PACKET_COUNT >= xmi.dwMaxLookahead );
        MY_ASSERT( !(FILESTRM_RENDER_PACKET_BYTES % xmi.dwInputSize) );
        MY_ASSERT( !xmi.dwOutputSize );
   // }

//#endif

    // Get the total wave file size.  We'll use this to calculate how far
    // along in the file we are during processing.
    hr = hMusic->pSourceFilter->GetLength( &hMusic->dwFileLength );
    if( FAILED(hr) )
        return hr;

	//Start Processing this music
	hMusic->bPlaying = true;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Process()
// Desc: Performs any work necessary to keep the stream playing.
//-----------------------------------------------------------------------------
HRESULT Process(DWORD* pdwPercentCompleted, HMUSIC hMusic)
{
    DWORD   dwPacketIndex;
    HRESULT hr;
    
    // Find a free packet.  If there's none free, we don't have anything
    // to do
    while( FindFreePacket(&dwPacketIndex, hMusic) )
    {
        // Read from the source filter
        hr = ProcessSource(hMusic);
        if( FAILED(hr) )
            return hr;
        
        // Pass the data through the transform
        hr = ProcessTransform(dwPacketIndex, hMusic);
        if( FAILED(hr) )
            return hr;

        // Send the data to the renderer
        hr = ProcessRenderer(dwPacketIndex, hMusic);
        if( FAILED(hr) )
            return hr;
    }

	//If it is a streamed voice, we don't need the request/continue callbacks
	if(!(hMusic->dwFlags & ISVOICE))
	{

	    // Calculate the completion percentage based on the total amount of
	    // data we've read from the source.
		if(pdwPercentCompleted )
        (*pdwPercentCompleted) = hMusic->dwFileProgress * 100 / hMusic->dwFileLength;


		//Use the callbacks
		if((*pdwPercentCompleted > 75) && (*pdwPercentCompleted < 100) && (NULL != g_pRequestFunc))
			g_pRequestFunc(hMusic->hsRef);
		
		if(hMusic->bDone && (NULL != g_pContinueFunc))//(*pdwPercentCompleted == 100) && (NULL != g_pContinueFunc))
			g_pContinueFunc(hMusic->hsRef);
	}

	return S_OK;
}




//-----------------------------------------------------------------------------
// Name: FindFreePacket()
// Desc: Finds a render packet available for processing.
//-----------------------------------------------------------------------------
BOOL FindFreePacket(DWORD* pdwPacketIndex, HMUSIC hMusic)
{
    for( DWORD dwPacketIndex = 0; dwPacketIndex < FILESTRM_PACKET_COUNT; dwPacketIndex++ )
    {
        if( XMEDIAPACKET_STATUS_PENDING != hMusic->adwPacketStatus[dwPacketIndex] )
        {
            if( pdwPacketIndex )
                (*pdwPacketIndex) = dwPacketIndex;

            return TRUE;
        }
    }

    return FALSE;
}




//-----------------------------------------------------------------------------
// Name: ProcessSource()
// Desc: Reads data from the source filter.
//-----------------------------------------------------------------------------
HRESULT ProcessSource(HMUSIC hMusic)
{
    DWORD        dwTotalSourceUsed   = 0;
    DWORD        dwSourceUsed;
    XMEDIAPACKET xmp;
    HRESULT      hr;
    
    // We're going to read a full packet's worth of data into the source
    // buffer.  Since we're playing in an infinite loop, we'll just spin
    // until we've read enough data, even if that means wrapping around the
    // end of the file.

    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer         = hMusic->pvSourceBuffer;
    xmp.dwMaxSize        = FILESTRM_SOURCE_PACKET_BYTES;
    xmp.pdwCompletedSize = &dwSourceUsed;

    while( dwTotalSourceUsed < FILESTRM_SOURCE_PACKET_BYTES )
    {
        // Read from the source
        hr = hMusic->pSourceFilter->Process(NULL, &xmp);
        if( FAILED(hr) )
            return hr;

        // Add the amount read to the total
        dwTotalSourceUsed = dwSourceUsed;

        // If we read less than the amount requested, it's because we hit
        // the end of the file.  Seek back to the start and keep going.
        if( dwSourceUsed < xmp.dwMaxSize )
        {
            xmp.pvBuffer  = (BYTE*)xmp.pvBuffer + dwSourceUsed;
            xmp.dwMaxSize = xmp.dwMaxSize - dwSourceUsed;
            
			if(!(hMusic->dwFlags & LOOPING))
			{
				hMusic->bDone = true;
				if(hMusic->dwFlags & ISVOICE)
				{
					VoiceDone();
				}
				return S_OK;
			}

            hr = hMusic->pSourceFilter->Seek(0,FILE_BEGIN,NULL);
            if( FAILED(hr) )
                return hr;
        };
    }

    // Update the file progress
    hMusic->dwFileProgress += dwTotalSourceUsed;
    hMusic->dwFileProgress %= hMusic->dwFileLength;

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: ProcessTransform()
// Desc: Transforms data in the source buffer into the render buffer.
//-----------------------------------------------------------------------------
HRESULT ProcessTransform(DWORD dwPacketIndex, HMUSIC hMusic)
{
    XMEDIAPACKET xmpSource;
    XMEDIAPACKET xmpRender;
    DWORD        dwSourceUsed;
    DWORD        dwRenderUsed;
    
    // The source buffer is full and we're ready to transform it's data into
    // the render buffer
    ZeroMemory( &xmpSource, sizeof(xmpSource) );
    xmpSource.pvBuffer         = hMusic->pvSourceBuffer;
    xmpSource.dwMaxSize        = FILESTRM_SOURCE_PACKET_BYTES;
    xmpSource.pdwCompletedSize = &dwSourceUsed;

    ZeroMemory( &xmpRender, sizeof(xmpRender) );
    xmpRender.pvBuffer         = (BYTE*)hMusic->pvRenderBuffer + (dwPacketIndex * FILESTRM_RENDER_PACKET_BYTES);
    xmpRender.dwMaxSize        = FILESTRM_RENDER_PACKET_BYTES;
    xmpRender.pdwCompletedSize = &dwRenderUsed;

    //hr = hMusic->pTransformFilter->Process(&xmpSource,&xmpRender);
    //if( FAILED(hr) )
    //    return hr;

     MY_ASSERT( FILESTRM_SOURCE_PACKET_BYTES == dwSourceUsed );
//    MY_ASSERT( FILESTRM_RENDER_PACKET_BYTES == dwRenderUsed );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: ProcessRenderer()
// Desc: Sends data to the renderer.
//-----------------------------------------------------------------------------
HRESULT ProcessRenderer(DWORD dwPacketIndex, HMUSIC hMusic)
{
    XMEDIAPACKET xmp;
    HRESULT      hr;

    // There's a full packet's worth of data ready for us to send to the
    // renderer.  We want to track the status of this packet since the
    // render filter is asychronous and we need to know when the packet is
    // completed.
    ZeroMemory( &xmp, sizeof(xmp) );
    xmp.pvBuffer  = (BYTE*)hMusic->pvRenderBuffer + (dwPacketIndex * FILESTRM_RENDER_PACKET_BYTES);
    xmp.dwMaxSize = FILESTRM_RENDER_PACKET_BYTES;
    xmp.pdwStatus = &hMusic->adwPacketStatus[dwPacketIndex];

    hr = hMusic->pRenderFilter->Process( &xmp, NULL );
    if( FAILED(hr) )
        return hr;

    return S_OK;
}

///////////////////////////////////////////WMA STUFF//////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
// File: AsyncXMO.cpp
//
// Desc: A sample to show how to stream data between 3 XMOs( 1 async source, 
//       one sychronous in the middle, one async target.
//
// Hist: 02.20.01 - New for March XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

//
// Debug macros
//
#define ASSERT(w) {if(w){}}
#define DBG_SPAM(_exp_)
#define DBG_INFO(_exp)
#define DBG_ERROR(_exp)
#define DBG_WARN(_exp)


//
// Simple macro to verify that the packet size is OK for a particular XMO
//
inline HRESULT XMOFILTER_VERIFY_PACKET_SIZE( XMEDIAINFO& xMediaInfo, DWORD dwPacketSize )
{
    if( xMediaInfo.dwOutputSize > dwPacketSize )
        return E_FAIL;
    if( xMediaInfo.dwOutputSize ) 
        if( dwPacketSize % xMediaInfo.dwOutputSize != 0 )
            return E_FAIL;
    if( dwPacketSize < xMediaInfo.dwMaxLookahead )
        return E_FAIL;

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: AttachPacketToSourceXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       source XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the source XMO (first xmo in the chain)
    hr = m_pSourceXMO->Process( NULL, &xmb );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our source list
    m_SourcePendingList.Add( &pCtx->ListEntry );

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: AttachPacketToTargetXMO
//
// Desc: Helper function that prepares a packet context and attaches it to the
//       target XMO
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx )
{
    HRESULT      hr;
    XMEDIAPACKET xmb;

    // Mark this packet as pending
    pCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

    // Set up our XMEDIAPACKET
    ZeroMemory( &xmb, sizeof(xmb) );
    xmb.pvBuffer         = pCtx->pBuffer;           // Point into buffer         
    xmb.dwMaxSize        = pCtx->dwCompletedSize;   // Size of packet
    xmb.pdwCompletedSize = &pCtx->dwCompletedSize;  // Pointer to completed size
    xmb.pdwStatus        = &pCtx->dwStatus;         // Pointer to status

    // Attach to the target XMO (first xmo in the chain)
    hr = m_pTargetXMO->Process( &xmb, NULL );
    if( FAILED(hr) ) 
    {
        DBG_ERROR(("InsertContext: Xmo %x, Process failed with hr = %x\n",hr));
    }

    // Add this context to our target list
    m_TargetPendingList.Add( &pCtx->ListEntry );

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Initialize
//
// Desc: Creates a streaming graph between 3 XMOs: a source, a in-between
//       (codec in this case) and a target. We only support one intermediate
//       xmo, but you could actually have multiple ones that manipulate the
//       same stream passing packets between them
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::Initialize(char* szFileName)
{
    HRESULT        hr = S_OK;
    DWORD          dwMinSize;
    XMEDIAINFO     xMediaInfo;
    DSSTREAMDESC   dssd;

    m_dwBytesRead = 0;
    m_dwPacketSize     = PACKET_SIZE;
    m_dwMaxBufferCount = PACKET_CNT;

	//Make sure we don't leak anything...
	if(m_pSourceXMO)
	{
		m_pSourceXMO->Release();
		m_pSourceXMO = NULL;
	}

    // Create src media object
	m_hOpenResult = WmaCreateDecoder(szFileName,//"D:\\MEDIA\\sound\\test.wma",
		                             NULL,
			                         TRUE,
				                     4096*16,
                                     16,    //max packets, let's guess 16 for now
                                     1,     //always yield, does this work?
					                 &m_wfxAudioFormat,
						             (XFileMediaObject **)&m_pSourceXMO );


    if( FAILED(m_hOpenResult) ) 
    {
        // If we failed to create a decoder, return success so we keep running.
        // FrameMove and render will check this error code and display an error
        // message instead of attempting to process the WMA
        DBG_ERROR( ("XmoFilter: WmaCreateDecoder failed with %x", m_hOpenResult) );
        return S_OK;
    }

    m_pSourceXMO->GetLength( &m_dwSourceLength );

    // Now create the target XMO, the end part of the streaming chain
    ZeroMemory( &dssd, sizeof(dssd) );
    //dssd.dwSize               = sizeof(dssd);
    dssd.dwFlags              = DSBCAPS_CTRLVOLUME;
    dssd.dwMaxAttachedPackets = PACKET_CNT;
    dssd.lpwfxFormat          = &m_wfxAudioFormat;

	//NO LEAKING!!!
	if(!m_pTargetXMO)
    {
		hr = DirectSoundCreateStream(&dssd, (LPDIRECTSOUNDSTREAM*)&m_pTargetXMO);
	}

    if( FAILED(hr) ) 
    {          
        DBG_ERROR( ("XmoFilter: DirectSoundCreateXMOStream failed with %x", hr) );
        DBG_ERROR( ("Init: Could not open a target audio XMO\n") );
        return hr;
    }

    //
    // At this point we should have all the XMOs.
    // Figure out the minimum packet size we need to pass media buffers
    // in between XMOs. All we do is verifying that our size (PACKET_SIZE)
    // is both larger than the min of all XMOs and its length aligned.
    // As a last check we make sure its also larger than the maxLookahead
    //
    // At the end of all this, m_dwMinPacketSize is the minimum packet size
    // for this filter graph.
    //
    ZeroMemory( &xMediaInfo, sizeof( XMEDIAINFO ) );

    if( m_pSourceXMO )
    {
        m_pSourceXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = xMediaInfo.dwOutputSize;

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    if( m_pTargetXMO )
    {
        m_pTargetXMO->GetInfo( &xMediaInfo );
        m_dwMinPacketSize = max( xMediaInfo.dwOutputSize, m_dwMinPacketSize );

        XMOFILTER_VERIFY_PACKET_SIZE( xMediaInfo, m_dwPacketSize );
    }

    ASSERT( m_pTargetXMO );
    ASSERT( m_pSourceXMO );

    // Initialize the linked lists
    m_SourcePendingList.Initialize();
    m_TargetPendingList.Initialize();

    //
    // Allocate one large buffer for incoming/outgoing data. The buffer is
    // going to be divided among our media context packets, which will be 
    // used to stream data between XMOs
    //
    dwMinSize = MAXBUFSIZE;
    //m_pTransferBuffer = new BYTE[dwMinSize];
    ZeroMemory( m_pTransferBuffer, dwMinSize );

    //
    // Allocate a context pool. A context is associated with a packet buffer
    // and used to track the pending packets attached to the source or target
    // XMO.
    dwMinSize = ( PACKET_CNT * sizeof(MEDIA_PACKET_CTX) );
    //m_pPacketContextPool = new BYTE[dwMinSize];
    ZeroMemory( m_pPacketContextPool, dwMinSize );

    //
    // We attach all available packet buffers in the beginning to prime the
    // graph: As each packet is completed by the source XMO, the status is
    // udpated in its packet context and we pass the packet to the next XMO.
    //
    for( DWORD i = 0; i < PACKET_CNT; i++ ) 
    {
        MEDIA_PACKET_CTX* pCtx = &((MEDIA_PACKET_CTX*)m_pPacketContextPool)[i];

        ZeroMemory( pCtx, sizeof(MEDIA_PACKET_CTX) );
        pCtx->dwCompletedSize = m_dwPacketSize;
        pCtx->pBuffer         = &m_pTransferBuffer[i*PACKET_SIZE];

        AttachPacketToSourceXMO( pCtx );
    }

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: Cleanup
// Desc: Clean up resources
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::Cleanup()
{
    // Cleanup: delete any XMO's
    if( m_pSourceXMO )       
        m_pSourceXMO->Release();
    if( m_pTargetXMO )       
        m_pTargetXMO->Release();

    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: FrameMove
// Desc: Performs per-frame updates, such as checking async xmo status, and
//       updating source file position for our progress bar
//-----------------------------------------------------------------------------
HRESULT
CFilterGraph::FrameMove()
{
   if( !FAILED(m_hOpenResult) ) 
   {
        // Instruct routine to poll the filter graph so completed packets can be
        // moved through the streaming chain.
        if( FAILED( TransferData() ) )
            return E_FAIL;

        // Because of compression, we have to ask the filter how much
        // we've processed
        m_pSourceXMO->Seek( 0, FILE_CURRENT, &m_dwBytesRead  );
   }
        
    return S_OK;
}


//-----------------------------------------------------------------------------
// Name: TransferData
// Desc: If we have a packet completed from our source XMO, pass it through
//       the intermediate XMO and on to the target.
//       If we have a packet completed from our target XMO, recycle it back
//       to the source XMO.
//-----------------------------------------------------------------------------
HRESULT CFilterGraph::TransferData()
{
    HRESULT        hr=S_OK;
    DWORD          index = 0;
    XMEDIAPACKET   xmb;
    MEDIA_PACKET_CTX* pSrcCtx = NULL;
    MEDIA_PACKET_CTX* pDstCtx = NULL;
    DWORD             dwSize  = 0;

    // Setup media buffer
    ZeroMemory( &xmb, sizeof(xmb) );

    //
    // Always deal with the oldest packet first.  Oldest packets are at the 
    // head, since we insert at the tail, and remove from head
    //
    if( !m_SourcePendingList.IsListEmpty() ) 
    {
        pSrcCtx = (MEDIA_PACKET_CTX*)m_SourcePendingList.pNext; // Head
    }

    if( !m_TargetPendingList.IsListEmpty() ) 
    {
        pDstCtx = (MEDIA_PACKET_CTX*)m_TargetPendingList.pNext; // Head
    }        

    // Do we have a completed source packet?
    if( pSrcCtx && pSrcCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING ) 
    {
        // A src buffer completed.
        // Remove this context from the Src pending list.
        // Send it to a codec, if present, then send it to the Target xmo
        pSrcCtx->ListEntry.Remove();

        // Before we pass it on, set the context packet to amount of data we received
        xmb.pvBuffer         = pSrcCtx->pBuffer;            
        xmb.dwMaxSize        = pSrcCtx->dwCompletedSize;

        DBG_SPAM(("Context %x received %x bytes, xmb %x\n",pSrcCtx, xmb.dwMaxSize, &xmb));
        ASSERT( xmb.dwMaxSize );

        // Rset the state of our context
        pSrcCtx->dwCompletedSize = 0;
        pSrcCtx->dwStatus        = XMEDIAPACKET_STATUS_PENDING;

        // Remember how much data we got from the source XMO
        dwSize = xmb.dwMaxSize;

        pSrcCtx->dwCompletedSize = m_dwPacketSize;

        if (dwSize < PACKET_SIZE) {
    
            //
            // the source xmo produced less than asked. this signals end of file for wma xmo
            // flush it so it starts at the begininning again...
            // Pass at least a sample worth of data to dsound so it will not RIP
            //
			if(!(g_WMAStream.dwFlags & LOOPING))
			{
				m_pSourceXMO->Flush();
				pSrcCtx->dwCompletedSize = max(4,dwSize);
				m_dwPercentCompleted = 100;
			}else{
				m_pSourceXMO->Flush();
				pSrcCtx->dwCompletedSize = max(4,dwSize);
			}

        }

        // Pass media buffer to the target xmo.
        AttachPacketToTargetXMO( pSrcCtx );
    }

    // Check if we have a completed packet from the target
    if( pDstCtx && pDstCtx->dwStatus != XMEDIAPACKET_STATUS_PENDING )
    {       
        DBG_SPAM(("Target XMO completed context %x\n",pDstCtx));

        // Remove the entry from the list
        pDstCtx->ListEntry.Remove();

        ASSERT(pDstCtx->dwCompletedSize != 0);

        // The target XMO is done with a buffer.
        pDstCtx->dwCompletedSize = PACKET_SIZE;
        AttachPacketToSourceXMO( pDstCtx );
    } 

    return S_OK;
}





//-----------------------------------------------------------------------------

// Name: DownloadScratch

// Desc: Downloads a DSP scratch image to the DSP

//-----------------------------------------------------------------------------

HRESULT DownloadScratch(IDirectSound8* pDSnd, PCHAR pszScratchFile)
{

    HANDLE hFile;
    DWORD dwSize;
    PVOID pBuffer = NULL;
    HRESULT hr = S_OK;
    LPDSEFFECTIMAGEDESC pDesc;
    DSEFFECTIMAGELOC pIDesc;

    // open scratch image file generated by xps2 tool
    hFile = CreateFile( pszScratchFile,
                        GENERIC_READ,
                        0,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );

    if( hFile == INVALID_HANDLE_VALUE )
    {
        DWORD err = GetLastError();

//        OutputDebugString( _T("Failed to open the dsp image file.\n") );
        hr = HRESULT_FROM_WIN32(err);
    }

    if( SUCCEEDED(hr) )
    {
        // Determine the size of the scratch image by seeking to
        // the end of the file
        dwSize = SetFilePointer( hFile, 0, NULL, FILE_END );
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        // Allocate memory to read the scratch image from disk
        pBuffer = new BYTE[dwSize];

        // Read the image in
        DWORD dwBytesRead;
        BOOL bResult = ReadFile( hFile,
                                 pBuffer,
                                 dwSize,
                                 &dwBytesRead,
                                 0 );

        if (!bResult)
        {
            DWORD err = GetLastError();

            //      OutputDebugString( _T("\n Failed to open the dsp image file.\n") );
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    if( SUCCEEDED(hr) )
    {
        // call dsound api to download the image..
        // call dsound api to download the image..
        pIDesc.dwI3DL2ReverbIndex = DSFX_IMAGELOC_UNUSED;//0;//I3DL2_CHAIN_I3DL2_REVERB;
        pIDesc.dwCrosstalkIndex = 1;//I3DL2_CHAIN_XTALK;

        if (SUCCEEDED(hr))
        {
            hr = pDSnd->DownloadEffectsImage( pBuffer,
                                              dwSize,
                                              NULL,
                                              &pDesc );
        }
    }

    delete[] pBuffer;

    if( hFile != INVALID_HANDLE_VALUE ) 
    {
        CloseHandle( hFile );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\wmv\debugstats.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation. All rights reserved.

Module Name:

    debugstats.cpp

Abstract:

    Debug information and statistics

--*/

#include "wmvplay.h"

#ifdef DEBUGSTATS

ULONGLONG TotalAudioData;
ULONG MaxAudioPacketSize, MinAudioPacketSize;
ULONG TotalVideoPackets, TotalAudioPackets;
ULONG LongestVideoStretch, LongestAudioStretch;
ULONG LastStretchType, LastStretchLength;
REFERENCE_TIME NextSpewTime;
MEMORYSTATUS StartMemStatus, StopMemStatus;

struct HEAPSTATUS {
    ULONG AllocedElementCount;
    ULONG AllocedElementBytes;
};
HEAPSTATUS StartHeapStatus, StopHeapStatus;

inline VOID UpdateStretch(ULONG type) {
    if (type != LastStretchType) {
        if (LastStretchType & PACKETFLAG_SOUND)
            LongestAudioStretch = max(LongestAudioStretch, LastStretchLength);
        if (LastStretchType & PACKETFLAG_VIDEO)
            LongestVideoStretch = max(LongestVideoStretch, LastStretchLength);
        LastStretchType = type;
        LastStretchLength = 0;
    }
}

//
// Obtain current process heap stats
//
VOID GetProcessHeapStatus(HEAPSTATUS* heapstats)
{
    HANDLE heap = GetProcessHeap();
    PROCESS_HEAP_ENTRY entry;

    memset(heapstats, 0, sizeof(*heapstats));
    memset(&entry, 0, sizeof(entry));

    BOOL lockok = HeapLock(heap);
    ASSERT(lockok);
    
    while (HeapWalk(heap, &entry)) {
        if (entry.wFlags & PROCESS_HEAP_ENTRY_BUSY) {
            heapstats->AllocedElementCount++;
            heapstats->AllocedElementBytes += entry.cbData;
        }
    }

    lockok = HeapUnlock(heap);
    ASSERT(lockok);
}

//
// Start collecting debug stats
//
VOID StartDebugStats()
{
    TotalAudioData = 0;
    MaxAudioPacketSize = 0;
    MinAudioPacketSize = ULONG_MAX;
    LongestAudioStretch = LongestVideoStretch = 0;
    TotalAudioPackets = TotalVideoPackets = 0;
    LastStretchType = 0;
    LastStretchLength = 0;
    NextSpewTime = 0;

    StartMemStatus.dwLength = sizeof(StartMemStatus);
    GlobalMemoryStatus(&StartMemStatus);
    GetProcessHeapStatus(&StartHeapStatus);
}

//
// Stop collecting debug stats and dump out the results
//
VOID StopDebugStats()
{
    UpdateStretch(0);

    VERBOSE("Total # of video packets: %d\n", TotalVideoPackets);
    VERBOSE("  longest stretch: %d\n", LongestVideoStretch);
    VERBOSE("Total # of audio packets: %d\n", TotalAudioPackets);
    VERBOSE("  longest stretch: %d\n", LongestAudioStretch);
    if (TotalAudioPackets) {
        VERBOSE("  average size: %d bytes\n", (ULONG) (TotalAudioData / TotalAudioPackets));
        VERBOSE("  max size: %d bytes\n", MaxAudioPacketSize);
        VERBOSE("  min size: %d bytes\n", MinAudioPacketSize);
    }

    StopMemStatus.dwLength = sizeof(StopMemStatus);
    GlobalMemoryStatus(&StopMemStatus);

    if (StopMemStatus.dwAvailPhys != StartMemStatus.dwAvailPhys) {
        VERBOSE("Physical memory delta: 0x%x - 0x%x = 0x%x\n",
            StartMemStatus.dwAvailPhys,
            StopMemStatus.dwAvailPhys,
            StartMemStatus.dwAvailPhys - StopMemStatus.dwAvailPhys);
    }
    
    GetProcessHeapStatus(&StopHeapStatus);
    if (StartHeapStatus.AllocedElementBytes != StopHeapStatus.AllocedElementBytes) {
        VERBOSE("Heap state before: %d elements, %d bytes\n",
                StartHeapStatus.AllocedElementCount,
                StartHeapStatus.AllocedElementBytes);
        VERBOSE("Heap state after: %d elements, %d bytes\n",
                StopHeapStatus.AllocedElementCount,
                StopHeapStatus.AllocedElementBytes);
        VERBOSE("Total delta: %d elements, %d bytes\n",
                StopHeapStatus.AllocedElementCount - StartHeapStatus.AllocedElementCount,
                StopHeapStatus.AllocedElementBytes - StartHeapStatus.AllocedElementBytes);
    }
}

//
// Update debug stats
//
VOID UpdateDebugStats(Packet* pkt)
{
    UpdateStretch(pkt->flags);
    LastStretchLength++;

    if (pkt->flags & PACKETFLAG_SOUND) {
        TotalAudioPackets++;
        TotalAudioData += pkt->completedSize;
        MaxAudioPacketSize = max(MaxAudioPacketSize, pkt->completedSize);
        MinAudioPacketSize = min(MinAudioPacketSize, pkt->completedSize);
    } else {
        TotalVideoPackets++;
    }

    if (pkt->timestamp >= NextSpewTime) {
        VERBOSE("%c %d\n",
                (pkt->flags & PACKETFLAG_SOUND) ? 'a' : 'v',
                (LONG) (pkt->timestamp / 10000));
        NextSpewTime += 1000*10000;
    }
}

#endif // DEBUGSTATS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\wmv\wmvplay.h ===
//=============================================================================
// File: wmvplay.h
//
// Desc: WMV playback - header file
// Created: 09/12/2001
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//=============================================================================

#pragma once

#include <xtl.h>
#include <wmvxmo.h>

extern IDirectSound8* g_pDSnd;

//
// Debug macros
//
#if _DEBUG
extern "C" ULONG __cdecl DbgPrint(CHAR*, ...);
#define VERBOSE DbgPrint
#define ASSERT(cond) do { \
            if (!(cond)) { \
                DbgPrint("Error on line %d: %s\n", __LINE__, #cond); \
                DebugBreak(); \
            } \
        } while (0)
#else
#define VERBOSE 1 ? (void)0 : (void)
#define ASSERT(cond)
#endif

//
// Maximum number of active sound packets
//  and the max size of each packets (in samples)
//
#define MAX_SOUND_PACKETS 256
#define MAX_SAMPLES_PER_SOUND_PACKET 512

//
// Maximum number of textures (must be >= 2)
//
#define MAX_TEXTURES            12
#define SCREENWIDTH             640
#define SCREENHEIGHT            480

//
// Packet queue structures
//
#define PACKETFLAG_SOUND        0x01
#define PACKETFLAG_VIDEO        0x02

struct Packet {
    Packet* next;
    DWORD flags;
    DWORD completedSize;
    DWORD status;
    REFERENCE_TIME timestamp;
    XMEDIAPACKET xmp;
};

struct PacketList {
    Packet* head;
    Packet* tail;

    PacketList() { head = tail = NULL; }

    BOOL IsEmpty() { return head == NULL; }

    Packet* RemoveHead() {
        Packet* pkt = head;

        if ((head = pkt->next) == NULL)
            tail = NULL;
        else
            pkt->next = NULL;

        return pkt;
    }
    
    VOID AddTail(Packet* pkt) {
        if (tail)
            tail->next = pkt;
        else
            head = pkt;

        tail = pkt;
        pkt->next = NULL;
    }
};

class PacketQueue {
public:
    //
    // Return the first packet in the free packet list to the decoder
    //
    Packet* GetFreeListHead() {
        Packet* pkt = freeList.RemoveHead();

        pkt->completedSize = 0;
        pkt->xmp.dwMaxSize = maxPacketSize;
        return pkt;
    }

    //
    // Return the packet to the free packet list
    //
    VOID ReleaseFreePacket(Packet* pkt) {
        freeList.AddTail(pkt);
    }

    //
    // This is called by the decoder when it has a packet ready
    // for the render threads.
    //
    VOID ScheduleReadyPacket(Packet* pkt) {
        pkt->xmp.dwMaxSize = pkt->completedSize;
        readyList.AddTail(pkt);
    }

    PacketList freeList;
    PacketList readyList;
    PacketList busyList;

protected:
    PacketQueue() {
        maxCount = 0;
        maxPacketSize = 0;
    }

    BOOL Initialize() {
        Packet* pkt = freeList.head;
        do {
            pkt->xmp.pdwCompletedSize = &pkt->completedSize;
            pkt->xmp.pdwStatus = &pkt->status;
            pkt->xmp.prtTimestamp = &pkt->timestamp;
            pkt = pkt->next;
        } while (pkt);

        return TRUE;
    }

    LONG maxCount;
    DWORD maxPacketSize;
};

//
// Sound packet queue
//
class SoundPacketQueue : public PacketQueue {
public:
    static SoundPacketQueue* Create() {
        SoundPacketQueue* soundq = new SoundPacketQueue();
        if (soundq && soundq->Initialize())
            return soundq;

        delete soundq;
        return NULL;
    }

    ~SoundPacketQueue() {
        if (packetArray) {
            free(packetArray);
        }

        if (soundStream) {
            soundStream->Release();
        }
    }

    VOID GetTime(REFERENCE_TIME* time) {
        HRESULT hr = g_pDSnd->GetTime(time);
        ASSERT(SUCCEEDED(hr));
    }

    VOID Process();
    VOID Shutdown() {
         while (!busyList.IsEmpty()) {
            RetireBusyList();
        }
    }

private:
    SoundPacketQueue() {
        soundStream = NULL;
        packetArray = NULL;
    }

    BOOL Initialize();
    BOOL RetireBusyList();

    LPDIRECTSOUNDSTREAM soundStream;
    VOID* packetArray;
};

//
// Texture buffer queue
//
struct TexturePacket : public Packet {
    IDirect3DTexture8* d3dtex;
};

class TextureBufferQueue : public PacketQueue {
public:
    static VOID InitializeD3D();

    static TextureBufferQueue* Create() {
        TextureBufferQueue* textureq = new TextureBufferQueue();
        if (textureq && textureq->Initialize())
            return textureq;
        delete textureq;
        return NULL;
    }

    ~TextureBufferQueue() {
        for (INT i=0; i < MAX_TEXTURES; i++) {
            if (textures[i].d3dtex) {
                textures[i].d3dtex->Release();
            }
        }
    }

    VOID Process();
    VOID Shutdown();

private:
    TextureBufferQueue() {
        memset(textures, 0, sizeof(textures));
    }

    BOOL Initialize();
    IDirect3DVertexBuffer8* CreateVertexBuffer(BOOL fullscreen);
    VOID RenderFrame(TexturePacket* pkt);
    
    TexturePacket textures[MAX_TEXTURES];
    LONG discardedFrames, overlayBlocks;

    static LONG refreshInterval;
};

extern WAVEFORMATEX AudioInfo;
extern SoundPacketQueue* SoundQ;
extern WMVVIDEOINFO VideoInfo;
extern TextureBufferQueue* TextureQ;
extern REFERENCE_TIME StartPresentationTime, CurrentPlayTime;
extern BOOL FullScreenMode;
extern INT DecodingFlag;
extern BOOL ContinuousMode;
extern BOOL TestDVDFiles;
extern INT TestFileIndex;

//
// Poll controllers for input
//
VOID PollInput();

//
// Decoding flags
//
enum {
    DECODING_IDLE,
    DECODING_PAUSED,
    DECODING_ABORTED,
    DECODING_INPROGRESS,
    DECODING_COMPLETED,
    DECODING_EXIT,
};

inline VOID AbortDecoding() { DecodingFlag = DECODING_ABORTED; }
inline BOOL DecodingInProgress() { return DecodingFlag == DECODING_INPROGRESS; }

//
// Debug information and statistics
//
#if DBG && defined(DONT_PLAY_SOUND) && defined(DONT_PLAY_VIDEO)
#define DEBUGSTATS
#endif

#ifdef DEBUGSTATS
VOID StartDebugStats();
VOID StopDebugStats();
VOID UpdateDebugStats(Packet* pkt);
#else
#define StartDebugStats()
#define StopDebugStats()
#define UpdateDebugStats(pkt)
#endif

bool PlayWMVFile(char *szFileName);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XAudio\XAudioI.h ===
/*****************************************************************************************************************

	These are flags used for the dwFlags parameter in the HSOUND struct.  3DSOUND will assert that the sound is 3D,
	ISVOICE lets us know that the sound is a voice, ISMUSIC tells us if it is music, RANDOM lets us know we should
	apply random effects to the sound within a certain range, and looping tells us if the sound loops or not

******************************************************************************************************************/

#define THREEDSND	0x00000001		//Is this a 3D Sound
#define ISVOICE		0x00000002		//Is this sound a voice
#define ISMUSIC		0x00000004		//Is this sound music
#define RANDOM		0x00000008		//Determines if we are to apply a random effect within some range

#define TWOTWOKHZ	0x00000010
#define FORFORKHZ	0x00000020

#define ADPCM		0x00000100
#define WMA			0x00000200
#define PCM			0x00000400
		
#define LOOPING		0x00001000

//Masks for checking format, sample rate, & both
#define FORMAT_MASK 0x00000f00
#define SAMPLE_MASK 0x000000f0
#define BUFFER_MASK 0x00000ff0


//Masks for deciding whether to apply Velocity, Position, & Cones to a sound played
#define VELOCITY	0x00000001
#define POSITION	0x00000010
#define CONE		0x00000100
#define VOLUME		0x00001000


//#define's for the real-world multiples of roll-off, doppler & Distance units
#define DISTANCE	1
#define DOPPLER		1
#define ROLLOFF		1

#define INVALID		-1



//JJBUG-- Get the real definition of Vector from Ronin
struct Vector
{
	float x;
	float y;
	float z;
};


typedef struct _tagVoiceInfo
{
	D3DVECTOR	pPosition;
	D3DVECTOR	pVelocity;
	
	//Cone Data
	DWORD		dwInConeAngle;
	DWORD		dwOutConeAngle;
	Vector		vConeOrientation;
	LONG		lOuterVolume;
}VOICE_INFO,*PVOICE_INFO;

//Voice & Music streams require the same info...
typedef void* HVOICE;
typedef void* HMUSIC;
typedef void* HSTREAM;
typedef void* SNDHANDLE;
typedef void* HCHANNEL3D;	//Really the same thing...except that the void* parameter doesn't matter

enum OBSTRUCTION_TYPE;			//JJBUG-- Figure out what obstruction types we need after talking w/ Ronin

//Functions

//Regular sound functions
HRESULT __stdcall xbInitAudio();
HRESULT __stdcall xbUninitAudio();													//JJBUG -- TODO- Necessary?
SNDHANDLE __stdcall xbGetHandle(void*, DWORD, DWORD);
HRESULT __stdcall xbPlaySound(SNDHANDLE, bool);								
HRESULT __stdcall xbStopSound(SNDHANDLE);				
HRESULT __stdcall xbSetVolume(SNDHANDLE, LONG);		
HRESULT __stdcall xbFadeVolume(SNDHANDLE,LONG,LONG);								//JJBUG -- NEED XDK Update
HRESULT __stdcall xbSet2DPan(SNDHANDLE, LONG);										//JJBUG -- NEED XDK Update
HRESULT __stdcall xbFade2DPan(SNDHANDLE, LONG, LONG);								//JJBUG -- NEED XDK Update
HRESULT __stdcall xbSet3DPosition(SNDHANDLE, Vector);									
HRESULT __stdcall xbSet3DVelocity(SNDHANDLE, Vector);									
HRESULT __stdcall xbSet3DCone(SNDHANDLE,DWORD,DWORD,Vector,LONG);
HRESULT __stdcall xbSetFX(SNDHANDLE);												//JJBUG -- NEED XDK Update
HRESULT __stdcall xbIsSoundPlaying(SNDHANDLE, bool*);									
HRESULT __stdcall xbGetFlags(SNDHANDLE, DWORD*);
HRESULT __stdcall xbSetFlags(SNDHANDLE, DWORD);


//2D Routing Funtions
HCHANNEL3D __stdcall xbGetChannel();
HRESULT __stdcall xbPlay3DSoundChannel(HCHANNEL3D);									
HRESULT __stdcall xbRoute2DSound(SNDHANDLE, HCHANNEL3D);


//Listener functions
HRESULT __stdcall xbSetListenerPosition(Vector);
HRESULT __stdcall xbSetListenerVelocity(Vector);
HRESULT __stdcall xbSetListenerOrientation(Vector, Vector);

//Music functions
HSTREAM __stdcall xbGetMusicStream(const char* szFileName, DWORD dwFlags);					
HRESULT __stdcall xbPlayMusic(HSTREAM);
HRESULT __stdcall xbSetMusicVolume(LONG);												
HRESULT __stdcall xbContinueMusic(HSTREAM);											//JJBUG -- TODO
HRESULT __stdcall xbFlourishMusic(HSTREAM);											//JJBUG -- TODO
HRESULT __stdcall xbStopMusic(HSTREAM);
HRESULT __stdcall xbFadeMusic(void*,LONG,DWORD);									//JJBUG -- NEED XDK UPDATE													
HRESULT __stdcall xbSetMusicRequestCallback(void WINAPI callBackFunc(HSTREAM));		
HRESULT __stdcall xbSetMusicContinueCallback(void WINAPI callBackFunc(HSTREAM));
HRESULT __stdcall xbProcess();
HRESULT __stdcall xbPauseMusic();
HRESULT __stdcall xbResumeMusic();
		
//Voice Stream functions
HVOICE  __stdcall xbPlayVoiceStream(char* szFileName, bool bDipMusic, PVOICE_INFO pVI, DWORD dwFlags);
HRESULT __stdcall xbSetVoiceVolume(LONG);
HRESULT __stdcall xbPauseVoice(void*);
HRESULT __stdcall xbResumeVoice(void*);

//Voices are 3D, music is not
HRESULT __stdcall xbSetVoicePosition(void*,Vector);
HRESULT __stdcall xbSetVoiceVelocity(void*,Vector);
HRESULT __stdcall xbSetVoiceCone(void*,DWORD,DWORD,Vector,LONG);

//Generic Stream Control
HRESULT __stdcall xbPauseAllStreams();
HRESULT __stdcall xbResumeAllStreams();


//NEED XDK UPDATE TO BE ABLE TO REALLY TEST THIS STUFF OUT
//Occlusion/Obstruction functions											
HRESULT __stdcall xbI3DClear();														//JJBUG -- TODO
HRESULT __stdcall xbI3DAddObstruction(Vector, Vector, OBSTRUCTION_TYPE);			//JJBUG -- TODO
HRESULT __stdcall xbI3DAddOcclusion(Vector, Vector, OBSTRUCTION_TYPE);				//JJBUG -- TODO
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XAudio\XAudio.h ===
#include <xtl.h>
#include <DSound.h>
#include <WinError.h>
#include <assert.h>

//Streaming #define's


// Define the maximum amount of packets we will ever submit to the renderer
#define FILESTRM_PACKET_COUNT 3

// Define the source packet size.  Because we have a transform filter that
// will expand the source data before sending it to the renderer, we have
// to maintain separate packet sizes: one for compressed and one for
// uncompressed.
//
// This value is hard-coded assuming an ADPCM block-alignment of 0x800.  If
// this ever changes, this value will need to be fixed.
#define FILESTRM_SOURCE_PACKET_BYTES 2048


// Define the renderer packet size.  See the comment block above for an
// explanation.
//
// This value is hard-coded assuming an ADPCM block alignment of 0x800 and
// stereo wave data.
#define FILESTRM_RENDER_PACKET_BYTES 8164 //-- make it mono


/*****************************************************************************************************************

	These are flags used for the dwFlags parameter in the HSOUND struct.  3DSOUND will assert that the sound is 3D,
	ISVOICE lets us know that the sound is a voice, ISMUSIC tells us if it is music, RANDOM lets us know we should
	apply random effects to the sound within a certain range, and looping tells us if the sound loops or not

******************************************************************************************************************/

#define THREEDSND	0x00000001		//Is this a 3D Sound
#define ISVOICE		0x00000002		//Is this sound a voice
#define ISMUSIC		0x00000004		//Is this sound music
#define RANDOM		0x00000008		//Determines if we are to apply a random effect within some range

#define TWOTWOKHZ	0x00000010
#define FORFORKHZ	0x00000020

#define ADPCM		0x00000100
#define WMA			0x00000200
#define PCM			0x00000400
		
#define LOOPING		0x00001000

//Masks for checking format, sample rate, & both
#define FORMAT_MASK 0x00000f00
#define SAMPLE_MASK 0x000000f0
#define BUFFER_MASK 0x00000ff0

#define FXAMPMOD		0x00002000
#define FXCHORUS		0x00004000
#define FXCOMPRESSOR	0x00008000
#define FXDISTORTION	0x00010000
#define FXECHO			0x00020000
#define FXFLANGER		0x00040000
#define FXREVERB		0x00080000


//#define's for the real-world multiples of roll-off, doppler & Distance units
#define DISTANCE	1
#define DOPPLER		1
#define ROLLOFF		1

//#define	16BIT	0x00000200
//#define 8BIT	0x00000400

//#define's for use with my handle system

#define NUMHANDLES		256
#define NUM2DSTRUCTS    32
#define NUM3DSTRUCTS	48
#define NUMCHANNELS		8

#define NUMSTREAMS		64
#define NUMVOICEHANDLES 4
#define NUMMUSICHANDLES 2

#define INVALID			-1


/*****************************************************************************************************************

	This structure is what is used to essentially keep track of sounds that are not streamed.

******************************************************************************************************************/

typedef struct _tagSoundHandle
{
	IDirectSoundBuffer8* pBuffer;
	void*				 pvData;
	DWORD				 dwFlags;
	DWORD				 dwEndTime;
} HSOUND, *PHSOUND;


/*****************************************************************************************************************

	This structure is what is used to keep track of the streamed sounds.  Music is the primary example of this,
	although this also encompasses voices.

******************************************************************************************************************/


//JJBUG-- Get the real definition of Vector from Ronin
struct Vector
{
	float x;
	float y;
	float z;
};


//This struct is passed to the xbPlayVoiceStream Function so that we know where to position the 3D Voice
typedef struct _tagVoiceInfo
{
	D3DVECTOR	pPosition;
	D3DVECTOR	pVelocity;
	
	//Cone Data
	DWORD		dwInConeAngle;
	DWORD		dwOutConeAngle;
	Vector		vConeOrientation;
	LONG		lOuterVolume;
}VOICE_INFO,*PVOICE_INFO;


typedef struct _tagMusicHandle
{
	char  szFileName[256];  //256 max char name
	DWORD dwFlags;
	int	  nID;
} SSTREAM, *HSTREAM;



typedef struct _tagStreamHandle
{                


	char				 szFileName[256];						 // Name of this wave file
	XFileMediaObject*    pSourceFilter;                          // Source (wave file) filter
    //XMediaObject*        pTransformFilter;                       // Transform (APDCM decompressor) filter
	BYTE          pvSourceBuffer[FILESTRM_SOURCE_PACKET_BYTES]; // Source filter data buffer
    BYTE          pvRenderBuffer[FILESTRM_RENDER_PACKET_BYTES*FILESTRM_PACKET_COUNT]; // Render filter data buffer
    DWORD                adwPacketStatus[FILESTRM_PACKET_COUNT]; // Packet status array
    DWORD                dwFileLength;                           // File duration, in bytes
    DWORD                dwFileProgress;						 // File progress, in bytes      
 
	IDirectSoundStream*  pRenderFilter;							 // Render (DirectSoundStream) filter

	//Can we use the dwFileProgress?  Queue up the next piece when the piece is >= 75% done? (~2 second buffer to load the next piece)
	bool				 bPlaying;
	bool				 bDone;
	HSTREAM				 hsRef;		// Reference to the handle that this represents
	LONG				 lVol;		//Volume
	DWORD				 dwFlags;	//Flags
} SMUSIC, *HMUSIC;
	
//Voice & Music streams require the same info...but use it slightly differently
#define HVOICE HMUSIC


typedef struct _tagSndHandle
{
	void*		pvData;
	int			nID;
	DWORD		dwFlags;
	DWORD		dwBufSiz;

///////////3 D Data
	D3DVECTOR	pPosition;
	D3DVECTOR	pVelocity;
	
	//Cone Data
	DWORD		dwInConeAngle;
	DWORD		dwOutConeAngle;
	Vector		vConeOrientation;
	LONG		lOuterVolume;
///////////End 3D Data
		
	LONG		lVolume;		//Current volume

}SNDSTRUCT, *SNDHANDLE;

#define HCHANNEL3D SNDHANDLE	//Really the same thing...except that the void* parameter doesn't matter

enum OBSTRUCTION_TYPE;			//JJBUG-- Figure out what obstruction types we need after talking w/ Ronin



//////////////////////////////////////////////WMA STUFF/////////////////////////////////////////////////////////////
//Taken from the XBOX sample...
//
// Linked list structure for tracking our media packet contexts
//
struct LINKED_LIST 
{
    LINKED_LIST* pNext;
    LINKED_LIST* pPrev;

    inline VOID Initialize()         { pNext = pPrev = this; }
    inline BOOL IsListEmpty()        { return pNext == this; }
    inline LINKED_LIST* RemoveHead() { pNext->Remove(); }
    inline LINKED_LIST* RemoveTail() { pPrev->Remove(); }

    inline VOID Remove() 
    {
        LINKED_LIST* pOldNext = pNext;
        LINKED_LIST* pOldPrev = pPrev;
        pOldPrev->pNext = pOldNext;
        pOldNext->pPrev = pOldPrev;
    }

    inline VOID Add( LINKED_LIST* pEntry ) 
    {
        LINKED_LIST* pOldHead = this;
        LINKED_LIST* pOldPrev = this->pPrev;
        pEntry->pNext   = pOldHead;
        pEntry->pPrev   = pOldPrev;
        pOldPrev->pNext = pEntry;
        pOldHead->pPrev = pEntry;
    }
};


//WMA STUFF
#define PACKET_CNT      4
#define PACKET_SIZE     0x1000*2
#define MAXBUFSIZE      (PACKET_SIZE*PACKET_CNT)

// This structure keeps track of our packet status, buffer data, etc.
struct MEDIA_PACKET_CTX
{
    LINKED_LIST ListEntry;
    DWORD       dwStatus;
    DWORD       dwCompletedSize;
    BYTE*       pBuffer;
};


//-----------------------------------------------------------------------------
// Name: class XFilterGraph
//
// Desc: Main class to run this application. Most functionality is inherited
//       from the CXBApplication base class.
//-----------------------------------------------------------------------------
class CFilterGraph //: public CXBApplication
{
public:
    XFileMediaObject* m_pSourceXMO;         // Source XMO - the WMA file
//    XMediaObject* m_pIntermediateXMO;       // Intermediate XMO - Echo filter
    XMediaObject* m_pTargetXMO;             // Target XMO - DSound

    DWORD         m_dwSourceLength;         // Size of source
    DWORD         m_dwBytesRead;            // Bytes of stream processed

    DWORD         m_dwMinPacketSize;        // For verifying our packet size
    DWORD         m_dwPacketSize;           // Packet size
    DWORD         m_dwMaxBufferCount;       // # of buffers

    WAVEFORMATEX  m_wfxAudioFormat;         // Audio format

    LINKED_LIST   m_SourcePendingList;      // Media Contexts in source list
    LINKED_LIST   m_TargetPendingList;      // Media Contexts in target list

    BYTE		  m_pTransferBuffer[MAXBUFSIZE];        // Buffer data
    BYTE          m_pPacketContextPool[PACKET_CNT * sizeof(MEDIA_PACKET_CTX)];     // Packet contexts

	DWORD		  m_dwPercentCompleted;
	DWORD		  dwFlags;
	HSTREAM		  hsRef;					// Reference to the handle that this represents
	//  CXBFont       m_Font;               // Font renderer

    HRESULT        m_hOpenResult;           // Error code from WMAStream::Initialize()

	bool		  bPlaying;					// Is this a currently active stream
	LONG		  lVol;
    // Virtual calls from CXBApplication
    virtual HRESULT Initialize(char*);
    virtual HRESULT FrameMove();
    virtual HRESULT Cleanup();

    // These functions attach a media context packet to an XMO by 
    // setting up the XMEDIAPACKET struct, calling Process(), and
    // then adding our media packet context to the appropriate list
    HRESULT AttachPacketToSourceXMO( MEDIA_PACKET_CTX* pCtx );
    HRESULT AttachPacketToTargetXMO( MEDIA_PACKET_CTX* pCtx );

    // Handles transferring packets through our filter graph
    HRESULT TransferData();
};




//////////////////////////////////////////////END WMA STUFF/////////////////////////////////////////////////////////////


//Globals:

IDirectSound8* g_pDSnd;
SNDSTRUCT	   g_HandleTable[NUMHANDLES];		//Handles for sound effects
SNDSTRUCT	   g_ChannelTable[NUMCHANNELS];		//Array of actual channels allocated for routing
HSOUND		   g_SndArr[NUM3DSTRUCTS];			//Array of actual sound structures for 3D Sfx
HSOUND		   g_2DSndArr[NUM2DSTRUCTS];		//Array of actual sound structures for 2D Sfx
SMUSIC		   g_MusicArr[NUMMUSICHANDLES];		//Array of actual Music structures
SMUSIC		   g_VoiceArr[NUMVOICEHANDLES];		//Array of actual Voice structures
SSTREAM 	   g_StreamArr[NUMSTREAMS];			//Handles for Music
CFilterGraph   g_WMAStream;						//Our only WMA Stream
LONG		   g_lMusicVol;						//Music Volume
LONG		   g_lVoiceVol;						//Voice Volume
LONG		   g_lDipVol;						//Old Music volume for restoring after the dip...
bool		   g_bVoicePause;					//Are voices paused?
bool		   g_bMusicPause;					//Is the music paused?

//Should the callbacks be global or on a per-Handle basis??
void (WINAPI* g_pRequestFunc)(void*);			//Request Callback
void (WINAPI* g_pContinueFunc)(void*);			//Continue Callback

DS3DLISTENER   g_Listener;						//JJBUG -- Do we even need this?

//Counters for Handles
int			   g_SNDID3D;
int			   g_SNDID2D;
int			   g_MUSICCNT;
int			   g_nVoiceCnt;						//Number of voices currently playing

//Functions

//Regular sound functions
HRESULT __stdcall xbInitAudio();
HRESULT __stdcall xbUninitAudio();												//JJBUG -- TODO- Necessary?
void*   __stdcall xbGetHandle(void*, DWORD, DWORD);
HRESULT __stdcall xbPlaySound(void*, bool);								
HRESULT __stdcall xbStopSound(void*);				
HRESULT __stdcall xbSetVolume(void*, LONG);
HRESULT __stdcall xbSetConeOuterVolume(void*, LONG);	
HRESULT __stdcall xbFadeVolume(void*,LONG,LONG);								//JJBUG -- XDK/HARDWARE
HRESULT __stdcall xbSet2DPan(void*, LONG);										//JJBUG -- NEED XDK Update
HRESULT __stdcall xbFade2DPan(void*, LONG, LONG);								//JJBUG -- NEED XDK Update
HRESULT __stdcall xbSet3DPosition(void*, Vector);									
HRESULT __stdcall xbSet3DVelocity(void*, Vector);									
HRESULT __stdcall xbSet3DCone(void*,DWORD,DWORD,Vector,LONG);
HRESULT __stdcall xbGetFlags(void*, DWORD*);
HRESULT __stdcall xbSetFlags(void*, DWORD);
HRESULT __stdcall xbIsSoundPlaying(void*, bool*);		

//FX Functions
HRESULT __stdcall xbCreateFX(DWORD);											//JJBUG -- XDK/HARDWARE
HRESULT __stdcall xbDeleteFX(DWORD);											//JJBUG -- XDK/HARDWARE
HRESULT __stdcall xbApplyFX(void* DWORD);										//JJBUG -- XDK/HARDWARE

//2D routing to 3D
void*	__stdcall xbGetChannel();												//UNTESTED
HRESULT __stdcall xbPlay3DSoundChannel(HCHANNEL3D);								//UNTESTED
HRESULT __stdcall xbRoute2DSound(void*, HCHANNEL3D);							//UNTESTED

//Listener functions
HRESULT __stdcall xbSetListenerPosition(Vector);
HRESULT __stdcall xbSetListenerVelocity(Vector);
HRESULT __stdcall xbSetListenerOrientation(Vector, Vector);

//Music functions
void*   __stdcall xbGetMusicStream(const char* szFileName, DWORD dwFlags);					
HRESULT __stdcall xbPlayMusic(void*);
HRESULT __stdcall xbSetMusicVolume(LONG);												
HRESULT __stdcall xbContinueMusic(void*);											
HRESULT __stdcall xbFlourishMusic(void*);
HRESULT __stdcall xbStopMusic(void*);
HRESULT __stdcall xbFadeMusic(void*,LONG);										  //JJBUG -- NEED XDK UPDATE				
HRESULT __stdcall xbSetMusicRequestCallback(void WINAPI callBackFunc(void*));		
HRESULT __stdcall xbSetMusicContinueCallback(void WINAPI callBackFunc(void*));
HRESULT __stdcall xbProcess();
HRESULT __stdcall xbPauseMusic();
HRESULT __stdcall xbResumeMusic();
		
//Voice Stream function
void*   __stdcall xbPlayVoiceStream(char* szFileName, bool bDipMusic, PVOICE_INFO pVI, DWORD dwFlags);
HRESULT __stdcall xbSetVoiceVolume(LONG);
HRESULT __stdcall xbPauseVoice(void*);
HRESULT __stdcall xbResumeVoice(void*);

//Voices are 3D, music is not
HRESULT __stdcall xbSetVoicePosition(void*,Vector);
HRESULT __stdcall xbSetVoiceVelocity(void*,Vector);
HRESULT __stdcall xbSetVoiceCone(void*,DWORD,DWORD,Vector,LONG); //Is this necessary?

//Generic Stream Control
HRESULT __stdcall xbPauseAllStreams();
HRESULT __stdcall xbResumeAllStreams();

//NEED XDK UPDATE TO BE ABLE TO REALLY TEST THIS STUFF OUT
//Occlusion/Obstruction functions											
HRESULT __stdcall xbI3DClear();														//JJBUG -- TODO
HRESULT __stdcall xbI3DAddObstruction(Vector, Vector, OBSTRUCTION_TYPE);			//JJBUG -- TODO
HRESULT __stdcall xbI3DAddOcclusion(Vector, Vector, OBSTRUCTION_TYPE);				//JJBUG -- TODO



//Generic Internal Utility functions
PHSOUND SoundFromHandle(SNDHANDLE);

//Stream API Utility Functions
HRESULT __stdcall InitChannels();
void InitStreams();
int GetFreeStream();
HVOICE GetVoiceStream();
HRESULT InitStream(const CHAR*, HMUSIC, DWORD);
HRESULT Process(DWORD*, HMUSIC);
BOOL FindFreePacket(DWORD*, HMUSIC);
HRESULT ProcessSource(HMUSIC);
HRESULT ProcessTransform(DWORD, HMUSIC);
HRESULT ProcessRenderer(DWORD, HMUSIC);
HSTREAM GetCurrentMusic();
HRESULT DownloadScratch(IDirectSound8* pDSnd,PCHAR pszScratchFile);
void __stdcall VoiceDone();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xdvdplay\pch.cpp ===
#define INITGUID

#include <streams.h>
#include <windows.h>
#include <dvdevcod.h>
#include <il21dec.h>

#include "xdvdplay.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XDIFile\XDIFile.h ===
#pragma once

#ifdef _XBOX
    #include <xtl.h>
#else
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
#endif

//
//Major/Minor version numbers
//
#define VERMAJOR   1L
#define VERMINOR   3L

#define DIBFLAGS_MOVIE		 0x00000001
#define DIBGLAGS_MOVIETEASER 0x00000100
#define DIBFLAGS_KIOSK		 0x00010000

#define nMAX_STRINGLEN 128

#pragma warning(push)
#pragma warning(disable : 4200)  //zero-size array in class
#pragma pack(1)
//
//Demo information block
//
class DIB
{
public:
	union 
    {
	    DWORD m_dwSize;
		DIB  *m_pNext;
	};

    DWORD m_dwFlags;
    DWORD m_dwPriority;
	char *m_pszTitle;
	char *m_pszFolder;
    char *m_pszXBE;
	char *m_pszTeaser;
    char *m_pszPersist;
	char *m_pszAddi;
    char *m_pszAuthor;
    char *m_pszDemoType;
	BYTE  m_data[];
};

#pragma warning(pop)

class XDIHEADER
{
public:
    BYTE m_bSignature[3];
    BYTE m_bPadding;
    LONG m_lVerMajor;
    LONG m_lVerMinor;
    LONG m_lNumDemos;
	LONG m_lCheckSum;
    BOOL m_fKiosk;
    char m_szGameName[nMAX_STRINGLEN];
    char m_szPersist[nMAX_STRINGLEN];

    XDIHEADER() 
    {
        m_bSignature[0] = 'X';
        m_bSignature[1] = 'D';
        m_bSignature[2] = 'I';
        m_lVerMajor = VERMAJOR;
        m_lVerMinor = VERMINOR;
        m_lNumDemos = 0L;
		m_lCheckSum = 0L;
        *m_szGameName = '\0';
        *m_szPersist = '\0';
    };
};
#pragma pack()

int VerifyContents(BYTE *pbDemos, DWORD dwFileSize);
void WriteChecksum(HANDLE hFile);

//
//headers for functions exported by XDIFile.dll
//

#ifdef _XBOX
    DWORD XDIReadFile(const char *pszXDIFile, void *pvDemos, DWORD dwFileSize);
#else
    extern "C"
    {
        _declspec(dllexport) long __stdcall XDIGetDllVersion(void);
        _declspec(dllexport) long __stdcall XDIGetDemoHeader(char *pszXDIFile, XDIHEADER *pxdi);
        _declspec(dllexport) long __stdcall XDIGetDemoInfo(char *pszXDIFile, DIB *pdib, LONG lIdx);
        _declspec(dllexport) long __stdcall XDIWriteDemoInfo(char *pszXDIFile, DIB *pdib);
        _declspec(dllexport) long __stdcall XDIWriteHeader(LPSTR pszXDIFile, LONG lNumDemos, LONG lKiosk,
                                                           char *pszCallingXBE, char *pszPersist);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDIFile\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by XDIFile.Rc
//
#define IDS_DEMO                        1
#define IDS_MOVIE                       2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDemos\XDIFile\XDIFile.cpp ===
#include "XDIFile.h"
#include <assert.h>

BOOL VerifyContents(BYTE *pbDemos, DWORD dwFileSize)
{
	LONG lCheckSum = 0;
	LONG lStoredCheckSum = ((XDIHEADER *) pbDemos)->m_lCheckSum;

	//zero out checksum for computation...
	((XDIHEADER *) pbDemos)->m_lCheckSum = 0L;

	while (dwFileSize--)
	{
		lCheckSum = lCheckSum + (((DWORD) *pbDemos + dwFileSize) % ((DWORD) *pbDemos + 1));
		pbDemos++;
	}

	return lCheckSum == lStoredCheckSum;
}

void WriteChecksum(HANDLE hFile)
{
	DWORD  dwFileSize;
	DWORD  dwNum;
	LONG   lCheckSum = 0;
	BYTE   *pbDemos;
	BYTE   *pbPtr;
	XDIHEADER *pxdi;
	
	FlushFileBuffers(hFile);
	dwFileSize = GetFileSize(hFile, NULL);
	
	pbDemos = (BYTE *) new BYTE[dwFileSize];
	if (pbDemos)
	{
		pxdi = (XDIHEADER *) pbDemos;
		
		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
		ReadFile(hFile, pbDemos, dwFileSize, &dwNum, NULL);
		
		if (dwFileSize == dwNum && dwFileSize >= sizeof(XDIHEADER))
		{
			//zero out checksum for computation...
			pxdi->m_lCheckSum = 0L;
			
			pbPtr = pbDemos;
			while (dwFileSize--)
			{
				lCheckSum = lCheckSum + (((DWORD) *pbPtr + dwFileSize) % ((DWORD) *pbPtr + 1));
				pbPtr++;
			}
			
			pxdi->m_lCheckSum = lCheckSum;
			
			SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
			
			WriteFile(hFile, pxdi, sizeof(XDIHEADER), &dwNum, NULL);
		}
		
		delete pbDemos;
	}
}

#ifdef _XBOX

// MJL 7/16/2001: for fixing up pointers
#define FIXUP(pointer, offset) (*(int *)(&(pointer))) += (*(int *)(&(offset)))

//
//Change byte offsets in DIB struct to pointers to actual data in m_data section
//
static void FixupXDIBlob(void *pvDemos)
{
    DIB       *pdib;
    LONG     lNumDemos = 0;

    lNumDemos = ((XDIHEADER *) pvDemos)->m_lNumDemos;

    //
    //Point past header to first XDI entry
    //
    pdib = (DIB *) ((BYTE *) pvDemos + sizeof(XDIHEADER));

    while (lNumDemos--)
    {
        //
        //Transform size into a pointer to the next demo info block
        //
        pdib->m_pNext = lNumDemos ? (DIB *) ((BYTE *) pdib + pdib->m_dwSize) : NULL;

        FIXUP(pdib->m_pszTitle,		pdib);
        FIXUP(pdib->m_pszFolder,	pdib);
        FIXUP(pdib->m_pszXBE,		pdib);
        FIXUP(pdib->m_pszTeaser,	pdib);
        FIXUP(pdib->m_pszAuthor,	pdib);
        FIXUP(pdib->m_pszDemoType,	pdib);

        if ((DWORD) -1 != (DWORD) pdib->m_pszPersist)
        {
            FIXUP(pdib->m_pszPersist, pdib);
        }
        else
        {
            pdib->m_pszPersist = NULL;
        }

        if ((DWORD) -1 != (DWORD) pdib->m_pszAddi)
        {
            FIXUP(pdib->m_pszAddi, pdib);
        }
        else
        {
            pdib->m_pszAddi = NULL;
        }

        pdib = (DIB *) pdib->m_pNext;
    }
}

DWORD XDIReadFile(const char *pszXDIFile, void *pvDemos, DWORD dwFileSize)
{
    HANDLE hFile;
    DWORD  dwNumRead;
    LONG   dwRc = -1;

    assert(pszXDIFile);
    assert(pvDemos || (dwFileSize==0));

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
		// MJL 7/16/2001
		// Helper to get file size
		if (pvDemos == NULL)
		{
			dwRc = GetFileSize(hFile, NULL);
	        CloseHandle(hFile);
			return dwRc;
		}

        if (ReadFile(hFile, pvDemos, dwFileSize, &dwNumRead, NULL))
        {
			if (dwFileSize == dwNumRead && VerifyContents((BYTE *) pvDemos, dwFileSize))
			{
	            dwRc = dwNumRead;
	            FixupXDIBlob(pvDemos);
			}
        }

        CloseHandle(hFile);
    }

    return dwRc;
}

#else

//
//Functions in here are called from the XDIGen Visual Basic app...
//

#include "resource.h"

BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    return TRUE;
}

_declspec(dllexport) long __stdcall XDIGetDllVersion(void)
{
    return MAKELONG(VERMINOR, VERMAJOR);
}

//
//Get the lIdx-th demo info
//
_declspec(dllexport) long __stdcall XDIGetDemoInfo(char *pszXDIFile, DIB *pdib, LONG lIdx)
{
    HANDLE hFile;
    DWORD  dwNumRead;
    DWORD  dwSize;
    BOOL   fOK;
    DIB    *pReadDib = NULL;
    XDIHEADER xdi;

    assert(pszXDIFile);
    assert(pdib);

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (fOK = (INVALID_HANDLE_VALUE != hFile))
    {
        //
        //Read past header...
        //
        fOK = ReadFile(hFile, (XDIHEADER *) &xdi, sizeof(XDIHEADER), &dwNumRead, NULL);

        //
        //Loop while no read errors and until we have the desired demo information block
        //
        while (fOK && lIdx--)
        {
            fOK = FALSE;

            //
            //If we allocated memory last loop, free it before allocating new after ReadFile below
            //
            if (pReadDib)
            {
                delete pReadDib;
                pReadDib = NULL;
            }

            //
            //Read just the size of the demo info
            //
            if (ReadFile(hFile, &dwSize, sizeof(DWORD), &dwNumRead, NULL))
            {
                assert(sizeof(DWORD) == dwNumRead);

                //
                //Now allocate a new DIB that is the size specified
                //
                pReadDib = (DIB *) new BYTE[dwSize];

                //
                //Read the demo information as it was written to file, don't read the size because the file
                //seek pointer is already set just beyond that because of read above
                //
                if (pReadDib && ReadFile(hFile, (BYTE *) pReadDib + sizeof(DWORD), dwSize - sizeof(DWORD), &dwNumRead, NULL))
                {
                    assert(dwSize - sizeof(DWORD) == dwNumRead);

                    fOK = TRUE;
                }
            }
        }

        if (fOK)
        {
            pdib->m_dwSize = dwSize;
            pdib->m_dwFlags = pReadDib->m_dwFlags;
            pdib->m_dwPriority = pReadDib->m_dwPriority;

            //
            //Memory was preallocated in Visual Basic for the pdib strings.  Copy the relevant strings
            //from the m_data blob into the stucture for passing back to VB.
            //
            lstrcpy(pdib->m_pszTitle, (char *) pReadDib + (DWORD) pReadDib->m_pszTitle);
            lstrcpy(pdib->m_pszFolder, (char *) pReadDib + (DWORD) pReadDib->m_pszFolder);
            lstrcpy(pdib->m_pszXBE, (char *) pReadDib + (DWORD) pReadDib->m_pszXBE);
            lstrcpy(pdib->m_pszTeaser, (char *) pReadDib + (DWORD) pReadDib->m_pszTeaser);
            lstrcpy(pdib->m_pszAuthor, (char *) pReadDib + (DWORD) pReadDib->m_pszAuthor);

            if ((DWORD) -1 != (DWORD) pReadDib->m_pszPersist)
            {
                lstrcpy(pdib->m_pszPersist, (char *) pReadDib + (DWORD) pReadDib->m_pszPersist);
            }
            else
            {
                lstrcpy(pdib->m_pszPersist, "");
            }

            if ((DWORD) -1 != (DWORD) pReadDib->m_pszAddi)
            {
                lstrcpy(pdib->m_pszAddi, (char *) pReadDib + (DWORD) pReadDib->m_pszAddi);
            }
            else
            {
                lstrcpy(pdib->m_pszAddi, "");
            }
        }

        if (pReadDib)
        {
            delete pReadDib;
        }

        CloseHandle(hFile);
    }

    return fOK;
}

_declspec(dllexport) long __stdcall XDIGetDemoHeader(char *pszXDIFile, XDIHEADER *pxdi)
{
    HANDLE hFile;
    DWORD dwNumRead;
	DWORD dwFileSize;
    XDIHEADER *pxdiRead;
    BOOL  fRc = FALSE;

    assert(pszXDIFile);
    assert(pxdi);

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
		dwFileSize = GetFileSize(hFile, NULL);
		BYTE *pbDemos = (BYTE *) new BYTE[dwFileSize];

        fRc = pbDemos && ReadFile(hFile, pbDemos, dwFileSize, &dwNumRead, NULL);

		if (fRc && dwFileSize == dwNumRead && VerifyContents(pbDemos, dwFileSize))
		{
			pxdiRead = (XDIHEADER *) pbDemos;

			pxdi->m_lNumDemos = pxdiRead->m_lNumDemos;
			pxdi->m_fKiosk = pxdiRead->m_fKiosk;
			pxdi->m_lVerMajor = pxdiRead->m_lVerMajor;
			pxdi->m_lVerMinor = pxdiRead->m_lVerMinor;
			lstrcpy(pxdi->m_szGameName, pxdiRead->m_szGameName);
			lstrcpy(pxdi->m_szPersist, pxdiRead->m_szPersist);
		}
		else
		{
			fRc = FALSE;
		}

		delete pbDemos;
        CloseHandle(hFile);
    }

    return (LONG) (INVALID_HANDLE_VALUE != hFile && fRc);
}

//
//Write the header info with the number of demos that is passed in from visual basic
//
_declspec(dllexport) long __stdcall XDIWriteHeader(LPSTR pszXDIFile, 
                                                   LONG lNumDemos, 
                                                   LONG lKiosk,
                                                   char *pszCallingXBE, 
                                                   char *pszPersist)
{
    HANDLE hFile;
    XDIHEADER xdi;
    DWORD dwNumWritten;
    BOOL  fRc = FALSE;

    xdi.m_lNumDemos = lNumDemos;
    xdi.m_fKiosk = lKiosk;
    xdi.m_lVerMajor = VERMAJOR;
    xdi.m_lVerMinor = VERMINOR;
    lstrcpy(xdi.m_szGameName, pszCallingXBE);
    lstrcpy(xdi.m_szPersist, pszPersist);

    //
    //Always recreate the file when writing the header
    //
	hFile = CreateFile(pszXDIFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, 
					   CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        fRc = WriteFile(hFile, &xdi, sizeof(XDIHEADER), &dwNumWritten, NULL);

        if (sizeof(XDIHEADER) == dwNumWritten)
		{
			WriteChecksum(hFile);
		}

        CloseHandle(hFile);
    }

    return (LONG) (INVALID_HANDLE_VALUE != hFile && fRc);
}

//
//Write the next demo info, appended to the end of the file
//
_declspec(dllexport) long __stdcall XDIWriteDemoInfo(char *pszXDIFile, DIB *pdib)
{
    HANDLE hFile;
    DWORD dwNumWritten;
    DIB   *pNewDib;
    char  szDemoType[nMAX_STRINGLEN];

    //
    //Find the handle to this dll (XDIDll.Dll) and load the descriptive demo type string from the string table
    //
    HMODULE hDll = GetModuleHandle("XDIDll");
    LoadString(hDll, pdib->m_dwFlags & DIBFLAGS_MOVIE ? IDS_MOVIE : IDS_DEMO, szDemoType, nMAX_STRINGLEN);

    //
    //Calculate size of this demo information block, include space for trailing zeros
    //
    pdib->m_dwSize = sizeof(DIB) + lstrlen(pdib->m_pszTitle) + 1 +
                                   lstrlen(pdib->m_pszFolder) + 1 +
                                   lstrlen(pdib->m_pszXBE) + 1 + 
                                   lstrlen(pdib->m_pszTeaser) + 1 +
                                   lstrlen(pdib->m_pszPersist) + 1 +
                                   lstrlen(pdib->m_pszAddi) + 1 +
                                   lstrlen(pdib->m_pszAuthor) + 1 +
                                   lstrlen(szDemoType) + 1;

    //
    //Allocate space for the DIB, and copy the parameter dib into it
    //
    pNewDib = (DIB *) new BYTE[pdib->m_dwSize];
	if (NULL == pNewDib)
	{
		return 0L;
	}

    CopyMemory(pNewDib, pdib, sizeof(DIB));

    char *pPtr = (char *) &pNewDib->m_data;
    ZeroMemory(pPtr, pNewDib->m_dwSize - sizeof(DIB));

    lstrcpy(pPtr, pNewDib->m_pszTitle);
    pNewDib->m_pszTitle = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszFolder);
    pNewDib->m_pszFolder = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszXBE);
    pNewDib->m_pszXBE = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszTeaser);
    pNewDib->m_pszTeaser = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszPersist);
    pNewDib->m_pszPersist = *pNewDib->m_pszPersist ? (char *) (pPtr - (char *) pNewDib) : (char *) -1;
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszAddi);
    pNewDib->m_pszAddi = *pNewDib->m_pszAddi ? (char *) (pPtr - (char *) pNewDib) : (char *) -1;
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszAuthor);
    pNewDib->m_pszAuthor = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, szDemoType);
    pNewDib->m_pszDemoType = (char *) (pPtr - (char *) pNewDib);

    //
    //We OPEN_EXISTING, because a call to XDIWriteHeader took place before this call
    //
	hFile = CreateFile(pszXDIFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, pNewDib, pNewDib->m_dwSize, &dwNumWritten, NULL);

        if (pNewDib->m_dwSize == dwNumWritten)
		{
			WriteChecksum(hFile);
		}

        CloseHandle(hFile);
    }

	delete pNewDib;
    return (LONG) (INVALID_HANDLE_VALUE != hFile);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDIFile\XDIFile.cpp ===
#include "XDIFile.h"
#include <assert.h>

BOOL VerifyContents(BYTE *pbDemos, DWORD dwFileSize)
{
	LONG lCheckSum = 0;
	LONG lStoredCheckSum = ((XDIHEADER *) pbDemos)->m_lCheckSum;

	//zero out checksum for computation...
	((XDIHEADER *) pbDemos)->m_lCheckSum = 0L;

	while (dwFileSize--)
	{
		lCheckSum = lCheckSum + (((DWORD) *pbDemos + dwFileSize) % ((DWORD) *pbDemos + 1));
		pbDemos++;
	}

	return lCheckSum == lStoredCheckSum;
}

void WriteChecksum(HANDLE hFile)
{
	DWORD  dwFileSize;
	DWORD  dwNum;
	LONG   lCheckSum = 0;
	BYTE   *pbDemos;
	BYTE   *pbPtr;
	XDIHEADER *pxdi;
	
	FlushFileBuffers(hFile);
	dwFileSize = GetFileSize(hFile, NULL);
	
	pbDemos = (BYTE *) new BYTE[dwFileSize];
	if (pbDemos)
	{
		pxdi = (XDIHEADER *) pbDemos;
		
		SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
		ReadFile(hFile, pbDemos, dwFileSize, &dwNum, NULL);
		
		if (dwFileSize == dwNum && dwFileSize >= sizeof(XDIHEADER))
		{
			//zero out checksum for computation...
			pxdi->m_lCheckSum = 0L;
			
			pbPtr = pbDemos;
			while (dwFileSize--)
			{
				lCheckSum = lCheckSum + (((DWORD) *pbPtr + dwFileSize) % ((DWORD) *pbPtr + 1));
				pbPtr++;
			}
			
			pxdi->m_lCheckSum = lCheckSum;
			
			SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
			
			WriteFile(hFile, pxdi, sizeof(XDIHEADER), &dwNum, NULL);
		}
		
		delete pbDemos;
	}
}

#ifdef _XBOX

// MJL 7/16/2001: for fixing up pointers
#define FIXUP(pointer, offset) (*(int *)(&(pointer))) += (*(int *)(&(offset)))

//
//Change byte offsets in DIB struct to pointers to actual data in m_data section
//
static void FixupXDIBlob(void *pvDemos)
{
    DIB       *pdib;
    LONG     lNumDemos = 0;

    lNumDemos = ((XDIHEADER *) pvDemos)->m_lNumDemos;

    //
    //Point past header to first XDI entry
    //
    pdib = (DIB *) ((BYTE *) pvDemos + sizeof(XDIHEADER));

    while (lNumDemos--)
    {
        //
        //Transform size into a pointer to the next demo info block
        //
        pdib->m_pNext = lNumDemos ? (DIB *) ((BYTE *) pdib + pdib->m_dwSize) : NULL;

        FIXUP(pdib->m_pszTitle,		pdib);
        FIXUP(pdib->m_pszFolder,	pdib);
        FIXUP(pdib->m_pszXBE,		pdib);
        FIXUP(pdib->m_pszTeaser,	pdib);
        FIXUP(pdib->m_pszAuthor,	pdib);
        FIXUP(pdib->m_pszDemoType,	pdib);

        if ((DWORD) -1 != (DWORD) pdib->m_pszPersist)
        {
            FIXUP(pdib->m_pszPersist, pdib);
        }
        else
        {
            pdib->m_pszPersist = NULL;
        }

        if ((DWORD) -1 != (DWORD) pdib->m_pszAddi)
        {
            FIXUP(pdib->m_pszAddi, pdib);
        }
        else
        {
            pdib->m_pszAddi = NULL;
        }

        pdib = (DIB *) pdib->m_pNext;
    }
}

DWORD XDIReadFile(const char *pszXDIFile, void *pvDemos, DWORD dwFileSize)
{
    HANDLE hFile;
    DWORD  dwNumRead;
    LONG   dwRc = -1;

    assert(pszXDIFile);
    assert(pvDemos || (dwFileSize==0));

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
		// MJL 7/16/2001
		// Helper to get file size
		if (pvDemos == NULL)
		{
			dwRc = GetFileSize(hFile, NULL);
	        CloseHandle(hFile);
			return dwRc;
		}

        if (ReadFile(hFile, pvDemos, dwFileSize, &dwNumRead, NULL))
        {
			if (dwFileSize == dwNumRead && VerifyContents((BYTE *) pvDemos, dwFileSize))
			{
	            dwRc = dwNumRead;
	            FixupXDIBlob(pvDemos);
			}
        }

        CloseHandle(hFile);
    }

    return dwRc;
}

#else

//
//Functions in here are called from the XDIGen Visual Basic app...
//

#include "resource.h"

BOOL APIENTRY DllMain(HANDLE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    return TRUE;
}

_declspec(dllexport) long __stdcall XDIGetDllVersion(void)
{
    return MAKELONG(VERMINOR, VERMAJOR);
}

//
//Get the lIdx-th demo info
//
_declspec(dllexport) long __stdcall XDIGetDemoInfo(char *pszXDIFile, DIB *pdib, LONG lIdx)
{
    HANDLE hFile;
    DWORD  dwNumRead;
    DWORD  dwSize;
    BOOL   fOK;
    DIB    *pReadDib = NULL;
    XDIHEADER xdi;

    assert(pszXDIFile);
    assert(pdib);

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (fOK = (INVALID_HANDLE_VALUE != hFile))
    {
        //
        //Read past header...
        //
        fOK = ReadFile(hFile, (XDIHEADER *) &xdi, sizeof(XDIHEADER), &dwNumRead, NULL);

        //
        //Loop while no read errors and until we have the desired demo information block
        //
        while (fOK && lIdx--)
        {
            fOK = FALSE;

            //
            //If we allocated memory last loop, free it before allocating new after ReadFile below
            //
            if (pReadDib)
            {
                delete pReadDib;
                pReadDib = NULL;
            }

            //
            //Read just the size of the demo info
            //
            if (ReadFile(hFile, &dwSize, sizeof(DWORD), &dwNumRead, NULL))
            {
                assert(sizeof(DWORD) == dwNumRead);

                //
                //Now allocate a new DIB that is the size specified
                //
                pReadDib = (DIB *) new BYTE[dwSize];

                //
                //Read the demo information as it was written to file, don't read the size because the file
                //seek pointer is already set just beyond that because of read above
                //
                if (pReadDib && ReadFile(hFile, (BYTE *) pReadDib + sizeof(DWORD), dwSize - sizeof(DWORD), &dwNumRead, NULL))
                {
                    assert(dwSize - sizeof(DWORD) == dwNumRead);

                    fOK = TRUE;
                }
            }
        }

        if (fOK)
        {
            pdib->m_dwSize = dwSize;
            pdib->m_dwFlags = pReadDib->m_dwFlags;
            pdib->m_dwPriority = pReadDib->m_dwPriority;

            //
            //Memory was preallocated in Visual Basic for the pdib strings.  Copy the relevant strings
            //from the m_data blob into the stucture for passing back to VB.
            //
            lstrcpy(pdib->m_pszTitle, (char *) pReadDib + (DWORD) pReadDib->m_pszTitle);
            lstrcpy(pdib->m_pszFolder, (char *) pReadDib + (DWORD) pReadDib->m_pszFolder);
            lstrcpy(pdib->m_pszXBE, (char *) pReadDib + (DWORD) pReadDib->m_pszXBE);
            lstrcpy(pdib->m_pszTeaser, (char *) pReadDib + (DWORD) pReadDib->m_pszTeaser);
            lstrcpy(pdib->m_pszAuthor, (char *) pReadDib + (DWORD) pReadDib->m_pszAuthor);

            if ((DWORD) -1 != (DWORD) pReadDib->m_pszPersist)
            {
                lstrcpy(pdib->m_pszPersist, (char *) pReadDib + (DWORD) pReadDib->m_pszPersist);
            }
            else
            {
                lstrcpy(pdib->m_pszPersist, "");
            }

            if ((DWORD) -1 != (DWORD) pReadDib->m_pszAddi)
            {
                lstrcpy(pdib->m_pszAddi, (char *) pReadDib + (DWORD) pReadDib->m_pszAddi);
            }
            else
            {
                lstrcpy(pdib->m_pszAddi, "");
            }
        }

        if (pReadDib)
        {
            delete pReadDib;
        }

        CloseHandle(hFile);
    }

    return fOK;
}

_declspec(dllexport) long __stdcall XDIGetDemoHeader(char *pszXDIFile, XDIHEADER *pxdi)
{
    HANDLE hFile;
    DWORD dwNumRead;
	DWORD dwFileSize;
    XDIHEADER *pxdiRead;
    BOOL  fRc = FALSE;

    assert(pszXDIFile);
    assert(pxdi);

	hFile = CreateFile(pszXDIFile, GENERIC_READ, FILE_SHARE_READ, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
		dwFileSize = GetFileSize(hFile, NULL);
		BYTE *pbDemos = (BYTE *) new BYTE[dwFileSize];

        fRc = pbDemos && ReadFile(hFile, pbDemos, dwFileSize, &dwNumRead, NULL);

		if (fRc && dwFileSize == dwNumRead && VerifyContents(pbDemos, dwFileSize))
		{
			pxdiRead = (XDIHEADER *) pbDemos;

			pxdi->m_lNumDemos = pxdiRead->m_lNumDemos;
			pxdi->m_fKiosk = pxdiRead->m_fKiosk;
			pxdi->m_lVerMajor = pxdiRead->m_lVerMajor;
			pxdi->m_lVerMinor = pxdiRead->m_lVerMinor;
			lstrcpy(pxdi->m_szGameName, pxdiRead->m_szGameName);
			lstrcpy(pxdi->m_szPersist, pxdiRead->m_szPersist);
		}
		else
		{
			fRc = FALSE;
		}

		delete pbDemos;
        CloseHandle(hFile);
    }

    return (LONG) (INVALID_HANDLE_VALUE != hFile && fRc);
}

//
//Write the header info with the number of demos that is passed in from visual basic
//
_declspec(dllexport) long __stdcall XDIWriteHeader(LPSTR pszXDIFile, 
                                                   LONG lNumDemos, 
                                                   LONG lKiosk,
                                                   char *pszCallingXBE, 
                                                   char *pszPersist)
{
    HANDLE hFile;
    XDIHEADER xdi;
    DWORD dwNumWritten;
    BOOL  fRc = FALSE;

    xdi.m_lNumDemos = lNumDemos;
    xdi.m_fKiosk = lKiosk;
    xdi.m_lVerMajor = VERMAJOR;
    xdi.m_lVerMinor = VERMINOR;
    lstrcpy(xdi.m_szGameName, pszCallingXBE);
    lstrcpy(xdi.m_szPersist, pszPersist);

    //
    //Always recreate the file when writing the header
    //
	hFile = CreateFile(pszXDIFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, 
					   CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        fRc = WriteFile(hFile, &xdi, sizeof(XDIHEADER), &dwNumWritten, NULL);

        if (sizeof(XDIHEADER) == dwNumWritten)
		{
			WriteChecksum(hFile);
		}

        CloseHandle(hFile);
    }

    return (LONG) (INVALID_HANDLE_VALUE != hFile && fRc);
}

//
//Write the next demo info, appended to the end of the file
//
_declspec(dllexport) long __stdcall XDIWriteDemoInfo(char *pszXDIFile, DIB *pdib)
{
    HANDLE hFile;
    DWORD dwNumWritten;
    DIB   *pNewDib;
    char  szDemoType[nMAX_STRINGLEN];

    //
    //Find the handle to this dll (XDIDll.Dll) and load the descriptive demo type string from the string table
    //
    HMODULE hDll = GetModuleHandle("XDIDll");
    LoadString(hDll, pdib->m_dwFlags & DIBFLAGS_MOVIE ? IDS_MOVIE : IDS_DEMO, szDemoType, nMAX_STRINGLEN);

    //
    //Calculate size of this demo information block, include space for trailing zeros
    //
    pdib->m_dwSize = sizeof(DIB) + lstrlen(pdib->m_pszTitle) + 1 +
                                   lstrlen(pdib->m_pszFolder) + 1 +
                                   lstrlen(pdib->m_pszXBE) + 1 + 
                                   lstrlen(pdib->m_pszTeaser) + 1 +
                                   lstrlen(pdib->m_pszPersist) + 1 +
                                   lstrlen(pdib->m_pszAddi) + 1 +
                                   lstrlen(pdib->m_pszAuthor) + 1 +
                                   lstrlen(szDemoType) + 1;

    //
    //Allocate space for the DIB, and copy the parameter dib into it
    //
    pNewDib = (DIB *) new BYTE[pdib->m_dwSize];
	if (NULL == pNewDib)
	{
		return 0L;
	}

    CopyMemory(pNewDib, pdib, sizeof(DIB));

    char *pPtr = (char *) &pNewDib->m_data;
    ZeroMemory(pPtr, pNewDib->m_dwSize - sizeof(DIB));

    lstrcpy(pPtr, pNewDib->m_pszTitle);
    pNewDib->m_pszTitle = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszFolder);
    pNewDib->m_pszFolder = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszXBE);
    pNewDib->m_pszXBE = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszTeaser);
    pNewDib->m_pszTeaser = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszPersist);
    pNewDib->m_pszPersist = *pNewDib->m_pszPersist ? (char *) (pPtr - (char *) pNewDib) : (char *) -1;
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszAddi);
    pNewDib->m_pszAddi = *pNewDib->m_pszAddi ? (char *) (pPtr - (char *) pNewDib) : (char *) -1;
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, pNewDib->m_pszAuthor);
    pNewDib->m_pszAuthor = (char *) (pPtr - (char *) pNewDib);
    pPtr += lstrlen(pPtr) + 1;

    lstrcpy(pPtr, szDemoType);
    pNewDib->m_pszDemoType = (char *) (pPtr - (char *) pNewDib);

    //
    //We OPEN_EXISTING, because a call to XDIWriteHeader took place before this call
    //
	hFile = CreateFile(pszXDIFile, GENERIC_READ|GENERIC_WRITE, 0, NULL, 
					   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        SetFilePointer(hFile, 0, NULL, FILE_END);
        WriteFile(hFile, pNewDib, pNewDib->m_dwSize, &dwNumWritten, NULL);

        if (pNewDib->m_dwSize == dwNumWritten)
		{
			WriteChecksum(hFile);
		}

        CloseHandle(hFile);
    }

	delete pNewDib;
    return (LONG) (INVALID_HANDLE_VALUE != hFile);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xdvdplay\winmain.cpp ===
//----------------------------------------------------------------------------
//
// Implement WinMain()
//
// Copyright (C) Microsoft Corporation, 1999.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define APP_NAME   "XBox DVD Player"

LRESULT CALLBACK
StaticWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    XDvdPlayer *pPlayer;

    pPlayer = (XDvdPlayer *)GetWindowLong(hWnd, GWLP_USERDATA);

    if (pPlayer)
    {
        return pPlayer->WndProc(hWnd, uMessage, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }
}

int WINAPI
WinMain(HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR pCmdLine,
        int iCmdShow)
{
    if (!hPrevInstance)
    {
        WNDCLASS wc;

        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = StaticWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = hInstance;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH) (1 + COLOR_WINDOW);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = APP_NAME;

        RegisterClass(&wc);
    }

    int iScreenWidth, iScreenHeight;
    iScreenWidth = GetSystemMetrics(SM_CXSCREEN);
    iScreenHeight = GetSystemMetrics(SM_CYSCREEN);

    HWND hWnd;
    hWnd = CreateWindow(
        APP_NAME,
        APP_NAME,
        WS_POPUP,
        0,
        0,
        0,
        0,
        NULL,
        NULL,
        hInstance,
        NULL);

    XDvdPlayer player;
    if (FAILED(player.Initialize(hWnd)))
    {
        DestroyWindow(hWnd);
        return 0;
    }

    SetWindowLong(hWnd, GWL_USERDATA, (LONG)&player);
    ShowWindow(hWnd, iCmdShow);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return msg.wParam;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\Xdemo\XDemos\XDIFile\XDIFile.h ===
#pragma once

#ifdef _XBOX
    #include <xtl.h>
#else
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
#endif

//
//Major/Minor version numbers
//
#define VERMAJOR   1L
#define VERMINOR   3L

#define DIBFLAGS_MOVIE		 0x00000001
#define DIBGLAGS_MOVIETEASER 0x00000100
#define DIBFLAGS_KIOSK		 0x00010000

#define nMAX_STRINGLEN 128

#pragma warning(push)
#pragma warning(disable : 4200)  //zero-size array in class
#pragma pack(1)
//
//Demo information block
//
class DIB
{
public:
	union 
    {
	    DWORD m_dwSize;
		DIB  *m_pNext;
	};

    DWORD m_dwFlags;
    DWORD m_dwPriority;
	char *m_pszTitle;
	char *m_pszFolder;
    char *m_pszXBE;
	char *m_pszTeaser;
    char *m_pszPersist;
	char *m_pszAddi;
    char *m_pszAuthor;
    char *m_pszDemoType;
	BYTE  m_data[];
};

#pragma warning(pop)

class XDIHEADER
{
public:
    BYTE m_bSignature[3];
    BYTE m_bPadding;
    LONG m_lVerMajor;
    LONG m_lVerMinor;
    LONG m_lNumDemos;
	LONG m_lCheckSum;
    BOOL m_fKiosk;
    char m_szGameName[nMAX_STRINGLEN];
    char m_szPersist[nMAX_STRINGLEN];

    XDIHEADER() 
    {
        m_bSignature[0] = 'X';
        m_bSignature[1] = 'D';
        m_bSignature[2] = 'I';
        m_lVerMajor = VERMAJOR;
        m_lVerMinor = VERMINOR;
        m_lNumDemos = 0L;
		m_lCheckSum = 0L;
        *m_szGameName = '\0';
        *m_szPersist = '\0';
    };
};
#pragma pack()

int VerifyContents(BYTE *pbDemos, DWORD dwFileSize);
void WriteChecksum(HANDLE hFile);

//
//headers for functions exported by XDIFile.dll
//

#ifdef _XBOX
    DWORD XDIReadFile(const char *pszXDIFile, void *pvDemos, DWORD dwFileSize);
#else
    extern "C"
    {
        _declspec(dllexport) long __stdcall XDIGetDllVersion(void);
        _declspec(dllexport) long __stdcall XDIGetDemoHeader(char *pszXDIFile, XDIHEADER *pxdi);
        _declspec(dllexport) long __stdcall XDIGetDemoInfo(char *pszXDIFile, DIB *pdib, LONG lIdx);
        _declspec(dllexport) long __stdcall XDIWriteDemoInfo(char *pszXDIFile, DIB *pdib);
        _declspec(dllexport) long __stdcall XDIWriteHeader(LPSTR pszXDIFile, LONG lNumDemos, LONG lKiosk,
                                                           char *pszCallingXBE, char *pszPersist);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\XIP\mesh.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "xip.h"

extern bool bQuiet;

#define MAKE_MESHID(fvfIndex, meshIndex) ((fvfIndex << 24) | (meshIndex))
#define INVALID_MESHID 0xffffffff

struct CMeshBuffer
{
	DWORD m_fvf;
	int m_nVertexStride;

	void* m_vertices;
	int m_nVertexCount;

	WORD* m_indices;
	int m_nIndexCount;
/*
	int* m_rgnMeshEnd;
	int m_nMeshCount;
*/
};

#define MAX_MESHBUFFER 10
CMeshBuffer rgMeshBuffer [MAX_MESHBUFFER];
int nMeshBufferCount = 0;

int FindMeshBuffer(DWORD fvf, int nVerts)
{
	for (int i = 0; i < nMeshBufferCount; i += 1)
	{
		if (rgMeshBuffer[i].m_fvf == fvf && rgMeshBuffer[i].m_nVertexCount + nVerts <= 65536)
			return i;
	}

	if (nMeshBufferCount >= MAX_MESHBUFFER)
	{
		fprintf(stderr, "ERROR: too many mesh buffers!\n");
		exit(1);
	}

	if (!bQuiet)
		printf("Adding buffer for FVF:%08x\n", fvf);

	nMeshBufferCount += 1;
	rgMeshBuffer[i].m_fvf = fvf;

	return i;
}

typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,

    D3DPT_FORCE_DWORD           = 0x7fffffff
} D3DPRIMITIVETYPE;


bool AddMesh(const char* szFileName, DWORD& dwMeshID, DWORD& dwPrimCount)
{
	D3DPRIMITIVETYPE m_primitiveType;
	int m_nFaceCount;
	DWORD m_fvf;
	int m_nVertexStride;
	int m_nVertexCount;
	int m_nIndexCount;

	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwValue, dwRead;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_primitiveType = (D3DPRIMITIVETYPE)dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nFaceCount = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_fvf = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nVertexStride = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nVertexCount = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nIndexCount = dwValue;


	int fvfIndex = FindMeshBuffer(m_fvf, m_nVertexCount);
	CMeshBuffer& mb = rgMeshBuffer[fvfIndex];
	int meshIndex = mb.m_nIndexCount;

	mb.m_nVertexStride = m_nVertexStride;

	BYTE* vertices = new BYTE [(mb.m_nVertexCount + m_nVertexCount) * mb.m_nVertexStride];
	CopyMemory(vertices, mb.m_vertices, mb.m_nVertexCount * mb.m_nVertexStride);
	ReadFile(hFile, vertices + mb.m_nVertexCount * mb.m_nVertexStride, m_nVertexCount * m_nVertexStride, &dwRead, NULL);
	delete [] mb.m_vertices;
	mb.m_vertices = vertices;
	mb.m_nVertexCount += m_nVertexCount;

	WORD* indices = new WORD [mb.m_nIndexCount + m_nIndexCount];
	CopyMemory(indices, mb.m_indices, mb.m_nIndexCount * sizeof (WORD));
	ReadFile(hFile, indices + mb.m_nIndexCount, m_nIndexCount * sizeof (WORD), &dwRead, NULL);
	for (int i = 0; i < m_nIndexCount; i += 1)
		indices[mb.m_nIndexCount + i] += mb.m_nVertexCount - m_nVertexCount;
	delete [] mb.m_indices;
	mb.m_indices = indices;
	mb.m_nIndexCount += m_nIndexCount;
/*
	int* rgnMeshEnd = new int [mb.m_nMeshCount + 1];
	CopyMemory(rgnMeshEnd, mb.m_rgnMeshEnd, mb.m_nMeshCount * sizeof (int));
	rgnMeshEnd[mb.m_nMeshCount] = mb.m_nIndexCount;
	delete [] mb.m_rgnMeshEnd;
	mb.m_rgnMeshEnd = rgnMeshEnd;
	mb.m_nMeshCount += 1;
*/
	CloseHandle(hFile);

	dwMeshID = MAKE_MESHID(fvfIndex, meshIndex);
	dwPrimCount = m_nIndexCount / 3;

	return true;
}


void WriteMergedMeshFiles(CXipCreator* pCreator)
{
	for (int i = 0; i < nMeshBufferCount; i += 1)
	{
		CMeshBuffer& mb = rgMeshBuffer[i];

		char szName [MAX_PATH];
		DWORD dwWrite;

		sprintf(szName, "~%d.ib", i);
		HANDLE hFile = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		WriteFile(hFile, mb.m_indices, mb.m_nIndexCount * sizeof (WORD), &dwWrite, NULL);
		CloseHandle(hFile);
		pCreator->AddFile(szName);

		sprintf(szName, "~%d.vb", i);
		hFile = CreateFile(szName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
		WriteFile(hFile, &mb.m_nVertexCount, sizeof (int), &dwWrite, NULL);
		WriteFile(hFile, &mb.m_fvf, sizeof (DWORD), &dwWrite, NULL);
		WriteFile(hFile, mb.m_vertices, mb.m_nVertexCount * mb.m_nVertexStride, &dwWrite, NULL);
		CloseHandle(hFile);
		pCreator->AddFile(szName);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\XIP\lzss.h ===
#pragma once

#define N		 4096	// size of ring buffer
#define F		   18	// upper limit for match_length
#define THRESHOLD	2   // encode string into position and length if match_length is greater than this
#define NIL			N	// index for root of binary search trees
#define SPACE	' '


class CLZSS
{
public:
	CLZSS();

	virtual int ReadByte() = 0; // return EOF (-1) at end
	virtual void WriteByte(BYTE b) = 0;

	void Decode();

#ifndef _LZSS_NO_ENCODER
	void Encode();
#endif

private:
	BYTE text_buf [N + F - 1];

#ifndef _LZSS_NO_ENCODER
	void InitTree();
	void InsertNode(int r);
	void DeleteNode(int p);

	UINT textsize;
	UINT codesize;

	int match_position;
	int match_length;

	int lson [N + 1];
	int rson [N + 257];
	int dad [N + 1];
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\XIP\lzss.cpp ===
#include <windows.h>
#include "lzss.h"

/*
This scheme is initiated by Ziv and Lempel [1].  A slightly modified
version is described by Storer and Szymanski [2].  An implementation
using a binary tree is proposed by Bell [3].  The algorithm is quite
simple: Keep a ring buffer, which initially contains "space" characters
only.  Read several letters from the file to the buffer.  Then search
the buffer for the longest string that matches the letters just read,
and send its length and position in the buffer.

If the buffer size is 4096 bytes, the position can be encoded in 12
bits.  If we represent the match length in four bits, the <position,
length> pair is two bytes long.  If the longest match is no more than
two characters, then we send just one character without encoding, and
restart the process with the next letter.  We must send one extra bit
each time to tell the decoder whether we are sending a <position,
length> pair or an unencoded character.
*/

CLZSS::CLZSS()
{
	textsize = 0;
	codesize = 0;
}

#ifndef _LZSS_NO_ENCODER
void CLZSS::InitTree()
{
	// For i = 0 to N - 1, rson[i] and lson[i] will be the right and
	// left children of node i.  These nodes need not be initialized.
	// Also, dad[i] is the parent of node i.  These are initialized to
	// NIL (= N), which stands for 'not used.'
	// For i = 0 to 255, rson[N + i + 1] is the root of the tree
	// for strings that begin with character i.  These are initialized
	// to NIL.  Note there are 256 trees.

	int  i;

	for (i = N + 1; i <= N + 256; i += 1)
		rson[i] = NIL;

	for (i = 0; i < N; i += 1)
		dad[i] = NIL;
}

void CLZSS::InsertNode(int r)
{
	// Inserts string of length F, text_buf[r..r+F-1], into one of the
	// trees (text_buf[r]'th tree) and returns the longest-match position
	// and length via the global variables match_position and match_length.
	// If match_length = F, then removes the old node in favor of the new
	// one, because the old one will be deleted sooner.
	// Note r plays double role, as tree node and position in buffer.

	int i, p, cmp;
	BYTE* key;

	cmp = 1;
	key = &text_buf[r];
	p = N + 1 + key[0];
	rson[r] = lson[r] = NIL;
	match_length = 0;

	for (;;)
	{
		if (cmp >= 0)
		{
			if (rson[p] != NIL)
			{
				p = rson[p];
			}
			else
			{
				rson[p] = r;
				dad[r] = p;
				return;
			}
		}
		else
		{
			if (lson[p] != NIL)
			{
				p = lson[p];
			}
			else
			{
				lson[p] = r;
				dad[r] = p;
				return;
			}
		}

		for (i = 1; i < F; i++)
		{
			cmp = key[i] - text_buf[p + i];
			if (cmp != 0)
				break;
		}
		
		if (i > match_length)
		{
			match_position = p;
			if ((match_length = i) >= F)
				break;
		}
	}

	dad[r] = dad[p];
	lson[r] = lson[p];
	rson[r] = rson[p];
	dad[lson[p]] = r;
	dad[rson[p]] = r;

	if (rson[dad[p]] == p)
		rson[dad[p]] = r;
	else
		lson[dad[p]] = r;

	dad[p] = NIL;
}

void CLZSS::DeleteNode(int p)
{
	int  q;
	
	if (dad[p] == NIL)
		return;

	if (rson[p] == NIL)
	{
		q = lson[p];
	}
	else if (lson[p] == NIL)
	{
		q = rson[p];
	}
	else
	{
		q = lson[p];
		if (rson[q] != NIL)
		{
			do
			{
				q = rson[q];
			}
			while (rson[q] != NIL);

			rson[dad[q]] = lson[q];
			dad[lson[q]] = dad[q];
			lson[q] = lson[p];
			dad[lson[p]] = q;
		}

		rson[q] = rson[p];
		dad[rson[p]] = q;
	}

	dad[q] = dad[p];
	if (rson[dad[p]] == p)
		rson[dad[p]] = q;
	else
		lson[dad[p]] = q;
	dad[p] = NIL;
}

void CLZSS::Encode()
{
	int i, c, len, r, s, last_match_length, code_buf_ptr;
	BYTE code_buf [17], mask;
	
	InitTree();  /* initialize trees */
	code_buf[0] = 0;  /* code_buf[1..16] saves eight units of code, and
		code_buf[0] works as eight flags, "1" representing that the unit
		is an unencoded letter (1 byte), "0" a position-and-length pair
		(2 bytes).  Thus, eight units require at most 16 bytes of code. */
	code_buf_ptr = mask = 1;
	s = 0;
	r = N - F;
	for (i = s; i < r; i += 1)
		text_buf[i] = SPACE;  // Clear the buffer with any character that will appear often.
	for (len = 0; len < F && (c = ReadByte()) != -1; len += 1)
		text_buf[r + len] = (BYTE)c;  // Read F bytes into the last F bytes of the buffer

	textsize = len;
	if (len == 0)
		return;

	// Insert the F strings, each of which begins with one or more 'space' characters.
	// Note the order in which these strings are inserted.  This way, degenerate trees
	// will be less likely to occur.
	for (i = 1; i <= F; i++)
		InsertNode(r - i);

	// Finally, insert the whole string just read.  The variables match_length and match_position are set.
	InsertNode(r);
	
	do
	{
		if (match_length > len)
			match_length = len;  // match_length may be spuriously long near the end of text.

		if (match_length <= THRESHOLD)
		{
			match_length = 1;  // Not long enough match.  Send one byte.
			code_buf[0] |= mask;  // 'send one byte' flag
			code_buf[code_buf_ptr++] = text_buf[r];  // Send uncoded.
		}
		else
		{
			// Send position and length pair. Note match_length > THRESHOLD.
			code_buf[code_buf_ptr++] = (BYTE)match_position;
			code_buf[code_buf_ptr++] = (BYTE)(((match_position >> 4) & 0xf0) | (match_length - (THRESHOLD + 1)));
		}

		if ((mask <<= 1) == 0)
		{
			// Shift mask left one bit.
			for (i = 0; i < code_buf_ptr; i++)  // Send at most 8 units of code together
				WriteByte(code_buf[i]);

			codesize += code_buf_ptr;
			code_buf[0] = 0;
			code_buf_ptr = mask = 1;
		}

		last_match_length = match_length;
		for (i = 0; i < last_match_length && (c = ReadByte()) != -1; i += 1)
		{
			DeleteNode(s);
			text_buf[s] = (BYTE)c;
			if (s < F - 1)
				text_buf[s + N] = (BYTE)c;
			s = (s + 1) & (N - 1);
			r = (r + 1) & (N - 1);
			InsertNode(r);
		}

		while (i++ < last_match_length)
		{
			DeleteNode(s);
			s = (s + 1) & (N - 1);
			r = (r + 1) & (N - 1);
			len -= 1;
			if (len != 0)
				InsertNode(r);
		}
	}
	while (len > 0);
	
	if (code_buf_ptr > 1)
	{
		// Send remaining code.
		for (i = 0; i < code_buf_ptr; i += 1)
			WriteByte(code_buf[i]);
		codesize += code_buf_ptr;
	}
}
#endif

void CLZSS::Decode()
{
	int i, j, k, r, c;
	UINT flags;
	
	for (i = 0; i < N - F; i++)
		text_buf[i] = SPACE;

	r = N - F;
	flags = 0;
	for (;;)
	{
		if (((flags >>= 1) & 256) == 0)
		{
			if ((c = ReadByte()) == -1)
				break;

			flags = c | 0xff00;
		}
		
		if (flags & 1)
		{
			if ((c = ReadByte()) == -1)
				break;

			WriteByte((BYTE)c);
			text_buf[r++] = (BYTE)c;
			r &= (N - 1);
		}
		else
		{
			if ((i = ReadByte()) == -1)
				break;
			if ((j = ReadByte()) == -1)
				break;

			i |= ((j & 0xf0) << 4);
			j = (j & 0x0f) + THRESHOLD;
			for (k = 0; k <= j; k++)
			{
				c = text_buf[(i + k) & (N - 1)];
				WriteByte((BYTE)c);
				text_buf[r++] = (BYTE)c;
				r &= (N - 1);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xdvdplay\xdvdplay.h ===
//----------------------------------------------------------------------------
//
// File: xdvdplay.h
//
// Copyright (C) Microsoft Corporation, 1999.
//
//----------------------------------------------------------------------------

#ifndef __XDVDPLAY_H__
#define __XDVDPLAY_H__

class XDvdPlayer
{
public:
    XDvdPlayer();
    ~XDvdPlayer();

    HRESULT Initialize(HWND hWnd);
    LRESULT CALLBACK WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

private:
    void SetFullScreen();
    void ToggleClosedCaption();
    void SetParentalLevel();
    BOOL OnKeyDown(HWND hWnd, WPARAM wParam);
    void OnDVDPlayEvent(WPARAM wParam, LPARAM lParam);
    void Exit(HWND hWnd);
    void Play();
    void Pause();
    void Stop();
    void Scan(double dSpeed, BOOL fForward);

private:
    IDvdGraphBuilder *m_pDvdGB;
    IDvdControl      *m_pDvdC;
    IMediaControl    *m_pMC;
    IMediaEventEx    *m_pME;
    BOOL              m_bMenuOn;
    BOOL              m_bScanning;
};

#endif // __XDVDPLAY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\XIP\xip.cpp ===
/*
	XIP -- Xbox "zip" file tool

	This tool will create XIP files and list the files within one.

	To create a XIP file:

		XIP <output-file> { <input-file> ... }

	To display the contents of a XIP file:

		XIP <xip-file>
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include "lzss.h"
#include "xip.h"

/*
	File format:

	XIPHEADER header
	FILENAME filenames [...]
	char rgszNames [...]
	FILEDATA filedata [...]
	BYTE data [...]
*/

extern bool AddMesh(const char* szFileName, DWORD& dwMeshID, DWORD& dwPrimCount);
extern void WriteMergedMeshFiles(CXipCreator* pCreator);

bool bQuiet = false;
bool bMergeMeshFiles = false;

#define MAX_IGNORE 20
char* rgszIgnore [MAX_IGNORE];
int nIgnoreCount = 0;

void AddIgnore(char* szIgnoreFile)
{
	if (nIgnoreCount == MAX_IGNORE)
	{
		fprintf(stderr, "ERROR: too many ignore files (max=%d)\n", MAX_IGNORE);
		exit(1);
	}

	rgszIgnore[nIgnoreCount] = szIgnoreFile;
	nIgnoreCount += 1;
}

bool IgnoreFile(const char* szFile)
{
	for (int i = 0; i < nIgnoreCount; i += 1)
	{
		if (_stricmp(szFile, rgszIgnore[i]) == 0)
			return true;
	}

	return false;
}

bool CompareFiles(HANDLE hFile1, HANDLE hFile2);

bool Read(HANDLE hFile, void* pv, int cb)
{
	DWORD dwRead;
	return ReadFile(hFile, pv, cb, &dwRead, NULL) && dwRead == (DWORD)cb;
}

bool Write(HANDLE hFile, void* pv, int cb)
{
	DWORD dwWrite;
	return WriteFile(hFile, pv, cb, &dwWrite, NULL) && dwWrite == (DWORD)cb;
}

void DumpXIP(const char* szXipFile)
{
	printf("Dumping %s...\n", szXipFile);

	HANDLE hFile = CreateFile(szXipFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open %s\n", szXipFile);
		return;
	}

	XIPHEADER xhdr;
	if (!Read(hFile, &xhdr, sizeof (XIPHEADER)) || xhdr.m_dwMagic != MAGIC)
	{
		printf("%s: not a valid xip file!\n", szXipFile);
		CloseHandle(hFile);
		return;
	}

	FILEDATA* filedata = new FILEDATA [xhdr.m_wFileCount];
	if (!Read(hFile, filedata, sizeof (FILEDATA) * xhdr.m_wFileCount))
	{
		printf("%s: not a valid xip file!\n", szXipFile);
		CloseHandle(hFile);
		return;
	}

	FILENAME* directory = new FILENAME [xhdr.m_wNameCount];
	if (!Read(hFile, directory, sizeof (FILENAME) * xhdr.m_wNameCount))
	{
		printf("%s: not a valid xip file!\n", szXipFile);
		CloseHandle(hFile);
		return;
	}

	DWORD dwNameSize = xhdr.m_dwDataStart - SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
	char* names = new char [dwNameSize];
	if (!Read(hFile, names, dwNameSize))
	{
		printf("%s: not a valid xip file!\n", szXipFile);
		CloseHandle(hFile);
		return;
	}

	for (DWORD i = 0; i < xhdr.m_wNameCount; i += 1)
	{
		const char* szName = names + directory[i].m_wNameOffset;
//		printf("%8d %s\n", filedata[directory[i].m_wFileDataIndex].m_dwSize, szName);
		FILEDATA* pFileData = &filedata[directory[i].m_wFileDataIndex];
		if (pFileData->m_dwType == XIP_TYPE_MESH_REFERENCE)
			printf("%3d %3d:%4d %8d %s\n", directory[i].m_wFileDataIndex, pFileData->m_dwDataOffset >> 24, pFileData->m_dwDataOffset & 0x00ffffff, pFileData->m_dwSize, szName);
		else if (pFileData->m_dwType == XIP_TYPE_TEXTURE)
			printf("%3d %8d %8d %s (texture)\n", directory[i].m_wFileDataIndex, xhdr.m_dwDataStart + pFileData->m_dwDataOffset, pFileData->m_dwSize, szName);
		else
			printf("%3d %8d %8d %s\n", directory[i].m_wFileDataIndex, xhdr.m_dwDataStart + pFileData->m_dwDataOffset, pFileData->m_dwSize, szName);

	}

	CloseHandle(hFile);
}



CXipCreator::CXipCreator()
{
	m_nFileCount = 0;
	m_nNameCount = 0;
	m_nFileAlloc = 0;
	m_nNameAlloc = 0;
	m_nTotalSize = 0;
	m_directory = NULL;
	m_filedata = NULL;
	m_rgszFileName = NULL;
	m_cchNames = 0;
	m_cchNamesAlloc = 0;
	m_names = NULL;
}

CXipCreator::~CXipCreator()
{
	delete [] m_directory;
	delete [] m_filedata;
	delete [] m_names;

	for (int i = 0; i < m_nFileCount; i += 1)
		delete [] m_rgszFileName [i];
	delete [] m_rgszFileName;
}

bool CXipCreator::AddFile(const char* szFileName)
{
	DWORD dwFileType = XIP_TYPE_GENERIC;

	// BLOCK: Determine type of file
	{
		const char* szFileType = strrchr(szFileName, '.');
		if (szFileType != NULL)
		{
			szFileType += 1;

			if (_stricmp(szFileType, "xm") == 0)
				dwFileType = XIP_TYPE_MESH;
			else if (_stricmp(szFileType, "ib") == 0)
				dwFileType = XIP_TYPE_INDEXBUFFER;
			else if (_stricmp(szFileType, "vb") == 0)
				dwFileType = XIP_TYPE_VERTEXBUFFER;
			else if (_stricmp(szFileType, "wav") == 0)
				dwFileType = XIP_TYPE_WAVE;
			else if (_stricmp(szFileType, "bmp") == 0)
				dwFileType = XIP_TYPE_TEXTURE;
			else if (_stricmp(szFileType, "tga") == 0)
				dwFileType = XIP_TYPE_TEXTURE;
			else if (_stricmp(szFileType, "xbx") == 0)
				dwFileType = XIP_TYPE_TEXTURE;
		}
	}

	char szTextureFileName [MAX_PATH];
    if (dwFileType == XIP_TYPE_TEXTURE)
	{
		// Change texture file references to *.xt when the *.xt exists...
		strcpy(szTextureFileName, szFileName);

        if (GetEnvironmentVariable("COOL_XDASH", NULL, 0)) {
            strcpy(strrchr(szTextureFileName, '.') + 1, "xbx.cool");
        } else {
            strcpy(strrchr(szTextureFileName, '.') + 1, "xbx");
        }

		HANDLE hFile = CreateFile(szTextureFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hFile);
			szFileName = szTextureFileName;
		}
		else
		{
			printf("WARNING: missing %s\n", szTextureFileName);
		}
	}

	// BLOCK: Just ignore files that are specified more than once!
	{
		for (int i = 0; i < m_nFileCount; i += 1)
		{
			const char* szName = m_names + m_directory[i].m_wNameOffset;

			if (_stricmp(szFileName, szName) == 0)
				return true;
		}
	}

	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	if (m_nNameCount >= m_nNameAlloc)
	{
		m_nNameAlloc += 100;

		FILENAME* directory = new FILENAME [m_nNameAlloc];
		CopyMemory(directory, m_directory, sizeof (FILENAME) * m_nNameCount);
		delete [] m_directory;
		m_directory = directory;
	}

	DWORD dwFileSize = GetFileSize(hFile, NULL);

	// See if this file is exactly the same as some other one...
	int nSameAs = -1;
	for (int i = 0; i < m_nFileCount; i += 1)
	{
		if (m_filedata[i].m_dwSize == dwFileSize && m_filedata[i].m_dwType == dwFileType)
		{
			const char* szName = m_names + m_directory[i].m_wNameOffset;
			HANDLE hFile2 = CreateFile(szName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
			if (hFile2 == INVALID_HANDLE_VALUE)
			{
				printf("Cannot open %s\n", szName);
				break;
			}

			bool bSame = CompareFiles(hFile, hFile2);

			CloseHandle(hFile2);

			if (bSame)
			{
				nSameAs = i;

				if (!bQuiet)
					printf("\t%s is the same as %s\n", szFileName, szName);
				break;
			}
		}
	}

	CloseHandle(hFile);

	if (nSameAs == -1)
	{
		// The file is unique so far, so add its content to the xip...
		m_directory[m_nNameCount].m_wFileDataIndex = (WORD)m_nFileCount;

		if (m_nFileCount >= m_nFileAlloc)
		{
			m_nFileAlloc += 100;

			FILEDATA* filedata = new FILEDATA [m_nFileAlloc];
			CopyMemory(filedata, m_filedata, sizeof (FILEDATA) * m_nFileCount);
			delete [] m_filedata;
			m_filedata = filedata;

			char** rgszFileName = new char* [m_nFileAlloc];
			CopyMemory(rgszFileName, m_rgszFileName, sizeof (char*) * m_nFileCount);
			delete [] m_rgszFileName;
			m_rgszFileName = rgszFileName;
		}

		if (bMergeMeshFiles && dwFileType == XIP_TYPE_MESH)
		{
			// Mesh's are funky...
			DWORD dwMeshID, dwPrimCount;
			if (!AddMesh(szFileName, dwMeshID, dwPrimCount))
			{
				fprintf(stderr, "ERROR: Cannot add mesh %s\n", szFileName);
				exit(1);
			}
			m_filedata[m_nFileCount].m_dwDataOffset = dwMeshID;
			m_filedata[m_nFileCount].m_dwSize = dwPrimCount;
			m_filedata[m_nFileCount].m_dwType = XIP_TYPE_MESH_REFERENCE;
			m_filedata[m_nFileCount].m_dwTimestamp = 0;

			m_rgszFileName[m_nFileCount] = NULL;
		}
		else // BLOCK: Add a filedata and its name...
		{
			m_filedata[m_nFileCount].m_dwDataOffset = m_nTotalSize;
			m_filedata[m_nFileCount].m_dwSize = dwFileSize;
			m_filedata[m_nFileCount].m_dwType = dwFileType;
			m_filedata[m_nFileCount].m_dwTimestamp = 0;

			m_rgszFileName[m_nFileCount] = new char [strlen(szFileName) + 1];
			strcpy(m_rgszFileName[m_nFileCount], szFileName);

//				printf("file %d at %d %s\n", m_nFileCount, m_nTotalSize, szFileName);

			m_nTotalSize += dwFileSize;
		}

		m_nFileCount += 1;
	}
	else
	{
		// This file is the same as another, so just reference the one we already have
		m_directory[m_nNameCount].m_wFileDataIndex = (WORD)nSameAs;
	}

	m_directory[m_nNameCount].m_wNameOffset = (WORD)m_cchNames;

	// BLOCK: Add the name to the char buffer...
	{
		int cchName = strlen(szFileName) + 1;
		if (m_cchNames + cchName > m_cchNamesAlloc)
		{
			m_cchNamesAlloc += 1024;
			char* names = new char [m_cchNamesAlloc];
			CopyMemory(names, m_names, m_cchNames);
			delete [] m_names;
			m_names = names;
		}

		CopyMemory(m_names + m_cchNames, szFileName, cchName);
		m_cchNames += cchName;
	}

	m_nNameCount += 1;

	return true;
}




class CAppendLZSS : public CLZSS
{
public:
	CAppendLZSS()
	{
		m_hDestFile = INVALID_HANDLE_VALUE;
		m_hSrcFile = INVALID_HANDLE_VALUE;
	}

	~CAppendLZSS()
	{
		if (m_hSrcFile != INVALID_HANDLE_VALUE)
			CloseHandle(m_hSrcFile);
	}

	bool CompressAll(HANDLE hDestFile, CXipCreator* pCreator)
	{
		m_pCreator = pCreator;
		m_nFile = 0;
		m_hDestFile = hDestFile;

		Encode();

		return true;
	}

	bool StartNextFile()
	{
		if (m_hSrcFile == INVALID_HANDLE_VALUE)
		{
			CloseHandle(m_hSrcFile);
			m_hSrcFile = INVALID_HANDLE_VALUE;
		}

		if (m_nFile >= m_pCreator->m_nFileCount)
			return false;

		while (m_pCreator->m_rgszFileName[m_nFile] == NULL)
		{
			m_nFile += 1;
			if (m_nFile >= m_pCreator->m_nFileCount)
				return false;
		}

		m_hSrcFile = CreateFile(m_pCreator->m_rgszFileName[m_nFile], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
		if (m_hSrcFile == INVALID_HANDLE_VALUE)
		{
			printf("Cannot open %s\n", m_pCreator->m_rgszFileName[m_nFile]);
			return false;
		}
		
		if (!bQuiet)
			printf("Compressing %s...\n", m_pCreator->m_rgszFileName[m_nFile]);

		m_nFile += 1;

		return true;
	}

	int ReadByte()
	{
		if (m_hSrcFile == INVALID_HANDLE_VALUE)
		{
			if (!StartNextFile())
				return -1;
		}

		BYTE b;
		DWORD dwRead;
		if (!ReadFile(m_hSrcFile, &b, 1, &dwRead, NULL) || dwRead != 1)
		{
			if (!StartNextFile())
				return -1;

			if (!ReadFile(m_hSrcFile, &b, 1, &dwRead, NULL) || dwRead != 1)
				return -1;
		}
		
		return b;
	}

	void WriteByte(BYTE b)
	{
		DWORD dwWrite;
		if (!WriteFile(m_hDestFile, &b, 1, &dwWrite, NULL))
		{
			fprintf(stderr, "ERROR: cannot write file\n");
			exit(2);
		}
	}

	HANDLE m_hSrcFile;
	HANDLE m_hDestFile;
	CXipCreator* m_pCreator;
	int m_nFile;
};

bool AppendFile(HANDLE hDestFile, const char* szSrcFile)
{
	BYTE buffer [16384];

	HANDLE hSrcFile = CreateFile(szSrcFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
	if (hSrcFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot open %s\n", szSrcFile);
		return false;
	}

	for (;;)
	{
		DWORD dwRead, dwWrite;

		if (!ReadFile(hSrcFile, buffer, 16384, &dwRead, NULL))
		{
			printf("ReadFile(%s) failed (%d)\n", szSrcFile, GetLastError());
			CloseHandle(hSrcFile);
			return false;
		}

		if (dwRead == 0)
			break;

		if (!WriteFile(hDestFile, buffer, dwRead, &dwWrite, NULL))
		{
			printf("WriteFile failed (%d)\n", GetLastError());
			CloseHandle(hSrcFile);
			return false;
		}
	}

	CloseHandle(hSrcFile);

	return true;
}

bool CompareFiles(HANDLE hFile1, HANDLE hFile2)
{
	BYTE buffer1 [16384];
	BYTE buffer2 [16384];

	for (;;)
	{
		DWORD dwRead1, dwRead2;

		if (!ReadFile(hFile1, buffer1, 16384, &dwRead1, NULL))
			return false;

		if (!ReadFile(hFile2, buffer2, 16384, &dwRead2, NULL))
			return false;

		if (dwRead1 != dwRead2)
			return false;

		if (dwRead1 == 0)
			return true;

		if (memcmp(buffer1, buffer2, dwRead1) != 0)
			return false;
	}
}

CXipCreator* g_pCreator;

static int __cdecl SortDirectoryCompare(const void *elem1, const void *elem2)
{
	const FILENAME* pName1 = (const FILENAME*)elem1;
	const FILENAME* pName2 = (const FILENAME*)elem2;
	return _stricmp(g_pCreator->m_names + pName1->m_wNameOffset, g_pCreator->m_names + pName2->m_wNameOffset);
}

void CreateXIP(const char* szXipFile, int nFiles, char* rgszFiles [], bool bCompress)
{
	CXipCreator creator;

	if (!bQuiet)
		printf("Creating %s...\n", szXipFile);

	HANDLE hFile = CreateFile(szXipFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		printf("Cannot create %s\n", szXipFile);
		return;
	}

	for (int i = 0; i < nFiles; i += 1)
	{
		if (strchr(rgszFiles[i], '?') != NULL || strchr(rgszFiles[i], '*') != NULL)
		{
			WIN32_FIND_DATA fd;
			HANDLE h = FindFirstFile(rgszFiles[i], &fd);
			if (h != INVALID_HANDLE_VALUE)
			{
				do
				{
					if (strcmp(fd.cFileName, ".") == 0 || strcmp(fd.cFileName, "..") == 0)
						continue;

					if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)
						continue;

					// TODO: If wildcard not in curdir, need to make a path for cFileName...
					if (!creator.AddFile(fd.cFileName))
						printf("Cannot open %s\n", fd.cFileName);
				}
				while (FindNextFile(h, &fd));
				FindClose(h);
			}
		}
		else
		{
			const char* szType = strrchr(rgszFiles[i], '.');
			if (szType != NULL)
			{
				szType += 1;
				if (_stricmp(szType, "xap") == 0)
				{
					HANDLE hXapFile = CreateFile(rgszFiles[i], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
					if (hXapFile != INVALID_HANDLE_VALUE)
					{
						// Check for a corresponding xab file and add it instead
						{
							char szXabFile [MAX_PATH];
							strcpy(szXabFile, rgszFiles[i]);
							strcpy(strrchr(szXabFile, '.') + 1, "xab");

							HANDLE hXabFile = CreateFile(szXabFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
							if (hXabFile != INVALID_HANDLE_VALUE)
							{
								// Check file time and warn if xap is newer than xab!
								FILETIME xapTime, xabTime;

								GetFileTime(hXapFile, NULL, NULL, &xapTime);
								GetFileTime(hXabFile, NULL, NULL, &xabTime);

								CloseHandle(hXabFile);

								if (CompareFileTime(&xapTime, &xabTime) > 0)
								{
									printf("%s: WARNING Compile is out of date; using text version\n", rgszFiles[i]);
									if (!creator.AddFile(rgszFiles[i]))
										printf("Cannot open %s\n", rgszFiles[i]);
								}
								else
								{
									if (!creator.AddFile(szXabFile))
										printf("Cannot open %s\n", szXabFile);
								}
							}
							else
							{
								printf("%s: WARNING Source has not been compiled; using text version\n", rgszFiles[i]);
								if (!creator.AddFile(rgszFiles[i]))
									printf("Cannot open %s\n", rgszFiles[i]);
							}
						}

						// Scan the xap file for .xm files and automatically add those too!
						{
							int nLine = 0;
							for (;;)
							{
								char szLine [1024];
								int cchLine = 0;
								DWORD dwRead;
								while (cchLine < sizeof (szLine) - 1)
								{
									if (!ReadFile(hXapFile, &szLine[cchLine], 1, &dwRead, NULL) || dwRead == 0 || szLine[cchLine] == '\n')
										break;
									cchLine += 1;
								}

								if (cchLine == 0)
									break;

								szLine[cchLine] = 0;
								nLine += 1;

								const char* szURL = strstr(szLine, "url \"");
								if (szURL == NULL)
									continue;

								szURL += 5;
								char* pch = strchr(szURL, '"');
								if (pch == NULL)
									continue;

								*pch = 0;

								pch = strchr(szURL, '.');
								if (pch == NULL)
									continue;
								pch += 1;

								if (!IgnoreFile(szURL))
								{
									if (_stricmp(pch, "wav") != 0)
									{
										if (!creator.AddFile(szURL))
											printf("%s(%d): WARNING reference to missing file: %s\n", rgszFiles[i], nLine, szURL);
									}
									else
									{
										if (!bQuiet)
											printf("\t%s(%d): Ignoring %s\n", rgszFiles[i], nLine, szURL);
									}
								}
							}
						}

						CloseHandle(hXapFile);
						continue;
					}
				}
			}

			creator.AddFile(rgszFiles[i]);
		}
	}

	if (bMergeMeshFiles)
	{
		// now add the merged mesh files...
		WriteMergedMeshFiles(&creator);
	}

	g_pCreator = &creator;
	qsort(creator.m_directory, creator.m_nNameCount, sizeof (FILENAME), SortDirectoryCompare);
	g_pCreator = NULL;

	XIPHEADER xhdr;
	xhdr.m_dwMagic = MAGIC;
	xhdr.m_wNameCount = (WORD)creator.m_nNameCount;
	xhdr.m_wFileCount = (WORD)creator.m_nFileCount;
	xhdr.m_dwDataStart = sizeof (XIPHEADER) + creator.m_nNameCount * sizeof (FILENAME) + creator.m_cchNames + creator.m_nFileCount * sizeof (FILEDATA);
	xhdr.m_dwDataSize = creator.m_nTotalSize;
	Write(hFile, &xhdr, sizeof (xhdr));

	Write(hFile, creator.m_filedata, creator.m_nFileCount * sizeof (FILEDATA));
	Write(hFile, creator.m_directory, creator.m_nNameCount * sizeof (FILENAME));
	Write(hFile, creator.m_names, creator.m_cchNames);

	DWORD dwDataStart = SetFilePointer(hFile, 0, NULL, FILE_CURRENT);
	if (bCompress)
	{
		CAppendLZSS lzss;
		lzss.CompressAll(hFile, &creator);
	}
	else
	{
		for (i = 0; i < creator.m_nFileCount; i += 1)
		{
			const char* szName = creator.m_rgszFileName[i];//creator.m_names + creator.m_directory[i].m_wNameOffset;

			if (creator.m_rgszFileName[i] == NULL)
				continue;

			if (!bQuiet)
				printf("\tadding %s\n", szName);

			if (SetFilePointer(hFile, 0, NULL, FILE_CURRENT) - dwDataStart != creator.m_filedata[i].m_dwDataOffset)
			{
				printf("\t\tthat file changed size!\n");
				break;
			}

			if (!AppendFile(hFile, szName))
				break;
		}
	}

	CloseHandle(hFile);
}

void UsageExit()
{
	printf("This tool will create XIP files and list the files within one.\n");
	printf("Usage:\n");
	printf("\txip [-options] <xip-file> <files> ...\n");
	printf("Options:\n");
	printf("\t-c\tCompress\n");
	printf("\t-i <file>\tIgnore references to <file>\n");
	printf("\t-q\tQuiet\n");

	exit(1);
}

int __cdecl main(int argc, char* argv [])
{
	const char* szXipFile = NULL;
	char** rgszAddFile = NULL;
	int nAddFileCount = 0;
	bool bCompress = false;

	for (int i = 1; i < argc; i += 1)
	{
		if (argv[i][0] == '/' || argv[i][0] == '-')
		{
			switch (argv[i][1])
			{
			default:
				UsageExit();
				break;

			case 'c':
			case 'C':
				bCompress = true;
				break;

			case 'q':
			case 'Q':
				bQuiet = true;
				break;

			case 'i':
			case 'I':
				{
					char* sz = argv[i] + 2;
					if (*sz == 0)
					{
						i += 1;
						sz = argv[i];
					}
					AddIgnore(sz);
				}
				break;

			case 'm':
			case 'M':
				bMergeMeshFiles = true;
				break;
			}
		}
		else if (szXipFile == NULL)
		{
			szXipFile = argv[i];
			nAddFileCount = argc - (i + 1);
			rgszAddFile = &argv[i + 1];
			break;
		}
	}

	if (szXipFile == NULL)
		UsageExit();

	if (nAddFileCount == 0)
	{
		DumpXIP(szXipFile);
		return 0;
	}

	CreateXIP(szXipFile, nAddFileCount, rgszAddFile, bCompress);

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xdvdplay\xdvdplay.cpp ===
//----------------------------------------------------------------------------
//
// File: xdvdplay.cpp
//
// Copyright (C) Microsoft Corporation, 1999.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#define RELEASE(x)          if (x) x->Release()
#define WM_DVDPLAY_EVENT    (WM_USER+100)

enum
{
    RATING_EARLY_CHILDHOOD,
    RATING_EVERYONE,
    RATING_TEEN,
    RATING_MATURE,
    RATING_ADULTS_ONLY,
    RATING_PENDING,
    RATING_ERROR
};

enum
{
    RATING_G = 1,
    RATING_PG = 3,
    RATING_PG13 = 4,
    RATING_R = 6,
    RATING_NC17 = 7
};

DWORD g_adwRating[5] = {RATING_G, RATING_PG, RATING_PG13, RATING_R, RATING_NC17};

XDvdPlayer::XDvdPlayer()
  : m_pDvdGB(NULL),
    m_pDvdC(NULL),
    m_pMC(NULL),
    m_pME(NULL),
    m_bMenuOn(FALSE),
    m_bScanning(FALSE)
{
    CoInitialize(NULL);
}

XDvdPlayer::~XDvdPlayer()
{
    RELEASE(m_pDvdGB);
    RELEASE(m_pDvdC);
    RELEASE(m_pMC);
    RELEASE(m_pME);
    
    CoUninitialize();
}

HRESULT
XDvdPlayer::Initialize(HWND hWnd)
{
    HRESULT hr;

    hr = CoCreateInstance(CLSID_DvdGraphBuilder, NULL, CLSCTX_INPROC,
                          IID_IDvdGraphBuilder, (LPVOID *)&m_pDvdGB);

    if (FAILED(hr))
        return hr;

    AM_DVD_RENDERSTATUS Status;
    hr = m_pDvdGB->RenderDvdVideoVolume(NULL, AM_DVD_HWDEC_PREFER, &Status);

    if (FAILED(hr))
        return hr;
    else if (hr == S_FALSE) // No dvd disk inserted.
        return E_FAIL;

    IGraphBuilder *pGraph;

    if (FAILED(hr = m_pDvdGB->GetFiltergraph(&pGraph)))
        return hr;

    pGraph->QueryInterface(IID_IMediaControl, (LPVOID *)&m_pMC);
    pGraph->QueryInterface(IID_IMediaEventEx, (LPVOID *)&m_pME);
    pGraph->Release();

    m_pME->SetNotifyWindow((OAHWND)hWnd, WM_DVDPLAY_EVENT, 0);

    m_pDvdGB->GetDvdInterface(IID_IDvdControl, (LPVOID *)&m_pDvdC);

    SetFullScreen();

    // CC is on by DShow's default. We need to change the default to off.
    ToggleClosedCaption();

    SetParentalLevel();

    Play();

    return S_OK;
}

void
XDvdPlayer::SetFullScreen()
{
    IVideoWindow *pVW;

    if (FAILED(m_pDvdGB->GetDvdInterface(IID_IVideoWindow, (LPVOID *)&pVW)))
        return;

    pVW->put_WindowStyle(0);

    LONG  lScrnWidth  = GetSystemMetrics(SM_CXSCREEN);
    LONG  lScrnHeight = GetSystemMetrics(SM_CYSCREEN);

    pVW->SetWindowPosition(0, 0, lScrnWidth, lScrnHeight);
    pVW->HideCursor(OATRUE);

    pVW->Release();
}

void
XDvdPlayer::ToggleClosedCaption()
{
    IAMLine21Decoder *pL21Dec;
    m_pDvdGB->GetDvdInterface(IID_IAMLine21Decoder, (LPVOID *)&pL21Dec);
    if (pL21Dec)
    {
        AM_LINE21_CCSTATE state;
        pL21Dec->GetServiceState(&state);
        pL21Dec->SetServiceState(state? AM_L21_CCSTATE_Off : AM_L21_CCSTATE_On);
        pL21Dec->Release();
    }
}

void
XDvdPlayer::SetParentalLevel()
{
    HKEY hKey;
    DWORD uSize, uType, uAllowedRating;
    ULONG ulLevel = 0xffffffff; // Parental management disabled.

    if (SUCCEEDED(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                               "Software\\Microsoft\\XBox\\Configuration",
                               0, KEY_ALL_ACCESS, &hKey)))
    {
        if (SUCCEEDED(RegQueryValueEx(hKey, "AllowedRating", 0, &uType,
                                      (BYTE *)&uAllowedRating, &uSize)))
        {
            if (uAllowedRating < RATING_PENDING)
            {
                ulLevel = g_adwRating[uAllowedRating];
            }
        }

        RegCloseKey(hKey);
    }

    m_pDvdC->ParentalLevelSelect(ulLevel);
}

LRESULT CALLBACK
XDvdPlayer::WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch(uMessage)
    {
        case WM_KEYDOWN:
            OnKeyDown(hWnd, wParam);
            break;

        case WM_DVDPLAY_EVENT:
            OnDVDPlayEvent(wParam, lParam);
            break;

        default:
            return DefWindowProc(hWnd, uMessage, wParam, lParam);
    }

    return 1;
}

BOOL
XDvdPlayer::OnKeyDown(HWND hWnd, WPARAM wParam)
{
    switch (wParam)
    {
        case VK_ESCAPE:
            Exit(hWnd);
            break;

        case 'A':
            Play();
            break;
        
        case 'B':
            Pause();
            break;

        case 'C':
            ToggleClosedCaption();
            break;

        case 'D':
            m_pDvdC->MenuCall(DVD_MENU_Root);
            break;

        case VK_SPACE:
            Stop();
            break;

        case VK_UP:
            if (m_bMenuOn)
                m_pDvdC->UpperButtonSelect();
            else
                Scan(8.0, TRUE);
            break;

        case VK_RIGHT:
            if (m_bMenuOn)
                m_pDvdC->RightButtonSelect();
            else
                Scan(2.0, TRUE);
            break;

        case VK_DOWN:
            if (m_bMenuOn)
                m_pDvdC->LowerButtonSelect();
            else
                Scan(8.0, FALSE);
            break;

        case VK_LEFT:
            if (m_bMenuOn)
                m_pDvdC->LeftButtonSelect();
            else
                Scan(2.0, FALSE);
            break;

        case VK_RETURN:
            if (m_bMenuOn)
                m_pDvdC->ButtonActivate();
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void
XDvdPlayer::OnDVDPlayEvent(WPARAM wParam, LPARAM lParam)
{
    LONG lEvent, lParam1, lParam2;

    while (SUCCEEDED(m_pME->GetEvent(&lEvent, &lParam1, &lParam2, 0)))
    {
        switch (lEvent)
        {
            case EC_DVD_ERROR:
                m_pMC->Stop();
                break;

            case EC_DVD_DOMAIN_CHANGE:
                switch (lParam1)
                {
                    case DVD_DOMAIN_FirstPlay:
                    case DVD_DOMAIN_Stop:
                        break;

                    case DVD_DOMAIN_VideoManagerMenu:
                    case DVD_DOMAIN_VideoTitleSetMenu:
                        m_bMenuOn = TRUE;
                        m_bScanning = FALSE;
                        break;

                    case DVD_DOMAIN_Title:
                        m_bMenuOn = FALSE;
                        break;
                }
                break;

            case EC_COMPLETE:
                m_pMC->Stop();
                break;
        }

        m_pME->FreeEventParams(lEvent, lParam1, lParam2);
    }
}

void
XDvdPlayer::Exit(HWND hWnd)
{
    Stop();
    PostQuitMessage(0);
    DestroyWindow(hWnd);
}

void
XDvdPlayer::Play()
{
    m_pMC->Run();
    m_pDvdC->ForwardScan(1.0);
    m_bScanning = FALSE;
}

void
XDvdPlayer::Stop()
{
    m_pMC->Stop();
}

void
XDvdPlayer::Pause()
{
    m_pMC->Pause();
}

void
XDvdPlayer::Scan(double dSpeed, BOOL fForward)
{
    // Need to press "Play" button between different scans,
    // otherwise it doesn't scan at the right speed.

    if (!m_bScanning)
    {
        if (fForward)
            m_pDvdC->ForwardScan(dSpeed);
        else 
            m_pDvdC->BackwardScan(dSpeed);

        m_bScanning = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\XIP\xip.h ===
#define MAGIC 0x30504958

#define XIP_TYPE_GENERIC			0
#define XIP_TYPE_MESH				1
#define XIP_TYPE_TEXTURE			2
#define XIP_TYPE_WAVE				3
#define XIP_TYPE_MESH_REFERENCE		4
#define XIP_TYPE_INDEXBUFFER		5
#define XIP_TYPE_VERTEXBUFFER		6

struct XIPHEADER
{
	DWORD m_dwMagic;
	DWORD m_dwDataStart;
	WORD m_wFileCount;
	WORD m_wNameCount;
	DWORD m_dwDataSize;
};

struct FILEDATA
{
	DWORD m_dwDataOffset;
	DWORD m_dwSize;
	DWORD m_dwType;
	DWORD m_dwTimestamp;
};

struct FILENAME
{
	WORD m_wFileDataIndex;
	WORD m_wNameOffset;
};

class CXipCreator
{
public:
	int m_nFileCount;
	int m_nNameCount;
	int m_nTotalSize;

	int m_nFileAlloc;
	int m_nNameAlloc;
	FILENAME* m_directory;
	FILEDATA* m_filedata;
	char** m_rgszFileName;

	int m_cchNames;
	int m_cchNamesAlloc;
	char* m_names;

	CXipCreator();
	~CXipCreator();
	bool AddFile(const char* szFileName);
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xm\TriStrip.h ===
//-----------------------------------------------------------------------------
// FILE: TRISTRIP.H
//
// Desc: tristrip header file
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

typedef unsigned short WORD;

//
// Main Stripify routine. Returns number of strip indices contained
// in ppstripindices. Caller must delete [] ppstripindices.
//
int Stripify(
    int numtris,                    // Number of triangles
    WORD *ptriangles,               // triangle indices pointer
    int *pnumindices,               // number of indices in ppstripindices (out)
    WORD **ppstripindices           // triangle strip indices
);

//
// Re-arrange vertices so that they occur in the order that they are first 
// used. This function doesn't actually move vertex data around, it returns
// an array that specifies where in the new vertex array each old vertex
// should go. It also re-maps the strip indices to use the new vertex 
// locations. Caller must delete [] pVertexPermutation.
//
void ComputeVertexPermutation
(
    int numstripindices,            // Number of strip indices
    WORD *pstripindices,            // Strip indices
    int *pnumverts,                 // Number of verts (in and out)
    WORD **ppvertexpermutation      // Map from orignal index to remapped index
);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xm\TriStrip.cpp ===
//-----------------------------------------------------------------------------
// FILE: TRISTRIP.CPP
//
// Desc: Xbox tristripper
//
// Copyright (c) 1999-2001 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

// identifier was truncated to '255' characters in the debug information
#pragma warning(disable: 4786)
// conversion from 'double' to 'float'
#pragma warning(disable: 4244)

#include <stdio.h>
#include <stdarg.h>
#include <algorithm>
#include <list>
#include <vector>
#include <assert.h>

#ifdef _DEBUG
#include <assert.h>
#include <crtdbg.h>
#endif

#include "tristrip.h"

using namespace std;

//=========================================================================
// structs
//=========================================================================
typedef vector<WORD> STRIPVERTS;
typedef list<STRIPVERTS *> STRIPLIST;
typedef WORD (*TRIANGLELIST)[3];

struct TRIANGLEINFO
{
    int neighbortri[3];
    int neighboredge[3];
};

// return true if strip starts clockwise
inline bool FIsStripCW(const STRIPVERTS &stripvertices)
{
    // last index should have cw/ccw bool
    return !!stripvertices[stripvertices.size() - 1];
}

// return length of strip
inline int StripLen(const STRIPVERTS &stripvertices)
{
    return stripvertices.size() - 1;
}

// free all stripverts and clear the striplist
inline void FreeStripListVerts(STRIPLIST *pstriplist)
{
    STRIPLIST::iterator istriplist = pstriplist->begin();
    while(istriplist != pstriplist->end())
    {
        STRIPVERTS *pstripverts = *istriplist;
        delete pstripverts;
        pstriplist->erase(istriplist++);
    }
}

//=========================================================================
// main stripper class
//=========================================================================
class CStripper
{
public:
    // ctors/dtors
    CStripper(int numtris, TRIANGLELIST ptriangles);
    ~CStripper();

    // initialize tri info
    void InitTriangleInfo(int tri, int vert);

    // get maximum length strip from tri/vert
    int CreateStrip(int tri, int vert, int maxlen, int *pswaps,
        bool flookahead, bool fstartcw, int *pstriptris, int *pstripverts);

    // stripify entire mesh
    void BuildStrips(STRIPLIST *pstriplist, int maxlen, bool flookahead);

    // blast strip indices to ppstripindices
    int CreateManyStrips(STRIPLIST *pstriplist, WORD **ppstripindices);
    int CreateLongStrip(STRIPLIST *pstriplist, WORD **ppstripindices);

    inline int GetNeighborCount(int tri)
    {
        int count = 0;
        for(int vert = 0; vert < 3; vert++)
        {
            int neighbortri = m_ptriinfo[tri].neighbortri[vert];
            count += (neighbortri != -1) && !m_pused[neighbortri];
        }
        return count;
    }

    // from callee
    int m_numtris;              // # tris
    TRIANGLELIST m_ptriangles;  // trilist

    TRIANGLEINFO *m_ptriinfo;   // tri edge, neighbor info
    int *m_pused;               // tri used flag
};

//=========================================================================
// vertex cache class
//=========================================================================
class CVertCache
{
public:
    CVertCache()
        { Reset(); }
    ~CVertCache()
        {};

    // reset cache
    void Reset()
    {
        m_iCachePtr = 0;
        m_cachehits = 0;
        memset(m_rgCache, 0xff, sizeof(m_rgCache));
    }

    // add vertindex to cache
    bool Add(int strip, int vertindex);

    int NumCacheHits() const
        { return m_cachehits; }

    enum { CACHE_SIZE = 16 };

private:
    int m_cachehits;                // current # of cache hits
    WORD m_rgCache[CACHE_SIZE];     // vertex cache
    int m_rgCacheStrip[CACHE_SIZE]; // strip # which added vert
    int m_iCachePtr;                // fifo ptr
};

//=========================================================================
// Get maximum length of strip starting at tri/vert
//=========================================================================
int CStripper::CreateStrip(int tri, int vert, int maxlen, int *pswaps,
    bool flookahead, bool fstartcw, int *pstriptris, int *pstripverts)
{
    *pswaps = 0;

    // this guy has already been used?
    if(m_pused[tri])
        return 0;

    // mark tri as used
    m_pused[tri] = 1;

    int swaps = 0;

    // add first tri info
    pstriptris[0] = tri;
    pstriptris[1] = tri;
    pstriptris[2] = tri;

    if(fstartcw)
    {
        pstripverts[0] = (vert) % 3;
        pstripverts[1] = (vert + 1) % 3;
        pstripverts[2] = (vert + 2) % 3;
    }
    else
    {
        pstripverts[0] = (vert + 1) % 3;
        pstripverts[1] = (vert + 0) % 3;
        pstripverts[2] = (vert + 2) % 3;
    }
    fstartcw = !fstartcw;

    // get next tri information
    int edge = (fstartcw ? vert + 2 : vert + 1) % 3;
    int nexttri = m_ptriinfo[tri].neighbortri[edge];
    int nextvert = m_ptriinfo[tri].neighboredge[edge];

    // start building the strip until we run out of room or indices
    for(int stripcount = 3; stripcount < maxlen; stripcount++)
    {
        // dead end?
        if(nexttri == -1 || m_pused[nexttri])
            break;

        // move to next tri
        tri = nexttri;
        vert = nextvert;

        // toggle orientation
        fstartcw = !fstartcw;

        // find the next natural edge
        int edge = (fstartcw ? vert + 2 : vert + 1) % 3;
        nexttri = m_ptriinfo[tri].neighbortri[edge];
        nextvert = m_ptriinfo[tri].neighboredge[edge];

        bool fswap = false;
        if(nexttri == -1 || m_pused[nexttri])
        {
            // if the next tri is a dead end - try swapping orientation
            fswap = true;
        }
        else if(flookahead)
        {
            // try a swap and see who our new neighbor would be
            int edgeswap = (fstartcw ? vert + 1 : vert + 2) % 3;
            int nexttriswap = m_ptriinfo[tri].neighbortri[edgeswap];
            int nextvertswap = m_ptriinfo[tri].neighboredge[edgeswap];

            if(nexttriswap != -1 && !m_pused[nexttriswap])
            {
                assert(nexttri != -1);

                // if the swap neighbor has a lower count, change directions
                if(GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri))
                {
                    fswap = true;
                }
                else if(GetNeighborCount(nexttriswap) == GetNeighborCount(nexttri))
                {
                    // if they have the same number of neighbors - check their neighbors
                    edgeswap = (fstartcw ? nextvertswap + 2 : nextvertswap + 1) % 3;
                    nexttriswap = m_ptriinfo[nexttriswap].neighbortri[edgeswap];

                    int edge1 = (fstartcw ? nextvert + 1 : nextvert + 2) % 3;
                    int nexttri1 = m_ptriinfo[nexttri].neighbortri[edge1];

                    if(nexttri1 == -1 || m_pused[nexttri1])
                    {
                        // natural winding order leads us to a dead end so turn
                        fswap = true;
                    }
                    else if(nexttriswap != -1 && !m_pused[nexttriswap])
                    {
                        // check neighbor counts on both directions and swap if it's better
                        if(GetNeighborCount(nexttriswap) < GetNeighborCount(nexttri1))
                            fswap = true;
                    }
                }
            }
        }

        if(fswap)
        {
            // we've been told to change directions so make sure we actually can
            // and then add the swap vertex
            int edgeswap = (fstartcw ? vert + 1 : vert + 2) % 3;
            nexttri = m_ptriinfo[tri].neighbortri[edgeswap];
            nextvert = m_ptriinfo[tri].neighboredge[edgeswap];

            if(nexttri != -1 && !m_pused[nexttri])
            {
                pstriptris[stripcount] = pstriptris[stripcount - 2];
                pstripverts[stripcount] = pstripverts[stripcount - 2];
                stripcount++;
                swaps++;
                fstartcw = !fstartcw;
            }
        }

        // record index information
        pstriptris[stripcount] = tri;
        pstripverts[stripcount] = (vert + 2) % 3;

        // mark triangle as used
        m_pused[tri] = 1;
    }

    // clear the used flags
    for(int j = 2; j < stripcount; j++)
        m_pused[pstriptris[j]] = 0;

    // return swap count and striplen
    *pswaps = swaps;
    return stripcount;
}

//=========================================================================
// Given a striplist and current cache state, pick the best next strip
//=========================================================================
STRIPLIST::iterator FindBestCachedStrip(STRIPLIST *pstriplist,
    const CVertCache &vertcachestate)
{
    if(pstriplist->empty())
        return NULL;

    bool fFlipStrip = false;
    int maxcachehits = -1;
    STRIPLIST::iterator istriplistbest = pstriplist->begin();

    int striplen = StripLen(**istriplistbest);
    bool fstartcw = FIsStripCW(**istriplistbest);

    // go through all the other strips looking for the best caching
    for(STRIPLIST::iterator istriplist = pstriplist->begin();
        istriplist != pstriplist->end();
        ++istriplist)
    {
        bool fFlip = false;
        const STRIPVERTS &stripverts = **istriplist;
        int striplennew = StripLen(stripverts);

        // check cache if this strip is the same type as us (ie: cw/odd)
        if((FIsStripCW(stripverts) == fstartcw) &&
            ((striplen & 0x1) == (striplennew & 0x1)))
        {
            // copy current state of cache
            CVertCache vertcachenew = vertcachestate;

            // figure out what this guy would do to our cache
            for(int ivert = 0; ivert < striplennew; ivert++)
                vertcachenew.Add(2, stripverts[ivert]);

            // even length strip - see if better cache hits reversed
            if(!(striplennew & 0x1))
            {
                CVertCache vertcacheflipped = vertcachestate;

                for(int ivert = StripLen(stripverts) - 1; ivert >= 0; ivert--)
                    vertcacheflipped.Add(2, stripverts[ivert]);

                if(vertcacheflipped.NumCacheHits() > vertcachenew.NumCacheHits())
                {
                    vertcachenew = vertcacheflipped;
                    fFlip = true;
                }
            }

            // record the best number of cache hits to date
            int numcachehits = vertcachenew.NumCacheHits() - vertcachestate.NumCacheHits();
            if(numcachehits > maxcachehits)
            {
                maxcachehits = numcachehits;
                istriplistbest = istriplist;
                fFlipStrip = fFlip;
            }
        }
    }

    if(fFlipStrip)
    {
        STRIPVERTS &stripverts = **istriplistbest;
        int ivertmin = 0;
        int ivertmax = StripLen(stripverts) - 1;

        for(; ivertmin < ivertmax; ivertmin++, ivertmax--)
            swap(stripverts[ivertmin], stripverts[ivertmax]);
    }

    // make sure we keep the list in order and always pull off
    // the first dude.
    if(istriplistbest != pstriplist->begin())
        swap(*istriplistbest, *pstriplist->begin());

    return pstriplist->begin();
}


//=========================================================================
// Don't merge the strips - just blast em into the stripbuffer one by one
// (useful for debugging)
//=========================================================================
int CStripper::CreateManyStrips(STRIPLIST *pstriplist, WORD **ppstripindices)
{
    // allow room for each of the strips size plus the final 0
    int indexcount = pstriplist->size() + 1;

    // we're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for(STRIPLIST::iterator istriplist = pstriplist->begin();
        istriplist != pstriplist->end();
        ++istriplist)
    {
        // add striplength plus potential degenerate to swap ccw --> cw
        indexcount += StripLen(**istriplist) + 1;
    }

    // alloc the space for all this stuff
    WORD *pstripindices = new WORD [indexcount];
    assert(pstripindices);

    CVertCache vertcache;
    int numstripindices = 0;

    for(istriplist = pstriplist->begin();
        !pstriplist->empty();
        istriplist = FindBestCachedStrip(pstriplist, vertcache))
    {
        const STRIPVERTS &stripverts = **istriplist;

        if(!FIsStripCW(stripverts))
        {
            // add an extra index if it's ccw
            pstripindices[numstripindices++] = StripLen(stripverts) + 1;
            pstripindices[numstripindices++] = stripverts[0];
        }
        else
        {
            // add the strip length
            pstripindices[numstripindices++] = (WORD)StripLen(stripverts);
        }

        // add all the strip indices
        for(int i = 0; i < StripLen(stripverts); i++)
        {
            pstripindices[numstripindices++] = stripverts[i];
            vertcache.Add(1, stripverts[i]);
        }

        // free this guy and pop him off the list
        delete &stripverts;
        pstriplist->pop_front();
    }

    // add terminating zero
    pstripindices[numstripindices++] = 0;
    *ppstripindices = pstripindices;

    return numstripindices;
}

//=========================================================================
// Merge striplist into one big uberlist with (hopefully) optimal caching
//=========================================================================
int CStripper::CreateLongStrip(STRIPLIST *pstriplist, WORD **ppstripindices)
{
    // allow room for one strip length plus a possible 3 extra indices per
    // concatenated strip list plus the final 0
    int indexcount = (pstriplist->size() * 3) + 2;

    // we're storing the strips in [size1 i1 i2 i3][size2 i4 i5 i6][0] format
    for(STRIPLIST::iterator istriplist = pstriplist->begin();
        istriplist != pstriplist->end();
        ++istriplist)
    {
        indexcount += StripLen(**istriplist);
    }

    // alloc the space for all this stuff
    WORD *pstripindices = new WORD [indexcount];
    assert(pstripindices);

    CVertCache vertcache;
    int numstripindices = 0;

    // add first strip
    istriplist = pstriplist->begin();
    const STRIPVERTS &stripverts = **istriplist;

    // first strip should be cw
    assert(FIsStripCW(stripverts));

    for(int ivert = 0; ivert < StripLen(stripverts); ivert++)
    {
        pstripindices[numstripindices++] = stripverts[ivert];
        vertcache.Add(1, stripverts[ivert]);
    }

    // kill first dude
    delete &stripverts;
    pstriplist->erase(istriplist);

    // add all the others
    while(pstriplist->size())
    {
        istriplist = FindBestCachedStrip(pstriplist, vertcache);
        STRIPVERTS &stripverts = **istriplist;
        short lastvert = pstripindices[numstripindices - 1];
        short firstvert = stripverts[0];

        if(firstvert != lastvert)
        {
            // add degenerate from last strip
            pstripindices[numstripindices++] = lastvert;

            // add degenerate from our strip
            pstripindices[numstripindices++] = firstvert;
        }

        // if we're not orientated correctly, we need to add a degenerate
        if(FIsStripCW(stripverts) != !(numstripindices & 0x1))
        {
            // This shouldn't happen - we're currently trying very hard
            // to keep everything oriented correctly.
            assert(false);
            pstripindices[numstripindices++] = firstvert;
        }

        // add these verts
        for(int ivert = 0; ivert < StripLen(stripverts); ivert++)
        {
            pstripindices[numstripindices++] = stripverts[ivert];
            vertcache.Add(1, stripverts[ivert]);
        }

        // free these guys
        delete &stripverts;
        pstriplist->erase(istriplist);
    }

    *ppstripindices = pstripindices;
    return numstripindices;
}

//=========================================================================
// Build a (hopefully) optimal set of strips from a trilist
//=========================================================================
void CStripper::BuildStrips(STRIPLIST *pstriplist, int maxlen, bool flookahead)
{
    // temp indices storage
    const int ctmpverts = 1024;
    int pstripverts[ctmpverts + 1];
    int pstriptris[ctmpverts + 1];

    assert(maxlen <= ctmpverts);

    // clear all the used flags for the tris
    memset(m_pused, 0, sizeof(m_pused[0]) * m_numtris);

    bool fstartcw = true;
    for(;;)
    {
        int besttri;
        int bestvert;
        float bestratio = 2.0f;
        int bestneighborcount = INT_MAX;

        for(int tri = 0; tri < m_numtris; tri++)
        {
            // if used the continue
            if(m_pused[tri])
                continue;

            // get the neighbor count
            int curneightborcount = GetNeighborCount(tri);
            assert(curneightborcount >= 0 && curneightborcount <= 3);

            // push all the singletons to the very end
            if(!curneightborcount)
                curneightborcount = 4;

            // if this guy has more neighbors than the current best - bail
            if(curneightborcount > bestneighborcount)
                continue;

            // try starting the strip with each of this tris verts
            for(int vert = 0; vert < 3; vert++)
            {
                int swaps;
                int len = CreateStrip(tri, vert, maxlen, &swaps, flookahead,
                    fstartcw, pstriptris, pstripverts);
                assert(len);

                int striplen = len - swaps;
                float ratio = (len == 3) ? 1.0f : (float)swaps / len;

                // check if this ratio is better than what we've already got for
                // this neighborcount
                if((curneightborcount < bestneighborcount) ||
                    ((curneightborcount == bestneighborcount) && (ratio < bestratio)))
                {
                    bestneighborcount = curneightborcount;

                    besttri = tri;
                    bestvert = vert;
                    bestratio = ratio;
                }

            }
        }

        // no strips found?
        if(bestneighborcount == INT_MAX)
            break;

        // recreate this strip
        int swaps;
        int len = CreateStrip(besttri, bestvert, maxlen,
            &swaps, flookahead, fstartcw, pstriptris, pstripverts);
        assert(len);

        // mark the tris on the best strip as used
        for(tri = 0; tri < len; tri++)
            m_pused[pstriptris[tri]] = 1;

        // create a new STRIPVERTS and stuff in the indices
        STRIPVERTS *pstripvertices = new STRIPVERTS(len + 1);
        assert(pstripvertices);

        // store orientation in first entry
        for(tri = 0; tri < len; tri++)
            (*pstripvertices)[tri] = m_ptriangles[pstriptris[tri]][pstripverts[tri]];
        (*pstripvertices)[len] = fstartcw;

        // store the STRIPVERTS
        pstriplist->push_back(pstripvertices);

        // if strip was odd - swap orientation
        if((len & 0x1))
            fstartcw = !fstartcw;
    }

#ifdef _DEBUG
    // make sure all tris are used
    for(int t = 0; t < m_numtris; t++)
        assert(m_pused[t]);
#endif
}

//=========================================================================
// Guesstimate on the total index count for this list of strips
//=========================================================================
int EstimateStripCost(STRIPLIST *pstriplist)
{
    int count = 0;

    for(STRIPLIST::iterator istriplist = pstriplist->begin();
        istriplist != pstriplist->end();
        ++istriplist)
    {
        // add count of indices
        count += StripLen(**istriplist);
    }

    // assume 2 indices per strip to tack all these guys together
    return count + (pstriplist->size() - 1) * 2;
}

//=========================================================================
// Initialize triangle information (edges, #neighbors, etc.)
//=========================================================================
void CStripper::InitTriangleInfo(int tri, int vert)
{
    WORD *ptriverts = &m_ptriangles[tri + 1][0];
    int vert1 = m_ptriangles[tri][(vert + 1) % 3];
    int vert2 = m_ptriangles[tri][vert];

    for(int itri = tri + 1; itri < m_numtris; itri++, ptriverts += 3)
    {
        if(m_pused[itri] != 0x7)
        {
            for(int ivert = 0; ivert < 3; ivert++)
            {
                if((ptriverts[ivert] == vert1) &&
                    (ptriverts[(ivert + 1) % 3] == vert2))
                {
                    // add the triangle info
                    m_ptriinfo[tri].neighbortri[vert] = itri;
                    m_ptriinfo[tri].neighboredge[vert] = ivert;
                    m_pused[tri] |= (1 << vert);

                    m_ptriinfo[itri].neighbortri[ivert] = tri;
                    m_ptriinfo[itri].neighboredge[ivert] = vert;
                    m_pused[itri] |= (1 << ivert);
                    return;
                }
            }
        }
    }
}

//=========================================================================
// CStripper ctor
//=========================================================================
CStripper::CStripper(int numtris, TRIANGLELIST ptriangles)
{
    // store trilist info
    m_numtris = numtris;
    m_ptriangles = ptriangles;

    m_pused = new int[numtris];
    assert(m_pused);
    m_ptriinfo = new TRIANGLEINFO[numtris];
    assert(m_ptriinfo);

    // init triinfo
    for(int itri = 0; itri < numtris; itri++)
    {
        m_ptriinfo[itri].neighbortri[0] = -1;
        m_ptriinfo[itri].neighbortri[1] = -1;
        m_ptriinfo[itri].neighbortri[2] = -1;
    }

    // clear the used flag
    memset(m_pused, 0, sizeof(m_pused[0]) * m_numtris);

    // go through all the triangles and find edges, neighbor counts
    for(itri = 0; itri < numtris; itri++)
    {
        for(int ivert = 0; ivert < 3; ivert++)
        {
            if(!(m_pused[itri] & (1 << ivert)))
                InitTriangleInfo(itri, ivert);
        }
    }

    // clear the used flags from InitTriangleInfo
    memset(m_pused, 0, sizeof(m_pused[0]) * m_numtris);
}

//=========================================================================
// CStripper dtor
//=========================================================================
CStripper::~CStripper()
{
    // free stuff
    delete [] m_pused;
    m_pused = NULL;

    delete [] m_ptriinfo;
    m_ptriinfo = NULL;
}

//=========================================================================
// Add an index to the cache - returns true if it was added, false otherwise
//=========================================================================
bool CVertCache::Add(int strip, int vertindex)
{
    // find index in cache
    for(int iCache = 0; iCache < CACHE_SIZE; iCache++)
    {
        if(vertindex == m_rgCache[iCache])
        {
            // if it's in the cache and it's from a different strip
            // change the strip to the new one and count the cache hit
            if(strip != m_rgCacheStrip[iCache])
            {
                m_cachehits++;
                m_rgCacheStrip[iCache] = strip;
                return true;
            }

            // we added this item to the cache earlier - carry on
            return false;
        }
    }

    // not in cache, add vert and strip
    m_rgCache[m_iCachePtr] = (WORD)vertindex;
    m_rgCacheStrip[m_iCachePtr] = strip;
    m_iCachePtr = (m_iCachePtr + 1) % CACHE_SIZE;
    return true;
}

#if 0
#ifdef _DEBUG
//=========================================================================
// Turn on c runtime leak checking, etc.
//=========================================================================
void EnableLeakChecking()
{
    int flCrtDbgFlags = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

    flCrtDbgFlags &=
        ~(_CRTDBG_LEAK_CHECK_DF |
        _CRTDBG_CHECK_ALWAYS_DF |
        _CRTDBG_DELAY_FREE_MEM_DF);

    // always check for memory leaks
    flCrtDbgFlags |= _CRTDBG_LEAK_CHECK_DF;

    // others you may / may not want to set
    flCrtDbgFlags |= _CRTDBG_CHECK_ALWAYS_DF;
    flCrtDbgFlags |= _CRTDBG_DELAY_FREE_MEM_DF;

    _CrtSetDbgFlag(flCrtDbgFlags);

    // all types of reports go via OutputDebugString
    _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);

    // big errors and asserts get their own assert window
    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_WNDW);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_WNDW);

    // _CrtSetBreakAlloc(0);
}
#endif // _DEBUG
#endif // #if 0

//=========================================================================
// Main Stripify routine
//=========================================================================
int Stripify(int numtris, WORD *ptriangles, int *pnumindices, WORD **ppstripindices)
{
    if(!numtris || !ptriangles)
        return 0;

#if 0
#ifdef _DEBUG
    EnableLeakChecking();
#endif //_DEBUG
#endif // #if 0

    CStripper stripper(numtris, (TRIANGLELIST)ptriangles);

    // map of various args to try stripifying mesh with
    struct ARGMAP
    {
        int     maxlen;         // maximum length of strips
        bool    flookahead;     // use sgi greedy lookahead (or not)
    } rgargmap[] =
    {
        { 1024,  true  },
        { 1024,  false },
    };
    static const int cargmaps = sizeof(rgargmap) / sizeof(rgargmap[0]);
    STRIPLIST   striplistbest;
    int         bestlistcost = 0;

    for(int imap = 0; imap < cargmaps; imap++)
    {
        STRIPLIST striplist;

        // build the strip with the various args
        stripper.BuildStrips(&striplist, rgargmap[imap].maxlen,
            rgargmap[imap].flookahead);

        // guesstimate the list cost and store it if it's good
        int listcost = EstimateStripCost(&striplist);
        if(!bestlistcost || (listcost < bestlistcost))
        {
            // free the old best list
            FreeStripListVerts(&striplistbest);

            // store the new best list
            striplistbest = striplist;
            bestlistcost = listcost;
            assert(bestlistcost > 0);
        }
        else
        {
            FreeStripListVerts(&striplist);
        }
    }

#ifdef NEVER
    // Return the strips in [size1 i1 i2 i3][size2 i4 i5 i6]...[0] format
    // Very useful for debugging...
    return stripper.CreateManyStrips(&striplistbest, ppstripindices);
#endif // NEVER

    // return one big long strip
    int numindices = stripper.CreateLongStrip(&striplistbest, ppstripindices);

    if(pnumindices)
        *pnumindices = numindices;
    return numindices;
}

//=========================================================================
// Class used to vertices for locality of access.
//=========================================================================
struct SortEntry
{
public:
    int iFirstUsed;
    int iOrigIndex;

    bool operator<(const SortEntry& rhs)
    {
        return iFirstUsed < rhs.iFirstUsed;
    }
};

//=========================================================================
// Reorder the vertices
//=========================================================================
void ComputeVertexPermutation(int numstripindices, WORD* pstripindices,
                              int* pnumverts, WORD** ppvertexpermutation)
{
    // Sort verts to maximize locality.
    SortEntry* pSortTable = new SortEntry[*pnumverts];

    // Fill in original index.
    for(int i = 0; i < *pnumverts; i++)
    {
        pSortTable[i].iOrigIndex = i;
        pSortTable[i].iFirstUsed = -1;
    }

    // Fill in first used flag.
    for(i = 0; i < numstripindices; i++)
    {
        int index = pstripindices[i];

        if(pSortTable[index].iFirstUsed == -1)
            pSortTable[index].iFirstUsed = i;
    }

    // Sort the table.
    sort(pSortTable, pSortTable + *pnumverts);

    // Copy re-mapped to orignal vertex permutaion into output array.
    *ppvertexpermutation = new WORD[*pnumverts];

    for(i = 0; i < *pnumverts; i++)
    {
        (*ppvertexpermutation)[i] = (WORD)pSortTable[i].iOrigIndex;
    }

    // Build original to re-mapped permutation.
    WORD* pInversePermutation = new WORD[numstripindices];

    for(i = 0; i < *pnumverts; i++)
    {
        pInversePermutation[pSortTable[i].iOrigIndex] = (WORD)i;
    }

    // We need to remap indices as well.
    for(i = 0; i < numstripindices; i++)
    {
        pstripindices[i] = pInversePermutation[pstripindices[i]];
    }

    delete[] pSortTable;
    delete[] pInversePermutation;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\basetexture.cpp ===
//-----------------------------------------------------------------------------
// File: BaseTexture.cpp
//
// Desc: Contains the basic texture-specific logic for the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <stdio.h>
#include "BaseTexture.h"
#include "Bundler.h"
#include "LoadImage.h"
#include "xgraphics.h"




// Texture formats
const FORMATSPEC g_TextureFormats[] = 
{
    // Format name           Xbox save format        Type           #alphabits
    { "D3DFMT_A8R8G8B8",     X_D3DFMT_A8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8R8G8B8",     X_D3DFMT_X8R8G8B8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_A8B8G8R8",     X_D3DFMT_A8B8G8R8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_B8G8R8A8",     X_D3DFMT_B8G8R8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_R8G8B8A8",     X_D3DFMT_R8G8B8A8,      FMT_SWIZZLED,   8    },
    { "D3DFMT_X8L8V8U8",     X_D3DFMT_X8L8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_Q8W8V8U8",     X_D3DFMT_Q8W8V8U8,      FMT_SWIZZLED,   0    },
    { "D3DFMT_V16U16  ",     X_D3DFMT_V16U16,        FMT_SWIZZLED,   0    },
    { "D3DFMT_A4R4G4B4",     X_D3DFMT_A4R4G4B4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_R4G4B4A4",     X_D3DFMT_R4G4B4A4,      FMT_SWIZZLED,   4    },
    { "D3DFMT_X1R5G5B5",     X_D3DFMT_X1R5G5B5,      FMT_SWIZZLED,   0    },
    { "D3DFMT_A1R5G5B5",     X_D3DFMT_A1R5G5B5,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G5B5A1",     X_D3DFMT_R5G5B5A1,      FMT_SWIZZLED,   1    },
    { "D3DFMT_R5G6B5",       X_D3DFMT_R5G6B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R6G5B5",       X_D3DFMT_R6G5B5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_L6V5U5",       X_D3DFMT_L6V5U5,        FMT_SWIZZLED,   0    },
    { "D3DFMT_R8B8",         X_D3DFMT_R8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_G8B8",         X_D3DFMT_G8B8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_V8U8",         X_D3DFMT_V8U8,          FMT_SWIZZLED,   0    },
    { "D3DFMT_A8L8",         X_D3DFMT_A8L8,          FMT_SWIZZLED,   8    },
    { "D3DFMT_AL8",          X_D3DFMT_AL8,           FMT_SWIZZLED,   8    },
    { "D3DFMT_A8",           X_D3DFMT_A8,            FMT_SWIZZLED,   8    },
    { "D3DFMT_L8",           X_D3DFMT_L8,            FMT_SWIZZLED,   0    },
//  { "D3DFMT_P8",           X_D3DFMT_P8,            FMT_SWIZZLED,   8    }, // Bundler doesn't support (yet)
    { "D3DFMT_L16",          X_D3DFMT_L16,           FMT_SWIZZLED,   0    },
    { "D3DFMT_DXT1",         X_D3DFMT_DXT1,          FMT_COMPRESSED, 1    },
    { "D3DFMT_DXT2",         X_D3DFMT_DXT2,          FMT_COMPRESSED, 8    },
//  { "D3DFMT_DXT3",         X_D3DFMT_DXT3,          FMT_COMPRESSED, 8    }, // Not supported on Xbox
    { "D3DFMT_DXT4",         X_D3DFMT_DXT4,          FMT_COMPRESSED, 8    },
//  { "D3DFMT_DXT5",         X_D3DFMT_DXT5,          FMT_COMPRESSED, 8    }, // Not supported on Xbox
    { "D3DFMT_LIN_A8B8G8R8", X_D3DFMT_LIN_A8B8G8R8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_A8R8G8B8", X_D3DFMT_LIN_A8R8G8B8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_B8G8R8A8", X_D3DFMT_LIN_B8G8R8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_R8G8B8A8", X_D3DFMT_LIN_R8G8B8A8,  FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_X8R8G8B8", X_D3DFMT_LIN_X8R8G8B8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_X8L8V8U8", X_D3DFMT_LIN_X8L8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_Q8W8V8U8", X_D3DFMT_LIN_Q8W8V8U8,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_V16U16",   X_D3DFMT_LIN_V16U16,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A4R4G4B4", X_D3DFMT_LIN_A4R4G4B4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_R4G4B4A4", X_D3DFMT_LIN_R4G4B4A4,  FMT_LINEAR    , 4    },
    { "D3DFMT_LIN_A1R5G5B5", X_D3DFMT_LIN_A1R5G5B5,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_R5G5B5A1", X_D3DFMT_LIN_R5G5B5A1,  FMT_LINEAR    , 1    },
    { "D3DFMT_LIN_X1R5G5B5", X_D3DFMT_LIN_X1R5G5B5,  FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R5G6B5",   X_D3DFMT_LIN_R5G6B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R6G5B5",   X_D3DFMT_LIN_R6G5B5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L6V5U5",   X_D3DFMT_LIN_L6V5U5,    FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_G8B8",     X_D3DFMT_LIN_G8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_R8B8",     X_D3DFMT_LIN_R8B8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8L8",     X_D3DFMT_LIN_A8L8,      FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_V8U8",     X_D3DFMT_LIN_V8U8,      FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_AL8",      X_D3DFMT_LIN_AL8,       FMT_LINEAR    , 8    },
    { "D3DFMT_LIN_L16",      X_D3DFMT_LIN_L16,       FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_L8",       X_D3DFMT_LIN_L8,        FMT_LINEAR    , 0    },
    { "D3DFMT_LIN_A8",       X_D3DFMT_LIN_A8,        FMT_LINEAR    , 8    },
};




//-----------------------------------------------------------------------------
// Name: ConvertTextureFormat()
// Desc: 
// TODO: Make this handle the pitch requirements of small textures
//-----------------------------------------------------------------------------
HRESULT ConvertTextureFormat( VOID* pSrcData, 
                              DWORD dwWidth, DWORD dwHeight, DWORD dwDepth, 
                              VOID* pDstData, DWORD dwDstFormat )
{
    // Create convenient access ptrs
    DWORD* pSrcData32 = (DWORD*)pSrcData;
    BYTE*  pDstData8  =  (BYTE*)pDstData;
    WORD*  pDstData16 =  (WORD*)pDstData;
    DWORD* pDstData32 = (DWORD*)pDstData;

    // Look through all pixels
    for( DWORD z=0; z<dwDepth; z++ )
    {
        for( DWORD y=0; y<dwHeight; y++ )
        {
            for( DWORD x=0; x<dwWidth; x++ )
            {
                // Read src pixel
                FLOAT a = (((*pSrcData32)&0xff000000)>>24L)/255.0f;
                FLOAT r = (((*pSrcData32)&0x00ff0000)>>16L)/255.0f;
                FLOAT g = (((*pSrcData32)&0x0000ff00)>> 8L)/255.0f;
                FLOAT b = (((*pSrcData32)&0x000000ff)>> 0L)/255.0f;
                pSrcData32++;

                // Assign values to non-ARGB channels
                FLOAT q = a;
                FLOAT w = r;
                FLOAT v = g;
                FLOAT u = b;
                FLOAT l = (r+g+b)/3;

                // Write dst pixel
                switch( dwDstFormat )
                {
                    case X_D3DFMT_A8R8G8B8:     // case X_D3DFMT_Q8W8V8U8:
                    case X_D3DFMT_LIN_A8R8G8B8: // case X_D3DFMT_LIN_Q8W8V8U8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_X8R8G8B8:     // case X_D3DFMT_X8L8V8U8:
                    case X_D3DFMT_LIN_X8R8G8B8: // case X_D3DFMT_LIN_X8L8V8U8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8B8G8R8:
                    case X_D3DFMT_LIN_A8B8G8R8:
                        (*pDstData32++) = (((DWORD)(a*0xff))<<24L) | 
                                          (((DWORD)(b*0xff))<<16L) | 
                                          (((DWORD)(g*0xff))<< 8L) | 
                                          (((DWORD)(r*0xff))<< 0L);
                        break;
                    case X_D3DFMT_B8G8R8A8:
                    case X_D3DFMT_LIN_B8G8R8A8:
                        (*pDstData32++) = (((DWORD)(b*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(r*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_R8G8B8A8:
                    case X_D3DFMT_LIN_R8G8B8A8:
                        (*pDstData32++) = (((DWORD)(r*0xff))<<24L) | 
                                          (((DWORD)(g*0xff))<<16L) | 
                                          (((DWORD)(b*0xff))<< 8L) | 
                                          (((DWORD)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A1R5G5B5:
                    case X_D3DFMT_LIN_A1R5G5B5:
                        (*pDstData16++) = (((WORD)(a*0x01))<<15L) | 
                                          (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_X1R5G5B5:
                    case X_D3DFMT_LIN_X1R5G5B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R5G5B5A1:
                    case X_D3DFMT_LIN_R5G5B5A1:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x1f))<< 6L) | 
                                          (((WORD)(b*0x1f))<< 1L) | 
                                          (((WORD)(a*0x01))<< 0L);
                        break;
                    case X_D3DFMT_R5G6B5:
                    case X_D3DFMT_LIN_R5G6B5:
                        (*pDstData16++) = (((WORD)(r*0x1f))<<11L) | 
                                          (((WORD)(g*0x3f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_R6G5B5:     // case X_D3DFMT_L6V5U5:
                    case X_D3DFMT_LIN_R6G5B5: // case X_D3DFMT_LIN_L6V5U5:
                        (*pDstData16++) = (((WORD)(r*0x3f))<<10L) | 
                                          (((WORD)(g*0x1f))<< 5L) | 
                                          (((WORD)(b*0x1f))<< 0L);
                        break;
                    case X_D3DFMT_A4R4G4B4:
                    case X_D3DFMT_LIN_A4R4G4B4:
                        (*pDstData16++) = (((WORD)(a*0x0f))<<12L) | 
                                          (((WORD)(r*0x0f))<< 8L) | 
                                          (((WORD)(g*0x0f))<< 4L) | 
                                          (((WORD)(b*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R4G4B4A4:
                    case X_D3DFMT_LIN_R4G4B4A4:
                        (*pDstData16++) = (((WORD)(r*0x0f))<<12L) | 
                                          (((WORD)(g*0x0f))<< 8L) | 
                                          (((WORD)(b*0x0f))<< 4L) | 
                                          (((WORD)(a*0x0f))<< 0L);
                        break;
                    case X_D3DFMT_R8B8:
                    case X_D3DFMT_LIN_R8B8:
                        (*pDstData16++) = (((WORD)(r*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_G8B8:     // case X_D3DFMT_V8U8:
                    case X_D3DFMT_LIN_G8B8: // case X_D3DFMT_LIN_V8U8:
                        (*pDstData16++) = (((WORD)(g*0xff))<< 8L) | 
                                          (((WORD)(b*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8L8:
                    case X_D3DFMT_LIN_A8L8:
                        (*pDstData16++) = (((WORD)(a*0xff))<< 8L) | 
                                          (((WORD)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_L16:
                    case X_D3DFMT_LIN_L16:
                        (*pDstData16++) = (((WORD)(l*0xffff))<< 0L);
                        break;
                    case X_D3DFMT_L8:
                    case X_D3DFMT_LIN_L8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_A8:
                    case X_D3DFMT_LIN_A8:
                        (*pDstData8++)  = (((BYTE)(a*0xff))<< 0L);
                        break;
                    case X_D3DFMT_AL8:
                    case X_D3DFMT_LIN_AL8:
                        (*pDstData8++)  = (((BYTE)(l*0xff))<< 0L);
                        break;
                    case X_D3DFMT_V16U16:
                    case X_D3DFMT_LIN_V16U16:
                        (*pDstData32++) = (((DWORD)(v*0xffff))<<16L) | 
                                          (((DWORD)(u*0xffff))<< 0L);
                        break;
                }
            }
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: CBaseTexture()
// Desc: Initializes member variables
//-----------------------------------------------------------------------------
CBaseTexture::CBaseTexture( CBundler * pBundler )
{
    m_strFormat[0] = '\0';
    m_nFormat      = -1;
    m_dwFilter     = D3DX_FILTER_TRIANGLE;
    m_dwLevels     = 1;
    m_pBundler     = pBundler;
}




//-----------------------------------------------------------------------------
// Name: ~CBaseTexture()
// Desc: Performs any cleanup needed before the object is destroyed
//-----------------------------------------------------------------------------
CBaseTexture::~CBaseTexture()
{
}




//-----------------------------------------------------------------------------
// Name: FormatFromString()
// Desc: Returns an index into the format spec array corresponding to the
//       given string
//-----------------------------------------------------------------------------
int CBaseTexture::FormatFromString( char * strFormat )
{
    int nFormats = sizeof( g_TextureFormats ) / sizeof( g_TextureFormats[0] );
    int i;

    if( strFormat[0] == 0 )
        return 0;

    for( i = 0; i < nFormats; i++ )
    {
        if( !lstrcmpi( strFormat, g_TextureFormats[i].strFormat ) )
            return i;
    }

    return -2;
}




//-----------------------------------------------------------------------------
// Name: LoadSurface()
// Desc: Loads source and alphasource surfaces
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::LoadSurface( CHAR* strSource, CHAR* strAlphaSource, 
                                   LPDIRECT3DSURFACE8* ppSurface )
{
    CImage             ColorImage;
    CImage             AlphaImage;
    LPDIRECT3DSURFACE8 pOrigColorSurface;
    LPDIRECT3DSURFACE8 pOrigAlphaSurface;
    LPDIRECT3DSURFACE8 pResizedColorSurface;
    LPDIRECT3DSURFACE8 pResizedAlphaSurface;
    D3DLOCKED_RECT     lock;
    HRESULT hr; 

    // Load the texture from the source file
    hr = ColorImage.Load( strSource );
    if( FAILED( hr ) )
    {
        m_pBundler->ErrorMsg( "Couldn't load image from <%s>\n", strSource );
        return hr;
    }

    // Depalettize any palettized images
    if( D3DFMT_P8 == ColorImage.m_Format )
        ColorImage.Depalettize();

    // Create a surface for the image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( ColorImage.m_Width, ColorImage.m_Height,
                                                       ColorImage.m_Format, &pOrigColorSurface );
    pOrigColorSurface->LockRect( &lock, 0, 0 );
    memcpy( lock.pBits, ColorImage.m_pData, ColorImage.m_Pitch * ColorImage.m_Height );
    pOrigColorSurface->UnlockRect();

    if( strAlphaSource[0] )
    {
        // Load the texture from the alpha source file
        hr = AlphaImage.Load( strAlphaSource );
        if( FAILED( hr ) )
        {
            m_pBundler->ErrorMsg( "Couldn't load image from <%s>\n", strAlphaSource );
            return hr;
        }

        // Can't currently deal with palettized images
        if( D3DFMT_P8 == AlphaImage.m_Format )
        {
            m_pBundler->ErrorMsg( "The bundler can not handled the palettized image, <%s>\n", strAlphaSource );
            return E_FAIL;
        }

        hr = m_pBundler->m_pd3ddev->CreateImageSurface( AlphaImage.m_Width, AlphaImage.m_Height,
                                                           AlphaImage.m_Format, &pOrigAlphaSurface );
        pOrigAlphaSurface->LockRect( &lock, 0, 0 );
        memcpy( lock.pBits, AlphaImage.m_pData, AlphaImage.m_Pitch * AlphaImage.m_Height );
        pOrigAlphaSurface->UnlockRect();
    }

    // Determine final texture size
    DWORD dwWidth  = ColorImage.m_Width;
    DWORD dwHeight = ColorImage.m_Height;
    
    if( strAlphaSource[0] )
    {
        if( dwWidth  < AlphaImage.m_Width  )   dwWidth  = AlphaImage.m_Width;
        if( dwHeight < AlphaImage.m_Height )   dwHeight = AlphaImage.m_Height;
    }

    // Do the size conversion for the source image
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                       &pResizedColorSurface );

    hr = D3DXLoadSurfaceFromSurface( pResizedColorSurface, NULL, NULL, 
                                     pOrigColorSurface, ColorImage.m_pPalette, NULL,
                                     m_dwFilter, 0 );

    if( strAlphaSource[0] )
    {
        // Do the size conversion for the alpha source image
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                           &pResizedAlphaSurface );

        hr = D3DXLoadSurfaceFromSurface( pResizedAlphaSurface, NULL, NULL, 
                                         pOrigAlphaSurface, AlphaImage.m_pPalette, NULL,
                                         m_dwFilter, 0 );
    }

    // Merge in the alpha channel
    if( strAlphaSource[0] )
    {
        D3DLOCKED_RECT lockColor;
        D3DLOCKED_RECT lockAlpha;
        hr = pResizedColorSurface->LockRect( &lockColor, NULL, 0 );
        hr = pResizedAlphaSurface->LockRect( &lockAlpha, NULL, 0 );

        DWORD* pColorBits = (DWORD*)lockColor.pBits;
        DWORD* pAlphaBits = (DWORD*)lockAlpha.pBits;

        for( DWORD yp = 0; yp < dwHeight; yp++ )
        {
            for( DWORD xp = 0; xp < dwWidth; xp++ )
            {
                DWORD dwAlpha = (*pAlphaBits) << 24;
                (*pColorBits) &= 0x00ffffff;
                (*pColorBits) |= dwAlpha;

                pColorBits++;
                pAlphaBits++;
            }
        }

        pResizedColorSurface->UnlockRect();
        pResizedAlphaSurface->UnlockRect();
    }
        
    // Return the surface in the output parameter
    (*ppSurface) = pResizedColorSurface;
    (*ppSurface)->AddRef();

    // Release the color surfaces
    pOrigColorSurface->Release();
    pResizedColorSurface->Release();

    // Release the alpha surfaces
    if( strAlphaSource[0] )
    {
        pOrigAlphaSurface->Release();
        pResizedAlphaSurface->Release();
    }

    return S_OK;
}



//-----------------------------------------------------------------------------
// Name: ResizeSurface()
// Desc: Convert the surface to the new width, height, and format
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::ResizeSurface( DWORD dwWidth, DWORD dwHeight, 
                                     LPDIRECT3DSURFACE8* ppSurface )
{
    LPDIRECT3DSURFACE8 pOldSurface = (*ppSurface);
    HRESULT hr; 

    // Do the size/format conversion for the final surface
    hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, D3DFMT_A8R8G8B8,
                                                    ppSurface );

    hr = D3DXLoadSurfaceFromSurface( (*ppSurface), NULL, NULL, 
                                     pOldSurface, NULL, NULL,
                                     m_dwFilter, 0 );

    // Release the old surface
    pOldSurface->Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: WriteSwizzledTextureData()
// Desc: Swizzles the texture data to NVidia's swizzled format.  
//       XGSwizzleRect requires that the memory being swizzled to is 16-byte
//       aligned.
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
                                              DWORD dwHeight, DWORD dwDepth )
{
    DWORD  dwBytesPerPixel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD  dwPitch         = (dwWidth*dwBytesPerPixel+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD  dwTextureSize   = dwPitch * dwHeight * dwDepth;
    BYTE*  pBitsUnaligned  = new BYTE[ dwTextureSize + 16 ];
    int    temp      = (int)pBitsUnaligned;
    BYTE*  pBitsTemp = (BYTE*)(( temp + 15 ) & ~15);   // 16-byte aligned ptr.

    // Swizzle the data into a temporary buffer, and then copy it back
    XGSwizzleBox( pBits, 0, 0, NULL, pBitsTemp, dwWidth, dwHeight, dwDepth,
                  NULL, dwBytesPerPixel );

    if( FAILED( m_pBundler->WriteData( pBitsTemp, dwTextureSize ) ) )
        return 0;

    delete[] pBitsUnaligned;

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: WriteCompressedTextureData()
// Desc: Compresses the texture data
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteCompressedTextureData( VOID* pSrcBits, DWORD dwWidth, 
                                                DWORD dwHeight, DWORD dwDepth )
{
    DWORD dwBlockSize;
    DWORD dwCompressedSize;
    DWORD dwSrcPitch   = (dwWidth*4+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    BOOL  bPreMultiply = g_TextureFormats[m_nFormat].strFormat[10] == '2' ||
                         g_TextureFormats[m_nFormat].strFormat[10] == '4';

    switch( g_TextureFormats[m_nFormat].dwXboxFormat )
    {
        case X_D3DFMT_DXT1: 
            dwBlockSize      = 8;
            dwCompressedSize = dwWidth*dwHeight/2; 
            break;
        case X_D3DFMT_DXT2:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        case X_D3DFMT_DXT4:
            dwBlockSize      = 16;
            dwCompressedSize = dwWidth*dwHeight; 
            break;
        default:
            return E_FAIL;
    }

    // Allocate space for the compressed data
    BYTE* pCompressedData = new BYTE[dwDepth*dwCompressedSize];
    BYTE* pDstBits        = pCompressedData;

    for( DWORD i=0; i<dwDepth; i++ )
    {
        // Compress the data
        if( FAILED( XGCompressRect( pDstBits,
                                    D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat),
                                    0, dwWidth, dwHeight, pSrcBits, 
                                    D3DFORMAT(X_D3DFMT_LIN_A8R8G8B8), 
                                    dwSrcPitch, 0.5,
                                    bPreMultiply ? XGCOMPRESS_PREMULTIPLY : 0 ) ) )
            return 0;

        pSrcBits = (BYTE*)pSrcBits + dwSrcPitch*dwHeight;
        pDstBits = (BYTE*)pDstBits + dwCompressedSize;
    }

    if( dwDepth == 1 )
    {
        // Write the compressed data
        if( FAILED( m_pBundler->WriteData( pCompressedData, dwDepth*dwCompressedSize ) ) )
            return 0;
    }
    else
    {
        // For volume textures, compressed blocks are stored in block linear
        // format, so we need to write them in the correct order.
        DWORD dwNumXBlocks = dwWidth/4;
        DWORD dwNumYBlocks = dwHeight/4;
        DWORD dwNumWBlocks = (dwDepth<4) ? 1 : dwDepth/4;

        for( DWORD w=0; w<dwDepth; w+=4 )
        {
            for( DWORD by=0; by<dwNumYBlocks; by++ )
            {
                for( DWORD bx=0; bx<dwNumXBlocks; bx++ )
                {
                    BYTE* pBits0 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+0)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits1 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+1)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits2 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+2)*dwNumXBlocks*dwNumYBlocks ) ];
                    BYTE* pBits3 = &pCompressedData[ dwBlockSize * ( bx + by*dwNumXBlocks + (w+3)*dwNumXBlocks*dwNumYBlocks ) ];
    
                    // Write the compressed data
                    if( dwDepth >= 1 ) 
                        m_pBundler->WriteData( pBits0, dwBlockSize );
                    if( dwDepth >= 2 ) 
                        m_pBundler->WriteData( pBits1, dwBlockSize );
                    if( dwDepth >= 3 ) 
                        m_pBundler->WriteData( pBits2, dwBlockSize );
                    if( dwDepth >= 4 ) 
                        m_pBundler->WriteData( pBits3, dwBlockSize );
                }
            }
        }
    }

    // Cleanup
    delete[] pCompressedData;

    // Return the number of bytes written
    return dwDepth*dwCompressedSize;
}




//-----------------------------------------------------------------------------
// Name: WriteLinearTextureData()
// Desc: 
//-----------------------------------------------------------------------------
DWORD CBaseTexture::WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
                                            DWORD dwHeight, DWORD dwDepth )
{
    DWORD dwBytesPerPixel = XGBytesPerPixelFromFormat( D3DFORMAT(g_TextureFormats[m_nFormat].dwXboxFormat) );
    DWORD dwPitch         = (dwWidth*dwBytesPerPixel+D3DTEXTURE_PITCH_ALIGNMENT-1)&~(D3DTEXTURE_PITCH_ALIGNMENT-1);
    DWORD dwTextureSize   = dwPitch * dwHeight * dwDepth;

    if( FAILED( m_pBundler->WriteData( pBits, dwTextureSize ) ) )
        return 0;

    return dwTextureSize;
}




//-----------------------------------------------------------------------------
// Name: SaveSurface()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveSurface( DWORD* pcbData, DWORD dwLevels, 
                                   LPDIRECT3DSURFACE8 pSurface )
{
    D3DSURFACE_DESC desc;
    HRESULT hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    pSurface->GetDesc( &desc );
    DWORD dwWidth  = desc.Width;
    DWORD dwHeight = desc.Height;

    // Allocate memory for converting the surface format
    VOID* pSurfaceData = (VOID*)new BYTE[dwWidth*dwHeight*4];

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        // Create the mipmap
        LPDIRECT3DSURFACE8 pMipmapLevel;
        hr = m_pBundler->m_pd3ddev->CreateImageSurface( dwWidth, dwHeight, desc.Format,
                                                        &pMipmapLevel );
        hr = D3DXLoadSurfaceFromSurface( pMipmapLevel, NULL, NULL, 
                                         pSurface, NULL, NULL,
                                         m_dwFilter, 0 );

        // Lock the surface data
        D3DLOCKED_RECT  lock;
        hr = pMipmapLevel->LockRect( &lock, NULL, D3DLOCK_READONLY );
        if( FAILED( hr ) )
            return hr;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( lock.pBits, dwWidth, dwHeight, 1 );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( lock.pBits, dwWidth, dwHeight, 1,
                                  pSurfaceData, g_TextureFormats[m_nFormat].dwXboxFormat );

            if( g_TextureFormats[m_nFormat].Type == FMT_SWIZZLED )
            {
                // If we're writing a swizzled format, swizzle the texture data
                (*pcbData) += WriteSwizzledTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
            else
            {
                // Write out linear surface data
                (*pcbData) += WriteLinearTextureData( pSurfaceData, dwWidth, dwHeight, 1 );
            }
        }

        pMipmapLevel->UnlockRect();

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;

        // Release the mipmap level
        pMipmapLevel->Release();
    }

    // Cleanup
    delete[] pSurfaceData;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: SaveVolumeTexture()
// Desc: Saves the raw surface data to the XPR file
//-----------------------------------------------------------------------------
HRESULT CBaseTexture::SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, 
                                         LPDIRECT3DVOLUMETEXTURE8 pVolumeTexture )
{
    D3DVOLUME_DESC desc;
    HRESULT        hr;

    // Pad data file to proper alignment for the start of the texture
    hr = m_pBundler->PadToAlignment( D3DTEXTURE_ALIGNMENT );
    if( FAILED( hr ) )
        return hr;

    // Get the surface desc, used to create mipmap levels
    pVolumeTexture->GetLevelDesc( 0, &desc );
    DWORD dwWidth  = desc.Width;
    DWORD dwHeight = desc.Height;
    DWORD dwDepth  = desc.Depth;

    // Get the source volume
    LPDIRECT3DVOLUME8 pSrcVolume;
    pVolumeTexture->GetVolumeLevel( 0, &pSrcVolume );

    // Allocate memory for converting the surface format
    VOID* pVolumeData = (VOID*)new BYTE[dwWidth*dwHeight*dwDepth*4];

    // Create a temporary destination volumetexture
    LPDIRECT3DVOLUMETEXTURE8 pDstVolumeTexture;
    hr = m_pBundler->m_pd3ddev->CreateVolumeTexture( dwWidth, dwHeight, dwDepth, dwLevels, 0, desc.Format,
                                                     D3DPOOL_SYSTEMMEM, &pDstVolumeTexture );

    // Loop over each mipmap level of the texture
    for( DWORD dwLevel = 0; dwLevel < dwLevels; dwLevel++ )
    {
        // Create the mipmap
        LPDIRECT3DVOLUME8 pDstVolume;
        pDstVolumeTexture->GetVolumeLevel( dwLevel, &pDstVolume );
        hr = D3DXLoadVolumeFromVolume( pDstVolume, NULL, NULL, 
                                       pSrcVolume, NULL, NULL,
                                       m_dwFilter, 0 );

        // Lock the volume data
        D3DLOCKED_BOX lock;
        hr = pDstVolume->LockBox( &lock, NULL, D3DLOCK_READONLY );
        if( FAILED( hr ) )
            return hr;

        if( g_TextureFormats[m_nFormat].Type == FMT_COMPRESSED )
        {
            // If we're writing a compressed format, compress the texture data
            (*pcbData) += WriteCompressedTextureData( lock.pBits, dwWidth, 
                                                      dwHeight, dwDepth );
        }
        else
        {
            // Convert the surface data to the destination format
            ConvertTextureFormat( lock.pBits, dwWidth, dwHeight, dwDepth,
                                  pVolumeData, g_TextureFormats[m_nFormat].dwXboxFormat );

            // If we're writing a swizzled format, swizzle the texture data
            (*pcbData) += WriteSwizzledTextureData( pVolumeData, dwWidth, dwHeight, dwDepth );
        }

        pDstVolume->UnlockBox();

        // Shrink dimensions down to next lower mipmap level
        if( dwWidth >= 2 )
            dwWidth >>= 1;
        if( dwHeight >= 2 )
            dwHeight >>= 1;
        if( dwDepth >= 2 )
            dwDepth >>= 1;

        // Release the mipmap level
        pDstVolume->Release();
    }

    // Cleanup
    delete[] pVolumeData;
    pDstVolumeTexture->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xipsign\xipsign.c ===
#define BUILD_XIPSIGN
#include <windows.h>
#include <xcrypt.h>
#include <xip.h>
#include <stdio.h>
#include <stdlib.h>

int __cdecl main(int argc, char **argv)
{
    XIP_PROTECTION xipp;
    XIP_SIG xsig;
    HANDLE hOut;
    HANDLE hIn = INVALID_HANDLE_VALUE;
    int nRet = 1;
    BYTE rgb[65536];
    DWORD cb;
    int i;
    LPCSTR szOutputName;
    int ich;

    if(argc < 3) {
        fprintf(stderr, "usage: xipsign <output-file> <input.xip> ...\n");
        exit(1);
    }

    argc -= 2;
    argv += 2;

    __try {
        szOutputName = argv[-1];
        hOut = CreateFile(szOutputName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
            0, NULL);
        if(hOut == INVALID_HANDLE_VALUE) {
            fprintf(stderr, "error X0000: cannot open %s\n", szOutputName);
            __leave;
        }

        while(argc--) {
            hIn = CreateFile(*argv++, GENERIC_READ, 0, NULL, OPEN_EXISTING,
                0, NULL);
            if(hIn == INVALID_HANDLE_VALUE) {
                fprintf(stderr, "error X0000: cannot open %s\n", argv[-1]);
                __leave;
            }

            /* Construct the sig header.  Note that we're stupid about the
             * filename and always use the pathname we were given -- we don't
             * strip off any directories */
            memset(&xipp, 0, sizeof xipp);
            for(ich = 0; argv[-1][ich] && ich < (sizeof xipp.Name / sizeof xipp.Name[0] - 1); ++ich)
                xipp.Name[ich] = argv[-1][ich];
            xipp.SignatureCount = (GetFileSize(hIn, NULL) + 65535) / 65536;

            /* Write out this portion of the header */
            if(!WriteFile(hOut, &xipp, sizeof xipp, &cb, NULL)) {
writeerr:
                fprintf(stderr, "error X0000: error writing to %s\n",
                    szOutputName);
                __leave;
            }

            /* Read the data in 64k chunks and write out each digest we get */
            for(i = xipp.SignatureCount; i--; ) {
                if(!ReadFile(hIn, rgb, sizeof rgb, &cb, NULL) ||
                    (cb < sizeof rgb && i != 0))
                {
                    fprintf(stderr, "error X0000: error reading %s\n",
                        argv[-1]);
                    __leave;
                }
                printf("%s chunk %d: %d\n", argv[-1], xipp.SignatureCount - i - 1,
                    cb);
                XCCalcDigest(rgb, cb, xsig.Signature);
                if(!WriteFile(hOut, &xsig, sizeof xsig, &cb, NULL))
                    goto writeerr;
            }
            CloseHandle(hIn);
            hIn = INVALID_HANDLE_VALUE;
        }

        /* Spit out an empty header to mark the end of the list */
        memset(&xipp, 0, sizeof xipp);
        if(!WriteFile(hOut, &xipp, sizeof xipp, &cb, NULL))
            goto writeerr;
        nRet = 0;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        fprintf(stderr, "error X0000: exception %08X occurred\n",
            GetExceptionCode());
    }

    if(hIn != INVALID_HANDLE_VALUE)
        CloseHandle(hIn);

    CloseHandle(hOut);

    if(nRet)
        DeleteFile(szOutputName);

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\basetexture.h ===
//-----------------------------------------------------------------------------
// File: BaseTexture.h
//
// Desc: Header file containing class, struct, and constant definitions
//       for the basic texture-related functionality of the bundler tool
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef BASETEXTURE_H
#define BASETEXTURE_H

#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>


class CBundler;


// Xbox-specific defines, taken from d3d8types-xbox.h and d3d8-xbox.h
#define X_D3DFMT_A8R8G8B8              0x00000006
#define X_D3DFMT_X8R8G8B8              0x00000007
#define X_D3DFMT_R5G6B5                0x00000005
#define X_D3DFMT_R6G5B5                0x00000027
#define X_D3DFMT_X1R5G5B5              0x00000003
#define X_D3DFMT_A1R5G5B5              0x00000002
#define X_D3DFMT_A4R4G4B4              0x00000004
#define X_D3DFMT_A8                    0x00000019
#define X_D3DFMT_A8B8G8R8              0x0000003A   
#define X_D3DFMT_B8G8R8A8              0x0000003B   
#define X_D3DFMT_R4G4B4A4              0x00000039   
#define X_D3DFMT_R5G5B5A1              0x00000038   
#define X_D3DFMT_R8G8B8A8              0x0000003C   
#define X_D3DFMT_R8B8                  0x00000029   
#define X_D3DFMT_G8B8                  0x00000028   
#define X_D3DFMT_P8                    0x0000000B
#define X_D3DFMT_L8                    0x00000000
#define X_D3DFMT_A8L8                  0x0000001A
#define X_D3DFMT_AL8                   0x00000001   
#define X_D3DFMT_L16                   0x00000032   
#define X_D3DFMT_V8U8                  0x00000028
#define X_D3DFMT_L6V5U5                0x00000027
#define X_D3DFMT_X8L8V8U8              0x00000007
#define X_D3DFMT_Q8W8V8U8              0x0000003A
#define X_D3DFMT_V16U16                0x00000033
#define X_D3DFMT_DXT1                  0x0000000C
#define X_D3DFMT_DXT2                  0x0000000E
#define X_D3DFMT_DXT3                0x0000000E // Not valid on Xbox
#define X_D3DFMT_DXT4                  0x0000000F
#define X_D3DFMT_DXT5                0x0000000F // Not valid on Xbox
#define X_D3DFMT_LIN_A1R5G5B5          0x00000010   
#define X_D3DFMT_LIN_A4R4G4B4          0x0000001D   
#define X_D3DFMT_LIN_A8                0x0000001F   
#define X_D3DFMT_LIN_A8B8G8R8          0x0000003F   
#define X_D3DFMT_LIN_A8R8G8B8          0x00000012   
#define X_D3DFMT_LIN_B8G8R8A8          0x00000040   
#define X_D3DFMT_LIN_G8B8              0x00000017   
#define X_D3DFMT_LIN_R4G4B4A4          0x0000003E   
#define X_D3DFMT_LIN_R5G5B5A1          0x0000003D   
#define X_D3DFMT_LIN_R5G6B5            0x00000011   
#define X_D3DFMT_LIN_R6G5B5            0x00000037   
#define X_D3DFMT_LIN_R8B8              0x00000016   
#define X_D3DFMT_LIN_R8G8B8A8          0x00000041   
#define X_D3DFMT_LIN_X1R5G5B5          0x0000001C   
#define X_D3DFMT_LIN_X8R8G8B8          0x0000001E   
#define X_D3DFMT_LIN_A8L8              0x00000020   
#define X_D3DFMT_LIN_AL8               0x0000001B   
#define X_D3DFMT_LIN_L16               0x00000035   
#define X_D3DFMT_LIN_L8                0x00000013   
#define X_D3DFMT_LIN_V16U16            0x00000036
#define X_D3DFMT_LIN_V8U8              0x00000017
#define X_D3DFMT_LIN_L6V5U5            0x00000037
#define X_D3DFMT_LIN_X8L8V8U8          0x0000001E
#define X_D3DFMT_LIN_Q8W8V8U8          0x00000012

#define D3DTEXTURE_ALIGNMENT            128

#define D3DFORMAT_DMACHANNEL_MASK       0x00000003
#define D3DFORMAT_DMACHANNEL_A          0x00000001
#define D3DFORMAT_DMACHANNEL_B          0x00000002

#define D3DFORMAT_CUBEMAP               0x00000004
#define D3DFORMAT_BORDERSOURCE_COLOR    0x00000008
#define D3DFORMAT_DIMENSION_MASK        0x000000F0
#define D3DFORMAT_DIMENSION_SHIFT       4
#define D3DFORMAT_FORMAT_MASK           0x0000FF00
#define D3DFORMAT_FORMAT_SHIFT          8
#define D3DFORMAT_MIPMAP_MASK           0x000F0000
#define D3DFORMAT_MIPMAP_SHIFT          16
#define D3DFORMAT_USIZE_MASK            0x00F00000
#define D3DFORMAT_USIZE_SHIFT           20
#define D3DFORMAT_VSIZE_MASK            0x0F000000
#define D3DFORMAT_VSIZE_SHIFT           24
#define D3DFORMAT_PSIZE_MASK            0xF0000000
#define D3DFORMAT_PSIZE_SHIFT           28

#define D3DCOMMON_TYPE_SHIFT         16
#define D3DCOMMON_TYPE_VERTEXBUFFER  0x00000000
#define D3DCOMMON_TYPE_INDEXBUFFER   0x00010000
#define D3DCOMMON_TYPE_PALETTE       0x00030000
#define D3DCOMMON_TYPE_TEXTURE       0x00040000
#define D3DCOMMON_TYPE_SURFACE       0x00050000
#define D3DCOMMON_VIDEOMEMORY        0x00800000

#define D3DTEXTURE_PITCH_ALIGNMENT   64


// Texture Resource Format
struct D3DTexture
{
    DWORD Common;
    DWORD Data;
    DWORD Lock;
    DWORD Format;
    DWORD Size;
};


// Enum for format definitions
typedef enum { FMT_LINEAR, FMT_SWIZZLED, FMT_COMPRESSED } FMT_TYPE;


// Format definition
struct FORMATSPEC
{
    CHAR*    strFormat;
    DWORD    dwXboxFormat;
    FMT_TYPE Type;
	DWORD    dwNumAlphaBits;
};
extern const FORMATSPEC g_TextureFormats[];




//-----------------------------------------------------------------------------
// Name: class CBaseTexture
// Desc: Handles all texture-specific processing, such as loading textures,
//       format conversion, swizzling, etc.
//-----------------------------------------------------------------------------
class CBaseTexture
{
public:
    CBaseTexture( CBundler* pBundler );
    ~CBaseTexture();

    CHAR  m_strFormat[MAX_PATH];
    int   m_nFormat;
    DWORD m_dwFilter;
    DWORD m_dwLevels;

//protected:
    int     FormatFromString( CHAR* strFormat );            // Format processing
    HRESULT LoadSurface( CHAR* strSource, CHAR* strAlphaSource, 
                         LPDIRECT3DSURFACE8* ppSurface );
    HRESULT ResizeSurface( DWORD dwWidth, DWORD dwHeight, LPDIRECT3DSURFACE8* ppSurface );
    HRESULT SaveSurface( DWORD* pcbData, DWORD dwLevels, 
                         LPDIRECT3DSURFACE8 pSurface );
    HRESULT SaveVolumeTexture( DWORD* pcbData, DWORD dwLevels, 
                               LPDIRECT3DVOLUMETEXTURE8 pVolume );
    DWORD   WriteLinearTextureData( VOID* pBits, DWORD dwWidth, 
		                            DWORD dwHeight, DWORD dwDepth );
	DWORD   WriteSwizzledTextureData( VOID* pBits, DWORD dwWidth, 
									  DWORD dwHeight, DWORD dwDepth );
	DWORD   WriteCompressedTextureData( VOID* pBits, DWORD dwWidth, 
								        DWORD dwHeight, DWORD dwDepth );

    CBundler* m_pBundler;
};


#endif // BASETEXTURE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\Bundler.h ===
class CBundler
{
public:
	CBundler();
	bool Init();
    void ErrorMsg( const char * strFmt, ... );
    HRESULT WriteData( void * pbBuff, DWORD cb );
    HRESULT PadToAlignment( DWORD dwAlign );

	HANDLE m_hFile;
    LPDIRECT3D8 m_pd3d;
    LPDIRECT3DDEVICE8 m_pd3ddev;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xm\xm.cpp ===
// xm.cpp : Defines the entry point for the console application.
//

#include "windows.h"
#include <stdio.h>
#include <math.h>
#include "TriStrip.h"

typedef enum _D3DPRIMITIVETYPE {
    D3DPT_POINTLIST             = 1,
    D3DPT_LINELIST              = 2,
    D3DPT_LINESTRIP             = 3,
    D3DPT_TRIANGLELIST          = 4,
    D3DPT_TRIANGLESTRIP         = 5,
    D3DPT_TRIANGLEFAN           = 6,

    D3DPT_FORCE_DWORD           = 0x7fffffff
} D3DPRIMITIVETYPE;

#define D3DFVF_XYZ              0x002
#define D3DFVF_NORMAL           0x010
#define D3DFVF_DIFFUSE          0x040
#define D3DFVF_TEX1             0x100
#define D3DFVF_NORMPACKED3		0x20000000

/*
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
*/


bool bStripify = false;
bool bClean = false;
bool bOptimize = false;
bool bCompress = false;
bool bDump = false;
bool bVerboseDump = false;

class CMeshFile
{
public:
	D3DPRIMITIVETYPE m_primitiveType;
	int m_nFaceCount;
	DWORD m_fvf;
	int m_nVertexStride;
	int m_nVertexCount;
	int m_nIndexCount;
	BYTE* m_pVertexBuffer;
	WORD* m_pIndexBuffer;

	bool LoadFile(const char* szFileName);
	bool SaveFile(const char* szFileName);
	bool Stripify();
	bool Clean();
	bool Optimize();
	bool Compress();
	void Dump();
};

bool CMeshFile::Optimize()
{
	// Remove duplicate vertices...
	int nStartVertexCount = m_nVertexCount;
	BYTE* pbSrcVert = m_pVertexBuffer;
	BYTE* pbDestVert = m_pVertexBuffer;
	for (int i = 0; i < m_nVertexCount - 1; i += 1)
	{
		for (int j = i + 1; j < m_nVertexCount; j += 1)
		{
			if (memcmp(m_pVertexBuffer + i * m_nVertexStride, m_pVertexBuffer + j * m_nVertexStride, m_nVertexStride) == 0)
			{
				// found a duplicate
//				printf("\tremoving vertex %d\n", j);
				for (int k = 0; k < m_nIndexCount; k += 1)
				{
					if (m_pIndexBuffer[k] == j)
						m_pIndexBuffer[k] = (WORD)i;
					else if (m_pIndexBuffer[k] > j)
						m_pIndexBuffer[k] -= 1;
				}

				MoveMemory(m_pVertexBuffer + j * m_nVertexStride, m_pVertexBuffer + (j + 1) * m_nVertexStride, (m_nVertexCount - j - 1) * m_nVertexStride);
				m_nVertexCount -= 1;
				j -= 1;
			}
		}
	}

	if (m_nVertexCount < nStartVertexCount)
	{
		printf("\tremoved %d vertices\n", nStartVertexCount - m_nVertexCount);
		return true;
	}

	return false;
}

bool CMeshFile::Clean()
{
	if ((m_fvf & D3DFVF_DIFFUSE) == 0)
	{
		printf("\tskipping; no diffuse color\n");
		return false;
	}

	BYTE* pbSrcVert = m_pVertexBuffer;
	BYTE* pbDestVert = m_pVertexBuffer;
	int nNewVertexStride = m_nVertexStride - 4;
	for (int i = 0; i < m_nVertexCount; i += 1)
	{
		BYTE* src = pbSrcVert;
		BYTE* dest = pbDestVert;

		if ((m_fvf & D3DFVF_XYZ) != 0)
		{
			float* pf = (float*)src;
			src += sizeof (float) * 3;
			*((float*&)dest)++ = pf[0];
			*((float*&)dest)++ = pf[1];
			*((float*&)dest)++ = pf[2];
		}

		if ((m_fvf & D3DFVF_NORMAL) != 0)
		{
			float* pf = (float*)src;
			src += sizeof (float) * 3;
			*((float*&)dest)++ = pf[0];
			*((float*&)dest)++ = pf[1];
			*((float*&)dest)++ = pf[2];
		}

		if ((m_fvf & D3DFVF_NORMPACKED3) != 0) {
			DWORD* pdw = (DWORD*)src;
			src += sizeof (DWORD);
			*((DWORD*&)dest)++ = *pdw;
		}

		// Skip the color...
		src += sizeof (DWORD);

		if ((m_fvf & D3DFVF_TEX1) != 0)
		{
			float* pf = (float*)src;
			src += sizeof (float) * 2;
			*((float*&)dest)++ = pf[0];
			*((float*&)dest)++ = pf[1];
		}

		pbSrcVert += m_nVertexStride;
		pbDestVert += nNewVertexStride;
	}

	m_nVertexStride = nNewVertexStride;
	m_fvf &= ~D3DFVF_DIFFUSE;

	return true;
}

bool CMeshFile::Stripify()
{
	if (m_primitiveType != D3DPT_TRIANGLELIST)
	{
		printf("\tskipping; not a triangle list\n");
		return false;
	}

	int nStrippedIndexCount = 0;
	WORD* pwStrippedIndices = NULL;

	::Stripify(m_nFaceCount, m_pIndexBuffer, &nStrippedIndexCount, &pwStrippedIndices);

	delete [] m_pIndexBuffer;
	m_pIndexBuffer = pwStrippedIndices;
	m_nIndexCount = nStrippedIndexCount;
	m_nFaceCount = nStrippedIndexCount - 2;
	m_primitiveType = D3DPT_TRIANGLESTRIP;

	// BLOCK: Create a new vertex buffer and sort the vertices into it...
	{
		WORD* pwVertexPermutation = NULL;
		ComputeVertexPermutation(nStrippedIndexCount, pwStrippedIndices, &m_nVertexCount, &pwVertexPermutation);

		BYTE* pVertexBuffer = new BYTE [m_nVertexCount * m_nVertexStride];
		
		for (int i = 0; i < m_nVertexCount; i += 1)
		{
			BYTE* pbSrcVert = m_pVertexBuffer + pwVertexPermutation[i] * m_nVertexStride;
			BYTE* pbDestVert = pVertexBuffer + i * m_nVertexStride;

			CopyMemory(pbDestVert, pbSrcVert, m_nVertexStride);
		}

		delete [] pwVertexPermutation;

		delete [] m_pVertexBuffer;
		m_pVertexBuffer = pVertexBuffer;
	}

	return true;
}

bool CMeshFile::LoadFile(const char* szFileName)
{
	HANDLE hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwValue, dwRead;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_primitiveType = (D3DPRIMITIVETYPE)dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nFaceCount = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_fvf = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nVertexStride = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nVertexCount = dwValue;

	ReadFile(hFile, &dwValue, 4, &dwRead, NULL);
	m_nIndexCount = dwValue;

	m_pVertexBuffer = new BYTE [m_nVertexCount * m_nVertexStride];
	ReadFile(hFile, m_pVertexBuffer, m_nVertexCount * m_nVertexStride, &dwRead, NULL);

	m_pIndexBuffer = new WORD [m_nIndexCount];
	ReadFile(hFile, m_pIndexBuffer, m_nIndexCount * sizeof (WORD), &dwRead, NULL);

	CloseHandle(hFile);

	return true;
}

bool CMeshFile::SaveFile(const char* szFileName)
{
	HANDLE hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		return false;

	DWORD dwValue, dwWritten;

	dwValue = (DWORD)m_primitiveType;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	dwValue = (DWORD)m_nFaceCount;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	dwValue = (DWORD)m_fvf;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	dwValue = (DWORD)m_nVertexStride;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	dwValue = (DWORD)m_nVertexCount;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	dwValue = (DWORD)m_nIndexCount;
	WriteFile(hFile, &dwValue, 4, &dwWritten, NULL);

	WriteFile(hFile, m_pVertexBuffer, m_nVertexCount * m_nVertexStride, &dwWritten, NULL);

	WriteFile(hFile, m_pIndexBuffer, m_nIndexCount * sizeof (WORD), &dwWritten, NULL);

	CloseHandle(hFile);

	return true;
}

void CMeshFile::Dump()
{
	const char* rgszPrimitiveType [] =
	{
		"unknown",
		"D3DPT_POINTLIST",
		"D3DPT_LINELIST",
		"D3DPT_LINESTRIP",
		"D3DPT_TRIANGLELIST",
		"D3DPT_TRIANGLESTRIP",
		"D3DPT_TRIANGLEFAN"
	};

	printf("\ttype: %s\n", rgszPrimitiveType[(int)m_primitiveType]);

	printf("\tfvf: ");
	if ((m_fvf & D3DFVF_XYZ) != 0)
		printf("D3DFVF_XYZ ");
	if ((m_fvf & D3DFVF_NORMAL) != 0)
		printf("D3DFVF_NORMAL ");
	if ((m_fvf & D3DFVF_NORMPACKED3) != 0)
		printf("D3DFVF_NORMPACKED3 ");
	if ((m_fvf & D3DFVF_DIFFUSE) != 0)
		printf("D3DFVF_DIFFUSE ");
	if ((m_fvf & D3DFVF_TEX1) != 0)
		printf("D3DFVF_TEX1 ");
	printf("\n");

	printf("\tface count: %d\n", m_nFaceCount);
	printf("\tvertex count: %d\n", m_nVertexCount);
	printf("\tindex count: %d\n", m_nIndexCount);

	if (bVerboseDump)
	{
		printf("\tvertices:\n");
		for (int i = 0; i < m_nVertexCount; i += 1)
		{
			printf("\t%6d: ", i);

			BYTE* vert = m_pVertexBuffer + m_nVertexStride * i;
			if ((m_fvf & D3DFVF_XYZ) != 0)
			{
				float* pf = (float*)vert;
				printf("xyz(%f,%f,%f)\n\t\t", pf[0], pf[1], pf[2]);
				vert += sizeof (float) * 3;
			}

			if ((m_fvf & D3DFVF_NORMAL) != 0)
			{
				float* pf = (float*)vert;
				printf("normal(%f,%f,%f)\n\t\t", pf[0], pf[1], pf[2]);
				vert += sizeof (float) * 3;
			}

			if ((m_fvf & D3DFVF_NORMPACKED3) != 0)
			{
				DWORD* pdw = (DWORD*)vert;
				printf("normal(0x%X)\n\t\t", *pdw);
				vert += sizeof (DWORD);
			}

			if ((m_fvf & D3DFVF_DIFFUSE) != 0)
			{
				vert += sizeof (DWORD);
			}

			if ((m_fvf & D3DFVF_TEX1) != 0)
			{
				float* pf = (float*)vert;
				printf("tex1(%f,%f)\n\t\t", pf[0], pf[1]);
				vert += sizeof (float) * 2;
			}
			printf("\n");
		}

		printf("\tindices:\n");
		for (i = 0; i < m_nIndexCount; i += 3)
		{
			printf("\t\t%d %d %d\n", m_pIndexBuffer[i + 0], m_pIndexBuffer[i + 1], m_pIndexBuffer[i + 2]);
		}
	}
}

DWORD CompressNormal(float* pvNormal) {

    float vNormal[3];
    float fLength;

    fLength = (float)sqrt(pvNormal[0] * pvNormal[0] + pvNormal[1] * pvNormal[1] + pvNormal[2] * pvNormal[2]);

    vNormal[0] = pvNormal[0] / fLength;
    vNormal[1] = pvNormal[1] / fLength;
    vNormal[2] = pvNormal[2] / fLength;

    return ((((DWORD)(vNormal[0] * 1023.0f) & 0x7FF) << 0)  |
            (((DWORD)(vNormal[1] * 1023.0f) & 0x7FF) << 11) |
            (((DWORD)(vNormal[2] *  511.0f) & 0x3FF) << 22));
}

bool CMeshFile::Compress()
{
	DWORD dwNormal;
	BYTE* pCompressedVertexBuffer;
	int nCompressedVertexStride = m_nVertexStride - 2 * sizeof (float);

	if ((m_fvf & D3DFVF_NORMPACKED3) || !(m_fvf & D3DFVF_NORMAL)) {
		return false;
	}

	pCompressedVertexBuffer = new BYTE [m_nVertexCount * nCompressedVertexStride];

	for (int i = 0; i < m_nVertexCount; i += 1)
	{
		BYTE* vert = m_pVertexBuffer + m_nVertexStride * i;
		BYTE* cvert = pCompressedVertexBuffer + nCompressedVertexStride * i;

		if ((m_fvf & D3DFVF_XYZ) != 0)
		{
			memcpy(cvert, vert, sizeof (float) * 3);
			vert += sizeof (float) * 3;
			cvert += sizeof (float) * 3;
		}

		if ((m_fvf & D3DFVF_NORMAL) != 0) // Should always be TRUE
		{
			dwNormal = CompressNormal((float*)vert);
			memcpy(cvert, &dwNormal, sizeof (DWORD));
			vert += sizeof (float) * 3;
			cvert += sizeof (DWORD);
		}

		if ((m_fvf & D3DFVF_DIFFUSE) != 0)
		{
			memcpy(cvert, vert, sizeof(DWORD));
			vert += sizeof (DWORD);
			cvert += sizeof (DWORD);
		}

		if ((m_fvf & D3DFVF_TEX1) != 0)
		{
			memcpy(cvert, vert, sizeof(float) * 2);
			vert += sizeof (float) * 2;
			cvert += sizeof (float) * 2;
		}
	}

	delete [] m_pVertexBuffer;
	m_pVertexBuffer = pCompressedVertexBuffer;
	m_nVertexStride = nCompressedVertexStride;

	m_fvf &= ~D3DFVF_NORMAL;
	m_fvf |= D3DFVF_NORMPACKED3;

	return true;
}

void ProcessFile(const char* szFileName)
{
	CMeshFile file;
	bool bModified = false;

	if (!file.LoadFile(szFileName))
	{
		fprintf(stderr, "Cannot load file '%s'\n", szFileName);
		return;
	}

	if (bClean)
	{
		printf("Cleaning %s...\n", szFileName);
		bModified = file.Clean();
	}

	if (bOptimize)
	{
		printf("Optimizing %s...\n", szFileName);
		bModified = file.Optimize();
	}

	if (bStripify)
	{
		printf("Stripifying %s...\n", szFileName);
		bModified = file.Stripify();
	}

	if (bCompress)
	{
		printf("Compressing %s...\n", szFileName);
		bModified = file.Compress();
	}

	if (bDump)
	{
		printf("Dump of %s\n", szFileName);
		file.Dump();
	}

	if (bModified)
	{
		if (!file.SaveFile(szFileName))
		{
			fprintf(stderr, "Cannot write file '%s'\n", szFileName);
			return;
		}
	}
}

void ProcessFiles(const char* szWild)
{
	WIN32_FIND_DATA fd;
	HANDLE h = FindFirstFile(szWild, &fd);
	if (h == INVALID_HANDLE_VALUE)
	{
		printf("Cannot find %s\n", szWild);
		return;
	}

	do
	{
		if (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
			continue;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)
			continue;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_TEMPORARY)
			continue;

		if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			continue;

		ProcessFile(fd.cFileName);
	}
	while (FindNextFile(h, &fd));

	FindClose(h);
}

int __cdecl main(int argc, char* argv[])
{
	bool bNeedHelp = true;

	for (int i = 1; i < argc; i += 1)
	{
		const char* sz = argv[i];

		if (sz[0] == '-' || sz[0] == '/')
		{
			sz += 1;
			while (*sz != '\0')
			{
				switch (*sz++)
				{
				case '?':
					goto LNeedHelp;

				case 's':
				case 'S':
					bStripify = true;
					break;

				case 'c':
				case 'C':
					bClean = true;
					break;

				case 'o':
				case 'O':
					bOptimize = true;
					break;

				case 'n':
				case 'N':
					bCompress = true;
					break;

				case 'd':
				case 'D':
					bDump = true;
					break;

				case 'v':
				case 'V':
					bDump = true;
					bVerboseDump = true;
					break;
				}
			}
		}
		else
		{
			bNeedHelp = false;
			ProcessFiles(sz);
		}
	}

	if (bNeedHelp)
	{
LNeedHelp:
		printf("This program processes XDash style 3D mesh files in various ways.\n");
		printf("Usage:\n\txm [-options] <file> ...\n");
		printf("Options:\n");
		printf("\t-d\tDump\n");
		printf("\t-v\tVerbose Dump\n");
		printf("\t-s\tStripify\n");
		printf("\t-c\tClean (remove diffuse color)\n");
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\LoadImage.cpp ===
//-----------------------------------------------------------------------------
// File: LoadImage.cpp
//
// Desc: Loads image files.
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#include <windows.h>
#include <d3d8.h>
#include "LoadImage.h"




//-----------------------------------------------------------------------------
// Name: CImage()
// Desc: Initializes object
//-----------------------------------------------------------------------------
CImage::CImage()
{
    m_Format         = D3DFMT_UNKNOWN;
    m_pData          = NULL;
    m_pPalette       = NULL;
    m_bDeleteData    = FALSE;
    m_bDeletePalette = FALSE;
}




//-----------------------------------------------------------------------------
// Name: ~CImage()
// Desc: Frees resources held by the object
//-----------------------------------------------------------------------------
CImage::~CImage()
{
    if( m_pData && m_bDeleteData )
        delete[] m_pData;

    if( m_pPalette && m_bDeletePalette )
        delete[] m_pPalette;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Attempts to load the given data as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( const VOID* pData, DWORD cbData )
{
    HRESULT hr;

    // Try all known image loading subroutines
    for( int i = 0; i < 4; i++ )
    {
        switch(i)
        {
            case 0: hr = LoadBMP( pData, cbData ); break;
            case 1: hr = LoadPPM( pData, cbData ); break;
            case 2: hr = LoadTGA( pData, cbData ); break;
            case 3: hr = LoadDIB( pData, cbData ); break;
        }

        if( SUCCEEDED(hr) )
            break;

        if( m_pData && m_bDeleteData )
            delete[] m_pData;

        if( m_pPalette && m_bDeletePalette )
            delete[] m_pPalette;

        m_pData          = NULL;
        m_pPalette       = NULL;
        m_bDeleteData    = FALSE;
        m_bDeletePalette = FALSE;
    }

    if( 4 == i )
    {
        DPF(0, "Unsupported file format");
        return D3DXERR_INVALIDDATA;
    }

    m_Rect.left   = 0;
    m_Rect.top    = 0;
    m_Rect.right  = m_Width;
    m_Rect.bottom = m_Height;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Depalettize()
// Desc: Depalettize palettized images
//-----------------------------------------------------------------------------
HRESULT CImage::Depalettize()
{
    if( NULL == m_pPalette )
        return S_OK;

    BYTE*  pSrcData = (BYTE*)m_pData;
    DWORD* pDstData = new DWORD[m_Width*m_Height];

    BYTE*  pOldData = (BYTE*)pSrcData;
    BYTE*  pNewData = (BYTE*)pDstData;

    // Loop through all texels and get 32-bit color from the 8-bit palette index
    for( DWORD y=0; y<m_Height; y++ )
    {
        for( DWORD x=0; x<m_Width; x++ )
        {
            BYTE  index = *pSrcData++;

            DWORD red   = m_pPalette[index].peRed;
            DWORD green = m_pPalette[index].peGreen;
            DWORD blue  = m_pPalette[index].peBlue;
            DWORD alpha = m_pPalette[index].peFlags;

            *pDstData++ = (alpha<<24) | (red<<16) | (green<<8) | (blue<<0);
        }
    }

    // Delete the old palette
    if( m_bDeletePalette )
        delete[] m_pPalette;
    m_pPalette       = NULL;
    m_bDeletePalette = FALSE;

    // Delete the old data, and assign the new data
    if( m_bDeleteData )
        delete[] m_pData;
    m_pData          = pNewData;
    m_bDeleteData    = TRUE;

    // The format is now A8R8G8B8
    m_Format = D3DFMT_A8R8G8B8;
    m_Pitch  = m_Width * sizeof(DWORD);

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Load()
// Desc: Reads the data from the file and tries to load it as an image
//-----------------------------------------------------------------------------
HRESULT CImage::Load( CHAR* strFilename )
{
    HANDLE hFile = CreateFileA( strFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL );
    if( INVALID_HANDLE_VALUE == hFile )
        return E_FAIL;

    // Allocate memory
    DWORD dwFileSize = GetFileSize( hFile, NULL );
    VOID* pFileData  = malloc( dwFileSize );

    // Read it the file
    DWORD dwRead;
    ReadFile( hFile, (VOID*)pFileData, dwFileSize, &dwRead, NULL );

    HRESULT hr = Load( pFileData, dwFileSize );

    // Free stuff
    CloseHandle( hFile );
    free( pFileData );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: LoadBMP()
// Desc: Attempts to load the given data as a BMP
//-----------------------------------------------------------------------------
HRESULT CImage::LoadBMP( const VOID* pvData, DWORD cbData )
{
    // Examine header
    if(cbData < sizeof(BITMAPFILEHEADER))
        return E_FAIL;

    BITMAPFILEHEADER *pFH = (BITMAPFILEHEADER *) pvData;

    if(pFH->bfType != (('B') | ('M' << 8)) || pFH->bfSize > cbData)
        return E_FAIL;

    return LoadDIB((BYTE *) pvData + sizeof(BITMAPFILEHEADER), cbData - sizeof(BITMAPFILEHEADER));
}




//-----------------------------------------------------------------------------
// Name: LoadDIB()
// Desc: Attempts to load the given data as a DIB
//-----------------------------------------------------------------------------
HRESULT CImage::LoadDIB( const VOID* pvData, DWORD cbData )
{
    UNALIGNED BITMAPINFOHEADER *pIH;
    DWORD     dwWidth, dwHeight, dwOffset, dwClrUsed;

    if(cbData < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    pIH = (BITMAPINFOHEADER *) pvData;

    if(pIH->biSize < sizeof(BITMAPINFOHEADER))
        return E_FAIL;

    dwWidth   = (DWORD) (pIH->biWidth);
    dwHeight  = (DWORD) (pIH->biHeight > 0 ? pIH->biHeight : -pIH->biHeight);
    dwClrUsed = (DWORD) (pIH->biClrUsed);

    if((pIH->biBitCount <= 8) && (0 == dwClrUsed))
        dwClrUsed = (DWORD) (1 << pIH->biBitCount);

    dwOffset  = (DWORD) pIH->biSize + dwClrUsed * sizeof(DWORD);

    if(dwOffset > (DWORD) cbData)
        return E_FAIL;

    if(pIH->biPlanes != 1)
        return E_FAIL;


    // Only RGB and BITFIELD bitmaps can be inverted
    if(pIH->biHeight < 0 && pIH->biCompression != BI_RGB && pIH->biCompression != BI_BITFIELDS)
        return E_FAIL;


    // Compute format
    DWORD dwB, dwG, dwR, dwA;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pIH->biCompression)
    {
        case BI_RGB:
        case BI_RLE4:
        case BI_RLE8:

            switch(pIH->biBitCount)
            {
                case 1:
                case 4:
                case 8:
                    Format = D3DFMT_P8;
                    break;

                case 16:
                    Format = D3DFMT_X1R5G5B5;
                    break;

                case 24:
#if 0
                    Format = D3DFMT_R8G8B8;
                    break;
#endif
                case 32:
                    Format = D3DFMT_X8R8G8B8;
                    break;

                default:
                    return E_FAIL;
            }
            break;

        case BI_BITFIELDS:
            if(pIH->biSize < sizeof(BITMAPV4HEADER))
                return E_FAIL;

            dwB = ((BITMAPV4HEADER *) pIH)->bV4BlueMask;
            dwG = ((BITMAPV4HEADER *) pIH)->bV4GreenMask;
            dwR = ((BITMAPV4HEADER *) pIH)->bV4RedMask;
            dwA = ((BITMAPV4HEADER *) pIH)->bV4AlphaMask;

            switch(pIH->biBitCount)
            {
                case 16:
                    if(dwB == 0x00ff && dwG == 0x00ff && dwR == 0x00ff && dwA == 0xff00)
                        Format = D3DFMT_A8L8;

                    else if(dwB == 0x001f && dwG == 0x07e0 && dwR == 0xf800 && dwA == 0x0000)
                        Format = D3DFMT_R5G6B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x0000)
                        Format = D3DFMT_X1R5G5B5;

                    else if(dwB == 0x001f && dwG == 0x03e0 && dwR == 0x7c00 && dwA == 0x8000)
                        Format = D3DFMT_A1R5G5B5;

                    else if(dwB == 0x000f && dwG == 0x00f0 && dwR == 0x0f00 && dwA == 0xf000)
                        Format = D3DFMT_A4R4G4B4;
        #if 0
                    else if(dwB == 0x0003 && dwG == 0x001c && dwR == 0x00e0 && dwA == 0xff00)
                        Format = D3DFMT_A8R3G3B2;
        #endif
                    break;

                case 24:
                    if(dwB == 0x0000ff && dwG == 0x00ff00 && dwR == 0xff0000 && dwA == 0x000000)
        #if 0                
                        Format = D3DFMT_R8G8B8;
        #else
                        Format = D3DFMT_X8R8G8B8;
        #endif
                    break;

                case 32:
                    if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0x00000000)
                        Format = D3DFMT_X8R8G8B8;

                    else if(dwB == 0x000000ff && dwG == 0x0000ff00 && dwR == 0x00ff0000 && dwA == 0xff000000)
                        Format = D3DFMT_A8R8G8B8;

                    break;
            }

            break;

        default:
            DPF(0, "LoadBMP: JPEG compression not supported");
            return E_NOTIMPL;
    }


    if(D3DFMT_UNKNOWN == Format)
    {
        return E_FAIL;
    }


    if(D3DFMT_P8 == Format)
    {
        DWORD dwClrUsed = pIH->biClrUsed;

        if(!dwClrUsed)
            dwClrUsed = 1 << pIH->biBitCount;

        m_bDeletePalette = TRUE;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        DWORD dw;
        RGBQUAD* prgb = (RGBQUAD*) (((BYTE *) pIH) + pIH->biSize);

        for(dw = 0; dw < dwClrUsed; dw++, prgb++)
        {
            m_pPalette[dw].peRed   = prgb->rgbRed;
            m_pPalette[dw].peGreen = prgb->rgbGreen;
            m_pPalette[dw].peBlue  = prgb->rgbBlue;
            m_pPalette[dw].peFlags = 0xff;
        }

        for(dw = dwClrUsed; dw < 256; dw++)
        {
            m_pPalette[dw].peRed   = 0xff;
            m_pPalette[dw].peGreen = 0xff;
            m_pPalette[dw].peBlue  = 0xff;
            m_pPalette[dw].peFlags = 0xff;
        }
    }

    DWORD dwWidthBytes;
    DWORD dwSrcInc, dwDstInc;

    switch(pIH->biBitCount)
    {
        case 1:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 3) + 3) & ~3;
            break;

        case 4:
            dwWidthBytes = dwWidth;
            dwSrcInc = ((dwWidth >> 1) + 3) & ~3;
            break;

        default:
            dwWidthBytes = (dwWidth * (pIH->biBitCount >> 3));
            dwSrcInc = (dwWidthBytes + 3) & ~3;
            break;
    }

    m_Format  = Format;
    m_Pitch   = (DWORD)((dwWidthBytes + 3) & ~3);
    m_Width   = (DWORD)dwWidth;
    m_Height  = (DWORD)dwHeight;
#if 1
    if (pIH->biBitCount == 24 && Format == D3DFMT_X8R8G8B8)
    {
        UNALIGNED BYTE* pbSrc;
        DWORD*          pdwDst;
        int             nStrideDst;
        UINT            i, j;

        dwWidthBytes = (dwWidth * (32 >> 3));
        m_Pitch      = (DWORD)((dwWidthBytes + 3) & ~3);

        m_bDeleteData = TRUE;

        m_pData = new BYTE[dwHeight * m_Pitch];
        if (!m_pData)
            return E_OUTOFMEMORY;

        pbSrc = ((BYTE*)pvData) + dwOffset;
        if (pIH->biHeight < 0)
        {
            pdwDst = (DWORD*)m_pData;
            nStrideDst = m_Pitch >> 2;
        }
        else
        {
            pdwDst = (DWORD*)((BYTE*)m_pData + m_Pitch * (dwHeight - 1));
            nStrideDst = -(int)(m_Pitch >> 2);
        }

        for (i = 0; i < dwHeight; i++)
        {
            for (j = 0; j < dwWidth; j++)
            {
                pdwDst[j] = pbSrc[2] << 16 | pbSrc[1] << 8 | *pbSrc;
                pbSrc += 3;
            }

            pdwDst += nStrideDst;
        }

        return S_OK;
    }
#endif
    if(pIH->biHeight < 0 && pIH->biBitCount >= 8)
    {
        // The data is in the correct format already in the file.
        m_pData  = new BYTE[dwHeight * m_Pitch];
        memcpy( m_pData, ((BYTE *)pvData) + dwOffset, dwHeight * m_Pitch );
        m_bDeleteData = TRUE;

        return S_OK;
    }

    // Data in file needs to be converted.. so lets allocate the destination
    // buffer which will contain the image..

    m_bDeleteData = TRUE;
    m_pData  = new BYTE[dwHeight * m_Pitch];

    if(!m_pData)
        return E_OUTOFMEMORY;

    UNALIGNED BYTE *pbSrc, *pbDest, *pbDestMin, *pbDestLim, *pbDestLine;

    pbSrc = ((BYTE *) pvData) + dwOffset;

    if(pIH->biHeight < 0)
    {
        dwDstInc = m_Pitch;
        pbDest = (BYTE *) m_pData;
    }
    else
    {
        dwDstInc = 0 - (DWORD)m_Pitch;
        pbDest = (BYTE *) m_pData + (dwHeight - 1) * m_Pitch;
    }

    pbDestLine = pbDest;
    pbDestMin = (BYTE *) m_pData;
    pbDestLim = (BYTE *) m_pData + dwHeight * m_Pitch;



    if(BI_RLE4 == pIH->biCompression)
    {
        // RLE4. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        for(int i = 0; i < pbSrc[1]; i++)
                            pbDest[i] = (i & 1) ?  (pbSrc[2 + (i >> 1)] & 0x0f) : (pbSrc[2 + (i >> 1)] >> 4);

                        pbDest += pbSrc[1];
                        pbSrc += ((pbSrc[1] >> 1) + 1) & ~1;
                        break;
                }
            }
            else
            {
                for(int i = 0; i < pbSrc[0]; i++)
                    pbDest[i] = (i & 1) ? (pbSrc[1] & 0x0f) : (pbSrc[1] >> 4);

                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }

    if(pIH->biCompression == BI_RLE8)
    {
        // RLE8. Always encoded upsidedown.

        while(pbDest >= pbDestMin)
        {
            if(0 == pbSrc[0])
            {
                switch(pbSrc[1])
                {
                    case 0:
                        D3DXASSERT(pbDest == pbDestLine + dwWidth);
                        pbDestLine -= m_Pitch;
                        pbDest = pbDestLine;
                        break;

                    case 1:
                        pbDest = pbDestMin - m_Pitch;
                        break;

                    case 2:
                        pbDest += pbSrc[2] - pbSrc[3] * m_Pitch;
                        pbSrc += 2;
                        break;

                    default:
                        memcpy(pbDest, pbSrc + 2, pbSrc[1]);
                        pbDest += pbSrc[1];
                        pbSrc += (pbSrc[1] + 1) & ~1;
                        break;
                }
            }
            else
            {
                memset(pbDest, pbSrc[1], pbSrc[0]);
                pbDest += pbSrc[0];
            }

            pbSrc += 2;
        }

        return S_OK;
    }


    if(1 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (pbSrc[i >> 3] >> (7 - (i & 7))) & 1;

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }

    if(4 == pIH->biBitCount)
    {
        while(pbDest >= pbDestMin && pbDest < pbDestLim)
        {
            for(UINT i = 0; i < dwWidth; i++)
                pbDest[i] = (i & 1) ? pbSrc[i >> 1] & 0x0f : (pbSrc[i >> 1] >> 4);

            pbDest += dwDstInc;
            pbSrc  += dwSrcInc;
        }

        return S_OK;
    }


    while(pbDest >= pbDestMin && pbDest < pbDestLim)
    {
        memcpy(pbDest, pbSrc, dwWidthBytes);

        pbDest += dwDstInc;
        pbSrc  += dwSrcInc;
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: struct TGAHEADER
// Desc: Defines the header format for TGA files
//-----------------------------------------------------------------------------
#pragma pack(1)
struct TGAHEADER
{
    BYTE IDLength;
    BYTE ColormapType;
    BYTE ImageType;

    WORD wColorMapIndex;
    WORD wColorMapLength;
    BYTE bColorMapBits;

    WORD wXOrigin;
    WORD wYOrigin;
    WORD wWidth;
    WORD wHeight;
    BYTE PixelDepth;
    BYTE ImageDescriptor;
};
#pragma pack()




//-----------------------------------------------------------------------------
// Name: LoadTGA()
// Desc: Attempts to load the given data as a TGA file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadTGA( const VOID* pvData, DWORD cbData )
{
    // Validate header.  TGA files don't seem to have any sort of magic number
    // to identify them.  Therefore, we will proceed as if this is a real TGA
    // file, until we see something we don't understand.

    BYTE*      pbData = (BYTE*)pvData;
    TGAHEADER* pFH    = (TGAHEADER*)pbData;

    if( cbData < sizeof(TGAHEADER) )
        return E_FAIL;

    if( pFH->ColormapType & ~0x01 )
        return E_FAIL;

    if( pFH->ImageType & ~0x0b )
        return E_FAIL;

    if( !pFH->wWidth || !pFH->wHeight )
        return E_FAIL;



    // Colormap size and format
    UINT uColorMapBytes = ((UINT) pFH->bColorMapBits + 7) >> 3;
    D3DFORMAT ColorMapFormat = D3DFMT_UNKNOWN;

    if(pFH->ColormapType)
    {
        switch(pFH->bColorMapBits)
        {
            case 15: ColorMapFormat = D3DFMT_X1R5G5B5; break;
            case 16: ColorMapFormat = D3DFMT_A1R5G5B5; break;
            case 24: 
#if 0
                     ColorMapFormat = D3DFMT_R8G8B8;   break;
#endif
            case 32: ColorMapFormat = D3DFMT_A8R8G8B8; break;
            default: return E_FAIL;
        }
    }


    // Image size and format
    UINT uBytes = ((UINT) pFH->PixelDepth + 7) >> 3;
    D3DFORMAT Format = D3DFMT_UNKNOWN;

    switch(pFH->ImageType & 0x03)
    {
        case 1:
            if(!pFH->ColormapType)
                return E_FAIL;

            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_P8; break;
                default: return E_FAIL;
            }
            break;

        case 2:
            switch(pFH->PixelDepth)
            {
                case 15: Format = D3DFMT_X1R5G5B5; break;
                case 16: Format = D3DFMT_A1R5G5B5; break;
                case 24: 
#if 0
                         Format = D3DFMT_R8G8B8;   break;
#endif
                case 32: Format = D3DFMT_A8R8G8B8; break;
                default: return E_FAIL;
            }
            break;

        case 3:
            switch(pFH->PixelDepth)
            {
                case 8: Format = D3DFMT_L8; break;
                default: return E_FAIL;
            }
            break;

        default:
            return E_FAIL;
    }

    BOOL bRLE         = pFH->ImageType & 0x08;
    BOOL bTopToBottom = 0x20 == (pFH->ImageDescriptor & 0x20);
    BOOL bLeftToRight = 0x10 != (pFH->ImageDescriptor & 0x10);

    pbData += sizeof(TGAHEADER);
    cbData -= sizeof(TGAHEADER);


    // Skip ID
    if(cbData < pFH->IDLength)
        return E_FAIL;

    pbData += pFH->IDLength;
    cbData -= pFH->IDLength;


    // Color map
    UINT cbColorMap = (UINT) pFH->wColorMapLength * uColorMapBytes;

    if(cbData < cbColorMap)
        return E_FAIL;

    if(D3DFMT_P8 == Format)
    {
        if(pFH->wColorMapIndex + pFH->wColorMapLength > 256)
            return E_FAIL;

        if(!(m_pPalette = new PALETTEENTRY[256]))
            return E_OUTOFMEMORY;

        m_bDeletePalette = TRUE;
        memset(m_pPalette, 0xff, 256 * sizeof(PALETTEENTRY));

        BYTE *pb = pbData;
        PALETTEENTRY *pColor = m_pPalette + pFH->wColorMapIndex;
        PALETTEENTRY *pColorLim = pColor + pFH->wColorMapLength;

        while(pColor < pColorLim)
        {
            UINT u, uA, uR, uG, uB;

            switch(ColorMapFormat)
            {
                case D3DFMT_X1R5G5B5:
                    u = *((WORD *) pb);

                    uA = 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

                case D3DFMT_A1R5G5B5:
                    u = *((WORD *) pb);

                    uA = (u >> 15) * 0xff;
                    uR = (u >> 10) & 0x1f;
                    uG = (u >>  5) & 0x1f;
                    uB = (u >>  0) & 0x1f;

                    uR = (uR << 3) | (uR >> 2);
                    uG = (uG << 3) | (uG >> 2);
                    uB = (uB << 3) | (uB >> 2);

                    pb += 2;
                    break;

    #if 0
                case D3DFMT_R8G8B8:
                    uA = 0xff;
                    uR = pb[2];
                    uG = pb[1];
                    uB = pb[0];

                    pb += 3;
                    break;
    #endif

                case D3DFMT_A8R8G8B8:
                    u = *((DWORD *) pb);

                    uA = (u >> 24) & 0xff;
                    uR = (u >> 16) & 0xff;
                    uG = (u >>  8) & 0xff;
                    uB = (u >>  0) & 0xff;

                    pb += 4;
                    break;
            }
            
            pColor->peRed   = (BYTE) uR;
            pColor->peGreen = (BYTE) uG;
            pColor->peBlue  = (BYTE) uB;
            pColor->peFlags = (BYTE) uA;
        
            pColor++;
        }
    }

    pbData += cbColorMap;
    cbData -= cbColorMap;


    // Image data
    UINT cbImage = (UINT) pFH->wWidth * (UINT) pFH->wHeight * uBytes;

    m_Format  = Format;
    m_pData   = pbData;
    m_Pitch   = (UINT) pFH->wWidth * uBytes;

    m_Width  = pFH->wWidth;
    m_Height = pFH->wHeight;


    if(!bRLE && bTopToBottom && bLeftToRight)
    {
        // Data is already in a format usable to D3D.. no conversion is necessary
        if(cbData < cbImage)
            return E_FAIL;

        m_pData = new BYTE[m_Height*m_Pitch];
        memcpy( m_pData, pbData, m_Height*m_Pitch );
        m_bDeleteData = TRUE;

        pbData += cbImage;
        cbData -= cbImage;
    }
    else
    {
        // Image data is compressed, or does not have origin at top-left
        if(!(m_pData = new BYTE[cbImage]))
            return E_OUTOFMEMORY;

        m_bDeleteData = TRUE;


        BYTE *pbDestY = bTopToBottom ? (BYTE *) m_pData : ((BYTE *) m_pData + (pFH->wHeight - 1) * m_Pitch);

        for(UINT uY = 0; uY < pFH->wHeight; uY++)
        {
            BYTE *pbDestX = bLeftToRight ? pbDestY : (pbDestY + m_Pitch - uBytes);

            for(UINT uX = 0; uX < pFH->wWidth; )
            {
                BOOL bRunLength;
                UINT uCount;

                if(bRLE)
                {
                    if(cbData < 1)
                        return E_FAIL;

                    bRunLength = *pbData & 0x80;
                    uCount = (*pbData & 0x7f) + 1;

                    pbData++;
                    cbData--;
                }
                else
                {
                    bRunLength = FALSE;
                    uCount = pFH->wWidth;
                }

                uX += uCount;

                while(uCount--)
                {
                    if(cbData < uBytes)
                        return E_FAIL;

                    memcpy(pbDestX, pbData, uBytes);

                    if(!bRunLength)
                    {
                        pbData += uBytes;
                        cbData -= uBytes;
                    }

                    pbDestX = bLeftToRight ? (pbDestX + uBytes) : (pbDestX - uBytes);
                }

                if(bRunLength)
                {
                    pbData += uBytes;
                    cbData -= uBytes;
                }
            }

            pbDestY = bTopToBottom ? (pbDestY + m_Pitch) : (pbDestY - m_Pitch);
        }
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Anonymous enum
// Desc: Enumerations used for loading PPM files
//-----------------------------------------------------------------------------
enum
{
    PPM_WIDTH, PPM_HEIGHT, PPM_MAX, PPM_DATA_R, PPM_DATA_G, PPM_DATA_B
};




//-----------------------------------------------------------------------------
// Name: LoadPPM()
// Desc: Attempts to load the given data as a PPM file
//-----------------------------------------------------------------------------
HRESULT CImage::LoadPPM( const VOID* pvData, DWORD cbData )
{
    BYTE *pbData = (BYTE *)pvData;

    // Check header
    BOOL bAscii;

    if(cbData < 2)
        return E_FAIL;

    if('P' == pbData[0] && '3' == pbData[1])
        bAscii = TRUE;
    else if('P' == pbData[0] && '6' == pbData[1])
        bAscii = FALSE;
    else
        return E_FAIL;

    pbData += 2;
    cbData -= 2;

    // Image data
    UINT uMode   = PPM_WIDTH;
    UINT uWidth  = 0;
    UINT uHeight = 0;
    UINT uMax    = 255;

    DWORD *pdw, *pdwLim;

    while(cbData)
    {
        if(!bAscii && PPM_DATA_R == uMode)
        {
            // Binary image data
            if(uMax > 255)
                return E_FAIL;

            if(cbData > 1 && '\r' == *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;

            while(cbData && pdw < pdwLim)
            {
                *pdw++ = ((255 * pbData[0] / uMax) << 16) |
                         ((255 * pbData[1] / uMax) <<  8) |
                         ((255 * pbData[2] / uMax) <<  0) | 0xff000000;

                pbData += 3;
                cbData -= 3;
            }

            if(pdw != pdwLim)
                return E_FAIL;

            return S_OK;
        }
        if(isspace(*pbData))
        {
            // Whitespace
            pbData++;
            cbData--;
        }
        else if('#' == *pbData)
        {
            // Comment
            while(cbData && '\n' != *pbData)
            {
                pbData++;
                cbData--;
            }

            pbData++;
            cbData--;
        }
        else
        {
            // Number
            UINT u = 0;

            while(cbData && !isspace(*pbData))
            {
                if(!isdigit(*pbData))
                    return E_FAIL;

                u = u * 10 + (*pbData - '0');

                pbData++;
                cbData--;
            }

            switch(uMode)
            {
                case PPM_WIDTH:
                    uWidth = u;

                    if(0 == uWidth)
                        return E_FAIL;

                    break;

                case PPM_HEIGHT:
                    uHeight = u;

                    if(0 == uHeight)
                        return E_FAIL;

                    if(!(m_pData = new BYTE[uWidth * uHeight * sizeof(DWORD)]))
                        return E_OUTOFMEMORY;

                    m_bDeleteData = TRUE;

                    pdw = (DWORD *) m_pData;
                    pdwLim = pdw + uWidth * uHeight;

                    m_Format = D3DFMT_X8R8G8B8;
                    m_Pitch  = uWidth * sizeof(DWORD);

                    m_Width  = uWidth;
                    m_Height = uHeight;
                    break;

                case PPM_MAX:
                    uMax = u;

                    if(0 == uMax)
                        return E_FAIL;

                    break;

                case PPM_DATA_R:
                    if(pdw >= pdwLim)
                        return E_FAIL;

                    *pdw  = ((u * 255 / uMax) << 16) | 0xff000000;
                    break;

                case PPM_DATA_G:
                    *pdw |= ((u * 255 / uMax) <<  8);
                    break;

                case PPM_DATA_B:
                    *pdw |= ((u * 255 / uMax) <<  0);

                    if(++pdw == pdwLim)
                        return S_OK;

                    uMode = PPM_DATA_R - 1;
                    break;
            }

            uMode++;
        }
    }

    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\LoadImage.h ===
//-----------------------------------------------------------------------------
// File: LoadImage.h
//
// Desc: Loads image files
//
// Hist: 04.13.01 - New for May XDK release
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef LOADIMAGE_H
#define LOADIMAGE_H


#define DPF(x,y)
#define D3DXASSERT(x)
#define D3DXERR_INVALIDDATA -1




//-----------------------------------------------------------------------------
// Name: class CImage
// Desc: Class to load different image formats
//-----------------------------------------------------------------------------
class CImage
{
public:
    VOID*           m_pData;
    D3DFORMAT       m_Format;
    DWORD           m_Width;
    DWORD           m_Height;
    DWORD           m_Pitch;
    PALETTEENTRY*   m_pPalette;

    RECT            m_Rect;

    BOOL            m_bDeleteData;
    BOOL            m_bDeletePalette;

    HRESULT LoadBMP( const VOID* pData, DWORD dwSize );
    HRESULT LoadDIB( const VOID* pData, DWORD dwSize );
    HRESULT LoadTGA( const VOID* pData, DWORD dwSize );
    HRESULT LoadPPM( const VOID* pData, DWORD dwSize );

public:
    HRESULT Load( const VOID* pData, DWORD dwSize );
    HRESULT Load( CHAR* strFilename );

    HRESULT Depalettize();

    CImage();
    ~CImage();
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\fontoutl.h ===
#include "Glyph.h"

#define WFO_FAILURE   FALSE 
#define WFO_SUCCESS   TRUE

#define PI      3.141592653589793
#define TWO_PI  2.0*PI   

#define ZERO_EPS    0.00000001

#define WARNING(s) OutputDebugString(s)
#define ASSERTOPENGL(a, b) {}
#define DBGPRINT(s) OutputDebugString(s)
#define ALLOC(size) malloc(size)
#define ALLOCZ(size) calloc(size, 1)
#define REALLOC(pb, size) realloc(pb, size)
#define __GL_ATAN2F(a, b) atan2(a, b)
#define __GL_SQRTF(a) sqrtf(a)
                    
#define FREE(pb) free(pb);

struct SFCVertex
{
    D3DXVECTOR3 vPosition;
    D3DXVECTOR3 vNormal;
};

struct SFCFace16
{
    WORD rgwIndices[3];
};

// default starting size for arrays in a face context
const int x_cFaceContextDefaultSize = 100;

class CFaceContext
{
public:
    CFaceContext();
    ~CFaceContext();

    HRESULT Init();

    void SetCurrentNormal(D3DXVECTOR3 *pvNormalNew)
    {
        m_vCurrentNormal = *pvNormalNew;
    }

    void SetCurrentZ(float fZNew)
    {
        m_fCurrentZ = fZNew;
    }

    HRESULT AddStrip(D3DXVECTOR2 *rgvVertices, UINT cVertices, BOOL bCCW);
    HRESULT AddTriangle(D3DXVECTOR2 *rgvVertices, UINT cVertices, BOOL bCCW);
    HRESULT AddFan(D3DXVECTOR2 *rgvVertices, UINT cVertices, BOOL bCCW);
    HRESULT AddQuad(D3DXVECTOR3 *rgvVertices, D3DXVECTOR3 *rgvNormal, BOOL bCCW);
    HRESULT AddQuadStrip(D3DXVECTOR3 *rgvVertices, D3DXVECTOR3 *rgvNormal, UINT cVertices, BOOL bCCW);

    HRESULT CopyMesh(SFCFace16 *rgFaces, SFCVertex *rgVertices);
    HRESULT Translate(D3DXVECTOR3 *pvTrans);

    UINT CFaces() { return m_cFaces;}
    UINT CVertices() { return m_cVertices;}

//private:
    HRESULT ResizeFaces(UINT cNewMax);
    HRESULT ResizeVertices(UINT cNewMax);
    void AddFace(SFCFace16 *pface);
    HRESULT SetupPrim(D3DXVECTOR2 *rgvVertices, UINT cVertices, UINT cTriangles,UINT *piFirstIndex);

    SFCVertex   *m_rgvVertices;
    UINT        m_cVertices;
    UINT        m_cVerticesMax;

    SFCFace16   *m_rgFaces;
    UINT        m_cFaces;
    UINT        m_cFacesMax;

    // primitive generation data
    D3DXVECTOR3 m_vCurrentNormal;
    float       m_fCurrentZ;

	WCHAR m_wch;
};

// concatenate the letters together into one mesh
HRESULT 
GenerateMesh
(
    CFaceContext **rgpfcLetters,
    UINT cLetters,
    CGlyphObject* pGlyphObject
);

static const double   CoplanarThresholdAngle = PI/180.0/2.0; // 0.5 degreees

// outline prim types
#define PRIM_LINE     3
#define PRIM_CURVE    4

typedef struct {
    FLOAT x,y;
} POINT2D;

typedef struct {
    FLOAT x,y,z;
} POINT3D;

typedef struct {
    DWORD   primType;
    DWORD   nVerts;
    DWORD   VertIndex;// index into Loop's VertBuf
    POINT2D *pVert;   // ptr to vertex list in Loop's VertBuf
    POINT3D *pFNorm;  // face normals
    POINT3D *pVNorm;  // vertex normals
} PRIM;


typedef struct {
    PRIM    *PrimBuf;  // array of prims
    DWORD   nPrims;
    DWORD   PrimBufSize;
    POINT2D *VertBuf;  // buffer of vertices for the loop
    DWORD   nVerts;
    DWORD   VertBufSize;
    POINT3D *FNormBuf;  // buffer of face normals
    POINT3D *VNormBuf;  // buffer of vertex normals
} LOOP;

typedef struct {
    LOOP    *LoopBuf;  // array of loops
    DWORD   nLoops;
    DWORD   LoopBufSize;
} LOOP_LIST;

typedef struct {
    FLOAT        zExtrusion;
    INT          extrType;
    FLOAT*       FaceBuf;
    DWORD        FaceBufSize;
    DWORD        FaceBufIndex;
    DWORD        FaceVertexCountIndex;
#ifdef FONT_DEBUG
    BOOL         bSidePolys;
    BOOL         bFacePolys;
#endif
    HRESULT      hrTessErrorOccurred;
    CFaceContext        *pfc;
} EXTRContext;

// Memory pool for tesselation Combine callback
#define POOL_SIZE 50
typedef struct MEM_POOL MEM_POOL;

struct MEM_POOL {
    int      index;             // next free space in pool
    POINT2D  pool[POOL_SIZE];   // memory pool
    MEM_POOL *next;             // next pool
};


typedef struct {
    HRESULT             hrTessErrorOccurred;
    FLOAT               chordalDeviation;
    FLOAT               scale;
    int                 format;
    UCHAR*              glyphBuf;
    DWORD               glyphSize;
    HFONT               hfontOld;
    GLUtesselator*      tess;
    MEM_POOL            combinePool;     // start of MEM_POOL chain
    MEM_POOL            *curCombinePool; // currently active MEM_POOL
    EXTRContext         *ec;
} OFContext;  // Outline Font Context

EXTRContext*   extr_Init(                FLOAT       extrusion,  
                                         INT         format ); 

void           extr_Finish(              EXTRContext *ec );

void           extr_DrawLines(           EXTRContext *ec, 
                                         LOOP_LIST   *pLoopList );

BOOL           extr_DrawPolygons(        EXTRContext *ec,
                                         LOOP_LIST   *pLoopList );


BOOL           extr_PolyInit(            EXTRContext *ec );

void           extr_PolyFinish(          EXTRContext *ec );

void CALLBACK  extr_glBegin(             GLenum      primType,
                                         void        *data );

void CALLBACK  extr_glVertex(            GLfloat     *v,
                                         void        *data );

void CALLBACK  extr_glEnd(               void );

double         CalcAngle(                POINT2D     *v1, 
                                         POINT2D     *v2 );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\fontoutl.cpp ===
#include "stdafx.h"

#include <math.h>
#include <malloc.h>
#include "Glyph.h"

#define PRINT Print

CFile* g_pFile;
CStdioFile* g_pWrlFile;

void Print(const TCHAR* szMsg, ...)
{
	if (g_pWrlFile == NULL)
		return;

	va_list args;
	va_start(args, szMsg);

	TCHAR szBuffer [512];
	_vsntprintf(szBuffer, sizeof(szBuffer)/sizeof(TCHAR), szMsg, args);

	g_pWrlFile->WriteString(szBuffer);

	va_end(args);
}



#define D3DXASSERT ASSERT
#define RELEASE(p) { if ((p) != NULL) (p)->Release(); }

namespace D3DX
{
#include <GL\glu.h>  // doesn't link against GL, but needs the headers
#include "fontoutl.h"

static HRESULT CreateOFContext(      HDC         hdc,
                                        FLOAT       chordalDeviation,
                                        FLOAT       extrusion, 
                                        int         type,
                                        OFContext   **ppofc );

static BOOL  ScaleFont(                 HDC         hdc, 
                                        OFContext*  ofc,
                                        BOOL        bUnicode );

static void  DestroyOFContext(          HDC         hdc,
                                        OFContext*  ofc );

static BOOL  DrawGlyph(                 OFContext*  ofc );

static HRESULT  MakeDisplayListFromGlyph(  OFContext*     ofc
                                        );


static BOOL  MakeLinesFromArc(          OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     p0,
                                        POINT2D     p1,
                                        POINT2D     p2,
                                        FLOAT       chordalDeviationSquared);

static HRESULT MakeLinesFromGlyph(   OFContext*  ofc, LOOP_LIST** ppLoopList);

static BOOL  MakeLinesFromTTLine(       OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static BOOL  MakeLinesFromTTPolycurve(  OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTPolygon(    OFContext*  ofc, 
                                        LOOP_LIST*  pLoopList,
                                        UCHAR**     pp );

static BOOL  MakeLinesFromTTQSpline(    OFContext*  ofc, 
                                        LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        UCHAR**     pp,
                                        WORD        pointCount );

static void CALLBACK TessError(         GLenum      error,
                                        void        *data);

static void CALLBACK TessCombine(       GLdouble    coord[3], 
                                        POINT2D*    data[4], 
                                        GLfloat     w[4],
                                        POINT2D**   dataOut,
                                        void        *userData);

static void FreeCombinePool(            MEM_POOL    *combinePool );

static void ApplyVertexFilter(          LOOP_LIST   *pLoopList );

static void CheckRedundantVertices(     LOOP*       pLoop );

static BOOL PointsColinear(             POINT2D     *p1, 
                                        POINT2D     *p2, 
                                        POINT2D     *p3 ); 

static FLOAT      GetFixed(             UCHAR**     p );

static LOOP_LIST* InitLoopBuf(          void );

static LOOP*      NewLoop(              LOOP_LIST   *Loops, 
                                        POINT2D     *pFirstPoint );

static void       FreeLoopList(         LOOP_LIST   *pLoopList );

static PRIM*      NewPrim(              LOOP        *pLoop, 
                                        DWORD       primType );

static void       CalcVertPtrs(         LOOP        *pLoop );

static BOOL       AppendToVertBuf(      LOOP*       pLoop,
                                        PRIM*       pPrim,
                                        POINT2D     *p );


// macros to access data from byte streams:

// get WORD from byte stream, increment stream ptr by WORD
//#define GetWord( p ) \
    //( *( ((WORD *) *p)++ ) ) 

// get DWORD from byte stream, increment stream ptr by DWORD
//#define GetDWord( p ) \
    //( *( ((DWORD *) *p)++ ) ) 
static inline DWORD 
GetDWord(UCHAR **p)
{
    DWORD dwRet;
    dwRet = *((DWORD*)*p);
    *p += sizeof(DWORD);
    return dwRet;
}

static inline WORD 
GetWord(UCHAR **p)
{
    WORD wRet;
    wRet = *((WORD*)*p);
    *p += sizeof(WORD);
    return wRet;
}

static inline SHORT 
GetSignedWord(UCHAR **p)
{
    SHORT wRet;
    wRet = *((WORD*)*p);
    *p += sizeof(SHORT);
    return wRet;
}

// get signed word (SHORT) from byte stream, increment stream ptr by SHORT
//#define GetSignedWord( p ) \
    //( *( ((SHORT *) *p)++ ) ) 


#define POINT2DEQUAL( p1, p2 ) \
    ( (p1->x == p2->x) && (p1->y == p2->y) )





/*****************************************************************************
 * MakeDisplayListFromGlyph
 * 
 * Converts the outline of a glyph to OpenGL drawing primitives, tessellating
 * as needed, and then draws the glyph.  Tessellation of the quadratic splines
 * in the outline is controlled by "chordalDeviation", and the drawing
 * primitives (lines or polygons) are selected by "format".
 *
 * Return value is nonzero for success, zero for failure.
 *
 * Does not check for OpenGL errors, so if the caller needs to know about them,
 * it should call glGetError().

 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/


static
HRESULT
MakeDisplayListFromGlyph
( 
    OFContext *ofc 
)
{
    HRESULT             hr = S_OK;
    DWORD               nLoops;
    DWORD               nVerts;
    LOOP_LIST           *pLoopList;
    LOOP                *pLoop;
    POINT2D             *p;
    MEM_POOL            *mp = NULL;

    /*
     * Convert the glyph outlines to a set of polyline loops.
     * (See MakeLinesFromGlyph() for the format of the loop data
     * structure.)
     */
    hr = MakeLinesFromGlyph(ofc, &pLoopList);
    if (FAILED(hr))
        goto e_Exit;

    /*
     * Filter out unnecessary vertices
     */
    ApplyVertexFilter( pLoopList );

    D3DXASSERT(ofc->format == WGL_FONT_POLYGONS);

    {
        GLdouble v[3];

        /*
         * This is the hard case.  We have to set up a tessellator
         * to convert the outlines into a set of polygonal
         * primitives, which the tessellator passes to some
         * auxiliary routines for drawing.
         */

        /* Initialize polygon extrusion for the glyph.
         * This prepares for tracking of the tesselation in order to
         * build the Back-facing polygons.
         */

        mp = &ofc->combinePool;
        ofc->curCombinePool = mp;
        mp->index = 0;
        mp->next = NULL;

        if( ofc->ec ) 
        {
            if( !extr_PolyInit( ofc->ec ) )
                goto e_Exit;

        }

        ofc->hrTessErrorOccurred = S_OK;
        v[2] = 0.0;
        gluTessBeginPolygon( ofc->tess, ofc );

        /*
         * Each loop returned from MakeLinesFromGlyph is closed (first and 
         * last points are the same).  The old tesselator had trouble with
         * this.  Since the tesselator automatically closes all loops,
         * we skip the last point to be on the safe side.
         */

        nLoops = pLoopList->nLoops;
        pLoop = pLoopList->LoopBuf;
        for( ; nLoops; nLoops--, pLoop++ )
        {
            gluTessBeginContour( ofc->tess );
                
            nVerts = pLoop->nVerts - 1;  // skip last point

            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ )
            {
                v[0] = p->x;
                v[1] = p->y;
                gluTessVertex(ofc->tess, v, p);
            }
            gluTessEndContour( ofc->tess );
        }

        gluTessEndPolygon( ofc->tess );

        if (FAILED(ofc->hrTessErrorOccurred))
        {
            hr = ofc->hrTessErrorOccurred;
            goto e_Exit;
        }

        if( ofc->ec ) {
            /* check for OUT_OF_MEMORY_ERROR in extrusion lib, that might
             * have occured during tesselation tracking.
             */
            if( FAILED(ofc->ec->hrTessErrorOccurred) )
            {
                hr = ofc->ec->hrTessErrorOccurred;
                goto e_Exit;
            }

            if( !extr_DrawPolygons( ofc->ec, pLoopList ) ) 
                goto e_Exit; 
        }
    }

e_Exit:
    /*
     * Putting PolyFinish here means PolyInit may not have been called.
     * This is ok.
     */
    if( mp )
        FreeCombinePool( mp );
    if( pLoopList )
        FreeLoopList( pLoopList );
    if( ofc->ec )
        extr_PolyFinish( ofc->ec );

    return hr;
}

/*****************************************************************************
 * TessCombine
 *
 * Tesselation callback for loop intersection.  We have to allocate a vertex
 * and return it to tesselator.  Allocation is from the context's static pool.
 * If this runs dry, then a linked list of MEM_POOL blocks is used.

*****************************************************************************/
 
static void CALLBACK
TessCombine( GLdouble coord[3], POINT2D *data[4], GLfloat w[4],
             POINT2D **dataOut, void *userData )
{
    OFContext *ofc = (OFContext *) userData;
    MEM_POOL *mp = ofc->curCombinePool;
    POINT2D *p;

    // make sure there's room available in the current pool block
    if( mp->index >=  POOL_SIZE )
    {
        // we need to allocate another MEM_POOL block
        MEM_POOL *newPool;

        newPool = (MEM_POOL *) ALLOC( sizeof(MEM_POOL) );
        if( !newPool )
            // tesselator will handle any problem with this
            return;

        newPool->index = 0;
        newPool->next = NULL;
        mp->next = newPool;
        mp = newPool;
        ofc->curCombinePool = mp; // new pool becomes the current pool
    }

    p = mp->pool + mp->index;
    p->x = (GLfloat) coord[0];        
    p->y = (GLfloat) coord[1];        
    mp->index ++;

    *dataOut = p;
}

/*****************************************************************************
 * FreeCombinePool
 *
 * Frees any pools of memory allocated by TessCombine callback

*****************************************************************************/
static void
FreeCombinePool( MEM_POOL *memPool )
{
    MEM_POOL *nextPool;

    memPool = memPool->next;  // first pool in list is static part of context
    while( memPool ) {
        nextPool = memPool->next;
        FREE( memPool );
        memPool = nextPool;
    }
}

/*****************************************************************************
 * TessError
 *
 * Saves the last tessellator error code in ofc->TessErrorOccurred.

*****************************************************************************/
 
static void CALLBACK
TessError(GLenum error, void *data)
{
    OFContext *ofc = (OFContext *) data;

    // Only some of these errors are fatal:
    switch( error ) {
        case GLU_TESS_COORD_TOO_LARGE:
        case GLU_TESS_NEED_COMBINE_CALLBACK:
            ofc->hrTessErrorOccurred = E_OUTOFMEMORY;
            break;
        default:
            break;
    }
}



/*****************************************************************************
 * MakeLinesFromGlyph
 * 
 * Converts the outline of a glyph from the TTPOLYGON format into
 * structures of Loops, Primitives and Vertices.
 *
 * Line segments from the TTPOLYGON are transferred to the output array in
 * the obvious way.  Quadratic splines in the TTPOLYGON are converted to
 * collections of line segments

*****************************************************************************/


static HRESULT
MakeLinesFromGlyph
( 
    OFContext* ofc,
    LOOP_LIST **ppLoopList
)
{
    UCHAR*  p;
    HRESULT hr = S_OK;
    LOOP_LIST *pLoopList;

    *ppLoopList = NULL;

    /*
     * Initialize the buffer into which we place the loop data:
     */
    if( !(pLoopList = InitLoopBuf()) )
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    p = ofc->glyphBuf;
    while (p < ofc->glyphBuf + ofc->glyphSize)
    {
        if( !MakeLinesFromTTPolygon( ofc, pLoopList, &p) )
        {
            WARNING("D3DXMakeLinesFromTTPolygon Failed!\n");
            hr = E_FAIL;
            goto e_Exit;
        }
    }

    *ppLoopList = pLoopList;
    pLoopList = NULL;
e_Exit:
    if (pLoopList != NULL) 
    {
        FreeLoopList( pLoopList );
    }
    
    return hr;
}



/*****************************************************************************
 * MakeLinesFromTTPolygon
 *
 * Converts a TTPOLYGONHEADER and its associated curve structures into a
 * LOOP structure.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolygon( IN      OFContext*  ofc, 
                        IN      LOOP_LIST*  pLoopList,
                        IN OUT  UCHAR**     pp)
{
    DWORD   polySize;
    UCHAR*  polyStart;
    POINT2D *pFirstP, *pLastP, firstPoint;
    LOOP    *pLoop;
    PRIM    *pPrim;

    /*
     * Record where the polygon data begins.
     */
    polyStart = *pp;

    /*
     * Extract relevant data from the TTPOLYGONHEADER:
     */
    polySize = GetDWord(pp);
    if( GetDWord(pp) != TT_POLYGON_TYPE )  /* polygon type */
        return WFO_FAILURE;
    firstPoint.x = ofc->scale * GetFixed(pp); // 1st X coord
    firstPoint.y = ofc->scale * GetFixed(pp); // 1st Y coord

    /* 
     * Initialize a new LOOP struct in the LoopBuf, with the first point
     */
    if( !(pLoop = NewLoop( pLoopList, &firstPoint )) )
        return WFO_FAILURE;
    
    /*
     * Process each of the TTPOLYCURVE structures in the polygon:
     */

    while (*pp < polyStart + polySize) {
        if( !MakeLinesFromTTPolycurve(  ofc, pLoop, pp ) )
            return WFO_FAILURE;
    }

    /* Now have to fix up end of loop : after studying the chars, it
     * was determined that if a curve started with a line, and ended with
     * a qspline, AND the first and last point were not the same, then there
     * is an implied line joining the two.
     * In any case, we also make sure here that first and last points are
     * coincident.
     */
    
    pLastP = (POINT2D *) (pLoop->VertBuf+pLoop->nVerts-1);
    pFirstP = &firstPoint;

    if( !POINT2DEQUAL( pLastP, pFirstP ) ) {
        // add 1-vertex line prim at the end

        if( !(pPrim = NewPrim( pLoop, TT_PRIM_LINE)) )
            return WFO_FAILURE;

        if ( !AppendToVertBuf( pLoop, pPrim, pFirstP) )
            return WFO_FAILURE;
    }

    /* At end of each loop, calculate pVert for each PRIM from its
     * VertIndex value (for convenience later).
     */
    CalcVertPtrs( pLoop );

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTPolyCurve
 *
 * Converts the lines and splines in a single TTPOLYCURVE structure to points
 * in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromTTPolycurve( IN     OFContext* ofc, 
                          IN     LOOP*      pLoop,
                          IN OUT UCHAR**    pp )
{
    WORD type;
    WORD pointCount;
    PRIM *pPrim;

    /*
     * Pick up the relevant fields of the TTPOLYCURVE structure:
     */
    type = GetWord(pp);
    pointCount = GetWord(pp);

    if( !(pPrim = NewPrim( pLoop, type )) )
        return WFO_FAILURE;

    /*
     * Convert the "curve" to line segments:
     */
    if (type == TT_PRIM_LINE) {
        return MakeLinesFromTTLine( ofc, pLoop, pPrim, pp, pointCount);

    } else if (type == TT_PRIM_QSPLINE) {
        return MakeLinesFromTTQSpline( ofc, pLoop, pPrim, pp, pointCount );

    } else
        return WFO_FAILURE;
}



/*****************************************************************************
 * MakeLinesFromTTLine
 *
 * Converts points from the polyline in a TT_PRIM_LINE structure to
 * equivalent points in the Loop.

*****************************************************************************/
static BOOL
MakeLinesFromTTLine(    IN     OFContext* ofc, 
                        IN     LOOP*      pLoop,
                        IN     PRIM*      pPrim,
                        IN OUT UCHAR**    pp,
                        IN     WORD       pointCount)
{
    POINT2D p;

    /*
     * Just copy the line segments into the vertex buffer (converting
     * type as we go):
     */

    while (pointCount--)
    {
        p.x = ofc->scale * GetFixed(pp); // X coord 
        p.y = ofc->scale * GetFixed(pp); // Y coord
        if( !AppendToVertBuf( pLoop, pPrim, &p ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromTTQSpline
 *
 * Converts points from the poly quadratic spline in a TT_PRIM_QSPLINE
 * structure to polyline points in the Loop. 

*****************************************************************************/

static BOOL
MakeLinesFromTTQSpline( IN      OFContext*  ofc, 
                        IN      LOOP*       pLoop,
                        IN      PRIM*       pPrim,
                        IN  OUT UCHAR**     pp,
                        IN      WORD        pointCount )
{
    POINT2D p0, p1, p2;
    WORD point;
    POINT2D p;

    /*
     * Process each of the non-interpolated points in the outline.
     * To do this, we need to generate two interpolated points (the
     * start and end of the arc) for each non-interpolated point.
     * The first interpolated point is always the one most recently
     * stored in VertBuf, so we just extract it from there.  The
     * second interpolated point is either the average of the next
     * two points in the QSpline, or the last point in the QSpline
     * if only one remains.
     */

    // Start with last generated point in VertBuf
    p0 = *(pLoop->VertBuf + pLoop->nVerts - 1);

    // pointCount should be >=2, but in case it's not...
    p1 = p2 = p0;

    for (point = 0; point < pointCount - 1; ++point)
    {
        p1.x = ofc->scale * GetFixed(pp);
        p1.y = ofc->scale * GetFixed(pp);

        if (point == pointCount - 2)
        {
            /*
             * This is the last arc in the QSpline.  The final
             * point is the end of the arc.
             */
            p2.x = ofc->scale * GetFixed(pp);
            p2.y = ofc->scale * GetFixed(pp);
        }
        else
        {
            /*
             * Peek at the next point in the input to compute
             * the end of the arc:
             */
            p.x = ofc->scale * GetFixed(pp);
            p.y = ofc->scale * GetFixed(pp);
            p2.x = 0.5f * (p1.x + p.x);
            p2.y = 0.5f * (p1.y + p.y);
            /*
             * Push the point back onto the input so it will
             * be reused as the next off-curve point:
             */
            *pp -= 2*sizeof(FIXED); // x and y
        }

        if( !MakeLinesFromArc(  ofc,
                                pLoop,
                                pPrim,
                                p0,
                                p1,
                                p2,
                                ofc->chordalDeviation * ofc->chordalDeviation))
            return WFO_FAILURE;

        // p0 is now the last interpolated point (p2)
        p0 = p2;
    }

    // put in last point in arc
    if( !AppendToVertBuf( pLoop, pPrim, &p2 ) )
        return WFO_FAILURE;

    return WFO_SUCCESS;
}


/*****************************************************************************
 * MakeLinesFromArc
 *
 * Subdivides one arc of a quadratic spline until the chordal deviation
 * tolerance requirement is met, then places the resulting set of line
 * segments in the Loop.

*****************************************************************************/

static BOOL
MakeLinesFromArc(   IN OFContext *ofc, 
                    IN LOOP*     pLoop,
                    IN PRIM*     pPrim,
                    IN POINT2D   p0,
                    IN POINT2D   p1,
                    IN POINT2D   p2,
                    IN FLOAT     chordalDeviationSquared)
{
    POINT2D p01;
    POINT2D p12;
    POINT2D midPoint;
    FLOAT   deltaX;
    FLOAT   deltaY;

    /*
     * Calculate midpoint of the curve by de Casteljau:
     */
    p01.x = 0.5f * (p0.x + p1.x);
    p01.y = 0.5f * (p0.y + p1.y);
    p12.x = 0.5f * (p1.x + p2.x);
    p12.y = 0.5f * (p1.y + p2.y);
    midPoint.x = 0.5f * (p01.x + p12.x);
    midPoint.y = 0.5f * (p01.y + p12.y);


    /*
     * Estimate chordal deviation by the distance from the midpoint
     * of the curve to its non-interpolated control point.  If this
     * distance is greater than the specified chordal deviation
     * constraint, then subdivide.  Otherwise, generate polylines
     * from the three control points.
     */
    deltaX = midPoint.x - p1.x;
    deltaY = midPoint.y - p1.y;
    if (deltaX * deltaX + deltaY * deltaY > chordalDeviationSquared)
    {
        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               p0,
                               p01,
                               midPoint,
                               chordalDeviationSquared) )
            return WFO_FAILURE;

        if( !MakeLinesFromArc( ofc, pLoop, pPrim, 
                               midPoint,
                               p12,
                               p2,
                               chordalDeviationSquared) )
            return WFO_FAILURE;
    }
    else
    {
        /*
         * The "pen" is already at (x0, y0), so we don't need to
         * add that point to the LineBuf.
         */
        if( !AppendToVertBuf( pLoop, pPrim, &p1 ) )
            return WFO_FAILURE;
    }

    return WFO_SUCCESS;
}


/*****************************************************************************
 * ApplyVertexFilter
 *
 * Filter the vertex buffer to get rid of redundant vertices.
 * These can occur on Primitive boundaries.

*****************************************************************************/
static void ApplyVertexFilter( LOOP_LIST *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;

    for( ; nLoops; nLoops--, pLoop++ ) {
        CheckRedundantVertices( pLoop );
    }
}

/*****************************************************************************
 * CheckRedundantVertices
 *
 * Check for redundant vertices on Curve-Curve boundaries (including loop
 * closure), and get rid of them, using in-place algorithm.

*****************************************************************************/

static void CheckRedundantVertices( LOOP  *pLoop )
{
    PRIM *pPrim, *pNextPrim; 
    DWORD nVerts;
    BOOL bEliminate, bLastEliminate;
    DWORD nEliminated=0, nPrims;
    POINT2D *pVert, *pVert2ndToLast;
    
    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pNextPrim = pPrim + 1;
    
    nPrims--; // the last prim is dealt with afterwards
    for( ; nPrims; nPrims--, pPrim = pNextPrim++ ) {
        bEliminate = FALSE;
        nVerts = pPrim->nVerts;

        // check spline<->* boundaries
        if( (pPrim->nVerts >= 2) &&
            ((pPrim->primType     == PRIM_CURVE ) || 
             (pNextPrim->primType == PRIM_CURVE )) ) {

            /* get ptr to 2nd-to-last vertex in current prim 
             * !! Note that last vertex in current prim and first vertex in
             *  next prim are the same.
             */
            pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2;
            if( PointsColinear( pVert2ndToLast, 
                                pVert2ndToLast+1,
                                pNextPrim->pVert+1 ) ) {
                // we eliminate last vertex in current prim
                bEliminate = TRUE;
                pPrim->nVerts--; 
                nVerts--;
            }
        }

        /* move vertices up in vertBuf if necessary (if any vertices
         * were PREVIOUSLY eliminated)
         */
        if( nEliminated ) {
            pVert = pPrim->pVert - nEliminated; // new pVert
            memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D));
            pPrim->pVert = pVert;
        }
        if( bEliminate ) {
            nEliminated += 1;
        }
    }

    /* also check for redundancy at closure:
     * - replace firstPrim's first vertex with 2nd-to-last of last prim
     * - eliminate last vertex in last prim
     */
    bLastEliminate = bEliminate;
    bEliminate = FALSE;
    nVerts = pPrim->nVerts;
    pNextPrim = pLoop->PrimBuf; // first prim in loop

    if( (pPrim->nVerts >= 2) &&
        ((pPrim->primType     == PRIM_CURVE ) || 
         (pNextPrim->primType == PRIM_CURVE )) ) {

        POINT2D *pVertLast;

        pVert2ndToLast = pPrim->pVert + pPrim->nVerts - 2; // always >=2 verts
        pVertLast = pVert2ndToLast + 1;

        if( (pPrim->nVerts == 2) && bLastEliminate )
            /* 2ndToLast vert (same as first vert) of this prim has
             * been eliminated.  Deal with it by backing up the ptr.
             * This didn't matter in above loop, because there wasn't the
             * possibility of munging the first vertex in the loop
             */
            pVert2ndToLast--;

        // point to 2nd-to-last vertex in prim
        if( PointsColinear( pVert2ndToLast, 
                            pVertLast,
                            pNextPrim->pVert+1 ) ) {
            bEliminate = TRUE;
            pPrim->nVerts--; 
            // munge first prim's first vertex
            /* problem here if have 2 eliminations in a row, and pPrim was
             * a 2 vertex prim - then pVert2ndToLast is pointing to an
             * eliminated vertex
             */
            *(pNextPrim->pVert) = *(pVert2ndToLast);
            nVerts--;
        }
    }

    // move up last prim's vertices if necessary
    if( nEliminated ) {
        pVert = pPrim->pVert - nEliminated; // new pVert
        memcpy( pVert+1, pPrim->pVert+1, (nVerts-1)*sizeof(POINT2D) );
        // This misses copying one vertex
        pPrim->pVert = pVert;
    }

    if( bEliminate ) {
        nEliminated += 1;
    }

    // now update vertex count in Loop
    pLoop->nVerts -= nEliminated;

    // Check for prims with nVerts=1 (invalidated), and remove them

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    nEliminated = 0;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->nVerts == 1 ) {
            nEliminated++;
            continue;
        }
        *(pPrim-nEliminated) = *pPrim;
    }
    pLoop->nPrims -= nEliminated;
}

/*****************************************************************************
 * PointsColinear
 *
 * Returns TRUE if the 3 points are colinear enough.

*****************************************************************************/

static BOOL PointsColinear( POINT2D *p1,
                            POINT2D *p2,
                            POINT2D *p3 )
{
    POINT2D v1, v2;

    // compare slopes of the 2 vectors? - optimize later
    if( POINT2DEQUAL( p1, p2 ) || POINT2DEQUAL( p2, p3 ) )
        // avoid sending 0 vector to CalcAngle (generates FPE)
        return TRUE;

    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    v2.x = p3->x - p2->x;
    v2.y = p3->y - p2->y;
    if( fabs(CalcAngle( &v1, &v2 )) < CoplanarThresholdAngle )
        return TRUE;

    return FALSE;
}


/*****************************************************************************
 * CreateOFContext
 *
 * Create and initialize the outline font context.
 *
 * History:
 *  26-Sep-1995 -by- Marc Fortier [marcfo]
 * Use extrusioniser to draw polygonal faces with extrusion=0

*****************************************************************************/

static HRESULT CreateOFContext( HDC    hdc,
                                   FLOAT  chordalDeviation,
                                   FLOAT  extrusion, 
                                   INT    format,
                                   OFContext **ppofc
                                   )
{
    OFContext *ofc = (OFContext *) NULL;
    HRESULT hr = S_OK;
 
    // validate parameters

    if( (format != WGL_FONT_LINES) && (format != WGL_FONT_POLYGONS) ) 
    {
        WARNING("D3DXUseFontOutlines: invalid format parameter\n");
        hr = E_INVALIDARG;
        goto e_Exit;
    }


    ofc = (OFContext *) ALLOCZ( sizeof(OFContext) );
    if (ofc == NULL) 
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }

    ofc->format = format;
    ofc->chordalDeviation = chordalDeviation;

    if( !ScaleFont( hdc, ofc, TRUE) )
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // handle extrusion
    ofc->ec = extr_Init( extrusion, format );
    if(ofc->ec == NULL) 
    {
        hr = E_FAIL;
        goto e_Exit;
    }

    // init a tess obj
    ofc->tess = NULL;
    //if( ofc->format == WGL_FONT_POLYGONS ) 
    D3DXASSERT(ofc->format == WGL_FONT_POLYGONS);
    {
        GLUtesselator *tess;

        tess = gluNewTess();
        if (tess == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // insert own callbacks here
        gluTessCallback(tess, GLU_TESS_BEGIN_DATA,  
                                (void(CALLBACK*)()) extr_glBegin);
        gluTessCallback(tess, GLU_TESS_END,    
                                (void(CALLBACK*)()) extr_glEnd);
        gluTessCallback(tess, GLU_TESS_VERTEX_DATA, 
                                (void(CALLBACK*)()) extr_glVertex);

        gluTessCallback(tess, GLU_TESS_ERROR_DATA,        
                                        (void(CALLBACK*)()) TessError);
        gluTessCallback(tess, GLU_TESS_COMBINE_DATA, 
                                        (void(CALLBACK*)()) TessCombine);

        // set tesselator normal and winding rule

        gluTessNormal( tess, 0.0, 0.0, 1.0 );
        gluTessProperty( tess, GLU_TESS_WINDING_RULE, GLU_TESS_WINDING_NONZERO);

        ofc->tess = tess;
    }

    *ppofc = ofc;
    ofc = NULL;

e_Exit:
    if (ofc != NULL)
    {
        DestroyOFContext( hdc, ofc );
    }

    return hr;
}

/*****************************************************************************
* ScaleFont
*
* To get the best representation of the font, we use its design height, or
* the emSquare size.  We then scale emSquare to 1.0.
* A maxChordTolerance value is set, otherwise it was found that some
* glyphs displayed ugly loop intersections.  The value .035f was chosen
* after cursory examination of the glyphs. 
*
* History:
*  31-Jul-1995 -by- [marcfo]
* Get rid of unicode functions - since we're just accessing text metrics,
* the default 'string' functions should work on all platforms.
*****************************************************************************/

static BOOL
ScaleFont( HDC hdc, OFContext *ofc, BOOL bUnicode )
{
    OUTLINETEXTMETRIC otm;
    HFONT       hfont;
    LOGFONT    lf;
    FLOAT       scale, maxChordTolerance=0.035f;
    UINT        otmEMSquare;

    // Query font metrics

    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 )
    {
        WARNING("D3DXGetOutlineTextMetrics failed.  Probably no font selected\n");
        // cmd failed, or buffer size=0
        return WFO_FAILURE;
    }

    otmEMSquare = otm.otmEMSquare;

    /*
     * The font data is scaled, so that 1.0 maps to the font's em square
     * size.  Note that it is still possible for glyphs to extend beyond
     * this square.
     */
    scale = 1.0f / (FLOAT) otmEMSquare;

    // create new font object, using largest size

    hfont = (HFONT)GetCurrentObject( hdc, OBJ_FONT );
    GetObject( hfont, sizeof(LOGFONT), &lf );
    lf.lfHeight = otmEMSquare;
    lf.lfWidth = 0;  // this will choose default width for the height
    hfont = CreateFontIndirect(&lf);

    // select new font into DC, and save current font
    ofc->hfontOld = (HFONT)SelectObject( hdc, hfont );

    // set ofc values

    ofc->scale = scale;

    /* check chord tolerance: in design space, minimum chord tolerance is
     * ~1 logical unit, = ofc->scale.
     */
    if( ofc->chordalDeviation == 0.0f ) {
        // select minimum tolerance in this case
        ofc->chordalDeviation = ofc->scale;
    }
    /* also impose a maximum, or things can get ugly */
    else if( ofc->chordalDeviation > maxChordTolerance ) {
        // XXX might want to change maxChordTolerance based on scale ?
        ofc->chordalDeviation = maxChordTolerance;
    }

    return WFO_SUCCESS;
}

/*****************************************************************************
 * DestroyOFContext
 *
*****************************************************************************/

static void 
DestroyOFContext( HDC hdc, OFContext* ofc )
{
    HFONT hfont;

    if( ofc->ec ) {
        extr_Finish( ofc->ec );
    }

    // put back original font object
    if( ofc->hfontOld ) {
        hfont = (HFONT)SelectObject( hdc, ofc->hfontOld );
        DeleteObject( hfont );
    }

    if( ofc->format == WGL_FONT_POLYGONS ) {
        if( ofc->tess )
            gluDeleteTess( ofc->tess );
    }

    FREE( ofc );
}

/*****************************************************************************
 * InitLoopBuf
 *
 * Initializes a LOOP_LIST structure for the Loops of each glyph.

*****************************************************************************/

static LOOP_LIST*
InitLoopBuf( void )
{
    LOOP *pLoop;
    LOOP_LIST *pLoopList;
    DWORD initSize = 10;

    pLoopList = (LOOP_LIST*) ALLOC( sizeof(LOOP_LIST) );
    if( !pLoopList )
        return( (LOOP_LIST *) NULL );

    pLoop = (LOOP*) ALLOC( initSize * sizeof(LOOP) );
    if( !pLoop ) {
        FREE( pLoopList );
        return( (LOOP_LIST *) NULL );
    }

    pLoopList->LoopBuf = pLoop;
    pLoopList->nLoops = 0;
    pLoopList->LoopBufSize = initSize;

    return pLoopList; 
}

/*****************************************************************************
 * NewLoop
 * 
 * Create a new LOOP structure.  The first point in the loop is supplied.

*****************************************************************************/

static LOOP*
NewLoop( LOOP_LIST *pLoopList, POINT2D *pFirstPoint )
{
    LOOP    *pNewLoop;
    PRIM    *pPrim;
    POINT2D *pVert;
    DWORD   size = 50;

    if( pLoopList->nLoops >=  pLoopList->LoopBufSize)
    {
        // need to increase size of LoopBuf
        LOOP *pLoop;

        pLoop = (LOOP*) REALLOC(pLoopList->LoopBuf,  
                                (pLoopList->LoopBufSize += size) *
                                sizeof(LOOP));
        if( !pLoop )
            return (LOOP *) NULL;
        pLoopList->LoopBuf = pLoop;
    }

    pNewLoop = pLoopList->LoopBuf + pLoopList->nLoops;

    // give the loop a block of prims to work with
    pPrim = (PRIM *) ALLOC( size * sizeof(PRIM) );
    if( !pPrim )
        return (LOOP *) NULL;
    pNewLoop->PrimBuf = pPrim;
    pNewLoop->nPrims = 0;
    pNewLoop->PrimBufSize = size;

    // give the loop a block of vertices to work with
    pVert = (POINT2D*) ALLOC( size * sizeof(POINT2D) );
    if( !pVert ) {
        FREE( pPrim );
        return (LOOP *) NULL;
    }
    pNewLoop->VertBuf = pVert;
    pNewLoop->nVerts = 0;
    pNewLoop->VertBufSize = size;

    // stick that first point in
    pVert->x = pFirstPoint->x;
    pVert->y = pFirstPoint->y;
    pNewLoop->nVerts++;

    // normal buffers - used by extrusion
    pNewLoop->FNormBuf = (POINT3D *) NULL;
    pNewLoop->VNormBuf = (POINT3D *) NULL;

    pLoopList->nLoops++; // increment loop count

    return pNewLoop;
}

/*****************************************************************************
 * NewPrim
 *
 * Create a new PRIM structure.  The primType is supplied.

*****************************************************************************/

static PRIM*
NewPrim( LOOP *pLoop, DWORD primType )
{
    PRIM    *pNewPrim;
    DWORD   size = 50;

    if( pLoop->nPrims >=  pLoop->PrimBufSize)
    {
        // need to increase size of PrimBuf
        PRIM *pPrim;

        pPrim = (PRIM *) REALLOC(pLoop->PrimBuf,  
                                 (pLoop->PrimBufSize += size) * sizeof(PRIM));
        if( !pPrim )
            return (PRIM *) NULL;
        pLoop->PrimBuf = pPrim;
    }

    pNewPrim = pLoop->PrimBuf + pLoop->nPrims;
    // translate primType to extrusion prim type
    primType = (primType == TT_PRIM_LINE) ? PRIM_LINE : PRIM_CURVE;
    pNewPrim->primType = primType;
    pNewPrim->nVerts = 1;  // since we include last point:
    /* 
     * VertIndex must point to the last point of the previous prim
     */
    pNewPrim->VertIndex = pLoop->nVerts - 1;
    // normal pointers - used by extrusion
    pNewPrim->pFNorm = (POINT3D *) NULL;
    pNewPrim->pVNorm = (POINT3D *) NULL;

    pLoop->nPrims++; // increment prim count

    return pNewPrim;
}

/*****************************************************************************
 * FreeLoopList
 *
 * Free up all memory associated with processing a glyph.
 *
*****************************************************************************/

static void
FreeLoopList( LOOP_LIST *pLoopList )
{
    DWORD nLoops;

    if( !pLoopList )
        return;

    if( pLoopList->LoopBuf ) {
        // free up each loop
        LOOP *pLoop = pLoopList->LoopBuf;

        nLoops = pLoopList->nLoops;
        for( ; nLoops; nLoops--, pLoop++ ) {
            if( pLoop->PrimBuf )
                FREE( pLoop->PrimBuf );
            if( pLoop->VertBuf )
                FREE( pLoop->VertBuf );
        } 
        FREE( pLoopList->LoopBuf );
    }
    FREE( pLoopList );
}

/*****************************************************************************
 * AppendToVertBuf
 *
 * Append a vertex to the Loop's VertBuf

*****************************************************************************/

static BOOL
AppendToVertBuf( LOOP      *pLoop,
                 PRIM      *pPrim,
                 POINT2D   *p )
{
    if( pLoop->nVerts >=  pLoop->VertBufSize)
    {
        POINT2D *vertBuf;
        DWORD   size = 100;

        vertBuf = (POINT2D *) REALLOC(pLoop->VertBuf,
                                      (pLoop->VertBufSize += size) *
                                      sizeof(POINT2D));
        if( !vertBuf )
            return WFO_FAILURE;
        pLoop->VertBuf = vertBuf;
    }
    pLoop->VertBuf[pLoop->nVerts] = *p;
    pLoop->nVerts++;
    pPrim->nVerts++;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalcVertPtrs
 *
 * Calculate vertex ptrs from index values for the prims in a loop.

*****************************************************************************/

static void
CalcVertPtrs( LOOP *pLoop )
{
    DWORD nPrims;
    PRIM  *pPrim;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; pPrim++, nPrims-- ) {
        pPrim->pVert = pLoop->VertBuf + pPrim->VertIndex;
    }
}


/*****************************************************************************
 * GetFixed
 *
 * Fetch the next 32-bit fixed-point value from a little-endian byte stream,
 * convert it to floating-point, and increment the stream pointer to the next
 * unscanned byte.

*****************************************************************************/

static FLOAT GetFixed(UCHAR** p)
{
    FLOAT value;
    FLOAT fraction;

    fraction = ((FLOAT) (UINT) GetWord(p)) / 65536.0f;
    value    = (FLOAT) GetSignedWord(p);

    return value+fraction;
}

/*****************************************************************************
 *      CFaceContext implementation
*****************************************************************************/

/*****************************************************************************
 * CFaceContext Constructor, just setup so that delete works
 *
*****************************************************************************/
CFaceContext::CFaceContext()
   :m_rgvVertices(NULL),
    m_cVertices(0),
    m_cVerticesMax(0),
    m_rgFaces(NULL),
    m_cFaces(0),
    m_cFacesMax(0),
    m_vCurrentNormal(0.0f,0.0f,0.0f),
    m_fCurrentZ(0.0f),
	m_wch(0)
{
}

/*****************************************************************************
 * CFaceContext Destructor, just blow away allocated memory
 *
*****************************************************************************/
CFaceContext::~CFaceContext()
{
    delete []m_rgvVertices;
    delete []m_rgFaces;
}

/*****************************************************************************
 * CFaceContext Init - resets face and vertex counts
 *                  if this is the first init it also pre-allocates arrays
 *
*****************************************************************************/
HRESULT 
CFaceContext::Init()
{
    m_cFaces = 0;
    m_cVertices = 0;

    if (m_cFacesMax == 0)
    {
        m_cFacesMax = x_cFaceContextDefaultSize;
        m_rgFaces = new SFCFace16[m_cFacesMax];
        if (m_rgFaces == NULL)
            return E_OUTOFMEMORY;
    }

    if (m_cVerticesMax == 0)
    {
        m_cVerticesMax = x_cFaceContextDefaultSize;
        m_rgvVertices = new SFCVertex[m_cVerticesMax];
        if (m_rgvVertices == NULL)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

/*****************************************************************************
 * CFaceContext ResizeFaces - resize the face array to a new maximum
 *
*****************************************************************************/
HRESULT CFaceContext::ResizeFaces(UINT cNewMax)
{
    SFCFace16 *rgFacesNew;
    D3DXASSERT(cNewMax > m_cFacesMax);

    m_cFacesMax = cNewMax;
    rgFacesNew = new SFCFace16[m_cFacesMax];
    if (m_rgFaces == NULL)
        return E_OUTOFMEMORY;

    memcpy(rgFacesNew, m_rgFaces, sizeof(SFCFace16) * m_cFaces);

    delete []m_rgFaces;
    m_rgFaces = rgFacesNew;

    return S_OK;
}

/*****************************************************************************
 * CFaceContext ResizeVertices - resize the vertex array to a new maximum
 *
*****************************************************************************/
HRESULT 
CFaceContext::ResizeVertices(UINT cNewMax)
{
    SFCVertex *rgVerticesNew;
    D3DXASSERT(cNewMax > m_cVerticesMax);

    m_cVerticesMax = cNewMax;
    rgVerticesNew = new SFCVertex[m_cVerticesMax];
    if (rgVerticesNew == NULL)
        return E_OUTOFMEMORY;

    memcpy(rgVerticesNew, m_rgvVertices, sizeof(SFCVertex) * m_cVertices);

    delete []m_rgvVertices;
    m_rgvVertices = rgVerticesNew;

    return S_OK;
}

/*****************************************************************************
 * CFaceContext AddFace - adds the face to the face array
 *
*****************************************************************************/
void
CFaceContext::AddFace
(
    SFCFace16 *pface
)
{
    D3DXASSERT(m_cFaces < m_cFacesMax);
    m_rgFaces[m_cFaces] = *pface;
    m_cFaces++;
}

/*****************************************************************************
 * CFaceContext::SetupPrim - Helper function for the triangle prim methods
 *              Adds given vertices and resizes the arrays
 *
*****************************************************************************/
HRESULT CFaceContext::SetupPrim
(
    D3DXVECTOR2 *rgvVertices, 
    UINT cVertices,
    UINT cTriangles,
    UINT *piFirstIndex
)
{
    UINT iVertex;
    UINT iCurIndex;
    HRESULT hr;

    if (cVertices + m_cVertices > m_cVerticesMax)
    {
        hr = ResizeVertices(cVertices + m_cVertices);
        if (FAILED(hr))
            return hr;
    }

    if (cTriangles + m_cFaces > m_cFacesMax)
    {
        hr = ResizeFaces(cTriangles + m_cFaces);
        if (FAILED(hr))
            return hr;
    }

    *piFirstIndex = m_cVertices;

    // load the data into the vertex buffer
    for (iVertex = 0, iCurIndex = m_cVertices; iVertex < cVertices; iVertex++, iCurIndex++)
    {
        m_rgvVertices[iCurIndex].vPosition.x = rgvVertices[iVertex].x;
        m_rgvVertices[iCurIndex].vPosition.y = rgvVertices[iVertex].y;
        m_rgvVertices[iCurIndex].vPosition.z = m_fCurrentZ;

        m_rgvVertices[iCurIndex].vNormal = m_vCurrentNormal;
    }

    m_cVertices += cVertices;

    return S_OK;
}

// arrays used to remap based on triangle orientation
const UINT x_rgiCW[3]  = { 0, 1, 2 };
const UINT x_rgiCCW[3] = { 0, 2, 1 };

/*****************************************************************************
 * CFaceContext::AddStrip - Adds the given strip to the face and vertex array
 *
*****************************************************************************/
HRESULT 
CFaceContext::AddStrip
(
    D3DXVECTOR2 *rgvVertices, 
    UINT cVertices,
    BOOL bCCW
)
{
    HRESULT hr;
    UINT cTriangles = cVertices - 2;
    UINT iFirstIndex;
    UINT iCurIndex;
    UINT iTriangle;
    SFCFace16 face;
    const UINT *rgiIndex = bCCW ? x_rgiCCW : x_rgiCW;

    hr = SetupPrim(rgvVertices, cVertices, cTriangles, &iFirstIndex);
    if (FAILED(hr))
        return hr;

    for (iTriangle = 0, iCurIndex = iFirstIndex; iTriangle < cTriangles; iTriangle++, iCurIndex++)
    {
        // if even
        if ((iTriangle & 0x1) == 1)
        {
            face.rgwIndices[rgiIndex[0]] = static_cast<WORD>(iCurIndex + 1);
            face.rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 2);
            face.rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex);
        }
        else // if odd
        {
            face.rgwIndices[rgiIndex[0]] = static_cast<WORD>(iCurIndex);
            face.rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 2);
            face.rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex + 1);
        }

        AddFace(&face);
    }

    return S_OK;
}

/*****************************************************************************
 * CFaceContext::AddTriangle - Adds the triangle list to the face and vertex array
 *
*****************************************************************************/
HRESULT 
CFaceContext::AddTriangle
(
    D3DXVECTOR2 *rgvVertices, 
    UINT cVertices,
    BOOL bCCW
)
{
    HRESULT hr;
    UINT cTriangles = cVertices / 3;
    UINT iFirstIndex;
    UINT iCurIndex;
    UINT iTriangle;
    SFCFace16 face;
    const UINT *rgiIndex = bCCW ? x_rgiCCW : x_rgiCW;

    hr = SetupPrim(rgvVertices, cVertices, cTriangles, &iFirstIndex);
    if (FAILED(hr))
        return hr;

    for (iTriangle = 0, iCurIndex = iFirstIndex; iTriangle < cTriangles; iTriangle++, iCurIndex += 3)
    {
        face.rgwIndices[rgiIndex[0]] = static_cast<WORD>(iCurIndex);
        face.rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 2);
        face.rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex + 1);

        AddFace(&face);
    }

    return S_OK;
}

/*****************************************************************************
 * CFaceContext::AddFan - Adds the given fan to the face and vertex array
 *
*****************************************************************************/
HRESULT 
CFaceContext::AddFan
(
    D3DXVECTOR2 *rgvVertices, 
    UINT cVertices,
    BOOL bCCW
)
{
    HRESULT hr;
    UINT cTriangles = cVertices - 2;
    UINT iFirstIndex;
    UINT iCurIndex;
    UINT iTriangle;
    SFCFace16 face;
    const UINT *rgiIndex = bCCW ? x_rgiCCW : x_rgiCW;

    hr = SetupPrim(rgvVertices, cVertices, cTriangles, &iFirstIndex);
    if (FAILED(hr))
        return hr;

    for (iTriangle = 0, iCurIndex = iFirstIndex + 1; iTriangle < cTriangles; iTriangle++, iCurIndex++)
    {
        face.rgwIndices[rgiIndex[0]] = static_cast<WORD>(iFirstIndex);
        face.rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 1);
        face.rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex);

        AddFace(&face);
    }

    return S_OK;
}

/*****************************************************************************
 * CFaceContext::AddQuad - Adds the given quad to the face and vertex array
 *
*****************************************************************************/
HRESULT 
CFaceContext::AddQuad
(
    D3DXVECTOR3 *rgvVertices, 
    D3DXVECTOR3 *rgvNorm,
    BOOL bCCW
)
{
    HRESULT hr;
    UINT iFirstIndex = m_cVertices;
    UINT iCurIndex;
    UINT iVertex;
    const UINT *rgiIndex = bCCW ? x_rgiCCW : x_rgiCW;

    if (4 + m_cVertices > m_cVerticesMax)
    {
        hr = ResizeVertices(4 + m_cVertices);
        if (FAILED(hr))
            return hr;
    }

    if (2 + m_cFaces > m_cFacesMax)
    {
        hr = ResizeFaces(2 + m_cFaces);
        if (FAILED(hr))
            return hr;
    }

    // load the data into the vertex buffer
    for (iVertex = 0, iCurIndex = m_cVertices; iVertex < 4; iVertex++, iCurIndex++)
    {
        m_rgvVertices[iCurIndex].vPosition = rgvVertices[iVertex];
        m_rgvVertices[iCurIndex].vNormal = rgvNorm[iVertex];
    }

    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[0]] = static_cast<WORD>(m_cVertices);
    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[1]] = static_cast<WORD>(m_cVertices + 2);
    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[2]] = static_cast<WORD>(m_cVertices + 1);
    m_cFaces++;

    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[0]] = static_cast<WORD>(m_cVertices);
    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[1]] = static_cast<WORD>(m_cVertices + 3);
    m_rgFaces[m_cFaces].rgwIndices[rgiIndex[2]] = static_cast<WORD>(m_cVertices + 2);
    m_cFaces++;

    m_cVertices += 4;

    return S_OK;
}

/*****************************************************************************
 * CFaceContext::AddStrip - Adds the given quad strip to the face and vertex array
 *
*****************************************************************************/
HRESULT 
CFaceContext::AddQuadStrip
(
    D3DXVECTOR3 *rgvVertices, 
    D3DXVECTOR3 *rgvNorm,
    UINT cVertices,
    BOOL bCCW
)
{
    HRESULT hr;
    UINT iFirstIndex = m_cVertices;
    UINT iCurIndex;
    UINT iVertex;
    UINT cTriangles = cVertices - 2;
    UINT cQuads = cTriangles / 2;
    UINT iQuad;
    const UINT *rgiIndex = bCCW ? x_rgiCCW : x_rgiCW;

    if (cVertices + m_cVertices > m_cVerticesMax)
    {
        hr = ResizeVertices(cVertices + m_cVertices);
        if (FAILED(hr))
            return hr;
    }

    if (cTriangles + m_cFaces > m_cFacesMax)
    {
        hr = ResizeFaces(cTriangles + m_cFaces);
        if (FAILED(hr))
            return hr;
    }

    // load the data into the vertex buffer
    for (iVertex = 0, iCurIndex = m_cVertices; iVertex < cVertices; iVertex++, iCurIndex++)
    {
        m_rgvVertices[iCurIndex].vPosition = rgvVertices[iVertex];
        m_rgvVertices[iCurIndex].vNormal = rgvNorm[iVertex];
    }

    for (iQuad = 0, iCurIndex = m_cVertices; iQuad < cQuads; iQuad++, iCurIndex += 2)
    {
        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[0]] = static_cast<WORD>(iCurIndex);
        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 3);
        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex + 1);
        m_cFaces++;

        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[0]] = static_cast<WORD>(iCurIndex);
        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[1]] = static_cast<WORD>(iCurIndex + 2);
        m_rgFaces[m_cFaces].rgwIndices[rgiIndex[2]] = static_cast<WORD>(iCurIndex + 3);
        m_cFaces++;
    }

    m_cVertices += cVertices;
    return S_OK;
}

/*****************************************************************************
 * CFaceContext::Translate - Translates the vertices by the provided vector
 *
*****************************************************************************/
HRESULT 
CFaceContext::Translate
(
    D3DXVECTOR3 *pvTrans
)
{
    UINT iVertex;

    // just add the vector to all positions
    for (iVertex = 0; iVertex < m_cVertices; iVertex++)
    {
        m_rgvVertices[iVertex].vPosition += *pvTrans;
    }

    return S_OK;
}

/*****************************************************************************
 * CFaceContext::CopyMesh - Copy the face and vertex data into the provided buffers
 *
*****************************************************************************/
HRESULT 
CFaceContext::CopyMesh
(
    SFCFace16 *rgFaces, 
    SFCVertex *rgvVertices
)
{
    memcpy(rgFaces, m_rgFaces, sizeof(SFCFace16) * m_cFaces);
    memcpy(rgvVertices, m_rgvVertices, sizeof(SFCVertex) * m_cVertices);

    return S_OK;
}
/*****************************************************************************
 * GenerateMesh - Generates a mesh that is the concatenation of all the
 *                  face contexts provided
 *
*****************************************************************************/
HRESULT 
GenerateMesh
(
    CFaceContext **rgpfcLetters,
    UINT cLetters,
    CGlyphObject* pGlyphObject
)
{
    HRESULT hr = S_OK;
/*
    LPD3DXMESH ptmMesh = NULL;
    UINT cFaces = 0;
    UINT cVertices = 0;
    LPDIRECT3DVERTEXBUFFER8 pVertexBuffer = NULL;
    SFCVertex *pvVertices = NULL;
    SFCVertex *pvVerticesCur;
    SFCFace16 *rgFaces = NULL;
    SFCFace16 *rgFacesCur;
    UINT iCurVertOffset;
    UINT cFacesCur;
    UINT cVerticesCur;
    UINT iFace;
*/
    UINT iLetter;

    D3DXASSERT(rgpfcLetters != NULL);
    D3DXASSERT(cLetters != 0);
/*
    D3DXASSERT(pDevice != NULL);
    D3DXASSERT(pptmMesh != NULL);

    // first find the face/vertex totals
    for (iLetter = 0; iLetter < cLetters; iLetter++)
    {
        D3DXASSERT(rgpfcLetters[iLetter] != NULL);

        cFaces += rgpfcLetters[iLetter]->CFaces();
        cVertices += rgpfcLetters[iLetter]->CVertices();
    }

    // next create the mesh and get the vertex buffer to copy into
    hr = D3DXCreateMeshFVF(cFaces, cVertices, D3DXMESH_MANAGED, D3DFVF_XYZ | D3DFVF_NORMAL, pDevice, &ptmMesh);
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMesh->GetVertexBuffer(&pVertexBuffer);
    if (FAILED(hr))
        goto e_Exit;

    hr = pVertexBuffer->Lock(0,0, (PBYTE*)&pvVertices, D3DLOCK_NOSYSLOCK );
    if (FAILED(hr))
        goto e_Exit;

    hr = ptmMesh->LockIndexBuffer(0, (PBYTE*)&rgFaces);
    if (FAILED(hr))
        goto e_Exit;
*/

    // now actually get the data from the face contexts into the mesh
/*
    rgFacesCur = rgFaces;
    pvVerticesCur = pvVertices;
    iCurVertOffset = 0;
*/
    for (iLetter = 0; iLetter < cLetters; iLetter++)
    {
		PRINT("DEF ch_%04x IndexedFaceSet\n{\n", rgpfcLetters[iLetter]->m_wch);

		PRINT("\tcoord Coordinate\n\t{\n\t\tpoint\n\t\t[\n");
		for (UINT i = 0; i < rgpfcLetters[iLetter]->m_cVertices; i += 1)
		{
			PRINT("\t\t\t%f %f %f,\n", rgpfcLetters[iLetter]->m_rgvVertices[i].vPosition.x, rgpfcLetters[iLetter]->m_rgvVertices[i].vPosition.y, rgpfcLetters[iLetter]->m_rgvVertices[i].vPosition.z);
		}
		PRINT("\t\t]\n\t}\n");

		PRINT("\tnormal Normal\n\t{\n\t\tvector\n\t\t[\n");
		for (i = 0; i < rgpfcLetters[iLetter]->m_cVertices; i += 1)
		{
			PRINT("\t\t\t%f %f %f,\n", rgpfcLetters[iLetter]->m_rgvVertices[i].vNormal.x, rgpfcLetters[iLetter]->m_rgvVertices[i].vNormal.y, rgpfcLetters[iLetter]->m_rgvVertices[i].vNormal.z);
		}
		PRINT("\t\t]\n\t}\n");

		PRINT("\tcoordIndex\n\t[\n");
		for (i = 0; i < rgpfcLetters[iLetter]->m_cFaces; i += 1)
		{
			PRINT("\t\t%d %d %d\n", 
				rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[0],
				rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[1],
				rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[2]
				);
		}
		PRINT("\t]\n");

/*
        cFacesCur = rgpfcLetters[iLetter]->CFaces();
        cVerticesCur = rgpfcLetters[iLetter]->CVertices();

        // first get the data out of the face context into the mesh
        hr = rgpfcLetters[iLetter]->CopyMesh(rgFacesCur, pvVerticesCur);
        if (FAILED(hr))
            goto e_Exit;

        // now fixup the faces to point at the current vertices
        for (iFace = 0; iFace < cFacesCur; iFace++)
        {
            rgFacesCur[iFace].rgwIndices[0] += static_cast<WORD>(iCurVertOffset);
            rgFacesCur[iFace].rgwIndices[1] += static_cast<WORD>(iCurVertOffset);
            rgFacesCur[iFace].rgwIndices[2] += static_cast<WORD>(iCurVertOffset);
        }

        rgFacesCur += cFacesCur;
        pvVerticesCur += cVerticesCur;
        iCurVertOffset += cVerticesCur;
*/
		PRINT("}\n\n");

		CGlyphShape* pGlyphShape = new CGlyphShape;
		pGlyphObject->m_pGlyphShape = pGlyphShape;

		pGlyphShape->m_nVertexCount = (WORD)rgpfcLetters[iLetter]->m_cVertices;
		pGlyphShape->m_vertices = new CGlyphVertex [pGlyphShape->m_nVertexCount];
		for (i = 0; i < pGlyphShape->m_nVertexCount; i += 1)
		{
			pGlyphShape->m_vertices[i].x = rgpfcLetters[iLetter]->m_rgvVertices[i].vPosition.x;
			pGlyphShape->m_vertices[i].y = rgpfcLetters[iLetter]->m_rgvVertices[i].vPosition.y;
		}

		pGlyphShape->m_nIndexCount = (WORD)rgpfcLetters[iLetter]->m_cFaces * 3;
		pGlyphShape->m_indices = new WORD [pGlyphShape->m_nIndexCount];
		for (i = 0; i < rgpfcLetters[iLetter]->m_cFaces; i += 1)
		{
			pGlyphShape->m_indices[i * 3] = rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[0];
			pGlyphShape->m_indices[i * 3 + 1] = rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[1];
			pGlyphShape->m_indices[i * 3 + 2] = rgpfcLetters[iLetter]->m_rgFaces[i].rgwIndices[2];
		}
    }

/*
    D3DXASSERT(iCurVertOffset == cVertices);
    D3DXASSERT(pvVerticesCur == pvVertices + cVertices);
    D3DXASSERT(rgFacesCur == rgFaces + cFaces);

    *pptmMesh = ptmMesh;
    ptmMesh->AddRef();

e_Exit:
    if (rgFaces != NULL)
    {
        ptmMesh->UnlockIndexBuffer();
    }

    RELEASE(ptmMesh);
    
    if (pvVertices != NULL)
    {
        pVertexBuffer->Unlock();
    }
    RELEASE(pVertexBuffer);
*/

    return hr;
}

} // namespace D3DX



/*****************************************************************************
 * wglUseFontOutlinesAW
 * 
 * Converts a subrange of the glyphs in a TrueType font to OpenGL display
 * lists.
 *
 * History:
 *  15-Dec-1994 -by- Marc Fortier [marcfo]
 * Wrote it.
*****************************************************************************/

HRESULT WINAPI MyCreateTextW
( 
    HDC   hDC,
    LPCWSTR wszText,
    FLOAT chordalDeviation,
    FLOAT extrusion,
    CGlyphObject* pGlyphOut
)
{
    HRESULT     hr = S_OK;
    DWORD       glyphIndex;
    UCHAR*      glyphBuf = NULL;
    DWORD       glyphBufSize = 0;
    DWORD       glyphSize, error;
    D3DX::OFContext*  ofc = NULL;
    GLYPHMETRICS    glyphMetrics;
    static MAT2 matrix =
    {
        {0, 1}, {0, 0},
        {0, 0}, {0, 1}
    };
    int format = WGL_FONT_POLYGONS; // UNDONE UNDONE should other formats be supported?
    D3DX::CFaceContext **rgpfcLetters = NULL;
    D3DXVECTOR3 vTrans(0.0f, 0.0f, 0.0f);

    UINT iIndex;
    UINT cchText = 0;
    

    if ((wszText == NULL) || (wszText[0] == L'\0'))
    {
        WARNING("D3DXUseFontOutlinesAW: No text specified\n");
        hr = E_INVALIDARG;
        goto e_Exit;
    }

    if( chordalDeviation < 0.0f ) {
        WARNING("D3DXUseFontOutlines: invalid deviation parameter\n");
        hr = E_INVALIDARG;
        goto e_Exit;
    }

    if( extrusion < 0.0f ) {
        WARNING("D3DXUseFontOutlines: invalid extrusion parameter\n");
        hr = E_INVALIDARG;
        goto e_Exit;
    }
    
    cchText = wcslen(wszText);
    D3DXASSERT(cchText > 0);

    rgpfcLetters = new D3DX::CFaceContext*[cchText];
    if (rgpfcLetters == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto e_Exit;
    }
    memset(rgpfcLetters, 0, sizeof(D3DX::CFaceContext*) * cchText);

    /*
     * Create font outline context
     */
    hr = D3DX::CreateOFContext(hDC, chordalDeviation, extrusion, format, &ofc);
    if (FAILED(hr)) 
    {
        WARNING("D3DXCreateOFContext failed\n");
        goto e_Exit;
    }

    /*
     * Process each glyph in the given range:
    */
    for (iIndex = 0; iIndex < cchText; iIndex++)
    {
        glyphIndex = wszText[iIndex];

        /*
         * Determine how much space is needed to store the glyph's
         * outlines.  If our glyph buffer isn't large enough,
         * resize it.
         */
        // UNDONE UNDONE - how to do unicode
        glyphSize = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE,
                                      &glyphMetrics, 0, NULL, &matrix );

        if( glyphSize == GDI_ERROR ) 
        {
            WARNING("D3DXGetGlyphOutline() failed\n");
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        if (glyphSize > glyphBufSize)
        {
            if (glyphBuf != NULL)
                FREE(glyphBuf);

            glyphBufSize = glyphSize;
            glyphBuf = (UCHAR*) ALLOC(glyphSize);
            if (glyphBuf == NULL) 
            {
                WARNING("D3DX: Alloc of glyphBuf failed\n");
                hr = E_OUTOFMEMORY;
                goto e_Exit;
            }
        }


        /*
         * Get the glyph's outlines.
         */
        // UNDONE UNDONE - how to do unicode
        error = GetGlyphOutlineW( hDC, glyphIndex, GGO_NATIVE, 
                    &glyphMetrics, glyphBufSize, glyphBuf, &matrix );

        if( error == GDI_ERROR ) 
        {
            WARNING("D3DX: GetGlyphOutline() failed\n");
            hr = E_FAIL;
            goto e_Exit;
        }

        /*
         * Turn the glyph into a display list:
         */
        ofc->glyphBuf = glyphBuf;
        ofc->glyphSize = glyphSize;

        hr = D3DX::MakeDisplayListFromGlyph(ofc);
        if (FAILED(hr))
        {
            WARNING("D3DXMakeDisplayListFromGlyph() failed\n");
            goto e_Exit;
        }

        // translate the mesh to the correct position, will be 
        //  combined with other characters in the string later
        ofc->ec->pfc->Translate(&vTrans);

        // save off the face context, so that we can generate as many
        //   letters as needed, then generate the final mesh in one go
        rgpfcLetters[iIndex] = ofc->ec->pfc;
		rgpfcLetters[iIndex]->m_wch = (WCHAR)glyphIndex;

        ofc->ec->pfc = new D3DX::CFaceContext();
        if (ofc->ec->pfc == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto e_Exit;
        }

        // update the translation for the next string
        vTrans.x += ofc->scale * (FLOAT) glyphMetrics.gmCellIncX;
        vTrans.y += ofc->scale * (FLOAT) glyphMetrics.gmCellIncY;

        /*
         * Supply scaled glyphMetrics if requested
         */
//        if( pGlyphOut ) 
//        {
            pGlyphOut->m_metrics.gmfBlackBoxX         = ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxX;
            pGlyphOut->m_metrics.gmfBlackBoxY         = ofc->scale * (FLOAT) glyphMetrics.gmBlackBoxY;
            pGlyphOut->m_metrics.gmfptGlyphOrigin.x   = ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.x;
            pGlyphOut->m_metrics.gmfptGlyphOrigin.y   = ofc->scale * (FLOAT) glyphMetrics.gmptGlyphOrigin.y;
            pGlyphOut->m_metrics.gmfCellIncX          = ofc->scale * (FLOAT) glyphMetrics.gmCellIncX;
            pGlyphOut->m_metrics.gmfCellIncY          = ofc->scale * (FLOAT) glyphMetrics.gmCellIncY;

//            pGlyphOut++;
//        }
    }

    // now actually generate the mesh from each of the letters face contexts
    hr = D3DX::GenerateMesh(rgpfcLetters, cchText, pGlyphOut);
    if (FAILED(hr))
        goto e_Exit;

    /*
     * Clean up temporary storage and return.  If an error occurred,
     * set error flags and return FAILURE status;
     * otherwise just return SUCCESS.
     */

e_Exit:
    if (glyphBuf != NULL)
        FREE(glyphBuf);

    if (ofc != NULL)
        D3DX::DestroyOFContext( hDC, ofc);

    if (rgpfcLetters != NULL)
    {
        for (iIndex = 0; iIndex < cchText; iIndex++)
        {
            delete rgpfcLetters[iIndex];
        }
    }

    delete []rgpfcLetters;


    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\Resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by xtf.rc
//
#define IDS_HELLO                       1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\Glyph.h ===
#pragma once

struct CGlyphVertex
{
	float x, y;
};

struct CGlyphShape
{
	WORD m_nIndexCount;
	WORD m_nVertexCount;
	WORD* m_indices;
	CGlyphVertex* m_vertices;
};

struct CGlyphObject
{
	GLYPHMETRICSFLOAT m_metrics;
	CGlyphShape* m_pGlyphShape; // or DWORD m_dwFileOffsetOfGlyphShape
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\fontextr.cpp ===
#include "stdafx.h"

#define D3DXASSERT ASSERT

namespace D3DX
{
#include <GL\glu.h> // doesn't link against GL, but needs the headers
#include "fontoutl.h"

// Extrusion types
#define EXTR_LINES    0
#define EXTR_POLYGONS 1

// Prim to prim transitions
#define EXTR_LINE_LINE      0
#define EXTR_LINE_CURVE     1
#define EXTR_CURVE_LINE     2
#define EXTR_CURVE_CURVE    3

static const double   CurveCurveCutoffAngle = PI/2.0;
static const double   LineCurveCutoffAngle = PI/4.0;

static BOOL   InitFaceBuf(      EXTRContext *ec );


static BOOL   DrawSidePolygons( EXTRContext *ec, 
                                LOOP_LIST   *pLoopList );

static void   DrawPrims(        EXTRContext *ec, 
                                LOOP        *pLoop,
                                BOOL        fCCW);

static void   DrawQuads(        EXTRContext *ec, 
                                PRIM        *pPrim,
                                BOOL        fCCW);

static void   DrawQuadStrip(    EXTRContext *ec, 
                                PRIM        *pPrim,
                                BOOL        fCCW);

static BOOL   AppendToFaceBuf(  EXTRContext *ec, 
                                FLOAT       value );

static BOOL   ReallocFaceBuf(   EXTRContext *ec );


static BOOL   CalculateFaceNormals(   LOOP        *pLoop, 
                                      GLenum      orientation );

static BOOL   CalculateVertexNormals( LOOP        *pLoop );

static void   ConsolidatePrims(       LOOP        *pLoop );

static double PrimNormAngle(          PRIM        *pPrimA, 
                                      PRIM        *pPrimB );

static int    PrimTransition(         PRIM        *pPrevPrim, 
                                      PRIM        *pPrim );

static GLenum LoopOrientation(        LOOP_LIST   *pLoopList );

static LOOP*  GetMaxExtentLoop(       LOOP_LIST   *pLoopList );

double        CalcAngle(              POINT2D     *v1, 
                                      POINT2D     *v2 );

static void   CalcNormal2d(           POINT2D     *p, 
                                      POINT2D     *n,
                                      GLenum      orientation );

static void   Normalize2d(            POINT2D     *n );

static void   AddVectors3d(           POINT3D     *v1, 
                                      POINT3D     *v2, 
                                      POINT3D     *n );

static void   FreeLoopMem(            LOOP        *pLoop );

static void   DrawFacePolygons( EXTRContext *ec, FLOAT z );


/*****************************************************************************
 * exported functions
*****************************************************************************/

/*****************************************************************************
 * extr_Init
 *
 * Initialises extrusion for a wglUseFontOutline call

*****************************************************************************/

EXTRContext *
extr_Init( FLOAT extrusion, INT format )
{
    EXTRContext *ec;

    ec = (EXTRContext *) ALLOCZ(sizeof(EXTRContext) );

    if( !ec )
        return NULL;

    ec->zExtrusion = -extrusion;

    switch( format ) {
        case WGL_FONT_LINES :
            ec->extrType = EXTR_LINES;
#ifdef FONT_DEBUG
            ec->bSidePolys = FALSE;
            ec->bFacePolys = FALSE;
#endif
            break;
        case WGL_FONT_POLYGONS :
            ec->extrType = EXTR_POLYGONS;
#ifdef FONT_DEBUG
            ec->bSidePolys = TRUE;
            ec->bFacePolys = TRUE;
#endif
            break;
        default:
            ASSERTOPENGL( FALSE, "extr_Init(): invalid format\n" );
    }

    ec->pfc = new CFaceContext();
    if (ec->pfc == NULL)
    {
        FREE(ec);
        return NULL;
        //hr = E_OUTOFMEMORY;
        //goto e_Exit;
    }

    return ec;
}

/*****************************************************************************
 * extr_Finish
 *
 * Finishes extrusion for a wglUseFontOutline call

*****************************************************************************/

void
extr_Finish( EXTRContext *ec )
{
    delete ec->pfc;

    FREE( ec );
}

/*****************************************************************************
 * extr_PolyInit
 *
 * Initializes the extrusion of a single glyph.
 * If the extrusion is polygonal, it sets up FaceBuf, which holds a buffer
 * of primitives for drawing the faces of the extruded glyphs.
 *
*****************************************************************************/

BOOL extr_PolyInit( EXTRContext *ec )
{
    HRESULT hr = S_OK;

    if( ec->extrType == EXTR_LINES )
        return WFO_SUCCESS;

    ec->FaceBuf = (FLOAT *) NULL;
    if( !InitFaceBuf( ec ) ||
        !AppendToFaceBuf( ec, 0.0f) ) // primitive count at FaceBuf[0]
        return WFO_FAILURE;

    hr = ec->pfc->Init();
    if (FAILED(hr))
        return WFO_FAILURE;

    // initialize error flag
    ec->hrTessErrorOccurred = S_OK;

    return WFO_SUCCESS;
}

/*****************************************************************************
 * extr_PolyFinish
 *
 * Cleans up stuff from processing a single glyph

*****************************************************************************/

void extr_PolyFinish(  EXTRContext *ec )
{
    if( ec->extrType == EXTR_LINES )
        return;

    if( ec->FaceBuf ) {
        FREE( ec->FaceBuf );
        ec->FaceBuf = (FLOAT *) NULL;
    }
}

/*****************************************************************************
 * extr_DrawLines
 *
 * Draws the lines in a glyph loop for Line extrusion

*****************************************************************************/

void extr_DrawLines( EXTRContext *ec, LOOP_LIST *pLoopList )
{
#if 0
    DWORD   nLoops, nVerts;
    POINT2D *p;
    LOOP    *pLoop;

    nLoops = pLoopList->nLoops;
    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Draw the back face loop

#ifdef FONT_DEBUG
        DrawColorCodedLineLoop( pLoop, ec->zExtrusion );
#else
        glBegin(GL_LINE_LOOP);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for ( ; nVerts; nVerts--, p++ ) {
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
#endif

        // Draw the lines along the sides

#ifdef FONT_DEBUG
        glColor3d( 0.0, 0.0, 1.0 );
#endif

        glBegin(GL_LINES);

            nVerts = pLoop->nVerts - 1; // skip last point
            p = pLoop->VertBuf;
            for( ; nVerts; nVerts--, p++ ) {
                glVertex2fv( (GLfloat *) p);
                glVertex3f( p->x, p->y, ec->zExtrusion );
            }

        glEnd();
    }
#endif
}

/*****************************************************************************
 * extr_glBegin
 *
 * Tesselation callback for glBegin.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glBegin( GLenum primType, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // buffer face data
    ec->FaceBuf[0] += 1.0f; // increment prim counter
    ec->FaceVertexCountIndex = ec->FaceBufIndex+1; // mark vertex count index

    if( !AppendToFaceBuf( ec, (FLOAT) primType ) ||  // enter prim type
        !AppendToFaceBuf( ec, 0.0f ) )               // vertex count
        ec->hrTessErrorOccurred = E_OUTOFMEMORY;
}

/*****************************************************************************
 * extr_glEnd
 *
 * Tesselation callback for glEnd.
 * Noop, since we are just tracking the tesselation at this point.
 *
*****************************************************************************/

void CALLBACK
extr_glEnd( void )
{
}

/*****************************************************************************
 * extr_glVertex
 *
 * Tesselation callback for glVertex.
 * Buffers data into FaceBuf
 *
*****************************************************************************/

void CALLBACK
extr_glVertex( GLfloat *v, void *data )
{
    EXTRContext *ec = ((OFContext *)data)->ec;

    // put vertex in face buffer
    if( !AppendToFaceBuf( ec, v[0]) || !AppendToFaceBuf( ec, v[1]) )
        ec->hrTessErrorOccurred = E_OUTOFMEMORY;

    // increment vertex counter
    ec->FaceBuf[ec->FaceVertexCountIndex] += 1.0f;
}


/*****************************************************************************
 * extr_DrawPolygons
 *
 * Draws the side and face polygons of a glyph for polygonal extrusion
 * Gets polygon information from LineBuf, which was created during
 * MakeLinesFromGlyph().

*****************************************************************************/

BOOL
extr_DrawPolygons( EXTRContext *ec, LOOP_LIST *pLoopList ) 
{
#ifdef FONT_DEBUG
    if( ec->bSidePolys )
        if( !DrawSidePolygons( ec, pLoopList ) ) {
            return WFO_FAILURE;
        }

    if( ec->bFacePolys ) {
        DrawFacePolygons( ec, 0.0f );              // front face
        DrawFacePolygons( ec, ec->zExtrusion );    // back face
    }
#else

#ifdef _EXTRUDE
    if( !DrawSidePolygons( ec, pLoopList ) )
        return WFO_FAILURE;
#endif
    DrawFacePolygons( ec, 0.0f );              // front face
#ifdef _EXTRUDE
    DrawFacePolygons( ec, ec->zExtrusion );    // back face
#endif

#endif

    return WFO_SUCCESS;
}


/*****************************************************************************
 * internal functions
*****************************************************************************/


/*****************************************************************************
 * DrawSidePolygons
 *
 * Draw the side prims, using several passes on each prim loop:
 *  1) Calculate face normals for all the prims
 *  2) Consolidate prims if possible
 *  3) Calculate vertex normals for curve prims
 *  4) Draw the prims
 * Side effects: sets glFrontFace 

*****************************************************************************/

static BOOL
DrawSidePolygons( EXTRContext *ec,
                  LOOP_LIST   *pLoopList )
{
    DWORD nLoops;
    LOOP *pLoop;
    GLenum orientation;
    BOOL bCCW;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return WFO_SUCCESS;

    /* 
     * Determine orientation of loop
     */
    orientation = LoopOrientation( pLoopList );
    bCCW = orientation == GL_CCW;

    //glFrontFace( orientation );

    pLoop = pLoopList->LoopBuf;
    for( ; nLoops; nLoops--, pLoop++ ) {

        // Calculate face normals
        if( !CalculateFaceNormals( pLoop, orientation ) )
            return WFO_FAILURE;

        // Consolidate list of prims
        ConsolidatePrims( pLoop );

        // Calculate vertex normals
        if( !CalculateVertexNormals( pLoop ) ) {
            FreeLoopMem( pLoop ); // free mem alloc'd by CalculateFaceNormals
            return WFO_FAILURE;
        }
    
        DrawPrims( ec, pLoop, bCCW );

        // Free memory allocated during loop processing
        FreeLoopMem( pLoop );
    }

    return WFO_SUCCESS;
}

/*****************************************************************************
 * FreeLoopMem
 *
 * Frees up memory associated with each prim loop

*****************************************************************************/

static void 
FreeLoopMem( LOOP *pLoop )
{
    //PRIM *pPrim;

    if( !pLoop )
        return;

    if( pLoop->FNormBuf )
        FREE( pLoop->FNormBuf );
    if( pLoop->VNormBuf )
        FREE( pLoop->VNormBuf );
}

/*****************************************************************************
 * DrawPrims
 *
 * Draws a loop of Prims

*****************************************************************************/

static void 
DrawPrims( EXTRContext *ec, LOOP *pLoop, BOOL bCCW )
{
    PRIM  *pPrim;
    DWORD nPrims;

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;

    for( ; nPrims; nPrims--, pPrim++ ) {

        switch( pPrim->primType ) {
            case PRIM_LINE:
                DrawQuads( ec, pPrim, bCCW ); 
                break;

            case PRIM_CURVE:
                DrawQuadStrip( ec, pPrim, bCCW ); 
                break;
        }
    }
}


//#define EXTRANORMAL 1

/*****************************************************************************
 * DrawQuads
 *
 * Draws independent quads of a PRIM.

*****************************************************************************/

static void
DrawQuads( EXTRContext *ec, PRIM *pPrim, BOOL bCCW )
{
    POINT2D *p;
    POINT3D *pNorm;
    ULONG quadCount;
    D3DXVECTOR3 rgvPos[4];
    D3DXVECTOR3 rgvNorm[4];

    quadCount = pPrim->nVerts - 1;

    //glBegin( GL_QUADS );

        p = pPrim->pVert;
        pNorm = pPrim->pFNorm;

        while( quadCount-- ) {
            Normalize2d( (POINT2D *) pNorm );     // normalize
            //glNormal3fv( (GLfloat *) pNorm );

            // should come up with better normals...
            rgvNorm[0] = rgvNorm[1] = rgvNorm[2] = rgvNorm[3] = *(D3DXVECTOR3*)pNorm;

            rgvPos[0] = D3DXVECTOR3( p->x, p->y, 0.0f );
            rgvPos[1] = D3DXVECTOR3( p->x, p->y, ec->zExtrusion );
            p++;

            rgvPos[2] = D3DXVECTOR3( p->x, p->y, ec->zExtrusion );
            rgvPos[3] = D3DXVECTOR3( p->x, p->y, 0.0f );
            pNorm++;

            ec->pfc->AddQuad(rgvPos, rgvNorm, bCCW);
        }

    //glEnd();
}

/*****************************************************************************
 * DrawQuadStrip
 *
 * Draws a quadstrip from a PRIM

*****************************************************************************/

static void
DrawQuadStrip( EXTRContext *ec, PRIM *pPrim, BOOL bCCW )
{
    POINT3D *pNorm;
    POINT2D *p;
    ULONG   nVerts;
    D3DXVECTOR3 *rgvPos = NULL;
    D3DXVECTOR3 *rgvNorm = NULL;
    UINT cVerts;
    UINT iPos;

    //glBegin( GL_QUAD_STRIP );

    // initialize pointers, setup
    nVerts = pPrim->nVerts;
    p = pPrim->pVert;
    pNorm = pPrim->pVNorm;

    cVerts = nVerts * 2;
    rgvPos = new D3DXVECTOR3[cVerts];
    rgvNorm = new D3DXVECTOR3[cVerts];
    if ((rgvPos == NULL) || (rgvNorm == NULL))
    {
        goto e_Exit;
    }

    iPos = 0;
    while( nVerts-- ) 
    {
        rgvNorm[iPos] = *(D3DXVECTOR3*)pNorm;
        rgvPos[iPos] = D3DXVECTOR3( p->x, p->y, 0.0f );
        iPos++;

#ifdef EXTRANORMAL
        glNormal3fv( (GLfloat *) pNorm );
#endif
        rgvNorm[iPos] = *(D3DXVECTOR3*)pNorm;
        rgvPos[iPos] = D3DXVECTOR3( p->x, p->y, ec->zExtrusion );
        iPos++;

        // reset pointers
        p++;  // next point
        pNorm++;  // next vertex normal
    }
    D3DXASSERT(iPos == cVerts);

    ec->pfc->AddQuadStrip(rgvPos, rgvNorm, cVerts, bCCW);

    //glEnd();

e_Exit:
    delete []rgvPos;
    delete []rgvNorm;
}



/*****************************************************************************
 * DrawFacePolygons
 *
 * Draws the front or back facing polygons of a glyph.
 * If z is 0.0, the front face of the glyph is drawn, otherwise the back
 * face is drawn.

*****************************************************************************/
static void 
DrawFacePolygons( EXTRContext *ec, FLOAT z )
{
    ULONG primCount, vertexCount;
    GLenum primType;
    FLOAT *FaceBuf = ec->FaceBuf;
    FLOAT *p;
    D3DXVECTOR3 vNormal;
    BOOL bCCW;

    if( z == 0.0f ) 
    {
        vNormal = D3DXVECTOR3(0.0f, 0.0f, 1.0f);
        bCCW = TRUE;
        //glFrontFace( GL_CCW );
    } 
    else 
    {
        vNormal = D3DXVECTOR3(0.0f, 0.0f, -1.0f);
        bCCW = FALSE;
        //glFrontFace( GL_CW );
    }

    ec->pfc->SetCurrentNormal(&vNormal);
    ec->pfc->SetCurrentZ(z);

    primCount = (ULONG) FaceBuf[0];
    p = &FaceBuf[1];

    while( primCount-- ) 
    {
    
        primType = (GLenum) *p++;
        vertexCount = (ULONG) *p++;

        switch (primType)
        {
            case GL_TRIANGLE_FAN:
                ec->pfc->AddFan((D3DXVECTOR2*)p, vertexCount, bCCW);
                break;

            case GL_TRIANGLE_STRIP:
                ec->pfc->AddStrip((D3DXVECTOR2*)p, vertexCount, bCCW);
                break;

            case GL_TRIANGLES:
                ec->pfc->AddTriangle((D3DXVECTOR2*)p, vertexCount, bCCW);
                break;

            default:
                D3DXASSERT(0);
                break;
        }

        p += vertexCount * 2;
    }
}

/*****************************************************************************
 * ConsolidatePrims
 *
 *  Consolidate a loop of prims.
 *  Go through list of prims, consolidating consecutive Curve and Line prims
 *  When 2 prims are consolidated into one, the first prim is set to
 *  null by setting it's nVerts=0.  The second prim get's the first's stuff.
 *  If joining occured, the array of prims is compacted at the end.
 *

*****************************************************************************/

static void
ConsolidatePrims( LOOP *pLoop )
{
    DWORD nPrims, nJoined = 0;
    BOOL bJoined; 
    PRIM *pPrim, *pPrevPrim;
    int trans;
    double angle;

    nPrims = pLoop->nPrims;
    if( nPrims < 2 )
        return;

    pPrim = pLoop->PrimBuf;
    pPrevPrim = pPrim++;

    nPrims--; // nPrim-1 comparisons
    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {

        bJoined = FALSE;
        trans = PrimTransition( pPrevPrim, pPrim );
        switch( trans ) {
            case EXTR_LINE_LINE:
                // always consolidate 2 lines
                bJoined = TRUE;
                break;

            case EXTR_LINE_CURVE:
                break;

            case EXTR_CURVE_LINE:
                break;

            case EXTR_CURVE_CURVE:
                /*
                 * Join the prims if angle_between_norms < cutoff_angle
                 */
                angle = PrimNormAngle( pPrevPrim, pPrim );
                if( angle < CurveCurveCutoffAngle ) {
                    bJoined = TRUE;
                }
                break;
        }
        if( bJoined ) {
            // nullify the prev prim - move all data to current prim
            pPrim->nVerts += (pPrevPrim->nVerts - 1);
            pPrim->pVert = pPrevPrim->pVert;
            pPrim->pFNorm = pPrevPrim->pFNorm;
            pPrevPrim->nVerts = 0;
            nJoined++;
        }
    }

    if( nJoined ) {
        // one or more prims eliminated - compact the list

        nPrims = pLoop->nPrims;
        pPrim = pLoop->PrimBuf;
        // set new nPrims value
        pLoop->nPrims = nPrims - nJoined;
        nJoined = 0;  // nJoined now used as counter
        for( ; nPrims; nPrims--, pPrim++ ) {
            if( pPrim->nVerts == 0 ) {
                nJoined++;
                continue;
            }
            *(pPrim-nJoined) = *pPrim;
        }
    }
}

/*****************************************************************************
 * PrimTransition
 *
 * Given two adjacent prims, returns a code based on prim-type transition.
 *
*****************************************************************************/

static int
PrimTransition( PRIM *pPrevPrim, PRIM *pPrim )
{
    int trans;

    if( pPrevPrim->primType == PRIM_LINE ) {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_LINE_LINE;
        else
            trans = EXTR_LINE_CURVE;
    } else {
        if( pPrim->primType == PRIM_LINE )
            trans = EXTR_CURVE_LINE;
        else
            trans = EXTR_CURVE_CURVE;
    }

    return trans;
}

/*****************************************************************************
 * LoopOrientation
 *
 * Check for glyphs that have incorrectly specified the contour direction (for
 * example, many of the Wingding glyphs).  We do this by first determining
 * the loop in the glyph that has the largest extent.  We then make the
 * assumption that this loop is external, and check it's orientation.  If
 * the orientation is CCW (non-default), we have to set the orientation to
 * GL_CCW in the extrusion context, so that normals will be generated
 * correctly.

* The method used here may fail for any loops that intersect themselves.
* This will happen if the loops created by the intersections are in the opposite
* direction to the main loop (if 1 such extra loop exists, then the sum of
* angles around the entire contour will be 0 - we put in a check for this,
* and always default to CW in this case)
*
* Note that this method *always* works for properly designed TruyType glyphs.
* From the TrueType font spec "The direction of the curves has to be such that,
* if the curve is followed in the direction of increasing point numbers, the
* black space (the filled area) will always be to the right."  So this means
* that the outer loop should always be CW.
* 
*****************************************************************************/

// These macros handle the rare case of a self-intersecting, polarity-reversing
// loop as explained above.  (Observed in animals1.ttf)  Note that will only
// catch some cases.
#define INTERSECTING_LOOP_WORKAROUND 1
#define NEAR_ZERO( fAngle ) \
    ( fabs(fAngle) < 0.00001 )

static GLenum
LoopOrientation( LOOP_LIST *pLoopList )
{
    DWORD  nLoops, nVerts;
    double angle = 0;
    POINT2D *p1, *p2, v1, v2;
    LOOP *pMaxLoop;

    nLoops = pLoopList->nLoops;
    if( !nLoops )
        return GL_CW; // default value

    // determine which loop has the maximum extent

    pMaxLoop = GetMaxExtentLoop( pLoopList );

    nVerts = pMaxLoop->nVerts;
    if( nVerts < 3 )
        return GL_CW;  // can't determine angle

    p1 = pMaxLoop->VertBuf + nVerts - 2;  // 2nd to last point
    p2 = pMaxLoop->VertBuf; // first point

    /* 
     * Accumulate relative angle between consecutive line segments along
     * the loop - this will tell us the loop's orientation.
     */
    v1.x = p2->x - p1->x;
    v1.y = p2->y - p1->y;
    nVerts--; // n-1 comparisons

    for( ; nVerts; nVerts-- ) {
        // calc next vector
        p1 = p2++;
        v2.x = p2->x - p1->x;
        v2.y = p2->y - p1->y;
        angle += CalcAngle( &v1, &v2 );
        v1 = v2;
    }

#ifdef INTERSECTING_LOOP_WORKAROUND
    if( NEAR_ZERO( angle ) ) {
        DBGPRINT( "D3DXUseFontOutlines:LoopOrientation : Total loop angle is zero, assuming CW orientation\n" );
        return GL_CW;
    }
#endif

    if( angle > 0.0 )
        return GL_CCW;
    else
        return GL_CW;
}


/*****************************************************************************
 * GetMaxExtentLoop
 *
 * Determine which of the loops in a glyph description has the maximum
 * extent, and return a ptr to it.  We check extents in the x direction.

*****************************************************************************/

LOOP *
GetMaxExtentLoop( LOOP_LIST *pLoopList )
{
    DWORD nLoops, nVerts;
    FLOAT curxExtent, xExtent=0.0f, x, xMin, xMax;
    LOOP  *pMaxLoop, *pLoop;
    POINT2D *p;

    pMaxLoop = pLoop = pLoopList->LoopBuf;

    nLoops = pLoopList->nLoops;
    if( nLoops == 1 )
        // just one loop - no comparison required
        return pMaxLoop;

    for( ; nLoops; nLoops--, pLoop++ ) {
        nVerts = pLoop->nVerts;
        p = pLoop->VertBuf;
        // use x value of first point as reference
        x = p->x;
        xMin = xMax = x;
        // compare x's of rest of points
        for( ; nVerts; nVerts--, p++ ) {
            x = p->x;
            if( x < xMin )
                xMin = x;
            else if( x > xMax )
                xMax = x;
        }
        curxExtent = xMax - xMin;
        if( curxExtent > xExtent ) {
            xExtent = curxExtent;
            pMaxLoop = pLoop;
        }
    }
    return pMaxLoop;
}

/*****************************************************************************
 * CalcAngle
 *
 * Determine the signed angle between 2 vectors.  The angle is measured CCW
 * from vector 1 to vector 2.

*****************************************************************************/

double
CalcAngle( POINT2D *v1, POINT2D *v2 )
{
    double angle1, angle2, angle;

    // Calculate absolute angle of each vector

    /* Check for (0,0) vectors - this shouldn't happen unless 2 consecutive
     * vertices in the VertBuf are equal.
     */
    if( (v1->y == 0.0f) && (v1->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle1 = __GL_ATAN2F( v1->y, v1->x ); // range: -PI to PI

    if( (v2->y == 0.0f) && (v2->x == 0.0f) )
        angle1 = 0.0f;
    else
        angle2 = __GL_ATAN2F( v2->y, v2->x ); // range: -PI to PI

    // Calculate relative angle between vectors
    angle = angle2 - angle1;        // range:  -2*PI to 2*PI

    // force angle to be in range -PI to PI
    if( angle < -PI  )
        angle += TWO_PI;
    else if( angle > PI )
        angle -= TWO_PI;

    return angle;
}

/*****************************************************************************
 * CalculateFaceNormals
 *
 * Calculate face normals for a prim loop.
 * The normals are NOT normalized.
 *
*****************************************************************************/

static BOOL
CalculateFaceNormals( LOOP      *pLoop, 
                      GLenum    orientation )
{
    DWORD nPrims;
    ULONG nQuads = 0;
    POINT2D *p;
    POINT3D *pNorm;
    PRIM *pPrim;

    // Need 1 normal per vertex
    pNorm = (POINT3D*) ALLOC(pLoop->nVerts*sizeof(POINT3D));
    pLoop->FNormBuf = pNorm;
    if( !pNorm )
        return WFO_FAILURE;

    // Calculate the face normals

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        pPrim->pFNorm = pNorm;   // ptr to each prims norms
        nQuads = pPrim->nVerts - 1;
        p = pPrim->pVert;
        for( ; nQuads; nQuads--, p++, pNorm++ ) {
            CalcNormal2d( p, (POINT2D *) pNorm, orientation );
            pNorm->z = 0.0f;    // normals in xy plane
        }
    }
    return WFO_SUCCESS;
}

/*****************************************************************************
 * CalculateVertexNormals
 *
 * Calculate vertex normals for a prim loop, only for those prims that
 * are of type 'CURVE'.
 * Uses previously calculated face normals to generate the vertex normals.
 * Allocates memory for the normals by calculating memory requirements on
 * the fly. 
 * The normals are normalized.
 * Handles closing of loops properly.
 * 
*****************************************************************************/

static BOOL
CalculateVertexNormals( LOOP *pLoop )
{
    ULONG nPrims, nVerts = 0;
    POINT3D *pVNorm, *pFNorm, *pDstNorm;
    PRIM    *pPrim, *pPrevPrim;
    double angle;
    GLenum trans;

    // How much memory we need for the normals?

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {
        if( pPrim->primType == PRIM_CURVE )
            nVerts += pPrim->nVerts;
    }

    if( !nVerts )
        return WFO_SUCCESS;

    // XXX: could just allocate 2*nVerts of mem for the normals
    pVNorm = (POINT3D*) ALLOC( nVerts*sizeof(POINT3D) );
    pLoop->VNormBuf = pVNorm;
    if( !pVNorm )
        return WFO_FAILURE;

    // First pass: calculate normals for all vertices of Curve prims

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    for( ; nPrims; nPrims--, pPrim++ ) {

        if( pPrim->primType == PRIM_LINE )
            continue;

        nVerts = pPrim->nVerts;
        pPrim->pVNorm = pVNorm;   // ptr to each prims norms
        pFNorm = pPrim->pFNorm;   // ptr to face norms already calculated

        // set the first vnorm to the fnorm
        *pVNorm = *pFNorm;

        Normalize2d( (POINT2D *) pVNorm );         // normalize it
        nVerts--;  // one less vertex to worry about
        pVNorm++;  // advance ptrs
        pFNorm++;

        nVerts--;  // do last vertex after this loop
        for( ; nVerts; nVerts--, pFNorm++, pVNorm++ ) {
            // use neighbouring face normals to get vertex normal
            AddVectors3d( pFNorm, pFNorm-1, pVNorm );
            Normalize2d( (POINT2D *) pVNorm );      // normalize it
        }

        // last vnorm is same as fnorm of *previous* vertex
        *pVNorm = *(pFNorm-1);
        Normalize2d( (POINT2D *) pVNorm );         // normalize it

        pVNorm++;  // next available space in vnorm buffer
    }

    // Second pass: calculate normals on prim boundaries

    nPrims = pLoop->nPrims;
    pPrim = pLoop->PrimBuf;
    // set pPrevPrim to last prim in loop
    pPrevPrim = pLoop->PrimBuf + pLoop->nPrims - 1;

    for( ; nPrims; nPrims--, pPrevPrim = pPrim++ ) {
        trans = PrimTransition( pPrevPrim, pPrim );
        angle = PrimNormAngle( pPrevPrim, pPrim );

        switch( trans ) {
            case EXTR_LINE_CURVE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's first vnorm to line's last fnorm
                    *(pPrim->pVNorm) = 
                                *(pPrevPrim->pFNorm + pPrevPrim->nVerts -2);
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                }
                break;

            case EXTR_CURVE_LINE:
                if( angle < LineCurveCutoffAngle ) {
                    // set curve's last vnorm to line's first fnorm
                    pDstNorm = pPrevPrim->pVNorm + pPrevPrim->nVerts - 1;
                    *pDstNorm = *(pPrim->pFNorm);
                    Normalize2d( (POINT2D *) pDstNorm );
                }
                break;

            case EXTR_CURVE_CURVE:
                if( angle < CurveCurveCutoffAngle ) {
                    // average normals of adjoining faces, and
                    // set last curve's first vnorm to averaged normal
                    AddVectors3d( pPrevPrim->pFNorm + pPrevPrim->nVerts - 2, 
                                  pPrim->pFNorm, 
                                  pPrim->pVNorm );
                    Normalize2d( (POINT2D *) pPrim->pVNorm );
                    // set first curve's last vnorm to averaged normal
                    *(pPrevPrim->pVNorm + pPrevPrim->nVerts - 1) =
                                                        *(pPrim->pVNorm); 
                }
                break;
            case EXTR_LINE_LINE:
                // nothing to do
                break;
        }

    }
    return WFO_SUCCESS;
}


/*****************************************************************************
 * PrimNormAngle
 *
 *  Determine angle between the last face's normal of primA, and the first
 *  face's normal of primB.
 *
 *  The result should be an angle between -PI and PI.
 *  For now, we only care about the relative angle, so we return the
 *  absolute value of the signed angle between the faces.
 *
*****************************************************************************/

static double
PrimNormAngle( PRIM *pPrimA, PRIM *pPrimB )
{
    double angle;
    // last face norm at index (nvert-2)
    POINT3D *normA = pPrimA->pFNorm + pPrimA->nVerts - 2;
    POINT3D *normB = pPrimB->pFNorm;

    angle = CalcAngle( (POINT2D *) normA, (POINT2D *) normB );

    return fabs(angle); // don't care about sign of angle for now
}


/*****************************************************************************
 * InitFaceBuf
 * 
 * Initializes FaceBuf and its associated size and current-element
 * counters.
 * 
*****************************************************************************/

static BOOL
InitFaceBuf( EXTRContext *ec )
{
    DWORD initSize = 1000;

    if( !(ec->FaceBuf = 
        (FLOAT*) ALLOC(initSize*sizeof(FLOAT))) )
        return WFO_FAILURE;
    ec->FaceBufSize = initSize;
    ec->FaceBufIndex = 0;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * AppendToFaceBuf
 *
 * Appends one floating-point value to the FaceBuf array.

*****************************************************************************/

static BOOL
AppendToFaceBuf(EXTRContext *ec, FLOAT value)
{
    if (ec->FaceBufIndex >= ec->FaceBufSize)
    {
       if( !ReallocFaceBuf( ec ) )
            return WFO_FAILURE;
    }
    ec->FaceBuf[ec->FaceBufIndex++] = value;
    return WFO_SUCCESS;
}

/*****************************************************************************
 * ReallocBuf
 *
 * Increases size of FaceBuf by a constant value.
 *
*****************************************************************************/

static BOOL
ReallocFaceBuf( EXTRContext *ec )
{
    FLOAT* f;
    DWORD increase = 1000; // in floats

    f = (FLOAT*) REALLOC(ec->FaceBuf, 
        (ec->FaceBufSize += increase)*sizeof(FLOAT));
    if (!f)
        return WFO_FAILURE;
    ec->FaceBuf = f;
    return WFO_SUCCESS;
}


/*****************************************************************************
 * CalcNormal2d
 *
 * Calculates the 2d normal of a 2d vector, by rotating the vector:
 * - CCW 90 degrees for CW contours.
 * - CW 90 degrees for CCW contours.
 * Does not normalize.
 *
*****************************************************************************/

static void
CalcNormal2d( POINT2D *p, POINT2D *n, GLenum orientation )
{
    static POINT2D v;

    v.x = (p+1)->x - p->x;
    v.y = (p+1)->y - p->y;
    if( orientation == GL_CW ) {
        n->x = -v.y;
        n->y = v.x;
    } else {
        n->x = v.y;
        n->y = -v.x;
    }
}


/*****************************************************************************
 * Normalize2d
 *
 * Normalizes a 2d vector
 *
*****************************************************************************/

static void
Normalize2d( POINT2D *n )
{
    float len;

    len = (n->x * n->x) + (n->y * n->y);
    if (len > ZERO_EPS)
        len = 1.0f / __GL_SQRTF(len);
    else
        len = 1.0f;

    n->x *= len;
    n->y *= len;
}

/*****************************************************************************
 * AddVectors3d
 *
 * Adds two 3d vectors.
 *
*****************************************************************************/

static void
AddVectors3d( POINT3D *v1, POINT3D *v2, POINT3D *n )
{
    n->x = v1->x + v2->x;
    n->y = v1->y + v2->y;
    n->z = v1->z + v2->z;
}


} // namespace D3DX
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	xtf.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xt\xt.cpp ===
#include <windows.h>
#include <d3dx8.h>
#include <xgraphics.h>
#include <stdio.h>
#include "Bundler.h"
#include "LoadImage.h"
#include "BaseTexture.h"

#ifdef _DEBUG
#pragma comment(lib, "../../../Public/wsdk/lib/i386/xgraphicsd.lib")
#else
#pragma comment(lib, "../../../Public/wsdk/lib/i386/xgraphics.lib")
#endif

#pragma comment(lib, "d3d8.lib")
#pragma comment(lib, "d3dx8.lib")

CBundler::CBundler()
{
	m_pd3d = NULL;
	m_pd3ddev = NULL;
	m_hFile = INVALID_HANDLE_VALUE;
}

bool CBundler::Init()
{
    HRESULT hr;
    D3DDISPLAYMODE dispMode;
    D3DPRESENT_PARAMETERS presentParams;

    m_pd3d = Direct3DCreate8(D3D_SDK_VERSION);
    if (m_pd3d == NULL)
    {
        ErrorMsg("Couldn't create Direct3d - is it installed?\n");
        return false;
    }

    m_pd3d->GetAdapterDisplayMode(D3DADAPTER_DEFAULT, &dispMode);

    ZeroMemory(&presentParams, sizeof(presentParams));
    presentParams.Windowed = TRUE;
    presentParams.SwapEffect = D3DSWAPEFFECT_COPY_VSYNC;
    presentParams.BackBufferWidth = 8;
    presentParams.BackBufferHeight = 8;
    presentParams.BackBufferFormat = dispMode.Format;

    hr = m_pd3d->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_REF, GetDesktopWindow(),
        D3DCREATE_SOFTWARE_VERTEXPROCESSING, &presentParams, &m_pd3ddev);
    if (FAILED(hr))
    {
        ErrorMsg("Couldn't create reference device\n");
        return false;
    }

    return true;
}

void CBundler::ErrorMsg( const char * szMsg, ... )
{
	va_list args;
	va_start(args, szMsg);

	char szBuffer [512];
	_vsnprintf(szBuffer, sizeof(szBuffer), szMsg, args);
	puts(szBuffer);

	va_end(args);
}

HRESULT CBundler::WriteData( void * pbBuff, DWORD cb )
{
	DWORD dwWrite;
	WriteFile(m_hFile, pbBuff, cb, &dwWrite, NULL);
	return S_OK;
}

HRESULT CBundler::PadToAlignment( DWORD dwAlign )
{
	return S_OK;
}


char* szInputFile = NULL;
char* szOutputFile = NULL;
char* szOutputFormat = NULL;
int nOutputWidth = 0;
int nOutputHeight = 0;
int nOutputLevels = 1;

void ProcessFile()
{
	CBundler bundler;
	if (!bundler.Init())
		exit(1);

	CBaseTexture texture(&bundler);
    LPDIRECT3DSURFACE8 pSurface;

	printf("Converting %s to %s...\n", szInputFile, szOutputFile);
	if (texture.LoadSurface(szInputFile, "", &pSurface))
	{
		fprintf(stderr, "Error loading %s\n", szInputFile);
		exit(2);
	}

	if (szOutputFormat == NULL)
		szOutputFormat = "D3DFMT_A8R8G8B8";

	int nFormat = texture.FormatFromString(szOutputFormat);
	if (nFormat < 0)
	{
		printf("Unknown format %s\n", szOutputFormat);
		exit(1);
	}

	texture.m_nFormat = nFormat;

	if (nOutputWidth == 0 || nOutputHeight == 0)
	{
		D3DSURFACE_DESC desc;
		pSurface->GetDesc(&desc);

		for (nOutputWidth = 1;  nOutputWidth  < (int)desc.Width; nOutputWidth <<= 1)
			;
		for (nOutputHeight = 1; nOutputHeight < (int)desc.Height; nOutputHeight <<= 1)
			;

		printf("\t%dx%d pixels\n", nOutputWidth, nOutputHeight);
	}

	if (FAILED(texture.ResizeSurface(nOutputWidth, nOutputHeight, &pSurface)))
	{
		fprintf(stderr, "Failed to resize!\n");
		exit(2);
	}

	bundler.m_hFile = CreateFile(szOutputFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
	if (bundler.m_hFile == INVALID_HANDLE_VALUE)
	{
		fprintf(stderr, "Cannot create %s\n", szOutputFile);
		exit(2);
	}

	D3DTexture d3dtex;
	XGSetTextureHeader(nOutputWidth, nOutputHeight, nOutputLevels, 0, (D3DFORMAT)g_TextureFormats[nFormat].dwXboxFormat, D3DPOOL_DEFAULT, (IDirect3DTexture8*)&d3dtex, 0, 0);
	bundler.WriteData(&d3dtex, sizeof(d3dtex));

	DWORD cbData = 0;
	texture.SaveSurface(&cbData, nOutputLevels, pSurface);

	CloseHandle(bundler.m_hFile);
}

void UsageExit()
{
	fprintf(stderr, "Usage:\n");
	fprintf(stderr, "\txt [options] input output\n");
	fprintf(stderr, "Options:\n");
	fprintf(stderr, "\t-f d3dformat\n");
	fprintf(stderr, "\t-w width\n");
	fprintf(stderr, "\t-h height\n");
	fprintf(stderr, "\t-m mipmap-levels\n");
	exit(1);
}

int __cdecl main(int argc, char* argv[])
{
	for (int i = 1; i < argc; i += 1)
	{
		char* sz = argv[i];

		if (sz[0] == '-' || sz[0] == '/')
		{
			switch (sz[1])
			{
			default:
				UsageExit();
				break;

			case 'f':
				if (sz[2] == 0)
				{
					i += 1;
					sz = argv[i];
				}
				else
				{
					sz += 2;
				}

				szOutputFormat = sz;
				break;

			case 'w':
				if (sz[2] == 0)
				{
					i += 1;
					sz = argv[i];
				}
				else
				{
					sz += 2;
				}

				nOutputWidth = atoi(sz);
				break;

			case 'h':
				if (sz[2] == 0)
				{
					i += 1;
					sz = argv[i];
				}
				else
				{
					sz += 2;
				}

				nOutputHeight = atoi(sz);
				break;

			case 'm':
				if (sz[2] == 0)
				{
					i += 1;
					sz = argv[i];
				}
				else
				{
					sz += 2;
				}

				nOutputLevels = atoi(sz);
				break;
			}
		}
		else
		{
			if (szInputFile == NULL)
				szInputFile = sz;
			else if (szOutputFile == NULL)
				szOutputFile = sz;
			else
				UsageExit();
		}
	}

	if (szInputFile == NULL || szOutputFile == NULL)
		UsageExit();

	ProcessFile();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A414C07E_635A_4C7E_880D_C31E6970BFB2__INCLUDED_)
#define AFX_STDAFX_H__A414C07E_635A_4C7E_880D_C31E6970BFB2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#define _WIN32_WINNT 0x0500

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

#include <d3dx8.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A414C07E_635A_4C7E_880D_C31E6970BFB2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\xtf.h ===
#if !defined(AFX_XTF_H__0FF719AB_CBE0_401E_B699_9FDAEEAA7B2B__INCLUDED_)
#define AFX_XTF_H__0FF719AB_CBE0_401E_B699_9FDAEEAA7B2B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"


#endif // !defined(AFX_XTF_H__0FF719AB_CBE0_401E_B699_9FDAEEAA7B2B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\makefile.inc ===
#
# Misc standard rules for VC project
#

!ifdef CMDFILE

.SUFFIXES: .cmd .rcs

!ifndef RCFILE
!error RCFILE must be defined
!endif

!ifndef CMDSRC
CMDSRC=$(CMDFILE)
!endif

$(RCFILE).rc : $O\$(CMDFILE).rcs

$O\$(CMDFILE).rcs: $(CMDSRC).cmd
	cl /EP $(C_DEFINES) $(CMDSRC).cmd > $O\$(CMDSRC).cmd
	cmdcomp $O\$(CMDSRC).cmd
!endif

.SUFFIXES: .bin .tpl

.tpl.bin:
    cmtempl $< $@

.tpl{$(O)}.bin:
    cmtempl $< $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emcpu.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ui\xtf\xtf.cpp ===
// xtf.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "xtf.h"
#include "Glyph.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#pragma comment(lib, "d3d8.lib")
#pragma comment(lib, "d3dx8.lib")

/////////////////////////////////////////////////////////////////////////////
// The one and only application object

CWinApp theApp;

using namespace std;

void Export(const TCHAR* szFilePath, const TCHAR* szFaceName, const TCHAR* szJFaceName, float nChordalDeviation);

void UsageExit()
{
	cerr << _T("Usage: XTF [/c <chordal deviation>] <output.xtf> <face name> [<japanese face name>]") << endl;
	exit(2);
}

int __cdecl _tmain(int argc, TCHAR* argv[], TCHAR* envp[])
{
	const TCHAR* szOutputFileName = NULL;
	const TCHAR* szFontFaceName = NULL;
	const TCHAR* szJFontFaceName = NULL;
	float nChordalDeviation = 0.001f;

	// initialize MFC and print and error on failure
	if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
	{
		cerr << _T("Fatal Error: MFC initialization failed") << endl;
		return 1;
	}
	
	if (argc < 3)
		UsageExit();

	for (int i = 1; i < argc; i += 1)
	{
		if (argv[i][0] == '/' || argv[i][0] == '-')
		{
			switch (argv[i][1])
			{
			default:
				UsageExit();
				break;

			case 'c':
			case 'C':
				{
					const TCHAR* szValue = argv[i] + 2;
					if (*szValue == 0)
					{
						i += 1;
						if (i >= argc)
							UsageExit();

						szValue = argv[i];
					}

					nChordalDeviation = (float)_tcstod(szValue, NULL);
					if (nChordalDeviation <= 0.0f)
					{
						cout << _T("Error: chordal deviation is too small!") << endl;
						return 1;
					}
				}
				break;
			}
		}
		else
		{
			if (szOutputFileName == NULL)
				szOutputFileName = argv[i];
			else if (szFontFaceName == NULL)
				szFontFaceName = argv[i];
			else if (szJFontFaceName == NULL)
				szJFontFaceName = argv[i];
			else
				UsageExit();
		}
	}

	if (szOutputFileName == NULL || szFontFaceName == NULL)
		UsageExit();

	cout << _T("Creating ") << szOutputFileName << _T(" from ") << szFontFaceName;
	if (szJFontFaceName != NULL)
		cout << _T(" and ") << szJFontFaceName << endl;

	Export(szOutputFileName, szFontFaceName, szJFontFaceName, nChordalDeviation);

	return 0;
}


extern CFile* g_pFile;
extern CStdioFile* g_pWrlFile;



extern HRESULT WINAPI MyCreateTextW
( 
    HDC   hDC,
    LPCWSTR wszText,
    FLOAT chordalDeviation,
    FLOAT extrusion,
    CGlyphObject* pGlyphObject
);

void Export(const TCHAR* szFilePath, const TCHAR* szFaceName, const TCHAR* szJFaceName, float nChordalDeviation)
{
	CFont font, fontJ;
	if (!font.CreatePointFont(100, szFaceName))
	{
		cout << _T("Error: Cannot load font: ") << szFaceName << endl;
		return;
	}

	if (szJFaceName != NULL && !fontJ.CreatePointFont(100, szJFaceName))
	{
		cout << _T("Error: Cannot load font: ") << szJFaceName << endl;
		return;
	}

	int cGlyphsSupportedJ = 0;
	int cRangesJ = 0;
	int nFirstJGlyphSet = -1;
	LPGLYPHSET pGlyphSetJ = NULL;

	if (szJFaceName != NULL)
	{
		// We need to adjust the GlyphSet to include the J characters as well...
		CClientDC dcJ(NULL);
		CFont* pOldFont = dcJ.SelectObject(&fontJ);
		
		DWORD dwGlyphSetSizeJ = GetFontUnicodeRanges(dcJ.m_hDC, NULL);
		pGlyphSetJ = (LPGLYPHSET)malloc(dwGlyphSetSizeJ);
		pGlyphSetJ->cbThis = dwGlyphSetSizeJ;
		GetFontUnicodeRanges(dcJ.m_hDC, pGlyphSetJ);

		for (int i = 0; i < pGlyphSetJ->cRanges; i += 1)
		{
			if (pGlyphSetJ->ranges[i].wcLow >= 0x3000)
			{
				if (nFirstJGlyphSet < 0)
					nFirstJGlyphSet = i;
				cGlyphsSupportedJ += pGlyphSetJ->ranges[i].cGlyphs;
				cRangesJ += 1;
			}
		}

		dcJ.SelectObject(pOldFont);
	}

	CClientDC dc(NULL);
	CFont* pOldFont = dc.SelectObject(&font);
	
	DWORD dwGlyphSetSize = GetFontUnicodeRanges(dc.m_hDC, NULL);
	dwGlyphSetSize += sizeof (WCRANGE) * cRangesJ;
	LPGLYPHSET pGlyphSet = (LPGLYPHSET)malloc(dwGlyphSetSize);
	pGlyphSet->cbThis = dwGlyphSetSize;
	GetFontUnicodeRanges(dc.m_hDC, pGlyphSet);
	pGlyphSet->cbThis = dwGlyphSetSize; // GetFontUnicodeRanges just trached this for us...

	if (nFirstJGlyphSet >= 0)
	{
		CopyMemory(&pGlyphSet->ranges[pGlyphSet->cRanges], &pGlyphSetJ->ranges[nFirstJGlyphSet], sizeof (WCRANGE) * cRangesJ);

		nFirstJGlyphSet = pGlyphSet->cRanges;
		pGlyphSet->cGlyphsSupported += cGlyphsSupportedJ;
		pGlyphSet->cRanges += cRangesJ;
	}

	CFile file(szFilePath, CFile::modeWrite | CFile::modeCreate);
	g_pFile = &file;


	file.Write("XTF0", 4); // magic number

	// BLOCK: Write face name
	{
		DWORD dwHeaderLen = LF_FACESIZE;
		file.Write(&dwHeaderLen, 4);

		char szFaceNameA [LF_FACESIZE];
		ZeroMemory(szFaceNameA, sizeof (szFaceNameA));

#ifdef _UNICODE
		WideCharToMultiByte(CP_ACP, 0, szFaceName, -1, szFaceNameA, LF_FACESIZE, NULL, NULL);
#else
		strncpy(szFaceNameA, szFaceName, LF_FACESIZE);
#endif

		file.Write(szFaceNameA, LF_FACESIZE);
	}

	file.Write(pGlyphSet, dwGlyphSetSize);

	CGlyphObject* rgGlyphObjects = new CGlyphObject [pGlyphSet->cGlyphsSupported];
	ZeroMemory(rgGlyphObjects, sizeof (CGlyphObject) * pGlyphSet->cGlyphsSupported);

	DWORD dwIndexPos = file.GetPosition();
	file.Seek(sizeof (CGlyphObject) * pGlyphSet->cGlyphsSupported, CFile::current);

	WCHAR wsz [2];
	wsz[1] = 0;

	int nGlyphIndex = 0;
	for (UINT i = 0; i < pGlyphSet->cRanges; i += 1)
	{
		if (i == nFirstJGlyphSet)
			dc.SelectObject(&fontJ);

		WCHAR wcHigh = pGlyphSet->ranges[i].wcLow + pGlyphSet->ranges[i].cGlyphs;
		for (wsz[0] = pGlyphSet->ranges[i].wcLow; wsz[0] < wcHigh; wsz[0] += 1)
		{
			VERIFY(MyCreateTextW(dc.m_hDC, wsz, nChordalDeviation, 0.0f, &rgGlyphObjects[nGlyphIndex]) == D3D_OK);

			CGlyphShape* pShape = rgGlyphObjects[nGlyphIndex].m_pGlyphShape;
			ASSERT(pShape != NULL);

			// Change pointer to file offset...
			rgGlyphObjects[nGlyphIndex].m_pGlyphShape = (CGlyphShape*)file.GetPosition();

			file.Write(&pShape->m_nIndexCount, sizeof (WORD));
			file.Write(&pShape->m_nVertexCount, sizeof (WORD));
			file.Write(pShape->m_indices, sizeof (WORD) * pShape->m_nIndexCount);
			file.Write(pShape->m_vertices, sizeof (CGlyphVertex) * pShape->m_nVertexCount);

			delete [] pShape->m_indices;
			delete [] pShape->m_vertices;
			delete pShape;

			nGlyphIndex += 1;
		}
	}

	// Backup and write the index...
	file.Seek(dwIndexPos, CFile::begin);
	file.Write(rgGlyphObjects, sizeof (CGlyphObject) * pGlyphSet->cGlyphsSupported);

	if (pGlyphSetJ != NULL)
		free(pGlyphSetJ);

	free(pGlyphSet);
	dc.SelectObject(pOldFont);

	g_pFile = NULL;
	g_pWrlFile = NULL;

	delete [] rgGlyphObjects;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\sources.inc ===
# First, define some root variables for intra project references.
# By default, these are:
#
# LANGAPI_ROOT      $(VCROOT)\langapi
# CRT_ROOT          $(VCROOT)\crt
# PDBSRC_ROOT       $(VCROOT)\pdb
# IDE_ROOT          $(VCROOT)\ide
# DEBUGGER_ROOT     $(IDE_ROOT)\debugger
# VCPUBLIC          $(VCROOT)\public

SDK_INC_PATH=$(BASEDIR)\public\wsdk\inc
SDK_LIB_PATH=$(BASEDIR)\public\wsdk\lib
WIN32_IE_VERSION=0x0400
ATL_VER=30

!ifndef LANGAPI_ROOT
LANGAPI_ROOT=$(VCROOT)\langapi
!endif
LANGAPI=$(LANGAPI_ROOT)

!ifndef CRT_ROOT
CRT_ROOT = $(VCROOT)\crt
!endif

!ifndef PDBSRC_ROOT
PDBSRC_ROOT = $(VCROOT)\pdb
!endif

!ifndef IDE_ROOT
IDE_ROOT=$(VCROOT)\ide
!endif

!ifndef DEBUGGER_ROOT
DEBUGGER_ROOT = $(IDE_ROOT)\debugger
!endif

#!ifndef VCPUBLIC
#VCPUBLIC = $(VCROOT)\public
#!endif

!ifndef VCMISC
VCMISC = $(VCROOT)\misc
!endif

!ifndef NONSHIP_LIB_PATH
NONSHIP_LIB_PATH = $(VCPUBLIC)\nonship\lib\$(TARGET_DIRECTORY)
!endif

!ifndef NONSHIP_INC_PATH
NONSHIP_INC_PATH = $(VCPUBLIC)\nonship\inc
!endif

!ifndef MISC_LIB_PATH
MISC_LIB_PATH = $(VCMISC)\lib
!endif

!ifndef MFC_LIBDIR
MFC_LIBDIR=$(SDK_LIB_PATH)
!endif

!ifndef OSDEBUG4
OSDEBUG4=1
!endif

# turn on 32-bit types everywhere with one swell foop.
386_CPPFLAGS = -DCC_CVTYPE32 -DCC_LAZYTYPES
ALPHA_CPPFLAGS = -DCC_CVTYPE32 -DCC_LAZYTYPES

!ifndef DEBUGGER_BUILD
DEBUGGER_BUILD=1
!endif

MASTER_VERSION_FILE = $(LANGAPI_ROOT)\include\version.h

# Then define the SDK, MFC and CRT paths needed to build VC
# (these are different from the paths used to build NT)

DBC=1

NEW_CRTS = 1

!ifndef MFC_VER
MFC_VER = 42
!endif

!IF $(FREEBUILD)
! IFDEF USE_MFCUNICODE
MFC_LIBS= \
    $(MFC_LIBDIR)\mfc$(MFC_VER)u.lib \
    $(MFC_LIBDIR)\mfcs$(MFC_VER)u.lib
! ELSE
MFC_LIBS= \
    $(MFC_LIBDIR)\mfc$(MFC_VER).lib \
    $(MFC_LIBDIR)\mfcs$(MFC_VER).lib
! ENDIF

!ELSE

DEBUG_CRTS=1
! IFDEF USE_MFCUNICODE
MFC_LIBS= \
    $(MFC_LIBDIR)\mfc$(MFC_VER)ud.lib \
    $(MFC_LIBDIR)\mfcs$(MFC_VER)ud.lib \
    $(MFC_LIBDIR)\mfco$(MFC_VER)ud.lib \
    $(MFC_LIBDIR)\mfcd$(MFC_VER)ud.lib \
    $(MFC_LIBDIR)\mfcn$(MFC_VER)ud.lib
! ELSE
MFC_LIBS= \
    $(MFC_LIBDIR)\mfc$(MFC_VER)d.lib \
    $(MFC_LIBDIR)\mfcs$(MFC_VER)d.lib \
    $(MFC_LIBDIR)\mfco$(MFC_VER)d.lib \
    $(MFC_LIBDIR)\mfcd$(MFC_VER)d.lib \
    $(MFC_LIBDIR)\mfcn$(MFC_VER)d.lib
! ENDIF
!ENDIF

# Override the binplace and placefil flags so we can use the VC coffbase/placefil.txt

COFFBASE_TXT_FILE =$(VCMISC)\dllbase.txt

# Set the global compiler warning file.
COMPILER_WARNINGS = /FI$(VCMISC)\inc\warning.h

# All of the VC product can use Native EH, RTTI, PDB's, and Lego

USE_NATIVE_EH=1
USE_PDB=1
NTLEGO=1
USE_MSVCRT=1
NO_NTDLL=1
USE_RTTI=1

# Finally, define a master VC_INCLUDES macro to collect the non-ship includes
# and langapi headers

VC_INCLUDES = $(LANGAPI_ROOT)\include;$(VCMISC)\inc

!ifdef _VCBUILD
NO_INCREMENTAL_LINKING=1
!endif

!if !$(FREEBUILD)
! ifndef NO_INCREMENTAL_LINKING
USE_INCREMENTAL_LINKING=1
! endif
NO_OPTIDATA=1
!endif

# Delay load some libraries
!if $(FREEBUILD)
LINKER_FLAGS=$(LINKER_FLAGS) \
	/delayload:mfcclwz.dll \
	/delayload:version.dll \
	/delayload:comdlg32.dll \
	/delayload:odbc32.dll \
	/delayload:msenc10.dll \
	$(CRT_LIB_PATH)\delayimp.lib
!if $(386)
LINKER_FLAGS=$(LINKER_FLAGS) /filealign:4096 
!endif
!endif


# Turn on lazy pdbs except for build lab or explicit request not to.
! if ("$(NO_SEPARATE_TYPES)" == "" && "$(_VCBUILD)" == "")
! if "$(DEBUG)" == "1" && $(386)
LINKER_FLAGS=$(LINKER_FLAGS) -pdbtype:sept
! endif 
! endif

# Temporary: our current version of rc does not handle the -z switch
RCNOFONTMAP=1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\biavst.h ===
#include "stdarg.h"

#undef i386
#undef _X86_
#undef MIPS
#undef _MIPS_
#undef ALPHA
#undef _ALPHA_
#undef PPC
#undef _PPC_


//
// _X86_ causes:
//      nt.h        include "nti386.h"
//      nti386.h    an x86 typedef for _DBGKD_CONTROL_REPORT et al
//      nti386.h    the 386 CONTEXT record and friends
//
// _ALPHA_ causes:
//      ntdef.h     UNALIGNED to be defined as __unaligned
//      nt.h        include "ntalpha.h"
//      ntalpha.h   an alpha typedef for _DBGKD_CONTROL_REPORT et al
//      ntalpha.h   the alpha CONTEXT record and friends
//
// _MIPS_ causes:
//      nt.h        include "ntmips.h"
//      ntdef.h     UNALIGNED to be defined as __unaligned
//      ntmips.h    _cdecl to be defined as ""
//      ntmips.h    ifdef MIPS:
//                      a MIPS typedef for _DBGKD_CONTROL_REPORT et al
//                      the MIPS CONTEXT record and friends
//
// _PPC_ causes:
//      ntdef.h     UNALIGNED to be defined as __unaligned
//      nt.h        include "ntppc.h"
//      ntppc.h     a ppc typedef for _DBGKD_CONTROL_REPORT et al
//      ntppc.h     the ppc CONTEXT record and friends
//
//
//



#if defined(TARGET_MIPS)

#define _MIPS_ 1

#if defined(HOST_MIPS)
#define MIPS 1
#endif

#if defined(HOST_i386)
#define __unaligned
#endif

#define _CONTEXT _MIPS_CONTEXT
#define CONTEXT MIPS_CONTEXT
#define PCONTEXT PMIPS_CONTEXT
#define LPCONTEXT LPMIPS_CONTEXT


#include <windows.h>
#include <basetsd.h>
#include <nt.h>
#include <windbgkd.h>
#include <imagehlp.h>

#if !defined(HOST_MIPS)
#undef MIPS
#undef _MIPS_
#endif

#if defined(HOST_i386)
#undef _cdecl
#undef UNALIGNED
#define UNALIGNED
#endif

#ifdef _BASETSD_H_
#undef _BASETSD_H_
#endif

#elif defined(TARGET_PPC)

#define _PPC_ 1

#if defined(HOST_MIPS)
#define MIPS 1
#endif

#if defined(HOST_i386)
#define __unaligned
#endif

#define _CONTEXT _PPC_CONTEXT
#define CONTEXT PPC_CONTEXT
#define PCONTEXT PPPC_CONTEXT
#define LPCONTEXT LPPPC_CONTEXT


#include <windows.h>
#include <basetsd.h>
#include <windbgkd.h>
#include <imagehlp.h>

#if !defined(HOST_MIPS)
#undef MIPS
#undef _MIPS_
#endif

#if defined(HOST_i386)
#undef _cdecl
#undef UNALIGNED
#define UNALIGNED
#endif

#ifdef _BASETSD_H_
#undef _BASETSD_H_
#endif






#elif defined(TARGET_i386)

#define _X86_ 1

#if defined(HOST_MIPS)
#define MIPS 1
#endif

#define _CONTEXT _I386_CONTEXT
#define CONTEXT I386_CONTEXT
#define PCONTEXT PI386_CONTEXT
#define LPCONTEXT LPI386_CONTEXT

#include <windows.h>
#include <basetsd.h>
#include <windbgkd.h>
#include <imagehlp.h>

#if defined(HOST_MIPS)
#undef _cdecl
#define _cdecl
#endif

#if defined(HOST_ALPHA)
#undef _cdecl
#define _cdecl
#endif

#ifdef _BASETSD_H_
#undef _BASETSD_H_
#endif


#elif defined(TARGET_ALPHA)

#define _ALPHA_ 1

#if defined(HOST_i386)
#define __unaligned
#endif

#if defined(HOST_MIPS)
#define MIPS 1
#endif

#define _CONTEXT _ALPHA_CONTEXT
#define CONTEXT ALPHA_CONTEXT
#define PCONTEXT PALPHA_CONTEXT
#define LPCONTEXT LPALPHA_CONTEXT

#include <windows.h>
#include <basetsd.h>
#include <windbgkd.h>
#include <imagehlp.h>

#if defined(HOST_MIPS)
#undef _cdecl
#define _cdecl
#endif

#if defined(HOST_i386)
#undef UNALIGNED
#define UNALIGNED
#endif

#if !defined(HOST_ALPHA)
#undef _ALPHA_
#endif

#ifdef _BASETSD_H_
#undef _BASETSD_H_
#endif

#else

#error "Unsupported target CPU"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\sources.inc ===
# Get all the other project paths.

VCROOT=$(BASEDIR)\private\vc6addon
#!include $(VCROOT)\sources.inc
!include $(VCROOT)\ide\sources.inc
DBG_ROOT=$(IDE_ROOT)\debugger

NOT_LEAN_AND_MEAN=
386_STDCALL = 1


DLLENTRY = _DllMainCRTStartup

MSC_WARNING_LEVEL=/WX /W3

C_DEFINES = $(C_DEFINES) -DWIN32 -DTARGET32 -DHOST32 -D_CROSS_PLATFORM_ -DOSDEBUG4

MIPS_FLAGS = -DHOST_MIPS
386_FLAGS  = -DHOST_i386
ALPHA_FLAGS= -DHOST_ALPHA
PPC_FLAGS  = -DHOST_PPC

!if $(FREEBUILD)
C_DEFINES = $(C_DEFINES) -DNDEBUG
D=
!else
C_DEFINES = $(C_DEFINES) -DDEBUGVER
D=D
!endif

DEBUG_INCLUDES=$(VC_INCLUDES);  \
               $(LANGAPI_ROOT)\debugger

DEBUG_LIB=$(IDE_ROOT)\lib
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    emdp.h

Author:

    Wesley Witt (wesw) 21-Sep-1993

--*/

#ifndef OSDEBUG4
#error ("must define OSDEBUG4!")
#endif

#include <windows.h>
#include <stdio.h>
#include <dde.h>
#include <stdlib.h>
#include <stddef.h>
#include <ctype.h>
#include <memory.h>
#include <string.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <tchar.h>

#include <imagehlp.h>
#include <cvinfo.h>

#pragma warning( disable: 4200)

#include "od.h"
#include "odp.h"
#include "odassert.h"

// BUGBUG kentf have to include shapi.h for LPDEBUGDATA?
#define FLOAT10 double
typedef LPADDR PADDR;
#define EXPCALL __stdcall

#include "shapi.h"

#include "emdm.h"
#include "win32dm.h"

#include "emcpu.h"
#include "emdata.h"
#include "emproto.h"

extern CRITICAL_SECTION csInTL;
#define GuardTL() EnterCriticalSection(&csInTL)
#define ReleaseTL() LeaveCriticalSection(&csInTL)

extern HINSTANCE hInstance;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\sources.inc ===
#
# sources.inc
#
# Kent Forschmiedt (kentf) 11/30/95
#
# This is the global sources file for the MSVC project.
# The environment variable VCROOT must be defined as the
# directory where this file is found.
# The following environment variables may be defined, and will
# be assigned reasonable values if they are not:
#
# LANGAPI           $(VCROOT)\langapi
# CRTROOT
# CRT_INCLUDES      $(CRTROOT)\crtw32\h
# CRTLIB_DIR

VCROOT=$(BASEDIR)\private\vc6addon

#
# Pick up master directory definitions
#

!include $(VCROOT)\sources.inc

#
# Default settings:
#

DBC=1
TEST=1
#OSDEBUG4=1

!if $(FREEBUILD)
DEBUG=0
!else
DEBUG=1
!endif


!if "$(OLE)"!="0"
OLE=1
!endif


#
# if RCTOOL is not defined, default to "rc"
# this allows the use a different rc from NT-J
#

!if "$(RCTOOL)" == ""
RCTOOL=rc
!endif

#
# Standard includes:
#

DBGINCLUDES=$(LANGAPI_ROOT)\debugger

IDE_INCLUDES=$(IDE_ROOT)\include;$(DBGINCLUDES);$(VC_INCLUDES);$(IDE_ROOT)\idl;$(LANGAPI)\ncb

#
# compiler defines
#

C_DEFINES = $(C_DEFINES) \
            -DSHIP -D_SUSHI -DNEW_PROJ_VIEW -DCODEVIEW -DPPC_PLATFORM  \
            -DHOST32 -DTARGET32 -DADDR_MIXED -DCROSS_PLATFORM          \
            -D_WINDOWS -DNT_BUILD -D_NTWIN -DSTRICT -DBORDER_BUTTONS\
            -D__DEVHELP98__ -DCC_MULTIPLE_STORES=1

#
# Is this a ship build, or are chickens made of cheese?
#

!if "$(_SHIP)" == "1"
!message Building _SHIPping version, really, honest.
C_DEFINES = $(C_DEFINES) -D_SHIP
!endif

!ifdef OSDEBUG4
C_DEFINES=$(C_DEFINES) -DOSDEBUG4
!endif

!if "$(DEBUG)" == "1"
D=D
CFGNAME=Win32 Debug
C_DEFINES = $(C_DEFINES) -DDEBUG=1
PACKVERCHECK=$(IDE_ROOT)\include\$(TARGET_DIRECTORY)\pkgverd.h
MKTYPLIB_FLAGS=$(MKTYPLIB_FLAGS) /D_DEBUG
MSC_OPTIMIZATION=/Od
!else
D=
CFGNAME=Win32 Release
C_DEFINES = $(C_DEFINES) -DNDEBUG
PACKVERCHECK=$(IDE_ROOT)\include\$(TARGET_DIRECTORY)\pkgver.h
!endif

!if "$(DBC)" == "1"
# !message Building DBC enabled version!
# !message adding-D_DBCS=1 -D_MBCS to compile flags
C_DEFINES = $(C_DEFINES) -D_DBCS=1 -D_MBCS
!endif

!if "$(TEST)"=="1"
C_DEFINES=$(C_DEFINES) -D_TEST
!endif

!ifdef DMALLOC
C_DEFINES = $(C_DEFINES) -DUSE_DMALLOC
!endif

!if "$(SPY)" == "1"
C_DEFINES = $(C_DEFINES) -DSPY
!endif

#
# Misc compile and linker options
#
NOT_LEAN_AND_MEAN = 1
386_STDCALL=0

MIPS_FLAGS = -DHOST_MIPS
386_FLAGS  = -DHOST_i386 -Dx86
ALPHA_FLAGS= -DHOST_ALPHA
PPC_FLAGS  = -DHOST_PPC

#
# Every dll here (?) has a DllMain
#
DLLENTRY=_DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdisasm.cpp ===
/**** EMDISASM.C - EM Lego disassembler interface                          *
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1995, Microsoft Corp                                     *
 *                                                                         *
 *  Created: September 18, 1995 by RafaelL                                 *
 *                                                                         *
 *  Revision History:                                                      *
 *                                                                         *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

#include "emdp.h"

#include <simpldis.h>
#define _CRTBLD
#include "undname.h"
#undef _CRTBLD

#define MAXL     20
#define CCHMAX   256

// these are defines taken from the compiler front-end
#define	LIMIT_DNAME_WSTRING_LENGTH	20
#define	LIMIT_DNAME_STRING_LENGTH	32

// offset is masm syntax, which means zero-prefixed if starts with A-F,
// h postfixed if =>10

LPSTR MasmOffset( DWORD dwOffset, LPSTR szResult )
{
	if (dwOffset==0)
	{
		*szResult = 0;
	}
	else
	{
		CHAR szNumber[10];
		_ultoa( dwOffset, szNumber, 16 );
		_strupr( szNumber );
		sprintf( szResult, "+%s%s%c", (szNumber[0]>'9') ? "0" : "", szNumber, (dwOffset>9) ? 'h' : 0 );
	}
	return szResult;
}

LOCAL int EncodedChar( const char *&p )
{
	int c = (int)(unsigned char)*p++;

	if (c!='?')
		return c;

	c = *p++;
	if ( (c>='0') && (c<='9') )
		return ",/\\:. \n\t'-"[ c-'0' ];

	if (c=='$')
	{
		// the masking is required due to a bug in V5 and pre-M3 V6 which was related to sign
		// extension and would output characters less than 'A', e.g.
		// 0x80 was output as "?$9A" instead of "?$IA"
		// mangling sources are in \\lang5\v5x.pro\src\cxxfe\sl\p1\c\outdname.c in DN_StringChar
		c = (unsigned char)((*p++) - 'A') & 0xF;
		c <<= 4;
		c |= (unsigned char)((*p++) - 'A') & 0xF;
		return c;
	}

	return c | 0x80;
}

// returns NULL if didn't like it
// length of result is:
// <string ""> 9
// Unicode worse case: L + 20 * "\n1234" = 121
// Ansi worse case: 32 * "?$XX" = 128
// Worse case = 138 (including terminator) which is well within limits (256) so no checks

LOCAL pchar_t ExtractString( LPTSTR pNewName, LPCTSTR pOldName, size_t /* nSize */, const ADDR& addr )
{
	assert( memcmp(pOldName, "\?\?_C@_",6)==0 );		// marker prefix

	const char *p = pOldName+6;
	bool bUnicode;
	switch (*p++)
	{
		case '0':
			bUnicode = false;
			break;
		case '1':
			bUnicode = true;
			break;
		default:
			assert(!"Strange unmangled string type");
			return NULL;
			break;
	}

	size_t nLength;
	if ( (p[1]!='@') && (p[1]<='9') )
	{
		// short length, single digit, no @ sign
		nLength = p[0]-'0';
		p++;
	}
	else
	{
		if (p[0]=='A')
		{
			nLength = 0;
			p+=2;
		}
		else if (p[0]<='9')
		{
			nLength = p[0]-'0'+1;
			p+=2;
		}
		else
		{
			nLength = 0;
			do
			{
				nLength = (nLength<<4) | (p[0]-'A');
				p++;
			}
			while (p[0]!='@');
			p++;
		}
	}

	// skip the checksum (whose value we don't care about)
	// if the checksum was ever 1-9 there would be no @ sign, cope with paranoid case
	if (*p>'9')
		while (*p!='@')
		{
			if (*p==0)
			{
				assert( !"Strange unmangled string" );
				return NULL;
			}
			p++;
		}
	p++;

	char *pOut = pNewName;
	strcpy( pOut, bUnicode ? "string L\"" : "string \"" );
	pOut += strlen(pOut);

	size_t i;
	bool bMore = false;

	// get displayable length, smaller of actual-terminator or limit
	if (bUnicode)
	{
		i = min( (nLength-1)/2, LIMIT_DNAME_WSTRING_LENGTH );
		bMore = (nLength>LIMIT_DNAME_WSTRING_LENGTH*2) ? true : false;
	}
	else
	{
		i = min( nLength-1, LIMIT_DNAME_STRING_LENGTH );
		bMore = (nLength>LIMIT_DNAME_STRING_LENGTH) ? true : false;
	}

#ifdef UNICODE
#error improve this code for Unicode
#endif

	while (i--)
	{
		int c = EncodedChar( p );

		if (bUnicode)
		{
			int lowbyte = EncodedChar( p );
			if ( (c!=0) || (lowbyte>0x7f) )
			{
				pOut += sprintf( pOut, "\\x%04x", (c<<8)|lowbyte );
				continue;
			}
			// simple conversion so do so
			c = lowbyte;
		}
		
		switch (c)
		{
			case 0:
				pOut += sprintf( pOut, "\\0" );
				break;
			case '\r':
				pOut += sprintf( pOut, "\\r" );
				break;
			case '\n':
				pOut += sprintf( pOut, "\\n" );
				break;
			case '\\':
				pOut += sprintf( pOut, "\\\\" );
				break;
			case '\t':
				pOut += sprintf( pOut, "\\t" );
				break;
			default:
				if ( (c<' ') || (c>0x7f) )
					pOut += sprintf( pOut, "\\x%02x", c );
				else
					*pOut++ = (char)c;
				break;
		}
	}

	strcpy( pOut, bMore ? "\"..." : "\"" );

	return pNewName;
}

LPSTR
_SHGetSymbol(
	LPADDR	addr1,
	SOP		sop,
	LPADDR	addr2,
	LPSTR	szName,
	LPDWORD	Delta,
	BOOL	bAddOffset
	)
{
	ODR		odr;
	LPSTR	lpstr;
	
	odr.lszName = szName;
	lpstr = SHGetSymbol (addr1, addr2, sop, &odr);

	if (Delta)
		*Delta = odr.dwDeltaOff;

	if (lpstr)
	{
		CHAR newname[512];		// same length as clients' buffers
		pchar_t pResult = NULL;

		// try and undecorate the symbol using (undocumented) CRT routine
		// Note you *cannot* pass NULL as the allocator, contrary to the 'docs'
		if (lpstr[0]=='?')
		{
			if (memcmp(lpstr+1,"\?_C@_",5)==0)
				pResult = ExtractString( newname, lpstr, sizeof(newname), *addr1 );
			else
				pResult = __unDName( newname, lpstr, sizeof(newname), malloc, free, UNDNAME_NAME_ONLY );
		}
		else if ((lpstr[0]=='@') && (lpstr[1]=='I') && (lpstr[2]=='L'))
		{
			// ILT symbols get generated on the fly by MSPDB, so turn
			// @ITL+0x1234(?Foothing) into an undecorated version
			LPSTR pOpen = _tcschr( lpstr, '(' );
			if (pOpen)
			{
				LPSTR pClose = _tcschr( pOpen+1, ')' );
				if (pClose)
				{
					CHAR noBrackets[512];
					size_t len = pClose-pOpen-1;
					memcpy( newname, pOpen+1, len );
					newname[len]=0;
					pResult = __unDName( noBrackets, newname, sizeof(noBrackets), malloc, free, UNDNAME_NAME_ONLY );
					if (pResult)
					{
						// put the unmangled version back together
						memcpy( szName, lpstr, pOpen-lpstr+1 );				// "@ILT+4("
						memcpy( szName + (pOpen-lpstr+1), noBrackets, _tcslen(noBrackets) );	// unmangled name
						_tcscpy( szName + (pOpen-lpstr+1)+_tcslen(noBrackets), ")" );
						pResult = NULL;				// prevent redundant copy below
					}
				}
			}
		}
		if (pResult)
			_tcscpy( szName, pResult );
	}
	
	if (lpstr && bAddOffset)
	{
		// we currently have "SymFoo", and an offset
		// we need to turn this into "SymFoo+masmoffset(0xrealaddr)"
		// and return an offset of zero to stop the disassembler from adding
		// spurious "+nnn" digits
		CHAR extra[25];
		CHAR szOffset[20];
		sprintf( extra, "%s (%08lx)", MasmOffset(*Delta, szOffset), GetAddrOff( *addr1 ) );
		_tcscat( lpstr, extra );
		*Delta = 0;
	}

	return lpstr;
}
	

XOSD Assemble (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPTSTR lszInput
    )
{
    return xosdUnsupported;
}


int
CvRegFromSimpleReg(
    MPT     mpt,
    int     regInstr
    )
{
    switch (mpt) {
    case mptix86:
        switch(regInstr) {
            case SimpleRegEax: return CV_REG_EAX;
            case SimpleRegEcx: return CV_REG_ECX;
            case SimpleRegEdx: return CV_REG_EDX;
            case SimpleRegEbx: return CV_REG_EBX;
            case SimpleRegEsp: return CV_REG_ESP;
            case SimpleRegEbp: return CV_REG_EBP;
            case SimpleRegEsi: return CV_REG_ESI;
            case SimpleRegEdi: return CV_REG_EDI;
        }
        break;

    case mptmips:
        return (regInstr + CV_M4_IntZERO);

    case mptdaxp:
        return (regInstr + CV_ALPHA_IntV0);

    case mptmppc:
        return (regInstr + CV_PPC_GPR0);

    }
    return (0);
}

int
SimpleArchFromMPT(
    MPT mpt
    )
{
    switch (mpt) {
        case mptix86:
            return Simple_Arch_X86;

        case mptmips:
            return Simple_Arch_Mips;

        case mptdaxp:
            return Simple_Arch_AlphaAxp;

        case mptmppc:
            return Simple_Arch_PowerPc;

        default:
            return -1;
    }
}



DWORDLONG
QwGetreg(
    PVOID   pv,
    int     regInstr
    )
{
    HTHD hthd = (HTHD)pv;

    XOSD        xosd;
    DWORDLONG   retVal;
    HPID        hpid = HpidFromHthd(hthd);

    xosd = GetRegValue(hpid,
                       HtidFromHthd(hthd),
                       CvRegFromSimpleReg(MPTFromHthd(hthd), regInstr),
                       &retVal
                       );

    return (xosd == xosdNone) ? retVal : 0;
}


size_t
WINAPI
CchRegrel(
    PVOID       pv,
    DWORD       ipaddr,
    int         reg,
    DWORD       offset,
    PCHAR       symbol,
    size_t      symsize,
    PDWORD      pDisp
    )
{
	HTHD hthd = (HTHD)pv;
 	
	CHAR    string[512];
    DWORD   dw;
    ADDR    AddrIP;
    ADDR    AddrData;
	MPT     mpt = MPTFromHthd(hthd);

	// ALPHA and PowerPC data access through registers other than SP
	int     cvReg = CvRegFromSimpleReg(mpt, reg);

	// Theoretically, you can get the value for the ALPHA GP register, or
	// for other non-SP registers when the current PC matches the 
	// instruction PC, and in some other cases,
	// but for now just fail for non-SP cases
	
	if ((mpt == mptdaxp && cvReg != CV_ALPHA_IntSP) || (mpt == mptmppc && cvReg != CV_PPC_GPR1))
	{
		return 0;
	}

	// Lock the thread only after we've interogated the thread
	// for any of the ALPHA or PPC cases above

    LPTHD   lpthd = (LPTHD)LLLock(hthd);
    AddrInit(&AddrIP,
             NULL,
             (SEGMENT)(lpthd->fFlat? 0 : (ipaddr >> 16)), //seg
             (lpthd->fFlat? ipaddr : (ipaddr & 0xffff)),
             lpthd->fFlat,
             lpthd->fOff32,
             0, // li
             lpthd->fReal);

    AddrInit(&AddrData,
             NULL,
             (SEGMENT)(lpthd->fFlat? 0 : (offset >> 16)), //seg
             (lpthd->fFlat? offset : (offset & 0xffff)),
             lpthd->fFlat,
             lpthd->fOff32,
             0,
             (USHORT)lpthd->fReal);

    LLUnlock(hthd);

 	// For x86 architecture SHGetSymbol assumes offsets are relative to ebp	
 	if ((!((SimpleArchFromMPT(mpt) == Simple_Arch_X86) && 
 		(CvRegFromSimpleReg(mpt,reg) != CV_REG_EBP)))
 		&& _SHGetSymbol (&AddrData, sopStack, &AddrIP, string,  &dw, FALSE )) {
    		_tcsncpy( symbol, string, symsize );
    		*pDisp = dw;
    	} else {
    		*pDisp = 0;
    		symbol[0] = 0;
    	} 
			
    return _tcslen(symbol);
}



unsigned int
CchAddr(
    PVOID       pv,
    ULONG       offset,
    char        *symbol,
    size_t      symsize,
    DWORD       *pDisp
    )
{
	HTHD hthd = (HTHD)pv;
	
    CHAR    string[512];
    DWORD   dw;
    ADDR    AddrIP;
    ADDR    AddrData;
    LPTHD   lpthd = (LPTHD)LLLock(hthd);

    AddrInit(&AddrData,
             NULL,
             (SEGMENT)(lpthd->fFlat? 0 : (offset >> 16)), //seg
             (lpthd->fFlat? offset : (offset & 0xffff)),
             lpthd->fFlat,
             lpthd->fOff32,
             0, // li
             (USHORT)lpthd->fReal);

    LLUnlock(hthd);

    AddrIP = AddrData;


       	if (_SHGetSymbol (&AddrData, sopNone, &AddrIP, string,  &dw, TRUE )) {
    		_tcsncpy( symbol, string, symsize );
    		*pDisp = dw;
    	} else {
    		*pDisp = 0;
    		symbol[0] = 0;
    	}
    	
    return _tcslen(symbol);
}


unsigned int
CchFixup(
    PVOID       pv,
    DWORD       ipaddr,
    ULONG       offset,
    size_t      size,
    PCHAR       symbol,
    size_t      symsize,
    DWORD       *pDisp
    )
{
	HTHD hthd = (HTHD)pv;
	
    CHAR    string[512];
    DWORD   dw;
    ADDR    AddrIP;
    ADDR    AddrData;
    LPTHD   lpthd = (LPTHD)LLLock(hthd);
    MPT     mpt = MPTFromHthd(hthd);

	// 16 bit displacement values cannot be fixed up on ALPHA or PowerPC
	// 16 bit register offsets are picked up in CchRegrel
	if (size < sizeof(DWORD) && (mpt == mptdaxp || mpt == mptmppc))
	{
		return 0;
	}


    AddrInit(&AddrIP,
             NULL,
             (SEGMENT)(lpthd->fFlat? 0 : (ipaddr >> 16)), //seg
             (lpthd->fFlat? ipaddr : (ipaddr & 0xffff)),
             lpthd->fFlat,
             lpthd->fOff32,
             0, // li
             (USHORT)lpthd->fReal);

    AddrInit(&AddrData,
             NULL,
             (SEGMENT)(lpthd->fFlat? 0 : (offset >> 16)), //seg
             (lpthd->fFlat? offset : (offset & 0xffff)),
             lpthd->fFlat,
             lpthd->fOff32,
             0,
             (USHORT)lpthd->fReal);

    LLUnlock(hthd);

	if (size==sizeof(DWORD))
	{
		// go get the DWORD at address 'offset'
		DWORD dw;
		DWORD res;
		XOSD xosd = ReadBuffer( HpidFromHthd(hthd), HtidFromHthd(hthd), &AddrData, size, (LPBYTE)&dw, &res );
		if (xosd==xosdNone)
			SetAddrOff( &AddrData, dw );
		else
		{
			// couldn't read the memory
			*pDisp = 0;
			symbol[0] = 0;
			return 0;
		}
	}

    	if (_SHGetSymbol (&AddrData, sopNone, &AddrIP, string,  &dw, TRUE )) {
    		_tcsncpy( symbol, string, symsize );
    		*pDisp = dw;
    	} else {
    		*pDisp = 0;
    		symbol[0] = 0;
    	}
    	
    return _tcslen(symbol);
}

int
AddString(
    LPSTR *ppchOut,
    LPINT  pichCur,
    LPINT  pcchMax,
    LPSTR  string
    )

/*++

Routine Description:

    Add a string to a packed list of strings.

Arguments:

    ppchOut - Supplies a pointer to a pointer to the position of the next
        entry in the string.  Returns the new position after this string
        is added.

    pichCur - Supplies a pointer to the current index in the string.  Returns
        the new index.

    pcchMax - Supplies a pointer to the number of characters available in the
        string.  Returns the new value of same.

    string - Supplies the string to add to the list.

Return Value:

    Index to beginning of string (original ichCur).  Returns -1 if the string
    could not be added.

--*/
{
    int r = -1;
    int l = _tcslen(string);
    if (l >= *pcchMax) {
        l = *pcchMax - 1;
    }
    if (l >= 0) {
        _tcsncpy(*ppchOut, string, l);
        (*ppchOut)[l] = 0;
        *pcchMax -= (l+1);
        r = *pichCur;
        *pichCur += (l+1);
        *ppchOut += (l+1);
    }
    return r;

}

XOSD
Disasm (
    HPID   hpid,
    HTID   htid,
    LPSDI  lpsdi
    )
{
    XOSD        xosd      = xosdNone;
    DWORD       dop       = lpsdi->dop;
    DWORD       cb;
    int         cbUsed    = 0;
    ADDR        addr;
    BYTE        rgb[MAXL];
    PBYTE       prgb;
    int         Bytes;
    DWORD       dwTgtMem;
    SIMPLEDIS   Sdis;
    HPRC        hprc = ValidHprcFromHpid(hpid);
    HTHD        hthd = HthdFromHtid( hprc, htid );
    MPT         mpt = MPTFromHthd(hthd);

    static char String[CCHMAX];
    LPSTR       lpchOut;
    int         ichCur;
    int         cchMax;




    lpsdi->ichAddr      = -1;
    lpsdi->ichBytes     = -1;
    lpsdi->ichOpcode    = -1;
    lpsdi->ichOperands  = -1;
    lpsdi->ichComment   = -1;
    lpsdi->ichEA0       = -1;
    lpsdi->ichEA1       = -1;
    lpsdi->ichEA2       = -1;

    lpsdi->cbEA0        =  0;
    lpsdi->cbEA1        =  0;
    lpsdi->cbEA2        =  0;

    lpsdi->fAssocNext   =  0;

    lpsdi->lpch         = String;



    //ADDR_IS_FLAT( addrStart ) = TRUE;

    //if (!Memory) {
        xosd = ReadBuffer(hpid, htid, &lpsdi->addr, MAXL, rgb, (unsigned long *) &cb);
        if (xosd != xosdNone) {
            cb = 0;
        }
        prgb = rgb;
    //}
    //else {
        //prgb = (BYTE *) Memory;
        //cb  = (DWORD)MemorySize;
    //}

    if ( cb == 0 ) {

        //
        // Even if we can't read memory we still need to send back the formatted address
        // so the shell can display it.  
        // HACK HACK: We make up the address string here from the passed in address. We need to 
        // come up with a better solution so we don't have to keep the address formatting 
        // between the disassembler and the EM in sync. [sanjays]

        if ((dop & dopAddr) || (dop & dopFlatAddr)) {

            //
            // address of instruction
            //
            sprintf(String,"%08X", GetAddrOff(lpsdi->addr)); 
            lpsdi->ichAddr = 0;
        }

        //cbUsed = 0;
        cbUsed = 1;
        xosd = xosdGeneral;

    } else {

		if (dop & dopSym) {
        Bytes = SimplyDisassemble(
            prgb,                         // code ptr
            cb,                           // bytes
            GetAddrOff(lpsdi->addr),
            SimpleArchFromMPT(mpt),
            &Sdis,
            CchAddr,
            CchFixup,
            CchRegrel,
            QwGetreg,
            (PVOID)hthd
            );
		} else {
		Bytes = SimplyDisassemble(
            prgb,                         // code ptr
            cb,                           // bytes
            GetAddrOff(lpsdi->addr),
            SimpleArchFromMPT(mpt),
            &Sdis,
			NULL,
            NULL,
            NULL,
            QwGetreg,
            (PVOID)hthd
            );
		}


        if (Bytes < 0) {
            cbUsed = -Bytes;
            //xosd = xosdGeneral;
        } else {
            cbUsed = Bytes;
        }

        //
        // unpack Sdis
        //


        //
        // fill in addresses, whether asked for or not
        //

        lpsdi->cbEA0 = Sdis.cbEA0;
        lpsdi->cbEA1 = Sdis.cbEA1;
        lpsdi->cbEA2 = Sdis.cbEA2;

        if (lpsdi->cbEA0) {
            AddrInit( &lpsdi->addrEA0,
                      NULL,
                      0,    // SEG
                      Sdis.dwEA0,
                      1,    // flat
                      1,    // off32
                      0,    // LI
                      0     // real
                      );
        }

        if (lpsdi->cbEA1) {
            AddrInit( &lpsdi->addrEA1,
                      NULL,
                      0,    // SEG
                      Sdis.dwEA1,
                      1,    // flat
                      1,    // off32
                      0,    // LI
                      0     // real
                      );
        }

        if (lpsdi->cbEA2) {
            AddrInit( &lpsdi->addrEA2,
                      NULL,
                      0,    // SEG
                      Sdis.dwEA2,
                      1,    // flat
                      1,    // off32
                      0,    // LI
                      0     // real
                      );
        }


        //
        // initialize packed string
        //
        lpchOut   = String;
        ichCur    = 0;
        cchMax    = CCHMAX;

        if ((dop & dopAddr) || (dop & dopFlatAddr)) {

            //
            // address of instruction
            //

            lpsdi->ichAddr = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szAddress);

        }

        if (dop & dopRaw) {

            //
            // Raw bytes
            //

            lpsdi->ichBytes = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szRaw);

        }

        if (dop & dopOpcode) {

            //
            // opcode...
            //

            lpsdi->ichOpcode = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szOpcode);

        }

        if (dop & dopOperands) {

            //
            // operands...
            //

            lpsdi->ichOperands = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szOperands);

        }

        {

            //
            // comment
            //

            lpsdi->ichComment   = -1;

        }

        if (dop & dopEA) {

            //
            // show EA(s)
            //

            if (lpsdi->cbEA0) {
                lpsdi->ichEA0 = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szEA0);
            }

            if (lpsdi->cbEA1) {
                lpsdi->ichEA1 = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szEA1);
            }

            if (lpsdi->cbEA2) {
                lpsdi->ichEA2 = AddString(&lpchOut, &ichCur, &cchMax, Sdis.szEA2);
            }
        }

    }

    GetAddrOff ( lpsdi->addr ) += cbUsed;
 	lpsdi->addr.emi = 0;

    return xosd;
}



XOSD
BackDisasm(
    HPID hpid,
    HTID htid,
    LPGPIS lpgpis
    )

/*++

Routine Description:

    This will find the instruction which ends nearest to the supplied address
    without consuming the supplied address.

    On machines with fixed instruction size and alignment, this is trivially
    accomplished with arithmetic.

    On machines with variable instruction size, this is done by disassembling
    instructions until a closest fit is found.

    This implementation will not consume the supplied address, but will accept
    either a) the first (longest) match which consumes the byte before the
    address, or b) the match which ends closest to the address.

Arguments:

    hpid -

    htid -

    lpgpis -


Return Value:


--*/
{
    HPRC        hprc = ValidHprcFromHpid(hpid);
    HTHD        hthd = HthdFromHtid( hprc, htid );
    MPT         mpt = MPTFromHthd(hthd);
    SIMPLEDIS   Sdis;

    if (GetAddrOff(*lpgpis->lpaddr) == 0) {

        return xosdBadAddress;

	} else if (mpt != mptix86) {
        //
		// all but X86 can assume DWORD alignment opcodes
        //

        SetAddrOff((lpgpis->lpaddr), GetAddrOff(*(lpgpis->lpaddr))-4);
        *(lpgpis->lpuoffset) = GetAddrOff(*(lpgpis->lpaddr)) & 3;
        SetAddrOff((lpgpis->lpaddr),
                 GetAddrOff(*(lpgpis->lpaddr)) - *(lpgpis->lpuoffset));

        return xosdNone; // Hack for MIPS&Alpha doesn't check page r/w
    } else {

        //
		// x86 is more painful
		// we start 20 bytes before and disassemble forwards until we hit it
		// if we miss it, we start again from the next byte	down
        //

        const int arch = SimpleArchFromMPT(mpt);
		const int X86_BACK_MAX = 20;
		UOFF32 endOffset = GetAddrOff(*lpgpis->lpaddr);		// where we want to end up
		ADDR startAddr = *lpgpis->lpaddr;
        DWORD cbTry;
		BYTE rgb[X86_BACK_MAX];

		// we start X86_BACK_MAX bytes before (checking that we're not too early)
		if (GetAddrOff(startAddr) < X86_BACK_MAX) {
			GetAddrOff(startAddr) = 0;
		} else {
			GetAddrOff(startAddr) -= X86_BACK_MAX;
        }

        XOSD xosd = ReadBuffer(hpid, htid, &startAddr, X86_BACK_MAX, rgb, &cbTry);

        if (xosd != xosdNone) {
            //
            // nothing there.  just decrement 1 and return.
            //
            SetAddrOff( lpgpis->lpaddr, endOffset - 1 );
            return xosd;
        }



        LPBYTE pbTry = rgb;
		UOFF32 tryOffset = GetAddrOff(startAddr);

		while (cbTry > 0) {

            LPBYTE pbCurr = pbTry;
            DWORD cbCurr = cbTry;
			UOFF32 currOffset = tryOffset;

			while (1) {

                int Bytes = SimplyDisassemble(pbCurr,
                                              cbCurr,
                                              currOffset,
                                              arch,
                                              &Sdis,
                                              CchAddr,
                                              CchFixup,
                                              CchRegrel,
                                              QwGetreg,
                                              (PVOID)hthd
                                              );
                if (Bytes < 0) {

                    //
                    // no instruction found - slide ahead one
                    // byte and start again.
                    //

                    pbTry += 1;
                    cbTry -= 1;
                    tryOffset += 1;
                    break;
                }

                if (Bytes == 0) {

                    //
                    // this is not supposed to happen
                    //

                    assert(!"SimplyDisassemble returned 0!");
                    SetAddrOff( lpgpis->lpaddr, endOffset - 1 );
                    return xosdGeneral;

                }

                if (Bytes > (int)cbCurr) {

                    //
                    // this is not supposed to happen
                    //

                    assert(!"SimplyDisassemble consumed too many bytes!");
                    SetAddrOff( lpgpis->lpaddr, endOffset - 1 );
                    return xosdGeneral;

                }

                if (Bytes < (int)cbCurr) {

                    //
                    // so far, so good.
                    //

                    cbCurr -= Bytes;
                    pbCurr += Bytes;
                    currOffset += Bytes;
                    continue;
                }


                if (Bytes == (int)cbCurr) {

                    //
                    // perfect fit
                    //

                    // currOffset is the one we want.

                    SetAddrOff(lpgpis->lpaddr, currOffset);
                    return xosdNone;
                }
				
			}

        }

        //
		// didn't find anything at all, so bail out and
        // pretend it's a one byte op-code
        //

		SetAddrOff( lpgpis->lpaddr, endOffset - 1 );
		return xosdNone;
	}

}

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    emdp.c

Abstract:

    This file contains the main driver for the native execution models
    supported by us.  This file additionally contains the machine
    independent portions of the execution model.  The machine dependent
    portions are in other files.

Author:

    Jim Schaad (jimsch) 05-23-92

Environment:

    Win32 -- User

Notes:

    The orginal source for this came from the CodeView group.

--*/

#include "emdp.h"
#include "simpldis.h"

#include "dbgver.h"

/*************************** DEFINES  *****************************/

#define CBBUFFERDEF 1024
#define CEXM_MDL_native 0x20
#define cchErrMax   50

/******************* TYPEDEFS and STRUCTURE ***********************/


/*********************** LOCAL DATA *******************************/

CRITICAL_SECTION csCache;
CRITICAL_SECTION csInTL;

LPBYTE          LpSendBuf = NULL;
DWORD           CbSendBuf = 0;

DWORD           CbDmMsg = 0;
LPDM_MSG        LpDmMsg = NULL;

LPDBF           lpdbf = (LPDBF)NULL;

LPFNSVC         lpfnsvcTL = (LPFNSVC)NULL;
XOSD (PASCAL LOADDS *CallTL) ( TLF, HPID, DWORD, LPVOID );
XOSD (PASCAL LOADDS *CallDB) ( DBC, HPID, HTID, DWORD, DWORD, LPVOID );
XOSD (PASCAL LOADDS *CallNT) ( EMF, HPID, HTID, DWORD, LPVOID );

HLLI            llprc = (HLLI)NULL;

HPRC            hprcCurr = 0;
HPID            hpidCurr = 0;
PID             pidCurr  = 0;
PCPU_POINTERS   pointersCurr = 0;
MPT             mptCurr;

HTHD            hthdCurr = 0;
HTID            htidCurr = 0;
TID             tidCurr  = 0;

HLLI            HllEo = (HLLI) NULL;



///BUGBUG
// need to either agree on one name for the target dm dll
// or to implement a protocol to get the name via TL
// currently MSVC assumed host==target

#define DEFAULT_DMNAME  _T("dm" DM_TAIL)
//#define       DEFAULT_DMNAME  _T("dmkdx86" DM_TAIL)


#define DEFAULT_DMPARAMS _T("")

LOADDMSTRUCT LoadDmStruct = {
    NULL, NULL
};



/********************* EXTERNAL/GLOBAL DATA ************************/

HINSTANCE hInstance = NULL;

/*********************** PROTOTYPES *******************************/



/************************** &&&&&& ********************************/

/*
 *  This is the description of all registers and flags for the
 *      machine being debugged.  These files are machine dependent.
 */





/*************************** CODE *****************************************/
LPTSTR
MHStrdup(
    LPTSTR lpstr
    )
{
    LPTSTR retstr = (LPTSTR) MHAlloc((_ftcslen(lpstr) + 1) * sizeof(TCHAR));
    assert(retstr);
    if (retstr) {
        _ftcscpy(retstr, lpstr);
    }
    return(retstr);
}

/**** DBGVersionCheck                                                   ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *                                                                         *
 *      To export out version information to the debugger.                 *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *      NONE.                                                              *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *      Returns - A pointer to the standard version information.           *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *      Just returns a pointer to a static structure.                      *
 *                                                                         *
 ***************************************************************************/

#ifdef DEBUGVER
DEBUG_VERSION('E','M',"Execution Model")
#else
RELEASE_VERSION('E','M',"Execution Model")
#endif

DBGVERSIONCHECK()

/**** SENDCOMMAND - Send a command to the DM                            ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *      Send a DMF command to the DM.                                      *
 *                                                                         *
 *  INPUTS:                                                                *
 *      dmf - the command to send                                          *
 *      hpid - the process                                                 *
 *      htid - the thread                                                  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      xosd - error code indicating if command was sent successfully      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *      Sending commands is asynchronous: this function may return before  *
 *      the DM has actually processed the command.                         *
 *                                                                         *
 ***************************************************************************/
XOSD
SendCommand (
    DMF dmf,
    HPID hpid,
    HTID htid
    )
{
    DBB dbb;

    dbb.dmf  = dmf;
    dbb.hpid = hpid;
    dbb.htid = htid;

    return CallTL ( tlfDebugPacket, hpid, FIELD_OFFSET ( DBB, rgbVar ), (LPV)&dbb );
}


/**** SENDREQUEST - Send a request to the DM                            ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *      Send a DMF request to the DM.                                      *
 *                                                                         *
 *  INPUTS:                                                                *
 *      dmf - the request to send                                          *
 *      hpid - the process                                                 *
 *      htid - the thread                                                  *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      xosd - error code indicating if request was sent successfully      *
 *      LpDmMsg - global buffer filled in with returned data               *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *      Unlike SendCommand, this function will wait for data to be         *
 *      returned from the DM before returning to the caller.               *
 *                                                                         *
 ***************************************************************************/
EMEXPORT XOSD
SendRequest (
    DMF dmf,
    HPID hpid,
    HTID htid
    )
{
    DBB     dbb;
    XOSD    xosd;

    dbb.dmf  = dmf;
    dbb.hpid = hpid;
    dbb.htid = htid;

    GuardTL();
    xosd = CallTL ( tlfRequest, hpid, FIELD_OFFSET ( DBB, rgbVar ), &dbb );

    if (xosd == xosdNone) {
        xosd = (XOSD) LpDmMsg->xosdRet;
    }

    ReleaseTL();
    return xosd;
}


/**** SENDREQUESTX - Send a request with parameters to the DM           ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *      Send a DMF request and its parameter info to the DM.               *
 *                                                                         *
 *  INPUTS:                                                                *
 *      dmf - the request to send                                          *
 *      hpid - the process                                                 *
 *      htid - the thread                                                  *
 *      wLen - number of bytes in lpv                                      *
 *      lpv - pointer to additional info needed by the DM; contents are    *
 *          dependent on the DMF                                           *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *      xosd - error code indicating if request was sent successfully      *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *      Unlike SendCommand, this function will wait for data to be         *
 *      returned from the DM before returning to the caller.               *
 *                                                                         *
 ***************************************************************************/
EMEXPORT XOSD
SendRequestX (
    DMF dmf,
    HPID hpid,
    HTID htid,
    DWORD wLen,
    LPVOID lpv
    )
{
    LPDBB   lpdbb;
    XOSD    xosd;

    if (wLen + FIELD_OFFSET(DBB, rgbVar) > CbSendBuf) {
        if (LpSendBuf) {
            MHFree(LpSendBuf);
        }
        CbSendBuf = FIELD_OFFSET(DBB, rgbVar) + wLen;
        LpSendBuf = (LPBYTE) MHAlloc(CbSendBuf);
    }

    if (!LpSendBuf) {
        return xosdOutOfMemory;
    }

    lpdbb = (LPDBB)LpSendBuf;

    lpdbb->dmf  = dmf;
    lpdbb->hpid = hpid;
    lpdbb->htid = htid;
    _fmemcpy ( lpdbb->rgbVar, lpv, wLen );

    GuardTL();
    xosd = CallTL ( tlfRequest, hpid, FIELD_OFFSET ( DBB, rgbVar ) + wLen, (LPVOID)lpdbb );

    if (xosd == xosdNone) {
        xosd = (XOSD) LpDmMsg->xosdRet;
    }

    ReleaseTL();
    return xosd;
}

// Helper function: repack dmfProgLoad/dmfSpawnOrphan arguments into the form:
//              DWORD dwChildFlags
//              TCHAR rgtchExe[]
//              TCHAR rgtchCmdLine[]
//              TCHAR rgtchDir[]
//
//      You probably want to free the lplpvPacket when you're done.
//
XOSD
RepackProgLoad (
        CONST LPPRL             lpprl,
        LPVOID                  *lplpvPacket,
        UINT                    *pcb
    )
{
    BYTE*   lpb;
    LPTSTR  lszRemoteDir = _T("");

    assert (lpprl);
    assert (lplpvPacket);
    assert (pcb);

    // lszRemoteDir is allowed to be NULL, in which case we pass ""
    if (lpprl -> lszRemoteDir != NULL) {
        lszRemoteDir = lpprl -> lszRemoteDir;
    }

    *pcb = sizeof(DWORD);
    *pcb += _ftcslen(lpprl -> lszRemoteExe) + 1;
    *pcb += _ftcslen(lpprl -> lszCmdLine) + 1;

    *pcb += _ftcslen(lszRemoteDir) + 1;
    *pcb += sizeof (SPAWNORPHAN);

#if defined(_UNICODE)
#pragma message("MHAlloc and *lplpvPacket+ctch need work")
#endif
    *lplpvPacket = MHAlloc(*pcb);
    lpb = (BYTE*) *lplpvPacket;

    if (!*lplpvPacket) {
        return xosdOutOfMemory;
    }

//  REVIEW:  SwapEndian ( &dwChildFlags, sizeof ( dwChildFlags ) );

    memcpy (lpb, &(lpprl -> dwChildFlags), sizeof (lpprl -> dwChildFlags));
    lpb += sizeof(DWORD);

    _ftcscpy((CHAR*) lpb, lpprl -> lszRemoteExe);
    lpb += _ftcslen (lpprl -> lszRemoteExe) + 1;

    _ftcscpy((CHAR*) lpb, lpprl -> lszCmdLine);
    lpb += _ftcslen (lpprl -> lszCmdLine) + 1;

    _ftcscpy((CHAR*) lpb, lszRemoteDir);
    lpb += _ftcslen (lszRemoteDir) + 1;

    if (lpprl -> lpso) {
        memcpy ((CHAR*) lpb, lpprl -> lpso, sizeof (SPAWNORPHAN));
    } else {
        *lpb = 0;
    }

    return xosdNone;
}
XOSD
SpawnOrphan (
    HPID  hpid,
    DWORD  cb,
    LPSOS lpsos
    )

/*++

Routine Description:

    This routine is called to cause a program to be loaded by the
    debug monitor, but not debugged.

Arguments:

    hpid  - Supplies the OSDEBUG handle to the process to be loaded
    cb    - Length of the command line
    lpsos - Pointer to structure containning the command line

Return Value:

    xosd error code

--*/

{
    LPVOID lpb;
    XOSD xosd;

    xosd = RepackProgLoad(lpsos, &lpb, (UINT*) &cb);
    if (xosd != xosdNone) {
        return (xosd);
    }

    assert (lpsos -> lpso);

    GuardTL();
    xosd = SendRequestX ( dmfSpawnOrphan,
                          hpid,
                          NULL,
                          cb,
                          lpb
                          );

    MHFree(lpb);

    memcpy (lpsos -> lpso, LpDmMsg->rgb, sizeof (SPAWNORPHAN));
    ReleaseTL();

    return xosd;
}                               /* SpawnOrphan() */




XOSD
ProgramLoad (
    HPID  hpid,
    DWORD  cb,
    LPPRL lpprl
    )

/*++

Routine Description:

    This routine is called to cause a program to be loaded by the
    debug monitor.

Arguments:

    hpid  - Supplies the OSDEBUG handle to the process to be loaded
    cb    - Length of the command line
    lpprl - Pointer to structure containning the command line

Return Value:

    xosd error code

--*/

{
    XOSD  xosd = xosdNone;
    LPPRC lpprc;
    HPRC  hprc = HprcFromHpid(hpid);
    LPVOID lpb;
    lpprc = (LPPRC) LLLock ( hprc );


	GetExceptionInfo ( hpid );
	
#if 0
    lpprc->efp  = efpNone;
#endif
    LLDestroy ( lpprc->llmdi );
    lpprc->llmdi = LLInit ( sizeof ( MDI ), llfNull, MDIKill, MDIComp );

    LLUnlock ( hprc );

    PurgeCache ();

    xosd = RepackProgLoad(lpprl, &lpb, (UINT*) &cb);
    if (xosd != xosdNone) {
        return (xosd);
    }
    assert (!lpprl->lpso);

    GuardTL();
    xosd = SendRequestX (
        dmfProgLoad,
        hpid,
        NULL,
        cb,
        lpb
    );

    MHFree(lpb);

    if (xosd == xosdNone) {
        xosd = LpDmMsg->xosdRet;
        lpprc = (LPPRC) LLLock ( hprc );
        lpprc->stat = statStarted;
        LLUnlock ( hprc );
    }
    ReleaseTL();

    return xosd;
}                               /* ProgramLoad() */


XOSD
DebugActive (
	HPID	hpid,
	DWORD	cb,
	LPVOID	lpv
	)
{
	XOSD	xosd;

	GetExceptionInfo ( hpid );
	
    GuardTL();
	xosd = SendRequestX ( dmfDebugActive, hpid, NULL, cb, lpv );

	if (xosd == xosdNone) {
		xosd = LpDmMsg->xosdRet;
	}
    ReleaseTL();

	return xosd;
}

		

/**** PROGRAMFREE - Terminate the program and free the pid              ****
 *                                                                         *
 *  PURPOSE:                                                               *
 *                                                                         *
 *  INPUTS:                                                                *
 *                                                                         *
 *  OUTPUTS:                                                               *
 *                                                                         *
 *  IMPLEMENTATION:                                                        *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

XOSD
ProgramFree (
    HPID hpid,
    HTID htid
    )
{
   // return SendCommand (dmfProgFree, hpid, NULL );

	return SendRequest (dmfProgFree, hpid, NULL);
}





XOSD
CompareAddrs(
    HPID hpid,
    HTID htid,
    LPCAS lpcas
    )
{
    ADDR a1 = *lpcas->lpaddr1;
    ADDR a2 = *lpcas->lpaddr2;
    XOSD xosd = xosdNone;
    LONG l;

    // if both are LI, see if they are comparable:
    if (ADDR_IS_LI(a1) && ADDR_IS_LI(a2)
          && emiAddr(a1) == emiAddr(a2)
          && GetAddrSeg(a1) == GetAddrSeg(a2))
    {
       if (GetAddrOff(a1) < GetAddrOff(a2)) {
           l = fCmpLT;
       } else if (GetAddrOff(a1) == GetAddrOff(a2)) {
           l = fCmpEQ;
       } else {
           l = fCmpGT;
       }
       *lpcas->lpResult = l;
    }

    else {

        // if neccessary, fixup addresses:
        if (ADDR_IS_LI(a1)) {
            FixupAddr(hpid, htid, &a1);
        }

        if (ADDR_IS_LI(a2)) {
            FixupAddr(hpid, htid, &a2);
        }


        // if real mode address, we can really compare
        if (ADDR_IS_REAL(a1) && ADDR_IS_REAL(a2)) {
            l =  ((GetAddrSeg(a1) << 4) + (GetAddrOff(a1) & 0xffff))
                - ((GetAddrSeg(a2) << 4) + (GetAddrOff(a2) & 0xffff));
            *lpcas->lpResult = (l < 0) ? -1 : ((l == 0) ? 0 : 1);
        }

        else if (ADDR_IS_FLAT(a1) != ADDR_IS_FLAT(a2)) {
            xosd = xosdInvalidParameter;
        }

        // if flat, ignore selectors
        else if (ADDR_IS_FLAT(a1)) {
            if (GetAddrOff(a1) < GetAddrOff(a2)) {
                l = fCmpLT;
            } else if (GetAddrOff(a1) == GetAddrOff(a2)) {
                l = fCmpEQ;
            } else {
                l = fCmpGT;
            }
            *lpcas->lpResult = l;
        }

        else if (GetAddrSeg(a1) == GetAddrSeg(a2)) {
            if (GetAddrOff(a1) < GetAddrOff(a2)) {
                l = fCmpLT;
            } else if (GetAddrOff(a1) == GetAddrOff(a2)) {
                l = fCmpEQ;
            } else {
                l = fCmpGT;
            }
            *lpcas->lpResult = l;
        }

        // not flat, different selectors
        else {
            xosd = xosdInvalidParameter;
        }

    }
    return xosd;
}



static BOOL fCacheDisabled = FALSE;

#define cbMaxCache CACHESIZE
typedef struct _MCI {
    WORD cb;
    HPID hpid;
    ADDR addr;
    BYTE rgb [ cbMaxCache ];
} MCI;  // Memory Cache Item

#define imciMax MAXCACHE
MCI FAR rgmci [ imciMax ] = {   { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 } };

// CACHESIZE *must* be a power of 2
#define	CACHE_ADDR_MASK	(~(CACHESIZE-1))

// Most recent used == 0, 2nd to last == 1, etc

int rgiUsage [ imciMax ] = {0};

void
InitUsage (
    void
    )
{
    int iUsage;

    for ( iUsage = 0; iUsage < imciMax; iUsage++ ) {
        rgiUsage [ iUsage ] = imciMax - ( iUsage + 1 );
    }
}

VOID
SetMostRecent (
    int imci
    )
{
    int i;

    if ( rgiUsage [ imci ] != 0 ) {
        for ( i = 0; i < imciMax; i++ ) {
            if ( rgiUsage [ i ] < rgiUsage [ imci ] ) {
                rgiUsage [ i ] ++;
            }
        }
        rgiUsage [ imci ] = 0;
    }
}

int
GetLeastRecent (
    VOID
    )
{
    int i;

    for ( i = 0; i < imciMax; i++ ) {
        assert ( rgiUsage [ i ] >= 0 && rgiUsage [ i ] < imciMax );
        if ( rgiUsage [ i ] == imciMax - 1 ) {
            return i;
        }
    }

    assert ( FALSE );

    return i;
}

VOID
SetLeastRecent (
    int imci
    )
{
    int i;

    if ( rgiUsage [ imci ] != imciMax - 1 ) {
        for ( i = 0; i < imciMax; i++ ) {
            if ( rgiUsage [ i ] > rgiUsage [ imci ] ) {
                rgiUsage [ i ] --;
            }
        }
        rgiUsage [ imci ] = imciMax-1;
    }
}


XOSD
ReadPhysical (
    HPID    hpid,
    DWORD   cb,
    LPBYTE  lpbDest,
    LPADDR  lpaddr,
    DWORD   iCache,
    LPDWORD lpcbr
    )
{
    LPDBB lpdbb;
    PRWP  prwp;
    XOSD  xosd = xosdNone;

    if (!ValidHprcFromHpid(hpid)) {
        return xosdBadProcess;
    }

    lpdbb = (LPDBB)MHAlloc(FIELD_OFFSET(DBB, rgbVar) + sizeof(RWP));
    prwp = (PRWP)lpdbb->rgbVar;

    lpdbb->dmf = dmfReadMem;
    lpdbb->hpid = hpid;
    lpdbb->htid = NULL;

    GuardTL();
    if ( cb + sizeof(DWORD) + FIELD_OFFSET(DM_MSG, rgb) > CbDmMsg ) {
        MHFree ( LpDmMsg );
        CbDmMsg = cb + sizeof ( DWORD ) + FIELD_OFFSET( DM_MSG, rgb );
        LpDmMsg = (LPDM_MSG) MHAlloc ( CbDmMsg );
        CallTL ( tlfSetBuffer, lpdbb->hpid, CbDmMsg, LpDmMsg );
    }

    prwp->cb   = cb;
    prwp->addr = *lpaddr;

    xosd = CallTL(tlfRequest, lpdbb->hpid, FIELD_OFFSET(DBB, rgbVar) + sizeof(RWP), lpdbb);

    if (xosd == xosdNone) {
        xosd = LpDmMsg->xosdRet;
        if (xosd == xosdNone) {
            *lpcbr = *( (LPDWORD) (LpDmMsg->rgb) );
            assert( *lpcbr <= cb );
            _fmemcpy ( lpbDest, LpDmMsg->rgb + sizeof ( DWORD ), *lpcbr );
        }
    }
    ReleaseTL();

    MHFree(lpdbb);

    return xosd;
}

XOSD
EnableCache (
    HPID  hpid,
    HTID  htid,
    BOOL  state
    )
{
    fCacheDisabled = state;

    if (fCacheDisabled) {
        PurgeCache();
    }

    return xosdNone;
}


void
PurgeCache (
    VOID
    )
{
    int imci;

    for ( imci = 0; imci < imciMax; imci++ ) {
        rgmci [ imci ].cb = 0;
    }
}

void
PurgeCacheHpid (
    HPID hpid
    )
{
    int imci;

    for ( imci = 0; imci < imciMax; imci++ ) {

        if ( rgmci [ imci ].hpid == hpid ) {
            rgmci [ imci ].cb = 0;
            SetLeastRecent ( imci );
        }
    }
}


XOSD
ReadForCache(
    HPID   hpid,
    DWORD  cbP,
    LPBYTE lpbDest,
    LPADDR lpaddr,
    LPDWORD lpcb
    )

/*++

Routine Description:

    This function will fill in a cache entry with the bytes requested
    to be read.  The function puts the bytes in both the cache and the
    memory buffer.

Arguments:

    hpid        - Supplies the process to do the read in

    cbP         - Supplies the number of bytes to be read

    lpbDest     - Supplies the buffer to place the bytes in

    lpaddr      - Supplies the address to read the bytes from

    lpcb        - Returns the number of bytes read

Return Value:

    XOSD error code

--*/

{
    assert(cbP <= cbMaxCache);
    DWORD       imci;
    DWORD       cbr;
    XOSD        xosd;
    ADDR        addrSave = *lpaddr;
    MCI *       pmci;
	const UOFFSET uAlignedOffset = GetAddrOff( *lpaddr ) & CACHE_ADDR_MASK;
	const DWORD dbOffset = GetAddrOff( addrSave ) - uAlignedOffset;

    /*
     *  Determine if the starting address is contained in a
     *  voided cache entry
     */

    for ( imci = 0, pmci = rgmci ; imci < imciMax; imci++, pmci++ ) {

        if ( (pmci->cb == 0) &&
             (pmci->hpid == hpid) &&
             (ADDR_IS_REAL( pmci->addr) == ADDR_IS_REAL( *lpaddr )) &&
             (GetAddrSeg ( pmci->addr ) == GetAddrSeg ( *lpaddr )) &&
             (uAlignedOffset == GetAddrOff ( pmci->addr ))
        ) {
            break;
        }
    }


    /*
     *  if we have not found a cache entry then just get one based on
     *  an LRU algorithm.
     */

    if ( imci == imciMax ) {
        imci = GetLeastRecent ( );
    }

    /*
     *  Do an actual read of memory from the debuggee
     */

	SetAddrOff( lpaddr, uAlignedOffset );

    xosd = ReadPhysical ( hpid, cbMaxCache, rgmci [ imci ].rgb, lpaddr, imci, &cbr );

    if ( xosd != xosdNone ) {
        return xosd;
    }

	assert(cbr==CACHESIZE);				// Win32 never gives us half-pages surely?

    /*
     *  touch the LRU table
     */

    SetMostRecent ( imci );

    /*
     *  set up the cache entry
     */

    assert(cbr <= cbMaxCache);
    rgmci [ imci ].cb = (WORD) cbr;
    rgmci [ imci ].addr = *lpaddr;
    rgmci [ imci ].hpid = hpid;

    *lpaddr = addrSave;

    /*
     *  compute the number of bytes read
     */

    DWORD cbT = min(cbMaxCache - dbOffset,cbP);

    /*
     *  copy from the cache entry to the users space
     */

    _fmemcpy ( lpbDest, rgmci [ imci ].rgb + dbOffset, cbT );

    /*
     *  return the number of bytes read
     */

    *lpcb = cbT;

    return xosdNone;
}                               /* ReadForCache() */


int
GetCacheIndex(
    HPID   hpid,
    LPADDR lpaddr
    )

/*++

Routine Description:

    This routine is given a process and an address and will locate
    which cache entry (if any) the address is in.

Arguments:

    hpid        - Supplies the handle to the process
    lpaddr      - Supplies the address to look for

Return Value:

    The index of the cache entry containing the address or imciMax if
    no cache entry contains the address

--*/

{
    int imci;

    for ( imci = 0; imci < imciMax; imci++ ) {
        LPADDR lpaddrT = &rgmci [ imci ].addr;

        /*
         *   To be in the cache entry check:
         *
         *      1.  The cache entry contains bytes
         *      2.  The cache entry is for the correct process
         *      3.  The cache entry if for the correct segment
         *      4.  The requested offset is between the starting and
         *              ending points of the cache
         */

        if ( (rgmci [ imci ].cb != 0) &&
             (rgmci [ imci ].hpid == hpid) &&
             (ADDR_IS_REAL( *lpaddrT ) == ADDR_IS_REAL( *lpaddr )) &&
             (GetAddrSeg ( *lpaddrT ) == GetAddrSeg ( *lpaddr )) &&
             (GetAddrOff ( *lpaddrT ) <= GetAddrOff ( *lpaddr )) &&
             (GetAddrOff ( *lpaddrT ) + rgmci[ imci ].cb > GetAddrOff ( *lpaddr ))) {

            break;
        }
    }

    return imci;
}                               /* GetCacheIndex() */


int
ReadFromCache (
    HPID hpid,
    DWORD cb,
    LPBYTE lpbDest,
    LPADDR lpaddr
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hpid        - Supplies a handle to the process
    cb          - Supplies the count of bytes to read from the cache
    lpbDest     - Suppiies the pointer to store bytes at
    lpaddr      - Supplies pointer to address to read at

Return Value:

    > 0         - The number of bytes read from the cache
    == 0        - No cache entry for the address was found

--*/

{
    int imci;

    /*
     *  See if the address for the start of the read is current contained
     *  in one of the cached buffers.
     */

    imci = GetCacheIndex ( hpid, lpaddr );

    /*
     *  If the starting address is in a cache entry then read as many
     *  bytes as is possible from that cache entry.
     */

    if ( imci != imciMax ) {
        DWORD ibStart;
        DWORD  cbT;

        /*
         *  Compute the difference between the address for the cache start
         *      and the address for the read request start and then
         *      the number of bytes which can be read in
         */

        ibStart = (DWORD)( GetAddrOff ( *lpaddr ) - GetAddrOff ( rgmci[imci].addr ) );
        cbT = min ( cb, rgmci [ imci ].cb - ibStart );

        /*
         *   Preform the copy
         */

        _fmemcpy ( lpbDest, rgmci [ imci ].rgb + ibStart, cbT );

        /*
         *   Return the number of bytes copied.  If it is less than
         *      zero then for some reason the current cache was not
         *      filled to capacity.
         */

        return cbT;
    }

    return 0;
}                               /* ReadFromCache() */


XOSD
ReadBuffer (
    HPID    hpid,
    HTID    htid,
    LPADDR  lpaddr,
    DWORD   cb,
    LPBYTE  lpbDest,
    LPDWORD lpcbRead
    )
/*++

Routine Description:

    This function is called in response to an emfReadBuf message.  The
    address to start the read at was set earlier and is stored in the
    adrCurrent Address Buffer.

Arguments:

    hpid        - Supplies the handle to the process to read memory for

    htid        - Supplies the handle to the thread to read memory for
                        (may be NULL)

    cb          - Supplies count of bytes to read

    lpbDest     - Supplies pointer to buffer to place bytes read

    lpcbRead    - Returns number of bytes read

Return Value:

    if >= 0 then it is the number of bytes actually read otherwise it
    is an xosdError code.

--*/

{
    XOSD        xosd = xosdNone;
    ADDR        addr;
    int         cbT = 0;
    int         cbRead = 0;
    HPRC        hprc = HprcFromHpid(hpid);
    LPPRC       lpprc;


    /*
     *  Retrieve the address to start the read at from the address buffer
     *  location
     */

    addr = *lpaddr;

        if (ADDR_IS_LI(addr)) {
                *lpcbRead = 0;
                return xosdBadAddress;      // can only do fixup addresses
        }

        /* If we are at the end of the memory address range and are trying to read
         * beyond the address range, just read till 0xFFFFFFFF
         */
        if ( cb != 0 && GetAddrOff(addr) + cb - 1 < GetAddrOff(addr))
        {
                assert(sizeof(GetAddrOff(addr)) == sizeof(DWORD));
                cb = 0xFFFFFFFF - GetAddrOff(addr) + 1;
        }

    /*
     *  Are we trying to read more bytes than is possible to store in
     *  a single cache?  If so then skip trying to hit the cache and
     *  go directly to asking the DM for the memory.
     *
     *  This generally is due to large memory dumps.
     */

    lpprc = (LPPRC) LLLock(hprc);
    if ( (cb > cbMaxCache) || (lpprc->fRunning ) || (fCacheDisabled) ) {
        LLUnlock(hprc);
        return ReadPhysical ( hpid, cb, lpbDest, &addr, MAXCACHE, lpcbRead );
    }
    LLUnlock(hprc);

    /*
     *  Read as much as possible from the set of cached memory reads.
     *  If cbT > 0 then bytes were read from a cache entry
     *  if cbT == 0 then no bytes were read in
     */

    while ((cb != 0) &&
           ( cbT = ReadFromCache ( hpid, cb, lpbDest, &addr ) ) > 0 ) {
        cbRead += cbT;
        lpbDest += cbT;
        GetAddrOff ( addr ) += cbT;
        cb -= cbT;
    }

    /*
     *  If there are still bytes left to be read then get the cache
     *  routines to read them in and copy both to a cache and to the
     *  buffer.
     */

    if ( cb > 0 ) {
        xosd = ReadForCache ( hpid, cb, lpbDest, &addr, (LPDWORD) &cbT );
        if (xosd == xosdNone) {
            cbRead += cbT;
			const DWORD nMore = cb - cbT;				// may straddle two aligned cache entries
			if (nMore)
			{
				// second block likely to already be in the cache so try that first
				ADDR addr2 = addr;
				SetAddrOff( &addr2, GetAddrOff( addr2 ) + cbT );
				DWORD cbCache = ReadFromCache( hpid, nMore, lpbDest+cbT, &addr2 );
				if (cbCache)
					cbRead += cbCache;
				else
				{
					xosd = ReadForCache( hpid, nMore, lpbDest+cbT, &addr2, (LPDWORD) &cbT );
					if (xosd==xosdNone)
						cbRead += cbT;
				}
			}
        }
    }

    if (lpcbRead) {
        *lpcbRead = cbRead;
    }

    return (cbRead!=0) ? xosdNone : xosd;
}                               /* ReadBuffer() */



XOSD
WriteBufferCache (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    DWORD cb,
    LPBYTE lpb,
    LPDWORD lpdwBytesWritten
    )
{
    PurgeCacheHpid ( hpid );
    return WriteBuffer ( hpid, htid, lpaddr, cb, lpb, lpdwBytesWritten );
}



XOSD
WriteBuffer (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    DWORD cb,
    LPBYTE lpb,
    LPDWORD lpdwBytesWritten
    )

/*++

Routine Description:

    This routine is used to send a request to the Debug Monitor to
    do a write to the debuggees memory.

Arguments:

    hpid        - Supplies the handle to the process to write memory in

    htid        - Supplies a thead handle

    lpaddr      - Supplies debuggee address to write at

    cb          - Supplies the number of bytes to be written

    lpb         - Supplies a pointer to the buffer to write

    lpdwBytesWritten - Returns number of bytes actually written

Return Value:

    an XOSD error code

--*/
{
    LPRWP lprwp = (LPRWP) MHAlloc( FIELD_OFFSET( RWP, rgb ) + cb );
    XOSD  xosd;

    lprwp->cb   = cb;
    lprwp->addr = *lpaddr;

    _fmemcpy ( lprwp->rgb, lpb, cb );

    GuardTL();
    xosd = SendRequestX (dmfWriteMem,
                         hpid,
                         htid,
                         FIELD_OFFSET ( RWP, rgb ) + cb,
                         lprwp
                         );

    MHFree ( lprwp );

    if (xosd == xosdNone) {
        *lpdwBytesWritten = *((LPDWORD)(LpDmMsg->rgb));
    } else {
        // REVIEW: what about partial writes. The DM will still send
        // the exact number of bytes written. Should we return that
        // back in lpdwBytesWritten
    }
    ReleaseTL();

    //
    //  Notify the shell that we changed memory. An error here is not
    //  tragic, so we ignore the return code.  The shell uses this
    //  notification to update all its memory breakpoints.
    //
    CallDB (
        dbcMemoryChanged,
        hpid,
        NULL,
        CEXM_MDL_native,
        cb,
        (LPVOID)lpaddr
        );

    return xosd;
}                               /* WriteBuffer() */



typedef struct _EMIC {
    HEMI hemi;
    HPID hpid;
    WORD sel;
} EMIC; // EMI cache item

#define cemicMax 4

EMIC rgemic [ cemicMax ] = {0};

XOSD
FindEmi (
    HPID   hpid,
    LPADDR lpaddr
    )
{
    XOSD        xosd = xosdNone;
    WORD        sel = (WORD)GetAddrSeg ( *lpaddr );
    HPRC        hprc = HprcFromHpid(hpid);
    HLLI        llmdi = LlmdiFromHprc ( hprc );
    BOOL        fFound = FALSE;
    ULONG       iobj = 0;
    HMDI        hmdi;
    LPPRC       lpprc = (LPPRC) LLLock( hprc );

    if ((lpprc->dmi.fAlwaysFlat) || (sel == lpprc->selFlatCs) || (sel == lpprc->selFlatDs)) {
        ADDR_IS_FLAT(*lpaddr) = TRUE;
		ADDR_IS_OFF32(*lpaddr) = TRUE;
    }
    LLUnlock( hprc );

    for ( hmdi = LLNext ( llmdi, hmdiNull );
          hmdi != hmdiNull;
          hmdi = LLNext ( llmdi, hmdi ) ) {

        LPMDI   lpmdi = (LPMDI) LLLock ( hmdi );
        OBJD *  rgobjd = &lpmdi->rgobjd[0];

        //  added && lpmdi->hemi to this conditional: the hemi can be null in
        //  the case that we recieved a dbcLoadModule, but did not end up
        //  loading the module  (a-math)

        for ( iobj = 0; iobj < lpmdi->cobj; iobj++ ) {
            if (((lpmdi->fFlatMode && ADDR_IS_FLAT(*lpaddr)) ||
                 (rgobjd[iobj].wSel == sel) && !ADDR_IS_FLAT(*lpaddr)) &&
                (rgobjd[iobj].offset <= GetAddrOff(*lpaddr)) &&
                (GetAddrOff(*lpaddr) < rgobjd[iobj].offset + rgobjd[iobj].cb) &&
                lpmdi->hemi) {

                fFound = TRUE;
                break;
            }
        }

        LLUnlock ( hmdi );

        // This break is here instead of in the "for" condition so
        //   that hmdi does not get advanced before we break

        if ( fFound ) {
            break;
        }
    }


    if ( !fFound ) {
        emiAddr ( *lpaddr ) = (HEMI) hpid;
    } else {
        emiAddr ( *lpaddr ) = (HEMI) HemiFromHmdi ( hmdi );

        if ( LLNext ( llmdi, hmdiNull ) != hmdi ) {

            // put the most recent hit at the head
            // this is an optimization to speed up the fixup/unfixup process
	     
	    // rajra: race condition here when multiple threads are in this routine       		
	    if (LLRemove ( llmdi, hmdi )) {
                LLAddHead ( llmdi, hmdi );
            }
        
	}
    }

    assert ( emiAddr ( *lpaddr ) != 0 );

    return xosd;
}

#pragma optimize ("", off)
XOSD
SetEmiFromCache (
    HPID   hpid,
    LPADDR lpaddr
    )
{
    XOSD xosd = xosdContinue;
#ifndef TARGET32
    int  iemic;

    for ( iemic = 0; iemic < cemicMax; iemic++ ) {

        if ( rgemic [ iemic ].hpid == hpid &&
             rgemic [ iemic ].sel  == GetAddrSeg ( *lpaddr ) ) {

            if ( iemic != 0 ) {
                EMIC emic = rgemic [ iemic ];
                int iemicT;

                for ( iemicT = iemic - 1; iemicT >= 0; iemicT-- ) {
                    rgemic [ iemicT + 1 ] = rgemic [ iemicT ];
                }
                rgemic [ 0 ] = emic;
            }

            xosd = xosdNone;
            emiAddr ( *lpaddr ) = rgemic [ 0 ].hemi;
            assert ( emiAddr ( *lpaddr ) != 0 );
            break;
        }
    }
#else
    Unreferenced( hpid );
    Unreferenced( lpaddr );
#endif // !TARGET32
    return xosd;
}
#pragma optimize ("", on)

XOSD
SetCacheFromEmi (
    HPID hpid,
    LPADDR lpaddr
    )
{
    int iemic;

    assert ( emiAddr ( *lpaddr ) != 0 );

    for ( iemic = cemicMax - 2; iemic >= 0; iemic-- ) {

        rgemic [ iemic + 1 ] = rgemic [ iemic ];
    }

    rgemic [ 0 ].hpid = hpid;
    rgemic [ 0 ].hemi = emiAddr ( *lpaddr );
    rgemic [ 0 ].sel  = (WORD)GetAddrSeg ( *lpaddr );

    return xosdNone;
}


/*** CleanCacheOfEmi
 *
 *  Purpose:
 *              To purge the emi cache
 *
 *  Notes:
 *              The emi cache must be purged whenever a RegisterEmi
 *              is done.  Unpredicable results can occur otherwise.
 *
 */
XOSD
CleanCacheOfEmi (
    void
    )
{
    int iemic;

    for ( iemic = 0; iemic < cemicMax; iemic++ ) {

        rgemic [ iemic ].hpid = NULL;
        rgemic [ iemic ].sel  = 0;
    }

    return xosdNone;
}



XOSD
SetEmi (
    HPID   hpid,
    LPADDR lpaddr
    )
{
    XOSD xosd = xosdNone;

    if ( emiAddr ( *lpaddr ) == 0 ) {

        //if (ADDR_IS_REAL(*lpaddr)) {
        //    emiAddr( *lpaddr ) = (HEMI) hpid;
        //    return xosd;
        //}

        if ( ( xosd = SetEmiFromCache ( hpid, lpaddr ) ) == xosdContinue ) {

            xosd = FindEmi ( hpid, lpaddr );
            if ( xosd == xosdNone ) {
                SetCacheFromEmi ( hpid, lpaddr );
            }
        }

        assert ( emiAddr ( *lpaddr ) != 0 );
    }

    return xosd;
}





/*
   Note: We are not guaranteed that the incoming address is actually
    on an instruction boundary.  When this happens, we derive the
    boundary and send back the difference in the return value and
    the address of the instruction previous to the DERIVED instruction
    in the address.

    Thus there are three classes of returns -

        ==0 - The incoming address was in fact on an instruction boundary
        > 0 - The case noted above
        < 0 - Error value - the most common "error" is that there is
                no previous instruction.

        When the return value >= 0, *lpaddr contains the address of the
            previous instruction.
*/


#define doffMax 60

static HPID hpidGPI = NULL;
static BYTE rgbGPI [ doffMax ];
static ADDR addrGPI;

XOSD
GPIBuildCache (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    )
{
    XOSD xosd   =  xosdBadAddress;
    int  fFound =  FALSE;
    ADDR addr   = *lpaddr;
    ADDR addrT;
    int  ib = 0;


    _fmemset ( rgbGPI, 0, doffMax );

    addrGPI = *lpaddr;
    hpidGPI = hpid;

    GetAddrOff ( addr ) -= (int) min ( (UOFFSET) doffMax, GetAddrOff ( *lpaddr ) );

    while ( !fFound && GetAddrOff ( addr ) < GetAddrOff ( *lpaddr ) ) {
        SDI  sdi;

        sdi.dop    = dopNone;
        sdi.addr   = addr;

        addrT = addr;

        Disasm ( hpid, htid, &sdi );

        addr = sdi.addr;

        rgbGPI [ ib ] = (BYTE) ( GetAddrOff ( addrGPI ) - GetAddrOff ( addr ) );

        if ( GetAddrOff ( addr ) == GetAddrOff ( *lpaddr ) ) {
            xosd   = xosdNone;
            *lpaddr= addrT;
            fFound = TRUE;
        }

        ib += 1;
    }

    // We haven't synced yet, so *lpaddr is probably pointing
    //  to something that isn't really synchronous

    if ( !fFound ) {
        xosd   = (XOSD) ( GetAddrOff ( *lpaddr ) - GetAddrOff ( addrT ) );
        GetAddrOff ( *lpaddr ) -= xosd;
        if ( GetAddrOff ( *lpaddr ) != 0 ) {
            (void) GetPrevInst ( hpid, htid, lpaddr );
        }
    }

    return xosd;
}


VOID
GPIShiftCache (
    LPADDR lpaddr,
    int *pib
    )
{
    int doff = (int) ( GetAddrOff ( addrGPI ) - GetAddrOff ( *lpaddr ) );
    int ib   = 0;

    *pib = 0;
    while ( ib < doffMax && rgbGPI [ ib ] != 0 ) {
        rgbGPI [ ib ] = (BYTE) max ( (int) rgbGPI [ ib ] - doff, 0 );

        if ( rgbGPI [ ib ] == 0 && *pib == 0 ) {
            *pib = ib;
        }

        ib += 1;
    }

    addrGPI = *lpaddr;
}

XOSD
GPIUseCache (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    )
{
    XOSD xosd   =  xosdBadAddress;
    int  fFound =  FALSE;
    ADDR addr   = *lpaddr;
    int  ib     =  0;
    int  ibCache=  0;
    int  ibMax  =  0;
    BYTE rgb [ doffMax ];


    GPIShiftCache ( lpaddr, &ibMax );

    _fmemset ( rgb, 0, doffMax );

    GetAddrOff ( addr ) -= (int) min ( (UOFFSET) doffMax, GetAddrOff ( *lpaddr ) );

    while ( !fFound && GetAddrOff ( addr ) < GetAddrOff ( *lpaddr ) ) {
        ADDR addrT;
        BYTE doff = (BYTE) ( GetAddrOff ( *lpaddr ) - GetAddrOff ( addr ) );

        // Attempt to align with the cache

        while ( doff < rgbGPI [ ibCache ] ) {
            ibCache += 1;
        }

        if ( doff == rgbGPI [ ibCache ] ) {

            // We have alignment with the cache

            addr  = *lpaddr;
            addrT = addr;
            GetAddrOff ( addrT ) -= rgbGPI [ ibMax - 1 ];
        }
        else {
            SDI  sdi;

            sdi.dop = dopNone;
            sdi.addr = addr;
            addrT = addr;

            Disasm ( hpid, htid, &sdi );


            addr = sdi.addr;

            rgb [ ib ] = (BYTE) ( GetAddrOff ( addrGPI ) - GetAddrOff ( addr ) );

            ib += 1;
        }

        if ( GetAddrOff ( addr ) == GetAddrOff ( *lpaddr ) ) {
            xosd   = xosdNone;
            *lpaddr= addrT;
            fFound = TRUE;
        }

    }

    // Rebuild the cache

    _fmemmove ( &rgbGPI [ ib - 1 ], &rgbGPI [ ibCache ], ibMax - ibCache );
    _fmemcpy  ( rgbGPI, rgb, ib - 1 );

    return xosd;
}

XOSD
GetPrevInst (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr
    )
{

    if ( GetAddrOff ( *lpaddr ) == 0 ) {

        return xosdBadAddress;
    }
    else if (
        hpid == hpidGPI &&
        GetAddrSeg ( *lpaddr ) == GetAddrSeg ( addrGPI ) &&
        GetAddrOff ( *lpaddr ) <  GetAddrOff ( addrGPI ) &&
        GetAddrOff ( *lpaddr ) >  GetAddrOff ( addrGPI ) - doffMax / 2
    ) {

        return GPIUseCache ( hpid, htid, lpaddr );
    }
    else {

        return GPIBuildCache ( hpid, htid, lpaddr );
    }
}


//
// Return xosdContinue if overlay is loaded
// Else return xosdNone
//
XOSD
FLoadedOverlay(
    HPID   hpid,
    LPADDR lpaddr
    )
{
    XOSD    xosd = xosdContinue;
    Unreferenced( hpid );
    Unreferenced( lpaddr );
    return xosd;
}



XOSD
SetupExecute(
    HPID       hpid,
    HTID       htid,
    LPHIND     lphind
    )
/*++

Routine Description:

    This function is used to set up a thread for doing function evaluation.
    The first thing it will do is to

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    HLLI                        hlli;
    HTHD                        hthd;
    HPRC                        hprc;
    LPTHD                       lpthd;
    LP_EXECUTE_OBJECT_EM        lpeo;
    XOSD                        xosd;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }
    hthd = HthdFromHtid(hprc, htid);
    if (!hthd || hthd == hthdInvalid) {
        return xosdBadThread;
    }

    /*
     *  If the list of execute objects has not yet been setup then it
     *  needs to be setup now.
     */

    if (HllEo == 0) {
        HllEo = LLInit(sizeof(EXECUTE_OBJECT_EM), llfNull, NULL, NULL);
    }

    /*
     *  Allocate an execute object for this working item.
     */

    if ((hlli = LLCreate( HllEo )) == 0) {
        return xosdOutOfMemory;
    }
    lpeo = (LP_EXECUTE_OBJECT_EM) LLLock( hlli );
    lpeo->regs = MHAlloc(SizeOfContext(hpid));

    /*
     *  Ask the DM to allocate a handle on its end for its low level
     *  execute object.
     */

    GuardTL();
    xosd = SendRequest(dmfSetupExecute, hpid, htid );

    if (xosd != xosdNone) {
        LLUnlock( hlli );
        LLDelete( HllEo, hlli );
        ReleaseTL();
        return xosd;
    }

    lpeo->heoDm = *(HIND *) LpDmMsg->rgb;
    ReleaseTL();

    /*
     *  Get the current register set for the thread on which we are going
     *  to do the exeucte.
     */

    lpthd = (LPTHD) LLLock( hthd );

    lpeo->hthd = hthd;

    if (!( lpthd->drt & drtAllPresent )) {
        UpdateRegisters( hprc, hthd );
    }

    _fmemcpy( lpeo->regs, lpthd->regs, SizeOfContext(hpid));

    LLUnlock( hthd );

    /*
     *  Unlock the execute object and return its handle
     */

    LLUnlock( hlli );

    *lphind =  (HIND)hlli;

    return xosdNone;
}                               /* SetupExecute() */



XOSD
StartExecute(
    HPID       hpid,
    HIND       hind,
    LPEXECUTE_STRUCT lpes
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    XOSD                        xosd;
    LP_EXECUTE_OBJECT_EM        lpeo;
    HTHD                        hthd;
    HTID                        htid;
    HPRC                        hprc;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }

    lpeo = (LP_EXECUTE_OBJECT_EM) LLLock( (HLLE)hind );
    hthd= lpeo->hthd;
    htid = HtidFromHthd(hthd),
    lpes->hindDm = lpeo->heoDm;
    FixupAddr(hpid, htid, &lpes->addr);
    LLUnlock( (HLLE)hind );

    /*
     *  Cause any changes to registers to be written back
     */

    UpdateChild(hpid, htid, dmfGo);

    /*
     *  Issue the command to the DM
     */

    xosd = SendRequestX(dmfStartExecute, hpid, htid,
                        sizeof(EXECUTE_STRUCT), lpes);


    return xosd;
}                               /* StartExecute() */



XOSD
CleanUpExecute(
    HPID hpid,
    HIND hind
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    LPTHD                       lpthd;
    LP_EXECUTE_OBJECT_EM        lpeo;

    lpeo = (LP_EXECUTE_OBJECT_EM) LLLock( (HLLE)hind );

    lpthd = (LPTHD) LLLock( lpeo->hthd );

    _fmemcpy( lpthd->regs, lpeo->regs, SizeOfContext(hpid));

    lpthd->drt = (DRT) (drtAllPresent | drtCntrlPresent | drtAllDirty | drtCntrlDirty);

    SendRequestX(dmfCleanUpExecute, hpid, HtidFromHthd(lpeo->hthd),
                 sizeof(HIND), &lpeo->heoDm);

    LLUnlock( (lpeo->hthd) );
    LLUnlock( (HLLE)hind );

    LLDelete( HllEo, (HLLE)hind );

    return xosdNone;

}                               /* CleanUpExecute() */


void
UpdateNLGStatus(
    HPID    hpid,
    HTID    htid
    )
{
    HPRC    hprc = HprcFromHpid (hpid);
    LPPRC   lpprc = (LPPRC)LLLock (hprc);
    HMDI    hmdi;
    XOSD    xosd = xosdNone;


    while ( hmdi = LLFind (lpprc->llmdi, NULL, NULL, emdiNLG )) {
        LPMDI   lpmdi = (LPMDI) LLLock ( hmdi );
        NLG     nlg = lpmdi->nlg;

        FixupAddr ( hpid, htid, &nlg.addrNLGDispatch );
        FixupAddr ( hpid, htid, &nlg.addrNLGDestination );
        FixupAddr ( hpid, htid, &nlg.addrNLGReturn );

        xosd = SendRequestX(dmfNonLocalGoto,
                            HpidFromHprc ( hprc ),
                            NULL,
                            sizeof ( nlg ),
                            &nlg
                            );

        lpmdi->fSendNLG = FALSE;
        LLUnlock ( hmdi );
    }

    LLUnlock (hprc);
}



XOSD FAR PASCAL
EMFunc (
    EMF  emf,
    HPID hpid,
    HTID htid,
    DWORD wValue,
    LONG lValue
    )

/*++

Routine Description:

    This is the main dispatch routine for processing of commands to the
    execution model.

Arguments:

    emf    - Supplies the function to be performed. (Execution Model Function )
    hpid   - Supplies The process to be used.
    htid   - Supplies The thread to be used.
    wValue - Supplies Info about the command
    lValue - Supplies Info about the command

Return Value:

    returns an XOSD error code

Other:

       Hpid and htid can never be invalid.  In some cases, they can be
       null.  The entries under P and T marked with an 0 indicate that
       the null value is valid for this function, an X indicates that
       it is invalid.

       Brief descriptions of the wValue and lValue


       EMF                 P   T   WVALUE          LVALUE

       emfGo               X   X   ----            ----
       emfShowDebuggee     X   0   ----            ----
       emfStop             X   0   ----            ----
       emfWriteBuf         X   0   #of bytes       pointer to buffer
       emfReadBuf          X   0   #of bytes       pointer to buffer
       emfSingleStep       X   X   ----            -----
       emfStepOver         X   X   ----            ----
       emfSetBreakPoint    X   X   ----            ----
       emfRemoveBreakPoint X   X   ----            ----
       emfSetWatchPoint    X   X   ----            ----
       emfRemoveWatchPoint X   X   ----            ----
       emfRangeStep,
       emfRangeOver,
       emfThreadStatus     X   X   ----            pointer to status buf.
       emfProcStatus       X   X   ----            pointer to status buf.
       emfFreeze           X   X   ----            ----
       emfThaw             X   X   ----            ----
       emfRegisterDBF      0   0   ----            pointer to dbf
       emfInit             0   0   ----            pointer to em serv.
       emfUnInit           0   0   ----            ----
       emfCreatePid        X   0   ----            ----
       emfDestroyPid       X   0   ----            ----
       emfDestroyTid       X   X   ----            ----
       emfDestroy          0   0   hem             ----
       emfIsValid          X   X   hem             ----
       emfSetAddr          X   X   ----            pointer to addr
       emfGetAddr          X   X   ----            pointer to addr
       emfRegValue         X   X   register index  pointer to buffer
       emfSetReg           X   X   register index  pointer to buffer
       emfSetFrameContext  X   X   frame
       emfFrameRegValue    X   X   register index  pointer to buffer
       emfFrameSetReg      X   X   register index  pointer to buffer
       emfSpawnOrphan      X   0
       emfProgramLoad      X   0   length          pntr to cmd line
       emfProgramFree      X   0   ----            ----
       emfDebugPacket      X   X   ----            pointer to buffer
       emfMetric           X   0   ----            pointer to metric
       emfUnassemble       X   X   ----            pointer to buffer
       emfAssemble         X   X   ----            pointer to buffer
       emfGetObjLength     X   X   ----            pointer to addr
       emfIOCTL            X   X   IOCTL type      pointer to data
       emfGetRegStruct     0   0   register index  pointer to buffer
       emfGetFlagStruct    0   0   flag index      pointer to buffer
       emfGetFlag          X   X   flag index      pointer to buffer
       emfSetFlag          X   X   flag index      pointer to data
       emfIsStackSetup     X   X   ----            pointer to addr
       emfCompareAddr      ?   ?   ----            pointerr to rglpaddr[2]
       emfSetupExecute     X   X   ----            pointer to handle
       emfStartExecute     X   -   Handle          pointer to execute_struct
       emfCleanUpExecute   X   0   Handle          -----
       emfLoadDllAck       X   0   ----            -----
       emfUnLoadDllAck     X   0   ----            pointer to MDI
       emfAttach           X   0   ----
       emfStackWalkSetup   X   X   PC In Prolog    pointer to stack walk data
       emfStackWalkNext    X   X   ----            pointer to stack walk data
       emfStackWalkCleanup X   X   ----            pointer to stack walk data
       emfDebugActive      X   0   ----            LPDBG_ACTIVE_STRUCT
       emfConnect          X   0   ----            ----
       emfDisconnect       X   0   ----            ----
       emfEnableCache      X   0   ----            ----
       emfGetMemInfo       X   0   sizeof MEMINFO  LPMEMINFO

--*/

{
    XOSD xosd = xosdNone;

    switch ( emf ) {

    default:
        assert ( FALSE );
        xosd = xosdUnknown;
        break;

    case emfShowDebuggee :

        xosd = SendRequestX ( dmfSelect, hpid, htid, sizeof ( BOOL ), &wValue );
        break;

    case emfStop:

        xosd = SendRequestX ( dmfStop, hpid, htid, sizeof(BOOL), &wValue );
        break;

    case emfRegisterDBF:

        InitUsage ( );
        lpdbf = (LPDBF) lValue;
        break;

    case emfInit:

        llprc = LLInit ( sizeof ( PRC ), llfNull, PiDKill, PDComp );

        CallDB = ( (LPEMCB) lValue)->lpfnCallBackDB;
        CallTL = ( (LPEMCB) lValue)->lpfnCallBackTL;
        CallNT = ( (LPEMCB) lValue)->lpfnCallBackNT;

        LpDmMsg = (LPDM_MSG) MHAlloc ( CBBUFFERDEF );
        CbDmMsg = CBBUFFERDEF;
        CallTL ( tlfSetBuffer, hpid, CBBUFFERDEF, LpDmMsg );

        break;

    case emfUnInit:

        /*
         * do any uninitialization for the EM itself
         */
        FreeEmErrorStrings ();

        CleanupDisassembler();
        MHFree(LpDmMsg);
        LpDmMsg = NULL;
        CbDmMsg = 0;
        break;

    case emfSetAddr:

        xosd = SetAddr( hpid, htid, (ADR) wValue, (LPADDR) lValue );
        break;

    case emfGetAddr:

        xosd = GetAddr( hpid, htid, (ADR) wValue, (LPADDR) lValue );
        break;

    case emfSpawnOrphan:

        xosd = SpawnOrphan ( hpid, wValue, (LPSOS) lValue);
        break;

    case emfProgramLoad:

        xosd = ProgramLoad ( hpid, wValue, (LPPRL) lValue );
        break;

    case emfProgramFree:

        xosd = ProgramFree ( hpid, htid );
        break;

    case emfFixupAddr:

        xosd = FixupAddr ( hpid, htid, (LPADDR) lValue );
        break;

    case emfUnFixupAddr:

        xosd = UnFixupAddr ( hpid, htid, (LPADDR) lValue );
        break;

    case emfSetEmi:

        xosd = SetEmi ( hpid, (LPADDR) lValue );
        break;

    case emfMetric:

        xosd = DebugMetric ( hpid, htid, wValue, (LPLONG) lValue );
        break;

    case emfDebugPacket:
    {
        LPRTP lprtp = (LPRTP) lValue;

        xosd = DebugPacket(
                     lprtp->dbc,
                     lprtp->hpid,
                     lprtp->htid,
                     lprtp->cb,
                     (lprtp->cb == 0 ) ? NULL : (LPBYTE) lprtp->rgbVar
                     );
        break;
    }

    case emfSetMulti:

        xosd  = SendRequest ( (DMF) (wValue ? dmfSetMulti : dmfClearMulti),
                                                                  hpid, htid );
        break;

    case emfDebugger:

        xosd = SendRequestX ( dmfDebugger, hpid, htid, wValue, (LPVOID) lValue );
        break;

    case emfRegisterEmi:

        RegisterEmi ( hpid, htid, (LPREMI) lValue );
        break;

    case emfGetModel:
        *(WORD FAR *)lValue = CEXM_MDL_native;
        break;

    case emfGetRegStruct:
        if (wValue >= CRgrd(hpid)) {
            xosd = xosdInvalidParameter;
        } else {
            //
            // v-vadimp - check if the register is present, and mark invisible if not
            //            
            HPRC hprc = ValidHprcFromHpid (hpid);
            LPPRC lpprc = (LPPRC) LLLock (hprc);
            DWORD dwProcessorFlags = lpprc->dmi.Processor.Flags;
            LLUnlock (hprc);
            RD rd = Rgrd(hpid)[wValue];
            if (((rd.rt & rtProcessorMask) == rtMMX) && !(dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX)) {
                rd.rt |= rtInvisible;
            } else if (((rd.rt & rtProcessorMask) == rtKatmai) && !(dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2)) {
                rd.rt |= rtInvisible;
            } else if (((rd.rt & rtProcessorMask) == rt3DNow) && !(dwProcessorFlags & PROCESSOR_FLAGS_I386_3DNOW)) {
                rd.rt |= rtInvisible;
            } else if (((rd.rt & rtProcessorMask) == rtWillamette) && !(dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3)) {
                rd.rt |= rtInvisible;
            }
            *((RD FAR *) lValue) = rd;

        }
        break;

    case emfGetFlagStruct:

        if (wValue >= CRgfd(hpid)) {
            xosd = xosdInvalidParameter;
        } else {
            *((FD FAR *) lValue) = Rgfd(hpid)[wValue].fd;
        }
        break;

    case emfGetFlag:
        xosd = GetFlagValue( hpid, htid, wValue, (LPVOID) lValue );
        break;

    case emfSetFlag:
        xosd = SetFlagValue( hpid, htid, wValue, (LPVOID) lValue );
        break;

    case emfSetupExecute:
        xosd = SetupExecute(hpid, htid, (LPHIND) lValue);
        break;

    case emfStartExecute:
        xosd = StartExecute(hpid, (HIND) wValue, (LPEXECUTE_STRUCT) lValue);
        break;

    case emfCleanUpExecute:
        xosd = CleanUpExecute(hpid, (HIND) wValue);
        break;

    case emfSetPath:
        xosd = SetPath (hpid, htid, wValue, (LPTSTR)lValue);
        break;

    case emfGo:
        xosd = Go(hpid, htid, (LPEXOP)lValue);
        break;

    case emfSingleStep:
        xosd = SingleStep ( hpid, htid, (LPEXOP)lValue );
        break;

    case emfRangeStep:
        xosd = RangeStep(hpid, htid, (LPRSS)lValue);
        break;

    case emfReturnStep:
        xosd = ReturnStep(hpid, htid, (LPEXOP)lValue);
        break;

    case emfWriteMemory:
    {
        LPRWMS lprwms = (LPRWMS)lValue;
        xosd = WriteBufferCache ( hpid, htid, lprwms->lpaddr, lprwms->cbBuffer,
                                               (LPBYTE) lprwms->lpbBuffer, lprwms->lpcb);
        break;
    }

    case emfReadMemory:
    {
        LPRWMS lprwms = (LPRWMS)lValue;
        xosd = ReadBuffer ( hpid, htid, lprwms->lpaddr, lprwms->cbBuffer,
                                               (LPBYTE) lprwms->lpbBuffer, lprwms->lpcb);
        break;
    }

    case emfGetMemoryInfo:
        xosd = GetMemoryInfo(hpid, htid, (LPMEMINFO)lValue);
        break;

    case emfBreakPoint:
        xosd = HandleBreakpoints( hpid, wValue, lValue );
        break;

    case emfProcessStatus:
        xosd = ProcessStatus(hpid, (LPPST)lValue);
        break;

    case emfThreadStatus:
        xosd = ThreadStatus(hpid, htid, (LPTST)lValue);
        break;

    case emfGetExceptionState:
        xosd = GetExceptionState(hpid, htid, (EXCEPTION_CONTROL) wValue,
                                              (LPEXCEPTION_DESCRIPTION) lValue);
        break;

    case emfSetExceptionState:
        xosd = SetExceptionState(hpid, htid, (LPEXCEPTION_DESCRIPTION)lValue);
        break;

    case emfFreezeThread:
        xosd = FreezeThread(hpid, htid, wValue);
        break;

    case emfCreateHpid:
        xosd = CreateHprc ( hpid );

        if ( xosd == xosdNone ) {
            xosd = SendRequest ( dmfCreatePid, hpid, NULL );
            //
            //  We're allowed to have an HPID with no TL, so special-case
            //  the xosdInvalidParameter return code, which is returned
            //  by CallTL if there is no TL.
            //
            if ( xosd == xosdInvalidParameter ) {
                xosd = xosdNone;
            }
        }

        break;

    case emfDestroyHpid:
        {
            HPRC hprc = HprcFromHpid(hpid);
            xosd = SendRequest ( dmfDestroyPid, hpid, NULL );
            if ( xosd == xosdLineNotConnected || xosd == xosdInvalidParameter ) {
                //
                //  xosdLineNotConnected:  Communication line broke, we'll
                //      ignore this error.
                //
                //  xosdInvalidParameter:  We're allowed to have an HPID with
                //      no TL, so special case this return code, which is
                //      returned by CallTL if there is no TL.
                //
                xosd = xosdNone;
            }
            DestroyHprc ( hprc );
        }
        break;

    case emfDestroyHtid:
        {
            HPRC hprc = HprcFromHpid(hpid);
            DestroyHthd( HthdFromHtid( hprc, htid ));
        }
        break;

    case emfUnassemble:
        Disasm ( hpid, htid, (LPSDI) lValue );
        break;

    case emfAssemble:
        xosd = Assemble ( hpid, htid, (LPADDR) wValue, (LPTSTR) lValue );
        break;

    case emfGetReg:
        xosd = GetRegValue( hpid, htid, wValue, (LPVOID) lValue );
        break;

    case emfSetReg:
        xosd = SetRegValue( hpid, htid, wValue, (LPVOID) lValue );
        break;

    case emfDebugActive:
		xosd = DebugActive( hpid, wValue, (LPVOID) lValue );
        break;

    case emfGetMessageMap:
        *((LPMESSAGEMAP *)lValue) = &MessageMap;
        break;

    case emfGetMessageMaskMap:
        *((LPMASKMAP *)lValue) = &MaskMap;
        break;

    case emfGetModuleList:
        xosd = GetModuleList( hpid, htid, (LPTSTR)wValue,
                                                 (LPMODULE_LIST FAR *)lValue );
        break;

    case emfCompareAddrs:
        xosd = CompareAddrs( hpid, htid, (LPCAS) lValue );
        break;

    case emfSetDebugMode:
#pragma message("Do something intelligent with emfSetDebugMode")
        xosd = xosdNone;
        break;

    case emfUnRegisterEmi:
        xosd = UnLoadFixups (hpid, (HEMI)lValue);
        break;

    case emfGetFrame:
        xosd = GetFrame(hpid, htid, wValue, lValue);
        break;

    case emfGetObjLength:
        xosd = GetObjLength(hpid, (LPGOL)lValue);
        break;

    case emfGetFunctionInfo:
        xosd = GetFunctionInfo(hpid, (LPGFI)lValue);
        break;

    case emfGetPrevInst:
        xosd = BackDisasm(hpid, htid, (LPGPIS)lValue );
        break;

    case emfConnect:
        if (!LoadDmStruct.lpDmName) {
            LoadDmStruct.lpDmName = MHStrdup(DEFAULT_DMNAME);
        }
        if (!LoadDmStruct.lpDmParams) {
            LoadDmStruct.lpDmParams = MHStrdup(DEFAULT_DMPARAMS);
        }
        xosd = CallTL( tlfLoadDM, hpid, sizeof(LOADDMSTRUCT), &LoadDmStruct);
        if (xosd == xosdNone) {
            xosd = SendRequest( dmfInit, hpid, htid );
        }
        break;

    case emfDisconnect:
        xosd = SendRequest( dmfUnInit, hpid, htid );
        break;

    case emfInfoReply:
        CallTL ( tlfReply, hpid, wValue, (LPVOID)lValue );
        xosd = xosdNone;
        break;

    case emfContinue:
        UpdateNLGStatus (hpid, htid);
        xosd = DoContinue( hpid );
        break;

    case emfSystemService:
        xosd = SystemService( hpid, htid, wValue, (LPSSS)lValue );
        break;

    case emfGetTimeStamp:
        xosd = GetTimeStamp (hpid, htid, (LPTCS) lValue);
        break;

	case emfCreateUserCrashDump:
		xosd = EMCreateUserCrashDump (hpid, htid, (LPTSTR) lValue);
		break;

    case emfSetup:

        {
            LPEMSS lpemss = (LPEMSS)lValue;

            // DWORD fLoad;
            // DWORD fInteractive;
            // DWORD fSave;
            // LPVOID lpvPrivate;
            // LPARAM lParam;
            // LPGETSETPROFILEPROC lpfnGetSet;
            //
            // typedef LONG (OSDAPI * LPGETSETPROFILEPROC)(
            //     LPSTR lpName,
            //     LPSTR lpValue,
            //     LPARAM lParam,
            //     DWORD fSet
            //     );

#if 0
            if (lpemss->fLoad) {
                lpemss->lpfnGetSet("DmName", String, lpemss->lParam, FALSE);
                if (LoadDmStruct.lpDmName) {
                    MHFree(LoadDmStruct.lpDmName);
                }
                LoadDmStruct.lpDmName = MHStrdup(String);

                lpemss->lpfnGetSet("DmParams", String, lpemss->lParam, FALSE);
                if (LoadDmStruct.lpDmParams) {
                    MHFree(LoadDmStruct.lpDmParams);
                }
                LoadDmStruct.lpDmParams = MHStrdup(String);
            }

            if (lpemss->fInteractive) {
            }

            if (lpemss->fSave) {
                lpemss->lpfnGetSet("DmName", LoadDmStruct.lpDmName, lpemss->lParam, FALSE);
                lpemss->lpfnGetSet("DmParams", LoadDmStruct.lpDmParams, lpemss->lParam, FALSE);
            }
#endif


            //
            // BUGBUG kentf this is a hackomatic version of emfSetup:
            //
            if (LoadDmStruct.lpDmName) {
                MHFree(LoadDmStruct.lpDmName);
                LoadDmStruct.lpDmName = 0;
            }
            if (LoadDmStruct.lpDmParams) {
                MHFree(LoadDmStruct.lpDmParams);
                LoadDmStruct.lpDmParams = 0;
            }

            if (lpemss->lpvPrivate) {
                LPTSTR p = (LPTSTR) lpemss->lpvPrivate;
                while (_istspace(*p)) {
                    p = _tcsinc(p);
                }
                if (_ftcsnicmp(p, _T("DM="), 3) == 0 || _ftcsnicmp(p, _T("DM:"), 3) == 0) {
                    LoadDmStruct.lpDmName = MHStrdup(_ftcstok(p+3, _T(" \t")));
                    p = p + 3 + _ftcslen(LoadDmStruct.lpDmName) + 1;
                    while (_istspace(*p)) {
                        p = _tcsinc(p);
                    }
                }
                LoadDmStruct.lpDmParams = MHStrdup(p);
            }
        }
        break;

    }

    return xosd;
}                               /* EMFunc() */


/*
**
*/

int
WINAPI
DllMain(
    HINSTANCE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    Unreferenced(dwReserved);

    switch (dwReason) {

      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
        break;

      case DLL_PROCESS_DETACH:

        if (LpSendBuf) {
            MHFree(LpSendBuf);
            CbSendBuf = 0;
        }
        if (LpDmMsg) {
            MHFree(LpDmMsg);
            CbDmMsg = 0;
        }

        if (LoadDmStruct.lpDmName) {
            MHFree(LoadDmStruct.lpDmName);
            LoadDmStruct.lpDmName = 0;
        }
        if (LoadDmStruct.lpDmParams) {
            MHFree(LoadDmStruct.lpDmParams);
            LoadDmStruct.lpDmParams = 0;
        }

        CleanupDisassembler();

        DeleteCriticalSection(&csCache);
        DeleteCriticalSection(&csInTL);
        break;

      case DLL_PROCESS_ATTACH:

        InitializeCriticalSection(&csCache);
        InitializeCriticalSection(&csInTL);
                DisableThreadLibraryCalls(hModule);
        break;
    }

	hInstance = hModule;
    
	return TRUE;
}



XOSD
DebugPacket (
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD wValue,
    LPBYTE lpb
    )
{
    XOSD        xosd = xosdContinue;
    HPRC        hprc = HprcFromHpid ( hpid );
    HTHD        hthd = HthdFromHtid ( hprc, htid );
    LONG        emdi;
    LPTHD       lpthd;
    LPPRC       lpprc = (LPPRC) LLLock(hprc);
    HTHD        hthdNext;

    for ( hthdNext = LLNext ( lpprc->llthd, hthdNull );
          hthdNext != hthdNull;
          hthdNext = LLNext ( lpprc->llthd, hthdNext ) ) {
        lpthd = (LPTHD) LLLock(hthdNext);
        lpthd->drt = drtNonePresent;
        LLUnlock(hthdNext);
    }

    LLUnlock(hprc);

    /* Do any preprocessing on the packet before sending the notification
     * on to the debugger.  For example, the wValue and lValue might need
     * some munging.  Also, if the notification shouldn't be passed on to
     * the debugger, then set xosd = xosdNone or some other value other
     * than xosdContinue.
     */

    switch ( dbc ) {
    case dbceAssignPID:
        {
            LPPRC lpprc = (LPPRC) LLLock ( hprc );

            assert ( wValue == sizeof ( PID ) );
            lpprc->pid = *( (PID FAR *) lpb );
            lpprc->stat = statStarted;
            LLUnlock ( hprc );
        }
        xosd = xosdNone;
        break;

    case dbcCreateThread:
        lpprc = (LPPRC) LLLock(hprc);
        lpprc->fRunning = FALSE;
        LLUnlock(hprc);

//		GetExceptionInfo (hpid);
        assert ( wValue == sizeof ( TCR ) );
        xosd = CreateThreadStruct ( hpid, *( (TID FAR *) lpb ), &htid );
        if ( ((LPTCR) lpb)->uoffTEB != 0 ) {
            HTHD  hthdT = HthdFromHtid ( hprc, htid );
            LPTHD lpthd = (LPTHD) LLLock ( hthdT );

            lpthd->uoffTEB = ((LPTCR) lpb)->uoffTEB;
            LLUnlock ( hthdT );
        }

        CallTL ( tlfReply, hpid, sizeof ( HTID ), (LPVOID)&htid );
        if ( xosd == xosdNone ) {
            xosd = xosdContinue;
        }
        break;

    case dbcNewProc:
        {
            HPRC  hprcT;
            HPID  hpidT;
            LPPRC lpprc;
            LPNPP lpnpp;

            /*
             * lpb points to an NPP (New Process Packet).  The PID is
             * the PID of the debuggee; fReallyNew indicates if this is
             * really a new process or if it already existed but hasn't
             * been seen before by OSDebug.
             */

            assert ( wValue == sizeof(NPP) );
            lpnpp = (LPNPP) lpb;

            // See EMCallBackDB in od.c

            CallDB ( dbcoNewProc, hpid, htid, CEXM_MDL_native,
                    sizeof ( HPID ), (LPVOID)&hpidT );

            (void) CreateHprc ( hpidT );

            hprcT       = HprcFromHpid ( hpidT );
            lpprc       = (LPPRC) LLLock ( hprcT );
            lpprc->pid  = lpnpp->pid;
            lpprc->stat = statStarted;
            LLUnlock ( hprcT );

            CallTL ( tlfReply, hpid, sizeof ( HPID ), (LPVOID)&hpidT );

            GetExceptionInfo( hpidT );

            wValue = (UINT)hpidT;
            lpb = (LPBYTE) (LONG) lpnpp->fReallyNew;
            if ( xosd == xosdNone ) {
                xosd = xosdContinue;
            }
        }
        break;


    case dbcThreadTerm:
        lpprc = (LPPRC) LLLock(hprc);
        lpprc->fRunning = FALSE;
        LLUnlock(hprc);
        lpthd = (LPTHD) LLLock(hthd);
        lpthd->fRunning = FALSE;
        LLUnlock(hthd);

    case dbcProcTerm:

        /*
         * For both of these notifications, the incoming wValue is
         * sizeof(ULONG), and lpb contains a ULONG which is the exit
         * code of the process or thread.  For the debugger, set
         * wValue = 0 and lValue = exit code.
         */

        assert ( wValue == sizeof(ULONG) );
        wValue = 0;
        lpb = (LPBYTE) (*(ULONG*)lpb);
        break;

    case dbcDeleteThread:

        lpthd = (LPTHD) LLLock(hthd);
        lpthd->tid    = (TID)-1;
        LLUnlock(hthd);

        assert ( wValue == sizeof(ULONG) );
        wValue = 0;
        lpb = (LPBYTE) (*(ULONG*)lpb);
        break;

    case dbcModLoad:
        lpprc = (LPPRC) LLLock(hprc);
        lpprc->fRunning = FALSE;
        LLUnlock(hprc);
        xosd = LoadFixups ( hpid, (LPMODULELOAD) lpb );
        break;

    case dbcModFree:            /* Should use dbceModFree*               */
        assert(FALSE);
        break;

    case dbceModFree32:
        emdi = emdiBaseAddr;
    modFree:
        {
            HMDI    hmdi;
            LPMDI   lpmdi;
            HLLI    llmdi;

            llmdi = LlmdiFromHprc ( hprc );
            assert( llmdi );

            hmdi = LLFind( llmdi, 0, lpb, emdi);

            ((LPPRC)LLLock(hprc))->fUnloadingModule = 1;
            LLUnlock(hprc);

            // If two dlls with the same name are loaded in the debuggee, this will
            // happen when we get the modFree for the second instance. The correct
            // fix for this is to make SHGetHexeFromName to not just depend on the basename
            // to decide the EMI. 

            if ( hmdi == NULL ) {
                UpdateNLGStatus(hpid, htid);
                xosd = DoContinue( hpid );
                return xosd;
            }
			
            lpmdi = (LPMDI) LLLock( hmdi );
            lpb = (LPBYTE) lpmdi->hemi;
            LLUnlock( hmdi );

            dbc = dbcModFree;
        }
        break;

    case dbceModFree16:
        emdi = emdiMTE;
        goto modFree;
        break;

    case dbcExecuteDone:
        lpprc = (LPPRC) LLLock(hprc);
        lpprc->fRunning = FALSE;
        LLUnlock(hprc);
        lpthd = (LPTHD) LLLock(hthd);
        lpthd->fRunning = FALSE;
        LLUnlock(hthd);
        break;

    case dbcStep:

    case dbcThreadBlocked:
    case dbcSignal:
    case dbcAsyncStop:
    case dbcBpt:
    case dbcEntryPoint:
    case dbcLoadComplete:
    case dbcCheckBpt:
        {
            LPBPR lpbpr = (LPBPR) lpb;
            LPTHD lpthd = (LPTHD) LLLock ( hthd );

            assert ( wValue == sizeof ( BPR ) );

            PurgeCache ( );
            lpprc = (LPPRC) LLLock(hprc);
            if (dbc != dbcCheckBpt) {
                lpprc->fRunning = FALSE;
                lpthd->fRunning = FALSE;
            }
            LLUnlock(hprc);

            CopyFrameRegs(hpid, lpthd, lpbpr);

            lpthd->fFlat         = lpbpr->fFlat;
            lpthd->fOff32        = lpbpr->fOff32;
            lpthd->fReal         = lpbpr->fReal;

            lpthd->drt = drtCntrlPresent;

            LLUnlock( hthd );

            wValue = lpbpr->dwNotify;
            lpb = NULL;
        }
        break;

    case dbcException:
        {
            LPEPR lpepr = (LPEPR) lpb;
            LPTHD lpthd = (LPTHD) LLLock ( hthd );

#if 0
            /*
              * This would be true if we did not pass parameters up
              */
            assert ( wValue == sizeof ( EPR ) );
#endif

            PurgeCache ( );
            lpprc = (LPPRC) LLLock(hprc);
            lpprc->fRunning = FALSE;
            LLUnlock(hprc);
            lpthd->fRunning = FALSE;


            CopyFrameRegs(hpid, lpthd, &lpepr->bpr);

            lpthd->fFlat        = lpepr->bpr.fFlat;
            lpthd->fOff32       = lpepr->bpr.fOff32;
            lpthd->fReal        = lpepr->bpr.fReal;

            lpthd->drt = drtCntrlPresent;

            LLUnlock( hthd );
        }
        break;

#if 0

    // BUGBUG kentf review this... do we need to support it?
    //              if so, it should turn into a dbcInfoAvail and
    //              a breakpoint or something.
    case dbcNtRip:
        {
            LPNT_RIP lprip   = (LPNT_RIP) lpb;
            LPTHD    lpthd   = LLLock ( hthd );
            ADDR     addr    = {0};

            assert ( wValue == sizeof ( NT_RIP ) );

            PurgeCache ( );
            lpprc = LLLock(hprc);
            lpprc->fRunning = FALSE;
            LLUnlock(hprc);
            lpthd->fRunning = FALSE;


            CopyFrameRegs(hpid, lpthd, lpbpr);

            lpthd->fFlat      = lprip->bpr.fFlat;
            lpthd->fOff32     = lprip->bpr.fOff32;
            lpthd->fReal      = lprip->bpr.fReal;

            lpthd->drt = drtCntrlPresent;

            LLUnlock (hthd );
        }
        break;
#endif

    case dbceCheckBpt:
        assert(FALSE);
        xosd = xosdNone;
        break;


    case dbcError:
        {
            static TCHAR sz[500];
            XOSD    xosdErr = *( (XOSD *)lpb );
            LPTSTR  str = (LPTSTR) (lpb + sizeof(XOSD));

            if (str[0]) {
                lpb = (LPBYTE) str;
            } else {
				LPCSTR lpszError = EmError (xosdErr);
				if (!lpszError) {
					assert (FALSE);
					lpszError = _T("Load failed for this error string.");
				}
                _stprintf(sz, _T("DM%04d: %s"), xosdErr, lpszError);
                lpb = (LPBYTE) sz;
            }
            wValue = xosdErr;
        }
        break;

    case dbceSegLoad:
        {
            SLI     sli;
            HMDI    hmdi;
            LPMDI   lpmdi;
            UINT    i;

            sli = *( (LPSLI) lpb );

            hmdi = LLFind( LlmdiFromHprc( hprc ), 0, &sli.mte,
                          (LONG) emdiMTE);

            assert( hmdi );

            lpmdi = (LPMDI) LLLock(hmdi );

            if (sli.wSegNo >= lpmdi->cobj) {
                i = lpmdi->cobj;
                lpmdi->cobj = sli.wSegNo+1;
                lpmdi->rgobjd = (OBJD *) MHRealloc(lpmdi->rgobjd,
                                        sizeof(OBJD)*lpmdi->cobj);
                memset(&lpmdi->rgobjd[i], 0, sizeof(OBJD)*(lpmdi->cobj - i));
            }
            lpmdi->rgobjd[ sli.wSegNo ].wSel = sli.wSelector;
            lpmdi->rgobjd[ sli.wSegNo ].wPad = 1;
            lpmdi->rgobjd[ sli.wSegNo ].cb = (DWORD) -1;

            LLUnlock( hmdi );

            //
            //  Let the shell know that a new segment was loaded, so it
            //  can try to instantiate virtual BPs.
            //
            xosd=CallDB( dbcSegLoad, hpid, htid, CEXM_MDL_native, 0,
                                                       (LPVOID)sli.wSelector );
            xosd=xosdNone;

        }
        break;

    case dbceSegMove:
        {
            SLI     sli;
            HMDI    hmdi;
            LPMDI   lpmdi;

            sli = *( (LPSLI) lpb );

            hmdi = LLFind( LlmdiFromHprc( hprc ), 0, &sli.mte,
                          (LONG) emdiMTE);

            assert( hmdi );

            lpmdi = (LPMDI) LLLock(hmdi );

            assert(sli.wSegNo > 0 );
            if (sli.wSegNo < lpmdi->cobj) {
                lpmdi->rgobjd[ sli.wSegNo - 1 ].wSel = sli.wSelector;
            }

            LLUnlock( hmdi );
        }
        break;

    case dbcCanStep:
        {
            CANSTEP CanStep;
            ADDR origAddr;

            assert ( wValue == sizeof ( ADDR ) );

            UnFixupAddr( hpid, htid, (LPADDR) lpb);
            origAddr = *(LPADDR)lpb;

            xosd=CallDB(dbc,hpid,htid,CEXM_MDL_native,0,(LPVOID)lpb);

            if ( xosd != xosdNone ) {
                CanStep.Flags = CANSTEP_NO;
            } else {
                CanStep = *((CANSTEP*)lpb);
                if (CanStep.Flags == CANSTEP_YES) {
                    AdjustForProlog(hpid, htid, &origAddr, &CanStep);
                }
            }

            CallTL ( tlfReply, hpid, sizeof( CanStep ), &CanStep );

            xosd = xosdNone;
        }
        break;

    case dbceGetOffsetFromSymbol:
        {
            ADDR addr = {0};
            if (SHGetPublicAddr ( &addr, (LSZ) lpb) && GetAddrOff(addr)) {
                FixupAddr(hpid, htid, &addr);
            }
            CallTL( tlfReply, hpid, sizeof(addr.addr.off), (LPVOID)&addr.addr.off );
            xosd = xosdNone;
        }
        break;

    case dbceGetSymbolFromOffset:
        {
            LPTSTR p;
#if defined(UNICODE) || defined(_UNICODE)
#pragma message("SHAddrToPublicName needs UNICODE api")
#endif
#ifdef NT_BUILD_ONLY
            ADDR addr;
            LPTSTR fname = (LPTSTR) SHAddrToPublicName( (LPADDR)lpb, &addr );
#else
            LPTSTR fname = (LPTSTR) SHAddrToPublicName( (LPADDR)lpb );
#endif
            HTID vhtid;

            GetFrame( hpid, htid, 1, (DWORD)&vhtid );
            lpthd = (LPTHD) LLLock(hthd);
            if (fname) {
                p = (LPTSTR) MHAlloc( (_ftcslen(fname) + 16) * sizeof(TCHAR) );
                _ftcscpy(p,fname);
                MHFree(fname);
            } else {
                p = (LPTSTR) MHAlloc( 32 );
                _stprintf( p, _T("<unknown>0x%08x"), GetAddrOff(*(LPADDR)lpb) );
            }
            fname = p;
            p += _ftcslen(p) + 1;
            *(UNALIGNED LPDWORD)p = lpthd->StackFrame.AddrReturn.Offset;
            LLUnlock(hthd);
            CallTL( tlfReply, hpid, (_ftcslen(fname)+1)*sizeof(TCHAR)+sizeof(DWORD), (LPVOID)fname );
            MHFree( fname );
            xosd = xosdNone;
        }
        break;

    case dbceEnableCache:
        EnableCache( hpid, htid, *(LPDWORD)lpb );
        CallTL( tlfReply, hpid, 0, NULL );
        xosd = xosdNone;
        break;

    case dbceGetMessageMask:
        {
            DWORD dwMsgMask = GetMessageMask( *(LPDWORD)lpb );
            CallTL( tlfReply, hpid, sizeof(DWORD), &dwMsgMask);
            xosd = xosdNone;
        }
        break;

	case dbceGetFrameWithSrc:
		{
			HTID	hvtid;
			ADDR	addr = {0};
			
			xosd = GetFrameWithSrc (hpid,
									htid,
									*((UINT*)lpb),
									&hvtid
									);

			if (xosd == xosdNone) {
				xosd = GetAddr (hpid, hvtid, adrPC, &addr);

				if (xosd == xosdNone) {
					xosd = FixupAddr (hpid, htid, &addr);
				}
			}
					
			if (xosd != xosdNone) {
				memset (&addr, 0, sizeof (addr));
			}
			
			CallTL (tlfReply, hpid, sizeof (addr), &addr);
		}
		break;

    case dbcLastAddr:
        assert( wValue == sizeof( ADDR ) );

        UnFixupAddr( hpid, htid, (LPADDR) lpb );

        xosd = CallDB(dbc, hpid, htid, CEXM_MDL_native, 0, (LPVOID) lpb);

        if ( xosd == xosdNone ) {
            FixupAddr( hpid, htid, (LPADDR) lpb );
        }

        CallTL( tlfReply, hpid, sizeof(ADDR), lpb);
        break;

    case dbceExceptionDuringStep:
        {
            DWORD cAddrsAllocated = 6, cbPacket;
            HTID vhtid = htid;
            LPEXHDLR lpexhdlr = (LPEXHDLR) MHAlloc(sizeof(EXHDLR)+sizeof(ADDR)*cAddrsAllocated);
            lpexhdlr->count = 0;
            GetFrameEH(hpid, htid, &lpexhdlr, &cAddrsAllocated);
            while (GetFrame(hpid, vhtid, 1, (DWORD)&vhtid)==xosdNone) {
                GetFrameEH(hpid, vhtid, &lpexhdlr, &cAddrsAllocated);
            }
            cbPacket = sizeof(EXHDLR)+(lpexhdlr->count * sizeof(ADDR));
            CallTL( tlfReply, hpid, cbPacket, (LPVOID) lpexhdlr);
            MHFree(lpexhdlr);
            xosd = xosdNone;
        }
        break;

    default:
        break;
    }

    if ((xosd == xosdContinue) && (dbc < dbcMax) && (dbc != dbcModLoad)) {
        xosd = CallDB ( dbc, hpid, htid, CEXM_MDL_native, wValue, (LPVOID)lpb );
    }

    switch ( dbc ) {

    case dbcProcTerm:
        {
            LPPRC lpprc = (LPPRC) LLLock ( hprc );
            lpprc->stat = statDead;
            LLUnlock ( hprc );
        }
        break;

    case dbcThreadTerm:
        {
            LPTHD lpthd = (LPTHD) LLLock ( hthd );
            lpthd->fVirtual = TRUE;
            LLUnlock ( hthd );
        }
        break;

    case dbcDeleteProc:
        break;

    case dbcDeleteThread:
        break;

        case dbcCheckBpt:
        case dbcCheckWatchPoint:
        case dbcCheckMsgBpt:
        {
            DWORD wContinue = xosd;
            xosd = xosdNone;
            CallTL( tlfReply, hpid, sizeof(wContinue), &wContinue);
        }
    }

    return xosd;
}                               /* DebugPacket() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp_plt.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    emdp_plt.h

Abstract:

    Target platform independent

Author:

    RafaelL 18-Sep-1995

Environment:

    Win32, User Mode

--*/

#pragma warning( disable: 4200)

#include "biavst.h"
#include "emdp.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdata.h ===
#ifndef _EMDATA
#define _EMDATA

/*
**  These are handles to structures.  The structures are different in
**  the EM and the DM
*/

typedef HLLE HPRC;
typedef HLLE HTHD;
typedef HLLE HEXD;



#ifdef HOSTDOS32
#define EMENTRY far pascal
#else
#define EMENTRY PASCAL LOADDS
#endif

#define IsSegEqual(seg1,seg2) ( (seg1) == (seg2) )
#if 0 // clash with dolphin types.h
#define FP_SEG(fp) (*((unsigned _far *)&(fp)+1))
#define FP_OFF(fp) (*((unsigned _far *)&(fp)))
#endif

typedef enum {
    statStarted,
    statRunning,
    statStopped,
    statDead
} STAT; // process STATus

typedef enum {
    efpNone,
    efpEmulator,
    efpChip
} EFP; // Existence of Floating Point chip or emulator


// Global Segment Info table
typedef struct _sgf {
    union {
        struct {
            unsigned short  fRead   :1;
            unsigned short  fWrite  :1;
            unsigned short  fExecute:1;
            unsigned short  f32Bit  :1;
            unsigned short  res1    :4;
            unsigned short  fSel    :1;
            unsigned short  fAbs    :1;
            unsigned short  res2    :2;
            unsigned short  fGroup  :1;
            unsigned short  res3    :3;
        } u1;
        struct {
            unsigned short  segAttr :8;
            unsigned short  saAttr  :4;
            unsigned short  misc    :4;
        } u2;
    } u;
} SGF;

typedef struct _sgi {
    SGF                 sgf;        // Segment flags
    unsigned short      iovl;       // Overlay number
    unsigned short      igr;        // Group index
    unsigned short      isgPhy;     // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       doffseg;    // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
} SGI;

typedef SGI FAR * LPSGI;

typedef struct _GSI {
    unsigned short   csgMax;
    unsigned short   csgLogical;
    SGI              rgsgi[];
} GSI;

typedef GSI FAR * LPGSI;


/*
 *  This structure is used by the EM to describe all of the relevant
 *      information for an executable object.
 *
 */

typedef struct _MDI {
    WORD            mte;        /* Unique handle identifing the DLL      */
    unsigned short  pad0;       /* PAD                                   */
    DWORD           lpBaseOfDll;/* Base offset of the DLL                */
    DWORD           dwSizeOfDll;
    SEGMENT         StartingSegment;    // Starting segment for real mode

    SEGMENT         CSSel;      /* FLAT CS selector                      */
    SEGMENT         DSSel;      /* FLAT DS selector                      */

    DWORD           cobj;       /* Count of objects (sections) in the DLL */
    OBJD *          rgobjd;     /* Array of object (section) descriptors */

    LPGSI           lpgsi;      /* Symbol handler description of sections */
    LPDEBUGDATA     lpDebug;    /* fpo/pdata/omap info                    */
    HEMI            hemi;       /* Handle to the symbol handle description */
    LPTSTR          lszName;    /* Name of DLL                           */

    DWORD           lpBaseOfData; /* for adrData */
    NLG             nlg;
    DWORD           isecTLS;
    BOOL            fSendNLG:1;
    BOOL            fFlatMode:1; /* Is this dll 0:32 or 16:32 addressing  */
    BOOL            fRealMode:1; /* Is this dll real mode?                */
    BOOL            fOffset32:1; /* Is this dll offset 32?                */
#ifdef OMNI
	DWORD			fOmniMap:1;
#endif
} MDI;  // Module Info
typedef MDI FAR *LPMDI;
typedef HLLE HMDI;

#define hmdiNull ((HMDI) 0)

// cache the tls index in this structure
typedef struct _ITLSCACHE {
    DWORD iTls;
    BOOL  fValid;
    ADDR  addr;
} ITLSCACHE;
typedef struct _UTLSCACHE {
    UOFFSET uoffTls;
    BOOL fValid;
} UTLSCACHE;

typedef struct _PRC {
    HPID hpid;
    PID  pid;

    BOOL	fRunning : 1;
    BOOL	fLoadingModule : 1;
    BOOL	fUnloadingModule : 1;
    BOOL	fDmiCache : 1;
	BOOL	fInitedExceptList : 1;		// has the exception list been inited yet (TRUE) or not (FALSE)

    DMINFO dmi;         // debug metric info
    HLLI llthd;         // list of threads
    HLLI llmdi;         // list of module info
    UINT cmdlTLS;
    HLLI llexc;         // Exceptions info
    STAT stat;

    SEGMENT     selFlatCs;      /* The one and only FLAT code selector */
    SEGMENT     selFlatDs;      /* The one and only FLAT data selector */
} PRC;
typedef PRC  FAR *LPPRC;   // Process information
typedef HPRC FAR *LPHPRC;

#define hprcNull 0
#define hprcInvalid (HPRC)(-1)

/*
 *   The THD structure contains the information which describes the
 *      internal state of a debuggee thread.
 */

//
// For specifying the frame number
// If the frame number is 0, use "regs", not "frameRegs"
//

typedef enum {
    drtNonePresent    =    0,   /* No registers present          */
    drtCntrlPresent   =    1,   /* Control registers are present */
    drtAllPresent     =    2,   /* All registers are present     */
    drtSpecialPresent =    4,   /* Kernel specials are present   */
    drtCntrlDirty     = 0x10,   /* Control registers are dirty   */
    drtAllDirty       = 0x20,   /* Non-control register dirty    */
    drtSpecialDirty   = 0x40,   /* Kernel special regs dirty     */
} DRT; // DiRTy registers

typedef struct _THD {
    HTID    htid;                // WinDbg thread identifier
    TID     tid;                 // System thread identifier
    HPRC    hprc;                // System process identifier
    BOOL    fVirtual:1;          // Thread has been terminated and does
                                 //      not really exist anymore
    BOOL    fFlat:1;             // Current context is in 0:32 bit mode
    BOOL    fOff32:1;            // Current context is 32-bit offset
    BOOL    fReal:1;             // Current context is in real mode
    BOOL    fRunning:1;          // Thread is thought to be executing

	UOFFSET	offBetterTopFrame;	 // This is the top frame address from
								 // Imagehlp. In some circumstances this is
								 // better than EBP, specifically when
								 // retial debugging.
	
	DRT     drt;                 // Thread dirty status flags
    ADDR    addrTls;             // Address of TLS data
    PVOID   regs;                // Last known context of thread

	
    DWORD   frameNumber;         // frame number
    PVOID   frameRegs;           // Regs for frameNumber

    KNONVOLATILE_CONTEXT_POINTERS frameRegPtrs;
                                 // Pointers to last place register saved.

    STACKFRAME StackFrame;       // Imagehlp stack frame struct

    PVOID   pvSpecial;           // kernel mode data
    DWORD   dwcbSpecial;         // size of special data
    UOFFSET  uoffTEB;
    UTLSCACHE uTlsCache;         // base of this thread's TLS
} THD;
typedef THD FAR *LPTHD;          // Thread information
typedef HTHD FAR *LPHTHD;

#define hthdNull    ((HTHD) 0)
#define hthdInvalid ((HTHD)(-1))

/*
 *
 */

#if 0
#pragma pack ( 1 )

typedef struct _EMC {
    WORD        wControl;   // Control word.
    WORD        wStatus;    // Status word.
    WORD        BASstk;     // base of emulator stack
    WORD        CURstk;     // current stack element
    WORD        LIMstk;     // limit of stack
} EMC;  // Emulator control


typedef struct _EME {
    WORD rgwMantissa [ 4 ];
    union {
        WORD wExponent;
        struct {
            WORD wExpPad    : 15;
            WORD bitExpSign : 1;
        } u;
    } u;
    BYTE fSingle : 1;
    BYTE flagpad : 6;
    BYTE fSign   : 1;
    BYTE tag     : 2;
    BYTE tagpad  : 6;
} EME;  // Emulator element

#pragma pack ( )
#endif

typedef enum {
    emdiName,
    emdiEMI,
    emdiMTE,
    emdiBaseAddr,
    emdiNLG
} EMDI;



/*
 *  The following structure is used for doing function evaluation
 */

typedef struct _EXECUTE_OBJECT_EM {
    PVOID       regs;           /* save register area            */
    HTHD        hthd;           /* thread execution is on        */
    HIND        heoDm;          /* execute object from DM        */
} EXECUTE_OBJECT_EM;

typedef EXECUTE_OBJECT_EM FAR * LP_EXECUTE_OBJECT_EM;

enum ModeDisasm
{
    mSpecDisasm,                       // from DM, memory had been read
    mRegularDisasm,                    // from EM, regular
};



//
// flag description structure.  contains a register description
// and the shift count to the rightmost bit in the flag.
//
struct RGFD {
    FD      fd;
    USHORT  iShift;
};


//
// These are the machine-specific functions which must be provided
// in emdp_CPU.cpp to support each CPU.
//

typedef  XOSD   (*PFNGETADDR) (HPID, HTID, ADR, LPADDR);
typedef  XOSD   (*PFNSETADDR) (HPID, HTID, ADR, LPADDR);
typedef  LPVOID (*PFNDOGETREG) (LPVOID, DWORD, LPVOID);
typedef  XOSD   (*PFNGETREGVALUE) (HPID, HTID, DWORD, LPVOID);
typedef  LPVOID (*PFNDOSETREG) (LPVOID, DWORD, LPVOID);
typedef  XOSD   (*PFNSETREGVALUE) (HPID, HTID, DWORD, LPVOID);
typedef  XOSD   (*PFNGETFLAG) (HPID, HTID, DWORD, LPVOID);
typedef  XOSD   (*PFNSETFLAG) (HPID, HTID, DWORD, LPVOID);
typedef  XOSD   (*PFNGETFRAME) (HPID, HTID, DWORD, DWORD);
typedef  XOSD   (*PFNGETFRAMEEH) (HPID, HTID, LPEXHDLR *, LPDWORD);
typedef  XOSD   (*PFNUPDATECHILD) (HPID, HTID, DMF);
typedef  VOID   (*PFNADJUSTFORPROLOG) (HPID, HTID, PADDR, CANSTEP *);
typedef  VOID   (*PFNCOPYFRAMEREGS) (LPTHD, LPBPR);
typedef  XOSD   (*PFNGETFUNCTIONINFO) (HPID, LPGFI);
typedef  XOSD   (*PFNGETFRAMEWITHSRC) (HPID, HTID, UINT, LPHTID);

typedef
struct _CPU_POINTERS {

    size_t              SizeOfContext;
    RGFD              * Rgfd;
    RD                * Rgrd;
    DWORD               CRgfd;
    DWORD               CRgrd;

    PFNGETADDR          pfnGetAddr;
    PFNSETADDR          pfnSetAddr;
    PFNDOGETREG         pfnDoGetReg;
    PFNGETREGVALUE      pfnGetRegValue;
    PFNDOSETREG         pfnDoSetReg;
    PFNSETREGVALUE      pfnSetRegValue;
    PFNGETFLAG          pfnGetFlagValue;
    PFNSETFLAG          pfnSetFlagValue;
    PFNGETFRAME         pfnGetFrame;
    PFNGETFRAMEEH       pfnGetFrameEH;
    PFNUPDATECHILD      pfnUpdateChild;
    PFNCOPYFRAMEREGS    pfnCopyFrameRegs;
    PFNADJUSTFORPROLOG  pfnAdjustForProlog;
    PFNGETFUNCTIONINFO  pfnGetFunctionInfo;
	PFNGETFRAMEWITHSRC	pfnGetFrameWithSrc;
} CPU_POINTERS;
typedef CPU_POINTERS * PCPU_POINTERS;



extern MASKINFO MaskInfo[];
extern MASKMAP MaskMap;
extern MESSAGEINFO MessageInfo[];
extern MESSAGEMAP MessageMap;

extern LPDBF   lpdbf;
extern LPFNSVC lpfnsvcTL;

extern HLLI llpid;

extern HLLI llprc;

extern HPRC hprcCurr;
extern HPID hpidCurr;
extern PID  pidCurr;
extern PCPU_POINTERS pointersCurr;
extern MPT  mptCurr;

extern HTHD hthdCurr;
extern HTID htidCurr;
extern TID  tidCurr;

#define cbBufferDef 525
extern DWORD cbBuffer;
extern LPDM_MSG LpDmMsg;

extern XOSD (PASCAL LOADDS *CallTL) ( TLF, HPID, DWORD, LPVOID );
extern XOSD (PASCAL LOADDS *CallDB) ( DBC, HPID, HTID, DWORD, DWORD, LPVOID );
extern XOSD (PASCAL LOADDS *CallNT) ( EMF, HPID, HTID, DWORD, LPVOID );

#define MAXADDR 0xffffffff

#endif  // _EMDATA
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp3.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    emdp3.c

Abstract:

    This file contains the some of the machine independent portions of the
    execution model.  The machine dependent portions are in other files.

Author:

    Kent Forschmiedt (kentf) 11-8-93

Environment:

    Win32 -- User

Notes:

    The orginal source for this came from the CodeView group.

--*/

#include "emdp.h"

#include "fbrdbg.h"


//
// This list is only used when there is no DM present.  Whenever an
// hpid is created, the real list is obtained from the DM and stored
// in a list bound to the hprc.
//
static EXCEPTION_DESCRIPTION DefaultExceptionList[] = {
    {EXCEPTION_ACCESS_VIOLATION,        efdStop,  _T("Access Violation")},
    {EXCEPTION_ARRAY_BOUNDS_EXCEEDED,   efdStop,  _T("Array Bounds Exceeded")},
    {EXCEPTION_FLT_DENORMAL_OPERAND,    efdStop,  _T("FP Denormal Operand")},
    {EXCEPTION_FLT_DIVIDE_BY_ZERO,      efdStop,  _T("FP Divide by Zero")},
    {EXCEPTION_FLT_INEXACT_RESULT,      efdStop,  _T("FP Inexact Result")},
    {EXCEPTION_FLT_INVALID_OPERATION,   efdStop,  _T("FP Invalid Operation")},
    {EXCEPTION_FLT_OVERFLOW,            efdStop,  _T("FP Overflow")},
    {EXCEPTION_FLT_STACK_CHECK,         efdStop,  _T("FP Stack Check")},
    {EXCEPTION_FLT_UNDERFLOW,           efdStop,  _T("FP Underflow")},
    {EXCEPTION_INT_DIVIDE_BY_ZERO,      efdStop,  _T("Int Divide by zero")},
    {EXCEPTION_INT_OVERFLOW,            efdStop,  _T("Int Overflow")},
    {EXCEPTION_PRIV_INSTRUCTION,        efdStop,  _T("Insufficient Privilege")},
    {EXCEPTION_IN_PAGE_ERROR,           efdStop,  _T("I/O Error in Paging")},
    {EXCEPTION_ILLEGAL_INSTRUCTION,     efdStop,  _T("Illegal Instruction")},
    {EXCEPTION_NONCONTINUABLE_EXCEPTION,efdStop,  _T("Noncontinuable Exception")},
    {EXCEPTION_STACK_OVERFLOW,          efdStop,  _T("Stack Overflow")},
    {EXCEPTION_INVALID_DISPOSITION,     efdStop,  _T("Invalid Disposition")},
    {DBG_CONTROL_C,                     efdStop,  _T("Control-C break")},
};


#define DECL_MASK(n,v,s) n = v,
#define DECL_MSG(n,s,m)

enum {
#include "win32msg.h"
};

#undef DECL_MASK
#define DECL_MASK(n,v,s) { n, _T(s) },

MASKINFO MaskInfo[] = {
#include "win32msg.h"
};

#define MASKMAPSIZE (sizeof(MaskInfo)/sizeof(MASKINFO))
MASKMAP MaskMap = {MASKMAPSIZE, MaskInfo};

#undef DECL_MASK
#undef DECL_MSG


#define DECL_MASK(n,v,s)
#define DECL_MSG(n,s,m) { n, _T(s), m },

MESSAGEINFO MessageInfo[] = {
#include "win32msg.h"
};

#define MESSAGEMAPSIZE (sizeof(MessageInfo)/sizeof(MESSAGEINFO))
MESSAGEMAP MessageMap = {MESSAGEMAPSIZE,MessageInfo};

#undef DECL_MASK
#undef DECL_MSG




XOSD
HandleBreakpoints(
    HPID hpid,
    DWORD wValue,
    LONG lValue
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    LPBPS lpbps = (LPBPS) lValue;
    LPDBB lpdbb = (LPDBB) MHAlloc(FIELD_OFFSET(DBB, rgbVar) + wValue);
    XOSD xosd;

    // let the DM handle everything?
    lpdbb->hpid = hpid;
    lpdbb->htid = NULL;
    lpdbb->dmf  = dmfBreakpoint;
    memcpy(lpdbb->rgbVar, lpbps, wValue);
    GuardTL();
    CallTL ( tlfRequest, hpid, FIELD_OFFSET ( DBB, rgbVar ) + wValue, (LPVOID)lpdbb );
    MHFree(lpdbb);
    xosd = LpDmMsg->xosdRet;
    ReleaseTL();
    return xosd;
}


XOSD
Go (
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    )
{
    UpdateChild( hpid, htid, dmfGo );
    return SendRequestX(dmfGo, hpid, htid, sizeof(EXOP), lpexop);
}


XOSD
ReturnStep (
    HPID hpid,
    HTID htid,
    LPEXOP lpexop
    )
{
    RTRNSTP rtrnstp;
    XOSD xosd = xosdNone;
    HTID vhtid = htid;

    rtrnstp.exop = *lpexop;
    if ((((DWORD)htid) & 1) == 0) {
        xosd = GetFrame( hpid, vhtid, 1, (DWORD)&vhtid );
    }
    if ( xosd == xosdNone ) {
       xosd = GetFrame( hpid, vhtid, 1, (DWORD)&vhtid );
       if ( xosd == xosdNone ) {
          xosd = GetAddr( hpid, vhtid, adrPC, &(rtrnstp.addrRA) );
          if ( xosd == xosdNone ) {
              xosd = GetAddr( hpid, htid, adrStack, &(rtrnstp.addrStack) );
          }
       }
    }
    if ( xosd != xosdNone ) {
       return( xosd );
    }
    return SendRequestX ( dmfReturnStep, hpid, htid, sizeof(rtrnstp), &rtrnstp);

}

XOSD
ThreadStatus (
    HPID hpid,
    HTID htid,
    LPTST lptst
    )
{
    XOSD xosd;

    GuardTL();
    xosd = SendRequest ( dmfThreadStatus, hpid, htid );
    if (xosd == xosdNone) {
        xosd = LpDmMsg->xosdRet;
    }
    if (xosd == xosdNone) {
        memcpy(lptst, LpDmMsg->rgb, sizeof(TST));
    } else {
                HPRC hprc = ValidHprcFromHpid(hpid);
                if (hprc) {
                        HTHD hthd = HthdFromHtid(hprc, htid);
                        if (hthd) {
                                LPTHD lpthd = (LPTHD) LLLock(hthd);
                                lptst->dwThreadID = lpthd->tid;
                                LLUnlock(hthd);
                        }
                }
        }
    ReleaseTL();
    return xosd;
}


XOSD
ProcessStatus(
    HPID hpid,
    LPPST lppst
    )
{
    XOSD xosd;
    GuardTL();
    xosd = SendRequest(dmfProcessStatus, hpid, NULL );
    if (xosd == xosdNone) {
        xosd = LpDmMsg->xosdRet;
    }
    if (xosd == xosdNone) {
        memcpy(lppst, LpDmMsg->rgb, sizeof(PST));
    }
    ReleaseTL();
    return xosd;
}


XOSD
GetTimeStamp(
	HPID	hpid,
	HTID	htid,
	LPTCS	lptcs
	)
{
	XOSD	xosd;
	ULONG	len;
	LPTCSR	lptcsr;

	len = _tcslen (lptcs->ImageName) + 1;
	
    GuardTL();
	lptcsr = (LPTCSR) LpDmMsg->rgb;
	xosd = SendRequestX (dmfGetTimeStamp, hpid, htid, len, lptcs->ImageName);

	if (xosd == xosdNone) {
		xosd = LpDmMsg->xosdRet;
	}

	if (xosd == xosdNone) {
		lptcs->TimeStamp = lptcsr->TimeStamp;
		lptcs->CheckSum = lptcsr->CheckSum;
	}
    ReleaseTL();

	return xosd;
}


XOSD
EMCreateUserCrashDump(
	HPID	hpid,
	HTID	htid,
	LPTSTR	szCrashFileName
	)
{
	XOSD	xosd;
	ULONG	len;

	len = _tcslen (szCrashFileName) + 1;

    GuardTL();
	xosd = SendRequestX (dmfCreateUserCrashDump,
						 hpid,
						 htid,
						 len,
						 szCrashFileName);

	if (xosd == xosdNone) {
		xosd = LpDmMsg->xosdRet;
	}
    ReleaseTL();

	return xosd;
}
		
		

XOSD
Freeze (
    HPID hpid,
    HTID htid
    )
{
    XOSD xosd;
    HTHD hthd;
    HPRC hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }
    if ( (hthd = HthdFromHtid(hprc, htid)) == hthdInvalid || hthd == NULL ) {
        return xosdBadThread;
    }

    GuardTL();
    SendRequest ( dmfFreeze, hpid, htid);

    xosd = LpDmMsg->xosdRet;
    ReleaseTL();
    return xosd;
}


XOSD
Thaw (
    HPID hpid,
    HTID htid
    )
{
    XOSD xosd;
    HTHD hthd;
    HPRC hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }
    if ( (hthd = HthdFromHtid(hprc, htid)) == hthdInvalid || hthd == NULL ) {
        return xosdBadThread;
    }

    GuardTL();
    SendRequest ( dmfResume, hpid, htid);

    xosd = LpDmMsg->xosdRet;
    ReleaseTL();
    return xosd;
}


XOSD
DebugMetric (
    HPID hpid,
    HTID htid,
    MTRC mtrc,
    LPLONG lpl
    )
/*++

Routine Description:

    The debugger queries this function to find out the size of OS and machine
    dependent values, e.g. the size of a process ID.

Arguments:

    hpid

    htid

    mtrc   - metric identifier

    lpl    - answer buffer

Return Value:

    xosdNone if the request succeeded, xosd error code otherwise.

--*/
{
    HPRC hprc;
    HTHD hthd;
    LPPRC lpprc = NULL;
    XOSD xosd = xosdNone;


    hprc = HprcFromHpid(hpid);

    if (hprc) {

        lpprc = (LPPRC) LLLock( hprc );
        assert( lpprc );

        switch ( mtrc ) {

          default:
            break;

          case mtrcProcessorType:
          case mtrcProcessorLevel:
          case mtrcEndian:
          case mtrcThreads:
          case mtrcAsync:
          case mtrcAsyncStop:
          case mtrcBreakPoints:
          case mtrcReturnStep:
          case mtrcRemote:
          case mtrcOSVersion:
            if (!lpprc->fDmiCache) {
                GuardTL();
                xosd = SendRequest ( dmfGetDmInfo, hpid, htid );
                if (xosd == xosdNone) {
                    memcpy(&lpprc->dmi, LpDmMsg->rgb, sizeof(DMINFO));
                    lpprc->fDmiCache = TRUE;
                }
                ReleaseTL();
            }
            break;

        }

        if (xosd != xosdNone) {
            LLUnlock( hprc );
            return xosd;
        }


    }

    switch ( mtrc ) {

      default:
        assert(FALSE);
        xosd = xosdInvalidParameter;
        break;

      case mtrcProcessorType:

        assert(lpprc);
        *lpl = lpprc->dmi.Processor.Type;
        break;

      case mtrcProcessorLevel:

        assert(lpprc);
        *lpl = lpprc->dmi.Processor.Level;
        break;

      case mtrcEndian:

        assert(lpprc);
        *lpl = lpprc->dmi.Processor.Endian;
        break;

      case mtrcThreads:

        assert(lpprc);
        *lpl = lpprc->dmi.fHasThreads;
        break;

      case mtrcCRegs:

        *lpl = CRgrd(hpid);
        break;

      case mtrcCFlags:

        *lpl = CRgfd(hpid);
        break;

      case mtrcExtRegs:

        assert(0 && "do something with this");
        break;

      case mtrcExtFP:

        assert(0 && "do something with this");
        break;

      case mtrcExtMMU:

        assert(0 && "do something with this");
        break;

      case mtrcExceptionHandling:

        *( (LPDWORD) lpl) = TRUE;
        break;

      case mtrcAssembler:
#if 0
        switch(MPTFromHprc(hprc)) {
            case mptix86:
            case mptmips:
            case mptdaxp:
            case mptmppc:
            default:
                *( (LPDWORD) lpl) = FALSE;
                break;
        }
#else
        *( (LPDWORD) lpl) = FALSE;
#endif
        break;

      case mtrcAsync:

        assert(lpprc);
#if defined(DOLPHIN) // HACK!!! Need to get mtrc bits into od.h
        *(LPWORD)lpl = (WORD)lpprc->dmi.mAsync;
#else
        *lpl = !!lpprc->dmi.mAsync;
#endif
        break;

      case mtrcAsyncStop:

        assert(lpprc);
        *lpl = !!(lpprc->dmi.mAsync & asyncStop);
        break;

      case mtrcBreakPoints:

        assert(lpprc);
        //
        // Message BPs are implemented in the EM
        // on top of the exec BP implemented by the DM.
        //
        *lpl = lpprc->dmi.Breakpoints |
                bptsMessage |
                bptsMClass;
        break;

      case mtrcReturnStep:

        assert(lpprc);
        *lpl = lpprc->dmi.fReturnStep;
        break;

      case mtrcShowDebuggee:

        *lpl = FALSE;
        break;

      case mtrcHardSoftMode:

        *lpl = FALSE;
        break;

      case mtrcRemote:

        assert(lpprc);
        *lpl = lpprc->dmi.fRemote;
        break;

      case mtrcOleRpc:

        *lpl = TRUE;
        break;

      case mtrcNativeDebugger:

        *lpl = FALSE;
        break;

      case mtrcOSVersion:

        *lpl = (lpprc->dmi.MajorVersion << 16) | lpprc->dmi.MinorVersion;
        break;

      case mtrcMultInstances:

        *(BOOL*) lpl = TRUE;
        break;

      case mtrcTidValue:
        HTHD hthd = HthdFromHtid(hprc, htid);
        if (hthd) {
            LPTHD lpthd = (LPTHD) LLLock(hthd);
            *lpl = lpthd->tid;
            LLUnlock(hthd);
        } else {
            *lpl = 0;
        }
        break;
    }

    LLUnlock( hprc );

    return xosdNone;
}


XOSD
FakeGetExceptionState(
    EXCEPTION_CONTROL exc,
    LPEXCEPTION_DESCRIPTION lpexd
    )
/*++

Routine Description:

    Handle the GetExceptionState call when there is no DM connected.

Arguments:

    exc - Supplies exfFirst, exfSpecified or exfNext

    lpexd - Returns EXCEPTION_DESCRIPTION record

Return Value:

    xosdNone except when exc is exfNext and lpexd->dwExceptionCode
    was not in the list.

--*/
{
    DWORD dwT;
    int i;

    if (exc == exfFirst) {
        *lpexd = DefaultExceptionList[0];
        return xosdNone;
    }

    for (i = 0; DefaultExceptionList[i].dwExceptionCode != 0; i++) {
        if (DefaultExceptionList[i].dwExceptionCode == lpexd->dwExceptionCode) {
            break;
        }
    }

    if (exc == exfSpecified) {
        dwT = lpexd->dwExceptionCode;
        *lpexd = DefaultExceptionList[i];
        lpexd->dwExceptionCode = dwT;
        return xosdNone;
    }

    if (DefaultExceptionList[i].dwExceptionCode != 0) {
        *lpexd = DefaultExceptionList[++i];
        return xosdNone;
    }

    return xosdInvalidParameter;
}


XOSD
GetExceptionState(
    HPID hpid,
    HTID htid,
    EXCEPTION_CONTROL exc,
    LPEXCEPTION_DESCRIPTION lpexd
    )
{
    HPRC hprc;
    LPPRC lpprc;
    XOSD xosd = xosdNone;
    HEXD hexd;

    if (!hpid) {
        return FakeGetExceptionState(exc, lpexd);
    }

    hprc = HprcFromHpid( hpid );
    assert(hprc);
    lpprc = (LPPRC) LLLock(hprc);

    switch (exc) {

      default:
        assert( 0 && "Invalid arg to em!GetExceptionState" );
        xosd = xosdInvalidParameter;
        break;

      case exfFirst:

        hexd = LLNext( lpprc->llexc, NULL );
        if (!hexd) {
            // get the default exception record
            DWORD dwT = 0;
            hexd = LLFind( lpprc->llexc, NULL, &dwT, 0 );
        }
        if (!hexd) {
           memset(lpexd, 0, sizeof(EXCEPTION_DESCRIPTION));
        }
        else {
           *lpexd = *(LPEXCEPTION_DESCRIPTION)LLLock(hexd);
           LLUnlock(hexd);
        }
        break;


      case exfSpecified:

        hexd = LLFind( lpprc->llexc, NULL, &lpexd->dwExceptionCode, 0 );
        if (!hexd) {
            // get the default exception record
            DWORD dwT = 0;
            hexd = LLFind( lpprc->llexc, NULL, &dwT, 0 );
        }
        if (!hexd) {
            memset(lpexd, 0, sizeof(EXCEPTION_DESCRIPTION));
            xosd = xosdInvalidParameter;
        }
        else {
           *lpexd = *(LPEXCEPTION_DESCRIPTION)LLLock(hexd);
           LLUnlock(hexd);
        }
        break;


      case exfNext:

        hexd = LLFind( lpprc->llexc, NULL, &lpexd->dwExceptionCode, 0 );
        if (!hexd) {
            //
            // origin must exist
            //
            xosd = xosdInvalidParameter;
        } else {
            //
            // but the next one need not
            //
            hexd = LLNext( lpprc->llexc, hexd );
            if (!hexd) {
                memset(lpexd, 0, sizeof(EXCEPTION_DESCRIPTION));
                xosd = xosdEndOfStack;
            } else {
                *lpexd = *(LPEXCEPTION_DESCRIPTION)LLLock(hexd);
                LLUnlock(hexd);
            }
        }
        break;

    }

    LLUnlock(hprc);
    return xosd;
}


XOSD
SetExceptionState(
    HPID hpid,
    HTID htid,
    LPEXCEPTION_DESCRIPTION lpexd
    )
{
    HPRC hprc = HprcFromHpid( hpid );
    HLLI llexc;
    HEXD hexd;

    assert(lpexd->efd == efdIgnore ||
           lpexd->efd == efdNotify ||
           lpexd->efd == efdCommand ||
           lpexd->efd == efdStop);

    if (!hprc) {
        return xosdBadProcess;
    }

    llexc = ((LPPRC)LLLock(hprc))->llexc;
    LLUnlock(hprc);

    hexd = LLFind( llexc, NULL, &lpexd->dwExceptionCode, 0 );

    if (!hexd) {
        hexd = LLCreate( llexc );
        if (!hexd) {
            return xosdOutOfMemory;
        }
        LLAdd( llexc, hexd );
    }

    *(LPEXCEPTION_DESCRIPTION)LLLock(hexd) = *lpexd;
    LLUnlock(hexd);

    return SendRequestX( dmfSetExceptionState, hpid, htid,
                                        sizeof(EXCEPTION_DESCRIPTION), lpexd);
}


XOSD
GetMemoryInfo(
    HPID hpid,
    HTID htid,
    LPMEMINFO lpmi
    )
{
    PMEMORY_BASIC_INFORMATION lpmbi;
    ADDR addr;
    XOSD xosd = xosdNone;

    Unreferenced(htid);

    addr = lpmi->addr;

    if (ADDR_IS_LI(addr)) {
        xosd = FixupAddr(hpid, htid, &addr);
    }

    GuardTL();
    if (xosd == xosdNone) {
        xosd = SendRequestX( dmfVirtualQuery, hpid, 0, sizeof(ADDR),
                                                              (LPVOID)&addr );
    }

    if (xosd == xosdNone) {
        lpmbi = (PMEMORY_BASIC_INFORMATION) LpDmMsg->rgb;
        lpmi->addrAllocBase = addr;
        lpmi->addrAllocBase.addr.off = (UOFF32)lpmbi->AllocationBase;
        lpmi->uRegionSize = (UOFF32)lpmbi->RegionSize;
        lpmi->dwProtect = lpmbi->Protect;
        lpmi->dwState = lpmbi->State;
        lpmi->dwType = lpmbi->Type;
    }
    ReleaseTL();

    return xosd;
}


XOSD
FreezeThread(
    HPID hpid,
    HTID htid,
    BOOL fFreeze
    )
{
    XOSD xosd;
    HTHD hthd;
    HPRC hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }
    if ( (hthd = HthdFromHtid(hprc, htid)) == hthdInvalid || hthd == NULL ) {
        return xosdBadThread;
    }

    GuardTL();
    if (fFreeze) {
        SendRequest ( dmfFreeze, hpid, htid);
    } else {
        SendRequest ( dmfResume, hpid, htid);
    }

    xosd = LpDmMsg->xosdRet;
    ReleaseTL();
    return xosd;
}



#define FreeModuleList(m)                       MHFree(m)


XOSD
GetModuleList(
    HPID                    hpid,
    HTID                    htid,
    LPTSTR                  lpModuleName,
    LPMODULE_LIST FAR *     lplpModuleList
    )
{
    XOSD            xosd = xosdNone;
    HLLI            llmdi;
    HMDI            hmdi;
    LPMDI           lpmdi;
    DWORD           Count;
    LPMODULE_LIST   ModList;
    LPMODULE_LIST   TmpList;
    LPMODULE_ENTRY  Entry;
    LDT_ENTRY       Ldt;
    DWORD           MaxSize;
    DWORD           Delta;
    DWORD           i;
    SEGMENT         Selector;
    DWORD           Base;
    DWORD           Limit;
    OBJD           *ObjD;
    LPTSTR          p;
    TCHAR           WantedName[ MAX_PATH ];
    TCHAR           WantedExt[ MAX_PATH ];
    TCHAR           ModName[ MAX_PATH ];
    TCHAR           ModExt[ MAX_PATH ];
    TCHAR           Name[ MAX_PATH ];

    *WantedName = '\0';
    *WantedExt  = '\0';

    if ( !lplpModuleList ) {
        xosd = xosdInvalidParameter;
        goto Done;
    }

    *lplpModuleList = NULL;

    llmdi = LlmdiFromHprc( HprcFromHpid ( hpid ));

    if ( !llmdi ) {
        xosd = xosdBadProcess;
        goto Done;
    }


    //
    //  Estimate the list size, to minimize the calls to realloc.
    //
    if ( lpModuleName ) {

        Count = 20;
        _tsplitpath( lpModuleName, NULL, NULL, WantedName, WantedExt );

    } else {

        hmdi  = hmdiNull;
        Count = 0;

        while ( (hmdi = LLNext( llmdi, hmdi )) != hmdiNull ) {
            lpmdi = (LPMDI) LLLock( hmdi );
            Count += lpmdi->fFlatMode ? 1 : lpmdi->cobj;
            LLUnlock( hmdi );
        }
    }

    //
    //  Allocate the list
    //
    MaxSize = sizeof(MODULE_LIST) + Count * sizeof(MODULE_ENTRY);

    ModList = (LPMODULE_LIST) MHAlloc( MaxSize );

    if ( !ModList ) {
        xosd = xosdOutOfMemory;
        goto Done;
    }

    //
    //  Build the list
    //
    Count = 0;

    for ( hmdi = NULL; (hmdi = LLNext( llmdi, hmdi )); LLUnlock( hmdi ) ) {

        lpmdi = (LPMDI) LLLock( hmdi );

        //
        //  Get the module name
        //
        p = (*(lpmdi->lszName) == _T('|')) ? lpmdi->lszName+1 : lpmdi->lszName;
        _ftcscpy( Name, p );
        p = _ftcschr( Name, _T('|') );
        if ( p ) {
            *p = _T('\0');
        }

        if ( lpModuleName ) {

            //
            //  Add if base name matches
            //
            _tsplitpath( Name, NULL, NULL, ModName, ModExt );

            if (_ftcsicmp(WantedName, ModName) || _ftcsicmp(WantedExt, ModExt) ) {
                continue;
            }
        }

        Delta = lpmdi->fFlatMode ? 1 : lpmdi->cobj;

        //
        //  Reallocate buffer if necessary
        //
        if ( (Count + Delta) * sizeof(MODULE_ENTRY) > MaxSize ) {

            MaxSize += Delta * sizeof(MODULE_ENTRY);
            TmpList = (LPMODULE_LIST) MHRealloc( ModList, MaxSize );
            if ( !TmpList ) {
                FreeModuleList(ModList);
                xosd = xosdOutOfMemory;
                break;
            }

            ModList = TmpList;
        }

        //
        //  have buffer, fill it up
        //
        if ( lpmdi->fFlatMode ) {

            Entry = NthModuleEntry(ModList,Count);

            ModuleEntryFlat(Entry)          = TRUE;
            ModuleEntrySegment(Entry)       = 0;
            ModuleEntrySelector(Entry)      = 0;
            ModuleEntryBase(Entry)          = lpmdi->lpBaseOfDll;
            ModuleEntryLimit(Entry)         = lpmdi->dwSizeOfDll;
            ModuleEntryType(Entry)          = 0;
            ModuleEntrySectionCount(Entry)  = lpmdi->cobj;
            ModuleEntryEmi(Entry)           = lpmdi->hemi;
            _ftcscpy(ModuleEntryName(Entry), Name);

            Count++;

        } else {

            for ( i=0, ObjD = lpmdi->rgobjd; i < Delta; i++, ObjD++ ) {

                if ( ObjD->wSel ) {

                    Selector = ObjD->wSel;

                    Entry    = NthModuleEntry(ModList,Count);

                    ModuleEntrySegment(Entry)       = i+1;
                    ModuleEntrySelector(Entry)      = Selector;
                    ModuleEntryType(Entry)          = 0;
                    ModuleEntrySectionCount(Entry)  = 0;
                    ModuleEntryEmi(Entry)           = lpmdi->hemi;

                    _ftcscpy(ModuleEntryName(Entry), Name);

                    if ( lpmdi->fRealMode ) {

                        xosd = xosdNone;

                        ModuleEntryFlat(Entry)          = FALSE;
                        ModuleEntryReal(Entry)          = TRUE;
                        ModuleEntryBase(Entry)          = 0xBAD00BAD;
                        ModuleEntryLimit(Entry)         = 0xBAD00BAD;

                        Count++;

                    } else {

                        GuardTL();
                        xosd = SendRequestX( dmfQuerySelector,
                                             hpid,
                                             NULL,
                                             sizeof(SEGMENT),
                                             &Selector );

                        if (xosd == xosdNone) {


                            _fmemcpy( &Ldt, LpDmMsg->rgb, sizeof(Ldt));

                            Base = (Ldt.HighWord.Bits.BaseHi  << 0x18) |
                                   (Ldt.HighWord.Bits.BaseMid << 0x10) |
                                   Ldt.BaseLow;

                            Limit = (Ldt.HighWord.Bits.LimitHi << 0x10) |
                                                    Ldt.LimitLow;

                            ModuleEntryFlat(Entry)          = FALSE;
                            ModuleEntryReal(Entry)          = FALSE;
                            ModuleEntryBase(Entry)          = Base;
                            ModuleEntryLimit(Entry)         = Limit;

                            Count++;

                        } else {

                            xosd = xosdNone;

                            ModuleEntryFlat(Entry)          = FALSE;
                            ModuleEntryReal(Entry)          = FALSE;
                            ModuleEntryBase(Entry)          = 0xBAD00BAD;
                            ModuleEntryLimit(Entry)         = 0xBAD00BAD;
                            Count++;
                        }
                        ReleaseTL();
                    }
                }
            }
        }
    }

    if (hmdi) {
        LLUnlock(hmdi);
    }

    ModuleListCount(ModList) = Count;
    *lplpModuleList = ModList;

Done:
    return xosd;
}


XOSD
DoContinue(
    HPID hpid
    )
{
    LPPRC       lpprc;
    HPRC        hprc = HprcFromHpid(hpid);
    XOSD        xosd = xosdUnknown;
    BYTE        b = 1;

    assert(hprc);

    lpprc = (LPPRC) LLLock(hprc);

    if (lpprc->fLoadingModule) {

        lpprc->fRunning = TRUE;
        lpprc->fLoadingModule = FALSE;
        CallTL ( tlfReply, hpid, 1, &b );
        xosd = xosdNone;

    } else if (lpprc->fUnloadingModule) {

        lpprc->fRunning = TRUE;
        lpprc->fUnloadingModule = FALSE;
        CallTL ( tlfReply, hpid, 1, &b );
        xosd = xosdNone;
    }

    LLUnlock(hprc);

    return xosd;
}


XOSD
DoCustomCommand(
    HPID   hpid,
    HTID   htid,
    DWORD  wValue,
    LPSSS  lpsss
    )
{
    LPTSTR  lpsz = (LPTSTR)lpsss->rgbData;
    LPTSTR  p;
    XOSD   xosd;
    TCHAR  cmd[256];

    //
    // parse the command from the command line
    //
    p = cmd;
    while (*lpsz && !_istspace(*lpsz)) {
                _tccpy(p,lpsz);
                p = _tcsinc(p);
                lpsz = _tcsinc(lpsz);
    }
    *p = _T('\0');

    //
    // this is where you would stricmp() for your custom em command
    // otherwise it is passed to the dm
    //

    return SendRequestX( dmfSystemService, hpid, htid, wValue, (LPVOID) lpsss );

    //
    // this is what would be executed if you have a custom em command
    // instead of the above sendrequest()
    //

#if 0
    _tcscpy( lpiol->rgbVar, lpsz );
    xosd = IoctlCmd(hpid, htid, wValue, lpiol);
#endif

    return xosd;
}                                    /* DoCustomCommand */




XOSD
SystemService(
    HPID   hpid,
    HTID   htid,
    DWORD  wValue,
    LPSSS  lpsss
    )

/*++

Routine Description:

    This function examines SystemService requests (escapes) and deals
    with those which the EM knows about.  All others are passed on to
    the DM for later processing.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    XOSD        xosd;
    DWORD       dw;
    HPRC        hprc;
    HTHD        hthd;
    LPTHD       lpthd;


    switch( lpsss-> ssvc ) {

      case ssvcGetStackFrame:
        hprc = HprcFromHpid( hpid );
        hthd = HthdFromHtid ( hprc, htid );
        assert(hthd);
        lpthd = (LPTHD) LLLock(hthd);
        _fmemcpy(lpsss->rgbData, &lpthd->StackFrame, sizeof(STACKFRAME));
        lpsss->cbReturned = sizeof(STACKFRAME);
        xosd = xosdNone;
        break;

      case ssvcGetThreadContext:

        GuardTL();
        xosd = SendRequest ( dmfReadReg, hpid, htid );
        if (xosd == xosdNone) {
            xosd = LpDmMsg->xosdRet;
            dw = min(lpsss->cbSend, (unsigned) SizeOfContext(hpid));
            _fmemcpy (lpsss->rgbData, LpDmMsg->rgb, dw);
            lpsss->cbReturned = dw;
        }
        ReleaseTL();
        break;

      case ssvcSetThreadContext:
        xosd = SendRequestX( dmfWriteReg, hpid, htid, lpsss->cbSend,
                                                              lpsss->rgbData );
        break;

      case ssvcGetProcessHandle:
      case ssvcGetThreadHandle:
        GuardTL();
        xosd = SendRequestX(dmfSystemService,hpid, htid, wValue, (LPVOID)lpsss);
        if (xosd == xosdNone) {
            xosd = LpDmMsg->xosdRet;
            dw = min(lpsss->cbSend, sizeof(HANDLE));
            _fmemcpy (lpsss->rgbData, LpDmMsg->rgb, dw);
            lpsss->cbReturned = dw;
        }
        ReleaseTL();
        break;


      case ssvcCustomCommand:
        xosd = DoCustomCommand(hpid, htid, wValue, lpsss);
        break;

      case ssvcGetPrompt:
        GuardTL();
        xosd = SendRequestX(dmfSystemService, hpid, htid, wValue, (LPVOID)lpsss);
        if (xosd == xosdNone) {
            xosd = LpDmMsg->xosdRet;
            lpsss->cbReturned = ((LPPROMPTMSG)((LPSSS)LpDmMsg->rgb))->len + sizeof(PROMPTMSG);
            if (lpsss->cbReturned) {
                _fmemcpy((LPVOID)lpsss->rgbData,
                         LpDmMsg->rgb,
                         lpsss->cbReturned);
            }
        }
        ReleaseTL();
        break;
      case ssvcFiberDebug:
        {
            OFBRS ofbrs = *((OFBRS *) lpsss->rgbData);
            GuardTL();
            xosd = SendRequestX(dmfSystemService,hpid, htid, wValue, (LPVOID)lpsss);
            if ((xosd == xosdNone) && 
                    ((ofbrs.op == OFBR_GET_LIST) ||
                    (ofbrs.op == OFBR_QUERY_LIST_SIZE))) {
                xosd = LpDmMsg->xosdRet;
                dw = min(lpsss->cbSend, *((DWORD *) LpDmMsg->rgb)-4);
                _fmemcpy (lpsss->rgbData, ((DWORD *)LpDmMsg->rgb)+1, dw);
                lpsss->cbReturned = dw;
            }
            ReleaseTL();
        }
        break;


      case ssvcGeneric:
        GuardTL();
        xosd = SendRequestX(dmfSystemService,hpid,htid,wValue,(LPVOID)lpsss);
        if (xosd == xosdNone) {
            xosd = LpDmMsg->xosdRet;
            lpsss->cbReturned = *((LPDWORD)LpDmMsg->rgb);
            if (lpsss->cbReturned) {
                _fmemcpy ( (LPVOID)lpsss->rgbData,
                          LpDmMsg->rgb + sizeof(DWORD),
                          lpsss->cbReturned);
            }
        }
        ReleaseTL();
        break;

      default:
        xosd = SendRequestX(dmfSystemService,hpid,htid,wValue,(LPVOID)lpsss);
        break;
    }

    return xosd;

}

XOSD
RangeStep (
    HPID   hpid,
    HTID   htid,
    LPRSS  lprss
    )

/*++

Routine Description:

    This function is called to implement range steps in the EM.  A range
    step is defined as step all instructions as long as the program counter
    remains within the starting and ending addresses.

Arguments:

    hpid      - Supplies the handle of the process to be stepped
    htid      - Supplies the handle of thread to be stepped

Return Value:

    XOSD error code

--*/

{
    RST		rst = {0};


    UpdateChild( hpid, htid, dmfRangeStep );

#if 0
    rst.fStepOver = lprss->lpExop->fStepOver;
    rst.fAllThreads = !lprss->lpExop->fSingleThread;
    rst.fInitialBP = lprss->lpExop->fInitialBP;
    rst.fReturnValues = lprss->lpExop->fReturnValues;
#endif

	rst.exop = *lprss->lpExop;
    rst.offStart = lprss->lpaddrMin->addr.off;
    rst.offEnd = lprss->lpaddrMax->addr.off;

#if defined(TARGET_MIPS) || defined(TARGET_PPC)
  	rst.fPassException = lprss->lpExop->fPassException;
#endif

    return SendRequestX (
        dmfRangeStep,
        hpid,
        htid,
        sizeof ( RST ),
        &rst
    );

}                           /* RangeStep() */

XOSD
SingleStep (
    HPID   hpid,
    HTID   htid,
    LPEXOP lpexop
    )
{
    assert ( hpid != NULL );
    assert ( htid != NULL );

    UpdateChild( hpid, htid, dmfSingleStep );

    return SendRequestX (
        dmfSingleStep,
        hpid,
        htid,
        sizeof(EXOP),
        lpexop
    );
}


int
__cdecl
CompMsg(
    void const *lpdwKeyMsg,
    void const *lpMessageInfo
    )
{
    if (*((LPDWORD)lpdwKeyMsg) < ((LPMESSAGEINFO)lpMessageInfo)->dwMsg) {
        return -1;
    } else if (*((LPDWORD)lpdwKeyMsg) > ((LPMESSAGEINFO)lpMessageInfo)->dwMsg) {
        return 1;
    } else {
        return 0;
    }
}

DWORD
GetMessageMask(
    DWORD dwMessage
)
{
    LPMESSAGEINFO lpMessageInfo;

    lpMessageInfo = (LPMESSAGEINFO)bsearch((const void*)&dwMessage,
                                           (const void*)MessageInfo,
                                           sizeof(MessageInfo)/sizeof(MESSAGEINFO),
                                           sizeof(MESSAGEINFO),
                                           CompMsg);

    if (lpMessageInfo) {
        return lpMessageInfo->dwMsgMask;
    } else {
        return 0;
    }
}

int
__cdecl
CompMESSAGEINFO(
    void const *lpMessageInfo1,
    void const *lpMessageInfo2
    )
{
    // a bit of code reuse
    return CompMsg(&((LPMESSAGEINFO)lpMessageInfo1)->dwMsg, lpMessageInfo2);
}

void
SortMessages (
    void
    )
{
    qsort(MessageInfo,
          sizeof(MessageInfo) / sizeof(MESSAGEINFO),
          sizeof(MESSAGEINFO),
          CompMESSAGEINFO);
}




XOSD
SetPath(
    HPID   hpid,
    HTID   htid,
    BOOL   Set,
    LPTSTR Path
    )
/*++

Routine Description:

    Sets the search path in the DM

Arguments:

    hpid    -   process
    htid    -   thread
    Set     -   set flag
    Path    -   Path to search, PATH if null


Return Value:

    xosd error code

--*/

{
    TCHAR    Buffer[ MAX_PATH ];
    SETPTH  *SetPth = (SETPTH *)&Buffer;

    if ( Set ) {

        SetPth->Set = TRUE;
        if ( Path ) {
            _ftcscpy(SetPth->Path, Path );
        } else {
            SetPth->Path[0] = _T('\0');
        }
    } else {
        SetPth->Set     = FALSE;
        SetPth->Path[0] = _T('\0');
    }

    return SendRequestX( dmfSetPath, hpid, htid,
                           sizeof(SETPTH) + _ftcslen(SetPth->Path)*sizeof(TCHAR),
                                                   SetPth );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\flag_x86.h ===
{ SzOverflow, rtRegular|rtExtended,  1, 0,  CV_REG_FLAGS,  11 },
    { SzDirection, rtRegular|rtExtended, 1, 0,  CV_REG_FLAGS,  10 },
    { SzInterrupt, rtRegular|rtExtended, 1, 0,  CV_REG_FLAGS,   9 },
    { SzTrap,   ftInvisible,             1, 0,  CV_REG_FLAGS,   8 },
    { SzSign,   rtRegular|rtExtended,    1, 0,  CV_REG_FLAGS,   7 },
    { SzZero,   rtRegular|rtExtended,    1, 0,  CV_REG_FLAGS,   6 },
    { SzACarry, rtRegular|rtExtended,    1, 0,  CV_REG_FLAGS,   4 },
    { SzParity, rtRegular|rtExtended,    1, 0,  CV_REG_FLAGS,   2 },
    { SzCarry,  rtRegular|rtExtended,    1, 0,  CV_REG_FLAGS,   0 },
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp2.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    emdp2.c

Abstract:

    This file contains the some of the machine independent portions of the
    execution model.  The machine dependent portions are in other files.

Author:

    Kent Forschmiedt (kentf) 10-23-92

Environment:

    Win32 -- User

Notes:

    The original source for this came from the CodeView group.

--*/
#include "emdp.h"
#include "resource.h"

#include <stdio.h>

extern CRITICAL_SECTION csCache;


#define DECL_XOSD(n,v,s) {IDS_##n, NULL, n},
static struct _EMERROR {
    UINT    uID;
    LPTSTR  lpsz;
    XOSD    xosd;
} EmErrors[] = {
#include "xosd.h"
};
const int nErrors = (sizeof(EmErrors)/sizeof(*EmErrors));
#undef DECL_XOSD




LPCTSTR
EmError(
    XOSD    xosd
    )
{
    int i = -1; // Not a magic value
    BOOL fFound = FALSE;


    //
    // Do a linear search through the array.  This is not
    // a serious performance issue since there are less than 100
    // errors and we only do this at error time.  
    //
    for (i = 0; i < nErrors && !fFound; i++) {
	if (EmErrors[i].xosd == xosd) {
	    fFound = TRUE;
	}
    }
	i--; // We're left with one i too many otherwise

    if (!fFound) {
	//
	// If it still didn't work, use the first entry
	//
		// The zero'th error is supposed the be xosdNone.  
		//

	i = 0;
	assert (EmErrors[i].xosd == xosdNone);
    }

    if (EmErrors[i].lpsz == NULL) {
	//
	// The string hasn't been loaded, so do it now.
	// How long should it be?
	//
	EmErrors[i].lpsz = (LPTSTR) MHAlloc (_MAX_PATH + 1);
		assert (hInstance);
	if (LoadString (hInstance, EmErrors[i].uID, EmErrors[i].lpsz, _MAX_PATH) == 0) {
			//
			// Resource was not found!
			//
			assert (FALSE);
			return NULL;
		}
    }

    return EmErrors[i].lpsz;
}

VOID
FreeEmErrorStrings(
    VOID
    )
{

    int i;

    for (i = 0; i < nErrors; i++) {
	if (EmErrors[i].lpsz) {
	    MHFree (EmErrors[i].lpsz);
	}
	EmErrors[i].lpsz = NULL;
    }
}



XOSD
LoadFixups (
    HPID  hpid,
    MODULELOAD *lpmdl
    )
/*++

Routine Description:

    This function is called in response to a module load message.  It
    will cause information to be internally setup for doing fixups/
    unfixups ...

Arguments:

    hpid        - Supplies a handle for the process

    lpmdl       - Supplies a pointer to a module load message from the DM

Return Value:

    xosd Error code

--*/

{
    XOSD            xosd = xosdNone;
    HMDI            hmdi;
    MDI *                       lpmdi;
    LPTSTR          lpName;
    HPRC            hprc = HprcFromHpid( hpid );
    HLLI            llmdi = LlmdiFromHprc ( hprc );
    LPPRC           lpprc;
    //DWORD         fIsRemote;
    //LPSTR         p1;
	BOOL			fBar = FALSE;

    hmdi = LLCreate ( llmdi );
    if ( hmdi == 0 ) {
	assert( "load dll cannot create llmdi" && FALSE );
	return xosdOutOfMemory;
    }

    lpmdi = (MDI *)LLLock ( hmdi );

    lpmdi->mte  = lpmdl->mte;
    lpmdi->lpBaseOfDll = (DWORD)lpmdl->lpBaseOfDll;
    lpmdi->dwSizeOfDll = lpmdl->dwSizeOfDll;
    lpmdi->StartingSegment = lpmdl->StartingSegment;

    lpmdi->CSSel  = lpmdl->CSSel;
    lpmdi->DSSel  = lpmdl->DSSel;
    lpmdi->lpBaseOfData = (DWORD)lpmdl->uoffDataBase;
    lpmdi->fRealMode = lpmdl->fRealMode;
    lpmdi->fOffset32 = lpmdl->fOffset32;
    lpmdi->fFlatMode = lpmdl->fFlatMode;
#ifdef OMNI
	lpmdi->fOmniMap = lpmdl->fOmniMap;
#endif
    lpmdi->fSendNLG = FALSE;
    lpmdi->nlg.fEnable = FALSE;
    if (lpmdi->fFlatMode) {
	lpprc = (LPPRC) LLLock( hprc );
	lpprc->selFlatCs = lpmdi->CSSel;
	lpprc->selFlatDs = lpmdi->DSSel;
	LLUnlock( hprc );
    }

    // Thread local storage info (iTls is 1 based)

    lpmdi->isecTLS = lpmdl->isecTLS;
    //lpmdi->iTls = lpmdl->iTls;
    //lpmdi->uoffiTls = lpmdl->uoffiTls;

    //
    // REVIEW:BUG how do we get the count of tls indexes?
    //

    if (lpmdl->uoffiTls) {
	lpprc->cmdlTLS++;
    }

    lpmdi->cobj = lpmdl->cobj;
    lpName = ( (LPTSTR) &( lpmdl->rgobjd[lpmdl->cobj] ) );

	if (*lpName == '|') {
		lpName++;
		fBar = TRUE;
	}

	if (lpName [0] == '#' && lpName [1] == ':' && lpName [2] == '\\') {
		lpmdi->lszName = (char*) MHAlloc (_tcslen (lpName));

		if (fBar) {
			_tcscpy (&lpmdi->lszName [1], lpName + 3);
			lpmdi->lszName [0] = '|';
		} else {
			_tcscpy (lpmdi->lszName, lpName + 3);
		}
		
	} else {
		if (fBar) {
			lpName --;
		}
		lpmdi->lszName = MHStrdup ( lpName );
	}

	lpName = NULL;

    if ( lpmdi->lszName == NULL )  {
	LLUnlock( hmdi );
	assert( "load dll cannot dup mod name" && FALSE );
	return xosdOutOfMemory;
    }

    lpmdi->rgobjd = (LPOBJD) MHAlloc ( sizeof(OBJD) * lpmdi->cobj);
    if ( lpmdi->rgobjd == NULL ) {
	LLUnlock( hmdi );
	assert( "load cannot create rgobjd" && FALSE );
	return xosdOutOfMemory;
    }
    _fmemcpy ( lpmdi->rgobjd,
	       lpmdl->rgobjd,
	       sizeof(OBJD) * lpmdi->cobj);

#ifdef OMNI

#pragma message ("building OMNI")

	// look for section with jit map, load and fixup the pointer to it
	if (lpmdi->fOmniMap) 
	{
		DWORD i;
		for (i = 0; i < lpmdi->cobj; i++)
		{
			DWORD cbOff = 1;
			if (lpmdi->rgobjd[i].pOmniJITMap)
			{
				// read the jit map, its beyond the string and its size is determined 
				// by the size of this section
				lpmdi->rgobjd[i].pOmniJITMap = (DWORD *) MHAlloc(lpmdi->rgobjd[i].cb);
				if ( lpmdi->rgobjd[i].pOmniJITMap == NULL ) {
					LLUnlock( hmdi );
					assert( "load cannot create jitmap" && FALSE );
					return xosdOutOfMemory;
				}
				_fmemcpy((BYTE *)lpmdi->rgobjd[i].pOmniJITMap, lpName + strlen(lpName) + cbOff, 
					lpmdi->rgobjd[i].cb);
				cbOff += lpmdi->rgobjd[i].cb;
			}
		}
	}
#endif

    LLAdd ( llmdi, hmdi );

#if 0
    //
    // If there is an hfile here, regardless of whether the target is
    // remote the hfile must become an OSDEBUG hfile.
    //

    //
    // The string is either "name" or "|name|time|cksum|hfile|imagebase|"
    // If there is an hfile, translate it.
    //

    hfile = -1;

    p1 = _tcschr(p1+1, '|');           // name
    if (p1) {
	p1 = p1 && _tcschr(p1+1, '|'); // time
	p1 = p1 && _tcschr(p1+1, '|'); // cksum
	p1 = p1 && _tcschr(p1+1, '|'); // hfile
	p1 = p1 && (p1 + 1);          //   first digit

	assert(p1 && *p1);

	if (p1) {
	    DWORD dw;
	    assert(p1[8] == '|');  // what, me trust the DM?
	    dw = _tcstoul(p1, &p2, 16);
	    xosd = OSDMakeFileHandle(hpid, dw, &dw);
	    // this can only fail because of xosdOutOfMemory or a bad hpid.
	    assert(xosd == xosdNone);
	    sprintf(p1, "%08X", dw);
	    p1[8] = '|';
	}
    }

    DebugMetric ( hpid, NULL, mtrcRemote, &fIsRemote );

    hfile = SHLocateSymbolFile( lpmdi->lszName, fIsRemote );

    //
    // get the pointer to the debug data (fpo/pdata/omap)
    //

    lpmdi->lpDebug = GetDebugData( hfile );

    //
    // the hfile stays open.  the SH will finish with it later.
    //

#endif // later...

    ((LPPRC)LLLock(hprc))->fLoadingModule = 1;
    LLUnlock(hprc);

    xosd = CallDB (
	dbcModLoad,
	hpid,
	NULL,
	CEXM_MDL_native,
	(UINT) hmdi,
	lpmdi->lszName
    );

    LLUnlock ( hmdi );

    return xosd;
}



XOSD
UnLoadFixups (
    HPID hpid,
    HEMI hemi
    )
/*++

Routine Description:

    This function is called in response to a module unload message.

    It returns the emi of the module being unloaded

Arguments:

    hprc        - Supplies a handle for the process
    hemi        - Supplies hemi (if Unload)

Return Value:

    TRUE if deleted

--*/

{
    HLLI        hlli;
    HMDI        hmdi;


    hlli = LlmdiFromHprc( HprcFromHpid ( hpid ));
    hmdi = LLFind( hlli, 0, (LPVOID)&hemi, (LONG) emdiEMI);

    if (hmdi == hmdiNull) {
	return xosdUnknown;
    } else {
		LPMDI lpmdi = (LPMDI) LLLock( hmdi );
		if ( lpmdi->nlg.fEnable ) {
			XOSD    xosd;
			NLG     nlg;

			lpmdi->nlg.fEnable = FALSE;
			nlg = lpmdi->nlg;

//                      SwapNlg ( &nlg );

			xosd = SendRequestX (
				dmfNonLocalGoto,
				hpid,
				NULL,
				sizeof ( nlg ),
				&nlg
				);
		}
		LLUnlock ( hmdi );
		LLDelete( hlli, hmdi );
		return xosdNone;
	}
}                               /* UnLoadFixups() */




XOSD
CreateThreadStruct (
    HPID hpid,
    TID tid,
    HTID FAR *lphtid
    )
{
    HPRC  hprc  = HprcFromHpid ( hpid );
    LPPRC lpprc = (LPPRC) LLLock ( hprc );
    HTHD  hthd  = hthdNull;
    LPTHD lpthd = NULL;


    hthd = HthdFromTid ( hprc, tid );
    assert(hthd == NULL);
    if ( hthd == hthdNull ) {

	hthd  = LLCreate ( lpprc->llthd );
	lpthd = (LPTHD) LLLock ( hthd );

	CallDB (
	    dbcoCreateThread,
	    hpid,
	    NULL,
	    CEXM_MDL_native,
	    sizeof ( HTID ),
	    (LPVOID)lphtid
	);

	lpthd->htid   = *lphtid;
	lpthd->hprc   = hprc;
	lpthd->tid    = tid;
	lpthd->drt    = drtNonePresent;
	lpthd->dwcbSpecial = lpprc->dmi.cbSpecialRegs;
	if (lpthd->dwcbSpecial) {
	    lpthd->pvSpecial = MHAlloc(lpthd->dwcbSpecial);
	}

	lpthd->regs = MHAlloc(SizeOfContext(hpid));
	lpthd->frameRegs = MHAlloc(SizeOfContext(hpid));

	LLAdd ( lpprc->llthd, hthd );
    }
    else {
	lpthd = (LPTHD) LLLock ( hthd );
	assert ( lpthd->fVirtual == TRUE );
	*lphtid = lpthd->htid;
	lpthd->fVirtual = FALSE;
	lpthd->drt    = drtNonePresent;
    }

    lpthd->fFlat = TRUE;  // Assume flat to start off.

    LLUnlock ( hthd );
    LLUnlock ( hprc );

    return xosdNone;
}                              /* CreateThreadStruct() */


VOID
GetExceptionInfo(
    HPID hpid
    )
/*++

Routine Description:

	Get exception information from DM.

--*/
{
	// ideally this would be a struct of DBB plus an EXCMD, but padding gets
	// in the way
    struct {
		DBB dbb;
		BYTE pad[sizeof(EXCMD)];
	} rgb;
    LPDBB    pdbb = &rgb.dbb;
	LPEXCMD lpcmd = (LPEXCMD)&rgb.dbb.rgbVar;
    LPEXCEPTION_CONTROL lpexc = &lpcmd->exc;
    LPEXCEPTION_DESCRIPTION lpexd = &lpcmd->exd;
    LPEXCEPTION_DESCRIPTION lpexdr;
    HEXD hexd;
    HPRC hprc;
    HLLI llexc;
    LONG lT;
    XOSD xosd;
	LPPRC	lpprc = NULL;

    hprc = HprcFromHpid(hpid);

	if (!hprc) {
		return ;
    }

	lpprc = (LPPRC) LLLock (hprc);

	if (lpprc->fInitedExceptList) {

		//
		// The exception info has alread been initialzied
		//

		LLUnlock (hprc);
		return ;
	}
	
	llexc = lpprc->llexc;

    // force the DMINFO struct to get loaded

    DebugMetric ( hpid, NULL, mtrcProcessorType, &lT );


    // get exception info

    pdbb->dmf  = dmfGetExceptionState;
    pdbb->hpid = hpid;
    pdbb->htid = NULL;
    *lpexc = exfFirst;


    GuardTL();
	do {

		xosd = CallTL (tlfRequest, hpid, sizeof (rgb), &rgb);

		if ((xosd != xosdNone) || (LpDmMsg->xosdRet != xosdNone)) {
			break;
		}

		//
		// add to local exception list
		//

		hexd = LLCreate( llexc );
		LLAdd( llexc, hexd );
		lpexdr = (LPEXCEPTION_DESCRIPTION) LLLock( hexd );
		*lpexdr = *((LPEXCEPTION_DESCRIPTION)(LpDmMsg->rgb));
		LLUnlock( hexd );

		//
		// ask for the next one
		//

		*lpexd = *((LPEXCEPTION_DESCRIPTION)(LpDmMsg->rgb));
		*lpexc = exfNext;

    } while (1); // lpexd->dwExceptionCode != 0); /* 0 is valid exception code */
    ReleaseTL();

	lpprc->fInitedExceptList = TRUE;
	LLUnlock (hprc);
}


XOSD
CreateHprc (
    HPID hpid
    )
{
    XOSD  xosd = xosdNone;
    HPRC  hprc;
    LPPRC lpprc;

    hprc = LLCreate ( llprc );

    if ( hprc == 0 ) {
	return xosdOutOfMemory;
    }

    LLAdd ( llprc, hprc );

    lpprc = (LPPRC) LLLock ( hprc );

    lpprc->stat = statDead;
    lpprc->hpid = hpid;
    lpprc->pid  = (PID) 0;
    lpprc->fDmiCache = 0;

    lpprc->llthd = LLInit (
	sizeof ( THD ),
	llfNull,
	TiDKill,
	TDComp
    );

    if ( lpprc->llthd == 0 ) {
	xosd = xosdOutOfMemory;
    }

    lpprc->llmdi = LLInit ( sizeof ( MDI ), llfNull, MDIKill, MDIComp );

    if ( lpprc->llmdi == 0 ) {
	xosd = xosdOutOfMemory;
    }

    lpprc->llexc = LLInit ( sizeof(EXCEPTION_DESCRIPTION),
			    llfNull,
			    NULL,
			    EXCComp );
    if ( lpprc->llexc == 0 ) {
	xosd = xosdOutOfMemory;
    }

    LLUnlock ( hprc );

    return xosd;
}

VOID
DestroyHprc (
    HPRC hprc
    )
{
    EnterCriticalSection(&csCache);

    LLDelete ( llprc, hprc );
    FlushPTCache();

    LeaveCriticalSection(&csCache);
}

VOID
DestroyHthd(
    HTHD hthd
    )
{
    LPTHD lpthd;
    HPRC  hprc;

    EnterCriticalSection(&csCache);

    lpthd = (LPTHD) LLLock ( hthd );
    hprc = lpthd->hprc;
    LLUnlock ( hthd );
    LLDelete ( LlthdFromHprc ( hprc ), hthd );
    FlushPTCache();

    LeaveCriticalSection(&csCache);
}

void EMENTRY
PiDKill (
    LPVOID lpv
    )
{
    LPPRC lpprc = (LPPRC) lpv;
    LLDestroy ( lpprc->llthd );
    LLDestroy ( lpprc->llmdi );
    LLDestroy ( lpprc->llexc );
}

void EMENTRY
TiDKill (
    LPVOID lpv
    )
{
    LPTHD lpthd = (LPTHD) lpv;

    if (lpthd->pvSpecial) {
	MHFree(lpthd->pvSpecial);
    }

    if (lpthd->regs) {
	MHFree(lpthd->regs);
    }

    if (lpthd->frameRegs) {
	MHFree(lpthd->frameRegs);
    }
}

void EMENTRY
MDIKill(
    LPVOID lpv
    )
{
    LPMDI lpmdi = (LPMDI)lpv;
    if (lpmdi->lszName) {
	MHFree(lpmdi->lszName);
	lpmdi->lszName = NULL;
    }
    if (lpmdi->rgobjd) {
	MHFree(lpmdi->rgobjd);
	lpmdi->rgobjd = NULL;
    }
    if (lpmdi->lpDebug) {
	MHFree(lpmdi->lpDebug);
	lpmdi->lpDebug = NULL;
    }
}


int EMENTRY
PDComp (
    LPVOID lpv1,
    LPVOID lpv2,
    LONG lParam
    )
{

    Unreferenced(lParam);

    if ( ( (LPPRC) lpv1)->hpid == *( (LPHPID) lpv2 ) ) {
	return fCmpEQ;
    }
    else {
	return fCmpLT;
    }
}

int EMENTRY
TDComp (
    LPVOID lpv1,
    LPVOID lpv2,
    LONG lParam
    )
{

    Unreferenced(lParam);

    if ( ( (LPTHD) lpv1)->htid == *( (LPHTID) lpv2 ) ) {
	return fCmpEQ;
    }
    else {
	return fCmpLT;
    }
}


int EMENTRY
MDIComp (
    LPVOID lpv1,
    LPVOID lpv,
    LONG lParam
    )
{
    LPMDI lpmdi = (LPMDI) lpv1;

    switch ( lParam ) {

	case emdiName:
	    if ( !_ftcschr( (const char *) lpv, _T('|') ) ) {
		TCHAR Buffer[MAX_PATH];
		LPTSTR p1,p2;
		p1 = lpmdi->lszName;
		if ( *p1 == _T('|') ) {
		    p1 = _tcsinc(p1);
		}
		p2 = _ftcschr(p1, _T('|'));
		if ( !p2 ) {
		    p2 = p1 + _ftcslen(p1);
		}
		memcpy(Buffer, p1, (p2-p1)*sizeof(TCHAR));
		Buffer[p2-p1]=_T('\0');
		return _tcsicmp ( (const char *) lpv, Buffer );

	    } else {
		return _tcsicmp ( (const char *) lpv, lpmdi->lszName );
	    }

	case emdiEMI:
	    return !(lpmdi->hemi == *(( HEMI FAR * ) lpv ) );

	case emdiMTE:
	    return !(lpmdi->mte == *((LPWORD) lpv ));

	case emdiBaseAddr:
	    return !(lpmdi->lpBaseOfDll == *((OFFSET *) lpv));

		case emdiNLG:
			return !lpmdi->fSendNLG;

	default:
	    return (0);
	    break;
    }
}


int
EMENTRY EXCComp(
    LPVOID lpRec,
    LPVOID lpVal,
    LONG lParam
    )
{
    Unreferenced(lParam);
    if ( ((LPEXCEPTION_DESCRIPTION)lpRec)->dwExceptionCode ==
							*((LPDWORD)lpVal)) {
	return fCmpEQ;
    } else {
	return fCmpLT;
    }
}


DWORD
RvaOmapLookup(
    DWORD   rva,
    LPOMAP  rgomap,
    DWORD   comap
    )
{
    OMAP  *pomapLow;
    OMAP  *pomapHigh;

    pomapLow = rgomap;
    pomapHigh = rgomap + comap;

    while (pomapLow < pomapHigh) {
	unsigned    comapHalf;
	OMAP  *pomapMid;

	comapHalf = comap / 2;

	pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

	if (rva == pomapMid->rva) {
	    return(pomapMid->rvaTo);
	}

	if (rva < pomapMid->rva) {
	    pomapHigh = pomapMid;
	    comap = (comap & 1) ? comapHalf : (comapHalf - 1);
	}

	else {
	    pomapLow = pomapMid + 1;
	    comap = comapHalf;
	}
    }

    assert(pomapLow == pomapHigh);

    // If no exact match, pomapLow points to the next higher address

    if (pomapLow == rgomap) {
	// This address was not found

	return(0);
    }

    if (pomapLow[-1].rvaTo == 0) {
	// This address is in a deleted/inserted range

	return(0);
    }

    // Return the new address plus the bias

    return(pomapLow[-1].rvaTo + (rva - pomapLow[-1].rva));
}

XOSD
GetObjLength(
    HPID hpid,
    LPGOL lpgol
)
{
    SEGMENT segAddr;

    SetEmi ( hpid, lpgol->lpaddr );

    *(lpgol->lplBase) = 0L;
    segAddr  = GetAddrSeg ( *(lpgol->lpaddr) );

    // SwapEndian ( &wSegAddr, sizeof ( wSegAddr ) );

    GuardTL();
    SendRequestX ( dmfSelLim, hpid, NULL, sizeof ( SEGMENT ), &segAddr);

    // SwapEndian ( lpbBuffer, sizeof ( LONG ) );
    *(lpgol->lplLen) = * ( (LONG *) LpDmMsg->rgb );
    ReleaseTL();

    return(xosdNone);
}

// given a section number, find where it started pre-lego
// and return its physical segment
ULONG
FindPreLegoSection(
	LPMDI lpmdi,
	ULONG wSeg,
	WORD *pSeg
)
{
	ULONG iSeg;
	LPGSI lpgsi = lpmdi->lpgsi;
	DWORD LastSectionStart = *(DWORD*)lpmdi->lpDebug->lpOmapTo;
	DWORD LastSectionSize = 0;
	const DWORD ImageAlign = lpmdi->lpDebug->dwOrigAlign;

	for (iSeg=0; iSeg<lpgsi->csgMax; iSeg++)
	{
		if (iSeg==wSeg)
		{
			assert(lpgsi->rgsgi[iSeg].isgPhy>0);
			*pSeg = lpmdi->rgobjd[(lpgsi->rgsgi[iSeg].isgPhy - 1)].wSel;
			return LastSectionStart;
		}

		LastSectionSize = (lpgsi->rgsgi[iSeg].cbSeg + ImageAlign -1) & ~(ImageAlign-1);
		LastSectionStart += LastSectionSize;
	}

	return (ULONG)-1;
}

// given an address in the pre-lego file, find its segment and offset
// returns (ULONG)-1 if failed to find
ULONG
FindPreLegoSegment(
	LPMDI lpmdi,
	ULONG uoff,
	ULONG *pOffset
)
{
	ULONG iSeg;
	LPGSI lpgsi = lpmdi->lpgsi;
	DWORD LastSectionStart = *(DWORD*)lpmdi->lpDebug->lpOmapTo;
	DWORD LastSectionSize = 0;
	const DWORD ImageAlign = lpmdi->lpDebug->dwOrigAlign;

	uoff -= lpmdi->lpBaseOfDll;

	if (uoff >= LastSectionStart)
		for (iSeg=0; iSeg < lpgsi->csgMax; iSeg++)
		{

			LastSectionSize = (lpgsi->rgsgi[iSeg].cbSeg + ImageAlign -1) & ~(ImageAlign-1);

			if (uoff < (LastSectionStart+LastSectionSize) )
			{
				*pOffset = uoff - LastSectionStart;
				return iSeg;
			}

			LastSectionStart += LastSectionSize;
		}

	*pOffset = 0;
	return (ULONG)-1;
}

XOSD
FixupAddr (
    HPID   hpid,
    HTID   htid,
    LPADDR lpaddr
    )
/*++

Routine Description:

    This routine is used to convert addresses between linker index (section
    or segment relative) addresses and real addresses (segment:offset).



Arguments:

    hpid        - Supplies the handle to the process for context to convert
			the address.
    lpaddr      - Pointer to address packet to be converted.

Return Value:

    XOSD error code.

--*/

{
    HMDI  hmdi;
    HPRC  hprc;
    HTHD  hthd;

    hprc = ValidHprcFromHpid(hpid);
    hthd = HthdFromHtid( hprc, htid );


    /*
     *  Check to see if the address is already a segment:offset pair and
     *  return if it is.
     */

    if ( !ADDR_IS_LI(*lpaddr) ) {
	return xosdNone;
    }

    /*
     *  Now based on the emi field of the address (which uniquely defines
     *  the executable module in the symbol handler), get the conversion
     *  information.
     */

    assert( emiAddr( *lpaddr ) != 0 );

    if ( (HPID)emiAddr ( *lpaddr ) == hpid ) {

	ADDR_IS_LI(*lpaddr) = FALSE;

	if (MPTFromHthd(hthd) != mptix86) {
	    /*
	     * The opposite of the code in UnFixupAddr -- Remove the 1
	     *      which was stuck in to make sure we did not think it was
	     *      an absolute
	     */
	    lpaddr->addr.seg = 0;
	}

	emiAddr( *lpaddr ) = 0;
	SetEmi( hpid, lpaddr );
    } else {

	/*
	 * Based on the symbol handler handle find our internal data structure
	 *      for the dll.
	 */

	hmdi = LLFind ( LlmdiFromHprc ( HprcFromHpid(hpid) ), 0,
		       (LPVOID)&emiAddr ( *lpaddr ), (LONG) emdiEMI );

	if ( hmdi == 0 ) {

	    return xosdUnknown ; // Do we need a special xosd for this.
				 // A common case where this will happen is pre-loading symbols.

	} else {

	    LPMDI lpmdi = (LPMDI) LLLock ( hmdi );
	    WORD  wsel;
	    LPSGI lpsgi;
	    unsigned short seg;

	    /*
	     *  If we could not find an internal structure for the DLL
	     *  then it must be some type of error.
	     */

	    if ( lpmdi == NULL ) {
		return xosdUnknown;
	    }

#ifdef OMNI
			if (lpmdi->fOmniMap) {
				DWORD i;
				DWORD off = GetAddrOff(*lpaddr);
			
				for (i = 0; i < lpmdi->cobj; i++) {
					if ((off >= lpmdi->rgobjd[i].rvaOffset) && 
						(off < (lpmdi->rgobjd[i].rvaOffset + lpmdi->rgobjd[i].cb))) {
						GetAddrOff ( *lpaddr ) -= lpmdi->rgobjd[i].rvaOffset;
						if (lpmdi->rgobjd[i].pOmniJITMap) {
							GetAddrOff(*lpaddr) = 
								lpmdi->rgobjd[i].pOmniJITMap[GetAddrOff(*lpaddr) / sizeof(DWORD)]; 
						}
						else {
							GetAddrOff ( *lpaddr ) += lpmdi->rgobjd[i].offset;
						}
						break;
					}
				}
			}
			else
#endif
	    /*
	     *  If the segment/selector is 0 then it must be an absolute
	     *  symbol and we therefore don't need to do any conversion.
	     *
	     *  If we could get no information describing the symbol
	     *  information then we can't do any conversion.
	     */

	    if ( (GetAddrSeg( *lpaddr ) > 0) && (lpmdi->lpgsi) ) {

		/*
		 * Get the linker index number for the segment number
		 *      and assure that it is valid.
		 */

		wsel = (WORD) (GetAddrSeg( *lpaddr ) - 1);
		if ( wsel >= lpmdi->lpgsi->csgMax ) {
		    /*
		     * Linker index is either not valid or not yet loaded
		     */

		    return xosdUnknown;
		}
		else {

		    /*
		     *  We know which section it comes from.  To compute
		     *  the real offset we need to add the following
		     *  items together.
		     *
		     *  original offset                GetAddrOff( *lpaddr )
		     *  offset of index in section     lpsgi->doffseg
		     *      (this is the group offset)
		     *  offset of section from base of rgobjd[physSeg-1].offset
		     *          image
		     *
		     *
		     *  The segment can just be loaded from the MAP.  Notice
		     *  that we will infact "lose" information in this
		     *  conversion sometimes.  Specifically a cs:data address
		     *  after unfixup and fixup will come out ds:data.  This
		     *  is "expected" behavior.
		     */
			if (lpmdi->lpDebug && lpmdi->lpDebug->lpOmapFrom)
			{
				// component has been legoed, so translate logical address
				// using pre-lego section starts
				WORD pSeg;
				DWORD off = FindPreLegoSection( lpmdi, wsel, &pSeg );
				if (off!=(ULONG)-1)
				{
					off = RvaOmapLookup( off + GetAddrOff( *lpaddr ),
				     lpmdi->lpDebug->lpOmapFrom,
				     lpmdi->lpDebug->cOmapFrom
				   );
					if (off)
					{
						GetAddrOff ( *lpaddr ) = off + lpmdi->lpBaseOfDll;
						GetAddrSeg ( *lpaddr ) = pSeg;
						ADDR_IS_REAL(*lpaddr) = (BYTE)lpmdi->fRealMode;
						ADDR_IS_OFF32(*lpaddr) = (BYTE)lpmdi->fOffset32;
						ADDR_IS_FLAT(*lpaddr) = (BYTE)lpmdi->fFlatMode;
						ADDR_IS_LI(*lpaddr) = FALSE;
						return xosdNone;
					}
				}
			}

		    lpsgi = &lpmdi->lpgsi->rgsgi[ wsel ];

            /* The process may have loaded fewer sections than the debug info
             * references.  Throw away references to the lost sections */
            if(lpsgi->isgPhy > lpmdi->cobj) {
                if(!hthd || lpsgi->isgPhy != lpmdi->isecTLS) {
                    LLUnlock(hmdi);
                    return xosdUnknown;
                }
            } else if (lpmdi->rgobjd[(lpsgi->isgPhy-1)].wPad == 0) {
                LLUnlock(hmdi);
			    return xosdUnknown;
		    }

		    GetAddrOff ( *lpaddr ) += lpsgi->doffseg;

		    if ( hthd && lpsgi->isgPhy == lpmdi->isecTLS ) {
			GetAddrOff ( *lpaddr ) += GetTlsBase (
			    hprc,
			    hthd,
			    lpmdi
			    );
			seg = 0;
		    }
		    else {

			GetAddrOff( *lpaddr ) +=
			    (UOFFSET) (lpmdi->rgobjd[ (lpsgi->isgPhy - 1) ]. offset);

			seg = lpmdi->rgobjd[(lpsgi->isgPhy - 1)].wSel;
		    }
		}

		GetAddrSeg ( *lpaddr ) = seg;
	    }

	    /*
	     *  Set the bits describing the address
	     */

	    ADDR_IS_REAL(*lpaddr) = (BYTE)lpmdi->fRealMode;
	    ADDR_IS_OFF32(*lpaddr) = (BYTE)lpmdi->fOffset32;
	    ADDR_IS_FLAT(*lpaddr) = (BYTE)lpmdi->fFlatMode;
	    ADDR_IS_LI(*lpaddr) = FALSE;

	    /*
	     * Now release the module description
	     */

	    LLUnlock ( hmdi );
	}
    }

    return xosdNone;
}                               /* FixupAddr() */


#ifdef OMNI
DWORD GetOffFromOmniJITMap(DWORD offIn, DWORD* pOmniJITMap, DWORD cb)
{
	DWORD i, iLo, iHi;
	signed long iRet;
	iLo = 0;
	iHi = cb / sizeof(DWORD);
	assert(!(offIn & 0xfffffffc));
    while (iLo <= iHi) {
	i = iLo + ((iHi - iLo) / 2);
		iRet = pOmniJITMap[i];

		if (!iRet)
		{
			// try to find a valid midpoint - first look up
			while ((--i >= iLo) && !(iRet = pOmniJITMap[i]));
			if (!iRet) {
				// no luck looking up go down
				i = iLo + ((iHi - iLo) / 2);
				while ((++i <= iHi) && !(iRet = pOmniJITMap[i]));
				assert(!iRet);
			}
		}

		iRet -= offIn;
		if (iRet < 0) {
	    iLo = i + 1;
	} else if (iRet > 0) {
	    iHi = i - 1;
	} else 
			break;
    }
	assert(pOmniJITMap[i] == offIn);
	return (i * sizeof(DWORD));
}
#endif

#ifdef _DEBUG
#define	TEST_FIXUP
#endif

XOSD
UnFixupAddr(
    HPID   hpid,
    HTID   htid,
    LPADDR lpaddr
    )

/*++

Routine Description:

    This routine is called to convert addresses from Real Physical addresses
    to linker index addresses.  Linker index addresses have an advantage
    to the symbol handler in that we know which DLL the address is in.

    The result of calling UnFixupAddr should be one of the following:

    1.  A true Linker Index address.  In this case
	emi == the HEXE (assigned by SH) for the DLL containning the address
	seg == the Section number of the address
	off == the offset in the Section

    2.  Address not in a dll.  In this case
	emi == the HPID of the current process
	seg == the physical selector of the address
	off == the offset in the physical selector

    3.  An error

Arguments:

    hpid   - Supplies the handle to the process the address is in
    lpaddr - Supplies a pointer to the address to be converted.  The
	     address is converted in place

Return Value:

    XOSD error code

--*/

{
    HPRC        hprc;
    HTHD        hthd;
    LPPRC       lpprc;
    LDT_ENTRY   ldt;
    XOSD        xosd;
#ifdef TEST_FIXUP
	ADDR	testAddr = *lpaddr;
#endif

    /*
     *  If the address already has the Linker Index bit set then there
     *  is no work for use to do.
     */


    if ( ADDR_IS_LI(*lpaddr) ) {
	return xosdNone;
    }

    /*
     *  If the EMI field in the address is not already filled in, then
     *  we will now fill it in.
     */

    if ( emiAddr ( *lpaddr ) == 0 ) {
	SetEmi ( hpid, lpaddr );
    }

    /*
     *  Get the internal Process Descriptor structure
     */

    hprc = HprcFromHpid(hpid);
    hthd = HthdFromHtid( hprc, htid );

    /*
     *  Is the EMI we got from the address equal to the process handle?
     *  if so then we cannot unfix the address and should just set the
     *  bits in the mode field.
     */

    if ( (HPID)emiAddr ( *lpaddr ) != hpid ) {
	LPMDI lpmdi;
	HMDI  hmdi = LLFind (LlmdiFromHprc ( hprc ), 0,
			     (LPVOID)&emiAddr ( *lpaddr ), (LONG) emdiEMI);
	WORD            igsn;
	LPSGI           lpsgi;
	ULONG                   ulo;
	USHORT          seg;
	ULONG           iSeg;


	if (hmdi == 0) {
	    /*
	     * If we get here we are really messed up.  We have a valid (?)
	     *  emi field set in the ADDR packeet, it is not the process
	     *  handle, but it does not correspond to a known emi in the
	     *  current process.  Therefore bail out as an error
	     */

	    return xosdUnknown;
	}

	lpmdi = (LPMDI) LLLock ( hmdi );
	if ( lpmdi == NULL ) {
	    return xosdUnknown;
	}

	/*
	 * Start out by using the "default" set of fields.  These
	 *      are based on what our best guess is for the executable
	 *      module.  This is based on what the DM told use when
	 *      it loaded the exe.
	 */

	ADDR_IS_REAL(*lpaddr) = (BYTE)lpmdi->fRealMode;
	ADDR_IS_OFF32(*lpaddr) = (BYTE)lpmdi->fOffset32;
	ADDR_IS_FLAT(*lpaddr) = (BYTE)lpmdi->fFlatMode;

#ifdef OMNI
		if (lpmdi->fOmniMap) {
			DWORD i;
			DWORD off = GetAddrOff(*lpaddr);
			
			for (i = 0; i < lpmdi->cobj; i++) {
				if ((off >= lpmdi->rgobjd[i].offset) && 
					(off < (lpmdi->rgobjd[i].offset + lpmdi->rgobjd[i].cb))) {
					GetAddrOff(*lpaddr) += (lpmdi->rgobjd[i].rvaOffset - lpmdi->rgobjd[i].offset);
					break;
				}
				if (lpmdi->rgobjd[i].pOmniJITMap &&
					(off >=lpmdi->rgobjd[i].pOmniJITMap[0]) &&
					(off < lpmdi->rgobjd[i].pOmniJITMap[lpmdi->rgobjd[i].cb / sizeof (DWORD)])) {
					GetAddrOff(*lpaddr) = 
						GetOffFromOmniJITMap(GetAddrOff(*lpaddr), 
						lpmdi->rgobjd[i].pOmniJITMap, lpmdi->rgobjd[i].cb);
					GetAddrOff(*lpaddr) += lpmdi->rgobjd[i].rvaOffset;
					break;
				}
			}
		}
		else
#endif
	/*
	 *  If there is not table describing the layout of segments in
	 *      the exe, there is no debug information and there fore no
	 *      need to continue this process.
	 */

	if ( lpmdi->lpgsi == NULL ) {
	    LLUnlock( hmdi );
	    emiAddr( *lpaddr ) = (HEMI) hpid;
	    goto itsBogus;
	}

	if (lpmdi->lpDebug && lpmdi->lpDebug->lpOmapTo) {

	    ulo = RvaOmapLookup( lpaddr->addr.off - lpmdi->lpBaseOfDll,
				 lpmdi->lpDebug->lpOmapTo,
				 lpmdi->lpDebug->cOmapTo
			       );

	    if (!ulo) {

				//
		// Address can not be mapped.  Removed by Lego.
		//

				ADDR_IS_LI (*lpaddr) = TRUE;
				lpaddr->emi = (HEMI) hpid;
		LLUnlock ( hmdi );
		return xosdUnknown;
	    }

	    ulo += lpmdi->lpBaseOfDll;

		{
			ULONG seg2, off2;
			seg2 = FindPreLegoSegment( lpmdi, ulo, &off2 );
			if (seg2!=(ULONG)-1)
			{
				GetAddrSeg( *lpaddr ) = (USHORT) (seg2 + 1);
				GetAddrOff( *lpaddr ) = off2;
				ADDR_IS_LI( *lpaddr ) = TRUE;
#ifdef TEST_FIXUP
				{
					ADDR fixedaddr = *lpaddr;
					FixupAddr( hpid, htid, &fixedaddr );
					if (GetAddrSeg( testAddr ))
						assert( GetAddrSeg( fixedaddr ) == GetAddrSeg( testAddr ) );
					assert( GetAddrOff( fixedaddr ) == GetAddrOff( testAddr ) );
				}
#endif
				return xosdNone;
			}
		}

		} else {
		ulo = (ULONG) GetAddrOff( *lpaddr );
		}

	    seg = (USHORT) GetAddrSeg( *lpaddr );
	lpsgi = lpmdi->lpgsi->rgsgi;

		/*
	 *  First correct out the "segment" portion of the offset.
	 *
	 *  For flat addresses this means that we locate which section
	 *      number the address fell in and adjust back to that section
	 *
	 *  For non-flat address this mains locate which segment number
	 *      the selector matches
	 */

	if (ADDR_IS_FLAT( *lpaddr )) {
	    for ( iSeg=0; iSeg < lpmdi->cobj; iSeg++) {
		if ((lpmdi->rgobjd[ iSeg ].offset <= ulo) &&
		    (ulo < (OFFSET) (lpmdi->rgobjd[ iSeg ].offset +
				     lpmdi->rgobjd[ iSeg].cb))) {

		    ulo -= lpmdi->rgobjd[ iSeg ].offset;
		    break;
		}
	    }
	} else {
	    for (iSeg=0; iSeg < lpmdi->cobj; iSeg++) {
		if (lpmdi->rgobjd[iSeg].wSel == seg) {
		    break;
		}
	    }
	}

	if (iSeg == lpmdi->cobj) {
	    // This was not a normal section, so now check to see if it is a TLS section

		LPPRC lpprc = (LPPRC) LLLock ( hprc );

		if ( lpprc->cmdlTLS > 0 ) {
		    UOFFSET uoffT = GetTlsBase (
			hprc,
			hthd,
			lpmdi
			);

		    if (
			uoffT != 0 &&
			GetAddrOff ( *lpaddr ) >= uoffT &&
			GetAddrOff ( *lpaddr ) <  uoffT +
				lpmdi->rgobjd [ lpmdi->isecTLS ].cb
		    ) {
			iSeg = lpmdi->isecTLS - 1;
		    }
		    else {
			lpaddr->mode.fIsLI = TRUE;
			emiAddr ( *lpaddr ) = (HEMI)hpid;
			LLUnlock ( hprc );
			goto itsBogus;
		    }
		}

		LLUnlock ( hprc );

	    emiAddr( *lpaddr ) = (HEMI) hpid;
	    goto itsBogus;
	}

	iSeg += 1;

	for( igsn=0; igsn < lpmdi->lpgsi->csgMax; igsn++, lpsgi++ ) {

	    if ( (ULONG)lpsgi->isgPhy == iSeg &&
		lpsgi->doffseg <= ulo &&
		ulo < lpsgi->doffseg + lpsgi->cbSeg ) {

		GetAddrSeg( *lpaddr ) = (USHORT) (igsn + 1);
		GetAddrOff( *lpaddr ) = ulo - lpsgi->doffseg;

		break;
	    }
	}

	if (igsn == lpmdi->lpgsi->csgMax) {
	    LLUnlock ( hmdi );
	    emiAddr( *lpaddr ) = (HEMI) hpid;
	    goto itsBogus;
	}
	LLUnlock ( hmdi );

    } else {
    itsBogus:
	if (ADDR_IS_REAL( *lpaddr )) {
	    ADDR_IS_FLAT( *lpaddr ) = FALSE;
	    ADDR_IS_OFF32( *lpaddr ) = FALSE;
	} else {
	    /*
	     * See if the segment matches the flat segment.  If it does not
	     *      then we must be in a non-flat segment.
	     */

	    lpprc = (LPPRC) LLLock( hprc );

	    if ((lpaddr->addr.seg == 0) ||
		(lpprc->dmi.fAlwaysFlat) ||
		(lpaddr->addr.seg == lpprc->selFlatCs) ||
		(lpaddr->addr.seg == lpprc->selFlatDs)) {

		ADDR_IS_FLAT(*lpaddr) = TRUE;
		ADDR_IS_OFF32(*lpaddr) = TRUE;
		ADDR_IS_REAL(*lpaddr) = FALSE;

	    } else {

        GuardTL();
		xosd = SendRequestX(dmfQuerySelector, hpid, NULL,
				    sizeof(SEGMENT), &GetAddrSeg(*lpaddr)  );

		if (xosd != xosdNone) {
            ReleaseTL();
		    LLUnlock(hprc);
		    return xosd;
		}

		_fmemcpy( &ldt, LpDmMsg->rgb, sizeof(ldt));
        ReleaseTL();

		ADDR_IS_FLAT(*lpaddr) = FALSE;
		ADDR_IS_OFF32(*lpaddr) = (BYTE) ldt.HighWord.Bits.Default_Big;
		ADDR_IS_REAL(*lpaddr) = FALSE;
	    }
	    LLUnlock( hprc );
	}

	if ( MPTFromHthd(hthd) != mptix86) {

	    /*
	     *      This line is funny.  We assume that all addresses
	     *      which have a segment of 0 to be absolute symbols.
	     *      We therefore set the segment to 1 just to make sure
	     *      that it is not zero.
	     */

	    if (emiAddr(*lpaddr) == (HEMI) hpid) {
	       lpaddr->addr.seg = 1;
	    }
	}
    }

    ADDR_IS_LI(*lpaddr) = TRUE;
    return xosdNone;
}                               /* UnFixupAddr() */



void
UpdateRegisters (
    HPRC hprc,
    HTHD hthd
    )
{
    LPTHD lpthd = (LPTHD) LLLock ( hthd );
    HPID hpid = HpidFromHprc(hprc);
	XOSD xosd;

    GuardTL();
    xosd = SendRequest ( dmfReadReg, hpid, HtidFromHthd ( hthd ) );

	//assert(xosd == xosdNone);
	
	if(xosd == xosdNone){
		_fmemcpy ( lpthd->regs, LpDmMsg->rgb, SizeOfContext(hpid) );
		lpthd->drt = (DRT) (drtCntrlPresent | drtAllPresent);
	} else {
		lpthd->drt = (DRT) drtNonePresent ;
	}
    ReleaseTL();

    LLUnlock ( hthd );
}




void
RegisterEmi (
    HPID   hpid,
    HTID   htid,
    LPREMI lpremi
    )
{
    HLLI     llmdi;
    HMDI     hmdi;
    LPMDI    lpmdi;
    LPSGI    lpsgi;
    LPSGI    lpsgiMax;
    USHORT   usOvlMax = 0;
	ADDR     addr;
    llmdi = LlmdiFromHprc( HprcFromHpid ( hpid ) );
    assert( llmdi != 0 );

    hmdi = LLFind( llmdi, 0, lpremi->lsz, (LONG)emdiName );

    if (hmdi == 0) {
	hmdi = LLFind( llmdi, 0, lpremi->hemi, (LONG)emdiEMI );
    }

    assert( hmdi != 0 );

	if (hmdi == 0) {
		return ;
	}

    lpmdi = (LPMDI) LLLock ( hmdi );
    assert( lpmdi != NULL );

    assert( lpremi->hemi != 0 );

    lpmdi->hemi = lpremi->hemi;


    lpmdi->lpDebug = (LPDEBUGDATA)SHGetDebugData( (HIND)(lpremi->hemi) );

    // Get the GSN info table from the symbol handler
    if ( lpmdi->lpgsi = (LPGSI)SHLpGSNGetTable( (HIND)(lpremi->hemi) ) ) {

#ifdef _DEBUG
	// perform some validation on the segmap as best we can
	// check segnums are OK, and limit sections
	assert( lpmdi->lpgsi->csgMax >= lpmdi->lpgsi->csgLogical );
	assert( lpmdi->lpgsi->csgMax < 500 );
	assert( lpmdi->lpgsi->csgMax !=0 );

	if ( lpmdi->lpgsi->csgMax != lpmdi->lpgsi->csgLogical )
		assert( !"Who put a Group in a segmap?" );			// groups are 16-bit legacy crap

	for (int i=0; i<lpmdi->lpgsi->csgMax; i++)
	{
		assert( lpmdi->lpgsi->rgsgi[i].igr==0 );			// no Groups
		assert( lpmdi->lpgsi->rgsgi[i].iovl==0 );			// no Overlays

		if (lpmdi->lpgsi->rgsgi[i].sgf.u.u1.fSel)			// if Selector
		{
			// check for valid segment numbers
			assert( lpmdi->lpgsi->rgsgi[i].isgPhy>0);
		}
		else if (lpmdi->lpgsi->rgsgi[i].sgf.u.u1.fGroup)
		{
			// groups are obsolete
			assert( !"segment marked as Group was found" );		// strange?
		}
		else
		{
			// Absolutes are OK, but nothing else is
			assert( lpmdi->lpgsi->rgsgi[i].sgf.u.u1.fAbs);	// if not Select, must be Abs
		}
	}
#endif

	//
	//  If real mode, do some patch magic.
	//
	if ( lpmdi->fRealMode ) {

	    int i;

	    lpmdi->cobj   = lpmdi->lpgsi->csgMax+1;
	    lpmdi->rgobjd = (OBJD *) MHRealloc(lpmdi->rgobjd,
				      sizeof(OBJD)*lpmdi->cobj);
	    memset(lpmdi->rgobjd, 0, sizeof(OBJD)*(lpmdi->cobj));

	    lpsgi    = lpmdi->lpgsi->rgsgi;
	    lpsgiMax = lpsgi + lpmdi->lpgsi->csgMax;

	    for( i=0; lpsgi < lpsgiMax; lpsgi++, i++ ) {

		lpmdi->rgobjd[ i ].wSel = (WORD)(lpsgi->doffseg + lpmdi->StartingSegment);
		lpmdi->rgobjd[ i ].wPad = 1;
		lpmdi->rgobjd[ i ].cb   = (DWORD) -1;

		lpsgi->doffseg = 0;

	    }
	}

	// Determine if child is overlaid and, if so, how many overlays
	lpsgi = lpmdi->lpgsi->rgsgi;
	lpsgiMax = lpsgi + lpmdi->lpgsi->csgMax;
	for( ; lpsgi < lpsgiMax; lpsgi++ ) {

	    // iovl == 0xFF is reserved, it means no overlay specified.
	    // we should ignore 0xFF in iovl.  Linker uses it
	    // to (insert lots of hand-waving here) support COMDATS
	    if ( lpsgi->iovl < 0xFF ) {                             // [02]
		usOvlMax = max( usOvlMax, lpsgi->iovl );
	    }
	}
#ifndef TARGET32
	// Setup the overlay table
	if ( usOvlMax ) {
	    lpmdi->lpsel = MHRealloc( lpmdi->lpsel, sizeof( WORD ) * usOvlMax + 1 );
	    _fmemset( &lpmdi->lpsel [ 1 ], 0, sizeof( WORD ) * usOvlMax );
	}
#endif // !TARGET32
    }
	// SHGetPublicAddr will use emi of out parameter to specify
	// which exe/dll to search
	emiAddr( addr ) = lpremi->hemi;
	memset(&lpmdi->nlg, 0, sizeof(lpmdi->nlg));
	if ( SHGetPublicAddr ( &addr, "__NLG_Dispatch")) {
		FixupAddr( hpid, htid, &addr );
		lpmdi->nlg.addrNLGDispatch = addr;
		emiAddr( addr ) = lpremi->hemi;
		if ( SHGetPublicAddr ( &addr, "__NLG_Destination")) {
			FixupAddr( hpid, htid, &addr );
			lpmdi->nlg.addrNLGDestination = addr;
			emiAddr( addr ) = lpremi->hemi;
			lpmdi->fSendNLG = TRUE;
			lpmdi->nlg.fEnable = TRUE;
			lpmdi->nlg.hemi = lpmdi->hemi;
			if ( SHGetPublicAddr ( &addr, "__NLG_Return")) {
				FixupAddr( hpid, htid, &addr );
				lpmdi->nlg.addrNLGReturn = addr;
				emiAddr( addr ) = lpremi->hemi;
			}

			if ( SHGetPublicAddr ( &addr, "__NLG_Return2")) {
			     FixupAddr( hpid, htid, &addr );
			     lpmdi->nlg.addrNLGReturn2 = addr;
			}
		}
	}

	LLUnlock ( hmdi );

    // purge the emi cache (get rid of old, now invalid hpid/emi pairs)
    CleanCacheOfEmi();
}


void
UpdateProcess (
    HPRC hprc
    )
{
    assert ( hprc != NULL );
    EnterCriticalSection(&csCache);

    {
	LPPRC lpprc = (LPPRC) LLLock ( hprc );

	FlushPTCache();

	hprcCurr = hprc;
	hpidCurr = lpprc->hpid;
	pidCurr  = lpprc->pid;
	pointersCurr = PointersFromMPT(lpprc->dmi.Processor.Type);
	mptCurr = lpprc->dmi.Processor.Type;

	LLUnlock ( hprc );
    }
    LeaveCriticalSection(&csCache);
}


void
UpdateThread (
    HTHD hthd
    )
{
    EnterCriticalSection(&csCache);

    if ( hthd == NULL ) {
	FlushPTCache();
    } else {
	LPTHD lpthd = (LPTHD) LLLock ( hthd );

	UpdateProcess ( lpthd->hprc );

	hthdCurr = hthd;
	htidCurr = lpthd->htid;
	tidCurr  = lpthd->tid;

	LLUnlock ( hthd );
    }
    LeaveCriticalSection(&csCache);
}



HEMI
HemiFromHmdi (
    HMDI hmdi
    )
{
    LPMDI lpmdi = (LPMDI) LLLock ( hmdi );
    HEMI  hemi = lpmdi->hemi;

    LLUnlock ( hmdi );
    return hemi;
}


void
FlushPTCache (
    void
    )
{
    EnterCriticalSection(&csCache);

    hprcCurr = NULL;
    hpidCurr = NULL;
    pidCurr  = 0;
    pointersCurr = NULL;
    mptCurr = (MPT)-1;

    hthdCurr = NULL;
    htidCurr = NULL;
    tidCurr =  0;

    LeaveCriticalSection(&csCache);
}


EMEXPORT HPRC
ValidHprcFromHpid(
    HPID hpid
    )
/*++

Routine Description:

    only return an hprc if there is a real process for it.
    the other version will return an hprc whose process has
    not been created or has been destroyed.

Arguments:

    hpid  - Supplies hpid to look for in HPRC list.

Return Value:

    An HPRC or NULL.

--*/
{
    HPRC hprcT;
    HPRC hprc = NULL;
    LPPRC lpprc;

    EnterCriticalSection(&csCache);

    if ( hpid == hpidCurr ) {

	hprc = hprcCurr;

    } else {

	if ( hpid != NULL ) {
	    hprc = LLFind ( llprc, NULL, (LPVOID)&hpid, 0 );
	}

	if ( hprc != NULL ) {
	    lpprc = (LPPRC) LLLock( hprcT = hprc );
	    if (lpprc->stat == statDead) {
		hprc = NULL;
	    }
	    LLUnlock( hprcT );
	}
	if ( hprc != NULL ) {
	    UpdateProcess ( hprc );
	}
    }

    LeaveCriticalSection(&csCache);

    return hprc;
}


HPRC
HprcFromHpid (
    HPID hpid
    )
{
    HPRC hprc = NULL;

    EnterCriticalSection(&csCache);

    if ( hpid == hpidCurr ) {

	hprc = hprcCurr;

    } else {

	if ( hpid != NULL ) {
	    hprc = LLFind ( llprc, NULL, (LPVOID)&hpid, 0 );
	}

	if ( hprc != NULL ) {
	    UpdateProcess ( hprc );
	}
    }

    LeaveCriticalSection(&csCache);

    return hprc;
}


EMEXPORT HPRC
HprcFromPid (
    PID pid
    )
{
    HPRC hprc;

    EnterCriticalSection(&csCache);

    if ( pid == pidCurr ) {

	hprc = hprcCurr;

    } else {

	for ( hprc = LLNext ( llprc, 0 );
	      hprc != 0;
	      hprc = LLNext ( llprc, hprc ) ) {

	    LPPRC lpprc = (LPPRC) LLLock ( hprc );
	    if ( lpprc->pid == pid )
		break;
	    LLUnlock ( hprc );
	}

	if ( hprc) {
	    LLUnlock ( hprc );
	    UpdateProcess ( hprc );
	}
    }

    LeaveCriticalSection(&csCache);

    return hprc;
}


EMEXPORT HPID
HpidFromHprc (
    HPRC hprc
    )
{
    HPID hpid = NULL;

    EnterCriticalSection(&csCache);

    if ( hprc == hprcCurr ) {
	hpid = hpidCurr;
    } else if ( hprc != NULL ) {
	UpdateProcess ( hprc );
	hpid = hpidCurr;
    }

    LeaveCriticalSection(&csCache);

    return hpid;
}


PID
PidFromHprc (
    HPRC hprc
    )
{
    PID pid = 0;

    EnterCriticalSection(&csCache);

    if ( hprc == hprcCurr ) {
	pid = pidCurr;
    } else if ( hprc != NULL ) {
	UpdateProcess ( hprc );
	pid = pidCurr;
    }

    LeaveCriticalSection(&csCache);

    return pid;
}


EMEXPORT HTHD
HthdFromTid (
    HPRC hprc,
    TID tid
    )
{
    LPPRC lpprc;
    HTHD  hthd = NULL;

    EnterCriticalSection(&csCache);

    if ( hprc == hprcCurr && tid == tidCurr ) {
	hthd = hthdCurr;
    } else {
	lpprc = (LPPRC) LLLock ( hprc );

	for ( hthd = LLNext ( lpprc->llthd, 0 );
	      hthd != 0;
	      hthd = LLNext ( lpprc->llthd, hthd ) ) {

	    LPTHD lpthd = (LPTHD) LLLock ( hthd );
	    if ( lpthd->tid == tid )
		break;

	    LLUnlock ( hthd );
	}

	LLUnlock ( hprc );

	if ( hthd ) {
	    LLUnlock ( hthd );
	    UpdateThread ( hthd );
	} else {
	    hthd = NULL;
	}
    }

    LeaveCriticalSection(&csCache);

    return hthd;
}


EMEXPORT HTHD
HthdFromHtid (
    HPRC hprc,
    HTID htid
    )
{
    HTHD  hthd = NULL;

    EnterCriticalSection(&csCache);

    if ((int)htid & 1) {// HACK around vhtid
       htid = (HTID) (((int)htid) ^ 1);
    }
    if ( hprc == hprcCurr && htid == htidCurr ) {
	hthd = hthdCurr;
    } else if ( hprc != NULL ) {
	LPPRC lpprc = (LPPRC) LLLock ( hprc );
	hthd  = LLFind ( lpprc->llthd, NULL, (LPVOID)&htid, 0 );
	LLUnlock ( hprc );
    }
    UpdateThread ( hthd );

    LeaveCriticalSection(&csCache);

    return hthd;
}


EMEXPORT HTID
HtidFromHthd (
    HTHD hthd
    )
{
    HTID htid = NULL;

    EnterCriticalSection(&csCache);

    if ( hthd != hthdCurr ) {
	UpdateThread ( hthd );
    }
    htid = htidCurr;

    LeaveCriticalSection(&csCache);

    return htid;
}


TID
TidFromHthd (
    HTHD hthd
    )
{
    TID tid = 0;

    EnterCriticalSection(&csCache);

    if ( hthd != hthdCurr ) {
	UpdateThread ( hthd );
    }
    tid = tidCurr;

    LeaveCriticalSection(&csCache);

    return tid;
}

EMEXPORT HPID
HpidFromHthd(
    HTHD hthd
    )
{
    HPID hpid = NULL;

    EnterCriticalSection(&csCache);

    if (hthd != hthdCurr) {
	UpdateThread( hthd );
    }
    hpid = hpidCurr;

    LeaveCriticalSection(&csCache);

    return hpid;
}

HLLI
LlthdFromHprc (
    HPRC hprc
    )
{
    HLLI llthd = 0;

    if ( hprc != NULL ) {
	LPPRC lpprc = (LPPRC) LLLock ( hprc );
	llthd = lpprc->llthd;
	LLUnlock ( hprc );
    }

    return llthd;
}

HLLI
LlmdiFromHprc (
    HPRC hprc
    )
{
    HLLI llmdi = 0;

    if ( hprc != NULL ) {
	LPPRC lpprc = (LPPRC) LLLock ( hprc );
	llmdi = lpprc->llmdi;
	LLUnlock ( hprc );
    }

    return llmdi;
}

STAT
StatFromHprc (
    HPRC hprc
    )
{
    LPPRC lpprc = (LPPRC) LLLock ( hprc );
    STAT  stat  = lpprc->stat;
    LLUnlock ( hprc );
    return stat;
}

MPT
MPTFromHthd(
    HTHD hthd
    )
{
    MPT m = (MPT)-1;
    EnterCriticalSection(&csCache);
    if (hthd != hthdCurr) {
	UpdateThread(hthd);
    }
    m = mptCurr;
    LeaveCriticalSection(&csCache);
    return m;
}

MPT
MPTFromHprc(
    HPRC hprc
    )
{
    MPT m = (MPT)-1;
    EnterCriticalSection(&csCache);
    if (hprc != hprcCurr) {
	UpdateProcess(hprc);
    }
    m = mptCurr;
    LeaveCriticalSection(&csCache);
    return m;
}


PCPU_POINTERS
PointersFromMPT(
    MPT mpt
    )
{
    //_asm int 3
	extern CPU_POINTERS X86Pointers;
//	extern CPU_POINTERS PpcPointers;
//	extern CPU_POINTERS MipsPointers;

	//
	// NOTE: MIPS and PPC are no longer supported.
	//

	switch (mpt) {
	case mptix86:
	    return &X86Pointers;

	default:
	    return NULL;
    }
}

PCPU_POINTERS
PointersFromHpid(
    HPID hpid
    )
{
    PCPU_POINTERS p = NULL;

    EnterCriticalSection(&csCache);

    if (hpid == hpidCurr || ValidHprcFromHpid(hpid)) {
	p = pointersCurr;
    }

    LeaveCriticalSection(&csCache);

    return p;
}

//**************************************************************************
//
// global stack walking api support functions
//
// these are the callbacks used by imagehlp.dll
//
// there are custom callbacks in each of the emdpdev.c files
//
//**************************************************************************


BOOL
SwReadMemory(
    LPVOID  lpvhpid,
    LPCVOID lpBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    )
{
    ADDR   addr;
    DWORD  cb;
    XOSD   xosd;
    HPID   hpid = (HPID)lpvhpid;

    addr.addr.off     = (OFFSET)lpBaseAddress;
    addr.addr.seg     = 0;
    addr.emi          = 0;
    addr.mode.fFlat   = TRUE;
    addr.mode.fOff32  = FALSE;
    addr.mode.fIsLI   = FALSE;
    addr.mode.fReal   = FALSE;

    xosd = ReadBuffer( hpid, NULL, &addr, nSize, (LPBYTE) lpBuffer, &cb );
    if (xosd != xosdNone) {
	return FALSE;
    }

    if (lpNumberOfBytesRead) {
	*lpNumberOfBytesRead = cb;
    }

    return TRUE;
}


HMDI
SwGetMdi(
    HPID    hpid,
    DWORD   Address
    )
{
    HLLI        hlli  = 0;
    HMDI        hmdi  = 0;
    LPMDI       lpmdi = NULL;


    hlli = LlmdiFromHprc( HprcFromHpid ( hpid ));

    do {

	hmdi = LLNext( hlli, hmdi );
	if (hmdi) {
	    lpmdi = (LPMDI)LLLock( hmdi );
	    if (lpmdi) {
		//
		// we have a pointer to a module so lets see if its the one...
		//
		if (Address >= lpmdi->lpBaseOfDll &&
		    Address <  lpmdi->lpBaseOfDll+lpmdi->dwSizeOfDll ) {

		    LLUnlock( hmdi );
		    return hmdi;

		}
		LLUnlock( hmdi );
	    }
	}

    } while (hmdi);

    return 0;
}


DWORD
SwGetModuleBase(
    LPVOID  lpvhpid,
    DWORD   ReturnAddress
    )
{
    HMDI        hmdi  = 0;
    LPMDI       lpmdi = NULL;
    HPID        hpid = (HPID)lpvhpid;
    DWORD state;

    hmdi = SwGetMdi( hpid, ReturnAddress );
    if (hmdi) {
		lpmdi = (LPMDI) LLLock( hmdi );
		if (lpmdi) {
		LLUnlock( hmdi );
		return lpmdi->lpBaseOfDll;
		}
    }

	// [apennell] VS98:6541 (and others)
	// returning zero here causes premature truncation of the callstack, so
	// if we like the look of the address we return the exe start address
	// even if it doesn't lie in a recognised code area

	if (ReturnAddress < 0x00010000)
		return 0;							// all below 64k on both OSes are illegal

	// is it readable memory? Use VirtualQueryEx, via the DM
	ADDR addr = {0};
	SetAddrOff( &addr, ReturnAddress );
	ADDRLIN32( addr );

    GuardTL();
	XOSD xosd = SendRequestX( dmfVirtualQuery, hpid, 0, sizeof(ADDR),
                                                              (LPVOID)&addr );
    if (xosd != xosdNone) {
        ReleaseTL();
		return 0;
    }

	PMEMORY_BASIC_INFORMATION lpmbi = (PMEMORY_BASIC_INFORMATION) LpDmMsg->rgb;
    state = lpmbi->State;
    ReleaseTL();

	if (state!=MEM_COMMIT)
		return 0;

	// lets return the start of the exe, which is the first mdi in the list
    HLLI        hlli  = 0;

    hlli = LlmdiFromHprc( HprcFromHpid ( hpid ));

	hmdi = LLNext( hlli, hmdi );
	if (!hmdi)
		return 0;

	lpmdi = (LPMDI)LLLock( hmdi );
	if (!lpmdi)
		return 0;

	return lpmdi->lpBaseOfDll;
}

// TLS
#if 0
XOSD
InitTLS (
    HPRC hprc,
    HTHD hthd
    )
{
    LPPRC   lpprc = (LPPRC) LLLock ( hprc );
    LPTHD   lpthd = (LPTHD) LLLock ( hthd );
    ADDR    addr  = {0};
    UINT    cb    = 0;
    XOSD    xosd  = xosdNone;

    if ( lpthd->uoffTEB == 0 ) {
	xosd = xosdBadThread;
    }
    else {

	GetAddrOff ( addr ) = lpthd->uoffTEB;
	ADDR_IS_OFF32( addr ) = TRUE;
	ADDR_IS_FLAT ( addr ) = TRUE;

	ReadBuffer ( lpprc->hpid, lpthd->htid, &addr, sizeof ( UOFFSET ), (LPBYTE) &GetAddrOff ( addr ), (LPDWORD) &cb);

	if ( cb != sizeof ( UOFFSET ) ) {
	    xosd = xosdRead;
	}
    }

    if ( xosd == xosdNone && GetAddrOff ( addr ) != 0 ) {
	lpthd->rguoffTlsBase = (UOFFSET *) MHAlloc ( lpprc->cmdlTLS * sizeof ( UOFFSET ) );

	ReadBuffer ( lpprc->hpid, lpthd->htid, &addr, lpprc->cmdlTLS * sizeof ( UOFFSET ), (LPBYTE)lpthd->rguoffTlsBase, (LPDWORD) &cb);

	if ( cb != lpprc->cmdlTLS * sizeof ( UOFFSET ) ) {
	    xosd = xosdRead;
	}
    }

    LLUnlock ( hprc );
    LLUnlock ( hthd );

    return xosd;
}

XOSD
ReadTlsIndex(
    HPRC hprc,
    LPADDR lpAddr,
    DWORD FAR * lpiTls,
    UTLSCACHE *puTlsCache
    )
{
    LPPRC pprc = (LPPRC) LLLock( hprc );
    DWORD iTls;
    DWORD cb;
    XOSD xosd = xosdNone;

    assert(hprc != hprcInvalid && hprc != hprcNull);
    assert(!ADDR_IS_LI(*lpAddr));

    if ( pprc->stat == statRunning ) {
	    // Always fetch a new value if we are running.
	    xosd = ReadBuffer(pprc->hpid, NULL, lpAddr, sizeof (iTls), (LPBYTE)&iTls, &cb);
        puTlsCache->fValid = FALSE;

	    // This is not required but invalidate the tls cache anyway.
	    pprc->iTlsCache.fValid = FALSE;
    }
    else {

	    // If the cache is not valid or the addresses don't match fetch a new value.
	    if ( !pprc->iTlsCache.fValid || !FAddrsEq(*lpAddr, pprc->iTlsCache.addr) ) {
	        xosd = ReadBuffer(pprc->hpid, NULL, lpAddr, sizeof( iTls), (LPBYTE)&(pprc->iTlsCache.iTls), &cb);
	        if ( xosd == xosdNone && cb == sizeof(iTls) ) {
		        pprc->iTlsCache.addr = *lpAddr ;
		        pprc->iTlsCache.fValid = TRUE;
                puTlsCache->fValid = FALSE;
            } else {
    	        pprc->iTlsCache.fValid = FALSE;
	        }
    	}
    	iTls =  pprc->iTlsCache.iTls;
    }

    LLUnlock( hprc );

    if(iTls != *lpiTls)
        puTlsCache->fValid = FALSE;
    *lpiTls = iTls;
    return xosd;
}
#endif

UOFFSET
GetTlsBase (
    HPRC hprc,
    HTHD hthd,
    LPMDI lpmdi
    )
{
    LPTHD   lpthd = (LPTHD) LLLock ( hthd );
    UOFFSET uoffRet = 0;
    LPPRC   lpprc = (LPPRC) LLLock ( hprc );
    ADDR    addr = {0};
    XOSD xosd;
    DWORD cb;

    // freshen the iTls value with the value from the data section
    assert ( lpthd->uoffTEB );

#if 0
    GetAddrOff ( addr ) = lpmdi->uoffiTls;
    GetAddrSeg ( addr ) = 0; //lpthd->regx86.ds;
    emiAddr ( addr ) = 0;
    ADDR_IS_OFF32 ( addr ) = TRUE;
    ADDR_IS_FLAT( addr ) = TRUE;
    xosd = ReadTlsIndex ( hprc, &addr, &lpmdi->iTlsIndex, &lpthd->uTlsCache);
#endif

    GetAddrOff(addr) = lpthd->uoffTEB;
    ADDR_IS_FLAT(addr) = TRUE;
    xosd = ReadBuffer(lpprc->hpid, lpthd->htid, &addr, sizeof(UOFFSET),
        (LPBYTE)&lpthd->uTlsCache.uoffTls, &cb);
    if(xosd == xosdNone && cb == sizeof(UOFFSET))
	    uoffRet = lpthd->uTlsCache.uoffTls;

    LLUnlock ( hprc );
    LLUnlock ( hthd );

    return uoffRet;
}



XOSD
GetFrameRegValue (
    HPID hpid,
    HTID htid,
    DWORD ireg,
    LPVOID lpvRegValue
    )
{
    LPTHD       lpthd;
    HTHD hthd = HthdFromHtid(HprcFromHpid(hpid), htid);

    assert ( hthd != hthdNull );

    lpthd = (LPTHD) LLLock ( hthd );

    lpvRegValue = DoGetReg(hpid, lpthd->frameRegs, ireg & 0xff, lpvRegValue );

    if ( lpvRegValue != NULL ) {
	ireg = ireg >> 8;
	if ( ireg != CV_REG_NONE ) {
	    lpvRegValue = DoGetReg( hpid, lpthd->frameRegs, ireg, lpvRegValue );
	}
    }

    LLUnlock ( hthd );

    if ( lpvRegValue == NULL ) {
	return xosdInvalidParameter;
    }

    return xosdNone;
}                             /* GetFrameRegValue */




XOSD
XXSetFlagValue (
    HPID   hpid,
    HTID   htid,
    DWORD  iFlag,
    LPVOID lpvRegValue
    )
{
    HPRC        hprc;
    HTHD        hthd;
    LPTHD       lpthd;
    LPVOID      lpregs;
    LONG        mask;
    LONG        l;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
	return xosdBadProcess;
    }
    hthd = HthdFromHtid(hprc, htid);
    assert ( hthd != hthdNull );

    lpthd = (LPTHD) LLLock( hthd );

    lpregs = lpthd->regs;

    if ( !( lpthd->drt & drtAllPresent )) {
	UpdateRegisters ( lpthd->hprc, hthd );
    }


    if ( DoGetReg( hpid, lpregs, Rgfd(hpid)[iFlag].fd.dwId, &l ) == NULL) {
	LLUnlock( hthd );
	return xosdInvalidParameter;
    }

    mask = (1 << Rgfd(hpid)[iFlag].fd.dwcbits) - 1;
    mask <<= Rgfd(hpid)[iFlag].iShift;
    l &= ~mask;
    l |= ((*((ULONG FAR *) lpvRegValue)) << Rgfd(hpid)[iFlag].iShift) & mask;
    DoSetReg(hpid, lpregs, Rgfd(hpid)[iFlag].fd.dwId, &l );

    lpthd->drt = (DRT) (lpthd->drt | drtAllDirty);
    LLUnlock ( hthd );
    return xosdNone;
}                             /* SetFlagValue */


XOSD
XXGetFlagValue (
    HPID hpid,
    HTID htid,
    DWORD iFlag,
    LPVOID lpvRegValue
    )
{
    HPRC      hprc;
    HTHD      hthd;
    LPTHD     lpthd;
    LPCONTEXT lpregs;
    DWORD     value;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
	return xosdBadProcess;
    }
    hthd = HthdFromHtid(hprc, htid);

    assert ( hthd != NULL );
    lpthd = (LPTHD) LLLock ( hthd );

    lpregs = (LPCONTEXT) lpthd->regs;

    if ( !(lpthd->drt & drtAllPresent) ) {
	UpdateRegisters ( hprc, hthd );
    }

    if (DoGetReg ( hpid, lpregs, Rgfd(hpid)[iFlag].fd.dwId, &value ) == NULL) {
	LLUnlock( hthd );
	return xosdInvalidParameter;
    }

    value = (value >> Rgfd(hpid)[iFlag].iShift) & ((1 << Rgfd(hpid)[iFlag].fd.dwcbits) - 1);
    *( (LPLONG) lpvRegValue) = value;

    LLUnlock(hthd);
    return xosdNone;
}




DWORD
ConvertOmapFromSrc(
    LPMDI       lpmdi,
    DWORD       addr
    )
{
    DWORD   rva;
    DWORD   comap;
    LPOMAP  pomapLow;
    LPOMAP  pomapHigh;
    DWORD   comapHalf;
    LPOMAP  pomapMid;


    if (!lpmdi) {
	return addr;
    }

    if ( lpmdi->lpgsi == NULL ) {
	SHWantSymbols( (HEXE)lpmdi->hemi );
	lpmdi->lpgsi = (LPGSI)SHLpGSNGetTable( (HEXE)lpmdi->hemi );
    }

    if ((!lpmdi->lpDebug) || (!lpmdi->lpDebug->lpOmapFrom)) {
	return addr;
    }

    rva = addr - lpmdi->lpBaseOfDll;

    comap = lpmdi->lpDebug->cOmapFrom;
    pomapLow = lpmdi->lpDebug->lpOmapFrom;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

	comapHalf = comap / 2;

	pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

	if (rva == pomapMid->rva) {
	    return lpmdi->lpBaseOfDll + pomapMid->rvaTo;
	}

	if (rva < pomapMid->rva) {
	    pomapHigh = pomapMid;
	    comap = (comap & 1) ? comapHalf : (comapHalf - 1);
	} else {
	    pomapLow = pomapMid + 1;
	    comap = comapHalf;
	}
    }

    assert(pomapLow == pomapHigh);

    //
    // If no exact match, pomapLow points to the next higher address
    //
    if (pomapLow == lpmdi->lpDebug->lpOmapFrom) {
	//
	// This address was not found
	//
	return 0;
    }

    if (pomapLow[-1].rvaTo == 0) {
	//
	// This address is not translated so just return the original
	//
	return addr;
    }

    //
    // Return the closest address plus the bias
    //
    return lpmdi->lpBaseOfDll + pomapLow[-1].rvaTo + (rva - pomapLow[-1].rva);
}


DWORD
ConvertOmapToSrc(
    LPMDI       lpmdi,
    DWORD       addr
    )
{
    DWORD   rva;
    DWORD   comap;
    LPOMAP  pomapLow;
    LPOMAP  pomapHigh;
    DWORD   comapHalf;
    LPOMAP  pomapMid;
    INT     i;


    if (!lpmdi) {
	return addr;
    }

    if ( lpmdi->lpgsi == NULL ) {
	SHWantSymbols( (HEXE)lpmdi->hemi );
	lpmdi->lpgsi = (LPGSI)SHLpGSNGetTable( (HEXE)lpmdi->hemi );
    }

    if ((!lpmdi->lpDebug) || (!lpmdi->lpDebug->lpOmapTo)) {
	return addr;
    }

    rva = addr - lpmdi->lpBaseOfDll;

    comap = lpmdi->lpDebug->cOmapTo;
    pomapLow = lpmdi->lpDebug->lpOmapTo;
    pomapHigh = pomapLow + comap;

    while (pomapLow < pomapHigh) {

	comapHalf = comap / 2;

	pomapMid = pomapLow + ((comap & 1) ? comapHalf : (comapHalf - 1));

	if (rva == pomapMid->rva) {
	    if (pomapMid->rvaTo == 0) {
		//
		// We are probably in the middle of a routine
		//
		i = -1;
		while ((&pomapMid[i] != lpmdi->lpDebug->lpOmapTo) && pomapMid[i].rvaTo == 0) {
		    //
		    // Keep on looping back until the beginning
		    //
		    i--;
		}
		return lpmdi->lpBaseOfDll + pomapMid[i].rvaTo;
	    } else {
		return lpmdi->lpBaseOfDll + pomapMid->rvaTo;
	    }
	}

	if (rva < pomapMid->rva) {
	    pomapHigh = pomapMid;
	    comap = (comap & 1) ? comapHalf : (comapHalf - 1);
	} else {
	    pomapLow = pomapMid + 1;
	    comap = comapHalf;
	}
    }

    assert(pomapLow == pomapHigh);

    //
    // If no exact match, pomapLow points to the next higher address
    //
    if (pomapLow == lpmdi->lpDebug->lpOmapTo) {
	//
	// This address was not found
	//
	return 0;
    }

    if (pomapLow[-1].rvaTo == 0) {
	return 0;
    }

    //
    // Return the new address plus the bias
    //
    return lpmdi->lpBaseOfDll + pomapLow[-1].rvaTo + (rva - pomapLow[-1].rva);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emproto.h ===
XOSD FAR PASCAL EMFunc ( EMF, HPID, HTID, DWORD, LONG );

XOSD
DebugPacket (
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD wValue,
    LPBYTE lpb
    );

// EMEXPORT is used to export native EM fns to NMs
#ifndef EMEXPORT
#define EMEXPORT __declspec( dllexport )
#endif

EMEXPORT HPRC ValidHprcFromHpid ( HPID );
EMEXPORT HPID HpidFromHprc ( HPRC );
EMEXPORT HTID HtidFromHthd ( HTHD );
EMEXPORT HPRC HprcFromHpid ( HPID );
EMEXPORT HPRC HprcFromPid ( PID );
EMEXPORT HTHD HthdFromHtid ( HPRC, HTID );
EMEXPORT HTHD HthdFromTid ( HPRC, TID );
EMEXPORT HPID HpidFromHthd(HTHD);
EMEXPORT XOSD SendRequest ( DMF, HPID, HTID );
EMEXPORT XOSD SendRequestX ( DMF dmf, HPID hpid, HTID htid, DWORD wLen, LPVOID lpv );

PID  PidFromHprc ( HPRC );
TID  TidFromHthd ( HTHD );
void FlushPTCache ( void );
void PurgeCache ( void );
HLLI LlthdFromHprc ( HPRC );
HLLI LlmdiFromHprc ( HPRC );
STAT StatFromHprc ( HPRC );

VOID GetExceptionInfo( HPID hpid );

HMDI SwGetMdi( HPID hpid, DWORD Address );


XOSD Go ( HPID, HTID, LPEXOP );
XOSD SingleStep ( HPID, HTID, LPEXOP );
XOSD RangeStep ( HPID, HTID, LPRSS );
XOSD ReturnStep ( HPID, HTID, LPEXOP );
XOSD WriteBufferCache ( HPID, HTID, LPADDR, DWORD, LPBYTE, LPDWORD );
XOSD WriteBuffer ( HPID, HTID, LPADDR, DWORD, LPBYTE, LPDWORD );
XOSD CompareAddrs( HPID, HTID, LPCAS );
XOSD UpdateChild ( HPID, HTID, DMF );
XOSD ProcessStatus( HPID, LPPST );
XOSD GetTimeStamp (HPID, HTID, LPTCS);
XOSD EMCreateUserCrashDump (HPID, HTID, LPTSTR);

XOSD ThreadStatus ( HPID hpid, HTID htid, LPTST lptst );
XOSD GetExceptionState(HPID, HTID, EXCEPTION_CONTROL, LPEXCEPTION_DESCRIPTION);
XOSD SetExceptionState( HPID, HTID, LPEXCEPTION_DESCRIPTION );
XOSD HandleBreakpoints( HPID hpid, DWORD wValue, LONG lValue );
XOSD FreezeThread( HPID hpid, HTID htid, BOOL fFreeze );
XOSD GetMemoryInfo( HPID hpid, HTID htid, LPMEMINFO lpmi );
XOSD GetModuleList( HPID, HTID, LPTSTR, LPMODULE_LIST FAR * );
XOSD DoContinue( HPID hpid );
XOSD UnLoadFixups ( HPID, HEMI );
XOSD SystemService(HPID hpid, HTID htid, DWORD wValue, LPSSS lpsss);
XOSD GetFrameRegValue (HPID hpid, HTID htid, DWORD ireg, LPVOID lpvRegValue);

int EMENTRY EXCComp(LPVOID, LPVOID, LONG);


XOSD ProgramLoad ( HPID, DWORD, LPPRL );
XOSD DebugActive ( HPID, DWORD, LPVOID );
XOSD ProgramFree ( HPID, HTID );
XOSD GetAddr ( HPID, HTID, ADR, LPADDR );
XOSD SetAddr ( HPID, HTID, ADR, LPADDR );
XOSD SetAddrFromCSIP ( HTHD hthd );
XOSD SetWatchPoint ( HPID, HTID, DWORD );
XOSD RemoveWatchPoint ( HPID, HTID, DWORD );
void InitUsage ( void );
XOSD ReadBuffer ( HPID, HTID, LPADDR, DWORD, LPBYTE, LPDWORD );
void UpdateRegisters ( HPRC, HTHD );
void UpdateSpecialRegisters ( HPRC hprc, HTHD hthd );
XOSD DoGetContext( HPID hpid, HTID htid, LPVOID  lpv );
XOSD DoSetContext( HPID hpid, HTID htid, LPVOID  lpv );
XOSD LoadFixups ( HPID, MODULELOAD *);
void RegisterEmi ( HPID, HTID, LPREMI );
XOSD CreateThreadStruct ( HPID, TID, HTID FAR * );
XOSD CreateHprc ( HPID );
VOID DestroyHprc ( HPRC );
VOID DestroyHthd ( HTHD );

XOSD
XXSetFlagValue (
    HPID   hpid,
    HTID   htid,
    DWORD  iFlag,
    LPVOID lpvRegValue
    );

XOSD
XXGetFlagValue (
    HPID hpid,
    HTID htid,
    DWORD iFlag,
    LPVOID lpvRegValue
    );

void EMENTRY PiDKill ( LPVOID );
void EMENTRY TiDKill ( LPVOID );
void EMENTRY MDIKill(LPVOID lpv);
int  EMENTRY PDComp ( LPVOID, LPVOID, LONG );
int  EMENTRY TDComp ( LPVOID, LPVOID, LONG );
int  EMENTRY BPComp ( LPVOID, LPVOID, LONG );
int  EMENTRY TBComp ( LPVOID, LPVOID, LONG );
int  EMENTRY MDIComp ( LPVOID, LPVOID, LONG );

XOSD DebugMetric ( HPID, HTID, MTRC, LPLONG );
XOSD FixupAddr ( HPID, HTID, LPADDR );
XOSD UnFixupAddr ( HPID, HTID, LPADDR );
XOSD SetEmi ( HPID, LPADDR );
XOSD SetFlagValue ( HPID, HTID , DWORD , LPVOID );


XOSD WMSGTranslate( LPWORD, LPWORD, LPTSTR, LPWORD );

HEMI HemiFromHmdi ( HMDI );
XOSD GetPrevInst ( HPID, HTID, LPADDR );

XOSD Disasm ( HPID, HTID, LPSDI );
XOSD BackDisasm( HPID hpid, HTID htid, LPGPIS lpgpis );


XOSD IsCall ( HPID, HTID, LPADDR, LPDWORD );

XOSD Assemble ( HPID, HTID, LPADDR, LPTSTR );                          // [00]

BOOL UpdateFPRegisters ( HPRC, HTHD );
XOSD CleanCacheOfEmi ( void );


XOSD SetPath ( HPID, HTID, BOOL, LPTSTR );
VOID FreeEmErrorStrings( VOID );
LPCTSTR EmError(XOSD xosd);
XOSD EnableCache( HPID  hpid, HTID  htid, BOOL  state );

DWORD GetMessageMask(DWORD);

LPTSTR MHStrdup(LPTSTR lptstr);
VOID InvalidateTlsIndexCache( HPRC );
XOSD ReadTlsIndex(HPRC, LPADDR, DWORD *, UTLSCACHE *);
UOFFSET GetTlsBase ( HPRC, HTHD, LPMDI);

XOSD
GetObjLength(
    HPID hpid,
    LPGOL lpgol
);

DWORD
ConvertOmapFromSrc(
    LPMDI       lpmdi,
    DWORD       addr
    );

DWORD
ConvertOmapToSrc(
    LPMDI       lpmdi,
    DWORD       addr
    );

//*************************************************************************
//
// stack walking apis
//
//*************************************************************************
BOOL
SwReadMemory(
    LPVOID  lpvhpid,
    LPCVOID lpBaseAddress,
    LPVOID  lpBuffer,
    DWORD   nSize,
    LPDWORD lpNumberOfBytesRead
    );

LPVOID
SwFunctionTableAccess(
    LPVOID  lpvhpid,
    DWORD   AddrBase
    );

DWORD
SwGetModuleBase(
    LPVOID  lpvhpid,
    DWORD   ReturnAddress
    );

DWORD
SwTranslateAddress(
    LPVOID    lpvhpid,
    LPVOID    lpvhtid,
    LPADDRESS lpaddr
    );


//
// helper functions for CPU-specific code
//

MPT
MPTFromHthd(
    HTHD hthd
    );

MPT
MPTFromHprc(
    HPRC hprc
    );

PCPU_POINTERS
PointersFromMPT(
    MPT mpt
    );

PCPU_POINTERS
XXPointersFromHprc(
    HPRC hprc
    );

PCPU_POINTERS
PointersFromHpid(
    HPID hpid
    );


//
// macros for CPU-specific functions
//

//#define PointersFromHpid(hpid) ((hpid == hpidCurr)? \
    //(pointersCurr): (ValidHprcFromHpid(hpid)?pointersCurr:((PCPU_POINTERS)0)))

#define GetAddr(hpid, htid, adr, lpaddr)    (PointersFromHpid(hpid)->pfnGetAddr(hpid, htid, adr, lpaddr))
#define SetAddr(hpid, htid, adr, lpaddr)    (PointersFromHpid(hpid)->pfnSetAddr(hpid, htid, adr, lpaddr))
#define DoGetReg(hpid, lpregs, reg, lpv)    (PointersFromHpid(hpid)->pfnDoGetReg(lpregs, reg, lpv))
#define GetRegValue(hpid, htid, reg, lpv)   (PointersFromHpid(hpid)->pfnGetRegValue(hpid, htid, reg, lpv))
#define DoSetReg(hpid, lpregs, reg, lpv)    (PointersFromHpid(hpid)->pfnDoSetReg(lpregs, reg, lpv))
#define SetRegValue(hpid, htid, reg, lpv)   (PointersFromHpid(hpid)->pfnSetRegValue(hpid, htid, reg, lpv))
#define GetFlagValue(hpid, htid, flag, lpv) (PointersFromHpid(hpid)->pfnGetFlagValue(hpid, htid, flag, lpv))
#define SetFlagValue(hpid, htid, flag, lpv) (PointersFromHpid(hpid)->pfnSetFlagValue(hpid, htid, flag, lpv))
#define GetFrame(hpid, htid, wval, lval)    (PointersFromHpid(hpid)->pfnGetFrame(hpid, htid, wval, lval))
#define UpdateChild(hpid, htid, dmf)        (PointersFromHpid(hpid)->pfnUpdateChild(hpid, htid, dmf))
#define GetFrameEH(hpid, htid, ppex, addr)  (PointersFromHpid(hpid)->pfnGetFrameEH(hpid, htid, ppex, addr))
#define CopyFrameRegs(hpid, lpthd, lpbpr)   (PointersFromHpid(hpid)->pfnCopyFrameRegs(lpthd, lpbpr))
#define AdjustForProlog(hpid, htid, paddr, canstep) (PointersFromHpid(hpid)->pfnAdjustForProlog(hpid, htid, paddr, canstep))
#define GetFunctionInfo(hpid, gfi)          (PointersFromHpid(hpid)->pfnGetFunctionInfo(hpid, gfi))
#define GetFrameWithSrc(hpid, htid, cFrames, lphtid) (PointersFromHpid(hpid)->pfnGetFrameWithSrc(hpid, htid, cFrames, lphtid))

#define Rgfd(hpid)          (PointersFromHpid(hpid)->Rgfd)
#define Rgrd(hpid)          (PointersFromHpid(hpid)->Rgrd)
#define CRgfd(hpid)         (PointersFromHpid(hpid)->CRgfd)
#define CRgrd(hpid)         (PointersFromHpid(hpid)->CRgrd)
#define SizeOfContext(hpid) (PointersFromHpid(hpid)->SizeOfContext)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\makefile.inc ===
$O\res_str.i: res_str.h
    $(TARGET_CPP) -EP -DRESOURCES $(CDEFINES) $(INCPATH0) -Tc res_str.h > $@


$O\em.res: $O\res_str.i
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\emdp_x86.cpp ===
/**** EMDPDEV.C - Debugger end Execution Model (x86 dependent code)       **
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1990, Microsoft Corp                                     *
 *                                                                         *
 *  Created: October 15, 1990 by David W. Gray                             *
 *                                                                         *
 *  Revision History:                                                      *
 *                                                                         *
 *  Purpose:                                                               *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

#define TARGET_i386
#include "emdp_plt.h"
#include "str_x86.h"

typedef struct _XMMI128 {   
    union {        
        float     fs[4];
        __int64   dl[2];
        double    fd[2];       
    } u;
} XMMI128, *PXMMI128;  

typedef struct _XMMI_AREA {
    XMMI128  Xmmi[8];
} XMMI_AREA, *PXMMI_AREA;

typedef struct _FLOATING_EXTENDED_SAVE_AREA {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   X87RegisterArea[128];
    UCHAR   Reserved3[128];
    UCHAR   Reserved4[224];
} FLOATING_EXTENDED_SAVE_AREA, *PFLOATING_EXTENDED_SAVE_AREA;

RD X86Rgrd[] = {
#include "regs_x86.h"
};
const unsigned CX86Rgrd = (sizeof(X86Rgrd)/sizeof(X86Rgrd[0]));

RGFD X86Rgfd[] = {
#include "flag_x86.h"
};
const unsigned CX86Rgfd = (sizeof(X86Rgfd)/sizeof(X86Rgfd[0]));





typedef struct _L_DOUBLE {
    BYTE b[10];
} L_DOUBLE, FAR *LPL_DOUBLE;

#pragma pack(push, 1)
// this is how MMX registers are stored within the 10 bytes of FPU regs
typedef struct _L_MMX {
	__int64 MMValue;
	WORD MMExponent;
} L_MMX, *LPL_MMX;

// and 3DNow floats are like this
typedef struct _L_3DNOW {
	float Float[2];
	WORD MMExponent;
} L_3DNOW, *LPL_3DNOW;
#pragma pack(pop)


#define CEXM_MDL_native 0x20


#ifdef TARGET32
#define SIZEOF_STACK_OFFSET sizeof(LONG)
#else // TARGET32
#define SIZEOF_STACK_OFFSET sizeof(WORD)
#endif // TARGET32

LPVOID X86SwFunctionTableAccess(LPVOID lpvhpid, DWORD   AddrBase);
void   X86UpdateSpecialRegisters (HPRC hprc, HTHD hthd);

XOSD
X86GetAddr (
    HPID   hpid,
    HTID   htid,
    ADR    adr,
    LPADDR lpaddr
    );

XOSD
X86SetAddr (
    HPID   hpid,
    HTID   htid,
    ADR    adr,
    LPADDR lpaddr
    );

LPVOID
X86DoGetReg(
    LPVOID lpregs1,
    DWORD ireg,
    LPVOID lpvRegValue
    );

XOSD
X86GetRegValue (
    HPID hpid,
    HTID htid,
    DWORD ireg,
    LPVOID lpvRegValue
    );

LPVOID
X86DoSetReg(
    LPVOID   lpregs1,
    DWORD    ireg,
    LPVOID   lpvRegValue
    );

XOSD
X86SetRegValue (
    HPID hpid,
    HTID htid,
    DWORD ireg,
    LPVOID lpvRegValue
    );

XOSD
X86DoGetFrame(
    HPID hpid,
    HTID uhtid,
    DWORD wValue,
    DWORD lValue
    );

XOSD
X86DoGetFrameEH(
    HPID hpid,
    HTID htid,
    LPEXHDLR *lpexhdlr,
    LPDWORD cAddrsAllocated
);

XOSD
X86UpdateChild (
    HPID hpid,
    HTID htid,
    DMF dmfCommand
    );

void
X86CopyFrameRegs(
    LPTHD lpthd,
    LPBPR lpbpr
    );

void
X86AdjustForProlog(
    HPID hpid,
    HTID htid,
    PADDR origAddr,
    CANSTEP *CanStep
    );

XOSD
X86DoGetFunctionInfo(
    HPID hpid,
    LPGFI lpgfi
    );

XOSD
X86GetFrameWithSrc(
	HPID	hpid,
	HTID	htid,
	UINT	cFrames,
	LPHTID	lphtid
	);

CPU_POINTERS X86Pointers = {
    sizeof(CONTEXT),        //  size_t SizeOfContext;
    X86Rgfd,                //  RGFD * Rgfd;
    X86Rgrd,                //  RD   * Rgrd;
    CX86Rgfd,               //  int    CRgfd;
    CX86Rgrd,               //  int    CRgrd;

    X86GetAddr,             //  PFNGETADDR          pfnGetAddr;
    X86SetAddr,             //  PFNSETADDR          pfnSetAddr;
    X86DoGetReg,            //  PFNDOGETREG         pfnDoGetReg;
    X86GetRegValue,         //  PFNGETREGVALUE      pfnGetRegValue;
    X86DoSetReg,            //  PFNSETREG           pfnDoSetReg;
    X86SetRegValue,         //  PFNSETREGVALUE      pfnSetRegValue;
    XXGetFlagValue,         //  PFNGETFLAG          pfnGetFlagValue;
    XXSetFlagValue,         //  PFNSETFLAG          pfnSetFlagValue;
    X86DoGetFrame,          //  PFNGETFRAME         pfnGetFrame;
    X86DoGetFrameEH,        //  PFNGETFRAMEEH       pfnGetFrameEH;
    X86UpdateChild,         //  PFNUPDATECHILD      pfnUpdateChild;
    X86CopyFrameRegs,       //  PFNCOPYFRAMEREGS    pfnCopyFrameRegs;
    X86AdjustForProlog,     //  PFNADJUSTFORPROLOG  pfnAdjustForProlog;
    X86DoGetFunctionInfo,   //  PFNGETFUNCTIONINFO  pfnGetFunctionInfo;
	X86GetFrameWithSrc,		//	PFNGETFRAMEWITHSRC  pfnGetFrameWithSrc;
};



XOSD
X86GetAddr (
    HPID   hpid,
    HTID   htid,
    ADR    adr,
    LPADDR lpaddr
    )

/*++

Routine Description:

    This function will get return a specific type of address.

Arguments:

    hpid   - Supplies the handle to the process to retrive the address from

    htid   - Supplies the handle to the thread to retrieve the address from

    adr    - Supplies the type of address to be retrieved

    lpaddr - Returns the requested address

Return Value:

    XOSD error code

--*/

{
    HPRC        hprc;
    HTHD        hthd;
    LPTHD       lpthd = NULL;
    XOSD        xosd = xosdNone;
    HEMI        hemi = emiAddr(*lpaddr);
    HMDI        hmdi;
    LPMDI       lpmdi;
    BOOL        fVhtid;

    assert ( lpaddr != NULL );
    assert ( hpid != NULL );

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }

    fVhtid = ((DWORD)htid & 1);
    if (fVhtid) {
        htid = (HTID) ((DWORD)htid & ~1);
    }

    hthd = HthdFromHtid(hprc, htid);

    if ( hthd != hthdNull ) {
        lpthd = (LPTHD) LLLock ( hthd );
    }

    _fmemset ( lpaddr, 0, sizeof ( ADDR ) );

    if (!fVhtid) {
        switch ( adr ) {
        case adrPC:
            if ( lpthd && !(lpthd->drt & drtCntrlPresent) ) {
                UpdateRegisters ( hprc, hthd );
            }
            break;

        case adrBase:
        case adrStack:
        case adrData:
            if ( lpthd && !(lpthd->drt & drtAllPresent )) {
                UpdateRegisters ( hprc, hthd );
            }
            break;
        }
    }

    switch ( adr ) {

        case adrPC:
            if (!fVhtid) {
                AddrInit(lpaddr, 0, (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegCs,
                     (UOFFSET) ((PCONTEXT) (lpthd->regs))->Eip, lpthd->fFlat,
                     lpthd->fOff32, FALSE, lpthd->fReal);
            } else {
                AddrInit(lpaddr, 0, (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegCs,
                         (UOFFSET) lpthd->StackFrame.AddrPC.Offset,
                         lpthd->fFlat, lpthd->fOff32, FALSE, lpthd->fReal);
            }
            SetEmi ( hpid, lpaddr );
            break;

        case adrBase:
			// Danger: ugly code alert to do with virtual frames [apennell] VS98:6296
			// It turns out that ImageHlp sometimes gives us a zero as the result,
			// mostly gives us the correct value, but on no-EBP functions it gives
			// us a value that is 4 too small. This code handles all of these cases.
            if (!fVhtid) {
				if (lpthd->offBetterTopFrame) {
					AddrInit(lpaddr, 0, (SEGMENT) 0,
						lpthd->offBetterTopFrame, lpthd->fFlat,
						lpthd->fOff32, FALSE, lpthd->fReal);
				} else {
					AddrInit(lpaddr, 0, (SEGMENT) 0,
						(UOFFSET) ((PCONTEXT) (lpthd->regs))->Ebp, lpthd->fFlat,
						lpthd->fOff32, FALSE, lpthd->fReal);
				}
            } else {
				UOFFSET uBase = (UOFFSET)lpthd->StackFrame.AddrFrame.Offset;
				PFPO_DATA pFpo = (PFPO_DATA)lpthd->StackFrame.FuncTableEntry;
				if (pFpo && !pFpo->fUseBP)
					uBase += 4;
                AddrInit(lpaddr, 0, (SEGMENT) 0,
                          uBase,
                         lpthd->fFlat, lpthd->fOff32, FALSE, lpthd->fReal);
            }
            SetEmi ( hpid, lpaddr );
            break;

        case adrData:
            AddrInit(lpaddr, 0, (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegDs, 0,
                     lpthd->fFlat, lpthd->fOff32, FALSE, lpthd->fReal);
            SetEmi ( hpid, lpaddr );
            break;

        case adrTlsBase:
            /*
             * If -1 then we have not gotten a value from the DM yet.
             */

            assert(hemi != 0);

            if (hemi == 0) {
                return xosdBadAddress;
            }

            if (hemi != emiAddr(lpthd->addrTls)) {
                hmdi = LLFind( LlmdiFromHprc( hprc ), 0, (LPBYTE) &hemi,
                                                                      emdiEMI);
                assert(hmdi != 0);

                if (hmdi == 0) {
                    return xosdBadAddress;
                }

                lpmdi = (LPMDI) LLLock( hmdi );

                GuardTL();
                SendRequestX( dmfQueryTlsBase, hpid, htid, sizeof(OFFSET),
                             &lpmdi->lpBaseOfDll);

                lpthd->addrTls = *((LPADDR) LpDmMsg->rgb);
                ReleaseTL();
                emiAddr(lpthd->addrTls) = hemi;
                LLUnlock( hmdi );

            }

            *lpaddr = lpthd->addrTls;
            emiAddr(*lpaddr) = 0;
            break;

        case adrStack:
            if (!fVhtid) {
                AddrInit(lpaddr, 0, (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegSs,
                         (UOFFSET) ((PCONTEXT) (lpthd->regs))->Esp, lpthd->fFlat,
                         lpthd->fOff32, FALSE, lpthd->fReal);
            } else {
                AddrInit(lpaddr, 0, (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegSs,
                         (UOFFSET)lpthd->StackFrame.AddrStack.Offset,
                         lpthd->fFlat, lpthd->fOff32, FALSE, lpthd->fReal);
            }
            SetEmi ( hpid, lpaddr );
            break;

        default:
            assert ( FALSE );
            break;
    }

    if ( hthd != hthdNull ) {
        LLUnlock ( hthd );
    }

    return xosd;
}                               /* GetAddr() */


XOSD
X86SetAddr (
    HPID   hpid,
    HTID   htid,
    ADR    adr,
    LPADDR lpaddr
    )
{
    HPRC  hprc;
    HTHD  hthd;
    LPTHD lpthd = NULL;

    assert ( lpaddr != NULL );
    assert ( hpid != NULL );

    assert ( ((DWORD)htid & 1) == 0 );

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }

    hthd = HthdFromHtid(hprc, htid);


    if ( hthd != hthdNull ) {
        lpthd = (LPTHD) LLLock ( hthd );
    }

    switch ( adr ) {
        case adrPC:
            if ( !( lpthd->drt & drtCntrlPresent) ) {
                UpdateRegisters ( hprc, hthd );
            }
            break;


        case adrBase:
        case adrStack:
        case adrData:
            if ( !(lpthd->drt & drtAllPresent) ) {
                UpdateRegisters ( hprc, hthd );
            }
            break;

    }
    switch ( adr ) {
        case adrPC:
            ((PCONTEXT) (lpthd->regs))->SegCs = GetAddrSeg ( *lpaddr );
            ((PCONTEXT) (lpthd->regs))->Eip = GetAddrOff ( *lpaddr );
            lpthd->drt = (DRT) (lpthd->drt | drtCntrlDirty);
            break;

        case adrBase:
            ((PCONTEXT) (lpthd->regs))->Ebp = GetAddrOff ( *lpaddr );
            lpthd->drt = (DRT) (lpthd->drt | drtAllDirty);
            break;

        case adrStack:
            ((PCONTEXT) (lpthd->regs))->SegSs = GetAddrSeg ( *lpaddr );
            ((PCONTEXT) (lpthd->regs))->Esp = GetAddrOff ( *lpaddr );
            lpthd->drt = (DRT) (lpthd->drt | drtAllDirty);
            break;

        case adrData:
        case adrTlsBase:
        default:
            assert ( FALSE );
            break;
    }

    if ( hthd != hthdNull ) {
        LLUnlock ( hthd );
    }

    return xosdNone;
}                               /* SetAddr() */


XOSD
X86SetAddrFromCSIP (
    HTHD hthd
    )
{

    ADDR addr = {0};
    LPTHD lpthd;

    assert ( hthd != hthdNull && hthd != hthdInvalid );

    lpthd = (LPTHD) LLLock ( hthd );

    GetAddrSeg ( addr ) = (SEGMENT) ((PCONTEXT) (lpthd->regs))->SegCs;
    GetAddrOff ( addr ) = (UOFFSET) ((PCONTEXT) (lpthd->regs))->Eip;
    emiAddr ( addr ) =  0;
    ADDR_IS_FLAT ( addr ) = TRUE;

    LLUnlock ( hthd );

    return xosdNone;
}


LPVOID
X86DoGetReg(
    LPVOID lpregs1,
    DWORD ireg,
    LPVOID lpvRegValue
    )

/*++

Routine Description:

    This routine is used to extract the value of a single register from
    the debuggee.

Arguments:

    lpregs      - Supplies pointer to the register set for the debuggee
    ireg        - Supplies the index of the register to be read
    lpvRegValue - Supplies the buffer to place the register value in

Return Value:

    return-value - lpvRegValue + size of register on sucess and NULL on
                failure
--*/

{
    int         i;
    LPCONTEXT  lpregs = (LPCONTEXT) lpregs1;
    DWORD dwProcessorFlags = *(PDWORD)lpvRegValue; //no other way to pass the processor flags in 6.0

	assert( sizeof(L_MMX)==10 );			// if this fires, struct packing is wrong

    switch ( ireg ) {

    case CV_REG_AL:
        *( (LPBYTE) lpvRegValue ) = (BYTE) lpregs->Eax;
        break;

    case CV_REG_CL:
        *( (LPBYTE) lpvRegValue ) = (BYTE) lpregs->Ecx;
        break;

    case CV_REG_DL:
        *( (LPBYTE) lpvRegValue ) = (BYTE) lpregs->Edx;
        break;

    case CV_REG_BL:
        *( (LPBYTE) lpvRegValue ) = (BYTE) lpregs->Ebx;
        break;

    case CV_REG_AH:
        *( (LPBYTE) lpvRegValue ) = (BYTE) (lpregs->Eax >> 8);
        break;

    case CV_REG_CH:
        *( (LPBYTE) lpvRegValue ) = (BYTE) (lpregs->Ecx >> 8);
        break;

    case CV_REG_DH:
        *( (LPBYTE) lpvRegValue ) = (BYTE) (lpregs->Edx >> 8);
        break;

    case CV_REG_BH:
        *( (LPBYTE) lpvRegValue ) = (BYTE) (lpregs->Ebx >> 8);
        break;

    case CV_REG_AX:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Eax;
        break;

    case CV_REG_CX:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Ecx;
        break;

    case CV_REG_DX:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Edx;
        break;

    case CV_REG_BX:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Ebx;
        break;

    case CV_REG_SP:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Esp;
        break;

    case CV_REG_BP:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Ebp;
        break;

    case CV_REG_SI:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Esi;
        break;

    case CV_REG_DI:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Edi;
        break;

    case CV_REG_IP:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->Eip;
        break;

    case CV_REG_FLAGS:
        *( (LPWORD) lpvRegValue ) = (WORD) lpregs->EFlags;
        break;

    case CV_REG_ES:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegEs;
        break;

    case CV_REG_CS:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegCs;
        break;

    case CV_REG_SS:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegSs;
        break;

    case CV_REG_DS:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegDs;
        break;

    case CV_REG_FS:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegFs;
        break;

    case CV_REG_GS:
        *( (LPWORD) lpvRegValue ) = (SEG16) lpregs->SegGs;
        break;

    case CV_REG_EAX:
        *( (LPLONG) lpvRegValue ) = lpregs->Eax;
        break;

    case CV_REG_ECX:
        *( (LPLONG) lpvRegValue ) = lpregs->Ecx;
        break;

    case CV_REG_EDX:
        *( (LPLONG) lpvRegValue ) = lpregs->Edx;
        break;

    case CV_REG_EBX:
        *( (LPLONG) lpvRegValue ) = lpregs->Ebx;
        break;

    case CV_REG_ESP:
        *( (LPLONG) lpvRegValue ) = lpregs->Esp;
        break;

    case CV_REG_EBP:
        *( (LPLONG) lpvRegValue ) = lpregs->Ebp;
        break;

    case CV_REG_ESI:
        *( (LPLONG) lpvRegValue ) = lpregs->Esi;
        break;

    case CV_REG_EDI:
        *( (LPLONG) lpvRegValue ) = lpregs->Edi;
        break;

    case CV_REG_EIP:
        *( (LPLONG) lpvRegValue ) = lpregs->Eip;
        break;

    case CV_REG_EFLAGS:
        *( (LPLONG) lpvRegValue ) = lpregs->EFlags;
        break;

    case CV_REG_ST0:
    case CV_REG_ST1:
    case CV_REG_ST2:
    case CV_REG_ST3:
    case CV_REG_ST4:
    case CV_REG_ST5:
    case CV_REG_ST6:
    case CV_REG_ST7:

//        i = (lpregs->FloatSave.StatusWord >> 11) & 0x7;
//        i = (i + ireg - CV_REG_ST0) % 8;

          i = ireg - CV_REG_ST0;

        *( (LPL_DOUBLE) lpvRegValue ) =
          ((LPL_DOUBLE)(lpregs->FloatSave.RegisterArea))[ i ];
        break;

	case CV_REG_MM0:
	case CV_REG_MM1:
	case CV_REG_MM2:
	case CV_REG_MM3:
	case CV_REG_MM4:
	case CV_REG_MM5:
	case CV_REG_MM6:
	case CV_REG_MM7:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX) {
            LPL_MMX pReg = &((LPL_MMX)(lpregs->FloatSave.RegisterArea))[ ireg - CV_REG_MM0 ];
            *( (__int64*) lpvRegValue ) = pReg->MMValue; 
        } else {
            return NULL;
        }
		break;

    case CV_REG_EMM0L:
    case CV_REG_EMM1L:
    case CV_REG_EMM2L:
    case CV_REG_EMM3L:
    case CV_REG_EMM4L:
    case CV_REG_EMM5L:
    case CV_REG_EMM6L:
    case CV_REG_EMM7L:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3) {
            *((PDWORDLONG)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_EMM0L].u.dl[0];
        } else {
            lpvRegValue = NULL;
        }
		break;

    case CV_REG_EMM0H:
    case CV_REG_EMM1H:
    case CV_REG_EMM2H:
    case CV_REG_EMM3H:
    case CV_REG_EMM4H:
    case CV_REG_EMM5H:
    case CV_REG_EMM6H:
    case CV_REG_EMM7H:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3) {
            *((PDWORDLONG)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_EMM0H].u.dl[1];
        } else {
            lpvRegValue = NULL;
        }
		break;

    case CV_REG_XMM0L:
    case CV_REG_XMM1L:
    case CV_REG_XMM2L:
    case CV_REG_XMM3L:
    case CV_REG_XMM4L:
    case CV_REG_XMM5L:
    case CV_REG_XMM6L:
    case CV_REG_XMM7L:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3) {
            *((double *)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0L].u.fd[0];
        } else {
            lpvRegValue = NULL;
        }
		break;

    case CV_REG_XMM0H:
    case CV_REG_XMM1H:
    case CV_REG_XMM2H:
    case CV_REG_XMM3H:
    case CV_REG_XMM4H:
    case CV_REG_XMM5H:
    case CV_REG_XMM6H:
    case CV_REG_XMM7H:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3) {
            *((double *)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0H].u.fd[1];
        } else {
            lpvRegValue = NULL;
        }
		break;

    case CV_REG_XMM0:
    case CV_REG_XMM1:
    case CV_REG_XMM2:
    case CV_REG_XMM3:
    case CV_REG_XMM4:
    case CV_REG_XMM5:
    case CV_REG_XMM6:
    case CV_REG_XMM7:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2) {
            *((PXMMI128)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0];
        } else {
            lpvRegValue = NULL;
        }
		break;

    case CV_REG_XMM00:
	case CV_REG_XMM01:
	case CV_REG_XMM02:
	case CV_REG_XMM03:
	case CV_REG_XMM10:
	case CV_REG_XMM11:
	case CV_REG_XMM12:
	case CV_REG_XMM13:
    case CV_REG_XMM20:
	case CV_REG_XMM21:
	case CV_REG_XMM22:
	case CV_REG_XMM23:
	case CV_REG_XMM30:
	case CV_REG_XMM31:
	case CV_REG_XMM32:
	case CV_REG_XMM33:
    case CV_REG_XMM40:
	case CV_REG_XMM41:
	case CV_REG_XMM42:
	case CV_REG_XMM43:
	case CV_REG_XMM50:
	case CV_REG_XMM51:
	case CV_REG_XMM52:
	case CV_REG_XMM53:
    case CV_REG_XMM60:
	case CV_REG_XMM61:
	case CV_REG_XMM62:
	case CV_REG_XMM63:
	case CV_REG_XMM70:
	case CV_REG_XMM71:
	case CV_REG_XMM72:
	case CV_REG_XMM73:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2) {
			*((PFLOAT)lpvRegValue) = ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[(ireg - CV_REG_XMM00) >> 2].u.fs[(ireg - CV_REG_XMM00) & 0x3];
        } else {
            lpvRegValue = NULL;
        }
		break;

	case CV_REG_MM00:
	case CV_REG_MM01:
	case CV_REG_MM10:
	case CV_REG_MM11:
	case CV_REG_MM20:
	case CV_REG_MM21:
	case CV_REG_MM30:
	case CV_REG_MM31:
	case CV_REG_MM40:
	case CV_REG_MM41:
	case CV_REG_MM50:
	case CV_REG_MM51:
	case CV_REG_MM60:
	case CV_REG_MM61:
	case CV_REG_MM70:
	case CV_REG_MM71:
		if (dwProcessorFlags & PROCESSOR_FLAGS_I386_3DNOW) {
            LPL_3DNOW pReg = &((LPL_3DNOW)(lpregs->FloatSave.RegisterArea))[ (ireg - CV_REG_MM00)>>1 ];
			*((PFLOAT)lpvRegValue) = pReg->Float[ireg&1];
		} else {
			lpvRegValue = NULL;
		}
		break;

    case CV_REG_MXCSR:
        if (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2) {
			*((LPLONG)lpvRegValue ) =  ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->MXCsr;
		} else {
            lpvRegValue = NULL;
        }
        break;

    case CV_REG_CTRL:
        *( (LPLONG) lpvRegValue ) =  lpregs->FloatSave.ControlWord;
        break;

    case CV_REG_STAT:
        *( (LPLONG) lpvRegValue ) =  lpregs->FloatSave.StatusWord;
        break;

    case CV_REG_TAG:
        *( (LPLONG) lpvRegValue ) =  lpregs->FloatSave.TagWord;
        break;

    case CV_REG_FPIP:
        *( (LPWORD) lpvRegValue ) =  (OFF16) lpregs->FloatSave.ErrorOffset;
        break;

    case CV_REG_FPEIP:
        *( (LPLONG) lpvRegValue ) =  lpregs->FloatSave.ErrorOffset;
        break;

    case CV_REG_FPCS:
        *( (LPWORD) lpvRegValue ) =  (SEG16) lpregs->FloatSave.ErrorSelector;
        break;

    case CV_REG_FPDO:
        *( (LPLONG) lpvRegValue ) =  (OFF16) lpregs->FloatSave.DataOffset;
        break;

    case CV_REG_FPEDO:
        *( (LPLONG) lpvRegValue ) =  lpregs->FloatSave.DataOffset;
        break;

    case CV_REG_FPDS:
        *( (LPWORD) lpvRegValue ) =  (SEG16) lpregs->FloatSave.DataSelector;
        break;

#define lpsr ((PKSPECIAL_REGISTERS)lpregs)
    case CV_REG_GDTR:
        *( (LPDWORD) lpvRegValue ) = lpsr->Gdtr.Base;
        break;

    case CV_REG_GDTL:
        *( (LPWORD) lpvRegValue ) = lpsr->Gdtr.Limit;
        break;

    case CV_REG_IDTR:
        *( (LPDWORD) lpvRegValue ) = lpsr->Idtr.Base;
        break;

    case CV_REG_IDTL:
        *( (LPWORD) lpvRegValue ) = lpsr->Idtr.Limit;
        break;

    case CV_REG_LDTR:
        *( (LPWORD) lpvRegValue ) = lpsr->Ldtr;
        break;

    case CV_REG_TR:
        *( (LPWORD) lpvRegValue ) = lpsr->Tr;
        break;

    case CV_REG_CR0:
        *( (LPDWORD) lpvRegValue ) = lpsr->Cr0;
        break;

    case CV_REG_CR2:
        *( (LPDWORD) lpvRegValue ) = lpsr->Cr2;
        break;

    case CV_REG_CR3:
        *( (LPDWORD) lpvRegValue ) = lpsr->Cr3;
        break;

    case CV_REG_CR4:
        *( (LPDWORD) lpvRegValue ) = lpsr->Cr4;
        break;
#undef lpsr

    case CV_REG_DR0:
        *( (PULONG) lpvRegValue ) = lpregs->Dr0;
        break;

    case CV_REG_DR1:
        *( (PULONG) lpvRegValue ) = lpregs->Dr1;
        break;

    case CV_REG_DR2:
        *( (PULONG) lpvRegValue ) = lpregs->Dr2;
        break;

    case CV_REG_DR3:
        *( (PULONG) lpvRegValue ) = lpregs->Dr3;
        break;

    case CV_REG_DR6:
        *( (PULONG) lpvRegValue ) = lpregs->Dr6;
        break;

    case CV_REG_DR7:
        *( (PULONG) lpvRegValue ) = lpregs->Dr7;
        break;

    }

    switch ( ireg ) {

    case CV_REG_AL:
    case CV_REG_CL:
    case CV_REG_DL:
    case CV_REG_BL:
    case CV_REG_AH:
    case CV_REG_CH:
    case CV_REG_DH:
    case CV_REG_BH:

        lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof ( BYTE ) ;
        break;

    case CV_REG_AX:
    case CV_REG_CX:
    case CV_REG_DX:
    case CV_REG_BX:
    case CV_REG_SP:
    case CV_REG_BP:
    case CV_REG_SI:
    case CV_REG_DI:
    case CV_REG_IP:
    case CV_REG_FLAGS:
    case CV_REG_ES:
    case CV_REG_CS:
    case CV_REG_SS:
    case CV_REG_DS:
    case CV_REG_FS:
    case CV_REG_GS:
    case CV_REG_FPCS:
    case CV_REG_FPDS:
    case CV_REG_CTRL:
    case CV_REG_STAT:
    case CV_REG_TAG:
    case CV_REG_FPIP:
    case CV_REG_FPDO:

    case CV_REG_GDTL:
    case CV_REG_IDTL:
    case CV_REG_LDTR:
    case CV_REG_TR:

        lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof ( WORD ) ;

        break;

    case CV_REG_EAX:
    case CV_REG_ECX:
    case CV_REG_EDX:
    case CV_REG_EBX:
    case CV_REG_ESP:
    case CV_REG_EBP:
    case CV_REG_ESI:
    case CV_REG_EDI:
    case CV_REG_EIP:
    case CV_REG_EFLAGS:
    case CV_REG_FPEIP:
    case CV_REG_FPEDO:

    case CV_REG_CR0:
    case CV_REG_CR1:
    case CV_REG_CR2:
    case CV_REG_CR3:
    case CV_REG_CR4:

    case CV_REG_DR0:
    case CV_REG_DR1:
    case CV_REG_DR2:
    case CV_REG_DR3:
    case CV_REG_DR4:
    case CV_REG_DR5:
    case CV_REG_DR6:
    case CV_REG_DR7:

    case CV_REG_GDTR:
    case CV_REG_IDTR:

        lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof ( LONG ) ;
        break;

    case CV_REG_ST0:
    case CV_REG_ST1:
    case CV_REG_ST2:
    case CV_REG_ST3:
    case CV_REG_ST4:
    case CV_REG_ST5:
    case CV_REG_ST6:
    case CV_REG_ST7:

        lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof ( L_DOUBLE ) ;
        break;

	case CV_REG_MM0:
	case CV_REG_MM1:
	case CV_REG_MM2:
	case CV_REG_MM3:
	case CV_REG_MM4:
	case CV_REG_MM5:
	case CV_REG_MM6:
	case CV_REG_MM7:
        lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX)? (LPBYTE) (lpvRegValue) + sizeof( __int64 ) : NULL;
        break;

    case CV_REG_EMM0L:
    case CV_REG_EMM1L:
    case CV_REG_EMM2L:
    case CV_REG_EMM3L:
    case CV_REG_EMM4L:
    case CV_REG_EMM5L:
    case CV_REG_EMM6L:
    case CV_REG_EMM7L:
    case CV_REG_EMM0H:
    case CV_REG_EMM1H:
    case CV_REG_EMM2H:
    case CV_REG_EMM3H:
    case CV_REG_EMM4H:
    case CV_REG_EMM5H:
    case CV_REG_EMM6H:
    case CV_REG_EMM7H:
        lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3)? (LPBYTE) (lpvRegValue) + sizeof( DWORDLONG ) : NULL;
		break;

    case CV_REG_XMM0L:
    case CV_REG_XMM1L:
    case CV_REG_XMM2L:
    case CV_REG_XMM3L:
    case CV_REG_XMM4L:
    case CV_REG_XMM5L:
    case CV_REG_XMM6L:
    case CV_REG_XMM7L:
    case CV_REG_XMM0H:
    case CV_REG_XMM1H:
    case CV_REG_XMM2H:
    case CV_REG_XMM3H:
    case CV_REG_XMM4H:
    case CV_REG_XMM5H:
    case CV_REG_XMM6H:
    case CV_REG_XMM7H:
        lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX3)? (LPBYTE) (lpvRegValue) + sizeof( double ) : NULL;
		break;

	case CV_REG_XMM0:
	case CV_REG_XMM1:
	case CV_REG_XMM2:
	case CV_REG_XMM3:
	case CV_REG_XMM4:
	case CV_REG_XMM5:
	case CV_REG_XMM6:
	case CV_REG_XMM7:
		lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2)? (LPBYTE) (lpvRegValue) + sizeof( XMMI128 ) : NULL;
		break;

    case CV_REG_XMM00:
	case CV_REG_XMM01:
	case CV_REG_XMM02:
	case CV_REG_XMM03:
	case CV_REG_XMM10:
	case CV_REG_XMM11:
	case CV_REG_XMM12:
	case CV_REG_XMM13:
    case CV_REG_XMM20:
	case CV_REG_XMM21:
	case CV_REG_XMM22:
	case CV_REG_XMM23:
	case CV_REG_XMM30:
	case CV_REG_XMM31:
	case CV_REG_XMM32:
	case CV_REG_XMM33:
    case CV_REG_XMM40:
	case CV_REG_XMM41:
	case CV_REG_XMM42:
	case CV_REG_XMM43:
	case CV_REG_XMM50:
	case CV_REG_XMM51:
	case CV_REG_XMM52:
	case CV_REG_XMM53:
    case CV_REG_XMM60:
	case CV_REG_XMM61:
	case CV_REG_XMM62:
	case CV_REG_XMM63:
	case CV_REG_XMM70:
	case CV_REG_XMM71:
	case CV_REG_XMM72:
	case CV_REG_XMM73:
		lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2)? (LPBYTE) (lpvRegValue) + sizeof( float ) : NULL;
		break;

	case CV_REG_MXCSR:
		lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_MMX2)? (LPBYTE) (lpvRegValue) + sizeof( ULONG ) : NULL;
		break;
    
	case CV_REG_MM00:
	case CV_REG_MM01:
	case CV_REG_MM10:
	case CV_REG_MM11:
	case CV_REG_MM20:
	case CV_REG_MM21:
	case CV_REG_MM30:
	case CV_REG_MM31:
	case CV_REG_MM40:
	case CV_REG_MM41:
	case CV_REG_MM50:
	case CV_REG_MM51:
	case CV_REG_MM60:
	case CV_REG_MM61:
	case CV_REG_MM70:
	case CV_REG_MM71:
		lpvRegValue = (dwProcessorFlags & PROCESSOR_FLAGS_I386_3DNOW)? (LPBYTE) (lpvRegValue) + sizeof( float ) : NULL;
		break;

    default:
        lpvRegValue = NULL;
        break;
    }

    return lpvRegValue;
}                               /* DoGetReg() */


LPVOID
X86DoSetReg(
    LPVOID   lpregs1,
    DWORD    ireg,
    LPVOID   lpvRegValue
    )
/*++

Routine Description:

    This routine is used to set a specific register in a threads
    context

Arguments:

    lpregs      - Supplies pointer to register context for thread
    ireg        - Supplies the index of the register to be modified
    lpvRegValue - Supplies the buffer containning the new data

Return Value:

    return-value - the pointer the the next location where a register
        value could be.

--*/

{
    int         i;
    LPCONTEXT   lpregs = (LPCONTEXT) lpregs1;

    switch ( ireg ) {

    case CV_REG_AL:
        lpregs->Eax = (lpregs->Eax & 0xFFFFFF00) | *( (LPBYTE) lpvRegValue );
        break;

    case CV_REG_CL:
        lpregs->Ecx = (lpregs->Ecx & 0xFFFFFF00) | *( (LPBYTE) lpvRegValue );
        break;

    case CV_REG_DL:
        lpregs->Edx = (lpregs->Edx & 0xFFFFFF00) | *( (LPBYTE) lpvRegValue );
        break;

    case CV_REG_BL:
        lpregs->Ebx = (lpregs->Ebx & 0xFFFFFF00) | *( (LPBYTE) lpvRegValue );
        break;

    case CV_REG_AH:
        lpregs->Eax = (lpregs->Eax & 0xFFFF00FF) |
          (((WORD) *( (LPBYTE) lpvRegValue )) << 8);
        break;

    case CV_REG_CH:
        lpregs->Ecx = (lpregs->Ecx & 0xFFFF00FF) |
          (((WORD) *( (LPBYTE) lpvRegValue )) << 8);
        break;

    case CV_REG_DH:
        lpregs->Edx = (lpregs->Edx & 0xFFFF00FF) |
          (((WORD) *( (LPBYTE) lpvRegValue )) << 8);
        break;

    case CV_REG_BH:
        lpregs->Ebx = (lpregs->Ebx & 0xFFFF00FF) |
          (((WORD) *( (LPBYTE) lpvRegValue )) << 8);
        break;

    case CV_REG_AX:
        lpregs->Eax = (lpregs->Eax & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_CX:
        lpregs->Ecx = (lpregs->Ecx & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_DX:
        lpregs->Edx = (lpregs->Edx & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_BX:
        lpregs->Ebx = (lpregs->Ebx & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_SP:
        lpregs->Esp = (lpregs->Esp & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_BP:
        lpregs->Ebp = (lpregs->Ebp & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_SI:
        lpregs->Esi = (lpregs->Esi & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_DI:
        lpregs->Edi = (lpregs->Edi & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_IP:
        lpregs->Eip = (lpregs->Eip & 0xFFFF0000) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FLAGS:
        lpregs->EFlags = (lpregs->EFlags & 0xFFFF0000 ) | *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_ES:
        lpregs->SegEs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_CS:
        lpregs->SegCs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_SS:
        lpregs->SegSs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_DS:
        lpregs->SegDs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FS:
        lpregs->SegFs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_GS:
        lpregs->SegGs = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_EAX:
        lpregs->Eax = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_ECX:
        lpregs->Ecx = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EDX:
        lpregs->Edx = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EBX:
        lpregs->Ebx = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_ESP:
        lpregs->Esp = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EBP:
        lpregs->Ebp = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_ESI:
        lpregs->Esi = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EDI:
        lpregs->Edi = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EIP:
        lpregs->Eip = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_EFLAGS:
        lpregs->EFlags = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_ST0:
    case CV_REG_ST1:
    case CV_REG_ST2:
    case CV_REG_ST3:
    case CV_REG_ST4:
    case CV_REG_ST5:
    case CV_REG_ST6:
    case CV_REG_ST7:
//        i = (lpregs->FloatSave.StatusWord >> 11) & 0x7;
//        i = (i + ireg - CV_REG_ST0) % 8;
        i = ireg - CV_REG_ST0;
        memcpy(&lpregs->FloatSave.RegisterArea[10*(i)], lpvRegValue, 10);
        break;

	case CV_REG_MM0:
	case CV_REG_MM1:
	case CV_REG_MM2:
	case CV_REG_MM3:
	case CV_REG_MM4:
	case CV_REG_MM5:
	case CV_REG_MM6:
	case CV_REG_MM7:
		{
		LPL_MMX pReg = &((LPL_MMX)(lpregs->FloatSave.RegisterArea))[ ireg - CV_REG_MM0 ];
		pReg->MMValue = *(__int64*)lpvRegValue;
		// emulate an MMX instruction, which means wack all 1s into the exponent
		// set TOS to 0, and zero all the tags too
		pReg->MMExponent = 0xFFFF;
		lpregs->FloatSave.TagWord &= ~0xFFFF;
		lpregs->FloatSave.StatusWord &= ~0x3800;

#if 0 //v-vadimp - not clear if this is required
        //
		// v-vadimp
		//
		// in case this is a Willamette machine do a similar thing for the corresponding EMM register (additionally requires the high 48 bits set to zero)
		// there is no need to check for architecture as setting the extended context area just won't do anything on older machines
		//
        struct _L_EMMX {
	        __int64 MMValue;
            union {
	            WORD MMExponent;
                __int64 HiBits;
            };
        } pRegEx = (LPL_EMMX)&(((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_MM0]);
		pRegEx->MMValue = *(__int64*)lpvRegValue;
        
		pRegEx->HiBits = 0; // do not change the order of assignments since HiBits and MMExponent interleave!!!
		pRegEx->MMExponent = 0xFFFF; 
		
		((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->TagWord &= ~0xFFFF;
		((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->StatusWord &= ~0x3800;
#endif

		}
		break;

    case CV_REG_EMM0L:
    case CV_REG_EMM1L:
    case CV_REG_EMM2L:
    case CV_REG_EMM3L:
    case CV_REG_EMM4L:
    case CV_REG_EMM5L:
    case CV_REG_EMM6L:
    case CV_REG_EMM7L:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_EMM0L].u.dl[0] = *((PDWORDLONG)lpvRegValue);
        ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->TagWord &= ~0xFFFF;
        ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->StatusWord &= ~0x3800;
        break;

    case CV_REG_EMM0H:
    case CV_REG_EMM1H:
    case CV_REG_EMM2H:
    case CV_REG_EMM3H:
    case CV_REG_EMM4H:
    case CV_REG_EMM5H:
    case CV_REG_EMM6H:
    case CV_REG_EMM7H:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_EMM0H].u.dl[1] = *((PDWORDLONG)lpvRegValue);
        ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->TagWord &= ~0xFFFF;
        ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->StatusWord &= ~0x3800;
        break;

    case CV_REG_XMM0L:
    case CV_REG_XMM1L:
    case CV_REG_XMM2L:
    case CV_REG_XMM3L:
    case CV_REG_XMM4L:
    case CV_REG_XMM5L:
    case CV_REG_XMM6L:
    case CV_REG_XMM7L:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0L].u.fd[0] = *((double *)lpvRegValue);
        break;

    case CV_REG_XMM0H:
    case CV_REG_XMM1H:
    case CV_REG_XMM2H:
    case CV_REG_XMM3H:
    case CV_REG_XMM4H:
    case CV_REG_XMM5H:
    case CV_REG_XMM6H:
    case CV_REG_XMM7H:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0H].u.fd[1] = *((double *)lpvRegValue);
        break;

    case CV_REG_XMM0:
    case CV_REG_XMM1:
    case CV_REG_XMM2:
    case CV_REG_XMM3:
    case CV_REG_XMM4:
    case CV_REG_XMM5:
    case CV_REG_XMM6:
    case CV_REG_XMM7:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[ireg - CV_REG_XMM0] = *((PXMMI128)lpvRegValue);
        break;

    case CV_REG_XMM00:
    case CV_REG_XMM01:
    case CV_REG_XMM02:
    case CV_REG_XMM03:
    case CV_REG_XMM10:
    case CV_REG_XMM11:
    case CV_REG_XMM12:
    case CV_REG_XMM13:
    case CV_REG_XMM20:
    case CV_REG_XMM21:
    case CV_REG_XMM22:
    case CV_REG_XMM23:
    case CV_REG_XMM30:
    case CV_REG_XMM31:
    case CV_REG_XMM32:
    case CV_REG_XMM33:
    case CV_REG_XMM40:
    case CV_REG_XMM41:
    case CV_REG_XMM42:
    case CV_REG_XMM43:
    case CV_REG_XMM50:
    case CV_REG_XMM51:
    case CV_REG_XMM52:
    case CV_REG_XMM53:
    case CV_REG_XMM60:
    case CV_REG_XMM61:
    case CV_REG_XMM62:
    case CV_REG_XMM63:
    case CV_REG_XMM70:
    case CV_REG_XMM71:
    case CV_REG_XMM72:
    case CV_REG_XMM73:
        ((PXMMI_AREA)(((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->Reserved3))->Xmmi[(ireg - CV_REG_XMM00) >> 2].u.fs[(ireg - CV_REG_XMM00) & 0x3] = *((PFLOAT)lpvRegValue);
        break;
    
    case CV_REG_MXCSR:
        ((PFLOATING_EXTENDED_SAVE_AREA)(lpregs->ExtendedRegisters))->MXCsr = *((LPLONG)lpvRegValue );
        break;

	case CV_REG_MM00:
	case CV_REG_MM01:
	case CV_REG_MM10:
	case CV_REG_MM11:
	case CV_REG_MM20:
	case CV_REG_MM21:
	case CV_REG_MM30:
	case CV_REG_MM31:
	case CV_REG_MM40:
	case CV_REG_MM41:
	case CV_REG_MM50:
	case CV_REG_MM51:
	case CV_REG_MM60:
	case CV_REG_MM61:
	case CV_REG_MM70:
	case CV_REG_MM71:
		{
		LPL_3DNOW pReg = &((LPL_3DNOW)(lpregs->FloatSave.RegisterArea))[ (ireg - CV_REG_MM00)>>1 ];
		pReg->Float[ireg&1] = *(float*)lpvRegValue;
		}
		break;

    case CV_REG_CTRL:
        lpregs->FloatSave.ControlWord = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_STAT:
        lpregs->FloatSave.StatusWord = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_TAG:
        lpregs->FloatSave.TagWord = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FPIP:
        lpregs->FloatSave.ErrorOffset = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FPEIP:
        lpregs->FloatSave.ErrorOffset = *( (LPLONG) lpvRegValue );
        break;

    case CV_REG_FPCS:
        lpregs->FloatSave.ErrorSelector = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FPDO:
        lpregs->FloatSave.DataOffset = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FPEDO:
        lpregs->FloatSave.DataOffset = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_FPDS:
        lpregs->FloatSave.DataSelector = *( (LPWORD) lpvRegValue );
        break;

#define lpsr ((PKSPECIAL_REGISTERS)lpregs)
    case CV_REG_GDTR:
        lpsr->Gdtr.Base = *( (LPDWORD) lpvRegValue );
        break;

    case CV_REG_GDTL:
        lpsr->Gdtr.Limit = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_IDTR:
        lpsr->Idtr.Base = *( (LPDWORD) lpvRegValue );
        break;

    case CV_REG_IDTL:
        lpsr->Idtr.Limit = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_LDTR:
        lpsr->Ldtr = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_TR:
        lpsr->Tr = *( (LPWORD) lpvRegValue );
        break;

    case CV_REG_CR0:
        lpsr->Cr0 = *( (LPDWORD) lpvRegValue );
        break;

    case CV_REG_CR2:
        lpsr->Cr2 = *( (LPDWORD) lpvRegValue );
        break;

    case CV_REG_CR3:
        lpsr->Cr3 = *( (LPDWORD) lpvRegValue );
        break;

    case CV_REG_CR4:
        lpsr->Cr4 = *( (LPDWORD) lpvRegValue );
        break;
#undef lpsr

    case CV_REG_DR0:
        lpregs->Dr0 = *( (PULONG) lpvRegValue );
        break;

    case CV_REG_DR1:
        lpregs->Dr1 = *( (PULONG) lpvRegValue );
        break;

    case CV_REG_DR2:
        lpregs->Dr2 = *( (PULONG) lpvRegValue );
        break;

    case CV_REG_DR3:
        lpregs->Dr3 = *( (PULONG) lpvRegValue );
        break;

    case CV_REG_DR6:
        lpregs->Dr6 = *( (PULONG) lpvRegValue );
        break;

    case CV_REG_DR7:
        lpregs->Dr7 = *( (PULONG) lpvRegValue );

    }


    switch ( ireg ) {

    case CV_REG_AL:
    case CV_REG_CL:
    case CV_REG_DL:
    case CV_REG_BL:
    case CV_REG_AH:
    case CV_REG_CH:
    case CV_REG_DH:
    case CV_REG_BH:

        lpvRegValue = (LPBYTE) lpvRegValue + sizeof ( BYTE );
        break;

    case CV_REG_AX:
    case CV_REG_CX:
    case CV_REG_DX:
    case CV_REG_BX:
    case CV_REG_SP:
    case CV_REG_BP:
    case CV_REG_SI:
    case CV_REG_DI:
    case CV_REG_IP:
    case CV_REG_FLAGS:
    case CV_REG_ES:
    case CV_REG_CS:
    case CV_REG_SS:
    case CV_REG_DS:
    case CV_REG_FS:
    case CV_REG_GS:
    case CV_REG_CTRL:
    case CV_REG_STAT:
    case CV_REG_TAG:
    case CV_REG_FPIP:
    case CV_REG_FPCS:
    case CV_REG_FPDO:
    case CV_REG_FPDS:
    case CV_REG_GDTL:
    case CV_REG_IDTL:
    case CV_REG_LDTR:
    case CV_REG_TR:

        lpvRegValue = (LPBYTE) lpvRegValue + sizeof ( WORD );
        break;

    case CV_REG_EAX:
    case CV_REG_ECX:
    case CV_REG_EDX:
    case CV_REG_EBX:
    case CV_REG_ESP:
    case CV_REG_EBP:
    case CV_REG_ESI:
    case CV_REG_EDI:
    case CV_REG_EIP:
    case CV_REG_EFLAGS:
    case CV_REG_FPEIP:
    case CV_REG_FPEDO:
    case CV_REG_CR0:
    case CV_REG_CR1:
    case CV_REG_CR2:
    case CV_REG_CR3:
    case CV_REG_CR4:
    case CV_REG_DR0:
    case CV_REG_DR1:
    case CV_REG_DR2:
    case CV_REG_DR3:
    case CV_REG_DR4:
    case CV_REG_DR5:
    case CV_REG_DR6:
    case CV_REG_DR7:
    case CV_REG_GDTR:
    case CV_REG_IDTR:

        lpvRegValue = (LPBYTE) lpvRegValue + sizeof ( LONG );
        break;

    case CV_REG_ST0:
    case CV_REG_ST1:
    case CV_REG_ST2:
    case CV_REG_ST3:
    case CV_REG_ST4:
    case CV_REG_ST5:
    case CV_REG_ST6:
    case CV_REG_ST7:

        lpvRegValue = (LPBYTE) lpvRegValue + sizeof ( L_DOUBLE );
        break;

	case CV_REG_MM0:
	case CV_REG_MM1:
	case CV_REG_MM2:
	case CV_REG_MM3:
	case CV_REG_MM4:
	case CV_REG_MM5:
	case CV_REG_MM6:
	case CV_REG_MM7:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( __int64 );
		break;

	case CV_REG_EMM0L:
	case CV_REG_EMM1L:
	case CV_REG_EMM2L:
	case CV_REG_EMM3L:
	case CV_REG_EMM4L:
	case CV_REG_EMM5L:
	case CV_REG_EMM6L:
	case CV_REG_EMM7L:
	case CV_REG_EMM0H:
	case CV_REG_EMM1H:
	case CV_REG_EMM2H:
	case CV_REG_EMM3H:
	case CV_REG_EMM4H:
	case CV_REG_EMM5H:
	case CV_REG_EMM6H:
	case CV_REG_EMM7H:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( DWORDLONG );
		break;

    case CV_REG_XMM0L:
	case CV_REG_XMM1L:
	case CV_REG_XMM2L:
	case CV_REG_XMM3L:
	case CV_REG_XMM4L:
	case CV_REG_XMM5L:
	case CV_REG_XMM6L:
	case CV_REG_XMM7L:
	case CV_REG_XMM0H:
	case CV_REG_XMM1H:
	case CV_REG_XMM2H:
	case CV_REG_XMM3H:
	case CV_REG_XMM4H:
	case CV_REG_XMM5H:
	case CV_REG_XMM6H:
	case CV_REG_XMM7H:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( double );
		break;

	case CV_REG_XMM0:
	case CV_REG_XMM1:
	case CV_REG_XMM2:
	case CV_REG_XMM3:
	case CV_REG_XMM4:
	case CV_REG_XMM5:
	case CV_REG_XMM6:
	case CV_REG_XMM7:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( XMMI128 );
		break;

	case CV_REG_XMM00:
	case CV_REG_XMM01:
	case CV_REG_XMM02:
	case CV_REG_XMM03:
	case CV_REG_XMM10:
	case CV_REG_XMM11:
	case CV_REG_XMM12:
	case CV_REG_XMM13:
	case CV_REG_XMM20:
	case CV_REG_XMM21:
	case CV_REG_XMM22:
	case CV_REG_XMM23:
	case CV_REG_XMM30:
	case CV_REG_XMM31:
	case CV_REG_XMM32:
	case CV_REG_XMM33:
	case CV_REG_XMM40:
	case CV_REG_XMM41:
	case CV_REG_XMM42:
	case CV_REG_XMM43:
	case CV_REG_XMM50:
	case CV_REG_XMM51:
	case CV_REG_XMM52:
	case CV_REG_XMM53:
	case CV_REG_XMM60:
	case CV_REG_XMM61:
	case CV_REG_XMM62:
	case CV_REG_XMM63:
	case CV_REG_XMM70:
	case CV_REG_XMM71:
	case CV_REG_XMM72:
	case CV_REG_XMM73:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( float );
		break;

	case CV_REG_MXCSR:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( DWORD );
		break;

	case CV_REG_MM00:
	case CV_REG_MM01:
	case CV_REG_MM10:
	case CV_REG_MM11:
	case CV_REG_MM20:
	case CV_REG_MM21:
	case CV_REG_MM30:
	case CV_REG_MM31:
	case CV_REG_MM40:
	case CV_REG_MM41:
	case CV_REG_MM50:
	case CV_REG_MM51:
	case CV_REG_MM60:
	case CV_REG_MM61:
	case CV_REG_MM70:
	case CV_REG_MM71:
		lpvRegValue = (LPBYTE) (lpvRegValue) + sizeof( float );
		break;

    default:

        lpvRegValue = NULL;
        break;
    }

    return lpvRegValue;
}                               /* DoSetReg() */



LPVOID
X86DoSetFrameReg(
    HPID hpid,
    HTID htid,
    LPTHD lpthd,
    PKNONVOLATILE_CONTEXT_POINTERS contextPtrs,
    DWORD ireg,
    LPVOID lpvRegValue
    )
{
    return X86DoSetReg( (LPCONTEXT) lpthd->regs, ireg, lpvRegValue);
}


XOSD
X86DoGetFrame(
    HPID hpid,
    HTID uhtid,
    DWORD wValue,
    DWORD lValue
    )
{
    HPRC hprc = ValidHprcFromHpid(hpid);
    HTHD hthd;
    LPTHD lpthd;
    HTID htid = (HTID)((DWORD)uhtid & ~1);
    HTID vhtid = (HTID)((DWORD)uhtid | 1);
    DWORD i;
    XOSD xosd;
    BOOL fGoodFrame;
    BOOL fReturnHtid = FALSE;
    ADDRESS_MODE  mode;
    LPPRC lpprc;

    if (!hprc) {
        return xosdBadProcess;
    }

    lpprc = (LPPRC)LLLock(hprc);

    if (wValue == (DWORD)-1) {
        wValue = 1;
        fReturnHtid = TRUE;
    }

    hthd = HthdFromHtid(hprc, htid);
    if (hthd == NULL) {
        return xosdBadThread;
    }

    lpthd = (LPTHD) LLLock( hthd );
    assert(lpthd != NULL);



    if ( uhtid == htid ) {

        //
        // first frame -
        // Get regs and clear STACKFRAME struct
        //

        if (lpthd->drt & (drtCntrlDirty|drtAllDirty)) {
            SendRequestX(dmfWriteReg,hpid,htid,sizeof(CONTEXT),lpthd->regs);
            lpthd->drt = (DRT) (lpthd->drt & ( ~(drtCntrlDirty | drtAllDirty) ) );
        }
        UpdateRegisters( hprc, hthd );

        ZeroMemory( &lpthd->StackFrame, sizeof(STACKFRAME) );
        memcpy (lpthd->frameRegs, lpthd->regs, sizeof(CONTEXT) );
        lpthd->frameNumber = 0;

        //
        // set the addressing mode
        //
        if (lpthd->fFlat || lpprc->dmi.fAlwaysFlat ) {
            mode = AddrModeFlat;
        } else
        if (lpthd->fReal) {
            mode = AddrModeReal;
        } else
        if (lpthd->fOff32) {
            mode = AddrMode1632;
        } else {
            mode = AddrMode1616;
        }

        //
        // setup the program counter
        //
        lpthd->StackFrame.AddrPC.Offset       = ((PCONTEXT) (lpthd->regs))->Eip;
        lpthd->StackFrame.AddrPC.Segment      = (WORD)((PCONTEXT) (lpthd->regs))->SegCs;
        lpthd->StackFrame.AddrPC.Mode         = mode;

        //
        // setup the frame pointer
        //
        lpthd->StackFrame.AddrFrame.Offset    = ((PCONTEXT) (lpthd->regs))->Ebp;
        lpthd->StackFrame.AddrFrame.Segment   = (WORD)((PCONTEXT) (lpthd->regs))->SegSs;
        lpthd->StackFrame.AddrFrame.Mode         = mode;

        //
        // setup the stack pointer
        //
        lpthd->StackFrame.AddrStack.Offset    = ((PCONTEXT) (lpthd->regs))->Esp;
        lpthd->StackFrame.AddrStack.Segment   = (WORD)((PCONTEXT) (lpthd->regs))->SegSs;
        lpthd->StackFrame.AddrStack.Mode         = mode;
    }

    fGoodFrame = FALSE;
    xosd = xosdNone;
    for (i = 0; xosd == xosdNone && ((wValue != 0)? (i < wValue) : 1); i++) {

        if (StackWalk( IMAGE_FILE_MACHINE_I386,
                       hpid,
                       htid,
                       &lpthd->StackFrame,
                       lpthd->frameRegs,
                       SwReadMemory,
                       X86SwFunctionTableAccess,
                       SwGetModuleBase,
                       SwTranslateAddress
                       ))
        {
            xosd = xosdNone;

			if (lpthd->frameNumber == 0) {
				lpthd->offBetterTopFrame = lpthd->StackFrame.AddrFrame.Offset;
			}
				
            lpthd->frameNumber++;
            fGoodFrame = TRUE;
        } else {
            xosd = xosdEndOfStack;
        }
    }

    if (fGoodFrame) {
        *(LPHTID)lValue = fReturnHtid? htid : vhtid;
    }

    LLUnlock( hthd );
    LLUnlock( hprc );

    return xosd;
}



PFPO_DATA
SwSearchFpoData(
    DWORD     key,
    PFPO_DATA base,
    DWORD     num
    )
{
    PFPO_DATA  lo = base;
    PFPO_DATA  hi = base + (num - 1);
    PFPO_DATA  mid;
    DWORD      half;

    while (lo <= hi) {
        if (half = num / 2) {
            mid = lo + (num & 1 ? half : (half - 1));
            if ((key >= mid->ulOffStart)&&
                       (key < (mid->ulOffStart+mid->cbProcSize))) {
                return mid;
            }
            if (key < mid->ulOffStart) {
                hi = mid - 1;
                num = num & 1 ? half : half-1;
            }
            else {
                lo = mid + 1;
                num = half;
            }
        }
        else if (num) {
            if ((key >= lo->ulOffStart)&&
                                     (key < (lo->ulOffStart+lo->cbProcSize))) {
                return lo;
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    return(NULL);
}

LPVOID
X86SwFunctionTableAccess(
    LPVOID  lpvhpid,
    DWORD   AddrBase
    )
{
    HMDI        hmdi  = 0;
    LPMDI       lpmdi = 0;
    DWORD       off;
    HPID        hpid = (HPID)lpvhpid;
    PFPO_DATA   pFpo = NULL;

    hmdi = SwGetMdi( hpid, AddrBase );

    if (hmdi) {

        lpmdi = (LPMDI) LLLock( hmdi );

        if (lpmdi) {
            if (lpmdi->lpDebug) {

                off = ConvertOmapToSrc( lpmdi, AddrBase );

                if (off) {
                    AddrBase = off;
                }

                pFpo = SwSearchFpoData( AddrBase-lpmdi->lpBaseOfDll,
                                        (PFPO_DATA) lpmdi->lpDebug->lpRtf,
                                        lpmdi->lpDebug->cRtf
                                      );
            }
            LLUnlock( hmdi );
        }
    }

    return (LPVOID)pFpo;
}

XOSD
X86DoGetFunctionInfo(
    HPID hpid,
    LPGFI lpgfi
    )
{
    PFPO_DATA pFpo;

    assert(!ADDR_IS_LI(*lpgfi->lpaddr));
    assert(ADDR_IS_FLAT(*lpgfi->lpaddr));

    pFpo = (PFPO_DATA)X86SwFunctionTableAccess((LPVOID)hpid, GetAddrOff(*(lpgfi->lpaddr)));

    if (pFpo) {
        AddrInit(&lpgfi->lpFunctionInformation->AddrStart,
                 0, (SEGMENT) 0, pFpo->ulOffStart,
                 TRUE, TRUE, FALSE, FALSE);
        AddrInit(&lpgfi->lpFunctionInformation->AddrEnd,
                 0, (SEGMENT) 0, pFpo->ulOffStart + pFpo->cbProcSize,
                 TRUE, TRUE, FALSE, FALSE);
        AddrInit(&lpgfi->lpFunctionInformation->AddrPrologEnd,
                 0, (SEGMENT) 0, pFpo->ulOffStart + pFpo->cbProlog,
                 TRUE, TRUE, FALSE, FALSE);
        return xosdNone;
    } else {
        return xosdUnknown;
    }
}


DWORD
SwTranslateAddress(
    LPVOID    lpvhpid,
    LPVOID    lpvhtid,
    LPADDRESS lpaddress
    )
{
    XOSD               xosd;

        const DWORD        dwPigLen = sizeof(ADDR) + 4;
        const DWORD        dwTotalLen = sizeof(SSS) + sizeof(IOCTLGENERIC) + dwPigLen;

    ADDR               addr;
    BYTE               buf[dwTotalLen];
    HPID               hpid = (HPID)lpvhpid;
    HTID               htid = (HTID)lpvhtid;
    LPSSS              lpsss = (LPSSS)buf;
    PIOCTLGENERIC      pig   = (PIOCTLGENERIC)lpsss->rgbData;


    ZeroMemory( &addr, sizeof(addr) );
    addr.addr.off     = lpaddress->Offset;
    addr.addr.seg     = lpaddress->Segment;
    addr.mode.fFlat   = lpaddress->Mode == AddrModeFlat;
    addr.mode.fOff32  = lpaddress->Mode == AddrMode1632;
    addr.mode.fReal   = lpaddress->Mode == AddrModeReal;

    memcpy( pig->data, &addr, sizeof(addr) );

    lpsss->ssvc           = (SSVC)ssvcGeneric;
        lpsss->cbSend             = sizeof(IOCTLGENERIC) + dwPigLen;
    pig->length           = dwPigLen;
    pig->ioctlSubType     = IG_TRANSLATE_ADDRESS;
    xosd = SystemService(hpid, htid, dwTotalLen, lpsss);

    if (xosd == xosdNone) {
        addr = *((LPADDR)pig->data);

        lpaddress->Offset   = addr.addr.off;
        lpaddress->Segment  = (WORD)addr.addr.seg;

        if (addr.mode.fFlat) {
            lpaddress->Mode = AddrModeFlat;
        } else
        if (addr.mode.fOff32) {
            lpaddress->Mode = AddrMode1632;
        } else
        if (addr.mode.fReal) {
            lpaddress->Mode = AddrModeReal;
        }

        return TRUE;
    }

    return FALSE;
}


XOSD
X86DoGetFrameEH(
    HPID hpid,
    HTID htid,
    LPEXHDLR *lpexhdlr,
    LPDWORD cAddrsAllocated
)
/*++

Routine Description:

    Fill lpexhdlr with the addresses of all exception handlers for this frame

Arguments

    hpid            - current hpid

    htid            - current htid (may be virtual)

    lpexhdlr        - where to store address

    cAddrsAllocated - how many addresses are currently allocated

Return Value:

    xosd status

--*/
{
    return(xosdUnsupported);
}




//////////////////////////////////////////////////////////////////
//  part 2.  Additional target dependent
//////////////////////////////////////////////////////////////////

XOSD
X86UpdateChild (
    HPID hpid,
    HTID htid,
    DMF dmfCommand
    )
/*++

Routine Description:

    This function is used to cause registers to be written back to
    the child as necessary before the child is executed.

Arguments:

    hprc        - Supplies a process handle

    hthdExec    - Supplies the handle of the thread to update

    dmfCommand  - Supplies the command about to be executed.

Return Value:

    XOSD error code

--*/

{
    HPRC  hprc;
    HTHD  hthd;
    HTHD  hthdExec;
    XOSD  xosd  = xosdNone;
    HLLI  llthd;
    LPPRC lpprc;
    PST pst;
    HLLI    hllmdi;
    HMDI    hmdi;

    hprc = HprcFromHpid(hpid);
    hthdExec = HthdFromHtid(hprc, htid);

    llthd = LlthdFromHprc ( hprc );

    xosd = ProcessStatus(hpid, &pst);

    if (xosd != xosdNone) {
        return xosd;
    }

    if (pst.dwProcessState == pstDead || pst.dwProcessState == pstExited) {
        return xosdBadProcess;
    }

    else if (pst.dwProcessState != pstRunning)

    {
        for ( hthd = LLNext ( llthd, hthdNull );
              hthd != hthdNull;
              hthd = LLNext ( llthd, hthd ) ) {

            LPTHD lpthd = (LPTHD) LLLock ( hthd );

            if ( lpthd->drt & (drtCntrlDirty | drtAllDirty) ) {
                assert(lpthd->drt & drtAllPresent);
                SendRequestX (dmfWriteReg,
                              hpid,
                              lpthd->htid,
                              sizeof ( CONTEXT ),
                              lpthd->regs
                             );

                lpthd->drt = (DRT) (lpthd->drt & ~(drtCntrlDirty | drtAllDirty) ) ;
            }
            if ( lpthd->drt & drtSpecialDirty ) {
                assert(lpthd->drt & drtSpecialPresent);
                if (lpthd->dwcbSpecial) {

                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr0 =
                                                 ((PCONTEXT) (lpthd->regs))->Dr0;
                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr1 =
                                                 ((PCONTEXT)  (lpthd->regs))->Dr1;
                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr2 =
                                                 ((PCONTEXT) (lpthd->regs))->Dr2;
                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr3 =
                                                 ((PCONTEXT) (lpthd->regs))->Dr3;
                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr6 =
                                                 ((PCONTEXT) (lpthd->regs))->Dr6;
                    ((PKSPECIAL_REGISTERS)(lpthd->pvSpecial))->KernelDr7 =
                                                 ((PCONTEXT) (lpthd->regs))->Dr7;

                    SendRequestX(dmfWriteRegEx,
                                 hpid,
                                 lpthd->htid,
                                 lpthd->dwcbSpecial,
                                 lpthd->pvSpecial
                                );
                } else {

                    DWORD DR[6];
                    DR[0] = ((PCONTEXT) (lpthd->regs) )->Dr0;
                    DR[1] = ((PCONTEXT) (lpthd->regs) )->Dr1;
                    DR[2] = ((PCONTEXT) (lpthd->regs) )->Dr2;
                    DR[3] = ((PCONTEXT) (lpthd->regs) )->Dr3;
                    DR[4] = ((PCONTEXT) (lpthd->regs) )->Dr6;
                    DR[5] = ((PCONTEXT) (lpthd->regs) )->Dr7;
                    SendRequestX (dmfWriteRegEx,
                                  hpid,
                                  lpthd->htid,
                                  sizeof ( DR ),
                                  DR
                                 );
                }
                lpthd->drt = (DRT) (lpthd->drt & ~drtSpecialDirty);
            }

            lpthd->fRunning = TRUE;

            LLUnlock ( hthd );

            if ( xosd != xosdNone ) {
                break;
            }
        }
        lpprc = (LPPRC) LLLock(hprc);
        lpprc->fRunning = TRUE;
        hllmdi = lpprc->llmdi;

        while ( hmdi = LLFind ( hllmdi, NULL, NULL, emdiNLG ) ) {
            LPMDI   lpmdi = (LPMDI) LLLock ( hmdi );
            NLG     nlg = lpmdi->nlg;

            FixupAddr ( hpid, htid, &nlg.addrNLGDispatch );
            FixupAddr ( hpid, htid, &nlg.addrNLGDestination );
            FixupAddr ( hpid, htid, &nlg.addrNLGReturn );

//          SwapNlg ( &nlg );

            xosd = SendRequestX(dmfNonLocalGoto,
                                HpidFromHprc ( hprc ),
                                NULL,
                                sizeof ( nlg ),
                                &nlg
                                );

            lpmdi->fSendNLG = FALSE;
            LLUnlock ( hmdi );
        }

        LLUnlock(hprc);
    }

    return xosd;
}




XOSD
X86GetRegValue (
    HPID hpid,
    HTID htid,
    DWORD ireg,
    LPVOID lpvRegValue
    )
{
    HPRC        hprc;
    HTHD        hthd;
    LPTHD       lpthd;
    LPPRC       lpprc;
    LPCONTEXT   lpregs;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }

    if ( (DWORD)htid & 1 ) {
        return GetFrameRegValue(hpid, (HTID)((DWORD)htid & ~1), ireg, lpvRegValue);
    }

    hthd = HthdFromHtid(hprc, htid);
    assert ( hthd != hthdNull );

    lpthd = (LPTHD) LLLock ( hthd );
    lpprc = (LPPRC) LLLock( hprc );

    lpregs = (LPCONTEXT) (lpthd->regs);

    if (lpthd->fRunning) {
        UpdateRegisters( lpthd->hprc, hthd );
        X86UpdateSpecialRegisters( lpthd->hprc, hthd );

        if (lpprc->dmi.fAlwaysFlat || ( ((LPCONTEXT) (lpthd->regs))->SegCs == lpprc->selFlatCs) ) {
            lpthd->fFlat = lpthd->fOff32 = TRUE;
            lpthd->fReal = FALSE;
        } else {
            /*
             *  BUGBUG -- jimsch -- some one might eventually catch on
             *  that this is incorrect.  We are not checking to see if the
             *  current address is really a 16-bit WOW address but assuming
             *  that it is.  This will be a problem for people who are doing
             *  real 16:32 programming (on WOW) and people who are doing
             *  real mode program -- but so what
             */
            lpthd->fFlat = lpthd->fOff32 = lpthd->fReal = FALSE;
        }
    } else {

        if ( !(lpthd->drt & drtAllPresent) ) {

            switch ( ireg ) {


            case CV_REG_CS:
            case CV_REG_IP:
            case CV_REG_SS:
            case CV_REG_BP:

            case CV_REG_EIP:
            case CV_REG_EBP:
                if (!(lpthd->drt & drtCntrlPresent)) {
                    UpdateRegisters( lpthd->hprc, hthd );
                }
                break;

            default:

                UpdateRegisters ( lpthd->hprc, hthd );
                break;
            }
        }


        if ( !(lpthd->drt & drtSpecialPresent) ) {

            switch ( ireg ) {

            case CV_REG_GDTR:
            case CV_REG_GDTL:
            case CV_REG_IDTR:
            case CV_REG_IDTL:
            case CV_REG_LDTR:
            case CV_REG_TR:

            case CV_REG_CR0:
            case CV_REG_CR1:
            case CV_REG_CR2:
            case CV_REG_CR3:
            case CV_REG_CR4:

            case CV_REG_DR0:
            case CV_REG_DR1:
            case CV_REG_DR2:
            case CV_REG_DR3:
            case CV_REG_DR4:
            case CV_REG_DR5:
            case CV_REG_DR6:
            case CV_REG_DR7:

                X86UpdateSpecialRegisters( lpthd->hprc, hthd );
                break;

            default:
                break;
            }
        }
    }

    switch ( ireg ) {

        case CV_REG_GDTR:
        case CV_REG_GDTL:
        case CV_REG_IDTR:
        case CV_REG_IDTL:
        case CV_REG_LDTR:
        case CV_REG_TR:

        case CV_REG_CR0:
        case CV_REG_CR1:
        case CV_REG_CR2:
        case CV_REG_CR3:
        case CV_REG_CR4:

            lpregs = (LPCONTEXT) lpthd->pvSpecial;
            break;

        default:
            break;
    }


    LLUnlock( hprc );
    LLUnlock( hthd );

	if ( ireg==CV_ALLREG_TEB )
	{
		// get @TEB pseudo-register
		*( (LPLONG)lpvRegValue ) = lpthd->uoffTEB;
	}
	else if ( ireg==CV_ALLREG_ERR || ireg==CV_ALLREG_TIMER )
	{
		// get @ERR psuedo-register, have to ask the DM
		// get @CLK psuedo-register, have to ask the DM
        GuardTL();
		XOSD xosd = SendRequestX( dmfGetSpecialReg, hpid, htid, sizeof(ireg),
                             &ireg);

        if (xosd==xosdNone)
            *( (LPLONG) lpvRegValue ) = *(DWORD*)LpDmMsg->rgb;
        ReleaseTL();
        if(xosd != xosdNone)
            return xosd;
	}
	else
	{
		*(PDWORD)lpvRegValue = lpprc->dmi.Processor.Flags;
		lpvRegValue = X86DoGetReg ( lpregs, ireg & 0xff, lpvRegValue );
	}

    if ( lpvRegValue == NULL ) {
        LLUnlock ( hthd );
        return xosdInvalidParameter;
    }
    ireg = ireg >> 8;

    if ( ireg != CV_REG_NONE ) {
        *(PDWORD)lpvRegValue = lpprc->dmi.Processor.Flags;
        lpvRegValue = X86DoGetReg ( lpregs, ireg, lpvRegValue );
        if ( lpvRegValue == NULL ) {
            return xosdInvalidParameter;
        }
    }

    return xosdNone;

}                        /* GetRegValue */





XOSD
X86SetRegValue (
    HPID hpid,
    HTID htid,
    DWORD ireg,
    LPVOID lpvRegValue
    )
{
    XOSD        xosd = xosdNone;
    HPRC        hprc;
    HTHD        hthd;
    LPTHD       lpthd;
    LPVOID      lpregs = NULL;

    hprc = ValidHprcFromHpid(hpid);
    if (!hprc) {
        return xosdBadProcess;
    }
    hthd = HthdFromHtid(hprc, htid);
    assert ( hthd != hthdNull );

    lpthd = (LPTHD) LLLock ( hthd );

    switch ( ireg ) {
        case CV_REG_GDTR:
        case CV_REG_GDTL:
        case CV_REG_IDTR:
        case CV_REG_IDTL:
        case CV_REG_LDTR:
        case CV_REG_TR:

        case CV_REG_CR0:
        case CV_REG_CR1:
        case CV_REG_CR2:
        case CV_REG_CR3:
        case CV_REG_CR4:

            lpregs = lpthd->pvSpecial;
            // fall thru

        case CV_REG_DR0:
        case CV_REG_DR1:
        case CV_REG_DR2:
        case CV_REG_DR3:
        case CV_REG_DR4:
        case CV_REG_DR5:
        case CV_REG_DR6:
        case CV_REG_DR7:

            if (!(lpthd->drt & drtSpecialPresent)) {
                X86UpdateSpecialRegisters( lpthd->hprc, hthd );
            }
            break;

        default:

            lpregs = lpthd->regs;

            if ( !(lpthd->drt & drtAllPresent) ) {
                UpdateRegisters ( lpthd->hprc, hthd );
            }
            break;
    }

	if (ireg==CV_ALLREG_TIMER)
	{
		SHREG shreg;
		shreg.hReg = (WORD)ireg;
		shreg.Byte4 = *(PDWORD)lpvRegValue;

		XOSD xosd = SendRequestX( dmfSetSpecialReg, hpid, htid, sizeof(shreg),
                        &shreg);

		if (xosd!=xosdNone)
			lpvRegValue = NULL;
	}
	else
	    lpvRegValue = X86DoSetReg ( (LPCONTEXT) lpregs, ireg & 0xff, lpvRegValue );

    if ( lpvRegValue == NULL ) {
        LLUnlock ( hthd );
        return xosdInvalidParameter;
    }

    ireg = ireg >> 8;
    if ( ireg != 0 ) {
        lpvRegValue = X86DoSetReg ( (LPCONTEXT) lpregs, ireg, lpvRegValue );
    }
    if ( lpvRegValue == NULL ) {
        LLUnlock ( hthd );
        return xosdInvalidParameter;
    }


    switch ( ireg ) {
        case CV_REG_GDTR:
        case CV_REG_GDTL:
        case CV_REG_IDTR:
        case CV_REG_IDTL:
        case CV_REG_LDTR:
        case CV_REG_TR:

        case CV_REG_CR0:
        case CV_REG_CR1:
        case CV_REG_CR2:
        case CV_REG_CR3:
        case CV_REG_CR4:

        case CV_REG_DR0:
        case CV_REG_DR1:
        case CV_REG_DR2:
        case CV_REG_DR3:
        case CV_REG_DR4:
        case CV_REG_DR5:
        case CV_REG_DR6:
        case CV_REG_DR7:

            lpthd->drt = (DRT) (lpthd->drt | drtAllDirty);
            break;

        default:

            lpthd->drt = (DRT) (lpthd->drt | drtAllDirty);
            break;
    }



    LLUnlock ( hthd );

    return xosd;

}


void
X86UpdateSpecialRegisters (
    HPRC hprc,
    HTHD hthd
    )
{

    LPTHD lpthd = (LPTHD) LLLock ( hthd );

    GuardTL();
    SendRequest ( dmfReadRegEx, HpidFromHprc ( hprc ), HtidFromHthd ( hthd ) );

    if (lpthd->dwcbSpecial) {
        //
        // in kernel mode...
        //
        _fmemcpy ( lpthd->pvSpecial, LpDmMsg->rgb, lpthd->dwcbSpecial );
        ((PCONTEXT) (lpthd->regs))->Dr0 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr0;
        ((PCONTEXT) (lpthd->regs))->Dr1 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr1;
        ((PCONTEXT) (lpthd->regs))->Dr2 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr2;
        ((PCONTEXT) (lpthd->regs))->Dr3 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr3;
        ((PCONTEXT) (lpthd->regs))->Dr6 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr6;
        ((PCONTEXT) (lpthd->regs))->Dr7 = ((PKSPECIAL_REGISTERS)(LpDmMsg->rgb))->KernelDr7;
    } else {
        //
        // User mode
        //
        ((PCONTEXT) (lpthd->regs))->Dr0 = ((LPDWORD)(LpDmMsg->rgb))[0];
        ((PCONTEXT) (lpthd->regs))->Dr1 = ((LPDWORD)(LpDmMsg->rgb))[1];
        ((PCONTEXT) (lpthd->regs))->Dr2 = ((LPDWORD)(LpDmMsg->rgb))[2];
        ((PCONTEXT) (lpthd->regs))->Dr3 = ((LPDWORD)(LpDmMsg->rgb))[3];
        ((PCONTEXT) (lpthd->regs))->Dr6 = ((LPDWORD)(LpDmMsg->rgb))[4];
        ((PCONTEXT) (lpthd->regs))->Dr7 = ((LPDWORD)(LpDmMsg->rgb))[5];
    }
    ReleaseTL();

    lpthd->drt = (DRT) (lpthd->drt & (~drtSpecialDirty) );
    lpthd->drt = (DRT) (lpthd->drt | drtSpecialPresent);

    LLUnlock ( hthd );

}




void
X86CopyFrameRegs(
    LPTHD lpthd,
    LPBPR lpbpr
    )
{
    ((PCONTEXT) (lpthd->regs))->SegCs   = lpbpr->segCS;
    ((PCONTEXT) (lpthd->regs))->SegSs   = lpbpr->segSS;
    ((PCONTEXT) (lpthd->regs))->Eip     = lpbpr->offEIP;
    ((PCONTEXT) (lpthd->regs))->Ebp     = lpbpr->offEBP;
}


void
X86AdjustForProlog(
    HPID hpid,
    HTID htid,
    PADDR origAddr,
    CANSTEP *CanStep
    )
{
    Unreferenced(hpid);
    Unreferenced(htid);
    Unreferenced(origAddr);
    Unreferenced(CanStep);
}


XOSD
X86GetFrameWithSrc(
	HPID	hpid,
	HTID	htid,
	UINT	cFrames,
	LPHTID	lphtid
	)
{
	HTID	hvtid;
	ADDR	addr = {0};
	XOSD	xosd;
	UINT	i;

	union {
		ADDR	addr;
		CANSTEP	CanStep;
	} buf;

	*lphtid = NULL;
	
	xosd = X86DoGetFrame (hpid, htid, 1, (LPARAM) &hvtid);

	if (xosd != xosdNone) {
		return xosd;
	}


	for (
		xosd = X86DoGetFrame (hpid, htid, 1, (LPARAM) &hvtid), i = 0;
		xosd == xosdNone, i < cFrames;
		xosd = X86DoGetFrame (hpid, hvtid, 1, (LPARAM) &hvtid), i++
		)
	{

		xosd = X86GetAddr (hpid, hvtid, adrPC, &addr);

		if (xosd != xosdNone) {
			return xosd;
		}

		buf.addr = addr;
			
		xosd = CallDB (dbcCanStep,
					   hpid,
					   htid,
					   CEXM_MDL_native,
					   NULL,
					   &buf);

		if (buf.CanStep.Flags == CANSTEP_YES) {
			*lphtid = hvtid;
			return xosdNone;
		}
	}

	return xosdEndOfStack;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\resource.h ===
//
// Used by em.rc
//

#ifndef RC_INVOKED
#define DECL_XOSD(n,v,s) IDS_##n = v,
enum _XOSD_STRINGS {
#include <xosd.h>
};
#undef DECL_XOSD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\res_str.h ===
#if ! defined( _RES_STR_ )
#define _RES_STR_

#define DECL_XOSD(n, v, s) v, s
STRINGTABLE DISCARDABLE
BEGIN

#include <xosd.h>

END

#endif // _RES_STR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\str_x86.h ===
#define   SzAH           "AH"
#define   SzAL           "AL"
#define   SzAX           "AX"
#define   SzEAX          "EAX"
#define   SzBH           "BH"
#define   SzBL           "BL"
#define   SzBX           "BX"
#define   SzEBX          "EBX"
#define   SzCH           "CH"
#define   SzCL           "CL"
#define   SzCX           "CX"
#define   SzECX          "ECX"
#define   SzDH           "DH"
#define   SzDL           "DL"
#define   SzDX           "DX"
#define   SzEDX          "EDX"
#define   SzSI           "SI"
#define   SzESI          "ESI"
#define   SzDI           "DI"
#define   SzEDI          "EDI"
#define   SzSP           "SP"
#define   SzESP          "ESP"
#define   SzBP           "BP"
#define   SzEBP          "EBP"
#define   SzIP           "IP"
#define   SzEIP          "EIP"
#define   SzFlags        "FL"
#define   SzEFlags       "EFL"
#define   SzCS           "CS"
#define   SzDS           "DS"
#define   SzES           "ES"
#define   SzSS           "SS"
#define   SzFS           "FS"
#define   SzGS           "GS"
#define   SzST0          "ST0"
#define   SzST1          "ST1"
#define   SzST2          "ST2"
#define   SzST3          "ST3"
#define   SzST4          "ST4"
#define   SzST5          "ST5"
#define   SzST6          "ST6"
#define   SzST7          "ST7"
#define   SzCtrl         "CTRL"
#define   SzStat         "STAT"
#define   SzTag          "TAGS"
#define   SzFpIp         "IP"
#define   SzFpEip        "EIP"
#define   SzFpCs         "CS"
#define   SzFpDo         "DO"
#define   SzFpEdo        "EDO"
#define   SzFpDs         "DS"

#define   SzCr0          "Cr0"
#define   SzCr2          "Cr2"
#define   SzCr3          "Cr3"
#define   SzCr4          "Cr4"

#define   SzMM0          "MM0"
#define   SzMM1          "MM1"
#define   SzMM2          "MM2"
#define   SzMM3          "MM3"
#define   SzMM4          "MM4"
#define   SzMM5          "MM5"
#define   SzMM6          "MM6"
#define   SzMM7          "MM7"

#define   SzEMM0L          "XMM0IL"
#define   SzEMM1L          "XMM1Il"
#define   SzEMM2L          "XMM2IL"
#define   SzEMM3L          "XMM3IL"
#define   SzEMM4L          "XMM4IL"
#define   SzEMM5L          "XMM5IL"
#define   SzEMM6L          "XMM6IL"
#define   SzEMM7L          "XMM7IL"
#define   SzEMM0H          "XMM0IH"
#define   SzEMM1H          "XMM1IH"
#define   SzEMM2H          "XMM2IH"
#define   SzEMM3H          "XMM3IH"
#define   SzEMM4H          "XMM4IH"
#define   SzEMM5H          "XMM5IH"
#define   SzEMM6H          "XMM6IH"
#define   SzEMM7H          "XMM7IH"

#define   SzXMM0L          "XMM0DL"
#define   SzXMM1L          "XMM1DL"
#define   SzXMM2L          "XMM2DL"
#define   SzXMM3L          "XMM3DL"
#define   SzXMM4L          "XMM4DL"
#define   SzXMM5L          "XMM5DL"
#define   SzXMM6L          "XMM6DL"
#define   SzXMM7L          "XMM7DL"
#define   SzXMM0H          "XMM0DH"
#define   SzXMM1H          "XMM1DH"
#define   SzXMM2H          "XMM2DH"
#define   SzXMM3H          "XMM3DH"
#define   SzXMM4H          "XMM4DH"
#define   SzXMM5H          "XMM5DH"
#define   SzXMM6H          "XMM6DH"
#define   SzXMM7H          "XMM7DH"

#define   SzXMM0          "XMM0"
#define   SzXMM1          "XMM1"
#define   SzXMM2          "XMM2"
#define   SzXMM3          "XMM3"
#define   SzXMM4          "XMM4"
#define   SzXMM5          "XMM5"
#define   SzXMM6          "XMM6"
#define   SzXMM7          "XMM7"

#define   SzXMM00          "XMM00"
#define   SzXMM01          "XMM01"
#define   SzXMM02          "XMM02"
#define   SzXMM03          "XMM03"
#define   SzXMM10          "XMM10"
#define   SzXMM11          "XMM11"
#define   SzXMM12          "XMM12"
#define   SzXMM13          "XMM13"
#define   SzXMM20          "XMM20"
#define   SzXMM21          "XMM21"
#define   SzXMM22          "XMM22"
#define   SzXMM23          "XMM23"
#define   SzXMM30          "XMM30"
#define   SzXMM31          "XMM31"
#define   SzXMM32          "XMM32"
#define   SzXMM33          "XMM33"
#define   SzXMM40          "XMM40"
#define   SzXMM41          "XMM41"
#define   SzXMM42          "XMM42"
#define   SzXMM43          "XMM43"
#define   SzXMM50          "XMM50"
#define   SzXMM51          "XMM51"
#define   SzXMM52          "XMM52"
#define   SzXMM53          "XMM53"
#define   SzXMM60          "XMM60"
#define   SzXMM61          "XMM61"
#define   SzXMM62          "XMM62"
#define   SzXMM63          "XMM63"
#define   SzXMM70          "XMM70"
#define   SzXMM71          "XMM71"
#define   SzXMM72          "XMM72"
#define   SzXMM73          "XMM73"
#define   SzMxCsr          "MXCSR"

#define   SzDr0          "Dr0"
#define   SzDr1          "Dr1"
#define   SzDr2          "Dr2"
#define   SzDr3          "Dr3"
#define   SzDr6          "Dr6"
#define   SzDr7          "Dr7"
#define   SzGdtr         "GDTR"
#define   SzGdtl         "GDTL"
#define   SzIdtr         "IDTR"
#define   SzIdtl         "IDTL"
#define   SzTr           "TR"
#define   SzLdtr         "LDTR"

#define   SzOverflow     "OV"
#define   SzDirection    "UP"
#define   SzInterrupt    "EI"
#define   SzTrap         "TP"
#define   SzSign         "PL"
#define   SzZero         "ZR"
#define   SzACarry       "AC"
#define   SzParity       "PE"
#define   SzCarry        "CY"

#define   SzFrozen       "Frozen"
#define   SzSuspended    "Suspended"
#define   SzBlocked      "Blocked"

#define   SzRunnable     "Runnable"
#define   SzRunning      "Running"
#define   SzStopped      "Stopped"
#define   SzExiting      "Exiting"
#define   SzDead         "Dead"
#define   SzUnknown      "UNKNOWN"

#define   SzExcept1st    "Except1st"
#define   SzExcept2nd    "Except2nd"
#define   SzRipped       "RIP"

#define   SzCritSec      "CritSec"

#define   SzStandard     "Standard"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\include\ctxptrs.h ===
#if defined( _NTMIPS_ )  ||  defined( _NTALPHA_ )
#define _CTXPTRS_H_
#endif

#ifndef _CTXPTRS_H_
#define _CTXPTRS_H_

#if !defined( _ALPHA_ ) && !defined (TARGET_ALPHA)

typedef  ULONG  KNONVOLATILE_CONTEXT_POINTERS;
typedef PULONG PKNONVOLATILE_CONTEXT_POINTERS;

#else

//
// modified from ntalpha.h   June 7, 1993.
//

//
// Nonvolatile context pointer record.
//

typedef struct _KNONVOLATILE_CONTEXT_POINTERS {

    PLARGE_INTEGER FloatingContext[1];
    PLARGE_INTEGER FltF1;
    // Nonvolatile floating point registers start here.
    PLARGE_INTEGER FltF2;
    PLARGE_INTEGER FltF3;
    PLARGE_INTEGER FltF4;
    PLARGE_INTEGER FltF5;
    PLARGE_INTEGER FltF6;
    PLARGE_INTEGER FltF7;
    PLARGE_INTEGER FltF8;
    PLARGE_INTEGER FltF9;
    PLARGE_INTEGER FltF10;
    PLARGE_INTEGER FltF11;
    PLARGE_INTEGER FltF12;
    PLARGE_INTEGER FltF13;
    PLARGE_INTEGER FltF14;
    PLARGE_INTEGER FltF15;
    PLARGE_INTEGER FltF16;
    PLARGE_INTEGER FltF17;
    PLARGE_INTEGER FltF18;
    PLARGE_INTEGER FltF19;
    PLARGE_INTEGER FltF20;
    PLARGE_INTEGER FltF21;
    PLARGE_INTEGER FltF22;
    PLARGE_INTEGER FltF23;
    PLARGE_INTEGER FltF24;
    PLARGE_INTEGER FltF25;
    PLARGE_INTEGER FltF26;
    PLARGE_INTEGER FltF27;
    PLARGE_INTEGER FltF28;
    PLARGE_INTEGER FltF29;
    PLARGE_INTEGER FltF30;
    PLARGE_INTEGER FltF31;

    PLARGE_INTEGER IntegerContext[1];
    PLARGE_INTEGER IntT0;
    PLARGE_INTEGER IntT1;
    PLARGE_INTEGER IntT2;
    PLARGE_INTEGER IntT3;
    PLARGE_INTEGER IntT4;
    PLARGE_INTEGER IntT5;
    PLARGE_INTEGER IntT6;
    PLARGE_INTEGER IntT7;
    // Nonvolatile integer registers start here.
    PLARGE_INTEGER IntS0;
    PLARGE_INTEGER IntS1;
    PLARGE_INTEGER IntS2;
    PLARGE_INTEGER IntS3;
    PLARGE_INTEGER IntS4;
    PLARGE_INTEGER IntS5;
    PLARGE_INTEGER IntFp;
    PLARGE_INTEGER IntA0;
    PLARGE_INTEGER IntA1;
    PLARGE_INTEGER IntA2;
    PLARGE_INTEGER IntA3;
    PLARGE_INTEGER IntA4;
    PLARGE_INTEGER IntA5;
    PLARGE_INTEGER IntT8;
    PLARGE_INTEGER IntT9;
    PLARGE_INTEGER IntT10;
    PLARGE_INTEGER IntT11;
    PLARGE_INTEGER IntRa;
    PLARGE_INTEGER IntT12;
    PLARGE_INTEGER IntAt;
    PLARGE_INTEGER IntGp;
    PLARGE_INTEGER IntSp;
    PLARGE_INTEGER IntZero;

} KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

#endif  // !_ALPHA_ && !TARGET_ALPHA

#endif  //  _CTXPTRS_H_

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\regs_x86.h ===
{ SzAH,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_AH },
    { SzAL,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_AL },
    { SzAX,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_AX },
    { SzEAX,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_EAX },
    { SzBH,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_BH },
    { SzBL,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_BL },
    { SzBX,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_BX },
    { SzEBX,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_EBX },
    { SzCH,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_CH },
    { SzCL,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_CL },
    { SzCX,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_CX },
    { SzECX,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_ECX },
    { SzDH,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_DH },
    { SzDL,     rtCPU | rtInvisible | rtInteger,        8,  0, CV_REG_DL },
    { SzDX,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_DX },
    { SzEDX,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_EDX },
    { SzSI,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_SI },
    { SzESI,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_ESI },
    { SzDI,     rtCPU | rtRegular  | rtInteger,         16, 0, CV_REG_DI },
    { SzEDI,    rtCPU | rtExtended | rtInteger,         32, 0, CV_REG_EDI },

    { SzIP,     rtCPU | rtRegular  | rtInteger | rtPC | rtNewLine,  16, 0, CV_REG_IP },
    { SzEIP,    rtCPU | rtExtended | rtInteger | rtPC | rtNewLine,  32, 0, CV_REG_EIP },
    { SzSP,     rtCPU | rtRegular  | rtInteger | rtFrame, 16, 0, CV_REG_SP },
    { SzESP,    rtCPU | rtExtended | rtInteger | rtFrame, 32, 0, CV_REG_ESP },
    { SzBP,     rtCPU | rtRegular  | rtInteger | rtFrame, 16, 0, CV_REG_BP },
    { SzEBP,    rtCPU | rtExtended | rtInteger | rtFrame, 32, 0, CV_REG_EBP },
    { SzFlags,  rtCPU | rtRegular  | rtInteger, 16, 0, CV_REG_FLAGS },
    { SzEFlags, rtCPU | rtExtended | rtInteger, 32, 0, CV_REG_EFLAGS },

    { SzMM0,     rtCPU | rtExtended | rtInteger | rtMMX | rtNewLine, 64, 0, CV_REG_MM0 },
	{ SzMM1,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM1 },
	{ SzMM2,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM2 },
	{ SzMM3,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM3 },
	{ SzMM4,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM4 },
	{ SzMM5,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM5 },
	{ SzMM6,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM6 },
	{ SzMM7,     rtCPU | rtExtended | rtInteger | rtMMX, 64, 0, CV_REG_MM7 },
	
    { SzXMM0L,     rtFPU | rtExtended | rtFloat | rtWillamette | rtNewLine, 64, 0, CV_REG_XMM0L },
	{ SzXMM0H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM0H },
	{ SzXMM1L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM1L },
	{ SzXMM1H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM1H },
	{ SzXMM2L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM2L },
	{ SzXMM2H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM2H },
	{ SzXMM3L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM3L },
	{ SzXMM3H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM3H },
    { SzXMM4L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM4L },
	{ SzXMM4H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM4H },
	{ SzXMM5L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM5L },
	{ SzXMM5H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM5H },
	{ SzXMM6L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM6L },
	{ SzXMM6H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM6H },
	{ SzXMM7L,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM7L },
	{ SzXMM7H,     rtFPU | rtExtended | rtFloat | rtWillamette, 64, 0, CV_REG_XMM7H },

	{ SzXMM0,    rtCPU | rtExtended | rtInteger | rtKatmai | rtNewLine, 128, 0, CV_REG_XMM0 },
    { SzXMM1,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM1 },
    { SzXMM2,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM2 },
    { SzXMM3,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM3 },
    { SzXMM4,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM4 },
    { SzXMM5,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM5 },
    { SzXMM6,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM6 },
    { SzXMM7,    rtCPU | rtExtended | rtInteger | rtKatmai, 128, 0, CV_REG_XMM7 },

    { SzXMM00,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM00 },
    { SzXMM01,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM01 },
    { SzXMM02,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM02 },
    { SzXMM03,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM03 },
    { SzXMM10,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM10 },
    { SzXMM11,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM11 },
    { SzXMM12,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM12 },
    { SzXMM13,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM13 },
    { SzXMM20,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM20 },
    { SzXMM21,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM21 },
    { SzXMM22,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM22 },
    { SzXMM23,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM23 },
    { SzXMM30,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM30 },
    { SzXMM31,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM31 },
    { SzXMM32,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM32 },
    { SzXMM33,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM33 },
    { SzXMM40,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM40 },
    { SzXMM41,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM41 },
    { SzXMM42,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM42 },
    { SzXMM43,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM43 },
    { SzXMM50,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM50 },
    { SzXMM51,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM51 },
    { SzXMM52,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM52 },
    { SzXMM53,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM53 },
    { SzXMM60,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM60 },
    { SzXMM61,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM61 },
    { SzXMM62,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM62 },
    { SzXMM63,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM63 },
    { SzXMM70,   rtFPU | rtExtended | rtFloat | rtKatmai | rtNewLine, 32, 0, CV_REG_XMM70 },
    { SzXMM71,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM71 },
    { SzXMM72,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM72 },
    { SzXMM73,   rtFPU | rtExtended | rtFloat | rtKatmai, 32, 0, CV_REG_XMM73 },
    { SzMxCsr,   rtFPU | rtExtended | rtInteger | rtKatmai, 32, 0, CV_REG_MXCSR },

    { SzCS,     rtCPU | rtExtended | rtRegular | rtInteger | rtPC | rtNewLine, 16, 0, CV_REG_CS },
    { SzDS,     rtCPU | rtExtended | rtRegular | rtInteger, 16, 0, CV_REG_DS },
    { SzES,     rtCPU | rtExtended | rtRegular | rtInteger, 16, 0, CV_REG_ES },
    { SzSS,     rtCPU | rtExtended | rtRegular | rtInteger | rtFrame, 16, 0, CV_REG_SS },
    { SzFS,     rtCPU | rtExtended | rtRegular | rtInteger, 16, 0, CV_REG_FS },
    { SzGS,     rtCPU | rtExtended | rtRegular | rtInteger, 16, 0, CV_REG_GS },

    { SzCr0,    rtCPU | rtSpecial | rtInteger | rtNewLine, 32, 0, CV_REG_CR0 },
    { SzCr2,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_CR2 },
    { SzCr3,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_CR3 },
    { SzCr4,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_CR4 },
    { SzDr0,    rtCPU | rtSpecial | rtInteger | rtNewLine, 32, 0, CV_REG_DR0 },
    { SzDr1,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_DR1 },
    { SzDr2,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_DR2 },
    { SzDr3,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_DR3 },
    { SzDr6,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_DR6 },
    { SzDr7,    rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_DR7 },
    { SzGdtr,   rtCPU | rtSpecial | rtInteger | rtNewLine, 32, 0, CV_REG_GDTR },
    { SzGdtl,   rtCPU | rtSpecial | rtInteger,             16, 0, CV_REG_GDTL },
    { SzIdtr,   rtCPU | rtSpecial | rtInteger,             32, 0, CV_REG_IDTR },
    { SzIdtl,   rtCPU | rtSpecial | rtInteger,             16, 0, CV_REG_IDTL },
    { SzTr,     rtCPU | rtSpecial | rtInteger,             16, 0, CV_REG_TR },
    { SzLdtr,   rtCPU | rtSpecial | rtInteger,             16, 0, CV_REG_LDTR },

	{ SzST0,    rtFPU | rtRegular | rtExtended | rtFloat | rtNewLine,   80, 0, CV_REG_ST0 },
    { SzST1,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST1 },
    { SzST2,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST2 },
    { SzST3,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST3 },
    { SzST4,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST4 },
    { SzST5,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST5 },
    { SzST6,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST6 },
    { SzST7,    rtFPU | rtRegular | rtExtended | rtFloat,   80, 0, CV_REG_ST7 },
    { SzCtrl,   rtFPU | rtRegular | rtExtended | rtInteger | rtNewLine, 16, 0, CV_REG_CTRL },
    { SzStat,   rtFPU | rtRegular | rtExtended | rtInteger, 16, 0, CV_REG_STAT },
    { SzTag,    rtFPU | rtRegular | rtExtended | rtInteger, 16, 0, CV_REG_TAG },
    { SzFpIp,   rtFPU | rtRegular | rtInteger,              16, 0, CV_REG_FPIP },
    { SzFpEip,  rtFPU | rtExtended | rtInteger,             32, 0, CV_REG_FPEIP },
    { SzFpCs,   rtFPU | rtRegular | rtExtended | rtInteger | rtNewLine, 16, 0, CV_REG_FPCS },
    { SzFpDs,   rtFPU | rtRegular | rtExtended | rtInteger, 16, 0, CV_REG_FPDS },
    { SzFpEdo,  rtFPU | rtExtended | rtInteger,             32, 0, CV_REG_FPEDO },
    { SzFpDo,   rtFPU | rtRegular | rtInteger,              16, 0, CV_REG_FPDO },

	{ "MM00",	rtFPU | rtExtended | rtFloat | rt3DNow | rtNewLine, 32, 0, CV_REG_MM00},
	{ "MM01",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM01},
	{ "MM10",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM10},
	{ "MM11",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM11},
	{ "MM20",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM20},
	{ "MM21",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM21},
	{ "MM30",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM30},
	{ "MM31",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM31},
	{ "MM40",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM40},
	{ "MM41",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM41},
	{ "MM50",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM50},
	{ "MM51",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM51},
	{ "MM60",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM60},
	{ "MM61",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM61},
	{ "MM70",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM70},
	{ "MM71",	rtFPU | rtExtended | rtFloat | rt3DNow, 32, 0, CV_REG_MM71},
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\em\win32msg.h ===
//
//  This file may be included many times, with different definitions
//  for DECL_MASK and DECL_MSG.
//


//
//  Windows Mesage mask values
//
// If you add or rearrange this list then verify that the order still works
// with Dolphin IDE which uses this order to match resource names to masks
//
DECL_MASK( MSG_TYPE_NONE,       msgMaskNone,    "None")
DECL_MASK( MSG_TYPE_WINDOW,     msgMaskWin,     "Window")
DECL_MASK( MSG_TYPE_INIT,       msgMaskInit,    "Init")
DECL_MASK( MSG_TYPE_INPUT,      msgMaskInput,   "Input")
DECL_MASK( MSG_TYPE_MOUSE,      msgMaskMouse,   "Mouse")
DECL_MASK( MSG_TYPE_SYSTEM,     msgMaskSys,     "System")
DECL_MASK( MSG_TYPE_CLIPBOARD,  msgMaskClip,    "Clipboard")
DECL_MASK( MSG_TYPE_NONCLIENT,  msgMaskNC,      "Non-Client")
DECL_MASK( MSG_TYPE_DDE,        msgMaskDDE,     "DDE")
DECL_MASK( MSG_TYPE_OTHER,      msgMaskOther,   "Other")
#if !defined(DOLPHIN)
DECL_MASK( MSG_TYPE_ALL,        msgMaskAll,     "All")
#endif

//
// Windows messages
//

DECL_MSG(WM_NULL               , "WM_NULL"                , MSG_TYPE_OTHER)
DECL_MSG(WM_CREATE             , "WM_CREATE"              , MSG_TYPE_WINDOW)
DECL_MSG(WM_DESTROY            , "WM_DESTROY"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_MOVE               , "WM_MOVE"                , MSG_TYPE_WINDOW)
DECL_MSG(WM_SIZE               , "WM_SIZE"                , MSG_TYPE_WINDOW)
DECL_MSG(WM_ACTIVATE           , "WM_ACTIVATE"            , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETFOCUS           , "WM_SETFOCUS"            , MSG_TYPE_WINDOW)
DECL_MSG(WM_KILLFOCUS          , "WM_KILLFOCUS"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_ENABLE             , "WM_ENABLE"              , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETREDRAW          , "WM_SETREDRAW"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETTEXT            , "WM_SETTEXT"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_GETTEXT            , "WM_GETTEXT"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_GETTEXTLENGTH      , "WM_GETTEXTLENGTH"       , MSG_TYPE_WINDOW)
DECL_MSG(WM_PAINT              , "WM_PAINT"               , MSG_TYPE_WINDOW)
DECL_MSG(WM_CLOSE              , "WM_CLOSE"               , MSG_TYPE_WINDOW)
DECL_MSG(WM_QUERYENDSESSION    , "WM_QUERYENDSESSION"     , MSG_TYPE_WINDOW)
DECL_MSG(WM_QUIT               , "WM_QUIT"                , MSG_TYPE_WINDOW)
DECL_MSG(WM_QUERYOPEN          , "WM_QUERYOPEN"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_ERASEBKGND         , "WM_ERASEBKGND"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_SYSCOLORCHANGE     , "WM_SYSCOLORCHANGE"      , MSG_TYPE_SYSTEM)
DECL_MSG(WM_ENDSESSION         , "WM_ENDSESSION"          , MSG_TYPE_SYSTEM)
DECL_MSG(WM_SHOWWINDOW         , "WM_SHOWWINDOW"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_WININICHANGE       , "WM_WININICHANGE"        , MSG_TYPE_SYSTEM)

DECL_MSG(WM_DEVMODECHANGE      , "WM_DEVMODECHANGE"       , MSG_TYPE_SYSTEM)
DECL_MSG(WM_ACTIVATEAPP        , "WM_ACTIVATEAPP"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_FONTCHANGE         , "WM_FONTCHANGE"          , MSG_TYPE_SYSTEM)
DECL_MSG(WM_TIMECHANGE         , "WM_TIMECHANGE"          , MSG_TYPE_SYSTEM)
DECL_MSG(WM_CANCELMODE         , "WM_CANCELMODE"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETCURSOR          , "WM_SETCURSOR"           , MSG_TYPE_MOUSE)
DECL_MSG(WM_MOUSEACTIVATE      , "WM_MOUSEACTIVATE"       , MSG_TYPE_MOUSE)
DECL_MSG(WM_CHILDACTIVATE      , "WM_CHILDACTIVATE"       , MSG_TYPE_WINDOW)
DECL_MSG(WM_QUEUESYNC          , "WM_QUEUESYNC"           , MSG_TYPE_SYSTEM)
DECL_MSG(WM_GETMINMAXINFO      , "WM_GETMINMAXINFO"       , MSG_TYPE_WINDOW)
DECL_MSG(WM_PAINTICON          , "WM_PAINTICON"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_ICONERASEBKGND     , "WM_ICONERASEBKGND"      , MSG_TYPE_WINDOW)
DECL_MSG(WM_NEXTDLGCTL         , "WM_NEXTDLGCTL"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_SPOOLERSTATUS      , "WM_SPOOLERSTATUS"       , MSG_TYPE_OTHER)
DECL_MSG(WM_DRAWITEM           , "WM_DRAWITEM"            , MSG_TYPE_WINDOW)
DECL_MSG(WM_MEASUREITEM        , "WM_MEASUREITEM"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_DELETEITEM         , "WM_DELETEITEM"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_VKEYTOITEM         , "WM_VKEYTOITEM"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_CHARTOITEM         , "WM_CHARTOITEM"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETFONT            , "WM_SETFONT"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_GETFONT            , "WM_GETFONT"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_SETHOTKEY          , "WM_SETHOTKEY"           , MSG_TYPE_INPUT )
DECL_MSG(WM_GETHOTKEY          , "WM_GETHOTKEY"           , MSG_TYPE_INPUT )
DECL_MSG(WM_QUERYDRAGICON      , "WM_QUERYDRAGICON"       , MSG_TYPE_WINDOW)
DECL_MSG(WM_COMPAREITEM        , "WM_COMPAREITEM"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_COMPACTING         , "WM_COMPACTING"          , MSG_TYPE_SYSTEM)
//DECL_MSG(WM_OTHERWINDOWCREATED , "WM_OTHERWINDOWCREATED"  , MSG_TYPE_SYSTEM)
//DECL_MSG(WM_OTHERWINDOWDESTROYED, "WM_OTHERWINDOWDESTROYED", MSG_TYPE_SYSTEM)
//DECL_MSG(WM_COMMNOTIFY         , "WM_COMMNOTIFY"          , MSG_TYPE_SYSTEM)
//DECL_MSG(WM_HOTKEYEVENT        , "WM_HOTKEYEVENT"         , MSG_TYPE_SYSTEM)
DECL_MSG(WM_WINDOWPOSCHANGING  , "WM_WINDOWPOSCHANGING"   , MSG_TYPE_WINDOW)
DECL_MSG(WM_WINDOWPOSCHANGED   , "WM_WINDOWPOSCHANGED"    , MSG_TYPE_WINDOW)
DECL_MSG(WM_POWER              , "WM_POWER"               , MSG_TYPE_SYSTEM)
DECL_MSG(WM_COPYDATA           , "WM_COPYDATA"            , MSG_TYPE_SYSTEM)
DECL_MSG(WM_CANCELJOURNAL      , "WM_CANCELJOURNAL"       , MSG_TYPE_SYSTEM)
DECL_MSG(WM_NCCREATE           , "WM_NCCREATE"            , MSG_TYPE_NONCLIENT)
DECL_MSG(WM_NCDESTROY          , "WM_NCDESTROY"           , MSG_TYPE_NONCLIENT)
DECL_MSG(WM_NCCALCSIZE         , "WM_NCCALCSIZE"          , MSG_TYPE_NONCLIENT)
DECL_MSG(WM_NCHITTEST          , "WM_NCHITTEST"           , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCPAINT            , "WM_NCPAINT"             , MSG_TYPE_NONCLIENT)
DECL_MSG(WM_NCACTIVATE         , "WM_NCACTIVATE"          , MSG_TYPE_NONCLIENT)
DECL_MSG(WM_GETDLGCODE         , "WM_GETDLGCODE"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_NCMOUSEMOVE        , "WM_NCMOUSEMOVE"         , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCLBUTTONDOWN      , "WM_NCLBUTTONDOWN"       , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCLBUTTONUP        , "WM_NCLBUTTONUP"         , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCLBUTTONDBLCLK    , "WM_NCLBUTTONDBLCLK"     , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCRBUTTONDOWN      , "WM_NCRBUTTONDOWN"       , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCRBUTTONUP        , "WM_NCRBUTTONUP"         , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCRBUTTONDBLCLK    , "WM_NCRBUTTONDBLCLK"     , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCMBUTTONDOWN      , "WM_NCMBUTTONDOWN"       , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCMBUTTONUP        , "WM_NCMBUTTONUP"         , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_NCMBUTTONDBLCLK    , "WM_NCMBUTTONDBLCLK"     , MSG_TYPE_NONCLIENT | MSG_TYPE_MOUSE)
DECL_MSG(WM_KEYDOWN            , "WM_KEYDOWN"             , MSG_TYPE_INPUT)
DECL_MSG(WM_KEYUP              , "WM_KEYUP"               , MSG_TYPE_INPUT)
DECL_MSG(WM_CHAR               , "WM_CHAR"                , MSG_TYPE_INPUT)
DECL_MSG(WM_DEADCHAR           , "WM_DEADCHAR"            , MSG_TYPE_INPUT)
DECL_MSG(WM_SYSKEYDOWN         , "WM_SYSKEYDOWN"          , MSG_TYPE_SYSTEM | MSG_TYPE_INPUT)
DECL_MSG(WM_SYSKEYUP           , "WM_SYSKEYUP"            , MSG_TYPE_SYSTEM | MSG_TYPE_INPUT)
DECL_MSG(WM_SYSCHAR            , "WM_SYSCHAR"             , MSG_TYPE_SYSTEM | MSG_TYPE_INPUT)
DECL_MSG(WM_SYSDEADCHAR        , "WM_SYSDEADCHAR"         , MSG_TYPE_SYSTEM | MSG_TYPE_INPUT)
DECL_MSG(WM_INITDIALOG         , "WM_INITDIALOG"          , MSG_TYPE_INIT)
DECL_MSG(WM_COMMAND            , "WM_COMMAND"             , MSG_TYPE_INPUT)
DECL_MSG(WM_SYSCOMMAND         , "WM_SYSCOMMAND"          , MSG_TYPE_SYSTEM)
DECL_MSG(WM_TIMER              , "WM_TIMER"               , MSG_TYPE_INPUT)
DECL_MSG(WM_HSCROLL            , "WM_HSCROLL"             , MSG_TYPE_INPUT)
DECL_MSG(WM_VSCROLL            , "WM_VSCROLL"             , MSG_TYPE_INPUT)
DECL_MSG(WM_INITMENU           , "WM_INITMENU"            , MSG_TYPE_INIT)
DECL_MSG(WM_INITMENUPOPUP      , "WM_INITMENUPOPUP"       , MSG_TYPE_INIT)
DECL_MSG(WM_MENUSELECT         , "WM_MENUSELECT"          , MSG_TYPE_INPUT)
DECL_MSG(WM_MENUCHAR           , "WM_MENUCHAR"            , MSG_TYPE_INPUT)
DECL_MSG(WM_ENTERIDLE          , "WM_ENTERIDLE"           , MSG_TYPE_SYSTEM)
DECL_MSG(WM_CTLCOLORMSGBOX     , "WM_CTLCOLORMSGBOX"      , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLOREDIT       , "WM_CTLCOLOREDIT"        , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLORLISTBOX    , "WM_CTLCOLORLISTBOX"     , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLORBTN        , "WM_CTLCOLORBTN"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLORDLG        , "WM_CTLCOLORDLG"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLORSCROLLBAR  , "WM_CTLCOLORSCROLLBAR"   , MSG_TYPE_WINDOW)
DECL_MSG(WM_CTLCOLORSTATIC     , "WM_CTLCOLORSTATIC"      , MSG_TYPE_WINDOW)
DECL_MSG(WM_MOUSEMOVE          , "WM_MOUSEMOVE"           , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_LBUTTONDOWN        , "WM_LBUTTONDOWN"         , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_LBUTTONUP          , "WM_LBUTTONUP"           , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_LBUTTONDBLCLK      , "WM_LBUTTONDBLCLK"       , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_RBUTTONDOWN        , "WM_RBUTTONDOWN"         , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_RBUTTONUP          , "WM_RBUTTONUP"           , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_RBUTTONDBLCLK      , "WM_RBUTTONDBLCLK"       , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_MBUTTONDOWN        , "WM_MBUTTONDOWN"         , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_MBUTTONUP          , "WM_MBUTTONUP"           , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_MBUTTONDBLCLK      , "WM_MBUTTONDBLCLK"       , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
DECL_MSG(WM_PARENTNOTIFY       , "WM_PARENTNOTIFY"        , MSG_TYPE_INPUT | MSG_TYPE_MOUSE)
//DECL_MSG(WM_ENTERMENULOOP      , "WM_ENTERMENULOOP"       , MSG_TYPE_SYSTEM)
//DECL_MSG(WM_EXITMENULOOP       , "WM_EXITMENULOOP"        , MSG_TYPE_SYSTEM)
DECL_MSG(WM_MDICREATE          , "WM_MDICREATE"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIDESTROY         , "WM_MDIDESTROY"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIACTIVATE        , "WM_MDIACTIVATE"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIRESTORE         , "WM_MDIRESTORE"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDINEXT            , "WM_MDINEXT"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIMAXIMIZE        , "WM_MDIMAXIMIZE"         , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDITILE            , "WM_MDITILE"             , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDICASCADE         , "WM_MDICASCADE"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIICONARRANGE     , "WM_MDIICONARRANGE"      , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIGETACTIVE       , "WM_MDIGETACTIVE"        , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDISETMENU         , "WM_MDISETMENU"          , MSG_TYPE_WINDOW)
DECL_MSG(WM_DROPFILES          , "WM_DROPFILES"           , MSG_TYPE_WINDOW)
DECL_MSG(WM_MDIREFRESHMENU     , "WM_MDIREFRESHMENU"      , MSG_TYPE_WINDOW)
DECL_MSG(0x280                 , "WM_IME_REPORT" 		  , MSG_TYPE_INPUT)
DECL_MSG(0x290                 , "WM_IMEKEYDOWN"          , MSG_TYPE_INPUT)
DECL_MSG(0x291                 , "WM_IMEKEYUP"            , MSG_TYPE_INPUT)
DECL_MSG(WM_CUT                , "WM_CUT"                 , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_COPY               , "WM_COPY"                , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_PASTE              , "WM_PASTE"               , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_CLEAR              , "WM_CLEAR"               , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_UNDO               , "WM_UNDO"                , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_RENDERFORMAT       , "WM_RENDERFORMAT"        , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_RENDERALLFORMATS   , "WM_RENDERALLFORMATS"    , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_DESTROYCLIPBOARD   , "WM_DESTROYCLIPBOARD"    , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_DRAWCLIPBOARD      , "WM_DRAWCLIPBOARD"       , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_PAINTCLIPBOARD     , "WM_PAINTCLIPBOARD"      , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_VSCROLLCLIPBOARD   , "WM_VSCROLLCLIPBOARD"    , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_SIZECLIPBOARD      , "WM_SIZECLIPBOARD"       , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_ASKCBFORMATNAME    , "WM_ASKCBFORMATNAME"     , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_CHANGECBCHAIN      , "WM_CHANGECBCHAIN"       , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_HSCROLLCLIPBOARD   , "WM_HSCROLLCLIPBOARD"    , MSG_TYPE_CLIPBOARD)
DECL_MSG(WM_QUERYNEWPALETTE    , "WM_QUERYNEWPALETTE"     , MSG_TYPE_WINDOW)
DECL_MSG(WM_PALETTEISCHANGING  , "WM_PALETTEISCHANGING"   , MSG_TYPE_WINDOW)
DECL_MSG(WM_PALETTECHANGED     , "WM_PALETTECHANGED"      , MSG_TYPE_WINDOW)
DECL_MSG(WM_HOTKEY             , "WM_HOTKEY"              , MSG_TYPE_WINDOW)
DECL_MSG(WM_DDE_INITIATE       , "WM_DDE_INITIATE"        , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_TERMINATE      , "WM_DDE_TERMINATE"       , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_ADVISE         , "WM_DDE_ADVISE"          , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_UNADVISE       , "WM_DDE_UNADVISE"        , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_ACK            , "WM_DDE_ACK"             , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_DATA           , "WM_DDE_DATA"            , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_REQUEST        , "WM_DDE_REQUEST"         , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_POKE           , "WM_DDE_POKE"            , MSG_TYPE_DDE)
DECL_MSG(WM_DDE_EXECUTE        , "WM_DDE_EXECUTE"         , MSG_TYPE_DDE)

=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\include\win32dm.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    win32dm.h

Abstract:

    This file contains structures used by the Win32 em/dm which
    are exposed to the debugger shell.

    This file should go away.  It is the collection point for
    non-portable stuff in windbg's shell.

Author:

    Kent Forschmiedt (kentf) 20-Oct-1993

Environment:

    Win32, User Mode

--*/



#if 0
//
// BUGBUG kentf this is probably going away
//
// RIP reporting structure
//
typedef struct _NT_RIP {
    BPR         bpr;
    ULONG       ulErrorCode;
    ULONG       ulErrorLevel;
} NT_RIP; // RIP Return
typedef NT_RIP FAR *LPNT_RIP;

#endif


//
// Packet for DebugActiveProcess
//
// BUGBUG kentf this needs to be generic.  it can't be private to Win32.
//
typedef struct _DAP {
    DWORD dwProcessId;
    HANDLE hEventGo;
} DAP;
typedef DAP FAR * LPDAP;


//
// System services provided by win32 em/dm
//

typedef enum _WIN32_SSVC {
    ssvcGetStackFrame           = FIRST_PRIVATE_SSVC,
    ssvcGetThreadContext,
    ssvcSetThreadContext,
    ssvcGetProcessHandle,
    ssvcGetThreadHandle,
    ssvcGetPrompt,
    ssvcCustomCommand,
    ssvcGeneric
};


//
// the kernel debugger reserves the first 255 subtypes
//
// the subtypes that are defined here are applicable to all
// dms that exist today.
//
#define IG_TRANSLATE_ADDRESS     256
#define IG_WATCH_TIME            257
#define IG_WATCH_TIME_STOP       258
#define IG_WATCH_TIME_RECALL     259
#define IG_WATCH_TIME_PROCS      260
#define IG_DM_PARAMS             261
#define IG_THREAD_INFO           262
#define IG_TASK_LIST             263
#define IG_RELOAD                264
#define IG_PAGEIN                265
#define IG_CHANGE_PROC           266

typedef struct _IOCTLGENERIC {
    DWORD   ioctlSubType;
    DWORD   length;
    char    data[0];
} IOCTLGENERIC, *PIOCTLGENERIC;

typedef struct _PROMPTMSG {
    DWORD   len;
    BYTE    szPrompt[];
} PROMPTMSG; // GetPrompt return
typedef PROMPTMSG * LPPROMPTMSG;

typedef struct _TASK_LIST {
    DWORD   dwProcessId;
    char    ProcessName[16];
} TASK_LIST, *PTASK_LIST;


typedef struct _DMSYM {
    ADDR    AddrSym;
    DWORD   Ra;
    char fname[];
} DMSYM;
typedef DMSYM *PDMSYM, *LPDMSYM;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\od\include\odassert.h ===
#ifndef _ODASSERT_
#define _ODASSERT_

#if DBG

#define assert(exp) { \
    if (!(exp)) { \
        LBAssert( #exp, __FILE__, __LINE__); \
    } \
}

#else

#define assert(exp)

#endif /* DBG */


#endif /* _ODASSERT_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\include\emdm.h ===
/**** EMDM.HMD - Common structures for Win32/NT EM and DM               ****
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1990, Microsoft Corp                                     *
 *                                                                         *
 *  Created: November 17, 1990 by David W. Gray                            *
 *                                                                         *
 *  Purpose:                                                               *
 *                                                                         *
 *      This file defines the types, enums, and constants that are common  *
 *      for all execution models, both debugger and debuggee end.          *
 *                                                                         *
 ***************************************************************************/

#ifndef _EMDM
#define _EMDM

//
// This is included to define a NONVOLATILE_CONTEXT_POINTERS structure
// of the appropriate size.  The goal is to keep any machine-specific
// reference out of emdp.c here, but we need to know how much data to
// transfer to the thread context on the different architectures.
//

#include "ctxptrs.h"

#define MAXCACHE 16
#define CACHESIZE 0x100

#ifndef try
#define try __try
#endif
#ifndef except
#define except __except
#endif
#ifndef finally
#define finally __finally
#endif

//#define OMNI		1			// support omni

typedef DWORD MTE;

#ifdef TARGET32
#define MAXBIGSEGS      3
#endif


typedef DWORD PID;
typedef DWORD TID;


typedef enum {
    dmfRemoteDied = -1,             /* debugger quit */
    dmfCommError  = -2,             /* transport layer error */

    dmfNull = 0,

    dmfInit,
    dmfUnInit,
    dmfRemoteQuit,
    dmfSelect,
    dmfConnect,

    dmfCreatePid,
    dmfDestroyPid,

    dmfSetPath,
    dmfSpawnOrphan,
    dmfProgLoad,
    dmfProgFree,
    dmfDebugActive,
    dmfTerm,

    dmfGo,
    dmfStop,
    dmfFreeze,
    dmfResume,

    dmfSingleStep,
    dmfReturnStep,
    dmfNonLocalGoto,
    dmfRangeStep,
    dmfGoToReturn,

    dmfBreakpoint,
    dmfGetExceptionState,
    dmfSetExceptionState,

    dmfReadMem,
    dmfReadReg,
    dmfReadFrameReg,
    dmfWriteMem,
    dmfWriteReg,
    dmfWriteFrameReg,
    dmfGetFP,
    dmfSetFP,
    dmfThreadStatus,
    dmfProcessStatus,
    dmfQueryTlsBase,
    dmfQuerySelector,
    dmfVirtualQuery,
    dmfReadRegEx,
    dmfWriteRegEx,
    dmfGetSections,

    dmfInit32SegValues,
    dmfSelLim,

    dmfSetMulti,
    dmfClearMulti,
    dmfDebugger,
    dmfSync,
    dmfSystemService,
    dmfGetPrompt,
    dmfSendChar,
    dmfGetDmInfo,

    dmfSetupExecute,
    dmfStartExecute,
    dmfCleanUpExecute,

    dmfRemoteUtility,       // for the mfile utility
    dmfGetTimeStamp,

    dmfGetSpecialReg,
    dmfSetSpecialReg,

	dmfCreateUserCrashDump,

    dmfLast

} _DMF;

typedef LONG DMF;


typedef struct _DM_MSG {
    union {
        XOSD  xosdRet;
        DWORDLONG Alignment;
    };
    BYTE  rgb[1];
} DM_MSG;
typedef DM_MSG FAR *LPDM_MSG;

#define iflgMax 12

typedef struct _RTRNSTP {
   EXOP exop;
   ADDR addrRA;         // Address to return to
   ADDR addrStack;       // Address of current SP.
} RTRNSTP; // ReTuRN STeP packet
typedef RTRNSTP FAR *LPRTRNSTP;

#pragma pack(4)

typedef struct _RST {
	EXOP	exop;
#ifdef TARGET32
    UOFF32     offStart;
    UOFF32     offEnd;
    UOFF32     offPC;
#else
    ADDR addrStart;
    ADDR addrEnd;
    ADDR addrCSIP;
#endif
#if defined(TARGET_MIPS) || defined(TARGET_PPC)
    BOOL fPassException;
#endif
} RST; // Range STep Packet

typedef RST FAR *LPRST;

typedef struct _TCR {
    TID             tid;
    UOFFSET uoffTEB;
} TCR;  // Thread Create Return
typedef TCR FAR *LPTCR;

typedef struct _SETPTH {
    BOOL Set;
    TCHAR Path[1];
} SETPTH;

#pragma pack()

//
// DM Misc info structure.
//
// Some of these correspond to the debug metrics exposed by OSDebug.
// These cover the differences between user and kernel mode, Win32,
// Win32s and Win32c, maybe Cairo, whatever other DMs might be handled
// by the Win32 EM.
//
typedef struct _PROCESSOR {
    MPT Type;
    DWORD Level;
    END Endian;
    DWORD Flags;
} PROCESSOR, FAR * LPPROCESSOR;

// Flags values, low word is general, high word is processor-specific
#define	PROCESSOR_FLAGS_EXTENDED    0x00000001
#define	PROCESSOR_FLAGS_I386_MMX    0x00010000
#define	PROCESSOR_FLAGS_I386_MMX2   0x00020000
#define	PROCESSOR_FLAGS_I386_MMX3   0x00040000
#define	PROCESSOR_FLAGS_I386_3DNOW  0x00080000

typedef struct _DMINFO {
    ASYNC mAsync;         // Mask of async capabilities
    DWORD fHasThreads:1;  //
    DWORD fReturnStep:1;  // step out of function?
    DWORD fRemote:1;      // target is not debugger host
    DWORD fAlwaysFlat:1;  // never use 16:16 for this target
    DWORD fHasReload:1;   // supports symbol reload
    //DWORD fIller:27;
    DWORD cbSpecialRegs;  // size of private regs struct for dmfGetRegsEx
    BPTS Breakpoints;     // OSDebug breakpoints supported
    PROCESSOR Processor;
    WORD MajorVersion;    // OS Version of target
    WORD MinorVersion;    //
} DMINFO;
typedef DMINFO FAR * LPDMINFO;

typedef struct _GOP {
    USHORT fBpt;
    USHORT fAllThreads;
    ADDR addr;
} GOP; // Go until this address

typedef GOP *PGOP;
typedef GOP FAR *LPGOP;

typedef struct _SBP {
    HPID    id;
    BOOL    fAddr;
    ADDR    addr;
    DWORD   Size;
} SBP;

typedef SBP FAR* LPSBP;

typedef struct _EHP {
    DWORD iException;
    BOOL  fHandle;
} EHP; // Exception Handled Packet
typedef EHP FAR *LPEHP;

typedef struct _RSR {
    WORD    segCS;
    UOFFSET offIP;
    WORD    segSS;
    UOFFSET offBP;
    WORD    segCSNext;
    UOFFSET offIPNext;
} RSR; // Range Step Return
typedef RSR FAR *LPRSR;

typedef struct _OBJD {
    DWORD       offset;
    DWORD       cb;
    WORD        wSel;
    WORD        wPad;
#ifdef OMNI
	DWORD		rvaOffset;
	DWORD*		pOmniJITMap;
#endif
} OBJD, FAR * LPOBJD;


#if defined(TARGMACPPC)
typedef struct _MODULELOAD {
    UOFFSET            uoffImageBase;
    DWORD            cbImageLength;
    DWORD            dwTimeStamp;
    LONG            cobj;
    OBJD            rgobjd[];
} MODULELOAD;

#elif defined(TARGJAVA)

typedef struct _MODULELOAD {
    IUnknown        *pRemoteClassField;
    DWORD            dwTimeStamp;
} MODULELOAD;

#else

typedef struct _MODULELOAD {
    WORD            mte;
    SEGMENT         StartingSegment;
    SEGMENT         CSSel;
    SEGMENT         DSSel;
    DWORD           fRealMode:1;
    DWORD           fFlatMode:1;
    DWORD           fOffset32:1;
#ifdef OMNI
	DWORD			fOmniMap:1;
#endif
    LPVOID          lpBaseOfDll;
    DWORD           dwSizeOfDll;
    LONG            cobj;
    UOFFSET         uoffDataBase;
    UOFFSET         uoffiTls;       // linear address in process of this module's tlsindex
    DWORD           isecTLS;        // index of .tls section
    DWORD           iTls;           // tls index, retrieved at initial breakpoint time
    OBJD            rgobjd[];
} MODULELOAD;
#endif

typedef MODULELOAD FAR *LPMODULELOAD;

#ifndef TARGJAVA
typedef struct _RWP {
    DWORD cb;
    ADDR addr;
    BYTE rgb[1];
} RWP; // Read Write Packet
#else
typedef struct _RWP {
    WORD cb;
    WORD pad;
    ADDR addr;
    BYTE rgb[];
} RWP; // Read Write Packet
#endif // TARGJAVA

typedef RWP *PRWP;
typedef RWP FAR *LPRWP;

typedef struct _NPP {
    PID     pid;
    BOOL    fReallyNew;
} NPP;  // New Process Packet, used with dbcNewProc.
        // See od.h for description of fReallyNew.
typedef NPP FAR * LPNPP;

typedef struct _WPP {
    ADDR addr;
    WORD cb;
} WPP; // Watch Point Packet
typedef WPP FAR *LPWPP;

#if defined( TARGMAC68K )
typedef struct _SLI {
    DWORD dwBaseAddr;
    DWORD fExecute;
    short sRezID;
    unsigned char szName[];
} SLI;  // Segment Load Info
#else
typedef struct _SLI {
    WORD        wSelector;
    WORD        wSegNo;
    WORD        mte;
} SLI, FAR * LPSLI;
#endif

typedef SLI FAR *LPSLI;

// Exception command packet
typedef struct _EXCMD {
   EXCEPTION_CONTROL exc;
   EXCEPTION_DESCRIPTION exd;
} EXCMD;
typedef EXCMD FAR * LPEXCMD;

typedef struct _EXHDLR {
    DWORD count;
    ADDR addr[];
} EXHDLR;
typedef EXHDLR FAR * LPEXHDLR;

// The DBCEs always come back in an RTP structure, which has additional
// info.  The comments on the DBCEs below refer to the other fields of
// the RTP structure.
typedef enum {
    dbceAssignPID = dbcMax,     // Tell the EM what PID is associated with
                                // a given HPID.  At offset 0 of rtp.rgbVar[]
                                // is the PID.
    dbceLoadBigSegTbl,          // ??
    dbceCheckBpt,               // Find out if EM wants us to single-step
                                // over a specified breakpoint.  Upon return,
                                // rgbVar[0] is fStop to stop at this
                                // breakpoint; if fStop is FALSE, then
                                // rgbVar[1] is the byte with which to
                                // overwrite the INT 3.
    dbceInstructionLen,         // Ask the em how long the instruction is.
                                // rgbVar contains the cs:ip
    dbceSegLoad,                // WOW just loaded a segment
    dbceSegMove,                // WOW just moved a segment
    dbceModFree16,              // Unload of a 16-bit DLL
    dbceModFree32,              // Unload of a 32-bit DLL
    dbceGetOffsetFromSymbol,    // like it sez
    dbceEnableCache,
    dbceGetSymbolFromOffset,
    dbceGetMessageMask,
    dbceExceptionDuringStep,    // Ask count prefix array of exception handlers
	dbceGetFrameWithSrc,		// Get closest frame with src
    dbceMax
} _DBCE;
typedef LONG DBCE;

//  it is important that the rgbVar fields be aligned on a DWORDLONG boundary
#ifndef TARGJAVA
typedef struct _DBB {
    DMF  dmf;
    HPID hpid;
    HTID htid;
    union {
        DWORDLONG Alignment;
        BYTE rgbVar[1];
    };
} DBB;
#else
typedef struct _DBB {
    DMF  dmf;
    WORD dummy;
    HPID hpid;
    HTID htid;
    BYTE rgbVar[];
} DBB;
#endif

typedef DBB FAR *LPDBB;

#ifndef TARGJAVA
typedef struct _RTP {
    DBC  dbc;                   // a DBC or a DBCE
    HPID hpid;
    HTID htid;
    DWORD cb;                    // the length of rgbVar
    union {
        DWORDLONG Alignment;
        BYTE rgbVar[1];         // additional information - see the
                                // definitions of the DBCE and DBC codes
    };
} RTP;
#else
typedef struct _RTP {
    DBC  dbc;        // a DBC or a DBCE
    WORD pad0;       // align to 4 bytes
    HPID hpid;
    HTID htid;
    WORD cb;         // the length of rgbVar
    BYTE rgbVar[];   // additional information - see the
                     // definitions of the DBCE and DBC codes
} RTP;
#endif // TARGJAVA

typedef RTP *PRTP;
typedef RTP FAR *LPRTP;

#define lpregDbb(dbb) ( (LPREG) &dbb )
#define lpfprDbb(dbb) ( (LPFPR) &dbb )
#define lszDbb(dbb)   ( (LSZ)   &dbb )

#define addrDbb(dbb)  (*( (LPADDR) &dbb ))
#define stpDbb(dbb)   (*( (LPSTP)  &dbb ))
#define rstDbb(dbb)   (*( (LPRST)  &dbb ))
#define gopDbb(dbb)   (*( (LPGOP)  &dbb ))
#define tstDbb(dbb)   (*( (LPTST)  &dbb ))
#define pstDbb(dbb)   (*( (LPF)    &dbb ))
#define rwpDbb(dbb)   (*( (LPRWP)  &dbb ))
#define fDbb(dbb)     (*( (LPF)    &dbb ))



/****************************************************************************
 *                                                                          *
 * Packets returned from the debuggee execution model to the debugger       *
 *  execution model.                                                        *
 *                                                                          *
 ****************************************************************************/


typedef struct _FRAME_INFO {
    CONTEXT frameRegs;
    KNONVOLATILE_CONTEXT_POINTERS frameRegPtrs;
} FRAME_INFO, * PFRAME_INFO;

typedef struct _NLG {
    HEMI    hemi;
    BOOL    fEnable;
    ADDR    addrNLGDispatch;
    ADDR    addrNLGDestination;
    ADDR    addrNLGReturn;
    ADDR    addrNLGReturn2;
} NLG;
typedef NLG * PNLG;
typedef NLG FAR * LPNLG;

#endif  // _EMDM
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\cv.h ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    cv.h

Abstract:

    This file contains all of the type definitions for accessing
    CODEVIEW data.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/
#include <cvtypes.h>
#include <cvinfo.h>
#include <cvexefmt.h>

// Global Segment Info table
typedef struct _sgf {
    unsigned short      fRead   :1;
    unsigned short      fWrite  :1;
    unsigned short      fExecute:1;
    unsigned short      f32Bit  :1;
    unsigned short      res1    :4;
    unsigned short      fSel    :1;
    unsigned short      fAbs    :1;
    unsigned short      res2    :2;
    unsigned short      fGroup  :1;
    unsigned short      res3    :3;
} SGF;

typedef struct _sgi {
    SGF                 sgf;        // Segment flags
    unsigned short      iovl;       // Overlay number
    unsigned short      igr;        // Group index
    unsigned short      isgPhy;     // Physical segment index
    unsigned short      isegName;   // Index to segment name
    unsigned short      iclassName; // Index to segment class name
    unsigned long       doffseg;    // Starting offset inside physical segment
    unsigned long       cbSeg;      // Logical segment size
} SGI;

typedef struct _sgm {
    unsigned short      cSeg;       // number of segment descriptors
    unsigned short      cSegLog;    // number of logical segment descriptors
} SGM;

#define FileAlign(x)  ( ((x) + p->optrs.optHdr->FileAlignment - 1) &  \
                            ~(p->optrs.optHdr->FileAlignment - 1) )
#define SectionAlign(x) (((x) + p->optrs.optHdr->SectionAlignment - 1) &  \
                            ~(p->optrs.optHdr->SectionAlignment - 1) )

#define NextSym32(m)  ((DATASYM32 *) \
  (((DWORD)(m) + sizeof(DATASYM32) + \
    ((DATASYM32*)(m))->name[0] + 3) & ~3))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\od\include\odp.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    odp.h

Abstract:

    This is part of OSDebug version 4.

    These are types and data which are private to OSDebug and the
    components below it: TL, EM and DM.

Author:

    Kent D. Forschmiedt (kentf)

Environment:

    Win32, User Mode

--*/

#ifndef _ODP_
#define _ODP_

#ifdef  __cplusplus
#pragma warning ( disable: 4200 )
extern "C" {
#endif

#define DECL_EMF(emfName)       emf##emfName,

typedef enum _EMF {
#include "emf.h"
} EMF;

#undef DECL_EMF

typedef struct _DBCPK {
   DBC     dbc;
   HPID    hpid;
   HTID    htid;
   LPARAM  wValue;
   LPARAM  lValue;
} DBCPK; // a dbc package
typedef DBCPK FAR *LPDBCPK;


typedef enum {
    dbcoCreateThread = dbcMax,
    dbcoNewProc,

    dbcoMax
} DBCO;  // Debug CallBacks Osdebug specific

// the set of transport layer commands process by TLFunc and DMTLFunc

typedef enum {
    tlfRegisterDBF,     // register the debugger helper functions
    tlfInit,            // initialize/create a (specific) transport layer
    tlfDestroy,         // vaporize any tl structs created
    tlfConnect,         // connect to the companion transport layer
    tlfDisconnect,      // disconnected from the companion transport layer
    tlfSendVersion,     // Send the version packet to the remote side
    tlfGetVersion,      // Request the version packet from the remote side
    tlfSetBuffer,       // set the data buffer to be used for incoming packets
    tlfDebugPacket,     // send the debug packet to the debug monitor
    tlfRequest,         // request data from the companion transport layer
    tlfReply,           // reply to a data request message
    tlfGetInfo,         // return an id string and other data
    tlfSetup,           // set up the transport layer
    tlfGetProc,         // return the true TLFUNC proc for the htl
    tlfLoadDM,          // load the DM module
    tlfSetErrorCB,      // Set the address of the error callback function
    tlfListen,          // Remote: wait for somebody to make a connection to us
    tlfRemoteQuit,      // signal loss of connection
    tlfPassiveConnect,      // the remote monitor connects to transport with this
    tlfGetLastError,    // get the string associated with the last error
    tlfMax
} _TLF;
typedef DWORD TLF;

//
// callbacks the TL uses to communicate with shell -- stub or client.
//
typedef enum {
    tlcbDisconnect,     // Transport layer was disconnected normally
    tlcbMax
} _TLCB;
typedef DWORD TLCB;


typedef XOSD (*TLFUNC_ODP) ( TLF, HPID, LPARAM, LPARAM );
typedef XOSD (*EMFUNC_ODP) ( EMF, HPID, HTID, LPARAM, LPARAM );
typedef XOSD (*TLFUNCTYPE) ( TLF, HPID, LPARAM, LPARAM );
typedef XOSD (*DMTLFUNCTYPE) ( TLF, HPID, LPARAM, LPARAM );
typedef XOSD (*TLCALLBACKTYPE) (HPID, LPARAM, LPARAM );
//typedef VOID (*LPDMINIT) ( DMTLFUNCTYPE, LPVOID ); // I think this is wrong
typedef XOSD (*LPDMINIT) ( DMTLFUNCTYPE, LPVOID );
typedef VOID (*LPDMFUNC) ( DWORD, LPBYTE );
typedef DWORD (*LPDMDLLINIT) ( LPDBF );
typedef XOSD (*TLSERVERCALLBACK) (TLCB, HPID, HTID, LPARAM, LPARAM );



DECLARE_HANDLE32(HEMP);

typedef struct _THREADINFO {
    HPID hpid;
    HLLI llemp;
} THREADINFO;
typedef THREADINFO *LPTHREADINFO;   // Thread information

typedef struct _PROCESSINFO {
    HTL     htl;
    HEMP    hempNative;
    HLLI    llemp;
    DWORD   fNative;
    DWORD   lastmodel;
    LPFNSVC lpfnsvcCC;
    HLLI    lltid;
} PROCESSINFO;
typedef PROCESSINFO *LPPROCESSINFO;   // Process information

typedef struct _EMS {
    EMFUNC_ODP  emfunc;
    EMTYPE      emtype;
    HLLI        llhpid;
    DWORD       model;
} EMS; // Execution Model Structure - per EM
typedef EMS *LPEMS;

typedef struct _EMP {
    HEM         hem;
    EMFUNC_ODP  emfunc;
    EMTYPE      emtype;
    DWORD       model;
} EMP; // Execution Model Structure - per process
typedef EMP *LPEMP;

typedef struct _TLS {
    TLFUNC_ODP  tlfunc;
} TLS; // Transport Layer Structure
typedef TLS *LPTL;

typedef struct _OSDFILE {
    HPID  hpid;
    DWORD dwPrivateData;    // EM's representation of the file
} OSDFILE;
typedef OSDFILE * LPOSDFILE;

//
// Compare Address Struct
//
typedef struct _CAS {
    LPADDR lpaddr1;
    LPADDR lpaddr2;
    LPDWORD lpResult;
} CAS;
typedef CAS * LPCAS;

//
// Range Step Struct
//
typedef struct _RSS {
    LPADDR lpaddrMin;
    LPADDR lpaddrMax;
    LPEXOP lpExop;
} RSS;
typedef RSS * LPRSS;

//
// read memory struct
//
typedef struct _RWMS {
    LPADDR lpaddr;
    LPVOID lpbBuffer;
    DWORD cbBuffer;
    LPDWORD lpcb;
} RWMS;
typedef RWMS * LPRWMS;

//
// Get Object Length struct
//
typedef struct _GOL {
    LPADDR lpaddr;
    LPUOFF32 lplBase;
    LPUOFF32 lplLen;
} GOL;
typedef GOL * LPGOL;

//
// Get Function Information Structure
//
typedef struct _GFI {
    LPADDR lpaddr;
    LPFUNCTION_INFORMATION lpFunctionInformation;
} GFI;
typedef GFI * LPGFI;

//
// Get Previous Instruction Structure
//
typedef struct _GPIS {
    LPADDR lpaddr;
    LPUOFF32 lpuoffset;
} GPIS;
typedef GPIS * LPGPIS;

//
// Set Debug Mode Structure
//
typedef struct _SDMS {
    DBM dbmService;
    LPVOID lpvData;
    DWORD cbData;
} SDMS;
typedef SDMS * LPSDMS;

typedef struct _SSS {
    SSVC ssvc;
    DWORD cbSend;
    DWORD cbReturned;
    BYTE rgbData[];
} SSS;
typedef SSS * LPSSS;

//
// The following structure is used by the emfSetupExecute message
//
typedef struct _EXECUTE_STRUCT {
    ADDR        addr;           /* Starting address for function        */
    HIND        hindDm;         /* This is the DMs handle               */
    HDEP        lphdep;         /* Handle of save area                  */
    DWORD       fIgnoreEvents:1; /* Ignore events coming back?          */
    DWORD       fFar:1;         /* Is the function a _far routine       */
} EXECUTE_STRUCT;
typedef EXECUTE_STRUCT * LPEXECUTE_STRUCT;

//
// Load DM packet, used by TL
//
typedef struct _LOADDMSTRUCT {
    LPTSTR lpDmName;
    LPTSTR lpDmParams;
} LOADDMSTRUCT, * LPLOADDMSTRUCT;


void ODPDKill  ( LPVOID );

void EMKill    ( LPVOID );
int  EMHpidCmp ( LPVOID, LPVOID, LONG );
void EMPKill   ( LPVOID );

void TLKill    ( LPVOID );

void NullKill  ( LPVOID );
int  NullComp  ( LPVOID, LPVOID, LONG );

typedef struct _EMCB {
    XOSD (*lpfnCallBackDB) ( DBC, HPID, HTID, DWORD, DWORD, VOID * );
    XOSD (*lpfnCallBackTL) ( TLF, HPID, DWORD, VOID * );
    XOSD (*lpfnCallBackNT) ( EMF, HPID, HTID, DWORD, VOID * );
    XOSD (*lpfnCallBackEM) ( EMF, HPID, HTID, DWORD, DWORD, VOID * );
} EMCB; // Execution Model CallBacks
typedef EMCB *LPEMCB;

typedef struct _REMI {
    HEMI    hemi;
    LPTSTR  lsz;
} REMI;     // Register EMI structure
typedef REMI * LPREMI;

// Packet used by OSDSpawnOrphan
typedef struct _SOS {
    DWORD   dwChildFlags;
    LPTSTR  lszRemoteExe;    // name of remote exe
    LPTSTR  lszCmdLine;      // command line
    LPTSTR  lszRemoteDir;    // initial dir of debuggee
    LPSPAWNORPHAN    lpso;   // info to return about the spawn.
} SOS, *LPSOS;        // Spawn Orphan Structure

// packet used by OSDProgramLoad
// Doesn't use SOS.lpso
typedef SOS PRL;
typedef PRL *   LPPRL;


//
//    Structures used by GetTimeStamp ()
//

typedef struct _TCS {
    LPTSTR    ImageName;
    ULONG    TimeStamp;
    ULONG    CheckSum;
} TCS;

typedef struct TCSR {
    ULONG    TimeStamp;
    ULONG    CheckSum;
} TCSR;

typedef TCS* LPTCS;
typedef TCSR* LPTCSR;

#define MHAlloc(x)   ((*lpdbf->lpfnMHAlloc)(x))
#define MHRealloc(a,b) ((*lpdbf->lpfnMHRealloc)(a,b))
#define MHFree(y)    ((*lpdbf->lpfnMHFree)(y))

#define LLInit    (*lpdbf->lpfnLLInit)
#define LLCreate  (*lpdbf->lpfnLLCreate)
#define LLAdd     (*lpdbf->lpfnLLAdd)
#define LLInsert  (*lpdbf->lpfnLLInsert)
#define LLDelete  (*lpdbf->lpfnLLDelete)
#define LLNext    (*lpdbf->lpfnLLNext)
#define LLDestroy (*lpdbf->lpfnLLDestroy)
#define LLFind    (*lpdbf->lpfnLLFind)
#define LLSize    (*lpdbf->lpfnLLSize)
#define LLLock    (*lpdbf->lpfnLLLock)
#define LLUnlock  (*lpdbf->lpfnLLUnlock)
#define LLLast    (*lpdbf->lpfnLLLast)
#define LLAddHead (*lpdbf->lpfnLLAddHead)
#define LLRemove  (*lpdbf->lpfnLLRemove)

#define LBAssert  (*lpdbf->lpfnLBAssert)
#define DHGetNumber (*lpdbf->lpfnDHGetNumber)

#define SHLocateSymbolFile (*lpdbf->lpfnSHLocateSymbolFile)
#define SHGetSymbol        (*lpdbf->lpfnSHGetSymbol)
#define SHLpGSNGetTable    (*lpdbf->lpfnSHLpGSNGetTable)
#define SHFindSymbol       (*lpdbf->lpfnSHFindSymbol)

#define SHGetDebugData     (*lpdbf->lpfnSHGetDebugData)
#define SHGetPublicAddr    (*lpdbf->lpfnSHGetPublicAddr)
#define SHAddrToPublicName (*lpdbf->lpfnSHAddrToPublicName)
#define GetTargetProcessor (*lpdbf->lpfnGetTargetProcessor)
#ifdef NT_BUILD_ONLY
#define SHWantSymbols(H)      (*lpdbf->lpfnSHWantSymbols)(H)
#else
#define SHWantSymbols(H)      (0)
#endif

#ifdef  __cplusplus
}   // extern "C"
#endif

#endif // _ODP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\cvcommon.h ===
/*
 *   PROTOTYPES, TYPEDEFS and other items for cvcommon.c
 */

DWORD   CreateSignature( PPOINTERS p );
DWORD   CreateDirectories( PPOINTERS p );
DWORD   CreateModuleDirectoryEntries( PPOINTERS p );
DWORD   CreateSegMapDirectoryEntries( PPOINTERS p );
DWORD   CreateSrcModulesDirectoryEntries( PPOINTERS p );
DWORD   CreatePublicDirectoryEntries( PPOINTERS p );
DWORD   CreateSymbolHashTable( PPOINTERS p );
DWORD   CreateAddressSortTable( PPOINTERS p );
DWORD   DWordXorLrl(char * szSym);
OMFModule *     NextMod(OMFModule * pMod);
VOID    UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\od\include\emf.h ===
//--------------------------------------------------------------------
// EMF.H
//
// This contains a list of all the EM functions.
// 
// There are multiple users of this file.  To use it, you must
// define a DECL_EMF macro to extract the pieces of information that
// you are interested in from this file.  For example, if you want
// to define the emf enumeration, you could write the following:
//
//		#define DECL_EMF(name)	emf ## name,
//
//		typedef enum {
//			#include "emf.h"
//		} EMF;
//
//		#undef DECL_EMF
//--------------------------------------------------------------------

DECL_EMF(DebugPacket)

DECL_EMF(RegisterDBF)
DECL_EMF(Init)
DECL_EMF(GetModel)
DECL_EMF(UnInit)
DECL_EMF(Detach)
DECL_EMF(Attach)
DECL_EMF(GetInfo)
DECL_EMF(Setup)
DECL_EMF(Connect)
DECL_EMF(Disconnect)

DECL_EMF(CreateHpid)
DECL_EMF(DestroyHpid)
DECL_EMF(DestroyHtid)

DECL_EMF(SetMulti)
DECL_EMF(Debugger)

DECL_EMF(SpawnOrphan)
DECL_EMF(ProgramLoad)
DECL_EMF(DebugActive)
DECL_EMF(SetPath)
DECL_EMF(ProgramFree)

DECL_EMF(ThreadStatus)
DECL_EMF(ProcessStatus)
DECL_EMF(FreezeThread)
DECL_EMF(SetThreadPriority)

DECL_EMF(GetExceptionState)
DECL_EMF(SetExceptionState)

DECL_EMF(GetModuleList)

DECL_EMF(Go)
DECL_EMF(SingleStep)
DECL_EMF(RangeStep)
DECL_EMF(ReturnStep)
DECL_EMF(Stop)

DECL_EMF(BreakPoint)

DECL_EMF(SetupExecute)
DECL_EMF(StartExecute)
DECL_EMF(CleanUpExecute)

DECL_EMF(GetAddr)
DECL_EMF(SetAddr)
DECL_EMF(FixupAddr)
DECL_EMF(UnFixupAddr)
DECL_EMF(SetEmi)
DECL_EMF(RegisterEmi)
DECL_EMF(UnRegisterEmi)
DECL_EMF(CompareAddrs)
DECL_EMF(GetObjLength)
DECL_EMF(GetMemoryInfo)
DECL_EMF(GetFunctionInfo)

DECL_EMF(ReadMemory)
DECL_EMF(WriteMemory)

DECL_EMF(GetRegStruct)
DECL_EMF(GetFlagStruct)
DECL_EMF(GetReg)
DECL_EMF(SetReg)
DECL_EMF(GetFlag)
DECL_EMF(SetFlag)
DECL_EMF(SaveRegs)
DECL_EMF(RestoreRegs)

DECL_EMF(Unassemble)
DECL_EMF(GetPrevInst)
DECL_EMF(Assemble)

DECL_EMF(GetFrame)

DECL_EMF(Metric)

DECL_EMF(GetMessageMap)
DECL_EMF(GetMessageMaskMap)

DECL_EMF(InfoReply)
DECL_EMF(Continue)

DECL_EMF(ReadFile)
DECL_EMF(WriteFile)

DECL_EMF(ShowDebuggee)
DECL_EMF(GetTaskList)
DECL_EMF(SystemService)
DECL_EMF(SetDebugMode)

DECL_EMF(Dbc)

DECL_EMF(GetTimeStamp)

DECL_EMF(CreateUserCrashDump)

DECL_EMF(Max)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\ec.cpp ===
// Edit and Continue

#include "shinc.hpp"
#pragma hdrstop
#include "cvr.h"
#include "cvinfo.h"
#include "csymbuf.h"
#include "comenvi.h"

extern VOID KillSci(SymConvertInfo &);
extern VOID VoidCaches(VOID);
extern HST HstFromLpmds (LPMDS);

//
// SHGetSrcPath
//
//  Returns a pointer to static memory that will be overwritten by
//  the next call. Not thread safe.
//
LSZ SHGetSrcPath(HMOD hmod)
{
    static _TCHAR      szFullPath[_MAX_PATH];
    szFullPath[0] = _T('\0');

    if ( !hmod ) {
        return NULL;
    }

    LPMDS lpmds = (LPMDS) hmod;
    if (lpmds->pmod) {
        CB cb = sizeof( szFullPath );
        ModQuerySrcFile( lpmds->pmod, szFullPath, &cb );
    } 
    return szFullPath;
}

//
// SHGetObjPath
//
//  Returns a pointer to static memory that will be overwritten by
//  the next call. Not thread safe.
//
LSZ SHGetObjPath(HMOD hmod)
{
    if ( !hmod ) {
        return NULL;
    }

    static _TCHAR      szFullPath[_MAX_PATH];
    szFullPath[0] = _T('\0');

    LPMDS lpmds = (LPMDS) hmod;
    PB symbuf = reinterpret_cast<PB>( GetSymbols( lpmds ) );
    if ( symbuf ) {
        // find the first S_OBJNAME symbol
        SymBuffer buffer( symbuf, lpmds->cbSymbols );
		for ( SymBuffer::iterator it = buffer.begin(); it != buffer.end(); ++it ) {
            if ( (*it).rectyp == S_OBJNAME ) {
                OBJNAMESYM* psym = reinterpret_cast<OBJNAMESYM*>( &*it );
                memcpy( szFullPath, &psym->name[1], psym->name[0] );
                szFullPath[ psym->name[0] ] = _T('\0');
                break;
            }
        }
    }
    return szFullPath;
}

//
// SHGetCompileEnv
//
//  Returns a pointer to cached symbol data from the pdb.
//      the string is of the form
//      [name\0value\0]*\0
//
LSZ SHGetCompileEnv(HMOD hmod)
{
    if ( !hmod ) {
        return NULL;
    }

    LPMDS lpmds = (LPMDS) hmod;
    PB symbuf = reinterpret_cast<PB>( GetSymbols( lpmds ) );
    if ( symbuf ) {
        // find the first S_COMPILE2 symbol
        SymBuffer buffer( symbuf, lpmds->cbSymbols );
		for ( SymBuffer::iterator it = buffer.begin(); it != buffer.end(); ++it ) {
            if ( (*it).rectyp == S_COMPILE2 ) {
                COMPILESYM* psym = reinterpret_cast<COMPILESYM*>( &*it );
                return reinterpret_cast<char*>(&psym->verSt[1])+psym->verSt[0];
            }
        }
    }
    return NULL;
}

BOOL SHModSupportsEC(HMOD hmod)
{
    if ( !hmod ) {
        return FALSE;
    }

    LPMDS lpmds = (LPMDS) hmod;
    if (lpmds->pmod) {
        return ModQuerySupportsEC( lpmds->pmod );
    }
    return FALSE;
}


BOOL SHExeSupportsEC(HEXE hexe)
{
    BOOL fRet = FALSE;
    if ( !hexe ) {
        return FALSE;
    }

    LPEXE lpexe = (LPEXE) LLLock ( hexe );
    LPEXG lpexg = (LPEXG) LLLock ( lpexe->hexg );

    if (lpexg->ppdb && lpexg->pdbi) {
        fRet = DBIQuerySupportsEC( lpexg->pdbi );
    }

    LLUnlock (lpexe->hexg);
    LLUnlock (hexe);

    return fRet;   
}

BOOL SHModLinkedFromLib(HMOD hmod)
{
    static _TCHAR      szNamePath[_MAX_PATH];
    static _TCHAR      szFilePath[_MAX_PATH];
    szNamePath[0] = _T('\0');
    szFilePath[0] = _T('\0');

    if ( !hmod ) {
        return NULL;
    }

    LPMDS lpmds = (LPMDS) hmod;
    if (lpmds->pmod) {
        // REVIEW: is it sufficient to compare that the two string?
        CB cb = sizeof( szNamePath );
        ModQueryName( lpmds->pmod, szNamePath, &cb );
        cb = sizeof( szFilePath );
        ModQueryFile( lpmds->pmod, szFilePath, &cb );
        return _tcscmp( szNamePath, szFilePath ) != 0;
    }
    return FALSE;
}

BOOL SHModFromHmod( HMOD hmod, PHANDLE ppmod )	// get the underlying Pdb Mod
{
    if ( hmod == 0 || ppmod == 0 ) {
        return false;
    }

    LPMDS lpmds = (LPMDS) hmod;
    *ppmod = lpmds->pmod;
    return lpmds->pmod != 0;
}

BOOL SHFlushModSyms( HMOD hmod )	        // flush symbols for mod
{
    VoidCaches();
    if ( !hmod ) return false;

    LPMDS   lpmds = (LPMDS) hmod;

    if ( !lpmds->pmod ) return false;   // only implemented for pdb symbols

    assert( lpmds->lpsgc == 0 );    // should not use this when we have a pdb?

    if (lpmds->symbols) {           // delete the symbols cache
        MHFree(lpmds->symbols);
#if CC_CVTYPE32
        KillSci(lpmds->sci);
#endif
        lpmds->symbols = 0;
        lpmds->cbSymbols = 0;
    }

    if (lpmds->hst) {               // delete the line numbers cache
        MHFree (lpmds->hst);
        lpmds->hst = 0;
    }
    // now immediatly reload line numbers
    HstFromLpmds( lpmds );
    return true;
}


void SHUseAltPdb( PFNPDBOpenValidateEx pfn )
{
    extern PFNPDBOpenValidateEx pAltPDBOpen;
    assert( pAltPDBOpen == 0 );
    assert( pfn != 0 );
    pAltPDBOpen = pfn;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\exptocv.cpp ===
/*++


Copyright (c) 1997  Microsoft Corporation

Module Name:

    exptocv.c

Abstract:

    This module handles the conversion activities requires for converting
    Exports or COFF info to CODEVIEW debug data. Based on SymCvt then updated
	to use the ImageHlp APIs.

Author:

    Andy Pennell (apennell) 15-July-1997

Environment:

    Win32, User Mode

--*/

#include "shinc.hpp"
#pragma hdrstop
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//#include "cv.h"
#include "symcvt.h"
#include "cvcommon.h"

#include <imagehlp.h>

typedef struct tagENUMINFO {
	PIMAGE_DEBUG_INFORMATION	pDebugInfo;
	HANDLE				hProcess;
	IMAGEHLP_MODULE		IModule;
	DWORD				numsyms;
	DATASYM32*			dataSym;
	PPOINTERS			p;
	PIMAGE_NT_HEADERS	pNtHeader;
} ENUMINFO, *PENUMINFO;


DWORD  CreateModulesFromExps( PPOINTERS p, ENUMINFO * );
DWORD  CreatePublicsFromExps( PPOINTERS p, ENUMINFO * );
DWORD  CreateSegMapFromExps( PPOINTERS p, ENUMINFO * );


BOOL InitReadExports(char *fname, ENUMINFO *pEnumInfo, SHE *pShe)
{
    char       szDrive    [_MAX_DRIVE];
    char       szDir      [_MAX_DIR];
    char       szFname    [_MAX_FNAME];
    char       szExt      [_MAX_EXT];
    char       szPath     [MAX_PATH];
	PIMAGE_DEBUG_INFORMATION pDebugInfo;
	BOOL bSymInit = FALSE;
	BOOL bSymLoad = FALSE;
	IMAGEHLP_MODULE IModule;
	HANDLE hProcess = 0;
	DWORD dwBase;

	SymSetOptions( 0 );						// get them all as raw as possible

	// the search path is the location of the file *only*
    _splitpath( fname, szDrive, szDir, szFname, szExt );
	_makepath( szPath, szDrive, szDir, NULL, NULL );
	if (szPath[strlen(szPath)-1]=='\\')
		szPath[strlen(szPath)-1] = 0;			// remove traling \ else will fail sometimes

	pDebugInfo = MapDebugInformation( NULL, fname, szPath, 0 );
	if (pDebugInfo==NULL)
		return FALSE;

	bSymInit = SymInitialize( hProcess, szPath, FALSE );

	if (!bSymInit)
		goto exit;

	dwBase = (DWORD)pDebugInfo->MappedBase;

	bSymLoad = SymLoadModule( hProcess, NULL, fname, NULL, dwBase, 0L );

	if (!bSymLoad)
		goto exit;

	pEnumInfo->IModule.SizeOfStruct = sizeof(IMAGEHLP_MODULE);

	if (!SymGetModuleInfo( hProcess, dwBase, &pEnumInfo->IModule ))
		goto exit;

	switch (pEnumInfo->IModule.SymType)
	{
		case SymExport:
			*pShe = sheExportsConverted;
			break;
		case SymCoff:
			*pShe = sheSymbolsConverted;
			break;
		case SymSym:
			// ImageHlp has yet to give us a SymSym value due to its broken
			// checking of the SYM header so we don't read those
			// assert(!"Got SYM file, cant do those");
			goto exit;
		case SymNone:
			// this happens on ODBCINT.DLL which is a resource-only DLL for example
			// assert(!"Got NO debug, shame");
			goto exit;
		default:
			goto exit;
	}

	pEnumInfo->numsyms = 0;

	pEnumInfo->pDebugInfo = pDebugInfo;
	pEnumInfo->hProcess = hProcess;
	pEnumInfo->pNtHeader = ImageNtHeader( pDebugInfo->MappedBase );

	return TRUE;

exit:
	if (bSymLoad)
		SymUnloadModule( hProcess, dwBase );

	if (bSymInit)
		SymCleanup( hProcess );

	if (pDebugInfo)
		UnmapDebugInformation( pDebugInfo );

	return FALSE;
}


LONG
GuardPageFilterFunction(
    DWORD                ec,
    LPEXCEPTION_POINTERS lpep
    )

/*++

Routine Description:

    This function catches all exceptions from the convertcofftocv function
    and all that it calls.  The purpose of this function is allocate memory
    when it is necessary.  This happens because the cofftocv conversion cannot
    estimate the memory requirements before the conversion takes place.  To
    handle this properly space in the virtual address space is reserved, the
    reservation amount is 10 times the image size.  The first page is commited
    and then the conversion is started.  When an access violation occurs and the
    page that is trying to be access has a protection of noaccess then the
    page is committed.  Any other exception is not handled.

Arguments:

    ec      - the ecxeption code (should be EXCEPTION_ACCESS_VIOLATION)
    lpep    - pointer to the exception record and context record


Return Value:

    EXCEPTION_CONTINUE_EXECUTION    - access violation handled
    EXCEPTION_EXECUTE_HANDLER       - unknown exception and is not handled

--*/

{
    LPVOID                      vaddr;
    SYSTEM_INFO                 si;
    MEMORY_BASIC_INFORMATION    mbi;


    if (ec == EXCEPTION_ACCESS_VIOLATION) {
        vaddr = (LPVOID)lpep->ExceptionRecord->ExceptionInformation[1];
        VirtualQuery( vaddr, &mbi, sizeof(mbi) );
        if (mbi.AllocationProtect == PAGE_NOACCESS) {
            GetSystemInfo( &si );
            VirtualAlloc( vaddr, si.dwPageSize, MEM_COMMIT, PAGE_READWRITE );
            return EXCEPTION_CONTINUE_EXECUTION;
        }
    }

//  return EXCEPTION_CONTINUE_SEARCH;
    return EXCEPTION_EXECUTE_HANDLER;
}

BOOL
ConvertExpToCv( PPOINTERS p, char *fname, SHE *pSheResult )

/*++

Routine Description:

    This is the control function for the conversion of Exports to CODEVIEW
    debug data.  It calls individual functions for the conversion of
    specific types of debug data.


Arguments:

    fname        - name of component to read


Return Value:

    TRUE     - conversion succeded
    FALSE    - conversion failed

--*/

{
    ENUMINFO            enumInfo;
    DWORD               dwSize;
	BOOL				bResult = FALSE;

	// poor-mans MapInputFile
    memset( p, 0, sizeof(POINTERS) );
    strcpy( p->iptrs.szName, fname );

	if (!InitReadExports( fname, &enumInfo, pSheResult ))
		return FALSE;

	enumInfo.p = p;

	if (enumInfo.IModule.SymType==SymExport)
	    dwSize = enumInfo.pDebugInfo->ExportedNamesSize;
	else
		dwSize = enumInfo.pDebugInfo->SizeOfCoffSymbols;

	// take a guess at the size. Mostly it is good, but sometimes
	// it is very wrong eg when they are a lot of unnamed exports
	// (like shell32 which has over a 1000 of them)
	dwSize += enumInfo.IModule.NumSyms * (sizeof(DATASYM32)+16) + 1024;

	SYSTEM_INFO si;
	GetSystemInfo( &si );

    //
    // reserve all necessary pages
    //
    p->pCvCurr = p->pCvStart.ptr = (LPBYTE)VirtualAlloc( NULL, max ( enumInfo.pDebugInfo->SizeOfImage*10, si.dwPageSize*10 ), MEM_RESERVE, PAGE_NOACCESS );

    //
    // commit the expected pages
    //
    VirtualAlloc( p->pCvCurr, dwSize, MEM_COMMIT, PAGE_READWRITE );

    if (p->pCvStart.ptr)
	    __try {

        CreateSignature( p );
        CreatePublicsFromExps( p, &enumInfo );
        CreateSymbolHashTable( p );
        CreateAddressSortTable( p );
        CreateSegMapFromExps( p, &enumInfo );
        CreateModulesFromExps( p, &enumInfo );
        CreateDirectories( p );
		bResult = TRUE;

    } __except ( GuardPageFilterFunction( GetExceptionCode(), GetExceptionInformation() )) {

        VirtualFree( p->pCvStart.ptr, 0, MEM_RELEASE );
        p->pCvStart.ptr = NULL;
        bResult = FALSE;
    }

    if (bResult) {
        p->pCvCurr = (LPBYTE)LocalAlloc( NONZEROLPTR, p->pCvStart.size );
		if (p->pCvCurr)
	        CopyMemory( p->pCvCurr, p->pCvStart.ptr, p->pCvStart.size );
		else
			bResult = FALSE;
        VirtualFree( p->pCvStart.ptr, 0, MEM_RELEASE );
		if (0)
		{
			char szMsg[256];
			wsprintf(szMsg, "Guess=%08lx, Actual=%08lx, P=%08lx, %s\n", dwSize, p->pCvStart.size, p->pCvStart.ptr, fname );
			OutputDebugString(szMsg);
		}
        p->pCvStart.ptr = p->pCvCurr;
    }

	SymUnloadModule( enumInfo.hProcess, (DWORD)enumInfo.pDebugInfo->MappedBase );
	SymCleanup( enumInfo.hProcess );
	UnmapDebugInformation( enumInfo.pDebugInfo );

	return bResult;
}

// dont use ImageRVAToVa as it uses the wrong Size field
// 0 means error
DWORD FindSection( IMAGE_DEBUG_INFORMATION *pDebugInfo, DWORD *pOffset )
{
	DWORD Address = *pOffset;
	PIMAGE_SECTION_HEADER sh = pDebugInfo->Sections;
	DWORD NumSections = pDebugInfo->NumberOfSections;
    ULONG i;
    for (i=0; i<NumSections; i++)
	{
        if (Address >= sh[i].VirtualAddress &&
            Address <  (sh[i].VirtualAddress + sh[i].Misc.VirtualSize))
		{
			*pOffset -= sh[i].VirtualAddress;
			return i+1;
        }
    }
    return 0;
}


// callback used when enumerating symbols

BOOL EnumExportsToPublics( LPSTR szSymName, ULONG SymbolAddress, ULONG /*SymbolSize*/, PVOID UserContext )
{
	ENUMINFO *const pEnumInfo = (ENUMINFO *const)UserContext;
	IMAGE_DEBUG_INFORMATION * const pDebugInfo = pEnumInfo->pDebugInfo;

	if (SymbolAddress==0)
	{
		// some DLLs give us strange info (eg JSCRIPT.DLL)
		return TRUE;
	}

	// calculate section and offset
	DWORD dwOffset = SymbolAddress - (DWORD)pDebugInfo->MappedBase;
	if (dwOffset==0)
	{
		// some exports (eg a bunch in OLEAUT32) have an Rva of zero, which means we
		// will not find an owner section for them so bail now
		return TRUE;
	}

	DWORD nSection = FindSection( pDebugInfo, &dwOffset );

	if (nSection==0)
	{
		// the symbol wasn't found in a section, so ignore it
		assert(!"Symbol not in section");
		return TRUE;
	}
	assert( (nSection>0) && (nSection<=pDebugInfo->NumberOfSections) );

	// build a symbol record
	DATASYM32 *dataSym = pEnumInfo->dataSym;

    dataSym->seg = (WORD)nSection;			// 1-based
    dataSym->off = dwOffset;


    dataSym->rectyp = S_PUB32;
    dataSym->typind = 0;
    dataSym->name[0] = (BYTE)strlen( szSymName );
    strcpy( (char*)&dataSym->name[1], szSymName );

	DATASYM32 *dataSym2 = NextSym32( dataSym );
    dataSym->reclen = (USHORT) ((DWORD)dataSym2 - (DWORD)dataSym) - 2;
    dataSym = dataSym2;

	pEnumInfo->numsyms++;
	pEnumInfo->dataSym = dataSym;

	return TRUE;
}

DWORD
CreatePublicsFromExps( PPOINTERS p, ENUMINFO *pEnumInfo )
{
    OMFSymHash          *omfSymHash;

    omfSymHash = (OMFSymHash *) p->pCvCurr;
    pEnumInfo->dataSym = (DATASYM32 *) (PUCHAR)((DWORD)omfSymHash + sizeof(OMFSymHash));
	pEnumInfo->numsyms = 0;

	SymEnumerateSymbols( pEnumInfo->hProcess, (DWORD)pEnumInfo->pDebugInfo->MappedBase, EnumExportsToPublics, pEnumInfo );

    UpdatePtrs( p, &p->pCvPublics, (LPVOID)pEnumInfo->dataSym, pEnumInfo->numsyms );

    omfSymHash->cbSymbol = p->pCvPublics.size - sizeof(OMFSymHash);
    omfSymHash->symhash  = 0;
    omfSymHash->addrhash = 0;
    omfSymHash->cbHSym   = 0;
    omfSymHash->cbHAddr  = 0;

    return pEnumInfo->numsyms;
}


DWORD
CreateModulesFromExps( PPOINTERS p, ENUMINFO *pEnumInfo )

/*++

Routine Description:

    Creates the individual CV module records.  There is one CV module
    record.

Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    The number of modules that were created.

--*/

{
    char                szDrive    [_MAX_DRIVE];
    char                szDir      [_MAX_DIR];
    char                szFname    [_MAX_FNAME];
    char                szExt      [_MAX_EXT];
    OMFModule           *m;
    char *              pb;

    _splitpath( p->iptrs.szName, szDrive, szDir, szFname, szExt );

    m = (OMFModule *) p->pCvCurr;

    m->ovlNumber        = 0;
    m->iLib             = 0;
    m->cSeg             = 1;
    m->Style[0]         = 'C';
    m->Style[1]         = 'V';
    m->SegInfo[0].Seg   = 1;
    m->SegInfo[0].pad   = 0;
    m->SegInfo[0].Off   = 0;
    m->SegInfo[0].cbSeg = pEnumInfo->pDebugInfo->SizeOfImage;

    pb = (char *) &m->SegInfo[1];
    sprintf( &pb[1], "%s.c", szFname );
    pb[0] = (char)strlen( &pb[1] );

    pb = (char *) NextMod(m);

    UpdatePtrs( p, &p->pCvModules, (LPVOID)pb, 1 );

    return 1;
}

DWORD
CreateSegMapFromExps( PPOINTERS p, ENUMINFO *pEnumInfo )

/*++

Routine Description:

    Creates the CV segment map.  The segment map is used by debuggers
    to aid in address lookups.  One segment is created for each 
    section in the image.

Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    The number of segments in the map.

--*/
{
    DWORD                       i;
    SGM                         *sgm;
    SGI                         *sgi;
    PIMAGE_SECTION_HEADER       sh;
    ULONG                       align;
	PIMAGE_DEBUG_INFORMATION	dbg = pEnumInfo->pDebugInfo;


    sgm = (SGM *) p->pCvCurr;
    sgi = (SGI *) ((DWORD)p->pCvCurr + sizeof(SGM));

    sgm->cSeg = (WORD)dbg->NumberOfSections;
    sgm->cSegLog = (WORD)dbg->NumberOfSections;

    sh = dbg->Sections;

	align = pEnumInfo->pNtHeader ? pEnumInfo->pNtHeader->OptionalHeader.SectionAlignment : 4096;

    for (i=0; i<dbg->NumberOfSections; i++, sh++) {
        sgi->sgf.fRead        = (USHORT) ((sh->Characteristics & IMAGE_SCN_MEM_READ)    == IMAGE_SCN_MEM_READ);
        sgi->sgf.fWrite       = (USHORT) ((sh->Characteristics & IMAGE_SCN_MEM_WRITE)   == IMAGE_SCN_MEM_WRITE);
        sgi->sgf.fExecute     = (USHORT) ((sh->Characteristics & IMAGE_SCN_MEM_EXECUTE) == IMAGE_SCN_MEM_EXECUTE);
        sgi->sgf.f32Bit       = 1;
        sgi->sgf.fSel         = 1;
        sgi->sgf.fAbs         = 0;
        sgi->sgf.fGroup       = 0;
        sgi->iovl             = 0;
        sgi->igr              = 0;
        sgi->isgPhy           = (USHORT) i + 1;
        sgi->isegName         = -1;
        sgi->iclassName       = -1;
        sgi->doffseg          = 0;
        sgi->cbSeg            = ((sh->Misc.VirtualSize + (align-1)) & ~(align-1));
        sgi++;
    }

    UpdatePtrs( p, &p->pCvSegMap, (LPVOID)sgi, i );

    return i;
}


PUCHAR
ConvertSymbolsForImage2(
                       HANDLE      hFile,
                       char *      fname,
					   SHE *       pSheResult
    )
{
	POINTERS   p;
	PUCHAR     rVal;

	*pSheResult = sheNoSymbols;

	ConvertExpToCv( &p, fname, pSheResult );
	rVal = p.pCvStart.ptr;

	return rVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\cvcommon.cpp ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cvcommon.c

Abstract:

    This file contians a set of common routines which are used in
    doing symbol conversions from one type of symbols to CodeView
    symbols.

Author:

    Wesley A. Witt (wesw) 19-April-1993
    Jim Schaad (jimsch) 22 May 1993

--*/

#include "shinc.hpp"
#pragma hdrstop
#include        <windows.h>
#include        <stdlib.h>
//#include        "cv.h"
#include        "symcvt.h"
#include        "cvcommon.h"

typedef struct tagSYMHASH {
    DWORD       dwHashVal;         // hash value for the symbol
    DWORD       dwHashBucket;      // hash bucket number
    DATASYM16 * dataSym;           // pointer to the symbol info
} SYMHASH;

typedef struct tagOFFSETSORT {
    DWORD       dwOffset;          // offset for the symbol
    DWORD       dwSection;         // section number of the symbol
    DATASYM16 * dataSym;           // pointer to the symbol info
} OFFSETSORT;


int __cdecl SymHashCompare( const void *arg1, const void *arg2 );
int __cdecl OffsetSortCompare( const void *arg1, const void *arg2 );


DWORD
CreateSignature( PPOINTERS p )

/*++

Routine Description:

    Creates the CODEVIEW signature record.  Currently this converter only
    generates NB08 data (MS C/C++ 7.0).


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    number of records generates, this is always 1.

--*/

{
    OMFSignature        *omfSig;

    omfSig = (OMFSignature *) p->pCvCurr;
    strcpy( omfSig->Signature, "NB08" );
    omfSig->filepos = 0;
    p->pCvStart.size += sizeof(OMFSignature);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFSignature);
    return 1;
}                               /* CreateSignature() */


DWORD
CreateDirectories( PPOINTERS p )

/*++

Routine Description:

    This is the control function for the generation of the CV directories.
    It calls individual functions for the generation of specific types of
    debug directories.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    the number of directories created.

--*/

{
    OMFDirHeader        *omfDir = (OMFDirHeader *)p->pCvCurr;
    OMFSignature        *omfSig = (OMFSignature *)p->pCvStart.ptr;

    omfSig->filepos = (DWORD)p->pCvCurr - (DWORD)p->pCvStart.ptr;

    omfDir->cbDirHeader = sizeof(OMFDirHeader);
    omfDir->cbDirEntry  = sizeof(OMFDirEntry);
    omfDir->cDir        = 0;
    omfDir->lfoNextDir  = 0;
    omfDir->flags       = 0;

    p->pCvStart.size += sizeof(OMFDirHeader);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirHeader);

    omfDir->cDir += CreateModuleDirectoryEntries( p );
    omfDir->cDir += CreatePublicDirectoryEntries( p );
    omfDir->cDir += CreateSegMapDirectoryEntries( p );
    omfDir->cDir += CreateSrcModulesDirectoryEntries( p );

    strcpy((char*)p->pCvCurr, "NB080000");
    p->pCvStart.size += 8;
    p->pCvCurr += 8;
    *((DWORD *) (p->pCvCurr-4)) = p->pCvStart.size;

    return omfDir->cDir;
}                               /* CreateDirectories() */


DWORD
CreateModuleDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry   *omfDirEntry = NULL;
    OMFModule     *m = NULL;
    OMFModule     *mNext = NULL;
    DWORD         i = 0;
    DWORD         mSize = 0;
    DWORD         lfo = (DWORD)p->pCvModules.ptr - (DWORD)p->pCvStart.ptr;

    m = (OMFModule *) p->pCvModules.ptr;
    for (i=0; i<p->pCvModules.count; i++) {
        mNext = NextMod(m);

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        mSize = (DWORD)mNext - (DWORD)m;
        omfDirEntry->SubSection = sstModule;
        omfDirEntry->iMod       = (USHORT) i + 1;
        omfDirEntry->lfo        = lfo;
        omfDirEntry->cb         = mSize;

        lfo += mSize;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

        m = mNext;
    }

    return p->pCvModules.count;
}                               /* CreateModuleDirectoryEntries() */


DWORD
CreatePublicDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the global publics.

Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstGlobalPub;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvPublics.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvPublics.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreatePublicDirectoryEntries() */


DWORD
CreateSegMapDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates the directory entry for the segment map.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    the number of directory entries created, always 1.

--*/

{
    OMFDirEntry   *omfDirEntry = (OMFDirEntry *) p->pCvCurr;

    omfDirEntry->SubSection = sstSegMap;
    omfDirEntry->iMod       = 0xffff;
    omfDirEntry->lfo        = (DWORD)p->pCvSegMap.ptr - (DWORD)p->pCvStart.ptr;
    omfDirEntry->cb         = p->pCvSegMap.size;

    p->pCvStart.size += sizeof(OMFDirEntry);
    p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);

    return 1;
}                               /* CreateSegMapDirectoryEntries() */


DWORD
CreateSrcModulesDirectoryEntries( PPOINTERS p )

/*++

Routine Description:

    Creates directory entries for each source module in the image.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    the number of directory entries created.

--*/

{
    OMFDirEntry         *omfDirEntry = NULL;
    DWORD               i;
    DWORD               lfo = (DWORD)p->pCvSrcModules.ptr - (DWORD)p->pCvStart.ptr;
    OMFSourceModule     *m;


    //
    // if there were no linenumber conversions then bail out
    //
    if (!p->pCvSrcModules.count) {
        return 0;
    }

    for (i=0; i<p->pCvSrcModules.count; i++) {

        if (!p->pMi[i].SrcModule) {
            continue;
        }

        omfDirEntry = (OMFDirEntry *) p->pCvCurr;

        omfDirEntry->SubSection = sstSrcModule;
        omfDirEntry->iMod = (USHORT) p->pMi[i].iMod;
        omfDirEntry->lfo = lfo;
        omfDirEntry->cb = p->pMi[i].cb;

        m = (OMFSourceModule*) p->pMi[i].SrcModule;

        lfo += omfDirEntry->cb;

        p->pCvStart.size += sizeof(OMFDirEntry);
        p->pCvCurr = (PUCHAR) p->pCvCurr + sizeof(OMFDirEntry);
    }

    LocalFree ( p->pMi );

    return p->pCvSrcModules.count;
}                               /* CreateSrcModulesDirectoryEntries() */


DWORD
DWordXorLrl( char *szSym )

/*++

Routine Description:

    This function will take an ascii character string and generate
    a hash for that string.  The hash algorithm is the CV NB08 hash
    algorithm.


Arguments:

    szSym    - a character pointer, the first char is the string length


Return Value:

    The generated hash value.

--*/

{
    char                *pName = szSym+1;
    int                 cb =  *szSym;
    char                *pch;
    char                c;
    DWORD               hash = 0;
    DWORD UNALIGNED     *pul = (DWORD *) pName;
    static              rgMask[] = {0, 0xff, 0xffff, 0xffffff};

    //
    // We replace all "::" to "__"
    //
    c = *(pName+cb);
    *(pName+cb) = '\0';
    pch = strstr( pName, "::" );
    if ( pch ) {
        *pch++ = '_';
        *pch   = '_';
    }
    *(pName+cb) = c;

    pch = pName + cb - 1;
    while (isdigit(*pch)) {
        pch--;
    }

    if (*pch == '@') {
        cb = pch - pName;
    }

    for (; cb > 3; cb-=4, pul++) {
        hash = _lrotl(hash, 4);
        hash ^= (*pul & 0xdfdfdfdf);
    }

    if (cb > 0) {
        hash = _lrotl(hash,4);
        hash ^= ((*pul & rgMask[cb]) & 0xdfdfdfdf);
    }

    return hash;
}                               /* DWordXorLrl() */



OMFModule *
NextMod(
        OMFModule *             pMod
        )
/*++

Routine Description:

    description-of-function.

Arguments:

    argument-name - Supplies | Returns description of argument.
    .
    .

Return Value:

    return-value - Description of conditions needed to return value. - or -
    None.

--*/

{
    char *      pb;

    pb = (char *) &(pMod->SegInfo[pMod->cSeg]);
    pb += *pb + 1;
    pb = (char *) (((unsigned long) pb + 3) & ~3);

    return (OMFModule *) pb;
}                               /* NextMod() */



int
__cdecl
SymHashCompare(
               const void *     arg1,
               const void *     arg2
               )
/*++

Routine Description:

    Sort compare function for sorting SYMHASH records by hashed
    bucket number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((SYMHASH*)arg1)->dwHashBucket < ((SYMHASH*)arg2)->dwHashBucket) {
        return -1;
    }
    if (((SYMHASH*)arg1)->dwHashBucket > ((SYMHASH*)arg2)->dwHashBucket) {
        return 1;
    }
    return 0;
}                               /* SymHashCompare() */


DWORD
CreateSymbolHashTable(
                      PPOINTERS p
                      )
/*++

Routine Description:


    Creates the CV symbol hash table.  This hash table is used
    primarily by debuggers to access symbols in a quick manner.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    The number of buckets is the hash table.

--*/

{
    DWORD               i;
    DWORD               j;
    int                 k;
    DWORD               numsyms;
    DWORD               numbuckets;
    OMFSymHash          *omfSymHash;
    DATASYM16           *dataSymStart;
    DATASYM16           *dataSym;
    LPVOID              pHashData;
    USHORT              *pCHash;
    DWORD               *pHashTable;
    USHORT              *pBucketCounts;
    DWORD               *pChainTable;
    SYMHASH             *symHashStart;
    SYMHASH             *symHash;
    DWORD               dwHashVal;
    char *              sz;

    numsyms = p->pCvPublics.count;
    numbuckets = (numsyms+9) / 10;
    numbuckets = (1 + numbuckets) & ~1;

    symHashStart =
    symHash = (SYMHASH *) LocalAlloc( NONZEROLPTR, numsyms * sizeof(SYMHASH) );
    if (symHashStart == NULL) {
        return 0;
    }

    memset( symHashStart, 0, numsyms * sizeof(SYMHASH) );

    pHashData = (LPVOID) p->pCvCurr;
    pCHash = (USHORT *) pHashData;
    pHashTable = (DWORD *) ((DWORD)pHashData + sizeof(DWORD));
    pBucketCounts = (USHORT *) ((DWORD)pHashTable +
                                  (sizeof(DWORD) * numbuckets));
    pChainTable = (DWORD *) ((DWORD)pBucketCounts +
                                 ((sizeof(USHORT) * numbuckets)));

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
    dataSym = (DATASYM16 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCHash = (USHORT)numbuckets;

    /*
     *  cruise thru the symbols and calculate the hash values
     *  and the hash bucket numbers; save the info away for later use
     */
    for (i=0; i<numsyms; i++, symHash++) {
        switch( dataSym->rectyp ) {
        case S_PUB32:
            sz = (char*)((DATASYM32 *) dataSym)->name;
            break;

        default:
            continue;
        }

        dwHashVal = DWordXorLrl( sz );
        symHash->dwHashBucket = dwHashVal % numbuckets;
        pBucketCounts[symHash->dwHashBucket] += 1;
        symHash->dataSym = dataSym;
        dataSym = ((DATASYM16 *) ((char *) dataSym + dataSym->reclen + 2));
    }

    qsort( (void*)symHashStart, numsyms, sizeof(SYMHASH), SymHashCompare );

    j = (char *)pChainTable - (char *)pHashData;
    for (i=0, k = 0; i<numbuckets;
         k += pBucketCounts[i], i += 1, pHashTable++ ) {
        *pHashTable = (DWORD) j + (k * 4);
    }

    dataSymStart = (DATASYM16 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0,symHash=symHashStart; i<numsyms; i++,symHash++,pChainTable++) {
        *pChainTable = (DWORD) (DWORD)symHash->dataSym - (DWORD)dataSymStart;
    }

    UpdatePtrs( p, &p->pCvSymHash, (LPVOID)pChainTable, numsyms );

    omfSymHash->symhash = 6;
    omfSymHash->cbHSym = p->pCvSymHash.size;

    LocalFree( symHashStart );

    return numbuckets;
}                               /* CreateSymbolHashTable() */


VOID
UpdatePtrs( PPOINTERS p, PPTRINFO pi, LPVOID lpv, DWORD count )

/*++

Routine Description:

    This function is called by ALL functions that put data into the
    CV data area.  After putting the data into the CV memory this function
    must be called.  It will adjust all of the necessary pointers so the
    the next guy doesn't get hosed.


Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)
    pi       - the CV pointer that is to be updated
    lpv      - current pointer into the CV data
    count    - the number of items that were placed into the CV data


Return Value:

    void

--*/

{
    if (!count) {
        return;
    }

    pi->ptr = p->pCvCurr;
    pi->size = (DWORD) ((DWORD)lpv - (DWORD)p->pCvCurr);
    pi->count = count;

    p->pCvStart.size += pi->size;
    p->pCvCurr = (PUCHAR) lpv;

    return;
}                               /* UpdatePtrs() */


int
__cdecl
OffsetSortCompare( const void *arg1, const void *arg2 )

/*++

Routine Description:

    Sort compare function for sorting OFFETSORT records by section number.


Arguments:

    arg1     - record #1
    arg2     - record #2


Return Value:

   -1        - record #1 is < record #2
    0        - records are equal
    1        - record #1 is > record #2

--*/

{
    if (((OFFSETSORT*)arg1)->dwSection < ((OFFSETSORT*)arg2)->dwSection) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwSection > ((OFFSETSORT*)arg2)->dwSection) {
        return 1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset < ((OFFSETSORT*)arg2)->dwOffset) {
        return -1;
    }
    if (((OFFSETSORT*)arg1)->dwOffset > ((OFFSETSORT*)arg2)->dwOffset) {
        return 1;
    }
    return 0;
}                               /* OffsetSortCompare() */


DWORD
CreateAddressSortTable( PPOINTERS p )

/*++

Routine Description:


    Creates the CV address sort table. This hash table is used
    primarily by debuggers to access symbols in a quick manner when
    all you have is an address.

Arguments:

    p        - pointer to a POINTERS structure (see cofftocv.h)


Return Value:

    The number of sections in the table.

--*/

{
    DWORD               i;
    DWORD               j;
    int                 k;
    DWORD               numsyms = p->pCvPublics.count;
    DWORD               numsections;
    OMFSymHash          *omfSymHash;
    DATASYM16           *dataSymStart;
    DATASYM16           *dataSym;
    LPVOID              pAddressData;
    USHORT              *pCSeg;
    DWORD               *pSegTable;
    USHORT              *pOffsetCounts;
    DWORD               *pOffsetTable;
    OFFSETSORT          *pOffsetSortStart;
    OFFSETSORT          *pOffsetSort;

    if (p->iptrs.fileHdr) {
        numsections = p->iptrs.fileHdr->NumberOfSections;
    } else if (p->iptrs.sepHdr) {
        numsections = p->iptrs.sepHdr->NumberOfSections;
    } else {
        numsections = 1; //AMPHACK was CSymSegs;
    }

    pOffsetSortStart =
      pOffsetSort = (OFFSETSORT *) LocalAlloc( NONZEROLPTR, numsyms * sizeof(OFFSETSORT) );

    if (pOffsetSort == NULL) {
        return 0;
    }

    memset( pOffsetSortStart, 0, numsyms * sizeof(OFFSETSORT) );

    pAddressData = (LPVOID) p->pCvCurr;
    pCSeg = (USHORT *) pAddressData;
    pSegTable = (DWORD *) ((DWORD)pAddressData + sizeof(DWORD));
    pOffsetCounts = (USHORT *) ((DWORD)pSegTable +
                                (sizeof(DWORD) * numsections));
    pOffsetTable = (DWORD *) ((DWORD)pOffsetCounts +
                              ((sizeof(USHORT) * numsections)));
    if (numsections & 1) {
        pOffsetTable = (DWORD *) ((DWORD)pOffsetTable + 2);
    }

    omfSymHash = (OMFSymHash *) p->pCvPublics.ptr;
    dataSymStart =
      dataSym = (DATASYM16 *) ((DWORD)omfSymHash + sizeof(OMFSymHash));

    *pCSeg = (USHORT)numsections;

    for (i=0;
         i<numsyms;
         i++, pOffsetSort++)
    {
        switch(dataSym->rectyp) {
        case S_PUB32:
            pOffsetSort->dwOffset = ((DATASYM32 *) dataSym)->off;
            pOffsetSort->dwSection = ((DATASYM32 *) dataSym)->seg;
        }

        pOffsetSort->dataSym = dataSym;
        pOffsetCounts[pOffsetSort->dwSection - 1] += 1;
        dataSym = ((DATASYM16 *) ((char *) dataSym + dataSym->reclen + 2));    }

//#if 0
    qsort((void*)pOffsetSortStart, numsyms, sizeof(OFFSETSORT), OffsetSortCompare );
//#endif

    j = (DWORD) (DWORD)pOffsetTable - (DWORD)pAddressData;
    for (i=0, k=0; i<numsections;
         k += pOffsetCounts[i], i += 1, pSegTable++) {
        *pSegTable = (DWORD) j + (k * 4);
    }

    dataSymStart = (DATASYM16 *) (PUCHAR)((DWORD)omfSymHash);
    for (i=0, pOffsetSort=pOffsetSortStart;
         i < numsyms;
         i++, pOffsetSort++, pOffsetTable++) {
        *pOffsetTable = (DWORD)pOffsetSort->dataSym - (DWORD)dataSymStart;
    }

    UpdatePtrs( p, &p->pCvAddrSort, (LPVOID)pOffsetTable, numsyms );

    omfSymHash->addrhash = 5;
    omfSymHash->cbHAddr = p->pCvAddrSort.size;

    LocalFree( pOffsetSortStart );

    return numsections;
}                               /* CreateAddressSort() */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\hash.cpp ===
#include "shinc.hpp"
#pragma hdrstop

#define toLowerMask 0x20202020

unsigned hashPbCb(PB pb, CB cb, unsigned long ulMod)
{
    unsigned long   ulHash  = 0;

    // hash leading dwords using Duff's Device
    long    cl      = cb >> 2;
    UNALIGNED unsigned long*        pul     = (unsigned long*)pb;
    UNALIGNED unsigned long*        pulMac  = pul + cl;
    int     dcul    = cl & 7;

    switch (dcul) {
        do {
            dcul = 8;
            ulHash ^= pul[7];
        case 7: ulHash ^= pul[6];
        case 6: ulHash ^= pul[5];
        case 5: ulHash ^= pul[4];
        case 4: ulHash ^= pul[3];
        case 3: ulHash ^= pul[2];
        case 2: ulHash ^= pul[1];
        case 1: ulHash ^= pul[0];
        case 0: ;
        } while ((pul += dcul) < pulMac);
    }

    pb = (PB) pul;

    // hash possible odd word
    if (cb & 2) {
        ulHash ^= *(UNALIGNED unsigned short*)pb;
        pb = (PB)((UNALIGNED unsigned short*)pb + 1);
    }

    // hash possible odd byte
    if (cb & 1) {
        ulHash ^= *(pb++);
    }

    ulHash |= toLowerMask;
    ulHash ^= (ulHash >> 11);

    return (unsigned)((ulHash ^ (ulHash >> 16)) % ulMod);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\ph.cpp ===
//  ph.cxx
//
//  Copyright <C> 1989-94, Microsoft Corporation
//
//      [01] 03-dec-91 DavidGra
//          Correct the BSearch to return the nearest element
//          less than the key element when there is not an
//          exact match.
//
//      [00] 15-nov-91 DavidGra
//          Suppress hashing when the SSTR_NoHash bit it set.
//
//      11/1/94 BryanT
//          Merge in NT changes
//          Remove fChild arg from SHFindNameInGlobal (unused)

#include "shinc.hpp"
#pragma hdrstop

       ULONG  GSTBSearch (UOFFSET, LPALM, ULONG, ULONG, UOFFSET *);
inline SYMPTR FindNameLinearInGlobs (LPEXG, SYMPTR, LPSSTR, PFNCMP, SHFLAG);
inline SYMPTR FindNameLinearInPubs (LPEXG, SYMPTR, LPSSTR, PFNCMP, SHFLAG);
       SYMPTR GSTFindNameLinear (LPEXG, LPGST, SYMPTR, LPSSTR, PFNCMP, SHFLAG);
inline SYMPTR FindNameHashedInGlobs(LPEXG, SYMPTR, LPSSTR, PFNCMP, SHFLAG, HMOD *);
inline SYMPTR FindNameHashedInStatics(LPEXG, SYMPTR, LPSSTR, PFNCMP, SHFLAG, HMOD *);
inline SYMPTR FindNameHashedInPubs (LPEXG, SYMPTR, LPSSTR, PFNCMP, SHFLAG, HMOD *);
       SYMPTR GSTFindNameHashed (LPEXG, LPGST, SYMPTR, LPSSTR, PFNCMP, SHFLAG, HMOD *);
inline SYMPTR FindNearest (LPEXG, LPADDR, LPL);
       SYMPTR GSTFindNearest (LPEXG, LPGST, LPADDR, LPL);
       SYMPTR PsymFromRef (LPEXG, SYMPTR, HMOD *);
       BOOL   GSTCmpName (SYMPTR, LPSSTR, PFNCMP, SHFLAG);
       SYMPTR GSIFindNameLinear (LPEXG, GSI*, SYMPTR, LPSSTR, PFNCMP, SHFLAG);
       SYMPTR GSIFindNameHashed (LPEXG, GSI*, SYMPTR, LPSSTR, PFNCMP, SHFLAG, HMOD *);



inline bool FIsRefSym(unsigned short rectyp)
{
   return (rectyp == S_PROCREF) ||
          (rectyp == S_DATAREF) ||
          (rectyp == S_LPROCREF);
}


inline void lpStrToSz(LPSSTR lpsstr, char* sz)
{
    assert(lpsstr->cb < 256);
    memcpy(sz, lpsstr->lpName, lpsstr->cb);
    sz[lpsstr->cb] = 0;
}


//  PHExactCmp
//
//  Purpose: Compare two strings.
//
//  Input:
//      lsz     Zero terminated string for compare
//      hsym    -- not used --
//      lstz    Zero terminated length prefixed string for compare
//      fCase   Perform case sensitive compare?
//
//  Output: Return ZERO if strings are equal, else non-zero.

SHFLAG
PHExactCmp(
    HVOID hvStr,
    HVOID hvSym,
    LSZ lpb,
    SHFLAG fCase
    )
{
    LPSSTR lpsstr = (LPSSTR) hvStr;
    size_t  cb;
    SHFLAG  shf = TRUE;

    Unreferenced (hvSym);

    if (lpb) {
        cb = (size_t)*lpb;

        // if length is diff, they are not equal
        if (lpsstr && (size_t) lpsstr->cb == cb) {
            if (fCase) {
                shf = (SHFLAG) memcmp (lpb + 1, lpsstr->lpName, cb);
            } else {
                shf = (SHFLAG) _tcsnicmp(lpb + 1, (_TCHAR *)lpsstr->lpName, cb);
            }
        }
    }
    return shf;
}

//  PHGetNearestHsym
//
//  Purpose: To find a public symbol within a module
//
//  Input:
//      paddr   - The address of the symbol to find
//      hExe    - The exe to look in for the symbol in
//      phsym   - The symbol pointer
//
//  Output:
//      Returns How far (in bytes) the found symbol is from the address.
//      CV_MAXOFFSET is returned if non is found.

CV_uoff32_t
PHGetNearestHsym(
    LPADDR  lpaddr,
    HEXE    hexe,
    PHSYM   phsym
    )
{
    CV_uoff32_t dCur = CV_MAXOFFSET;
    LPEXE  lpexe;
    LPEXG  lpexg;

    *phsym = NULL;

    if (!VerifyHexe (hexe)) {
        return dCur;
    }

    lpexe = (LPEXE) LLLock (hexe);

    if (lpexe->hexg != hexgNull) {
        lpexg = (LPEXG) LLLock (lpexe->hexg);
        *phsym = FindNearest (lpexg, lpaddr, (LPL) &dCur);
        LLUnlock(lpexe->hexg);
    }

    LLUnlock(hexe);

    return dCur;
}


BOOL
PHGetAddr(
    LPADDR paddr,
    LSZ lszName
    )
{
    HSYM    hsym = NULL;
    HEXE    hexe = 0;
    SSTR    sstr = {0};

    if (lszName == NULL || *lszName == '\0') {
        return FALSE;
    }

    sstr.lpName = (LPB) lszName;
    sstr.cb  = (BYTE) _tcslen (lszName);

    if (!(hsym = PHFindNameInPublics (NULL,
                                      hexe = SHGetNextExe (hexeNull),
                                      (LPSSTR) &sstr,
                                      TRUE,
                                      PHExactCmp)))
    {
        return FALSE;
    }

    SHAddrFromHsym (paddr, hsym);

    assert (hexe);
    emiAddr (*paddr) = (HEMI) hexe;

    return TRUE;
}

//  PHFindNameInPublics
//
//  Purpose: To find a public symbol
//
//  Input:
//      hsym    - This must be NULL! In the future this routine may
//                  be a find first find next behavior. For a first
//                  find use NULL, for a next find use the last symbol.
//      hExe    - The exe to search
//      hInfo   - The info packet to give to the comparison routine
//      fCase   - If TRUE do a case sensitive search.
//      pfnCm   - A pointer to the comparison function
//
//  Output:
//      Returns A public symbol or NULL on error
//
//  Exceptions: For now, the input hsym MUST BE NULL!

#define dwrd_toupper(dw) (dw & 0xDFDFDFDF)
#define byt_toupper(b) (b & 0xDF)

#define HASHFUNC(i,lpsstr,wModulo,lpul) \
    ((i==6)?DWordXor(lpsstr,wModulo,lpul):DWordXorShift(lpsstr,wModulo,lpul))

ushort
DWordXor(
    LPSSTR lpsstr,
    WORD wModulo,
    LPUL lpul
    )
{
    LPB   lpbName  = lpsstr->lpName;
    UNALIGNED ULONG * lpulName = (UNALIGNED ULONG*) lpbName;
    int   cb       = lpsstr->cb;
    int   cul;
    int   iul;
    ULONG ulSum    = 0;
    ULONG ulEnd    = 0;

    while (cb & 3) {
        ulEnd |= byt_toupper (lpbName [ cb - 1 ]);
        ulEnd <<= 8;
        cb -= 1;
    }

    cul = cb / 4;

    for (iul = 0; iul < cul; iul++) {
        ulSum ^= dwrd_toupper(lpulName[iul]);
    }
    ulSum ^= ulEnd;

    *lpul = ulSum;

    return (ushort) (ulSum % wModulo);
}

ushort
DWordXorShift(
    LPSSTR lpsstr,
    WORD wModulo,
    LPUL lpul
    )
{
    LPB   lpbName  = lpsstr->lpName;
    UNALIGNED ULONG* lpulName = (UNALIGNED ULONG*) lpbName;
    int   cb       = lpsstr->cb;
    int   cul;
    int   iul;
    ULONG ulSum    = 0;
    ULONG ulEnd    = 0;

    while (cb & 3) {
        ulEnd |= byt_toupper (lpbName [ cb - 1 ]);
        ulEnd <<= 8;
        cb -= 1;
    }

    cul = cb / 4;

    for (iul = 0; iul < cul; iul++) {
        ulSum ^= dwrd_toupper(lpulName[iul]);
        ulSum = _lrotl (ulSum, 4);
    }
    ulSum ^= ulEnd;

    *lpul = ulSum;

    return (ushort) (ulSum % wModulo);
}


HSYM
PHFindNameInPublics(
    HSYM    hsym,
    HEXE    hexe,
    LPSSTR  lpsstr,
    SHFLAG  fCase,
    PFNCMP  pfnCmp
    )
{
    SYMPTR psym  = (SYMPTR) hsym;
    LPEXE  lpexe;
    LPEXG  lpexg;

    if (hexe == hexeNull) {
        return NULL;
    }

    lpexe = (LPEXE) LLLock (hexe);

    if (lpexe->hexg == hexgNull) {
        psym = (SYMPTR)NULL;
    } else {
        lpexg  = (LPEXG) LLLock (lpexe->hexg);
        if (lpsstr->searchmask & SSTR_NoHash)
            psym = FindNameLinearInPubs (lpexg, psym, lpsstr, pfnCmp, fCase);
        else
            psym = FindNameHashedInPubs (lpexg, psym, lpsstr, pfnCmp, fCase, NULL);
        LLUnlock (lpexe->hexg);
    }

    LLUnlock (hexe);

    return psym;
}


int
SHPublicNameToAddr(
    PADDR loc,
    PADDR pMpAddr,
    LSZ lszName
    )
{
    HSYM    hsym = NULL;
    int     wRet = FALSE;
    ADDR    addr = *loc;
    SSTR    sstr = {0};

    sstr.lpName = (LPB) lszName;
    sstr.cb  = (BYTE) _tcslen (lszName);

    // Look for the name in the public symbols of that .EXE
    hsym = PHFindNameInPublics( NULL, (HEXE) emiAddr(addr), &sstr, 0, PHExactCmp);

    if (hsym) {
        SYMPTR psym = (SYMPTR) hsym;

        switch (psym->rectyp) {
            case S_PUB32:
                ADDRLIN32 (*pMpAddr);
                SetAddrSeg (pMpAddr, ((DATAPTR32)psym)->seg);
                SetAddrOff (pMpAddr, ((DATAPTR32)psym)->off);
                break;
        }

        ADDR_IS_LI (*pMpAddr) = TRUE;
        emiAddr (*pMpAddr) = emiAddr (addr);
        wRet = TRUE;
    }

    return wRet;
}

ULONG
GSTBSearch(
    UOFFSET uoffKey,
    LPALM   lpalm,
    ULONG   ibBase,
    ULONG   cb,
    UOFFSET *lpoff
    )
{
    ULONG ibLow;
    ULONG ibHigh;
    ULONG ibMid = 0;
    ULONG cbWidth = sizeof (ULP);
    ULONG uoffFound = 0;

    LPULP lpulp = NULL;

    ibLow  = 0;
    ibHigh = cb;

    while (ibLow < ibHigh) {

        ibMid = (ibLow + ibHigh) / 2;

        uoffFound =
             ((LPULP) (LpvFromAlmLfo (lpalm, ibBase + ibMid * cbWidth)))->ulId;

        if (uoffFound > uoffKey) {
            ibHigh = ibMid;
        }
        else if (uoffKey > uoffFound) {
            ibLow = ibMid + 1;
        }
        else {
            break;
        }
    }

    if (uoffFound > uoffKey && ibMid != 0) {
        ibMid -= 1;
    }

    lpulp = (LPULP) LpvFromAlmLfo (lpalm, ibBase + ibMid * cbWidth);

    *lpoff = lpulp->ulId;
    return lpulp->ib;

}

inline SYMPTR
FindNameLinearInGlobs(
    LPEXG  lpexg,
    SYMPTR psym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    if (lpexg->pgsiGlobs) {
        return GSIFindNameLinear(lpexg, lpexg->pgsiGlobs, psym, lpsstr, pfnCmp, fCase);
    } else {
        return GSTFindNameLinear(lpexg, &lpexg->gstGlobals, psym, lpsstr, pfnCmp, fCase);
    }
}

inline SYMPTR
FindNameLinearInPubs(
    LPEXG  lpexg,
    SYMPTR psym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    if (lpexg->pgsiPubs) {
        return GSIFindNameLinear(lpexg, lpexg->pgsiPubs, psym, lpsstr, pfnCmp, fCase);
    } else {
        return GSTFindNameLinear(lpexg, &lpexg->gstPublics, psym, lpsstr, pfnCmp, fCase);
    }
}

SYMPTR
GSTFindNameLinear(
    LPEXG  lpexg,
    LPGST  lpgst,
    SYMPTR psym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    if (lpgst->lpalm == NULL)
        return (SYMPTR)NULL;

    if (psym == NULL) {
        psym = (SYMPTR) LpvFromAlmLfo (lpgst->lpalm, 0);
    } else {
        psym = GetNextSym (psym, lpgst->lpalm);
    }

    while (psym != NULL) {
        // NOTE: Don't find referenced procs/data in linear search

        if (!FIsRefSym(psym->rectyp) &&
            GSTCmpName(psym, lpsstr, pfnCmp, fCase)) {
            break;
        }

        psym = GetNextSym (psym, lpgst->lpalm);
    }

    return psym;
}

SYMPTR
GSIFindNameLinear(
    LPEXG  lpexg,
    GSI*   pgsi,
    SYMPTR psym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    if (pgsi == NULL)
        return (SYMPTR)NULL;

    psym = (SYMPTR) pgsi->NextSym((PB) psym);

    while (psym != NULL) {
        // NOTE: Don't find referenced procs/data in linear search

        if (!FIsRefSym(psym->rectyp) &&
            GSTCmpName(psym, lpsstr, pfnCmp, fCase)) {
            break;
        }

        psym = (SYMPTR) pgsi->NextSym((PB) psym);
    }

    return psym;
}

inline SYMPTR
FindNameHashedInGlobs(
    LPEXG   lpexg,
    SYMPTR  psym,
    LPSSTR  lpsstr,
    PFNCMP  pfnCmp,
    SHFLAG  fCase,
    HMOD   *lphmod
    )
{
    if (lpexg->pgsiGlobs) {
        return GSIFindNameHashed (lpexg, lpexg->pgsiGlobs, psym, lpsstr, pfnCmp, fCase, lphmod);
    } else {
        return GSTFindNameHashed (lpexg, &lpexg->gstGlobals, psym, lpsstr, pfnCmp, fCase, lphmod);
    }
}

inline SYMPTR
FindNameHashedInStatics(
    LPEXG   lpexg,
    SYMPTR  psym,
    LPSSTR  lpsstr,
    PFNCMP  pfnCmp,
    SHFLAG  fCase,
    HMOD   *lphmod
   )
{
    if (lpexg->pgsiGlobs)
        // this assumes that the client has already completed an unsucessful search
        // thru the globals
       return (SYMPTR)NULL;
    else
       return GSTFindNameHashed(lpexg,
                                &lpexg->gstStatics,
                                psym,
                                lpsstr,
                                pfnCmp,
                                fCase,
                                lphmod
                               );
}

inline SYMPTR
FindNameHashedInPubs(
    LPEXG   lpexg,
    SYMPTR  psym,
    LPSSTR  lpsstr,
    PFNCMP  pfnCmp,
    SHFLAG  fCase,
    HMOD   *lphmod
    )
{
    if (lpexg->pgsiPubs) {
        return GSIFindNameHashed (lpexg, lpexg->pgsiPubs, psym, lpsstr, pfnCmp, fCase, lphmod);
    } else {
        return GSTFindNameHashed (lpexg, &lpexg->gstPublics, psym, lpsstr, pfnCmp, fCase, lphmod);
    }
}

SYMPTR
GSTFindNameHashed(
    LPEXG   lpexg,
    LPGST   lpgst,
    SYMPTR  psym,
    LPSSTR  lpsstr,
    PFNCMP  pfnCmp,
    SHFLAG  fCase,
    HMOD   *lphmod
    )
{
    LPSHT  lpsht   = &lpgst->shtName;

    if (lpsht->HashIndex == 0) {
        // No hash exists.  Punt to the linear code.
        return(GSTFindNameLinear(lpexg, lpgst, psym, lpsstr, pfnCmp, fCase));
    }

    ULONG  ulId    = 0;
    WORD   iib     = 0;
    SYMPTR psymRet = NULL;

    ULONG  ib      = 0;
    ULONG  culp    = 0;
    ULONG  iulp    = 0;

    BOOL   fNext   = psym != NULL;

    if ((lpsht->ccib == 0) ||(lpgst->lpalm == NULL))
        return (SYMPTR)NULL;

    iib  = HASHFUNC(lpsht->HashIndex, lpsstr, lpsht->ccib, &ulId);

    ib   = lpsht->rgib  [ iib ];
    culp = lpsht->rgcib [ iib ];

    // Loop through all the entries in this bucket

    for (iulp = 0; iulp < culp; iulp++) {

        LPULP lpulp = (LPULP) LpvFromAlmLfo (lpsht->lpalm,
                                    ib + (iulp * sizeof (ULP)));

        if (lpulp == NULL) {
            return NULL;
        }

        if (lpulp->ulId == ulId) {
            HMOD hmodT = hmodNull;

            // Checksums match, now check the symbols themselves

            SYMPTR psymT = (SYMPTR) LpvFromAlmLfo (lpgst->lpalm, lpulp->ib);

            if (psymT == NULL) {
                return NULL;
            }

            if (FIsRefSym(psymT->rectyp)) {
                psymT = PsymFromRef (lpexg, psymT, &hmodT);

                // catch case where there are no module symbols... [rm]

                if (psymT == NULL)
                    return NULL;
            }

            if (fNext) {

                // We need to get back to the Current hsym before get can
                // get just one more.  Soon as we are there we know we can
                // get the next one.

                if (psymT == psym) {
                    fNext = FALSE;
                }
                continue;
            }

            if (GSTCmpName (psymT, lpsstr, pfnCmp, fCase)) {
                if (lphmod) *lphmod = hmodT;
                psymRet = psymT;
                break;
            }
        }
    }

    return psymRet;
}

SYMPTR
GSIFindNameHashed(
    LPEXG   lpexg,
    GSI*    pgsi,
    SYMPTR  psym,
    LPSSTR  lpsstr,
    PFNCMP  pfnCmp,
    SHFLAG  fCase,
    HMOD   *lphmod
    )
{
    HMOD    hmodT = hmodNull;
    char    szBuf[256];
    SYMPTR  psymGS;
    SYMPTR psymRet;

    BOOL   fNext   = psym != NULL;

    if (!pgsi)
        return (SYMPTR)NULL;

    lpStrToSz(lpsstr, szBuf);
    psymGS = (SYMPTR) pgsi->HashSym(szBuf, (PB) psym);

    for (; psymGS; psymGS = (SYMPTR) pgsi->HashSym(szBuf, (PB) psymGS)) {
        if (FIsRefSym(psymGS->rectyp)) {
            psymRet = PsymFromRef (lpexg, psymGS, &hmodT);

            // catch case where there are no module symbols... [rm]
            if (psymRet == NULL)
                return NULL;
        } else
            psymRet = psymGS;

        if (fNext) {

            // We need to get back to the Current hsym before get can
            // get just one more.  Soon as we are there we know we can
            // get the next one.

            if (psymRet == psym) {
                fNext = FALSE;
            }
            continue;
        }

        if (GSTCmpName (psymRet, lpsstr, pfnCmp, fCase)) {
            if (lphmod) *lphmod = hmodT;
            return psymRet;
        }
    }

    return NULL;
}


inline SYMPTR
FindNearest(
    LPEXG lpexg,
    LPADDR lpaddr,
    LPL lpdb
    )
{
    SYMPTR  symptr;

    if (lpexg->pgsiPubs) {
#pragma message ("Need to search pgsiGlobals in FindNearest for NB10")
        return (SYMPTR) lpexg->pgsiPubs->NearestSym((USHORT) GetAddrSeg(*lpaddr),
                                                    GetAddrOff(*lpaddr),
                                                    lpdb);
    } else {

        SYMPTR  symptrT;
        LONG    db;

        // Search first in globals
        symptr = GSTFindNearest(lpexg, &lpexg->gstGlobals, lpaddr, lpdb);

        // Search in publics
        symptrT = GSTFindNearest(lpexg, &lpexg->gstPublics, lpaddr, &db);

        // If there's an entry in the publics AND there was either
        // no match in the globals or the delta for the public is
        // less than the delta for the global, use the public
        if (symptrT && (!symptr || labs(db) < labs (*lpdb))) {
            *lpdb = db;
            symptr = symptrT;
        }
    }

    return symptr;
}

SYMPTR
GSTFindNearest(
    LPEXG lpexg,
    LPGST lpgst,
    LPADDR lpaddr,
    LPL lpdb
    )
{
    SYMPTR psym;
    ULONG  db    = CV_MAXOFFSET;
    LPSHT  lpsht = &lpgst->shtAddr;
    WORD   iseg;
    ULONG  ibSym = 0;
    OFFSET off   = GetAddrOff (*lpaddr);

    if (lpgst->lpalm == NULL)
        return NULL;

    // See if there's a hash index.  If not, do a linear search.
    if (lpsht->HashIndex == 0) {
        SYMPTR  psymClosest = NULL, psymT, psymEnd;
        HMOD    hmodT;
        psym    = (SYMPTR) LpvFromAlmLfo(lpgst->lpalm, ibSym);
        psymEnd = (SYMPTR) ((LPB) psym + lpgst->lpalm->cb);
        iseg    = (WORD)GetAddrSeg (*lpaddr);

        for (; psym < psymEnd; psym = NEXTSYM(SYMPTR, psym)) {
            if (FIsRefSym(psym->rectyp)) {
                hmodT = hmodNull;

                psymT = PsymFromRef(lpexg, psym, &hmodT);

                if (psymT == NULL) {
                    psymT = psym;
                }
            } else {
                psymT = psym;
            }

            switch (psymT->rectyp) {
                case S_PUB32:
                    if ((iseg == ((DATAPTR32)psymT)->seg) &&
                        ((off - ((DATAPTR32)psymT)->off) >= 0) &&
                        (db > (off - ((DATAPTR32)psymT)->off))) {

                        // we are closer, so save this symbol and offset

                        db = (ULONG) (off - ((DATAPTR32)psymT)->off);
                        psymClosest = psymT;
                    }
                    break;
            }

            if (db == 0) {
                // Got an exact match.
                break;
            }
        }

        psym = psymClosest;

    } else {
        iseg = (WORD)GetAddrSeg (*lpaddr) - 1;
        if (iseg != 0xFFFF &&
            iseg < lpsht->ccib &&
            lpsht->rgcib [ iseg ] > 0)
        {
            UOFFSET offT = 0;

            ibSym = GSTBSearch (off,
                                lpsht->lpalm,
                                lpsht->rgib [ iseg ],
                                (WORD) lpsht->rgcib [ iseg ],
                                &offT);

            db = (off - offT);

            psym = (SYMPTR) LpvFromAlmLfo (lpgst->lpalm, ibSym);

            if (FIsRefSym(psym->rectyp)) {
                HMOD hmodT = hmodNull;

                psym = PsymFromRef(lpexg, psym, &hmodT);

                // Couldn't get the ref, set the db to what
                // would be returned in an error condition
                if (!psym) {
                    db = CV_MAXOFFSET;
                }
            }
        }
    }

    *lpdb = (LONG) db;
    return psym;
}

SYMPTR
PsymFromRef(
    LPEXG lpexg,
    SYMPTR psymRef,
    HMOD *lphmod
    )
{
    REFSYM  *lpref      = (REFSYM *) psymRef;
    LPB      lpbSymbols;
    LPMDS    lpmds;

    assert(lpref->imod <= lpexg->cMod);

    lpmds  = &lpexg->rgMod[lpref->imod];

    lpbSymbols = (LPB) GetSymbols (lpmds);

    if (lphmod) {
        *lphmod = (HMOD) lpmds;
    }

    // catch case where there are no module symbols...
    if (lpbSymbols == NULL)
        return NULL;

    return (SYMPTR) (lpbSymbols + lpref->ibSym);
}

BOOL
GSTCmpName(
    SYMPTR psym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    LSZ lsz = NULL;

    // We are basically ignoring publics with set == 0

    if ((psym->rectyp == S_PUB32 && ((DATAPTR32) psym)->seg == 0))
    {
        return FALSE;
    }

    lsz  = (LSZ) SHlszGetSymName (psym);

    if (lsz != NULL) {
        return (!(lpsstr->searchmask & SSTR_symboltype) ||
                 (psym->rectyp == lpsstr->symtype)) &&
                !(*pfnCmp) (lpsstr, psym, lsz, fCase);
    } else {
        return FALSE;
    }
}


//  SHFindNameInGlobal
//
//  Purpose:    To look for the name in the global symbol table.
//
//  Input:
//      hSym    - The starting symbol, if NULL, then the first symbol
//                  in the global symbol table is used. (NULL is find first).
//      pCXT    - The context to do the search.
//      lpsstr  - pointer to search parameters (passed to the compare routine)
//      fCaseSensitive - TRUE/FALSE on a case sensitive search
//      pfnCmp  - A pointer to the comparison routine
//      fChild  - TRUE if all child block are to be searched, FALSE if
//                  only the current block is to be searched.
//
//  Output:
//      pCXTOut - The context generated
//
//  Returns:
//      - A handle to the symbol found, NULL if not found
//
//  Notes:
//      If an hSym is specified, the hMod, hGrp and addr MUST be
//      valid and consistant with each other! If hSym is NULL only
//      the hMod must be valid.  The specification of an hSym
//      forces a search from the next symbol to the end of the
//      module scope.  Continues searches may only be done at
//      module scope.
//
//      If an hGrp is given it must be consistant with the hMod!

HSYM
SHFindNameInGlobal(
    HSYM   hsym,
    PCXT   pcxt,
    LPSSTR lpsstr,
    SHFLAG fCase,
    PFNCMP pfnCmp,
    PCXT   pcxtOut
    )
{
    HEXG    hexg;
    LPEXG   lpexg;
    HEXE    hexe;
    LPEXE   lpexe;
    HMOD    hmod   = hmodNull;
    SYMPTR  psym   = NULL;

    *pcxtOut = *pcxt;
    pcxtOut->hProc = NULL;
    pcxtOut->hBlk = NULL;

    if (!pcxt->hMod) {
        return NULL;
    }

    hexe    = SHHexeFromHmod(pcxt->hGrp ? pcxt->hGrp : pcxt->hMod);
    lpexe   = (LPEXE) LLLock(hexe);
    hexg    = lpexe->hexg;
    lpexg   = (LPEXG) LLLock (hexg);
    LLUnlock(hexe);

    // Make sure these symbols are loaded.
//    SHWantSymbols(hexe);

    if (lpsstr->searchmask & SSTR_NoHash) {
        psym = FindNameLinearInGlobs (lpexg, (SYMPTR) hsym, lpsstr, pfnCmp, fCase);
    } else {
        psym = FindNameHashedInGlobs (lpexg, (SYMPTR) hsym, lpsstr, pfnCmp, fCase, &hmod);

        if (hmod != hmodNull) {
            pcxtOut->hMod = pcxt->hGrp = hmod;

            switch (psym->rectyp) {

                case S_LPROC32:
                case S_GPROC32:
                case S_LPROCMIPS:
                case S_GPROCMIPS:
                    emiAddr (pcxtOut->addr) = (HEMI) SHHexeFromHmod (hmod);
                    SHAddrFromHsym (&pcxtOut->addr, psym);
                    SHHPROCFrompCXT(pcxtOut) = psym;
                    break;

                default: {
                    LPMDS lpmds = (LPMDS) hmod;

                    SetAddrFromMod(lpmds, &pcxtOut->addr);
                    emiAddr (pcxtOut->addr) = (HEMI) SHHexeFromHmod (hmod);
                    ADDR_IS_LI (pcxtOut->addr) = TRUE;
                    break;
                }
            }
        }
    }

    LLUnlock (hexg);
    return psym;
}



HSYM
FindNameInStatics(
    HSYM   hsym,
    PCXT   pcxt,
    LPSSTR lpsstr,
    SHFLAG fCase,
    PFNCMP pfnCmp,
    PCXT   pcxtOut
    )
{
    HEXG    hexg   = hexgNull;
    HMOD    hmod   = hmodNull;
    LPEXG   lpexg  = NULL;
    SYMPTR  psym   = NULL;

    *pcxtOut = *pcxt;
    pcxtOut->hProc = NULL;
    pcxtOut->hBlk = NULL;

    if (!pcxt->hGrp) {
        return NULL;
    }

    hexg = SHHexgFromHmod (pcxt->hGrp);
    lpexg  = (LPEXG) LLLock (hexg);

    psym = FindNameHashedInStatics(lpexg, (SYMPTR) hsym, lpsstr, pfnCmp, fCase, &hmod);

    if (hmod != hmodNull) {
        pcxtOut->hMod = pcxt->hGrp = hmod;

        switch (psym->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
            case S_LPROCMIPS:
            case S_GPROCMIPS:
                emiAddr (pcxtOut->addr) = (HEMI) SHHexeFromHmod (hmod);
                SHAddrFromHsym (&pcxtOut->addr, psym);
                SHHPROCFrompCXT(pcxtOut) = psym;
                break;

            default: {
                LPMDS lpmds = (LPMDS) hmod;

                SetAddrFromMod(lpmds, &pcxtOut->addr);
                emiAddr (pcxtOut->addr) = (HEMI) SHHexeFromHmod (hmod);
                ADDR_IS_LI (pcxtOut->addr) = TRUE;
                break;
            }
        }
    }

    LLUnlock (hexg);
    return psym;
}

//
// This routine needs to be threadsafe. Mutliple threads
// come in - random results out due to use of unprotected statics
//
// VS: 22689
//
// rajra
//
BOOL
VerifyHexe(
    HEXE hexe
    )
{
    HEXE hexeT = 0;
	BOOL   fRet;

	EnterCriticalSection (&csSh);

    static BOOL fFound = FALSE;
    static HEXE hexeSave = 0;

    if (hexe == hexeNull) {
		LeaveCriticalSection (&csSh);
        return FALSE;
    }

    if (hexe == hexeSave) {
		LeaveCriticalSection (&csSh);
		fRet = fFound;
        return fRet;
    }

    hexeSave = hexe;
    fFound = FALSE;

    while(!fFound && (hexeT = SHGetNextExe(hexeT))) {
        if (hexeT == hexe) {
            fFound = TRUE;
        }
    }

	fRet = fFound;
    LeaveCriticalSection (&csSh);
    return fRet;
}


//  SHFindNameInTypes
//
//  Purpose:    To look for the name in the UDT table.
//
//  Input:
//      pCXT    - The context to do the search.
//      lpsstr  - pointer to search parameters (passed to the compare routine)
//      fCaseSensitive - TRUE/FALSE on a case sensitive search
//      pfnCmp  - A pointer to the comparison routine
//
//  Output:
//      pCXTOut - The context generated
//
//  Returns:
//      - A handle to the type found, NULL if not found
//
//  Notes:
//      The hMod in the context must be valid.

HSYM
SHFindNameInTypes(
    PCXT pcxt,
    LPSSTR lpsstr,
    SHFLAG fCase,
    PFNCMP pfnCmp,
    PCXT pcxtOut
    )
{
    HEXG    hexg   = hexgNull;
    LPEXG   lpexg  = NULL;
    UDTPTR  psym   = NULL;
    char    szBuf[256];
    unsigned iHash;
    TI ti;

    *pcxtOut = *pcxt;
    pcxtOut->hProc = NULL;
    pcxtOut->hBlk = NULL;

    if (!pcxt->hMod || ( lpsstr->searchmask & SSTR_NoHash ))
         return NULL;

    hexg = SHHexgFromHmod ( pcxt->hMod );

    lpexg  = (LPEXG)LLLock ( hexg );
    if (!lpexg->ptpi) {
        LLUnlock ( hexg );
        return NULL;
    }

    if (!STABFindUDTSym(lpexg->pstabUDTSym, lpsstr, pfnCmp, fCase, &psym, &iHash)) {
        TPI* ptpi = 0;
        if ( ((LPMDS)pcxt->hMod)->pmod ) {    /* use the mod's type server */
            ((LPMDS) pcxt->hMod)->pmod->QueryTpi(&ptpi);
        }
        if ( ptpi == 0 ) ptpi = lpexg->ptpi;
        lpStrToSz(lpsstr, szBuf);
        assert(ptpi);
        if (!ptpi->QueryTiForUDT(szBuf, fCase, &ti) ||
            !STABAddUDTSym(lpexg->pstabUDTSym, lpsstr, iHash, &psym)) {
            LLUnlock ( hexg );
            return NULL;
        }
        assert(psym);
        psym->typind = ti;
    }

    LLUnlock ( hexg );
    return (SYMPTR) psym;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\loadomf.cpp ===
// loadomf.cxx - load
//
//  Copyright <C> 1989-94, Microsoft Corporation
//
//  Purpose:
//
//  10-Nov-94   BryanT
//      Merge in NT changes.
//      Change the load code so we first call the Shell to see
//      if the symbol load s/b deferred or ignored.
//      Functions changed: OLStart, OLLoadOmf
//      New Functions: OLContinue (the part of OLStart that determines)
//                          what type of file we're looking at).
//                     LoadOmfForReal (the part of OLLoadOmf that actually
//                          performs the symbol load)
//      Replace all the hexg param's with lpexg's.  We have it everywhere
//      it's needed and every function calls LLLock/LLUnlock to get it...
//      Define UnloadOmf.
//
//  07-Jan-96   BryanT
//

#include "shinc.hpp"
#pragma hdrstop

#include <imagehlp.h>

// The exe file information

static LSZ          lszFName;           // file name
static LONG         lfaBase;            // offset of directory info from end of file
static ULONG        cDir;               // number of directory entries
static OMFDirEntry *lpdss;              // pointer to directory table
static OMFDirEntry *lpdssCur;           // pointer to current directory entry
static LONG         lcbFilePos;
static WORD         csegExe;
static PIMAGE_SECTION_HEADER  SecHdr;
static unsigned int SecCount;
static WORD         btAlign;            // Alignment bit
static DWORD        fLoadExports;		// load Exports as debug info

typedef struct _PDB_INFO {
    SIG sig;
    AGE age;
    char sz[_MAX_PATH];
} PDB_INFO;

static  PDB_INFO pdbInfo;

const ULONG sigNB11 = '11BN';
const ULONG sigNB10 = '01BN';
const ULONG sigNB09 = '90BN';
const ULONG sigNB08 = '80BN';
const ULONG sigNB07 = '70BN';
const ULONG sigNB06 = '60BN';
const ULONG sigNB05 = '50BN';

// compile time assert
#if !defined(cassert)
#define cassert(x) extern char dummyAssert[ (x) ]
#endif


SHE  CheckSignature (INT , OMFSignature *, PDB_INFO *);
SHE  OLStart (LPEXG);
BOOL OLMkSegDir (WORD, LPSGD *, LPSGE *, LPEXG);
SHE  OLLoadTypes (LPEXG);
SHE  OLLoadSym (LPEXG);
SHE  OLLoadSrc (LPEXG);
SHE  OLGlobalPubs (LPEXG);
SHE  OLGlobalSym (LPEXG);
SHE  OLStaticSym (LPEXG);
SHE  OLLoadSegMap (LPEXG);
SHE  OLLoadNameIndex (LPEXG);
LPCH OLRwrSrcMod (OMFSourceModule *);
BOOL OLLoadHashSubSec (LPGST, LPB, WidenTi * =0);
SHE  NB10LoadOmf (LPEXG, HEXG);
SHE  LoadPdb (LPEXG, PDB_INFO *);
SHE  NB10LoadModules (LPEXG, ULONG*, HEXG);
VOID LoadSymbols(HPDS, HEXG, BOOL);
SHE  LoadOmfForReal(LPEXG, HEXG);
SHE  LoadFpo(LPEXG, int, PIMAGE_DEBUG_DIRECTORY);
SHE  LoadPdata(LPEXG, int, ULONG, ULONG, ULONG, ULONG, BOOL);
SHE  LoadOmap(LPEXG, int, PIMAGE_DEBUG_DIRECTORY);
int  OLMkModule(LPEXG, HEXG);
SHE  OLValidate(int, void *, LPSTR);
void QueryRegistry();

SHE  SheFixupConvertedSyms(LPEXG);
void ConvertGlobal16bitSyms(WidenTi*, LPGST, PB, ULONG);
SHE  LoadDebugDataFromPdb(LPEXG lpexg, PDB_INFO *ppdb);

#define MAX_SEARCH_PATH_LEN   512
#define SHECONV(s)  (((s)==sheExportsConverted)?2:TRUE)

static TCHAR szSearchPath[MAX_SEARCH_PATH_LEN];
BOOL  fQueriedRegistry = FALSE;
PFNPDBOpenValidateEx pAltPDBOpen = 0;

// CFile is a simple helper class which will force its file to be closed
// as soon as the CFile object is destructed.

class CFile {
    public:
        INT m_hfile;

        CFile() { m_hfile = -1; }
        void ReInit() {
            if (m_hfile != -1) {
                SYClose(m_hfile);
                m_hfile = -1;
            }
        }
        INT Open(LSZ lszName) {
            m_hfile = SYOpen(lszName);
            return(m_hfile);
        }

        ~CFile() {
            if(m_hfile != -1) {
                SYClose (m_hfile);
                m_hfile = -1;
            }
        }

        operator INT&() { return m_hfile; }
};

VOID
LoadDefered(
    HEXG  hexg
    )
{
    LoadSymbols(hpdsCur, hexg, TRUE);
    return;
}

VOID
UnloadDefered(
    HEXG hexg
    )
{
    return;
}

inline BOOL
fSheGoodReturn(SHE she)
{
    return she == sheNone || she == sheSymbolsConverted || she == sheConvertTIs || she == sheExportsConverted;
}

//  OLLoadOmf - load omf information from exe
//
//  error = OLLoadOmf (hexg)
//
//  Entry   hexg = handle to executable information struct
//
//  Exit
//
//  Returns An error code suitable for errno.

SHE
OLLoadOmf(
    HEXG    hexg,
    VLDCHK *pVldChk,
    DWORD   dllLoadAddress
    )
{
    SHE     sheRet = sheNone;
    LSZ     lszFname = NULL;
    LPEXG   lpexg = (LPEXG) LLLock (hexg);

    if (lpexg->fOmfLoaded) {
        return sheNone;
    }

    // Query the shell and see if we should load this one now.

    lszFname = lpexg->lszName;

#if 0

        //      SYGetDefaultShe () always returns TRUE and leavs the parameters
        //      unchanged; so this bit of code is dead.

    if (!SYGetDefaultShe(lszFname, &sheRet)) {
        if (lpexg->lszAltName) {
            lszFname = lpexg->lszAltName;
            if (!SYGetDefaultShe(lszFname, &sheRet)) {
                SYGetDefaultShe(NULL, &sheRet);
                lszFname = lpexg->lszName;
            }
        } else {
            SYGetDefaultShe(NULL, &sheRet);
        }
    }

    // SYGetDefaultShe is expected to return one of the following
    // values:
    //
    // sheSuppressSyms - Don't load, just keep track of the name/start
    // sheNoSymbols - This module has already been processed and there are no symbols
    // sheDeferSyms - Defer symbol loading until needed
    // sheSymbolsConverted - The symbols are already loaded
    // sheNone - Go ahead and load the symbols now.

#endif

    // Regardless of the load type, save some stuff

    lpexg->LoadAddress  = dllLoadAddress;
    lpexg->ulTimeStamp = pVldChk->TimeDateStamp;

    lpexg->debugData.she = sheRet;

    // If we made it this far, we must load the symbols

    LoadSymbols(hpdsCur, hexg, FALSE);

    if (lpexg->fOmfMissing)
        sheRet = sheNoSymbols;
    else if (lpexg->fOmfSkipped)
        sheRet = sheSuppressSyms;
    else if (lpexg->fOmfDefered)
        sheRet = sheDeferSyms;
    else if (lpexg->fSymConverted==2)
        sheRet = sheExportsConverted;
    else if (lpexg->fSymConverted)
        sheRet = sheSymbolsConverted;

    lpexg->debugData.she = sheRet;

    LLUnlock(hexg);

    return(sheRet);
}


//  LoadSymbols
//
//  Purpose: This function loads a defered module's symbols.  After
//      the symbols are loaded the shell is notified of the completed
//      module load.
//
//  Input:  hpds - Handle to process to load the symbols for
//          hexg - exg handle for the module to be added
//          fNotifyShell - Should shell be notified on load.
//
//  Return: None

VOID
LoadSymbols(
    HPDS hpds,
    HEXG hexg,
    BOOL fNotifyShell
    )
{
    SHE     sheRet;
    HEXE    hexe;
    LPEXG   lpexg = NULL;
    LPPDS   lppds = NULL;
    LPEXE   lpexe = NULL;
    LPSTR   lpname = NULL;
    HPDS    hpdsLast;

//    EnterCriticalSection( &CsSymbolLoad );

    //  find the exe for this exg

    hexe = NULL;
    while ((hexe=SHGetNextExe(hexe))) {
        lpexe = (LPEXE) LLLock(hexe);
        if ((hexg == lpexe->hexg) &&
            (hpds == lpexe->hpds))
        {
                break;
        } else {
            LLUnlock(hexe);
        }
    }

    if (!hexe) {
        goto done;              // didn't find a hexg/hpds match
    }

    //  lock down the necessary data structures

    lpexg = (LPEXG) LLLock(hexg);
    if (!lpexg) {
        goto done;
    }

    lppds = (LPPDS) LLLock(lpexe->hpds);
    if (!lppds) {
        goto done;
    }

    //  mark the module as being loaded
    lpexg->fOmfLoading = TRUE;

//    LeaveCriticalSection( &CsSymbolLoad );

    //  load the symbols (yes, pass both lpexg and hexg.
    //          OlMkModule needs hexg for creating the lpmds)

    sheRet = LoadOmfForReal(lpexg, hexg);

//    EnterCriticalSection( &CsSymbolLoad );

    switch (sheRet) {
        case sheNoSymbols:
            lpexg->fOmfMissing = TRUE;
            break;

        case sheSuppressSyms:
            lpexg->fOmfSkipped = TRUE;
            break;

        case sheNone:
        case sheSymbolsConverted:
        case sheExportsConverted:
            lpexg->fOmfLoaded   = TRUE;
            break;

        default:
            lpexg->fOmfMissing = TRUE;
            break;
    }

    if (fNotifyShell) {
        //
        // notify the shell that symbols have been loaded
        //
        if (lpexg->lszAltName) {
            lpname = lpexg->lszAltName;
        } else {
            lpname = lpexg->lszName;
        }
//        hpdsLast = SHChangeProcess(hpds, TRUE);
        hpdsLast = SHChangeProcess(hpds);
        DLoadedSymbols(sheRet, lppds->hpid, lpname);
//        SHChangeProcess(hpdsLast, FALSE);
        SHChangeProcess(hpdsLast);
    }

    // update the module flags

    lpexg->fOmfDefered = FALSE;
    lpexg->fOmfLoading = FALSE;

done:

//    LeaveCriticalSection( &CsSymbolLoad );

    // free resources

    if (lpexe) {
        if (lppds) {
            LLUnlock(lpexe->hpds);
        }
        LLUnlock(hexe);
    }

    if (lpexg) {
        LLUnlock(hexg);
    }

    return;
}

//  LoadOmfForReal
//
//  Purpose: Here's where the symbolic is actually loaded from the image.
//
//  Input:  lpexg - The pointer to the exg structure
//          hexg  - The handle of the exg structure
//
//  Return: Standard she error codes.

SHE
LoadOmfForReal(
    LPEXG  lpexg,
    HEXG   hexg
    )
{
    SHE     sheRet = sheNone;
    SHE     sheRetSymbols = sheNone;
    WORD    cbMod = 0;
    ULONG   cMod;
    ULONG   iDir;

    csegExe = 0;

    __try {

        // Open and verify the exe.

        sheRet = sheRetSymbols = OLStart(lpexg);

        // If there was an error, bail.
        //  (sheNone doesn't mean "no symbols", it means "error None")

        if (!fSheGoodReturn(sheRet)) {
            goto returnhere;
        }

        if (lpexg->ppdb) {
            sheRet = NB10LoadOmf(lpexg, hexg);
            goto returnhere;
        }

        if (sheRet == sheConvertTIs) {
            // set up to do the conversions
            if (!WidenTi::fCreate(lpexg->pwti)) {
                sheRet = sheOutOfMemory;
                goto returnhere;
            }
        }

        btAlign = (WORD)(lfaBase & 1);

        lpdssCur = lpdss;
        iDir = 0;

        // Load up the module table.

        // First, count up how many sstModule entries we have.  The spec
        // requires all the sstModules to be before any other.

        while (iDir < cDir && lpdssCur->SubSection == sstModule) {
            lpdssCur++;
            iDir++;
        }

        // If there's no modules, there's no sense continuing.
        if (iDir == 0) {
            sheRet = sheNoSymbols;
            goto returnhere;
        }

        lpexg->cMod = cMod = iDir;

        // Allocate the rgMod buffer and load each dir entry in.

        lpexg->rgMod = (LPMDS)MHAlloc((cMod+2) * sizeof(MDS));
        if (lpexg->rgMod == NULL) {
            sheRet = sheOutOfMemory;
            goto returnhere;
        }
        memset(lpexg->rgMod, 0, sizeof(MDS)*(cMod+2));
        lpexg->rgMod[cMod+1].imds = (WORD) -1;

        // Go through the list of directory entries and process all of the sstModule records.

        for (iDir = 0, lpdssCur = lpdss;
             iDir < cMod;
             iDir += 1, lpdssCur++) {

            if (!OLMkModule (lpexg, hexg)) {
                sheRet = sheOutOfMemory;
                goto returnhere;
            }
        }

        // Set up map of modules.  This function is used to create a map
        // of contributer segments to modules.  This is then used when
        // determining which module is used for an address.
        lpexg->csgd = csegExe;
        if (!OLMkSegDir (csegExe, &lpexg->lpsgd, &lpexg->lpsge, lpexg)) {
            sheRet = sheOutOfMemory;
            goto returnhere;
        }

        // continue through the directory entries

        for (; iDir < cDir; lpdssCur++, iDir++) {
            if (lpdssCur->cb == 0) {
                // if nothing in this entry
                continue;
            }

            switch (lpdssCur->SubSection) {
                case sstSrcModule:
                    sheRet = OLLoadSrc(lpexg);
                    break;

                case sstAlignSym:
                    sheRet = OLLoadSym(lpexg);
                    break;

                case sstGlobalTypes:
                    sheRet = OLLoadTypes(lpexg);
                    break;

                case sstGlobalPub:
                    sheRet = OLGlobalPubs(lpexg);
                    break;

                case sstGlobalSym:
                    sheRet = OLGlobalSym(lpexg);
                    break;

                case sstSegMap:
                    sheRet = OLLoadSegMap(lpexg);
                    break;

                case sstLibraries:          // ignore this table
                case sstMPC:                // until this table is implemented
                case sstSegName:            // until this table is implemented
                case sstModule:             // Handled elsewhere
                    break;

                case sstFileIndex:
                    sheRet = OLLoadNameIndex(lpexg);
                    break;

                case sstStaticSym:
                    sheRet = OLStaticSym(lpexg);
                    break;

                default:
                    sheRet = sheCorruptOmf;
                    break;
            }

            if (sheRet == sheCorruptOmf) {
                sheRet = sheNoSymbols;
            }
        }
        if (lpexg->pwti) {
            sheRet = SheFixupConvertedSyms(lpexg);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        sheRet = sheNoSymbols;
    }

returnhere:

    if (SecHdr) {
        MHFree(SecHdr);
        SecHdr = NULL;
        SecCount = 0;
    }

    return sheRet;
}

SHE
NB10LoadOmf(
    LPEXG   lpexg,
    HEXG    hexg
    )
{
    SHE     sheRet = sheNone;
    WORD    cbMod = 0;
    ULONG   ModCnt = 0;

    btAlign = (WORD)(lfaBase & 1);

    // we need to allocate a buffer large enough to read the largest module
    // table entry

    if ((sheRet = NB10LoadModules (lpexg, &ModCnt, hexg)) != sheNone) {
        return sheRet;
    }

    if (ModCnt == 0L) {
        // if no symbols found
        return sheNoSymbols;
    }

    lpexg->cMod = ModCnt;

    if(!DBIOpenGlobals(lpexg->pdbi, &(lpexg->pgsiGlobs)) ||
       !DBIOpenPublics(lpexg->pdbi, &(lpexg->pgsiPubs)))
    {
        return sheOutOfMemory;
    }

    if((sheRet = OLLoadSegMap(lpexg)) != sheNone ||
       (sheRet = OLLoadNameIndex(lpexg)) != sheNone)
    {
        return sheRet;
    }

    return sheRet;
}

#define cbFileMax   (_MAX_CVFNAME + _MAX_CVEXT)

class NoCriticalErrors
{
public:
	NoCriticalErrors()
	{
		m_nOldMode = ::SetErrorMode( SEM_FAILCRITICALERRORS );
	}
	~NoCriticalErrors()
	{
		::SetErrorMode( m_nOldMode );
	}
private:
	UINT m_nOldMode;
};

// OLStart - get exe debug information
//
//  Purpose: To open the file specified and get the offset to the directory
//           and get the base that everyone is offset from.
//
//  Entry   hexg = handle to exe to get info for
//
//  Exit    lfaBase = base offset of debug information
//          cDir = count of number of directory entries
//          lpdss = directory entries
//
//  Returns file open status

#define UNKNOWN_IMAGE   0
#define DOS_IMAGE       1
#define VCDBG_IMAGE     2
#define WIN16_IMAGE     3
#define PE_IMAGE        4
#define ROM_IMAGE       5
#define NTDBG_IMAGE     6

SHE
OLStart(
    LPEXG   lpexg
    )
{
    SHE                     sheRet;
    ULONG                   DirSize;
    OMFSignature            Signature;
    OMFDirHeader            DirHeader;
    IMAGE_DOS_HEADER        doshdr;            // Old format MZ header
    IMAGE_NT_HEADERS        pehdr;
    IMAGE_ROM_HEADERS       romhdr;
    IMAGE_SEPARATE_DEBUG_HEADER  sepHdr;
    PIMAGE_FILE_HEADER      pfile;
    IMAGE_DEBUG_DIRECTORY   dbgDir;
    IMAGE_DEBUG_DIRECTORY   cvDbgDir;
    DWORD                   cbData;
    DWORD                   dllLoadAddress;
    DWORD                   ul;
    VLDCHK                  vldChk;
    LSZ                     szFName = NULL;
    char                    szNewName[_MAX_PATH];
    int                     ImageType = UNKNOWN_IMAGE;
    DWORD                   cDebugDir;
    DWORD                   offDbgDir;
    DWORD                   cObjs;
    CFile                   hfile;
    enum
    {
        stateStart,
        stateTryingDBG,
        stateTryingExport,
    } stateLoad;

	// disable critical errors (e.g. for drive E: on msvcrt) VS98:38390
	NoCriticalErrors SeeAbove;

    QueryRegistry();

    stateLoad = stateStart;

    if (lpexg->lszAltName) {
        szFName = lpexg->lszAltName;
    } else {
        szFName = lpexg->lszName;
    }

    // lpexg->lszDebug is the file where we pull the symbolic from.

    dllLoadAddress          = lpexg->LoadAddress;
    vldChk.TimeDateStamp    = lpexg->ulTimeStamp;
	lpexg->ulImageAlign     = 0;

    hfile.Open(szFName);

    // zero some globals, to make it easier to catch when we forget to set them (!)
    lpdss = NULL;
    cDir = 0;
    lfaBase = 0;

    if (hfile == -1) {
retry:
        if (lpexg->lszDebug) {
            MHFree(lpexg->lszDebug);
            lpexg->lszDebug = 0;
        }
        if (stateLoad==stateTryingExport)
        {
            // tried DBG, now try exports
            _tcscpy( szNewName, szFName );
            hfile.Open(szNewName);
        }
        else
        {
            hfile = SYFindExeFile(szFName, szNewName, sizeof(szNewName), &vldChk, (PFNVALIDATEEXE)OLValidate);
            stateLoad = stateTryingDBG;
        }
        if (hfile == -1) {
            if (stateLoad==stateTryingDBG)
            {
                // try exports next if set
                if (fLoadExports)
                {
                    stateLoad = stateTryingExport;
                    goto retry;
                }
            }
            sheRet = sheFileOpen;
            goto ReturnHere;
        }

        if ( ! ( lpexg->lszDebug = (LSZ) MHAlloc ( _ftcslen ( szNewName ) + 1 ) ) ) {
            sheRet = sheOutOfMemory;
            goto ReturnHere;
        }
        _tcscpy ( lpexg->lszDebug, szNewName );

    } else {
        // Assert that the input file is OK.  We only get here
        // when using the file name as passed in from the DM.

        sheRet = OLValidate(hfile, &vldChk, NULL);
        if ((sheRet == sheBadChecksum) ||
            (sheRet == sheBadTimeStamp))
        {
            hfile.ReInit();
            goto retry;
        }
        if ( (sheRet == sheNoSymbols) && (stateLoad!=stateTryingExport) )
        {
            hfile.ReInit();
            goto retry;
        }

        if ( ! ( lpexg->lszDebug = (LSZ) MHAlloc ( _ftcslen ( szFName ) + 1 ) ) ) {
            sheRet = sheOutOfMemory;
            goto ReturnHere;
        }
        _tcscpy ( lpexg->lszDebug, szFName );

    }

    // HACK: If we are pre-loading symbols lpexg->ulTimeStamp will be 0
    // at this point. However vldChk will be updated to have the appropriate
    // information. Update the lpexg structures with the right value.

    if (lpexg->ulTimeStamp == 0) {
        lpexg->ulTimeStamp = vldChk.TimeDateStamp;
    }

    // Now figure out what we're looking at.  Here are the possible formats:
    // 1. Image starts with a DOS MZ header and e_lfanew is zero
    //     - Standard DOS exe.
    // 2. Image starts with a DOS NE header and e_lfanew is non-zero
    //     - If e_lfanew points to a PE header, this is a PE image
    //     - Otherwise, it's probably a Win16 image.
    // 3. Image starts with a PE header.
    //     - Image is a PE image built with -stub:none
    // 4. Image starts with a ROM PE header.
    //     - Image is a ROM image.  If characteristics flag
    //          doesn't have IMAGE_FILE_DEBUG_STRIPPED set, the debug
    //          directory is at the start of rdata.
    // 5. Image starts with a DBG file header
    //     - Image is an NT DBG file (symbols only).
    // 6. None of the signatures match.
    //     - This may be a Languages DBG file.  Seek to the end
    //       of the file and attempt to read the CV signature/offset
    //       from there (a Languages DBG file is made by chopping an
    //       image at the start of the debug data and writing the end
    //       in a new file.  In the CV format, the signature/offset at the
    //       end of the file points back to the beginning of the data).

    if ((SYSeek(hfile, 0, SEEK_SET) == 0) &&
        sizeof(doshdr) == SYReadFar (hfile, (LPB) &doshdr, sizeof(doshdr)))
    {
        switch (doshdr.e_magic) {
            case IMAGE_DOS_SIGNATURE:
                //  This is a DOS NE header.
                if (doshdr.e_lfanew == 0) {
                    ImageType = DOS_IMAGE;
                } else {
                    if ((SYSeek(hfile, doshdr.e_lfanew, SEEK_SET) == doshdr.e_lfanew) &&
                        (SYReadFar(hfile, (LPB) &pehdr, sizeof(pehdr)) == sizeof(pehdr)))
                    {
                        if (pehdr.Signature == IMAGE_NT_SIGNATURE) {
                            ImageType = PE_IMAGE;
                            lpexg->ulImageAlign = pehdr.OptionalHeader.SectionAlignment;
                            pfile = &pehdr.FileHeader;

                            //
                            // Correct for different sized OptionalHeader in PEs.
                            //

                            if (sizeof (pehdr.OptionalHeader) != pehdr.FileHeader.SizeOfOptionalHeader) {

                                if (!SYSeek (hfile, pehdr.FileHeader.SizeOfOptionalHeader - sizeof (pehdr.OptionalHeader), SEEK_CUR)) {

                                    sheRet = sheCorruptOmf;
                                    goto ReturnHere;
                                }
                            }

                        } else {
                            ImageType = WIN16_IMAGE;
                        }
                    } else {
                        // No luck reading from the image.  Must be corrupt.
                        sheRet = sheCorruptOmf;
                        goto ReturnHere;
                    }
                }
                break;

            case IMAGE_SEPARATE_DEBUG_SIGNATURE:
                // This image is an NT DBG file.
                ImageType = NTDBG_IMAGE;
                if ((SYSeek(hfile, 0, SEEK_SET) != 0) ||
                    (SYReadFar(hfile, (LPB) &sepHdr, sizeof(sepHdr)) != sizeof(sepHdr)))
                {
                    // No luck reading from the image.  Must be corrupt.
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }

                // If there's no debug info, we can't continue further.

                if (sepHdr.DebugDirectorySize / sizeof(dbgDir) == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                break;

            default:
                // None of the above.  See if it's a ROM image.
                // Note: The only way we think we're working on a ROM image
                // is if the optional header size is correct.  Not really foolproof.

                if ((SYSeek(hfile, 0, SEEK_SET) == 0) &&
                    (SYReadFar(hfile, (LPB) &romhdr, sizeof(romhdr)) == sizeof(romhdr)))
                {
                    if (romhdr.FileHeader.SizeOfOptionalHeader == IMAGE_SIZEOF_ROM_OPTIONAL_HEADER) {
                        // If we think we have a ROM image, make sure there's
                        // symbolic to look for.
                        if (romhdr.FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
                            sheRet = sheNoSymbols;
                            goto ReturnHere;
                        } else {
                            ImageType = ROM_IMAGE;
                            pfile = &romhdr.FileHeader;
                        }
                    } else {
                        ImageType = VCDBG_IMAGE;
                    }
                } else {
                    // No luck reading from the image.  Must be corrupt.
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }
                break;
        }

    } else {
        // No luck reading from the image.  Must be corrupt.
        sheRet = sheCorruptOmf;
        goto ReturnHere;
    }

    // Now, we know what kind of image we're looking at.
    // Either obtain the pointer to the CV debug data (and other
    // relevant data along the way) or convert whatever we do find
    // to CV debug data.

    lpexg->fSymConverted = FALSE;

    switch (ImageType) {
        case DOS_IMAGE:
        case VCDBG_IMAGE:
        case WIN16_IMAGE:
            // Easy.  Skip to the end and look back.
            ul = SYSeek (hfile, -((LONG)sizeof (OMFSignature)), SEEK_END);
            if ((sheRet = CheckSignature (hfile, &Signature, &pdbInfo)) == sheNone) {
                // seek to the base and read in the new key

                lfaBase = SYSeek (hfile, -Signature.filepos, SEEK_END);
                sheRet = CheckSignature(hfile, &Signature, &pdbInfo);
                cbData = ul - lfaBase;
            }
            // If the CV signature is invalid, see if we can convert what we do
            // have (perhaps a .sym file?)

            if (sheRet != sheNone) {
                if (fLoadExports) {
                    lpexg->lpbData = (LPB) (pfConvertSymbolsForImage)(
                                             (HANDLE)(int)hfile, lpexg->lszDebug, &sheRet);
                }
                // If no symbols converted, bail.  Nothing more we can do.
                if (lpexg->lpbData == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                Signature = *(OMFSignature*)lpexg->lpbData;
                lpexg->fSymConverted = SHECONV(sheRet);
            }
            break;

        case PE_IMAGE:
        case ROM_IMAGE:
            // In both the PE image and ROM image, we're past the FILE
            // and OPTIONAL header by now.  Walk through the section
            // headers and pick up interesting data.  We make a
            // a copy of the section headers in case we need to
            // reconstruct the original values for a Lego'd image

            cObjs = pfile->NumberOfSections;
            SecCount = pfile->NumberOfSections;

            ul = SecCount * sizeof(IMAGE_SECTION_HEADER);

            // Note: SecHdr is free'd by LoadOmfForReal.
            SecHdr = (PIMAGE_SECTION_HEADER) MHAlloc(ul);

            if (!SecHdr) {
                sheRet = sheNoSymbols;
                goto ReturnHere;
            }

            if (SYReadFar(hfile, (LPB) SecHdr, ul) != ul) {
                sheRet = sheNoSymbols;
                goto ReturnHere;
            }


            if (ImageType == PE_IMAGE) {
                // look for the .pdata section on RISC platforms
                if ((pfile->Machine == IMAGE_FILE_MACHINE_ALPHA) ||
                    (pfile->Machine == IMAGE_FILE_MACHINE_R4000) ||
                    (pfile->Machine == IMAGE_FILE_MACHINE_R10000) ||
                    (pfile->Machine == IMAGE_FILE_MACHINE_POWERPC))
                {

                    for (ul=0; ul < cObjs; ul++) {
                        if (_tcscmp((char *) SecHdr[ul].Name, ".pdata") == 0) {
                            LoadPdata(lpexg,
                                      hfile,
                                      dllLoadAddress,
                                      pehdr.OptionalHeader.ImageBase,
                                      SecHdr[ul].PointerToRawData,
                                      SecHdr[ul].SizeOfRawData,
                                      FALSE);
                            break;
                        }
                    }
                }

                // If the debug info has been stripped, close this handle
                // and look for the .dbg file...

                if (pfile->Characteristics & IMAGE_FILE_DEBUG_STRIPPED){
                    // The debug info has been stripped from this image.
                    // Close this file handle and look for the .DBG file.
                    if (stateLoad!=stateTryingExport)
                    {
                        hfile.ReInit();
                        ImageType = UNKNOWN_IMAGE;
                        MHFree(SecHdr);
                        SecHdr = 0;
                        goto retry;
                    }
                    else
                    {
                        // let vcsymcvt find any exports for us
                        if (fLoadExports) {
                            lpexg->lpbData = (LPB)(pfConvertSymbolsForImage)( (HANDLE)(int)hfile, lpexg->lszDebug, &sheRet);
                        }
                        if (lpexg->lpbData == 0) {
                            sheRet = sheNoSymbols;
                            goto ReturnHere;
                        }
                        Signature = *(OMFSignature*)lpexg->lpbData;
                        lpexg->fSymConverted = SHECONV(sheRet);
                        break;
                    }
                }

                // Find the debug directory and the number of entries in it.

                // For PE images, walk the section headers looking for the
                // one that's got the debug directory.
                for (ul=0; ul < cObjs; ul++) {
                    if ((SecHdr[ul].VirtualAddress <=
                         pehdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress) &&
                        (pehdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress <
                         SecHdr[ul].VirtualAddress + SecHdr[ul].SizeOfRawData)) {

                        // This calculation really isn't necessary nor is the range test
                        // above.  Like ROM images, it s/b at the beginning of .rdata.  The
                        // only time it won't be is when a pre NT 1.0 image is split sym'd
                        // creating a new MISC debug entry and relocating the directory
                        // to the DEBUG section...

                        offDbgDir = SecHdr[ul].PointerToRawData +
                            pehdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress -
                            SecHdr[ul].VirtualAddress;
                        cDebugDir = pehdr.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size /
                                 sizeof(IMAGE_DEBUG_DIRECTORY);
                        break;
                    }
                }
            } else {
                // For ROM images, there's much less work to do.  We only
                // need to search for the .rdata section.  There's no need
                // to look for .pdata (it will never exist) or worry about
                // stripped debug symbolic (that case was already handled above).
                for (ul=0; ul < cObjs; ul++) {
                    if (!_tcscmp((char *)SecHdr[ul].Name, ".rdata")) {
                        offDbgDir = SecHdr[ul].PointerToRawData;
                        if (SYSeek(hfile, offDbgDir, SEEK_SET) != (LONG) offDbgDir) {
                            sheRet = sheCorruptOmf;
                            goto ReturnHere;
                        }

                        // The linker stores an empty directory entry for ROM
                        // images to terminate the list.

                        cDebugDir = 0;
                        do {
                            if (SYReadFar(hfile, (LPB) &dbgDir, sizeof(dbgDir)) != sizeof(dbgDir)) {
                                sheRet = sheNoSymbols;
                                goto ReturnHere;
                            }
                            cDebugDir++;
                        } while (dbgDir.Type != 0);

                        break;
                    }
                }
            }

            // Assuming we haven't exhausted the list of section headers,
            // we should have the debug directory now.
            if (ul == cObjs) {
                // We didn't find any CV info.  Try converting what we did
                // find.
                if (fLoadExports) {
                    lpexg->lpbData = (LPB)(pfConvertSymbolsForImage)( (HANDLE)(int)hfile, lpexg->lszDebug, &sheRet);
                }
                if (lpexg->lpbData == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                Signature = *(OMFSignature*)lpexg->lpbData;
                lpexg->fSymConverted = SHECONV(sheRet);
                break;
            }

            // Now search the debug directory for relevant entries.

            if (SYSeek(hfile, offDbgDir, SEEK_SET) != (LONG) offDbgDir) {
                sheRet = sheCorruptOmf;
                goto ReturnHere;
            }

            ZeroMemory(&cvDbgDir, sizeof(cvDbgDir) );

            for (ul=0; ul < cDebugDir; ul++) {
                if (SYReadFar(hfile, (LPB) &dbgDir, sizeof(dbgDir)) != sizeof(dbgDir)) {
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }

                if (dbgDir.Type == IMAGE_DEBUG_TYPE_CODEVIEW) {
                    cvDbgDir = dbgDir;
                    continue;
                }

                if (dbgDir.Type == IMAGE_DEBUG_TYPE_FPO) {
                    LoadFpo(lpexg, hfile, &dbgDir);
                }

                if (dbgDir.Type == IMAGE_DEBUG_TYPE_OMAP_FROM_SRC ||
                    dbgDir.Type == IMAGE_DEBUG_TYPE_OMAP_TO_SRC) {
                    LoadOmap(lpexg, hfile, &dbgDir);
                }
            }

            if (cvDbgDir.Type != IMAGE_DEBUG_TYPE_CODEVIEW) {
                // We didn't find any CV info.  Try converting what we did
                // find.
                if (fLoadExports) {
                    lpexg->lpbData = (LPB)(pfConvertSymbolsForImage)( (HANDLE)(int)hfile, lpexg->lszDebug, &sheRet);
                }
                if (lpexg->lpbData == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                Signature = *(OMFSignature*)lpexg->lpbData;
                lpexg->fSymConverted = SHECONV(sheRet);
            } else {
                // Otherwise, calculate the location/size so we can load it.
                lfaBase = cvDbgDir.PointerToRawData;
                cbData =  cvDbgDir.SizeOfData;
                if (SYSeek(hfile, lfaBase, SEEK_SET) != lfaBase) {
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }
                sheRet = CheckSignature (hfile, &Signature, &pdbInfo);
                if (sheRet != sheNone && sheRet != sheConvertTIs)
                {
                    goto ReturnHere;
                }
            }
            break;

        case NTDBG_IMAGE:
            SecCount = sepHdr.NumberOfSections;

            if (sepHdr.SectionAlignment) {
                lpexg->ulImageAlign = sepHdr.SectionAlignment;
            }

            ul = SecCount * sizeof(IMAGE_SECTION_HEADER);

            // Note: SecHdr is free'd by LoadOmfForReal.

            SecHdr = (PIMAGE_SECTION_HEADER) MHAlloc(ul);
            if (!SecHdr) {
                sheRet = sheNoSymbols;
                goto ReturnHere;
            }

            // Read in the section headers.

            if (SYReadFar(hfile, (LPB) SecHdr, ul) != ul) {
                sheRet = sheCorruptOmf;
                goto ReturnHere;
            }

            // Skip over the exported names.

            SYSeek(hfile, sepHdr.ExportedNamesSize, SEEK_CUR);

            // Look for the interesting debug data.

            ZeroMemory(&cvDbgDir, sizeof(cvDbgDir));

            for (ul=0; ul < (sepHdr.DebugDirectorySize/sizeof(dbgDir)); ul++) {
                if (SYReadFar(hfile, (LPB) &dbgDir, sizeof(dbgDir)) != sizeof(dbgDir)) {
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }

                switch (dbgDir.Type) {
                    case IMAGE_DEBUG_TYPE_CODEVIEW :
                    cvDbgDir = dbgDir;
                        break;

                    case IMAGE_DEBUG_TYPE_FPO :
                    LoadFpo(lpexg, hfile, &dbgDir);
                        break;

                    case IMAGE_DEBUG_TYPE_EXCEPTION :
                        // UNDONE: We can eliminate this load for images
                        // that we've already processed the pdata from the
                        // real image...

                    LoadPdata(lpexg,
                              hfile,
                              dllLoadAddress,
                              sepHdr.ImageBase,
                              dbgDir.PointerToRawData,
                              dbgDir.SizeOfData,
                              TRUE);
                        break;

                    case IMAGE_DEBUG_TYPE_OMAP_TO_SRC :
                    case IMAGE_DEBUG_TYPE_OMAP_FROM_SRC :
                    LoadOmap(lpexg, hfile, &dbgDir);
                        break;
                }
            }

            if (cvDbgDir.Type != IMAGE_DEBUG_TYPE_CODEVIEW) {
                if (fLoadExports) {
                    lpexg->lpbData = (LPB)(pfConvertSymbolsForImage)( (HANDLE)(int)hfile, szFName /*lpexg->lszDebug*/, &sheRet);
                }
                if (lpexg->lpbData == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                Signature = *(OMFSignature*)lpexg->lpbData;
                lpexg->fSymConverted = SHECONV(sheRet);
            } else {
                lfaBase = cvDbgDir.PointerToRawData;
                cbData =  cvDbgDir.SizeOfData;
                if (SYSeek(hfile, lfaBase, SEEK_SET) != lfaBase) {
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }
                sheRet = CheckSignature (hfile, &Signature, &pdbInfo);

                if (sheRet != sheNone && sheRet != sheConvertTIs)
                {
                    goto ReturnHere;
                }
            }
            break;

        default:
            // No way we should get here, but assert if we do.
            assert(FALSE);
    }

    // O.K.  Everything's loaded.  If we're looking at a pdb file,
    // load it and get out.

    if ((*(LONG UNALIGNED *)(Signature.Signature)) == sigNB10) {
        sheRet = LoadPdb(lpexg, &pdbInfo);
        if (sheRet!=sheNone)
        {
            // PDB failed (not found, didn't match) so fallback
            // to exports
            if (fLoadExports)
            {
                lpexg->lpbData = (LPB)(pfConvertSymbolsForImage)( (HANDLE)(int)hfile, szFName, &sheRet);
                if (lpexg->lpbData == 0) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }
                Signature = *(OMFSignature*)lpexg->lpbData;
                lpexg->fSymConverted = SHECONV(sheRet);
                goto ReadCVDir;
            }
        }
    } else {
        // No PDB.
        // If the symbols weren't synthesized, allocate a buffer and
        //  copy them in...

        if (!lpexg->fSymConverted) {
            HANDLE hMap;
            HANDLE hFileMap;

            hFileMap = CreateFile(lpexg->lszDebug,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);

            if (hFileMap != INVALID_HANDLE_VALUE) {
                hMap = CreateFileMapping(hFileMap,
                                        NULL,
                                        PAGE_WRITECOPY,
                                        0,
                                        0,
                                        NULL);
                if (hMap != NULL) {
                    // Map in the symbolic (only).
                    SYSTEM_INFO si;
                    DWORD dwAllocStart, dwAllocDiff;

                    GetSystemInfo(&si);

                    dwAllocStart = lfaBase & (~(si.dwAllocationGranularity - 1));
                    dwAllocDiff = lfaBase - dwAllocStart;

                    lpexg->pvSymMappedBase = MapViewOfFile(hMap,
                                                           FILE_MAP_COPY,
                                                           0,
                                                           dwAllocStart,
                                                           cbData + dwAllocDiff);
                    if (lpexg->pvSymMappedBase) {
                        lpexg->lpbData = ((BYTE *) lpexg->pvSymMappedBase) + dwAllocDiff;
                    }

                    CloseHandle(hMap);
                }

                CloseHandle(hFileMap);
            }

            if (lpexg->lpbData == NULL) {

                // Unable to map the image.  Read the whole blob in from disk.

                lpexg->lpbData = (LPB)MHAlloc(cbData);
                if (!lpexg->lpbData) {
                    sheRet = sheNoSymbols;
                    goto ReturnHere;
                }

                if ((SYSeek (hfile, lfaBase, SEEK_SET) != lfaBase) ||
                    (SYReadFar (hfile, lpexg->lpbData, cbData) != cbData))
                {
                    // Failed to read in the data... Must be corrupt.
                    MHFree(lpexg->lpbData);
                    lpexg->lpbData = 0;
                    sheRet = sheCorruptOmf;
                    goto ReturnHere;
                }
            }
        }

ReadCVDir:
        // We now have a pointer to the CV debug data.  Setup the
        //  pointers to the CV Directory header and return.

        LPB     lpb;
        lpexg->ppdb = NULL;
        lpexg->ptpi = NULL;
        lpexg->pdbi = NULL;

        lpb = Signature.filepos + lpexg->lpbData;

        DirHeader = *(OMFDirHeader *) lpb;
        cDir = DirHeader.cDir;

        // check to make sure somebody has not messed with omf structure
        if (DirHeader.cbDirEntry != sizeof (OMFDirEntry)) {
            sheRet = sheCorruptOmf;
            goto ReturnHere;
        }

        lpdss = (OMFDirEntry *)(lpb + sizeof(DirHeader));

        if (lpexg->fSymConverted) {
            sheRet = sheSymbolsConverted;
            goto ReturnHere;
        }

        if (sheRet == sheConvertTIs) {
            goto ReturnHere;
        }

        sheRet = sheNone;
    }

ReturnHere:

    lpexg->debugData.she = sheRet;

    return sheRet;
}


SHE
LoadFpo(
    LPEXG                   lpexg,
    int                     hfile,
    PIMAGE_DEBUG_DIRECTORY  dbgDir
    )
{
    LONG fpos;

    fpos = SYTell(hfile);

    lpexg->fIsRisc = FALSE;

    if (SYSeek(hfile, dbgDir->PointerToRawData, SEEK_SET) != (LONG) dbgDir->PointerToRawData) {
        return(sheCorruptOmf);
    }

    if(!(lpexg->debugData.lpFpo = (PFPO_DATA) MHAlloc(dbgDir->SizeOfData)))
        return sheOutOfMemory;

    SYReadFar(hfile, (LPB) lpexg->debugData.lpFpo, dbgDir->SizeOfData);
    lpexg->debugData.cRtf = dbgDir->SizeOfData / SIZEOF_RFPO_DATA;

    SYSeek(hfile, fpos, SEEK_SET);

    return sheNone;
}

SHE
LoadOmap(
    LPEXG                   lpexg,
    int                     hfile,
    PIMAGE_DEBUG_DIRECTORY  dbgDir
    )
{
    LONG    fpos;
    LPVOID  lpOmap;
    DWORD   dwCount;

    fpos = SYTell(hfile);

    if (SYSeek(hfile, dbgDir->PointerToRawData, SEEK_SET) != (LONG) dbgDir->PointerToRawData) {
        return(sheCorruptOmf);
    }
    if(!(lpOmap = (LPVOID) MHAlloc(dbgDir->SizeOfData)))
        return sheOutOfMemory;
    SYReadFar(hfile, (LPB) lpOmap, dbgDir->SizeOfData);

    dwCount = dbgDir->SizeOfData / sizeof(OMAP);

    SYSeek(hfile, fpos, SEEK_SET);

    if(dbgDir->Type == IMAGE_DEBUG_TYPE_OMAP_FROM_SRC) {
        lpexg->debugData.lpOmapFrom = (LPOMAP) lpOmap;
        lpexg->debugData.cOmapFrom = dwCount;
    } else
    if(dbgDir->Type == IMAGE_DEBUG_TYPE_OMAP_TO_SRC) {
        lpexg->debugData.lpOmapTo = (LPOMAP) lpOmap;
        lpexg->debugData.cOmapTo = dwCount;
    } else {
        MHFree(lpOmap);
    }
	assert( lpexg->ulImageAlign!=0 );
	lpexg->debugData.dwOrigAlign = lpexg->ulImageAlign;
    return sheNone;
}

SHE
LoadPdata(
    LPEXG                   lpexg,
    int                     hfile,
    ULONG                   loadAddress,
    ULONG                   imageBase,
    ULONG                   start,
    ULONG                   size,
    BOOL                    fDbgFile
    )
{
    ULONG                          cFunc;
    LONG                           diff;
    ULONG                          index;
    PIMAGE_RUNTIME_FUNCTION_ENTRY  rf;
    PIMAGE_RUNTIME_FUNCTION_ENTRY  tf;
    PIMAGE_FUNCTION_ENTRY          dbgRf;
    LONG                           fpos;

    lpexg->debugData.lpRtf = NULL;
    lpexg->debugData.cRtf  = 0;

    if(size == 0) {
        return sheNone;    // No data to read...  Just return.
    }

    if(fDbgFile) {
        cFunc = size / sizeof(IMAGE_FUNCTION_ENTRY);
        diff = 0;
    } else {
        cFunc = size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);
#if defined(TARGET_ALPHA)
        // Executable's load address is never initialized

        if (loadAddress) {
            diff = loadAddress - imageBase;
        } else {
                diff = 0;
                }
#else
        diff = loadAddress - imageBase;
#endif
    }

    lpexg->fIsRisc = TRUE;

    fpos = SYTell(hfile);

    if (SYSeek(hfile, start, SEEK_SET) != (LONG) start) {
        return(sheCorruptOmf);
    }

    if(fDbgFile) {
        if(!(dbgRf = (PIMAGE_FUNCTION_ENTRY) MHAlloc(size))) {
            return sheOutOfMemory;
        }
        SYReadFar(hfile, (LPB)dbgRf, size);
        size = cFunc * sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);
        if(!(tf = rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY) MHAlloc(size))) {
            MHFree(dbgRf);
            return sheOutOfMemory;
        }
        for(index=0; index<cFunc; index++) {
            rf[index].BeginAddress       = dbgRf[index].StartingAddress + loadAddress;
            rf[index].EndAddress         = dbgRf[index].EndingAddress + loadAddress;
            rf[index].PrologEndAddress   = dbgRf[index].EndOfPrologue + loadAddress;
            rf[index].ExceptionHandler   = 0;
            rf[index].HandlerData        = 0;
        }
        MHFree(dbgRf);

    } else {
        if(!(tf = rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY) MHAlloc(size))) {
            return sheOutOfMemory;
        }
        SYReadFar(hfile, (LPB)rf, size);
    }

    // If this is an ilink'd image, there'll be padding at the end of the pdata section
    //  (to allow for insertion later).  Shrink the table if this is true.

    // Find the start of the padded page (end of the real data)

    for(index=0; index<cFunc && tf->BeginAddress; tf++,index++) {
        ;
    }

    if(index < cFunc) {
        cFunc = index;
        size  = index * sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);
        if(!(rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY) MHRealloc(rf, size))) {
            return sheOutOfMemory;
        }
    }

    if (diff != 0) {
        for (index=0; index<cFunc; index++) {
            rf[index].BeginAddress += diff;
            rf[index].EndAddress += diff;
            rf[index].PrologEndAddress += diff;
            rf[index].ExceptionHandler = 0;
            rf[index].HandlerData = 0;
        }
    }

    lpexg->debugData.lpRtf = rf;
    lpexg->debugData.cRtf  = cFunc;

    SYSeek(hfile, fpos, SEEK_SET);
    return sheNone;
}


//  CheckSignature - check file signature
//
//  she = CheckSignature (INT hfile, OMFSignature *pSig)
//
//  Entry   hfile = handle to file
//          pSig  = location where signature should be written to
//          ppdb  = PDB information.
//
//  Exit    none
//
//  Return  sheNoSymbols if exe has no signature
//          sheMustRelink if exe has NB00 to NB06 or NB07 (qcwin) signature
//          sheNotPacked if exe has NB08 signature
//          sheNone if exe has NB11 signature
//          sheConvertTIs if exe has NB09 signature
//          sheFutureSymbols if exe has NB12 to NB99 signature

SHE
CheckSignature(
    INT hfile,
    OMFSignature *pSig,
    PDB_INFO *ppdb
    )
{
    UINT    uSig;

    if ((SYReadFar (hfile, (LPB) pSig, sizeof (*pSig)) != sizeof (*pSig)) ||
         (pSig->Signature[0] != 'N') ||
         (pSig->Signature[1] != 'B') ||
         (!isdigit(pSig->Signature[2])) ||
         (!isdigit(pSig->Signature[3]))) {
        return sheNoSymbols;
    }

    switch (*(LONG UNALIGNED *)(pSig->Signature)) {
        case sigNB05:
        case sigNB06:
        case sigNB07:
            return sheMustRelink;
        case sigNB08:
            return sheNotPacked;
        case sigNB09:
            return sheConvertTIs;
        case sigNB10:
            SYReadFar(hfile, (LPB)ppdb, sizeof(PDB_INFO));
        case sigNB11:
            return sheNone;
        default:
            return sheFutureSymbols;
    }
}


//  OLMkSegDir - MakeSegment directory
//
//  Entry
//
//  Returns non-zero for success

BOOL
OLMkSegDir(
    WORD  csgd,
    LPSGD *lplpsgd,
    LPSGE *lplpsge,
    LPEXG lpexg
    )
{
    LPSGD lpsgd;
    LPSGE lpsge = NULL;
    int  *lpisge;
    int   csgc = 0;
    int   isge = 0;
    int   isgd = 0;
    DWORD iMod;

    if (!(lpsgd = (LPSGD) MHAlloc (csgd * sizeof (SGD)))) {
        return FALSE;
    }

    if (!(lpisge = (int *) MHAlloc (csgd * sizeof (int)))) {
        MHFree(lpsgd);
        return FALSE;
    }

    memset(lpsgd,  0, csgd * sizeof(SGD));
    memset(lpisge, 0, csgd * sizeof(int));

    // Count the number of contributers per segment

    for (iMod = 1; iMod <= lpexg->cMod; iMod++) {
        LPMDS lpmds = &lpexg->rgMod[iMod];
        int cseg = lpmds->csgc;
        int iseg = 0;
        int isegT = 0;

        for (iseg = 0; iseg < cseg; iseg++) {
            isegT = lpmds->lpsgc [ iseg ].seg;
            if (isegT != 0) {
                lpsgd [ isegT - 1 ].csge += 1;
                csgc += 1;
            }
        }
    }

    // Allocate subtable for each all segments

    lpsge = (LPSGE) MHAlloc (csgc * sizeof (SGE));

    if (!lpsge) {
        MHFree (lpsgd);
        MHFree (lpisge);
        return FALSE;
    }

    // Set up sgd's with pointers into appropriate places in the sge table

    isge = 0;
    for (isgd = 0; isgd < (int) csgd; isgd++) {
        lpsgd[ isgd ].lpsge = lpsge + isge;
        isge += lpsgd[ isgd ].csge;
    }

    // Fill in the sge table

    for (iMod = 1; iMod <= lpexg->cMod; iMod += 1) {
        LPMDS lpmds = &lpexg->rgMod[iMod];
        int cseg = lpmds->csgc;
        int iseg = 0;

        for (iseg = 0; iseg < cseg; iseg++) {
            int isgeT = lpmds->lpsgc[ iseg ].seg - 1;

            if (isgeT != -1) {
                lpsgd[ isgeT ].lpsge[ lpisge[ isgeT ]].sgc =
                    lpmds->lpsgc[ iseg ];
                lpsgd[ isgeT ].lpsge[ lpisge[ isgeT ]].hmod =
                    (HMOD)lpmds;
                lpisge[ isgeT ] += 1;
            }
        }
    }

    MHFree (lpisge);

    *lplpsge = lpsge;
    *lplpsgd = lpsgd;

    return TRUE;
}

//  OLMkModule - make module entries for module
//
//  Entry   lpexg  - Supplies the pointer to the EXG structure for current exe
//          hexg   - Supplies the handle EXG structure
//
//  Returns non-zero for success


int
OLMkModule(
    LPEXG   lpexg,
    HEXG    hexg
    )
{
    LSZ     lszModName;
    LPMDS   lpmds;
    LPB     lpbName;
    WORD    cbName;
    WORD    i;
    OMFModule *pMod;

    // Point to the OMFModule table.  This structure describes the name and
    // segments for the current Module being processed.  There is a one to one
    // correspondance of modules to object files.

    pMod = (OMFModule *) (lpexg->lpbData + lpdssCur->lfo);

    // Point to the name field in the module table.  This location is variable
    // and is dependent on the number of contributuer segments for the module.

    lpbName = ((LPB)pMod) +
      offsetof (OMFModule, SegInfo[0]) +
      (sizeof (OMFSegDesc) * pMod->cSeg);
    cbName = *((LPB)lpbName)++;
    lszModName = (LPCH) MHAlloc (cbName + 1);
    memmove(lszModName, lpbName, cbName);
    *(lszModName + cbName) = 0;

    lpmds = &lpexg->rgMod[lpdssCur->iMod];

    lpmds->imds   = lpdssCur->iMod;
    lpmds->hexg   = hexg;
    lpmds->name   = lszModName;

    // step thru making the module entries
    //
    // NOTENOTE -- This can most likely be optimized as the data
    //          is just being copied from the debug data.

    lpmds->csgc = pMod->cSeg;
    lpmds->lpsgc = (LPSGC)MHAlloc ( pMod->cSeg * sizeof ( SGC ) );

    for ( i = 0; i < pMod->cSeg; i++ ) {
        if ( pMod->SegInfo[i].Seg > csegExe ) {
            csegExe = pMod->SegInfo[i].Seg;
        }
        lpmds->lpsgc[i].seg = pMod->SegInfo[i].Seg;
        lpmds->lpsgc[i].off = pMod->SegInfo[i].Off;
        lpmds->lpsgc[i].cb  = pMod->SegInfo[i].cbSeg;
    }

    return TRUE;
}

SHE
NB10LoadModules(
    LPEXG   lpexg,
    ULONG*  pcMods,
    HEXG    hexg
    )
{
    Mod* pmod = NULL;
    ULONG   cMod = 0;
    IMOD    imod;

    // First count up the number of Mods

    while (DBIQueryNextMod(lpexg->pdbi, pmod, &pmod) && pmod) {
        if(!ModQueryImod(pmod, &imod))
            return sheCorruptOmf;
        if(imod > *pcMods)
            cMod = imod;
    }

    *pcMods = cMod;

    // Got the count.  Allocate rgMod.

    lpexg->rgMod = (LPMDS) MHAlloc((cMod+2) * sizeof(MDS));
    if (lpexg->rgMod == NULL) {
        return sheOutOfMemory;
    }
    memset(lpexg->rgMod, 0, sizeof(MDS)*(cMod+2));
    lpexg->rgMod[cMod+1].imds = (WORD) -1;

    // Now fill in the blanks.

    pmod = NULL;

    for (; cMod; cMod--) {
        LPMDS   lpmds;
        LPCH    lpchName;
        CB      cbName;

        DBIQueryNextMod(lpexg->pdbi, pmod, &pmod);

        if(!ModQueryImod(pmod, &imod))
            return sheCorruptOmf;

        lpmds = &lpexg->rgMod[imod];

        lpmds->imds = imod;
        lpmds->pmod = pmod;
        lpmds->hexg = hexg;

        if(!ModQueryName(pmod, NULL, &cbName))
            return sheCorruptOmf;
        lpmds->name  = (LSZ) MHAlloc(cbName);
        if(!lpmds->name)
            return sheOutOfMemory;
        if(!ModQueryName(pmod, lpmds->name, &cbName))
            return sheCorruptOmf;
        if(!ModSetPvClient(pmod, lpmds))
            return sheCorruptOmf;
    }
    return sheNone;
}


BOOL
OLLoadHashTable(
    LPB     lpbData,
    ULONG   cbTable,
    LPSHT   lpsht,
    BOOL    fDWordChains
    )
{
    WORD    ccib   = 0;
    LPUL    rgib   = NULL;
    LPUL    rgcib  = NULL;
    ULONG   cbHeader = 0;
    LPB     lpHashStart = lpbData;

    memset(lpsht, 0, sizeof(SHT));

    ccib = *(WORD *)lpbData;        // First, get the hash bucket counts
    lpbData += 4;                   // the 2 byte hash count and 2 bytes padding
    rgib = (LPUL) lpbData;

    lpbData += ccib * sizeof(ULONG);

    rgcib = (LPUL) lpbData;

    lpbData += ccib * sizeof(ULONG);

    // Subtract off what we've processed already.

    cbTable     -= (lpbData - lpHashStart);

    lpsht->ccib  = ccib;
    lpsht->rgib  = rgib;
    lpsht->rgcib = rgcib;
    lpsht->lpalm = BuildALM(FALSE,
                            btAlign,
                            lpbData,
                            cbTable,
                            cbAlign);

    if (lpsht->lpalm == NULL) {
        return FALSE;
    }

    return TRUE;
}


BOOL
OLLoadHashSubSec(
    LPGST       lpgst,
    LPB         lpbData,
    WidenTi *   pwti
    )
{
    LPB        lpbTbl = NULL;
    OMFSymHash hash;
    ULONG      cbSymbol;
    BOOL       fRet = TRUE;
    LPSHT      lpshtName = &lpgst->shtName;
    LPSHT      lpshtAddr = &lpgst->shtAddr;

    memset(lpshtAddr, 0, sizeof(SHT));
    memset(lpshtName, 0, sizeof(SHT));

    hash = *(OMFSymHash *)lpbData;

    lpbData += sizeof (OMFSymHash);

    cbSymbol = hash.cbSymbol;

    if (pwti) {
        ConvertGlobal16bitSyms(pwti, lpgst, lpbData, cbSymbol);
    }
    else
    {
        lpgst->lpalm = BuildALM(TRUE,
                                btAlign,
                                lpbData,
                                cbSymbol,
                                cbAlign);
    }

    if (lpgst->lpalm == NULL) {
        return FALSE;
    }

    lpbData += cbSymbol;

//    if (hash.symhash == 6 || hash.symhash == 10) {
    if (hash.symhash == 10) {
        fRet = OLLoadHashTable(lpbData,
                               hash.cbHSym,
                               &lpgst->shtName,
                               hash.symhash == 10);
        lpgst->shtName.HashIndex = hash.symhash;
    }

    lpbData += hash.cbHSym;

//    if (hash.addrhash == 8 || hash.addrhash == 12) {
    if (hash.addrhash == 12) {
        fRet = OLLoadHashTable(lpbData,
                               hash.cbHAddr,
                               &lpgst->shtAddr,
                               hash.addrhash == 12);
        lpgst->shtAddr.HashIndex = hash.addrhash;
    }

    return fRet;
}

//  OLLoadTypes - load compacted types table
//
//  Input:  lpexg - Pointer to exg we're working on.
//
//  Returns:    - An error code

SHE
OLLoadTypes(
    LPEXG lpexg
    )
{
    LPB         pTyp;
    LPB         pTypes;

    OMFTypeFlags flags;
    DWORD        cType  = 0;
    DWORD       *rgitd  = NULL;
    DWORD        ibType = 0;

    pTyp = pTypes = lpexg->lpbData + lpdssCur->lfo;

    flags = *(OMFTypeFlags *) pTypes;
    pTypes += sizeof(OMFTypeFlags);
    cType = *(ULONG *) pTypes;
    pTypes += sizeof(ULONG);

    if (!cType) {
        return sheNone;
    }

    // Point to the array of pointers to types

    rgitd = (DWORD *) pTypes;

    // Move past them

    pTypes += cType * sizeof(ULONG);

    // Read in the type index table

    ibType = pTypes - pTyp;
    lpexg->lpalmTypes = BuildALM (FALSE,
                                  btAlign,
                                  pTypes,
                                  lpdssCur->cb - ibType,
                                  cbAlignType);

    if (lpexg->lpalmTypes == NULL) {
        return sheOutOfMemory;
    }

    lpexg->rgitd = rgitd;
    lpexg->citd  = cType;

    return sheNone;
}


//  OLLoadSym - load symbol information
//
//  error = OLLoadSym (pMod)
//
//  Entry   lpexg - Pointer to exg structure to use.
//
//  Returns sheNone if symbols loaded

SHE
OLLoadSym(
    LPEXG lpexg
    )
{
    // UNDONE: If we run into problems with a stale VC, we'll have to
    //  revert to reading the file on demand.  The expectation is that the
    //  mapped I/O code will just work.

    // lpexg->rgMod[lpdssCur->iMod].symbols = NULL;

    if (lpexg->pwti) {
        // we be converting 16-bit symbols to 32-bit versions.
        SHE                 sheRet = sheOutOfMemory;
        WidenTi *           pwti = lpexg->pwti;
        PMDS                pmod = &lpexg->rgMod[lpdssCur->iMod];
        SymConvertInfo &    sci = pmod->sci;
        PB                  pbSyms = lpexg->lpbData + lpdssCur->lfo;
        CB                  cbSyms = lpdssCur->cb;

        // Remember the signature!
        if (pwti->fQuerySymConvertInfo (sci, pbSyms, cbSyms, sizeof ULONG)) {
            sci.pbSyms = PB(MHAlloc (sci.cbSyms));
            sci.rgOffMap = POffMap(MHAlloc (sci.cSyms * sizeof OffMap));
            if (sci.pbSyms && sci.rgOffMap) {
                memset (sci.pbSyms, 0, sci.cbSyms);
                memset (sci.rgOffMap, 0, sci.cSyms * sizeof OffMap);
                if (pwti->fConvertSymbolBlock (sci, pbSyms, cbSyms, sizeof ULONG) ) {
                    pmod->symbols = sci.pbSyms;
                    *(ULONG*)pmod->symbols = CV_SIGNATURE_C11;
                    pmod->cbSymbols = sci.cbSyms;
                    // REVIEW: What about pmod->ulsym?  how is it used?
                    sheRet = sheNone;
                }
                else {
                    sheRet = sheCorruptOmf;
                }
            }
        }
        return sheRet;
    }
    else
    {
        lpexg->rgMod[lpdssCur->iMod].symbols = lpexg->lpbData + lpdssCur->lfo;
        lpexg->rgMod[lpdssCur->iMod].cbSymbols = lpdssCur->cb;
        lpexg->rgMod[lpdssCur->iMod].ulsym = lpdssCur->lfo;
        return sheNone;
    }
}


__inline SHE
OLLoadSrc(
    LPEXG lpexg
    )
{
    lpexg->rgMod[lpdssCur->iMod].hst = (HST) (lpexg->lpbData + lpdssCur->lfo);
    return sheNone;
}


__inline SHE
OLGlobalPubs(
    LPEXG   lpexg
    )
{
    SHE   she   = sheNone;

    if (!OLLoadHashSubSec (&lpexg->gstPublics,
                           lpexg->lpbData + lpdssCur->lfo,
                           lpexg->pwti)) {
        she = sheOutOfMemory;
    }

    return she;
}


__inline SHE
OLGlobalSym(
    LPEXG   lpexg
    )
{
    SHE   she   = sheNone;

    if (!OLLoadHashSubSec (&lpexg->gstGlobals,
                           lpexg->lpbData + lpdssCur->lfo,
                           lpexg->pwti)) {
        she = sheOutOfMemory;
    }

    return she;
}

SHE
OLLoadSegMap(
    LPEXG   lpexg
    )
{
    LPB lpb;
    SHE sheRet = sheNone;

    if(lpexg->pdbi) {
        CB      cb;

        // load from the pdb
        if(!DBIQuerySecMap(lpexg->pdbi, NULL, &cb) ||
           !(lpb = (LPB) MHAlloc (cb))) {
            sheRet = sheOutOfMemory;
        } else
        if(!DBIQuerySecMap(lpexg->pdbi, lpb, &cb)) {
            MHFree(lpb);
            lpb = NULL;
            sheRet = sheOutOfMemory;
        }
    } else {
            lpb = lpexg->lpbData + lpdssCur->lfo;
    }

    lpexg->lpgsi = lpb;

    return sheRet;
}

SHE
OLLoadNameIndex(
    LPEXG   lpexg
    )
{
    OMFFileIndex *  lpefi;
    WORD            cmod = 0;
    WORD            cfile = 0;
    CB              cb;

    if(lpexg->pdbi) {
        if(!DBIQueryFileInfo(lpexg->pdbi, 0, &cb)) {
            return sheNoSymbols;
        }
        else if(!(lpefi = (OMFFileIndex *) MHAlloc(cb))) {
            return sheOutOfMemory;
        }
        else if(!DBIQueryFileInfo(lpexg->pdbi, (PB)lpefi, &cb)) {
            MHFree(lpefi);
            return sheNoSymbols;
        }
    } else {
        lpefi = (OMFFileIndex *)(lpexg->lpbData + lpdssCur->lfo);
        cb = (CB)lpdssCur->cb;
    }

    cmod  = lpefi->cmodules;
    // Make sure we found as many sstModule entries as we should have.
    assert(cmod == lpexg->cMod);
//    lpexg->cmod      = cmod;
    cfile = lpefi->cfilerefs;

    lpexg->lpefi     = (LPB) lpefi;
    lpexg->rgiulFile = lpefi->modulelist;
    lpexg->rgculFile = &lpefi->modulelist [cmod];
    lpexg->rgichFile = (LPUL) &lpefi->modulelist [cmod * 2];

    lpexg->lpchFileNames = (LPCH) &lpefi->modulelist [cmod * 2 + cfile * 2];

    lpexg->cbFileNames =
        (ULONG)(cb - ((LPB)lpexg->lpchFileNames - (LPB)lpefi + 1));

    return sheNone;
}

SHE
OLStaticSym(
    LPEXG   lpexg
    )
{
    SHE   she   = sheNone;

    if (!OLLoadHashSubSec (&lpexg->gstStatics,
                           lpexg->lpbData + lpdssCur->lfo,
                           lpexg->pwti)) {
        she = sheOutOfMemory;
    }

    return she;

}


const SHE mpECToShe[] = {
    sheNone,            // EC_OK
    sheNoSymbols,       // EC_USAGE (invalid parameter of call order)
    sheOutOfMemory,     // EC_OUT_OF_MEMORY (-, out of RAM)
    sheNoSymbols,       // EC_FILE_SYSTEM (pdb name, can't write file, out of disk, etc)
    shePdbNotFound,     // EC_NOT_FOUND (PDB file not found)
    shePdbBadSig,       // EC_INVALID_SIG (PDB::OpenValidate() and its clients only)
    shePdbInvalidAge,   // EC_INVALID_AGE (PDB::OpenValidate() and its clients only)
    sheNoSymbols,       // EC_PRECOMP_REQUIRED (obj name, Mod::AddTypes only)
    sheNoSymbols,       // EC_OUT_OF_TI (pdb name, TPI::QueryTiForCVRecord() only)
    sheNoSymbols,       // EC_NOT_IMPLEMENTED
    sheNoSymbols,       // EC_V1_PDB (pdb name, PDB::Open() only)
    shePdbOldFormat,    // EC_FORMAT (accessing pdb with obsolete format)
    sheNoSymbols,       // EC_LIMIT,
    sheNoSymbols,       // EC_CORRUPT,             // cv info corrupt, recompile mod
    sheNoSymbols,       // EC_TI16,                // no 16-bit type interface present
    sheNoSymbols,       // EC_ACCESS_DENIED,       // "pdb name", PDB file read-only
};

// Get the name of the pdb file (OMF name) for the specified exe.  If the
// LoadPdb hasn't been called on this exe OR it's not NB10, this will return
// an empty string!  Note: There will only be an lszPdbName if there was
// an error loading the pdb

VOID LOADDS
SHPdbNameFromExe(
    LSZ lszExe,
    LSZ lszPdbName,
    UINT cbMax
    )
{
    HEXE    hexe;

    // Zero out the destination
    memset(lszPdbName, 0, cbMax);

    // Look up the exe
    if (hexe = SHGethExeFromName(lszExe)) {
        HEXG    hexg = ((LPEXE)LLLock(hexe))->hexg;
        LPEXG   lpexg = (LPEXG)LLLock(hexg);

        // Only copy if there's a pdbname
        if (lpexg->lszPdbName) {
            _tcsncpy(lszPdbName, lpexg->lszPdbName, cbMax);
        }

        // Clean up
        LLUnlock(hexg);
        LLUnlock(hexe);
    }
}


BOOL
GetDefaultKeyName(
        LPCTSTR KeySuffix,
        LPTSTR  KeyBuffer,
        DWORD   nLength
        )
{
        DWORD   lnLength = nLength;

    if (!GetRegistryRoot(KeyBuffer, &lnLength)) {
                return FALSE;
    }

    if (KeyBuffer[lnLength - 1] != _T('\\')) {
        KeyBuffer[lnLength++] = _T('\\');
        KeyBuffer[lnLength] = _T('\0');
        }

    assert(*KeySuffix != _T('\\'));
    _tcscpy(&KeyBuffer[lnLength], KeySuffix);

        return TRUE;
}

// read stuff from the registry, but do it only once

void QueryRegistry()
{
    TCHAR szDefaultKeyName[300];
    static const TCHAR szKeySuffix[] =
        _T("Build System\\Components\\Platforms\\Win32 (x86)\\Directories");
    static const TCHAR szPdbDirs[] = "Pdb Dirs";

    if (fQueriedRegistry)
        return;

    fQueriedRegistry = TRUE;

    GetDefaultKeyName(szKeySuffix, szDefaultKeyName, sizeof(szDefaultKeyName));

    HKEY hSectionKey = NULL;
    DWORD nType = REG_SZ;
    DWORD nSize = sizeof(szSearchPath);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szDefaultKeyName, 0, KEY_READ, &hSectionKey) != ERROR_SUCCESS)
    {
        szSearchPath[0] = 0;
    }
    else
    {
        if (RegQueryValueEx(hSectionKey,
                            szPdbDirs,
                         NULL,
                         &nType,
                            (LPBYTE) szSearchPath,
                            &nSize) != ERROR_SUCCESS)
        {
            szSearchPath[0] = 0;
        }

        CloseHandle(hSectionKey);
    }

    GetDefaultKeyName("Debug", szDefaultKeyName, sizeof(szDefaultKeyName));
    nType = REG_DWORD;
    nSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szDefaultKeyName, 0, KEY_READ, &hSectionKey) != ERROR_SUCCESS)
    {
        fLoadExports = FALSE;
    }
    else
    {
        if (RegQueryValueEx(hSectionKey,
                            "LoadExports",
                         NULL,
                         &nType,
                            (LPBYTE) &fLoadExports,
                            &nSize) != ERROR_SUCCESS)
        {
            fLoadExports = FALSE;
        }

        CloseHandle(hSectionKey);
    }

}

SHE
LoadPdb(
    LPEXG lpexg,
    PDB_INFO *ppdb
    )
{
    EC ec;
    char szRefPath[_MAX_PATH];
    char szPDBOut[cbErrMax];
    BOOL fOpenValidate;

    assert(lpexg);

    // figure out the home directory of the EXE/DLL or DBG file - pass that along to
    // OpenValidate this will direct to dbi to search for it in that directory.

    _fullpath(szRefPath, lpexg->lszDebug ? lpexg->lszDebug : lpexg->lszName, _MAX_PATH);
    char *pcEndOfPath = _tcsrchr(szRefPath, '\\');
    *pcEndOfPath = '\0';        // null terminate it
    *szPDBOut = '\0';

    if (!fQueriedRegistry)
        QueryRegistry();

    if ( pAltPDBOpen == 0 ) {
        fOpenValidate = PDBOpenValidateEx(ppdb->sz,
                                           szRefPath,
                                           szSearchPath,
                                           pdbRead,
                                           ppdb->sig,
                                           ppdb->age,
                                           &ec,
                                           szPDBOut,
                                           &lpexg->ppdb);
    } else {
        fOpenValidate = (*pAltPDBOpen)   (ppdb->sz,
                                           szRefPath,
                                           szSearchPath,
                                           pdbRead,
                                           ppdb->sig,
                                           ppdb->age,
                                           &ec,
                                           szPDBOut,
                                           &lpexg->ppdb);
    }

    if (!fOpenValidate) {
        // Save the name of the pdb with the error

        if (!(lpexg->lszPdbName = (LSZ)MHAlloc(_tcslen(szPDBOut) + 1))) {
            return sheOutOfMemory;
        }

        _tcscpy(lpexg->lszPdbName, szPDBOut);

        return mpECToShe[ec];
    }

    // Store the name of the pdb in lszDebug.

    char *szPdb = PDBQueryPDBName(lpexg->ppdb, (char *)szPDBOut);
    assert(szPdb);

    // Save the name of the PDB

    if (lpexg->lszDebug) {
        MHFree(lpexg->lszDebug);
        lpexg->lszDebug = 0;
    }

    if (!(lpexg->lszDebug = (LSZ)MHAlloc(_tcslen(szPDBOut) + 1))) {
        return sheOutOfMemory;
    }

    _tcscpy(lpexg->lszDebug, szPDBOut);

    if (!PDBOpenTpi(lpexg->ppdb, pdbRead, &(lpexg->ptpi))) {
        ec = PDBQueryLastError(lpexg->ppdb, NULL);

        return mpECToShe[ec];
    }

#if CC_LAZYTYPES
    if (!PDBOpenDBIEx(lpexg->ppdb, pdbRead, lpexg->lszName, &(lpexg->pdbi), pSYFindDebugInfoFile))
#else
    if (!PDBOpenDBI(lpexg->ppdb, pdbRead, lpexg->lszName, &(lpexg->pdbi)))
#endif
    {
        ec = PDBQueryLastError(lpexg->ppdb, NULL);

        return mpECToShe[ec];
    }

    if (!STABOpen(&(lpexg->pstabUDTSym))) {
        return sheOutOfMemory;
    }

#ifndef ACTIVEDBG
	// stub out while V7 uses PDB5 APIs

	// try to load FPO/OMAP/etc information if they have not
	// been loaded yet from the executable
	return LoadDebugDataFromPdb(lpexg, ppdb);
}


// Routine Description:
//
//  This routine loads FPO / RTE / OMAP from the pdb
//  if the relevant tables have not already been loaded from the executable

LOCAL SHE
LoadDebugDataFromPdb(
    LPEXG lpexg,
    PDB_INFO *ppdb
    )
{
    EC ec;
    char szExePath[_MAX_PATH];
    char szPDBOut[cbErrMax];

	if (lpexg->debugData.cRtf == 0) {
		Dbg *pfpo, *pexcept;
		if (DBIOpenDbg(lpexg->pdbi, dbgtypeFPO, &pfpo)) {
			long cFpo = DbgQuerySize(pfpo);
			if (cFpo > 0) {
				lpexg->debugData.cRtf = cFpo;
				if (!(lpexg->debugData.lpFpo = (PFPO_DATA) MHAlloc(cFpo * sizeof (FPO_DATA)))) {
					DbgClose(pfpo);
					return sheOutOfMemory;
				}
				if (!DbgQueryNext(pfpo, cFpo, lpexg->debugData.lpFpo)) {
					ec = PDBQueryLastError(lpexg->ppdb, NULL);
					DbgClose(pfpo);
					return mpECToShe[ ec ];
				}
			}
		}
		else if (DBIOpenDbg(lpexg->pdbi, dbgtypeException, &pexcept)) {
			long cRtf = DbgQuerySize(pexcept);
			long index;

			if (cRtf > 0) {
				PIMAGE_FUNCTION_ENTRY dbgRf;
				PIMAGE_RUNTIME_FUNCTION_ENTRY rf;
				if(	!(dbgRf = (PIMAGE_FUNCTION_ENTRY) 
						MHAlloc(cRtf * sizeof (IMAGE_FUNCTION_ENTRY))) ||
					!(rf = (PIMAGE_RUNTIME_FUNCTION_ENTRY) 
						MHAlloc(cRtf * sizeof (IMAGE_RUNTIME_FUNCTION_ENTRY)))){
					DbgClose(pexcept);
					return sheOutOfMemory;
				}
				lpexg->debugData.cRtf = cRtf;
				if (!DbgQueryNext(pexcept, cRtf, dbgRf)) {
					ec = PDBQueryLastError(lpexg->ppdb, NULL);
					DbgClose(pexcept);
					return mpECToShe[ ec ];
				}

				for(index=0; index < cRtf; index++) {
					rf[index].BeginAddress       = dbgRf[index].StartingAddress + lpexg->LoadAddress;
					rf[index].EndAddress         = dbgRf[index].EndingAddress + lpexg->LoadAddress;
					rf[index].PrologEndAddress   = dbgRf[index].EndOfPrologue + lpexg->LoadAddress;
					rf[index].ExceptionHandler   = 0;
					rf[index].HandlerData        = 0;
				}
				MHFree(dbgRf);
				lpexg->debugData.lpRtf = rf;				
			}
		}
	}

	if (lpexg->debugData.cOmapFrom == 0) {
		Dbg *pomapf;
		if (DBIOpenDbg(lpexg->pdbi, dbgtypeOmapFromSrc, &pomapf)) {
			long cOmapFrom = DbgQuerySize(pomapf);
			if (cOmapFrom > 0) {
				lpexg->debugData.cOmapFrom = cOmapFrom;
				if (!(lpexg->debugData.lpOmapFrom = (LPOMAP) MHAlloc(cOmapFrom * sizeof (OMAP)))) {
					DbgClose(pomapf);
					return sheOutOfMemory;
				}
				if (!DbgQueryNext(pomapf, cOmapFrom, lpexg->debugData.lpOmapFrom)) {
					ec = PDBQueryLastError(lpexg->ppdb, NULL);
					DbgClose(pomapf);
					return mpECToShe[ ec ];
				}
			}
		}
	}

	if (lpexg->debugData.cOmapTo == 0) {
		Dbg *pomapt;
		if (DBIOpenDbg(lpexg->pdbi, dbgtypeOmapToSrc, &pomapt)) {
			long cOmapTo = DbgQuerySize(pomapt);
			if (cOmapTo > 0) {
				lpexg->debugData.cOmapTo = cOmapTo;
				if (!(lpexg->debugData.lpOmapTo = (LPOMAP) MHAlloc(cOmapTo * sizeof (OMAP)))) {
					DbgClose(pomapt);
					return sheOutOfMemory;
				}
				if (!DbgQueryNext(pomapt, cOmapTo, lpexg->debugData.lpOmapTo)) {
					ec = PDBQueryLastError(lpexg->ppdb, NULL);
					DbgClose(pomapt);
					return mpECToShe[ ec ];
				}
			}
		}
	}
	lpexg->debugData.dwOrigAlign = lpexg->ulImageAlign;
#endif

	return sheNone;
}


// Routine Description:
//
//  This routine is used to validate that the debug information
//  in a file matches the debug information requested
//
// Arguments:
//
//  hFile       - Supplies the file handle to be validated
//  lpv         - Supplies a pointer to the information to used in vaidation
//
// Return Value:
//
//  TRUE if matches and FALSE otherwise

SHE
OLValidate(
    int          hFile,
    void *       lpv,
    LPSTR        lpszErrText
    )
{
    VLDCHK *            pVldChk = (VLDCHK *) lpv;
    IMAGE_DOS_HEADER    exeHdr;
    IMAGE_NT_HEADERS    peHdr;
    int                 fPeExe = FALSE;
    int                 fPeDbg = FALSE;

    if (lpszErrText) {
        *lpszErrText = 0;
    }

    // Read in a dos exe header

    if ((SYSeek(hFile, 0, SEEK_SET) != 0) ||
        (SYReadFar( hFile, (LPB) &exeHdr, sizeof(exeHdr)) != sizeof(exeHdr))) {
        return sheNoSymbols;
    }

    // See if it is a dos exe hdr

    if (exeHdr.e_magic == IMAGE_DOS_SIGNATURE) {
        if ((SYSeek(hFile, exeHdr.e_lfanew, SEEK_SET) == exeHdr.e_lfanew) &&
            (SYReadFar(hFile, (LPB) &peHdr, sizeof(peHdr)) == sizeof(peHdr))) {
            if (peHdr.Signature == IMAGE_NT_SIGNATURE) {
                fPeExe = TRUE;
            }
        }
    } else if (exeHdr.e_magic == IMAGE_SEPARATE_DEBUG_SIGNATURE) {
        fPeDbg = TRUE;
    }

    if (fPeExe) {
        if (pVldChk->TimeDateStamp == 0) {
            // If the timestamp has not been initialized do so now.

            pVldChk->TimeDateStamp = peHdr.FileHeader.TimeDateStamp;
        }

        if (peHdr.FileHeader.Characteristics & IMAGE_FILE_DEBUG_STRIPPED) {
            return sheNoSymbols;
        }

        if (peHdr.FileHeader.TimeDateStamp != pVldChk->TimeDateStamp) {
            if (lpszErrText) {
                sprintf(lpszErrText,
                        "*** WARNING: symbols timestamp is wrong 0x%08x 0x%08x",
                        peHdr.FileHeader.TimeDateStamp,
                        pVldChk->TimeDateStamp);
            }

            return sheBadTimeStamp;
        }
    } else if (fPeDbg) {
        IMAGE_SEPARATE_DEBUG_HEADER sepHdr;

        if ((SYSeek(hFile, 0, SEEK_SET) != 0) ||
            (SYReadFar(hFile, (LPB) &sepHdr, sizeof(sepHdr)) != sizeof(sepHdr))) {
            return sheNoSymbols;
        }

        if (sepHdr.TimeDateStamp != pVldChk->TimeDateStamp) {
            if (lpszErrText) {
                sprintf(lpszErrText,
                        "*** WARNING: symbols timestamp is wrong 0x%08x 0x%08x",
                        sepHdr.TimeDateStamp,
                        pVldChk->TimeDateStamp);
            }

            return sheBadTimeStamp;
        }
    } else {
            return sheNoSymbols;
        }

    return sheNone;
}


BOOL
OLUnloadOmf(
    LPEXG lpexg
    )
{
    ULONG i;
    // Cleanup the Module table;
    for (i = 1; i <= lpexg->cMod; i++) {
        KillMdsNode(&lpexg->rgMod[i]);
    }

    if (lpexg->rgMod) {
        MHFree(lpexg->rgMod);
        lpexg->rgMod = NULL;
        lpexg->cMod = 0;
    }

    // module map info
    if (lpexg->lpsgd) {
        MHFree(lpexg->lpsgd);
        lpexg->lpsgd = NULL;
        lpexg->csgd = 0;
    }

    //
    if (lpexg->lpsge) {
        MHFree(lpexg->lpsge);
        lpexg->lpsge = NULL;
    }

    if (lpexg->lpbData) {
        // Depending on how we got the data, free it.

        if (lpexg->pvSymMappedBase) {
            // Mapped view of file.
            UnmapViewOfFile(lpexg->pvSymMappedBase);
            lpexg->pvSymMappedBase = NULL;
        } else {
            if (lpexg->fSymConverted) {
                // Converted from coff/sym file
                LocalFree(lpexg->lpbData);
            } else {
                // Read the blob in from disk
                MHFree(lpexg->lpbData);
            }
        }

        lpexg->lpbData = NULL;
    }

    // OSDebug 4 FPO info
    if (lpexg->debugData.lpRtf) {
        MHFree(lpexg->debugData.lpRtf);
        lpexg->debugData.lpRtf = NULL;
    }

    if (lpexg->debugData.lpOmapFrom) {
        MHFree(lpexg->debugData.lpOmapFrom);
        lpexg->debugData.lpOmapFrom = NULL;
    }

    if (lpexg->debugData.lpOmapTo) {
        MHFree(lpexg->debugData.lpOmapTo);
        lpexg->debugData.lpOmapTo = NULL;
    }

    if (lpexg->debugData.lpSecStart) {
        MHFree(lpexg->debugData.lpSecStart);
        lpexg->debugData.lpSecStart = NULL;
    }

    // Segment map info
    if (lpexg->lpgsi) {
        if (lpexg->ppdb) {
            MHFree (lpexg->lpgsi);
        }
        lpexg->lpgsi = NULL;
    }

    // Source Module information
    if (lpexg->lpefi) {
        if (lpexg->ppdb) {
            MHFree(lpexg->lpefi);
        }
        lpexg->lpefi = NULL;
    }

    // Type Info array

    lpexg->citd = 0;
    lpexg->rgitd = NULL;

    // Publics, Globals, and Statics

    KillGst(&lpexg->gstPublics);
    KillGst(&lpexg->gstGlobals);
    KillGst(&lpexg->gstStatics);

    // If there's PDB info, clean up and close

    if (lpexg->ppdb) {
        if (lpexg->pgsiPubs) {
            if (!GSIClose(lpexg->pgsiPubs)) {
                assert(FALSE);
            }
            lpexg->pgsiPubs = 0;
        }

        if (lpexg->pgsiGlobs) {
            if (!GSIClose(lpexg->pgsiGlobs)) {
                assert(FALSE);
            }
            lpexg->pgsiGlobs = 0;
        }

        if (lpexg->pdbi) {
            if (!DBIClose(lpexg->pdbi)) {
                assert(FALSE);
            }
            lpexg->pdbi = 0;
        }

        if (lpexg->ptpi) {
            if (!TypesClose(lpexg->ptpi)) {
                assert(FALSE);
            }
            lpexg->ptpi = 0;
        }

        if (lpexg->pstabUDTSym) {
            STABClose(lpexg->pstabUDTSym);
            lpexg->pstabUDTSym = 0;
        }

        if (!PDBClose(lpexg->ppdb)) {
            assert(FALSE);
        }

        lpexg->ppdb = 0;
    }

    lpexg->fOmfLoaded = 0;

    return TRUE;
}

cassert(offsetof(OffMap,offOld) == 0);

int __cdecl
sgnCompareOffsFromOffMap(
    const void *  pOff1,
    const void *  pOff2
    )
{
    ULONG   off1 = POffMap(pOff1)->offOld;
    ULONG   off2 = POffMap(pOff2)->offOld;

    if (off1 < off2)
        return -1;
    if (off1 > off2)
        return 1;
    return 0;
}

void
FixupHash(
    SymConvertInfo &    sci,
    SHT &               sht
    )
{
    // for every offset in the hash, we need to fixup the offset which
    // references the old 16-bit pool with the associated new one for the
    // new pool of 32-bit types.
    assert(sht.HashIndex);
    assert(sci.cSyms);
    assert(sci.rgOffMap);

    unsigned    iBucketMax = sht.ccib;

    for (unsigned iBucket = 0; iBucket < iBucketMax; iBucket++) {
        unsigned    offChain = sht.rgib[iBucket];
        unsigned    iulpMax = sht.rgcib[iBucket];
        for (unsigned iulp = 0; iulp < iulpMax; iulp++, offChain += sizeof ULP ) {
            LPULP   pulp = LPULP(LpvFromAlmLfo(sht.lpalm, offChain));

            POffMap poffmap = POffMap(
                bsearch(
                    &pulp->ib,
                    sci.rgOffMap,
                    sci.cSyms,
                    sizeof OffMap,
                    sgnCompareOffsFromOffMap
                    )
                );
            // we should always find it
            assert(poffmap);
            if (poffmap) {
                pulp->ib = poffmap->offNew;
            }
        }
    }
}

//
// this routine will do all the post processing for the inter-relationships
// that exist between the module symbols and the global syms.  The global
// syms include procref and dataref records that include offsets into the
// module symbols.  We have to fix up those offsets to refer to the new
// offsets.  Each of these mappings is stored in the MDS structure and can
// be released after this operation.
//
// the hash offsets for the globals, publics, and statics are also fixed up here
//
void
FixupGst(
    LPEXG   pexg,
    GST &   gst,
    BOOL    fFixupRefSyms
    )
{
    assert(pexg->pwti);

    if (!gst.lpalm)
        return;

    // first off, we check to see if we need to and can fixup the refsyms
    // that may be present.
    if (fFixupRefSyms) {
        for (
            SYMPTR  psym = SYMPTR(gst.lpalm->pbData);
            psym;
            psym = GetNextSym(psym, gst.lpalm)
        ) {
            unsigned    rectyp = psym->rectyp;
            if (rectyp == S_PROCREF || rectyp == S_LPROCREF || rectyp == S_DATAREF) {
                // fix up the ibSym from the module's array of offset mappings
                REFSYM &            refsym = *(REFSYM *)psym;
                SymConvertInfo &    sci = pexg->rgMod[refsym.imod].sci;

                POffMap poffmap = POffMap(
                    bsearch(
                        &refsym.ibSym,
                        sci.rgOffMap,
                        sci.cSyms,
                        sizeof OffMap,
                        sgnCompareOffsFromOffMap
                        )
                    );
                // we should always find it.
                assert(poffmap);
                if (poffmap) {
                    refsym.ibSym = poffmap->offNew;
                }
            }
        }
    }

    // next, we check our hash tables and fix up all of the offsets there.
    if (gst.shtName.HashIndex) {
        // fixup name hash
        FixupHash(gst.sci, gst.shtName);
    }
    if (gst.shtAddr.HashIndex) {
        // fixup address hash
        FixupHash(gst.sci, gst.shtAddr);
    }
}


SHE
SheFixupConvertedSyms(
    LPEXG   pexg
    )
{
    // for each of the symbol blocks, iterate over all symbols,
    // and if they are REFSYMs of some sort, we go to the appropriate
    // module's sci.rgoffmap to find what new offset we need to plug into
    // the REFSYM.ibSym field.

    FixupGst(pexg, pexg->gstGlobals, TRUE);
    FixupGst(pexg, pexg->gstStatics, TRUE);
    FixupGst(pexg, pexg->gstPublics, FALSE);

    // we can safely get rid of all of our offmap buffers.

    // first, the module ones.
    unsigned    imod = 0;
    unsigned    imodMax = pexg->cMod;

    while (imod < imodMax) {
        MDS &   mds = pexg->rgMod[imod];
        if (mds.sci.rgOffMap) {
            MHFree(mds.sci.rgOffMap);
            mds.sci.rgOffMap = 0;
        }
        imod++;
    }

    // now, the gst versions
    if (pexg->gstGlobals.sci.rgOffMap) {
        MHFree(pexg->gstGlobals.sci.rgOffMap);
        pexg->gstGlobals.sci.rgOffMap = 0;
    }

    if (pexg->gstStatics.sci.rgOffMap) {
        MHFree(pexg->gstStatics.sci.rgOffMap);
        pexg->gstStatics.sci.rgOffMap = 0;
    }

    if (pexg->gstPublics.sci.rgOffMap) {
        MHFree(pexg->gstPublics.sci.rgOffMap);
        pexg->gstPublics.sci.rgOffMap = 0;
    }

    return sheNone;
}

void
ConvertGlobal16bitSyms(
    WidenTi *           pwti,
    LPGST               pgst,
    PB                  pbSymSrc,
    ULONG               cbSymSrc
    )
{
    SymConvertInfo &    sci = pgst->sci;

    memset ( &sci, 0, sizeof sci );
    if (pwti->fQuerySymConvertInfo(sci, pbSymSrc, cbSymSrc)) {
        // allocate the needed memory
        sci.pbSyms = PB(MHAlloc(sci.cbSyms));
        sci.rgOffMap = POffMap(MHAlloc(sci.cSyms * sizeof OffMap));
        if (sci.pbSyms && sci.rgOffMap) {
            memset(sci.pbSyms, 0, sci.cbSyms);
            memset(sci.rgOffMap, 0, sci.cSyms * sizeof OffMap);
            if (pwti->fConvertSymbolBlock(sci, pbSymSrc, cbSymSrc)) {
                // all cool, set up the ALM.
                pgst->lpalm = BuildALM(
                    FALSE,
                    0,
                    sci.pbSyms,
                    sci.cbSyms,
                    cbAlign);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\shinc.hpp ===
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <share.h>
#include <io.h>
#include <dos.h>
#include <malloc.h>
#include <errno.h>
#include <windows.h>

#if !defined(UNALIGNED)
#if defined(_MIPS_) || defined(_ALPHA_)
#define UNALIGNED __unaligned
#else
#define UNALIGNED
#endif
#endif

#ifdef _MBCS
#include <mbstring.h>
#else // _MBCS
#include <string.h>
#endif // _MBCS

#include <tchar.h>

#include <memory.h>
#include <stdarg.h>
#include <fcntl.h>

#include "vcbudefs.h"
#include "pdb.h"
#include "types.h"
#include "cvtypes.h"
#include "cvinfo.h"
#include "cv.h"
//#include "cvexefmt.h"
#include "shapi.h"
#include "sapi.hxx"
#include "cvproto.hxx"
#include "shiproto.hxx"
#ifndef ACTIVEDBG
#include "shassert.h"
#else
#include "assert.h"
#endif

typedef REGREL32 *LPREGREL32;

#ifdef DEBUGVER
#undef LOCAL
#define LOCAL
#else
#define LOCAL static
#endif

//
// For IceCAP builds, make everything public.
//

#if PROFILE
	#ifdef LOCAL
		#undef LOCAL
	#endif
	#define LOCAL
#endif

#ifdef ACTIVEDBG
	#if DBG_API_VERSION !=7
	#error DBG_API_VERSION
	#error Building AD2 version with VC5/VC6 langapi
	#endif
#else // ACTIVEDBG
	#if DBG_API_VERSION !=6
	#error Building VC6 OSDebug version with VC7 langapi
	#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\sh.cpp ===
//  SH.CXX - Symbol Handler: Low level management
//
//      Copyright (C)1991-94, Microsoft Corporation
//
//      Purpose: Provide layer between SH functions and linked list manager.
//
//  Notes: Also included are fixup/unfixup functions until OSDEBUG is on-line.
//
//      DESCRIPTION OF INITIALIZATION CALLING SEQUENCE
//      ----------------------------------------------
//      During startup of debugging a user application, a large number of
//      Symbol Handler functions need to be called.  Here is the order in
//      which it makes sense to call them, and what they do:
//
//      (1) SHCreateProcess
//                  To create a handle for the new debuggee process which
//                  is being debugged.
//      (2) SHSetHpid
//                  This doesn't have to be called right now, but it should
//                  be called as soon as the HPID of the debuggee is known.
//      (3) SHAddDll
//                  Call this a number of times: once for the EXE which is
//                  being debugged, and once for each DLL being debugged
//                  (e.g., in CodeView, for all the /L xxxx.DLL files).
//                  This doesn't load the symbolic information off disk;
//                  it just lets the SH know that these files are being
//                  debugged.
//      (4) SHAddDllsToProcess
//                  This associates all added DLLs with the added EXE, so
//                  the SH knows that they are all being debugged as part
//                  of the same process.
//      (5) SHLoadDll
//                  Call this once for the EXE and each DLL, passing FALSE
//                  for the fLoading parameter.  This actually loads the
//                  symbolic information off disk.
//      (6) Start debuggee running
//      (7) SHLoadDll
//                  Call this for EXEs/DLLs as notifications are received
//                  indicating that they have been loaded into memory.
//                  This time, pass TRUE for the fLoading parameter.
//      (8) SHUnloadDll
//                  Call this for EXEs/DLLs as notifications are received
//                  indicating that they have been unloaded from memory.
//                  This does not actually unload the symbolic information.
//
//
//  Revision History:
//
//      07-Nov-94 BryanT
//          Merge in NT changes.  Changes include: removing PASCAL/LOADDS/FAR/NEAR
//          references.  Calls to STRxxx and MEMxxx functions (use strxxx/memxxx)
//          Replace calls to SHSplitPath with splitpath.  Remove non-WIN32 host
//          support.  Change EXS structure to EXE.  LLLock(hexe) yields a lpexe like
//          all other Handles do.  Eliminate need for EXR structure.  Consolidate
//          several static locals into global xxxCache variables so they can be
//          cleared when a process terminates (for multiprocess support).
//          Remove single user for SHHexeRemove (it can be done in place).
//          Add a vldChk arg to SHAddDllExt so one can pass a timestamp/checksum
//          to be used for image lookup.
//          Store just the name in exg.lszModule (SHAddDllExt).  The full path is
//          still stored in exg.lszName.  Needed for cmd window support.
//          Remove hlliMds references.  Rather than use the LL code, change
//          loadomf.cpp to keep an array with the index stored in each node
//          (no need to iterate to find, etc).
//          Define SHGetModule (used for ntsd syntax support)
//          Remove the dual global Exg lists and replace with a single one
//          Rewrite LoadDll to handle symbol sharing and multiple processes.
//          Add SHLszGetErrorText (to return the error message for an SH error code)
//          Add SHWantSymbols (To allow other parts of the debugger to indicate
//          symbols s/b loaded for a module).
//          Change SHChangeProcess to return the old HPDS.
//
//      [untagged] 21-Oct-93 MarkBro
//
//          Added SHUnloadSymbolHandler for NB10 notifications. Can
//          also be used in the future to free up memory so symbol
//          handler doesn't need to be free'd and reloaded.
//
//      [02] 05-Mar-93 DanS
//
//          Added critical section for win32 build.
//
//      [01] 31-dec-91 DavidGra
//
//          Fix bug with far addresses being unfixed up in the disassembler
//          when passed through the symbol handler.
//
//      [00] 11-dec-91 DavidGra
//
//          Make SHAddDll return an she indicating file not found or
//          out of memory or success.  Create SHAddDllExt to handle
//          the internal support and thunk it with SHAddDll to keep
//          the API the same.

#include "shinc.hpp"
#pragma hdrstop
#ifdef ACTIVEDBG
#define V7_ASSERT(_x)	assert(_x)
#define V6_ASSERT(_x)
#else
#define V7_ASSERT(_x)
#define V6_ASSERT(_x)	assert(_x)
#endif

#include "xboxdbg.h"

#include "strings.h"

HLLI    HlliPds;                // List of processes
HPDS    hpdsCur;                // Current process which is being debugged
HPID    hpidCurr;               // Current PID
MODCACHE    ModCache;           // Last module returned from SHHextFromHmod
LINECACHE   LineCache;          // Last Linenumber from SLFLineToAddr
HSFCACHE    HsfCache;           // Last Hsf returned from SLHmodFromHsf
CXTCACHE    CxtCache;           // Last Context info from SHSetCxtMod
SLCACHE     SlCache;            // Last Addr info from SLCAddrFromLine
ADDRCACHE   AddrCache;          // Last Line info from SLLineFromAddr

static HLLI HlliExgExe;
//static char rgchFile [_MAX_CVPATH];
//static INT  fhCur = -1 ;
extern BOOL fQueriedRegistry;

#define MATCH_NAMEONLY  1
#define AllocAlign(cb) ( (PVOID) (((DWORD) MHAlloc(cb+1) + 1) & 0xFFFFFFFE) )


// UNDONE: Investigate moving the cache data into the exg, exe, or mds struct.

VOID VoidCaches(VOID);

//  VoidCaches
//
//  Purpose: Reinitialized the various caches to a known state

VOID
VoidCaches(
    VOID
    )
{
    memset(&LineCache, 0, sizeof(LineCache));
    memset(&AddrCache, 0, sizeof(AddrCache));
    memset(&ModCache, 0, sizeof(ModCache));
    memset(&HsfCache, 0, sizeof(HsfCache));
    memset(&CxtCache, 0, sizeof(CxtCache));
    if (SlCache.lpslp) {
        MHFree(SlCache.lpslp);
    }
    memset(&SlCache, 0, sizeof(SlCache));
    SlCache.cslp = -1;
}

//  SHCreateProcess
//
//  Purpose: Create a handle for a new debuggee process.  The debuggee
//           process doesn't actually have to be running yet; this is
//           just an abstract handle for the Symbol Handler's use, so
//           that it can keep track of symbols for multiple debuggee
//           processes at the same time.
//
//  Output:
//      Returns an HPDS, a handle to the new process, or 0 for failure.

HPDS
SHCreateProcess (
    VOID
    )
{
    HPDS hpds = SHFAddNewPds();
    SHChangeProcess(hpds);

    return hpds;
}

//  SHSetHpid
//
//  Purpose: Tell the SH what HPID to assign to the current process.
//           Each debuggee process has an HPID, and this call associates
//           an HPID with a HPDS in the SH.
//  Input:  hpid    The HPID to make current.

VOID
SHSetHpid (
    HPID hpid
    )
{
    LPPDS lppds = (LPPDS) LLLock(hpdsCur);

    lppds->hpid = hpidCurr = hpid;

    LLUnlock(hpdsCur);
}

//  SHDeleteProcess
//
//  Purpose: Delete a debuggee process handle (HPDS).  Removes it from
//          the SH's internal list of HPDS's.
//
//  Input:  hpds    The HPDS to delete.
//
//  Output:
//      TRUE for success, FALSE for failure.

BOOL
SHDeleteProcess (
    HPDS hpds
    )
{
    HPDS hpdsT = hpdsCur;
    HPID hpidT = hpidCurr;

    SHChangeProcess (hpds);

    LLDelete(HlliPds, hpdsCur);

    if (hpdsT != hpdsCur) {
        hpdsCur  = hpdsT;
        hpidCurr = hpidT;
    } else {
        hpdsCur = LLNext (HlliPds, NULL);
        if ( hpdsCur != 0 ) {
            LPPDS lppds = (LPPDS) LLLock (hpdsCur);
            hpidCurr = lppds->hpid;
            LLUnlock (hpdsCur);
        }
    }

    return TRUE;
}

//  SHChangeProcess
//
//  Purpose: Change the current debuggee process handle (HPDS).  The SH
//           can maintain symbols for multiple processes; this sets which
//           one is current, so that symbol lookups will be done on the
//           right set of symbolic information.
//
//  Input:  hpds    The HPDS to make current.

HPDS
SHChangeProcess(
    HPDS hpds
    )
{
    LPPDS lppds;
    HPDS  hpdsLast = hpdsCur;

    hpdsCur = hpds;

    lppds = (LPPDS) LLLock (hpdsCur);

    hpidCurr = lppds->hpid;

    LLUnlock (hpdsCur);
    return(hpdsLast);
}


BOOL
FInitLists (
    VOID
    )
{
    // Create the pds list
    HlliPds    = LLInit ( sizeof ( PDS ), 0, KillPdsNode, CmpPdsNode );
    HlliExgExe = LLInit ( sizeof ( EXG ), 0, KillExgNode, CmpExgNode );

    return HlliPds && HlliExgExe;
}

//  KillPdsNode
//
//  Purpose: Destroy private contents of a process node
//
//  Input:  pointer to node data
//
//  Notes: Only data in the pds structure to destroy is a list of exe's.

VOID
KillPdsNode (
    PVOID lpvPdsNode
    )
{
    LPPDS lppds = (LPPDS) lpvPdsNode;

    LLDestroy ( lppds->hlliExe );
}

int
CmpPdsNode (
    PVOID lpv1,
    PVOID lpv2,
    LONG lParam
    )
{
    LPPDS lppds   = (LPPDS) lpv1;
    HPID  *lphpid = (HPID *) lpv2;
    Unreferenced (lParam);

    return !(lppds->hpid == *lphpid);
}

VOID
KillAlm(
    LPALM lpalm
    )
{
    if (lpalm) {
        MHFree ( lpalm );
    }
}

VOID
KillSht(
    LPSHT lpsht
    )
{
    if (lpsht) {
        if (lpsht->rgib) {
            lpsht->rgib = 0;
        }

        if (lpsht->rgcib) {
            lpsht->rgcib = 0;
        }

        KillAlm (lpsht->lpalm);
        lpsht->lpalm = 0;
    }
}

#if CC_CVTYPE32
VOID
KillSci(
    SymConvertInfo & sci
    )
{
    if (sci.rgOffMap)
        MHFree(sci.rgOffMap);
    if (sci.pbSyms)
        MHFree(sci.pbSyms);
    memset(&sci, 0, sizeof sci);
}
#endif

VOID
KillGst(
    LPGST lpgst
    )
{
    if (lpgst) {
        KillSht ( &lpgst->shtName );
        KillSht ( &lpgst->shtAddr );
        KillAlm ( lpgst->lpalm );
#if CC_CVTYPE32
        KillSci ( lpgst->sci );
#endif
        lpgst->lpalm = 0;
    }
}

//  KillExgNode
//
//  Purpose: Destroy information contained in an exe node
//
//  Input: pointer to node data

VOID
KillExgNode (
    PVOID lpvExgNode
    )
{
    LPEXG   lpexg = (LPEXG) lpvExgNode;
    DWORD   i;

    // Debug info file name
    if (lpexg->lszDebug) {
        MHFree (lpexg->lszDebug);
        lpexg->lszDebug = 0;
    }

    // .exe/.com file name
    if (lpexg->lszName) {
        MHFree (lpexg->lszName);
        lpexg->lszName = 0;
    }

    // AltName

    if (lpexg->lszAltName) {
        MHFree(lpexg->lszAltName);
        lpexg->lszAltName = 0;
    }

    // Pdb name
    if (lpexg->lszPdbName) {
        MHFree (lpexg->lszPdbName);
        lpexg->lszPdbName = 0;
    }

    // Type table
    if (lpexg->lpalmTypes) {
        KillAlm(lpexg->lpalmTypes);
        lpexg->lpalmTypes = 0;
    }

    // Free up memory associated with the dll name
    if (lpexg->lszModule) {
        MHFree ( lpexg->lszModule );
        lpexg->lszModule = 0;
    }

#if CC_CVTYPE32
    if (lpexg->pwti) {
        lpexg->pwti->release();
        lpexg->pwti = 0;
    }
#endif

    // Nuke the OMF symbolic.

    OLUnloadOmf(lpexg);

    // And any possible cache references to this module.

    VoidCaches();
}

LSZ
NameOnly(
    LSZ    lsz
    )
{
    LSZ p;

    p = lsz + _tcslen(lsz);

    // Search from the end back for the path delimiter.
    while ( p > lsz && *p != '\\' && *p != ':' ) {
        p = _tcsdec(lsz, p);
    }

    if (p > lsz) {
        // We're pointing at the delimiter.  Move forward one.
        p = _tcsinc(p);
    }

    return p;
}

//  CmpExgNode
//
//  Purpose: Compare global exe nodes
//
//  Input: pointer to node data

int
CmpExgNode (
    PVOID lpv1,
    PVOID lpv2,
    LONG lParam
    )
{
    LPEXG   lpexg1 = (LPEXG) lpv1;
    LSZ     lsz1   = lpexg1->lszName;
    LSZ     lsz2   = (LSZ) lpv2;

    if (lParam == MATCH_NAMEONLY) {
        lsz1 = NameOnly(lsz1);
        lsz2 = NameOnly(lsz2);
    }

    return _tcsicmp(lsz1, lsz2);
}


//  KillExeNode
//
//  Purpose: Destroy information contained in an exe node
//
//  Input: pointer to node data

VOID
KillExeNode(
    PVOID     lpvExeNode
    )
{
    // REVIEW: when a process dies at startup (missing dll for ex) , this ends up being
    // non-NULL because SHUnloadDll does not get called. We should re-enable this
    // later.
    // assert (((LPEXE)lpvExeNode)->pDebugData == NULL);

    // All we need to do is flush the global cache (in case we're still in it)

    VoidCaches();
}


int
CmpExeNode(
    PVOID     lpv1,
    PVOID     lpv2,
    LONG    l
    )
{
    LPEXE   lpexe1 = (LPEXE) lpv1;

    Unreferenced(l);

    return !(lpexe1->hexg == (HEXG) lpv2);
}

//  KillMdsNode
//
//  Purpose: Free up memory allocations associated with node
//
//  Input:  pointer to the mds node

VOID
KillMdsNode (
    PVOID lpvMdsNode
    )
{
    LPMDS   lpmds = (LPMDS)lpvMdsNode;

    if (lpmds->name) {
        MHFree (lpmds->name);
        lpmds->name = 0;
    }

    if (lpmds->lpsgc) {
        MHFree (lpmds->lpsgc);
        lpmds->lpsgc = 0;
    }

    if (lpmds->symbols) {
        if (lpmds->pmod) {
            // For PDB, symbols is a copy.
            MHFree(lpmds->symbols);
        }
#if CC_CVTYPE32
        KillSci(lpmds->sci);
#endif
        lpmds->symbols = 0;
        lpmds->cbSymbols = 0;
    }

    if (lpmds->hst) {
        //  Just a pointer to the cv data
        if (lpmds->pmod) {
            // if we are not using pdbs the hst just points
            // into lpexg->lpbData and so shouldn't be freed.
            MHFree (lpmds->hst);
        }

        lpmds->hst = 0;
    }

    if (lpmds->pmod) {
        if (!ModClose(lpmds->pmod)) {
            assert (FALSE);
        }
        lpmds->pmod = 0;
    }
}

//  CmpMdsNode
//
//  Purpose: To compare two mds nodes.
//
//  Input:
//      lpv1   far pointer to first node
//      lpv2   far pointer to second node
//      lParam comparison type ( MDS_INDEX is only valid one, for now)
//
//  Output: Returns zero if imds are equal, else non-zero

int
CmpMdsNode (
    PVOID lpv1,
    PVOID lpv2,
    LONG lParam
    )
{
    LPMDS   lpmds1 = (LPMDS) lpv1;
    LPMDS   lpmds2 = (LPMDS) lpv2;

    assert (lParam == MDS_INDEX);

    return lpmds1->imds != lpmds2->imds;
}


//  SHHexgFromHmod
//
//  Purpose: Get the hexg from the specified mds handle
//
//  Input: handle to a VALID mds node
//
//  Output: handle to the hmod's parent (hexe)

HEXG
SHHexgFromHmod (
    HMOD hmod
    )
{
    HEXG    hexg;

    assert(hmod);

    hexg = ((LPMDS)hmod)->hexg;
    return hexg;
}


//  SHHexeFromHmod
//
//  Purpose: Get the hexe from the specified module handle
//
//  Input: handle to a VALID mds node
//
//  Output: handle to the hmod's parent (hexe)

HEXE
SHHexeFromHmod (
    HMOD hmod
    )
{
    HEXG    hexg;
    LPEXG   lpexg;
    LPPDS   lppds;

    if (hmod == NULL) {
        return hexeNull;
    }

    // If this isn't the same hmod or hpds as last time, look up
    // the hexe in current process list and return.

    if ((hmod != ModCache.hmod) || (hpdsCur != ModCache.hpds)) {
        hexg = ((LPMDS) hmod)->hexg;

        if (hexg != NULL) {
            ModCache.hmod = hmod;
            ModCache.hpds = hpdsCur;
            lppds = (LPPDS) LLLock(hpdsCur);
            ModCache.hexe = LLFind(lppds->hlliExe, 0, (PVOID) hexg, 0L);
            LLUnlock(hpdsCur);
        }
    }

    return ModCache.hexe;
}

//  SHGetExeName
//
//  Purpose: Get the exe name for a specified hexe
//
//  Input: handle to the exe node
//
//  Output: pointer to the exe's full path-name file

LSZ
SHGetExeName (
    HEXE hexe
    )
{
    LSZ     lsz;
    HEXG    hexg;
    LPEXG   lpexg;

    assert(hpdsCur && hexe);

    if (!hexe || !VerifyHexe(hexe))
    {
        return(NULL);
    }


    hexg = ((LPEXE) LLLock (hexe))->hexg;
    lpexg = (LPEXG) LLLock(hexg);

    // If there's an alternate name (as in kernel debugging when hal.dll
    // may really be halmp or halncr or...), use it.

    if (lpexg->lszAltName) {
        lsz = lpexg->lszAltName;
    } else {
        lsz = lpexg->lszName;
    }

    // Bypass the fake "#:\" drive letter the DM added for a remote drive

    if (lsz[0] == '#' && lsz[1] == ':' && lsz[2] == '\\') {
        lsz += 3;
    }

    LLUnlock (hexe);
    LLUnlock (hexg);

    return lsz;
}

//  SHGetModNameFromHexe
//
//  Purpose: Get the module name from the specified hexe
//
//  Input:  handle to the exe node
//
//  Output: pointer to the exe's module name

LSZ
SHGetModNameFromHexe(
    HEXE hexe
    )
{
    LSZ     lsz;
    HEXG    hexg;
    LPEXG   lpexg;

    assert(hpdsCur && hexe);

    hexg = ((LPEXE) LLLock(hexe))->hexg;
    lpexg = (LPEXG) LLLock(hexg);
    lsz = lpexg->lszModule;

    LLUnlock (hexe);
    LLUnlock (hexg);

    return lsz;
}

//  SHGetSymFName
//
//  Purpose: Get the symbol file name for the specified hexe
//
//  Input: handle to the exe node
//
//  Output: pointer to the exe's full path-name file

LSZ
SHGetSymFName(
    HEXE hexe
    )
{
    LSZ     lsz;
    HEXG    hexg;
    LPEXG   lpexg;

    assert(hpdsCur && hexe);

    hexg  = ((LPEXE)LLLock(hexe))->hexg;
    lpexg = (LPEXG)LLLock(hexg);
    lsz = lpexg->lszDebug;
    if (!lsz) {
        lsz = lpexg->lszName;
    }

    // Bypass the fake "#:\" drive letter the DM added for a remote drive

    if (lsz[0] == '#' && lsz[1] == ':' && lsz[2] == '\\') {
        lsz += 3;
    }

    LLUnlock(hexe);
    LLUnlock(hexg);

    return lsz;
}

//  SHGetNextExe
//
//  Purpose: Get the handle to the next node in the exe list for the CURRENT
//           process. If the hexe is null, then get the first one in the list.
//
//  Input:  handle to the "previous" node.  If null, get the first one in
//          the exe list.
//
//  Output: Returns a handle to the next node.  Returns NULL if the end of
//          the list is reached (ie: hexe is last node in the list)

HEXE
SHGetNextExe (
    HEXE hexe
    )
{
    HEXE    hexeRet;
    HLLI    hlli;

    if (!hpdsCur)               // check for non-null process [rm]
        return NULL;

    hlli    = ((LPPDS) LLLock (hpdsCur))->hlliExe;
    hexeRet = LLNext (hlli, hexe);
    LLUnlock (hpdsCur);

    return hexeRet;
}

//  SHHmodGetNext
//
//  Purpose: Retrieve the next module in the list.  If a hmod is specified, get
//           the next in the list.  If the hmod is NULL, then get the first module
//           in the exe.  If no hexe is specified, then get the first exe in the list.
//
//  Input:
//      hexe    hexe containing list of hmod's.  If NULL, get first in CURRENT
//              process list.
//      hmod    module to get next in list.  If NULL, get first in the list.
//
//  Output: Returns an hmod of the next one in the list.  NULL if the end of
//          the list is reached.

HMOD
SHHmodGetNext (
    HEXE hexe,
    HMOD hmod
    )

{
    HMOD hmodRet = 0;

    if (!hpdsCur) {
        return hmodRet;
    }

    if (hmod) {
        hmodRet = (HMOD)((LPMDS)hmod + 1);
        if (((LPMDS)(hmodRet))->imds == 0xFFFF) {
            hmodRet = NULL;
        }

        return(hmodRet);
    }

    if (hexe) {
        MDS     *pMds;
        HEXG     hexg;
        LPEXG    lpexg;
        LPEXE    lpexe;

        lpexe = (LPEXE) LLLock(hexe);
        // The test for 10 is arbitrary.  Testing for only NULL
        // may allow some cases to slip through.
        if (lpexe < (LPEXE) 10) {
            return(hmodRet);
        }
        hexg = lpexe->hexg;
        LLUnlock(hexe);

        if (hexg == 0) {
            return(hmodRet);
        }

        lpexg = (LPEXG) LLLock(hexg);
        if (lpexg < (LPEXG) 10) {
            return(hmodRet);
        }

        pMds = lpexg->rgMod;
        if (pMds != NULL) {
            hmodRet = (HMOD) &pMds[1];
			//
			// Assumption: Module (eg foo.dll) will have
			//  >0 compilands( eg foo.obj).
			// 
			// I've seen a pdb that violated this.
			// rajra
			if (((LPMDS)(hmodRet))->imds == 0xFFFF) {
			    hmodRet = NULL;
			}
        }
        LLUnlock(hexg);
    }

    return hmodRet;
}
//  SHFAddNewPds
//
//  Purpose: Create a new process node and make it current!
//
//  Input: Word value to identify pds indexing
//
//  Output: Non-zero if successful, else zero.
//
//  Notes: Creates a new node and initializes private list of exe's.

HPDS
SHFAddNewPds (
    VOID
    )
{
    LPPDS   lppds;
    HPDS    hpds;

    if (hpds = (HIND) LLCreate (HlliPds)) {
        lppds = (LPPDS) LLLock (hpds);
        lppds->hlliExe = LLInit (sizeof(EXE), 0, KillExeNode, CmpExeNode);

        // If the list create failed, destroy the node and return failure
        if (!lppds->hlliExe) {
            LLUnlock (hpds);
            MMFree ((HDEP) hpds);
            hpds = 0;
        } else {
            // Otherwise, add the pds to the list and return success
            LLUnlock(hpds);
            LLAdd (HlliPds, hpds);
            hpdsCur = hpds;
        }
    }
    return hpds;
}

//  SHHexeAddNew
//
//  Purpose: Create and initialize an exe node.
//
//  Input:
//      hpds		Process hexe is assoceiated with
//      hexg		Symbol information for the exe.
//      LoadAddress A value of 0 means the DLL hasn't actually been loaded --
//					we are just pre-loading its symbols
//
//  Output: Returns hexg of newly created node.  NULL if OOM.
//
//	Note:
//		We cannot release HEXEs while debugging.  Even when modules are loaded
//		and unloaded, we cannot release the HEXE because it is the HEMI field
//		of the addr structure.  If the HEXE was removed, all ADDRs in that
//		DLL would silenly become invalid.  We therefore have disabled the
//		refcounting mechanism so that it never unloads an HEXE.  What this
//		means is that when a dll gets re-loaded it will already exist.
//

HEXE
SHHexeAddNew (
    HPDS hpds,
    HEXG hexg,
    DWORD LoadAddress
    )
{
    HEXE    hexe;
    LPEXE   lpexe;
    LPEXG   lpexg;
    HLLI    hlli;

    if (!hpds) {
        hpds = hpdsCur;
    }

    hlli = ((LPPDS)LLLock(hpds))->hlliExe;

    // Ensure that the hexg isn't already in the list
    hexe = LLFind(hlli, 0, (PVOID)hexg, 0L);

    if (!hexe && (hexe = LLCreate (hlli))) {
        // Not already there.  Create one, init the fields, and add it to the list
        lpexe = (LPEXE) LLLock (hexe);
        lpexe->hexg = hexg;
        lpexe->hpds = hpdsCur;
        lpexe->fIsLoaded = LoadAddress ? TRUE : FALSE;
        lpexe->LoadAddress = LoadAddress;
        lpexe->pDebugData = NULL;
        LLAdd (hlli, hexe);
        LLUnlock (hexe);

        // Increment the ref count on the image.
        lpexg = (LPEXG) LLLock(hexg);
#ifdef USE_REFCOUNTING
		lpexg->cRef++;
#endif
        LLUnlock (hexg);
    } else {

		lpexe = (LPEXE) LLLock (hexe);

#ifdef ACTIVEDBG
		assert (!lpexe->fIsLoaded);
		assert (lpexe->LoadAddress == 0);
#endif
		lpexe->LoadAddress = LoadAddress;
        lpexg = (LPEXG) LLLock(hexg);
        lpexg->LoadAddress  = LoadAddress;
        LLUnlock (hexg);
        LLUnlock (hexe);
    }

    LLUnlock (hpds);
    return hexe;
}


//  SHAddDll
//
//  Purpose: Notify the SH about an EXE/DLL for which symbolic information
//           will need to be loaded later.
//
//           During the startup of a debuggee application, this function
//           will be called once for the EXE, and once for each DLL that
//           is used by the EXE.  After making these calls,
//           SHAddDllsToProcess will be called to associate those DLLs
//           with that EXE.
//
//           See the comments at the top of this file for more on when
//           this function should be called.
//
//  Input:
//      lsz     Fully qualified path/file specification.
//      fDll    TRUE if this is a DLL, FALSE if it is an EXE.
//
//  Output:
//      Returns nonzero for success, zero for out of memory.
//
//  Notes:
//      This function does NOT actually load the symbolic information;
//      SHLoadDll does that.

SHE
SHAddDll (
    LSZ lsz,
    BOOL fDll
    )
{
    HEXG hexg = hexgNull;
    SHE  sheRet;

    EnterCriticalSection(&csSh);

    sheRet = SHAddDllExt (lsz, fDll, TRUE, NULL, &hexg);

    LeaveCriticalSection(&csSh);

    return sheRet;
}


//  SHAddDllExt
//
//  Purpose: Notify the SH about an EXE/DLL for which symbolic information
//           will need to be loaded later.
//
//           During the startup of a debuggee application, this function
//           will be called once for the EXE, and once for each DLL that
//           is used by the EXE.  After making these calls,
//           SHAddDllsToProcess will be called to associate those DLLs
//           with that EXE.
//
//           See the comments at the top of this file for more on when
//           this function should be called.
//
//  Input:
//      lsz         Fully qualified path/file specification.
//      fDll        TRUE if this is a DLL, FALSE if it is an EXE.
//      pVldChk     Pointer to a VLDCHK structure. If NULL no checking should
//                  be done.
//      fMustExist  TRUE if success requires that the dll must be found
//                  i.e. the user asked for symbol info for this dll
//                  and would expect a warning if it isn't found.
//
//  Output:
//      [Public interface]
//          Returns nonzero for success, zero for out of memory.
//
//      [Private SAPI interface]
//          Returns HEXG of newly created node, or NULL if out of memory.
//
//  Notes:
//      This function does NOT actually load the symbolic information;
//      SHLoadDll does that.
//
//      This function is used internally, AND it is also exported
//      to the outside world.  When exported, the return value should
//      just be considered a BOOL: zero means out of memory, nonzero
//      means success.

SHE
SHAddDllExt (
    LSZ     lsz,
    BOOL    fDll,
    BOOL    fMustExist,
    VLDCHK *pVldChk,
    HEXG   *lphexg
    )
{
    HEXG            hexg;
    LPEXG           lpexg;
    _TCHAR          szPath [_MAX_CVPATH];

    if (fDll) {
        struct _stat    statT;
        _TCHAR  szDir[_MAX_DRIVE + _MAX_CVDIR];
        _TCHAR  szFile[_MAX_CVPATH];
        _TCHAR  szExt[_MAX_CVEXT];
        _TCHAR  *lpszPath;

        _tsplitpath (lsz, szDir, szDir + _MAX_DRIVE, szFile, szExt);

        _tcscat(szFile, *szExt ? szExt : ".DLL");

        _tcscat (szDir, szDir + _MAX_DRIVE);
        _tfullpath (szPath, szDir, _MAX_CVDIR);
        _tcsupr (szPath);

        lpszPath = szPath;
        lpszPath = _tcsdec(lpszPath, _tcschr(lpszPath, '\0'));

        if (*lpszPath != '\\') {
            _tcscat(szPath, "\\");
        }

        _tcsupr (szFile);
        _tcscat (szPath, szFile);

        if (!*szDir || _tstat (szPath, &statT)) {
            _tsearchenv (szFile, "PATH", szPath);
        }

        if (*szPath == 0) {
            if (fMustExist) {
                *lphexg = hexgNull;
                return sheFileOpen;
            } else {
                // Retain the full path instead of just the filname
                // If we just remember the file name then during
                // a restart when we get the same dll load again
                // the IDE will report an error as the paths don't
                // match.
                _tcscpy (szPath, lsz);
            }
        }
    } else {
        _tcscpy(szPath, lsz);
    }

    hexg = LLFind (HlliExgExe, 0, &szPath, pVldChk ? MATCH_NAMEONLY : 0L);

    // If we have an image and a validity check structure, make
    // sure we have the correct image...

    if ((hexg != hexgNull) && pVldChk) {
        lpexg = (LPEXG) LLLock(hexg);

        // A TimeAndDateStamp field of -1 means we don't care.
        if (pVldChk->TimeDateStamp == 0xffffffff) {
            pVldChk->TimeDateStamp = lpexg->ulTimeStamp;
        }

        if (pVldChk->TimeDateStamp != lpexg->ulTimeStamp) {
            LLUnlock(hexg);
            hexg = hexgNull;
        } else {
            LLUnlock(hexg);
        }
    }

    if ((hexg == hexgNull) &&
        ((hexg = LLCreate (HlliExgExe)) != hexgNull)) {

        lpexg = (LPEXG)LLLock(hexg);

        memset(lpexg, 0, sizeof(EXG));

        lpexg->fOmfLoaded = FALSE;

        if (lpexg->lszModule = (LSZ) MHAlloc (_tcslen(lsz) + 1)) {
            // Skip past the fake "#:\" drive the DM might have added

            if (lsz[0] == '#' && lsz[1] == ';' && lsz[2] == '\\') {
                lsz += 3;
            }
            _tsplitpath(lsz, NULL, NULL, lpexg->lszModule, NULL);
        }

        if (lpexg->lszName = (LSZ) MHAlloc(_tcslen(szPath) + 1)) {
            _tcscpy(lpexg->lszName, (LSZ) szPath);
        }

        if (!lpexg->lszName || !lpexg->lszModule || (*lpexg->lszName == '\0')) {
            // If any of the allocated fields are NULL,
            // then destroy the node and return failure

            KillExgNode((PVOID)lpexg);
            LLUnlock( hexg );
            hexg = hexgNull;
        } else {
            // Otherwise, add the node to the list
            LLAdd (HlliExgExe, hexg);
            LLUnlock(hexg);
        }
    }

    *lphexg = hexg;
    return (hexg == hexgNull) ? sheOutOfMemory : sheNone;
}


//  SHHmodGetNextGlobal
//
//  Purpose: Retrieve the next module in the current PROCESS.
//
//  Input:
//      phexe   Pointer to hexe.  This will be updated.  If NULL, then
//              start at the first exe in the current process.
//      hmod    Handle to mds.  If NULL, set *phexe to the next process.
//              and get the first module in it.  Otherwise get the next
//              module in the list.
//
//  Output: Returns a handle to the next module in the proces list.  Will
//          return hmodNull if the end of the list is reached.

HMOD
SHHmodGetNextGlobal (
    HEXE  *phexe,
    HMOD hmod
    )
{
    assert(hpdsCur);

    do {
        // If either the hexe or hmod is NULL, then on to the next exe.
        if (!*phexe || !hmod) {
            *phexe = SHGetNextExe (*phexe);
            hmod = hmodNull;        // Start at the beginning of the next one
        }

        // If we've got an exe, get the next module
        if (*phexe) {
            hmod = SHHmodGetNext(*phexe, hmod);
        }
    } while(!hmod && *phexe);
    return hmod;
}

//  SHGetSymbol
//
//  Searches for a symbol value in the symbol table containing the seg and off
//
//  Entry conditions:
//      paddrOp:
//          segment and offset of the symbol to be found
//      paddrLoc:
//          assumes that the module variable startaddr is set to the beginning
//            of the code line currently being disassembled.
//      sop:
//          symbol options: what kinds of symbols to match. (???)
//      lpodr:
//          pointer where delta to symbol will be stored as well as
//          near/farness, FPO/NON-FPO, cbProlog and symbol name.
//
//  Exit conditions:
//      *lpdoff:
//          offset from symbol to the address
//      return value:
//          ascii name of symbol, or NULL if no match found

LSZ
SHGetSymbol (
    LPADDR paddrOp,
    LPADDR paddrLoc,
    SOP    sop,
    LPODR  lpodr
    )
{
    CXT   cxt    = {0};
    ADDR  addrT  = *paddrLoc;
    ADDR  addrOp = *paddrOp;

    if (!ADDR_IS_FLAT(addrOp) && GetAddrSeg (addrOp) == 0) {
        return NULL;
    }

    SYUnFixupAddr ( &addrT );

    if (sop & sopStack) {

        // UNDONE: This is the only caller of FindBpOrReg...  Optimize
        if (SHFindBpOrReg (&addrT,
                           GetAddrOff ( addrOp ),
                           S_BPREL32,
                           lpodr->lszName))
        {
            lpodr->dwDeltaOff = 0;
            return lpodr->lszName;
        } else {
            return NULL;
        }
    } else {
        SYUnFixupAddr ( &addrOp );
    }

    cxt.hMod = 0;

    if (sop & sopData) {
        SHSetCxtMod (&addrT, &cxt);
    } else {
        SHSetCxtMod (&addrOp, &cxt);
    }
    cxt.addr = addrOp;

    // get the closest symbol, including locals

    SHdNearestSymbol (&cxt, sop, lpodr);

    if ((sop & sopExact) && lpodr->dwDeltaOff) {
        return NULL;
    } else {
        if (lpodr->dwDeltaOff == CV_MAXOFFSET) {
            return NULL;
        } else {
            return lpodr->lszName;
        }
    }
}


LSZ
SHGetModule (
    LPADDR paddrOp,
    LSZ    rgbName
    )
{
    CXT    cxt = {0};
    ADDR   addrOp = *paddrOp;
    HEXE   hexe;
    HEXG   hexg;
    LPEXG  lpexg;

    rgbName[0] = '\0';
    SYUnFixupAddr (&addrOp);
    cxt.hMod = 0;
    SHSetCxtMod (&addrOp, &cxt);
    if (!cxt.hMod ) {
        return NULL;
    }
    cxt.addr = addrOp;
    hexe = SHHexeFromHmod(cxt.hMod);
    if (hexe) {
        hexg = ((LPEXE) LLLock (hexe))->hexg;
        lpexg = (LPEXG) LLLock(hexg);
        _tcscpy(rgbName, lpexg->lszModule);
        LLUnlock (hexe);
        LLUnlock (hexg);
        return rgbName;
    }

    return NULL;
}


// SHHexeFromName - private function */

HEXE
SHHexeFromName (
    LSZ lszName
    )
{
    BOOL fFound = FALSE;
    HEXE hexe = hexeNull;

    // Find the hexe associated with the libname

    while(!fFound && (hexe = SHGetNextExe (hexe))) {
        HEXG hexg = ((LPEXE)LLLock(hexe))->hexg;
        LLUnlock (hexe);
        fFound = !_tcsicmp (((LPEXG)LLLock(hexg))->lszName, lszName);
        LLUnlock (hexg);
    }

    return fFound ? hexe : hexeNull;
}


//  SHUnloadDll
//
//  Purpose: Mark an EXE/DLL as no longer resident in memory.  The debugger
//           should call this function when it receives a notification from
//           the OS indicating that the module has been unloaded from
//           memory.  This does not unload the symbolic information for the
//           module.
//
//           See the comments at the top of this file for more on when this
//           function should be called.
//
//  Input:  hexe - The handle to the EXE/DLL which was unloaded. After
//                 getting a notification from the OS, the debugger can
//                 determine the HEXE by calling SHGethExeFromName.

VOID
SHUnloadDll (
    HEXE hexe
    )
{
    LPEXE   lpexe;
    LPEXG   lpexg;
    HPDS    hpds;
    HEXG    hexg;
    LPPDS   lppds;

    assert(hexe);
    lpexe = (LPEXE) LLLock (hexe);
    assert(lpexe);
    hexg = lpexe->hexg;
    assert(hexg);
    lpexg = (LPEXG) LLLock (hexg);
    assert(lpexg);
#ifdef USE_REFCOUNTING
    assert(lpexg->cRef);
#endif
    hpds = lpexe->hpds;
    assert(hpds);
    lppds = (LPPDS) LLLock(hpds);
    assert(lppds);

    // Decrement the reference count
#ifdef USE_REFCOUNTING
	lpexg->cRef--;
#endif

    // See if it's in the deferred load queue.  If so, remove it.

    if (lpexg->fOmfDefered) {
        UnloadDefered(hexg);
    }

    // If this exe has exg DEBUGDATA, free it.

    if (lpexe->pDebugData) {
        // Free the copy of the debug data that we got from the exg.

        if (lpexe->pDebugData != &lpexg->debugData) {
            // This must be a fixed up copy
            MHFree(lpexe->pDebugData->lpRtf);
            MHFree(lpexe->pDebugData);
        }
        lpexe->pDebugData = NULL;
    }

#ifdef USE_REFCOUNTING
	if (lpexg->cRef==0)
        lpexe->fIsLoaded = FALSE;
#else // VC5/6 hacks here so that we don't unload anything, ever
	lpexe->fIsLoaded = FALSE;
	lpexe->LoadAddress = 0;
#endif

    LLUnlock(hexg);
    LLUnlock (hexe);
    LLUnlock(hpds);

#ifdef USE_REFCOUNTING
    // If we're the last reference to the module, delete it from the image list.

    if (lpexg->cRef == 0) {
        LLUnlock(hexg);
        LLDelete(HlliExgExe, hexg);
    } else {
        LLUnlock(hexg);
    }

    LLUnlock (hexe);

    // Remove this image from the process list.

    LLDelete(lppds->hlliExe, hexe);
    LLUnlock(hpds);
#endif

    return;
}

//  SHLoadDll
//
//  Purpose: This function serves two purposes:
//
//           (1) Load symbolic information for an EXE/DLL into memory,
//               so its symbols are available to the user.
//           (2) Indicate to the SH whether the EXE/DLL itself is loaded
//               into memory.
//
//           Because it serves two purposes, this function may be called
//           more than once for the same EXE/DLL.  See the comments at
//           the top of this file for more on when this function should
//           be called.
//
//  Input:
//      lszName     The name of the EXE or DLL.
//      fLoading    TRUE if the EXE/DLL itself is actually loaded at this
//                  time, FALSE if not.
//
//  Output:
//      Returns an SHE error code.
//
//	NOTE:
//		The V7 debugger uses SHLoadDllEx (below) not this function.
//

SHE
SHLoadDll (
    LSZ lszName,
    BOOL fLoading
    )
{
    SHE     she = sheNone;
    HEXE    hexe;
    HEXG    hexg = hexgNull;
    LSZ     lsz = lszName;
    LSZ     lsz2 = NULL;
    LSZ     lsz3;
    INT     hfile = -1;
    HEXG    hexgMaybe = hexgNull;
    LSZ     AltName = NULL;
    VLDCHK  vldChk= {0, 0}; // 0 ==> unknown.
    LPEXG   lpexg;
    LSZ     lszFname;
    BOOL    fContinueSearch = TRUE;
    DWORD   dllLoadAddress = 0;

	//
	// V7 (ActiveDebug) should use SHLoadDllEx instead.
	//
	
	V7_ASSERT (FALSE);

    EnterCriticalSection(&csSh);

    // Check for the possiblity that we have a module only name
    //
    // We may get two formats of names.  The first is just a name,
    // no other information.  The other is a big long string
    // for PE exes.
    // The program exe on ALPHA is first passed in as just a name
    // from LoadDebuggee (and ChecEXEForDebug),
    // which results in its load address being incorrectly set to zero.

    if (*lszName == '|') {
        // name
        ++lszName;
        lsz2 = _tcschr(lszName, '|');

        lsz = lsz2;

        if (lsz && *lsz == '|') {
            // timestamp
            vldChk.TimeDateStamp = _tcstoul(++lsz, &lsz, 16);
        }
        if (lsz && *lsz == '|') {
            // checksum
            vldChk.CheckSum = _tcstoul(++lsz, &lsz, 16);
        }
        if (lsz && *lsz == '|') {
            // hfile
            hfile = _tcstoul(++lsz, &lsz, 16);

            // Always close the handle returned from the DM.
            // We'll reopen it iff need be in OlLoadOmf.
            if (hfile != -1) {
                SYClose(hfile);
                hfile = -1;
            }
        }
        if (lsz && *lsz == '|') {
            // image base
            dllLoadAddress = _tcstoul(++lsz, &lsz, 16);
        }
        if (lsz && *lsz == '|') {
            // alternate symbol file name
            lsz++;
            if (*lsz) {
                lsz3 = _tcschr(lsz, '|');
                *lsz3 = 0;
                if (AltName = (LSZ) MHAlloc(_tcslen(lsz) + 1)) {
                    _tcscpy(AltName, (LSZ) lsz);
                }
                *lsz3 = '|';
                lsz = lsz3;
            }
        }

        // isolate name
        if (lsz2) {
            *lsz2 = 0;
        }
    }

    // We can't just call SHExeFromName here because there may be
    // multiple images with the same name (for instance, when debugging
    // more than one process or more than one machine) and we want to
    // to share symbols wherever possible.

    // Look and see if we already have this debug information loaded
    while (fContinueSearch) {
        // Find the next OMF set by name of EXE module
        hexg = LLFind(HlliExgExe, hexg, lszName, MATCH_NAMEONLY);

        if (hexg == hexgNull) {
            fContinueSearch = FALSE;    // Nothing by this name.
        } else {
            // If we found one, do the checksum and timestamp match?

            lpexg = (LPEXG) LLLock(hexg);

            // If the timestamp is set to -1, use whatever this image has.

            if (vldChk.TimeDateStamp == 0xffffffff) {
                vldChk.TimeDateStamp = lpexg->ulTimeStamp;
            }


            // UNDONE: We don't compare LoadAddresses here to ensure they match
            // when the symbols are correct...  Investigate if this is a bug.

            //  Check the timestamp & checksum only if the Omf has been
            //  succesfully loaded

            if (fLoading && lpexg->fOmfLoaded &&
                    ((vldChk.TimeDateStamp != lpexg->ulTimeStamp))
                ) {


#ifdef USE_REFCOUNTING
                // NB: the reference counting mechanism is not correct -- so
                // we cannot use it here.  Fix when we fix ref counting

                // The debug info no longer matches -- check to see if
                // there are any references to the debug info. If not then
                // free it as it has been superceded.

                if ( lpexg->cRef == 0 ) {
                    LLUnlock(hexg);
                    LLDelete(HlliExgExe, hexg);
                    hexg = hexgNull;
                }
                // Keep looking for a match.
#endif
            } else {

                // Timestamp and checksum are valid.  Has the user decided
                // to change the load status of this exe?

                lszFname = lpexg->lszName;

                if (!SYGetDefaultShe(lszFname, &she)) {
                    SYGetDefaultShe(NULL, &she);
                }

                switch (she) {
                    case sheDeferSyms:
                    case sheNone:
                        if (!lpexg->fOmfMissing && !lpexg->fOmfSkipped) {
                            fContinueSearch = FALSE;
                        } else {
                            hexgMaybe = hexg;
                        }
                        break;

                    case sheSuppressSyms:
                        if (lpexg->fOmfMissing || lpexg->fOmfSkipped) {
                            fContinueSearch = FALSE;
                        } else {
                            hexgMaybe = hexg;
                        }
                        break;

                    default:
                        assert((she == sheDeferSyms) ||
                               (she == sheSuppressSyms) ||
                               (she == sheNone));
                        break;
                }
            }

            if (hexg) {
                LLUnlock(hexg);
            }
        }
    }

    // If we did not find an OMF module -- create one

    if (hexg == hexgNull && hexgMaybe == hexgNull) {

        SHAddDllExt (lszName, TRUE, FALSE, fLoading? &vldChk:NULL, &hexg);
        if (hexg == hexgNull) {
            she = sheOutOfMemory;
        }
        else if (SHHexeAddNew (hpdsCur, hexg, dllLoadAddress) == NULL) {
            she = sheOutOfMemory;
        }
        else {
            if (AltName) {
                lpexg = (LPEXG) LLLock(hexg);
                lpexg->lszAltName = AltName;
                LLUnlock(hexg);
            }

            she = OLLoadOmf(hexg, &vldChk, dllLoadAddress);
            VoidCaches();
        }
    } else if (hexg != hexgNull) {

        // We found the OMF lying around

        // If we found a partial match as well, see if it s/b discarded.

        if (hexgMaybe) {

#ifdef USE_REFCOUNTING
        // NB: comments above about #if'ing out reference counting code.

            lpexg = (LPEXG) LLLock(hexgMaybe);
            LLUnlock(hexgMaybe);
            if (lpexg->cRef == 0) {
                LLDelete(HlliExgExe, hexgMaybe);
            }
#endif
        }

        if (SHHexeAddNew(hpdsCur, hexg, dllLoadAddress) == NULL) {
            she = sheOutOfMemory;
        }

        if ( !hexgMaybe )
        {
            lpexg = (LPEXG) LLLock(hexg);
            // REVIEW: The shell can call SHAddDll and later SHLoadDll to actually load
            // the OMF. We have to load the dll in this case. This whole function needs to
            // be revisited.
            if (!lpexg->fOmfLoaded && !lpexg->fOmfMissing)
            {
                OLLoadOmf(hexg, &vldChk, dllLoadAddress);
                VoidCaches();
            }
            LLUnlock(hexg);
        }

        if (fLoading)
        {
            HLLI hlli = ((LPPDS)LLLock(hpdsCur))->hlliExe;
            HEXE hexe = LLFind(hlli, 0, (PVOID)hexg, 0L);
            LLUnlock(hlli);
            if (hexe)
            {
                ((LPEXE)LLLock(hexe))->fIsLoaded = TRUE;
                LLUnlock(hexe);
            }
            LLUnlock(hpdsCur);
        }

        if (hfile != -1) {
            SYClose(hfile);
        }
    } else {
        // Found the right exg, but the wrong load state.
        lpexg = (LPEXG) LLLock(hexgMaybe);
        if (lpexg->fOmfMissing) {
            // no OMF in image.  We can't improve things.
            LLUnlock(hexgMaybe);
            she = sheNoSymbols;
        } else if (lpexg->fOmfSkipped) {

            // decided to load syms this time around.
            LLUnlock(hexgMaybe);
            she = OLLoadOmf(hexgMaybe, &vldChk, dllLoadAddress);
            VoidCaches();
        } else {

            // have syms and want to discard them.
            OLUnloadOmf(lpexg);
            VoidCaches();       // Just in case.
            lpexg->fOmfSkipped = TRUE;
            LLUnlock( hexgMaybe );
            she = sheSuppressSyms;
        }

        if (SHHexeAddNew(hpdsCur, hexgMaybe, dllLoadAddress) == NULL) {
            she = sheOutOfMemory;
        }
    }

    // Restore damage to the input buffer

    if (lsz2 != NULL) {
        *lsz2 = '|';
    }

    LeaveCriticalSection(&csSh);

    return she;
}




//  SHLoadDllEx
//
//  Purpose: This function serves two purposes:
//
//           (1) Load symbolic information for an EXE/DLL into memory,
//               so its symbols are available to the user.
//
//           (2) Indicate to the SH whether the EXE/DLL itself is loaded
//               into memory.
//
//           Because it serves two purposes, this function may be called
//           more than once for the same EXE/DLL.  See the comments at
//           the top of this file for more on when this function should
//           be called.
//
//  Input:
//      lszName     The name of the EXE or DLL.
//      fLoading    TRUE if the EXE/DLL itself is actually loaded at this
//                  time, FALSE if not.
//		TimeStamp	The image's timestamp.
//		CheckSum	The image's checksum.
//		LoadAddress	The image's LoadAddress.
//		lphexe		An out parameter to recieve the HEXE associated with this
//					Dll.
//
//
//  Output:
//      Returns an SHE error code.
//
//	BUGBUG:
//		This function was cut+pasted from SHLoadDll -- there is a ton of
//		duplicate code between them.  One of these functions should die.
//
//	NOTE ALSO:
//		This function is used by V7 NOT V6.  I have put the appropiate asserts
//		in to check this.
//

SHE
SHLoadDllEx (
    LSZ		lszName,
    BOOL	fLoading,
	ULONG	TimeDateStamp,
	ULONG	CheckSum,
	ULONG	LoadAddress,
	HEXE*	lphexe
    )
{
    SHE     she = sheNone;
    HEXE    hexe = NULL;
    HEXG    hexg = NULL;
    HEXG    hexgMaybe = NULL;
    LSZ     AltName = NULL;
    LPEXG   lpexg = NULL;
    LSZ     lszFname = NULL;
    BOOL    fContinueSearch = TRUE;

	//
	// V6 (Msdev) should SHLoadDll instead.
	//
	
	V6_ASSERT (FALSE);
	
    EnterCriticalSection(&csSh);

	assert (*lszName != '|');
	assert (*lszName != '#');
	assert (*lszName != '?');


    // We can't just call SHExeFromName here because there may be
    // multiple images with the same name (for instance, when debugging
    // more than one process or more than one machine) and we want to
    // to share symbols wherever possible.

    // Look and see if we already have this debug information loaded

	while (fContinueSearch) {

		//
        // Find the next OMF set by name of EXE module
		//
		
        hexg = LLFind (HlliExgExe, hexg, lszName, MATCH_NAMEONLY);

        if (hexg == hexgNull) {
		
            fContinueSearch = FALSE;    // Nothing by this name.

		} else {

			//
            // If we found one, do the checksum and timestamp match?
			//

            lpexg = (LPEXG) LLLock (hexg);

            // If the timestamp is set to -1, use whatever this image has.

            if (TimeDateStamp == 0xffffffff) {
                TimeDateStamp = lpexg->ulTimeStamp;
            }

			// NOTE: it is not correct (or relevant) to check the load
			// address.  The load address is a part of the HEXE -- not
			// the HEXG.
			
            // Check the timestamp & checksum only if the Omf has been
            // succesfully loaded

            if (fLoading && lpexg->fOmfLoaded &&
				(TimeDateStamp != lpexg->ulTimeStamp)) {


#ifdef USE_REFCOUNTING

                // NB: the reference counting mechanism is not correct -- so
                // we cannot use it here.  Fix when we fix ref counting

                // The debug info no longer matches -- check to see if
                // there are any references to the debug info. If not then
                // free it as it has been superceded.

                if ( lpexg->cRef == 0 ) {
                    LLUnlock(hexg);
                    LLDelete(HlliExgExe, hexg);
                    hexg = hexgNull;
                }
                // Keep looking for a match.
#endif
            } else {

				//
                // The TimeStamp and CheckSum are valid.  Has the user
				// decided to change the load status of this exe?
				//

                lszFname = lpexg->lszName;

                if (!SYGetDefaultShe (lszFname, &she)) {
                    SYGetDefaultShe (NULL, &she);
                }

                switch (she) {
                    case sheDeferSyms:
                    case sheNone:
                        if (!lpexg->fOmfMissing && !lpexg->fOmfSkipped) {
                            fContinueSearch = FALSE;
                        } else {
                            hexgMaybe = hexg;
                        }
                        break;

                    case sheSuppressSyms:
                        if (lpexg->fOmfMissing || lpexg->fOmfSkipped) {
                            fContinueSearch = FALSE;
                        } else {
                            hexgMaybe = hexg;
                        }
                        break;

                    default:
                        assert((she == sheDeferSyms) ||
                               (she == sheSuppressSyms) ||
                               (she == sheNone));
                        break;
                }
            }

            if (hexg) {
                LLUnlock(hexg);
            }
        }
    }


	VLDCHK	vldChk;
	vldChk.TimeDateStamp = TimeDateStamp;
	vldChk.CheckSum = CheckSum;

	//
	// Three Cases:
	//
	//	hexg == NULL && hexgMaybe == NULL => we did not find an OMF module,
	//		create a new one.
	//
	//	hexg != NULL => we found a match.
	//
	//  otherwise => we found a partial match (hexgMaybe).
	//


	if (hexg == hexgNull && hexgMaybe == hexgNull) {

		//
		// No match.  Create a new OMF.
		//

        SHAddDllExt (lszName, TRUE, FALSE, fLoading ? &vldChk : NULL, &hexg);

		if (hexg == NULL) {
            she = sheOutOfMemory;
			goto exit;
        }
		
        hexe = SHHexeAddNew (hpdsCur, hexg, LoadAddress);

		if (hexe == NULL) {
            she = sheOutOfMemory;
			goto exit;
        }

		if (AltName) {
			lpexg = (LPEXG) LLLock (hexg);
            lpexg->lszAltName = AltName;
            LLUnlock (hexg);
        }

        she = OLLoadOmf (hexg, &vldChk, LoadAddress);
        VoidCaches ();

	} else if (hexg != hexgNull) {

		//
        // We found a matching OMF.
		//

		//
        // If we found a partial match as well, see if it should be discarded.
		//

        if (hexgMaybe) {

#ifdef USE_REFCOUNTING
        // NB: comments above about #if'ing out reference counting code.

            lpexg = (LPEXG) LLLock (hexgMaybe);
            LLUnlock (hexgMaybe);
            if (lpexg->cRef == 0) {
                LLDelete (HlliExgExe, hexgMaybe);
            }
#endif
        }

        hexe = SHHexeAddNew (hpdsCur, hexg, LoadAddress);

		if (hexe == NULL) {
            she = sheOutOfMemory;
			goto exit;
        }


		if (!hexgMaybe) {
		
            lpexg = (LPEXG) LLLock (hexg);

			// REVIEW: The shell can call SHAddDll and later SHLoadDll
			// to actually load the OMF.  We have to load the dll in this
			// case. This whole function needs to be revisited.
			
            if (!lpexg->fOmfLoaded && !lpexg->fOmfMissing) {
                OLLoadOmf (hexg, &vldChk, LoadAddress);
                VoidCaches ();
            }
			
            LLUnlock (hexg);
        }

        if (fLoading) {
		
            HLLI hlli = ((LPPDS)LLLock (hpdsCur))->hlliExe;
            HEXE hexe = LLFind (hlli, 0, (PVOID)hexg, 0L);
            LLUnlock (hlli);

			if (hexe) {
                ((LPEXE)LLLock(hexe))->fIsLoaded = TRUE;
                LLUnlock(hexe);
            }
            LLUnlock (hpdsCur);
        }

    } else {

		//
        // Found the right exg, but the wrong load state.
		//
		
        lpexg = (LPEXG) LLLock (hexgMaybe);
		
        if (lpexg->fOmfMissing) {

			// no OMF in image.  We can't improve things.
			
            LLUnlock (hexgMaybe);
            she = sheNoSymbols;
			
        } else if (lpexg->fOmfSkipped) {

            // decided to load syms this time around.
			
            LLUnlock (hexgMaybe);
            she = OLLoadOmf (hexgMaybe, &vldChk, LoadAddress);
            VoidCaches ();
			
        } else {

            // have syms and want to discard them.
			
            OLUnloadOmf (lpexg);
            VoidCaches ();				// Just in case.
            lpexg->fOmfSkipped = TRUE;
            LLUnlock (hexgMaybe);
            she = sheSuppressSyms;
        }

        hexe = SHHexeAddNew (hpdsCur, hexgMaybe, LoadAddress);

		if (hexe == NULL) {
            she = sheOutOfMemory;
			goto exit;
        }
    }

exit:
	*lphexe = hexe;

    LeaveCriticalSection(&csSh);

    return she;
}

//  SHAddDllsToProcess
//
//  Purpose: Associate all DLLs that have been loaded with the current EXE.
//
//           The debugger, at init time, will call SHAddDll on one EXE
//           and zero or more DLLs.  Then it should call this function
//           to indicate that those DLLs are associated with (used by)
//           that EXE; thus, a user request for a symbol from the EXE
//           will also search the symbolic information from those DLLs.
//
//  Output: Returns an SHE error code.  At this writing, the only legal values
//          are sheNone and sheOutOfMemory.

SHE
SHAddDllsToProcess (
    VOID
    )
{
    SHE  she = sheNone;
    HEXG hexg;

    if (!SHHexeAddNew (hpdsCur, LLLast (HlliExgExe), NULL)) {
        she = sheOutOfMemory;
    } else {
        if (she == sheNone) {
            for (hexg = LLNext (HlliExgExe, hexgNull);
                 (hexg != hexgNull) && (she == sheNone);
                 hexg = LLNext (HlliExgExe, hexg))
            {
                if (!SHHexeAddNew (hpdsCur, hexg, NULL)) {
                    she = sheOutOfMemory;
                    break;
                }
            }
        }
    }

    return she;
}


//  BuildALM
//
//  Purpose: Build an ALM (ALigned Memory) structure.  To be used later on
//           for demand symbol table loads.

LPALM
BuildALM (
    BOOL    fSeq,
    WORD    btAlign,
    LPB     lpbData,
    DWORD   cb,
    WORD    cbBlock
    )
{
    LPALM  lpalm;

    lpalm = (LPALM) AllocAlign (sizeof(ALM) + sizeof(UFOP) + sizeof(WORD));
    if (lpalm == NULL) {
        return NULL;
    }

    lpalm->fSeq         = fSeq;
    lpalm->btAlign      = btAlign;
    lpalm->cb           = cb;
    lpalm->cbBlock      = cbBlock;
    lpalm->pbData       = lpbData;

    return lpalm;
}


PVOID
LpvFromAlmLfo (
    LPALM lpalm,
    DWORD lfo
    )
{
    if (lfo > lpalm->cb) {
        return(NULL);
    } else {
        return lpalm->pbData + lfo;
    }
}


//  GetNextSym
//
//  Purpose: Return the next symbol from a file.  Handle S_ALIGN records as
//          they're encountered.

SYMPTR
GetNextSym (
    SYMPTR psym,
    LPALM  lpalm
    )
{
    SYMPTR psymNext = (SYMPTR) (((LPB) psym) + psym->reclen + sizeof(WORD));

    if ((BYTE *) psymNext > (lpalm->pbData + lpalm->cb)) {
        return(NULL);
    }

    if (psymNext->rectyp == S_ALIGN) {
        // If we hit a S_ALIGN record, skip over it.

        psymNext = (SYMPTR) (((LPB) psymNext) + psymNext->reclen + sizeof(WORD));
    }

    return(psymNext);
}


//  GetSymbols
//
//  Purpose: Return a pointer to the symbols for a module.

PVOID
GetSymbols(
    LPMDS lpmds
    )
{
    PVOID lpvRet = NULL;

    if (lpmds->symbols) {
        lpvRet = lpmds->symbols;
    } else if (lpmds->pmod) {
        // Allocate space for this module's local symbols, then load them
        // from the PDB.

        if (ModQuerySymbols(lpmds->pmod, 0, (CB *)&lpmds->cbSymbols) &&
            (lpmds->symbols = (LPB) MHAlloc(lpmds->cbSymbols))) {

            if (ModQuerySymbols(lpmds->pmod, lpmds->symbols, (CB *)&lpmds->cbSymbols)) {
                lpvRet = lpmds->symbols;
            } else {
                MHFree(lpmds->symbols);
                lpmds->symbols = NULL;
                lpmds->cbSymbols = 0;
            }
        }
    }

    return lpvRet;
}

VOID
SHUnloadSymbolHandler(
    BOOL fResetLists
    )
{
    // Put code here to execute just before
    // the symbol handler is Freed from memory (FreeLibrary...)

    if (HlliPds) {
        LLDestroy(HlliPds);
        HlliPds = NULL;
    }

    hpdsCur = hpdsNull;

    if (HlliExgExe) {
        LLDestroy(HlliExgExe);
        HlliExgExe = NULL;
    }

	fQueriedRegistry = FALSE;			// reload registry info

    if (fResetLists) {
        // If fResetLists, the symbol handler is NOT being unloaded, but
        // the information in the linked lists are no longer valid so we
        // will have destroyed the list info, just reinitialize the lists.

        FInitLists();

    } else {
        // Otherwise, free up the last system resources.

        // Release the symcvt ptr.
#if 0
        if (hLib != NULL) {
            FreeLibrary(hLib);
            hLib = NULL;
        }

        // null out the function pointer
        pfConvertSymbolsForImage = NULL;
#endif
        // cleanup synchronization objects

        DeleteCriticalSection(&csSh);
#if 0
        DeleteCriticalSection(&CsSymbolLoad);
        DeleteCriticalSection(&CsSymbolProcess);
        CloseHandle(hEventLoaded);
#endif
    }
}


//  Get the time stamp of the EXE (which has the CV info)
//
//  Returns: sheFileOpen
//          sheCorruptOmf
//          sheNone

SHE
SHGetExeTimeStamp(
    LSZ     szExeName,
    DWORD*  lplTimeStamp,   OPTIONAL
    DWORD*  lpCheckSum      OPTIONAL
    )
{
    IMAGE_DOS_HEADER    doshdr;         // Old format MZ header
    IMAGE_NT_HEADERS    PEHeader;
    DWORD               dwMagic;
    UINT                hfile;
    SHE                 sheRet = sheNone;
	DM_XBE xbe;

	/* Try as an XBE first */
	if(SUCCEEDED(XbeGetXbeInfo(szExeName, &xbe))) {
		if(lplTimeStamp)
			*lplTimeStamp = xbe.TimeStamp;
		if(lpCheckSum)
			*lpCheckSum = xbe.CheckSum;
		return sheNone;
	}

    if ((hfile = SYOpen (szExeName)) == -1) {
        sheRet = sheFileOpen;
        goto cleanup;
    }

    // Go to beginning of file and read old EXE header

    if (SYReadFar (hfile, (LPB) &doshdr, sizeof(IMAGE_DOS_HEADER)) !=
            sizeof (IMAGE_DOS_HEADER))
    {
        sheRet = sheCorruptOmf;
        goto cleanup;
    }

    // Go to beginning of new header, read it in and verify

    if (doshdr.e_magic == IMAGE_DOS_SIGNATURE) {
        // DOS/Win16/Win32 image with stub.  See if this is a PE image
        //  and read from there.

        if (SYSeek (hfile, doshdr.e_lfanew, SEEK_SET) != doshdr.e_lfanew) {
            sheRet = sheCorruptOmf;
            goto cleanup;
        }
    } else if (doshdr.e_magic == IMAGE_NT_SIGNATURE) {
        // Win32 Image w/o a stub or a ROM image.  restart at the beginning.
        if (SYSeek(hfile, 0, SEEK_SET) != 0) {
            sheRet = sheCorruptOmf;
            goto cleanup;
        }
    }

#if 0
    if ((SYReadFar (hfile, (LPB) &dwMagic, sizeof(dwMagic)) != sizeof(dwMagic)) ||
        (dwMagic != IMAGE_NT_SIGNATURE))
    {
        sheRet = sheCorruptOmf;
        goto cleanup;
    }
#endif

    if (SYReadFar (hfile, (LPB) &PEHeader, sizeof(IMAGE_NT_HEADERS)) !=
         sizeof(IMAGE_NT_HEADERS))
    {
        sheRet = sheCorruptOmf;
        goto cleanup;
    }

    if (lplTimeStamp)
        *lplTimeStamp = PEHeader.FileHeader.TimeDateStamp;

    if (lpCheckSum)
        *lpCheckSum = PEHeader.OptionalHeader.CheckSum;

cleanup:
    if (hfile != -1) {
        SYClose (hfile);
    }
    return sheRet;
}

//  SHLszGetErrorText
//
//  Synopsis:   lsz = SHLszGetErrorText( she )
//
//  Entry:      she - error number to get text for
//
//  Returns:    pointer to the string containing the error text
//
//  Description: This routine is used by the debugger to get the
//              text for an error which occured in the symbol handler.

LSZ
SHLszGetErrorText(
    SHE she
    )
{
    static LSZ const rglsz[] = {
        SzSheNone,
        SzSheNoSymbols,
        SzSheFutureSymbols,
        SzSheMustRelink,
        SzSheNotPacked,
        SzSheOutOfMemory,
        SzSheCorruptOmf,
        SzSheFileOpen,
        SzSheSuppressSyms,
        SzSheDeferSyms,
        SzSheSymbolsConverted,
        SzSheBadTimeStamp,
        SzSheBadChecksum,
        SzShePdbNotFound,
        SzShePdbBadSig,
        SzShePdbInvalidAge,
        SzShePdbOldFormat,
        SzSheConvertTIs
    };

    assert((sizeof(rglsz) / sizeof(*rglsz)) == sheMax);

    if (she < sheMax) {
        return rglsz[she];
    }
    return SzSheBadError;
}

//  SHWantSymbols
//
//  Purpose:    Loads symbols of a defered module
//
//  Input:      HEXE for which to load symbols

BOOL
SHWantSymbols(
    HEXE hexe
    )
{
    HEXG    hexg;
    LPEXE   lpexe;
    LPEXG   lpexg;
    BOOL    fRet = TRUE;

    if (!hexe) {
        fRet = FALSE;
    } else {
        lpexe = (LPEXE)LLLock(hexe);
        hexg  = lpexe->hexg;

        if (!hexg) {
            fRet = FALSE;
        } else {
            lpexg = (LPEXG)LLLock (hexg);

            if (lpexg->fOmfDefered) {
                LoadDefered(hexg);
            }

            LLUnlock (hexg);
        }

        LLUnlock (hexe);
    }

    return fRet;
}

//  SHSplitPath
//
//  Custom split path that allows parameters to be null

VOID
SHSplitPath (
    LSZ lszPath,
    LSZ lszDrive,
    LSZ lszDir,
    LSZ lszName,
    LSZ lszExt
    )
{
    // For 32-bit versions, there's no need for all the extra work
    _tsplitpath(lszPath, lszDrive, lszDir, lszName, lszExt);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\shsymbol.cpp ===
//  shsymbol
//
//  Copyright <C> 1989-94, Microsoft Corporation
//
//      [02] 31-dec-91 DavidGra
//              Add Symbol support for assembler.
//
//      [01] 02-dec-91 DavidGra
//              Pass symbol to compare function when SSTR_symboltype bit
//              is set only when its rectyp field is equal to the symtype
//              field in the SSTR structure.
//
//      [00] 15-nov-91 DavidGra
//              Suppress hashing when the SSTR_NoHash bit it set.
//
//      10-Nov-94 BryanT
//          Merge in NT changes.
//          Replace SPRINTF with sprintf.
//          Change SHAddrFromHsym to ignore S_BPREL16/S_BPREL32/S_REGREL32
//          since the address w/o the stack/register context is useless.
//          SHIsAddrInMod -> IsAddrInMod
//          Change SHSetCxtMod to save the previous value in CxtCache so we
//          can clear it when a process is removed.
//          Change SHGetCxtFromHmod to test for actual code in the mod before
//          setting the context.
//          Add SHGetCxtFromHexe (basically iterate over every hmod and call
//          SHGetCxtFromHmod until successful or out of hmods.
//          Add thunks support to SHGetNearestHsym.  Add default asserts in
//          case something changes.
//          Attempt to simplify the code in SHIsInProlog
//          Provide a shortcut out of SHGoToParent
//          Rewrite SHGethExeFromName to call SHGethExeFromExeName and
//          SHGethExeFromAltName.  Needed for multiple names in the kernel
//          debugger
//          Write SHGethExeFromModuleName
//          Flesh out SHCompareRE
//          Delete DOS compare routines used by the EE.
//          Delete SHIsEmiLoaded (not needed any longer).
//          Remove fChild arg from SHFindNameInContext (all users pass in FALSE)
//          Remove SHIsOmfLocked tests (hLocked was never set)
//
//      07-Jan-96 BryanT
//          Add in the MIPS changes Roger made for nested funcs *before* the parent proc.

#include "shinc.hpp"
#pragma hdrstop

LOCAL   VOID CheckHandles (PCXT);
LOCAL   PCXT SHSetBlksInCXT (PCXT);

//  SHAddrFromHsym - Given a symbol get the offset and seg and return
//
//  Purpose: This function will return the address of a symbol if it has an address.
//      If there is no address for the symbol then the function returns FALSE.
//
//  Input:
//      paddr  - Supplies the address structure to put the address in
//      hsym   - Supplies the handle to the symbol to get the address for.
//
//  Returns:
//      TRUE if the symbol has an address and FALSE if there is not
//      address associated with the symbol.

BOOL
SHAddrFromHsym (
    LPADDR  paddr,
    HSYM    hsym
    )
{
    SYMPTR psym = (SYMPTR) hsym;

    switch (psym->rectyp) {
        case S_GPROC32:
        case S_LPROC32:
        case S_BLOCK32:
            SetAddrOff (paddr, (UOFFSET) (((PROCPTR32) psym)->off));
            SetAddrSeg (paddr, ((PROCPTR32) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_GPROCMIPS:
        case S_LPROCMIPS:
            SetAddrOff (paddr, (UOFFSET) (((PROCPTRMIPS) psym)->off));
            SetAddrSeg (paddr, ((PROCPTRMIPS) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_LABEL32:
            SetAddrOff (paddr, (UOFFSET) (((LABELPTR32) psym)->off));
            SetAddrSeg (paddr, ((LABELPTR32) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_THUNK32:
            SetAddrOff (paddr, (UOFFSET) (((THUNKPTR32) psym)->off));
            SetAddrSeg (paddr, ((THUNKPTR32) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_WITH32:
            SetAddrOff (paddr, (UOFFSET) (((WITHPTR32) psym)->off));
            SetAddrSeg (paddr, ((WITHPTR32) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_PUB32:
        case S_LDATA32:
        case S_LTHREAD32:
        case S_GDATA32:
        case S_GTHREAD32:
            SetAddrOff (paddr, ((DATAPTR32) psym)->off);
            SetAddrSeg (paddr, ((DATAPTR32) psym)->seg);
            ADDRLIN32 (*paddr);
            break;

        case S_BPREL32:
        case S_REGREL32:  // UNDONE: Can we do better simply bailing here?
        default:
            return FALSE;
    }
    ADDR_IS_LI (*paddr) = TRUE;
    return TRUE;
}

//  SHGetNextMod
//
//  Purpose: To sequence through the modules. Only unique module indexes
//      are checked.
//
//  Input:
//      hMod    The last module, if NULL a starting point is picked
//
//  Returns:
//      The next module (hMod) in the module change or NULL if at end.

HMOD
SHGetNextMod (
    HEXE hexe,
    HMOD hmod
    )
{
    return SHHmodGetNext (hexe, hmod);
}

PCXT
SetModule (
    PADDR paddr,
    PCXT pcxt,
    HEXE hexe,
    HMOD hmod
    )
{
    memset(pcxt, 0, sizeof(CXT));
    *SHpADDRFrompCXT(pcxt) = *paddr;

    if (!emiAddr(*paddr)) {
        SHpADDRFrompCXT(pcxt)->emi = (HEMI) hexe;
    }
    SHHMODFrompCXT(pcxt) = hmod;
    SHHGRPFrompCXT(pcxt) = hmod;

    return pcxt;
}

BOOL
IsAddrInMod (
    LPMDS lpmds,
    LPADDR lpaddr,
    ISECT* pisect,
    OFF* poff,
    CB* pcb
    )
{
    int isgc;

    if (lpmds->pmod) {
        DBI* pdbi;
        Mod* pmodRet;
        if (!ModQueryDBI(lpmds->pmod, &pdbi) ||
            !DBIQueryModFromAddr(pdbi,
                                 (USHORT)GetAddrSeg (*lpaddr),
                                 GetAddrOff (*lpaddr),
                                 &pmodRet,
                                 pisect,
                                 poff,
                                 pcb))
            return FALSE;
        return (pmodRet == lpmds->pmod);
    } else {
        for (isgc = 0; isgc < (int) lpmds->csgc; isgc++) {
            if (lpmds->lpsgc[isgc].seg == GetAddrSeg (*lpaddr) &&
                lpmds->lpsgc[isgc].off <= GetAddrOff (*lpaddr) &&
                GetAddrOff (*lpaddr) < lpmds->lpsgc[isgc].off + lpmds->lpsgc[isgc].cb
            ) {
                if (pisect)
                    *pisect = (ISECT)lpmds->lpsgc[isgc].seg;
                if (poff)
                    *poff = lpmds->lpsgc[isgc].off;
                if (pcb)
                    *pcb = lpmds->lpsgc[isgc].cb;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//  SHSetCxtMod
//
//  Purpose: To set the Mod and Group of a CXT
//
//  Input:
//      paddr   - The address to find
//
//  Output:
//      pcxt    - The point to the CXT to make.
//
//  Returns:
//      The pointer to the CXT, NULL if failure.
//
//  Notes:
//  The CXT must be all zero or be a valid CXT. Unpredictable results
//  (possible GP) if the CXT has random data in it. If the CXT is valid
//  the module pointed by it will be the first module searched.
//
//  There are no changes to the CXT if a module couldn't be found

PCXT
SHSetCxtMod (
    LPADDR  paddr,
    PCXT    pcxt
    )
{
    // BUGBUG: Check with WesW about this.  For some reason, he
    // removed the Save variables in April/1994.  I replaced the with
    // a Cache arg that is cleared like all the other Cache args...
    // Is this why he made the change?

    // If we're still in the same pds/exe/seg/range, it's the same module...

	assert (ADDR_IS_LI(*paddr));
	
    if (CxtCache.hpds     == hpdsCur &&
        CxtCache.hexe     == (HEXE)emiAddr(*paddr) &&
        CxtCache.seg      == (WORD)GetAddrSeg (*paddr) &&
        CxtCache.uoffBase <= GetAddrOff (*paddr) &&
        CxtCache.uoffLim  >  GetAddrOff (*paddr))
    {
        return SetModule (paddr, pcxt, CxtCache.hexe, CxtCache.hmod);
    } else if (GetAddrSeg(*paddr)) {

        HEXE hexe = hexeNull;

        while (hexe = SHGetNextExe (hexe)) {

            if (hexe == (HEXE) emiAddr (*paddr)) {
                LPEXE lpexe = (LPEXE) LLLock (hexe);
                LPEXG lpexg = (LPEXG) LLLock (lpexe->hexg);
                if (lpexg->ppdb) {
                    Mod* pmod;
                    CB cb;
                    BOOL fTmp;
                    assert(lpexg->pdbi);
                    if (DBIQueryModFromAddr(lpexg->pdbi,
                                            (USHORT)GetAddrSeg(*paddr),
                                            GetAddrOff(*paddr),
                                            &pmod,
                                            &CxtCache.seg,
                                            (OFF *)&CxtCache.uoffBase,
                                            &cb))
                    {
                        CxtCache.uoffLim = CxtCache.uoffBase + cb;
                        CxtCache.hpds = hpdsCur;
                        fTmp  = ModGetPvClient(pmod, (void **)&CxtCache.hmod);
                        assert(fTmp);
                        CxtCache.hexe  = hexe;
                        return SetModule (paddr, pcxt, CxtCache.hexe, CxtCache.hmod);
                    }
                } else {
                    LPSGD rgsgd = lpexg->lpsgd;

                    LLUnlock (lpexe->hexg);
                    LLUnlock (hexe);

                    if (rgsgd == NULL) {

                        return SetModule(paddr, pcxt, hexe, hmodNull);

                    } else if (GetAddrSeg (*paddr) <= lpexg->csgd) {

                        LPSGD lpsgd = &rgsgd [GetAddrSeg (*paddr) - 1];
                        WORD  isge = 0;

                        for (isge = 0; isge < lpsgd->csge; isge++) {
                            LPSGE lpsge = &lpsgd->lpsge [isge];

                            if (lpsge->sgc.seg == GetAddrSeg (*paddr) &&
                                lpsge->sgc.off <= GetAddrOff (*paddr) &&
                                GetAddrOff (*paddr) < lpsge->sgc.off + lpsge->sgc.cb
                            ) {
                                CxtCache.hpds      = hpdsCur;
                                CxtCache.hmod      = lpsge->hmod;
                                CxtCache.hexe      = hexe;
                                CxtCache.seg       = (WORD)GetAddrSeg (*paddr);
                                CxtCache.uoffBase  = lpsge->sgc.off;
                                CxtCache.uoffLim   = lpsge->sgc.off + lpsge->sgc.cb;

                                return SetModule (paddr, pcxt, CxtCache.hexe, CxtCache.hmod);
                            }
                        }
                    }
                }
            }
        }
    }

    // In case we don't get a context match anywhere, at least init the cxt
    // structure (in case the caller forgets to test the return value).

    SetModule (paddr, pcxt, hexeNull, hmodNull);
    return (NULL);
}


//  SHSetBlksInCXT
//
//  Purpose:  To update the CXT packet with Proc, and Blk information
//      based on pCXT->addr. It is possible to have a Blk record without
//      a Proc.
//
//      The Procs or Blocks will inclose the pCXT->addr. Also a
//      block will never inclose a Proc.
//
//      The updating of the ctxt will be effecient. If the packet is already
//      updated or partiallly updated, the search reduced or removed.
//
//  Input:
//      pcxt   - A pointer to a CXT with a valid HMOD, HGRP and addr
//
//  Output:
//      pcxt   - HPROC and HBLK are all updated.
//
//  Returns .....
//      pcxt on success or NULL on failure
//
//
//  Notes:  This is the core address to context routine! This particular
//    routine should only be used by other routines in this module
//    (i.e. remain static near!). The reason for this is so symbol
//    lookup can change with easy modification to this module and
//    not effecting other modules.

LOCAL PCXT
SHSetBlksInCXT (
    PCXT pcxt
    )
{
    SYMPTR  psym;
    SYMPTR  psymEnd;
    LPB     lpstart;
    LPMDS   lpmds;
    int     fGo;
    UOFFSET uoffCxt;
    UOFFSET uoffT;

    // determine if we can find anything
    if (!(pcxt->hMod && pcxt->hGrp)) {
        return NULL;
    }

    uoffCxt = GetAddrOff(pcxt->addr);

    // get the module limits

    lpmds = (LPMDS) pcxt->hGrp;
    if (GetSymbols(lpmds)) {
        lpstart = (LPB)(lpmds->symbols);
        psym = (SYMPTR) ((LPB) lpmds->symbols + sizeof (long));
        psymEnd = (SYMPTR) (((LPB) psym) + lpmds->cbSymbols - sizeof (long));
    } else {
        psym = psymEnd = NULL;
    }

    pcxt->hProc = NULL;
    pcxt->hBlk  = NULL;

    if (psym >= psymEnd) {
        return(pcxt);
    }

    // now search the symbol tables starting at psym for the correct block.

    while (psym < psymEnd) {
        switch (psym->rectyp) {
            // check to make sure this address starts before the address
            // of interest

            case S_LPROC32:
            case S_GPROC32:
                uoffT = ((PROCPTR32)psym)->off;

                if (((PROCPTR32)psym)->seg != GetAddrSeg(pcxt->addr) ||
                    uoffT > uoffCxt ||
// v-vadimp - fix for the decorated function name showing in the calls stack/context window
// on Alpha when in a function prolog [apennell] moved fix into Intel
                    (uoffT + ((PROCPTR32)psym)->len <= uoffCxt))
                {
                    // Wrong segment/too high/too low.
                    psym = (SYMPTR)(lpstart + ((PROCPTR32)psym)->pEnd);
                } else {
                    // Right proc.
                    pcxt->hProc = (HPROC) psym;
                    pcxt->hBlk = (HBLK) NULL;
                }

                break;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                if (((PROCPTRMIPS)psym)->seg != GetAddrSeg(pcxt->addr) ||
                    ((PROCPTRMIPS)psym)->off > uoffCxt) {
                    // No match.  Look for the next symbol.
                    psym = (SYMPTR)(lpstart + ((PROCPTRMIPS)psym)->pEnd);
                } else {
                    uoffT = ((PROCPTRMIPS)psym)->off;

                    if (uoffCxt < (uoffT + ((PROCPTRMIPS)psym)->len)) {
                        // The offset is before the end of the parents range.

                        if (uoffCxt >= uoffT) {
                            // And it's after the start of the parent proc... Must be right.
                            psymEnd = (SYMPTR) (lpstart + ((PROCPTRMIPS)psym)->pEnd);

                            // MIPS can have several local functions in a module (for exception
                            //  filters, finally clauses, etc).  Make sure we're looking at
                            //  the right one.

                            if ((pcxt->hProc == NULL) &&
                                (uoffCxt > (uoffT + ((PROCPTRMIPS)psym)->DbgEnd)))
                            {
                                SYMPTR psymProc = NEXTSYM (SYMPTR, psym);
                                BOOL fFound = FALSE;
                                while (psymProc < psymEnd && !fFound) {
                                    if (psymProc->rectyp == S_LPROCMIPS) {
                                        uoffT = ((PROCPTRMIPS)psymProc)->off;
                                        if ((uoffCxt >= uoffT) &&
                                            (uoffCxt < (uoffT + ((PROCPTRMIPS)psymProc)->len))) {
                                            psym = psymProc;
                                            psymEnd = (SYMPTR) (lpstart + ((PROCPTRMIPS)psymProc)->pEnd);
                                            if (uoffCxt <= uoffT + ((PROCPTRMIPS)psymProc)->DbgEnd) {
                                                fFound = TRUE;
                                            }
                                        } else {
                                            psymProc = (SYMPTR)(lpstart + ((PROCPTRMIPS)psym)->pEnd);
                                        }
                                    }
                                    psymProc = NEXTSYM (SYMPTR, psymProc);
                                }
                            }
                            pcxt->hProc = (HPROC) psym;
                            pcxt->hBlk = (HBLK) NULL;
                        } else {
                            // Not within this proc.  Myst be before it.
                            // search for nested procs which have offsets < parent.

                            SYMPTR psymProc = ((SYMPTR) (((LPB) (psym)) + ((SYMPTR) (psym))->reclen + 2));
                            SYMPTR psymEndT = (SYMPTR) (lpstart + ((PROCPTRMIPS)psym)->pEnd);
                            BOOL fFound = FALSE;
                            while (psymProc < psymEndT) {
                                if (S_LPROCMIPS == psymProc->rectyp ) {
                                    unsigned long procLen = ((PROCPTRMIPS)psymProc)->len;
                                    uoffT = ((PROCPTRMIPS)psymProc)->off;
                                    if ((uoffCxt >= uoffT) &&
                                        (uoffCxt < (uoffT + procLen)))
                                    {
                                        psymEnd = (SYMPTR) (lpstart + ((PROCPTRMIPS)psym)->pEnd);
                                        psym = psymProc;
                                        pcxt->hProc = (HPROC) psym;
										pcxt->hBlk = (HBLK) NULL;
                                        fFound = FALSE;
                                        break;
                                    }
                                }
                                psymProc = ((SYMPTR) (((LPB) (psymProc)) + ((SYMPTR) (psymProc))->reclen + 2));     // 2?  Why 2?  BryanT 1/7/96
                            }
                            if (fFound) {
                                psym = (SYMPTR)(lpstart + ((PROCPTRMIPS)psym)->pEnd);
                            }
                        }
                    } else {
                        // The offset is after this symbol's range.. Keep looking.
                        psym = (SYMPTR)(lpstart + ((PROCPTRMIPS)psym)->pEnd);
                    }
                }

                break;

            case S_BLOCK32:
                if (((BLOCKPTR32)psym)->seg != GetAddrSeg(pcxt->addr) ||
                    ((BLOCKPTR32)psym)->off > uoffCxt ||
                    ((BLOCKPTR32)psym)->off + ((BLOCKPTR32)psym)->len < uoffCxt)
                {
                    psym = (SYMPTR)(lpstart + ((BLOCKPTR32)psym)->pEnd);
                } else {
                    pcxt->hBlk = (HBLK)psym;
                }

                break;

            case S_WITH32:
                if (((WITHPTR32)psym)->seg == GetAddrSeg(pcxt->addr)) {
                    if (((WITHPTR32)psym)->off > uoffCxt) {
                        goto returnhere;
                    } else if (uoffCxt >= ((WITHPTR32)psym)->off + ((WITHPTR32) psym)->len) {
                        psym = (SYMPTR)(lpstart + ((WITHPTR32)psym)->pEnd);
                    }
                }
                break;
        }
        // get the next psym address
        psym = NEXTSYM (SYMPTR, psym);
    }

returnhere:

    return pcxt;
}


//  SHSetCxt
//
//  Purpose: To set all field in a CXT to the represent the given address
//
//  Input:  pAddr   -The address to set the CXT to.
//
//  Output: pcxt    -A pointer to the CXT to fill.
//
//  Notes:  The CXT must be all zero or be a valid CXT. Unpredictable results
//          (possible GP) if the CXT has random data in it. If the CXT is valid
//          the module pointed by it will be the first module searched.
//
//  There are no changes to the CXT if a module couldn't be found

PCXT
SHSetCxt(
    LPADDR paddr,
    PCXT pcxt
    )
{
	assert (ADDR_IS_LI (*paddr));
	
    // get the module part
    if (SHSetCxtMod(paddr, pcxt)) {
        SHSetBlksInCXT(pcxt);
        return(pcxt);
    }
    return NULL;
}


//  SHGetCxtFromHmod
//
//  Purpose: To make a CXT from only an hmod
//
//  Input:  hmod    - The module to make
//
//  Output: pCXT    - A pointer to a CXT to initialize to this hmod
//
//  Returns: A pointer to the CXT or NULL on error.

PCXT
SHGetCxtFromHmod (
    HMOD hmod,
    PCXT pcxt
    )
{
    LPMDS   lpmds = (LPMDS) hmod;

    if (!hmod) {
        return(NULL);
    }

    if (!lpmds->pmod && !lpmds->csgc) {
        return(NULL);
    }

    HEXE    hexe  = SHHexeFromHmod(hmod);

    // clear the CXT
    memset(pcxt, 0, sizeof(CXT));

    // set the module info
    pcxt->hGrp = pcxt->hMod = hmod;

    // put in the address
    SetAddrFromMod(lpmds, &pcxt->addr);
    emiAddr(pcxt->addr) = (HEMI) hexe;
    ADDR_IS_LI(pcxt->addr) = TRUE;
    // Set the fFlat and fOff32 bits based on the exe
    {
        HEXG hexg = ((LPEXE) LLLock(hexe))->hexg;
        LLUnlock (hexe);

        if (((LPEXG) LLLock (hexg))->fIsPE) {
            // REVIEW - billjoy - should we check machine type or something?
            ADDRLIN32 (pcxt->addr);
        }
        else {
            // REVIEW - billjoy - should we check machine type or something?
            //ADDR????
        }
        LLUnlock (hexg);
    }

    return(pcxt);
}


//  SHGetCxtFromHexe
//
//  Purpose: To make a CXT from only an hexe.  The first hmod with code
//          will be used.
//
//  Input:  hexe    - A handle to the exe in question
//
//  Output: pCXT    - A pointer to a CXT to initialize to this hmod
//
//  Returns: A pointer to the CXT or NULL on error
//
//  Notes:  This code depends on SHGetCxtFromHmod returning NULL if
//          lpmds->csgc is zero.

PCXT
SHGetCxtFromHexe (
    HEXE hexe,
    PCXT pcxt
    )
{
    HMOD  hmod;
    PCXT  pcxtRet = NULL;

    if (hexe) {
        hmod = (HMOD)NULL;
        while (!pcxtRet && (hmod = SHGetNextMod(hexe, hmod))) {
            pcxtRet = SHGetCxtFromHmod(hmod, pcxt);
        }
    }
    return pcxtRet;
}

//  SHGetNearestHsym
//
//  Purpose: To find the closest label/proc to the specified address is
//      found and put in pch. Both the symbol table and the
//      publics tables are searched.
//
//  Input:
//      pctxt   - a pointer to the context, address
//                and mdi must be filled in.
//      fIncludeData    - If true, symbol type local will be included
//                      in the closest symbol search.
//  Output:
//      pch     - The name is copied here.
//
//  Returns .....
//      The difference between the address and the symbol
//
//Notes:  If CV_MAXOFFSET is returned, there is no closest symbol
//      Also all symbols in the module are searched so only the
//      ctxt.addr and ctxt.mdi have meaning.

UOFF32
SHGetNearestHsym (
    LPADDR paddr,
    HMOD hmod,
    int mDataCode,
    PHSYM phSym
    )
{
    LBS         lbs;
    CV_uoff32_t doff    = (CV_uoff32_t)CV_MAXOFFSET;
    SYMPTR      psym;

    // get the module to search
    *phSym = NULL;
    if (hmod) {
        // at some point we may wish to specify only a scope to search for
        // a label. So we may wish to initialize the lbs differently

        // get the Labels
        lbs.tagMod = hmod;
        lbs.addr   = *paddr;
        SHpSymlplLabLoc(&lbs);

        // check for closest data local, if requested
        if (((mDataCode & EEDATA) == EEDATA) && lbs.tagLoc) {
            psym = (SYMPTR) (LPB) lbs.tagLoc;
            switch (psym->rectyp) {
                case S_BPREL32:
                    doff = GetAddrOff(lbs.addr) - ((BPRELPTR32)psym)->off;
                    break;

                case S_REGREL32:
                    doff = GetAddrOff(lbs.addr) - ((LPREGREL32)psym)->off;
                    break;

                default:
                    assert(FALSE);
                    break;
            }
            *phSym = (HSYM) lbs.tagLoc;
        }

        // check for closest label
        if (((mDataCode & EECODE) == EECODE) && lbs.tagLab) {
            psym = (SYMPTR) (LPB) lbs.tagLab;
            switch (psym->rectyp) {
                case S_LABEL32:
                    if ((UOFFSET) (GetAddrOff(lbs.addr) - (UOFFSET)((LABELPTR32)psym)->off) <= doff) {
                        doff = GetAddrOff(lbs.addr) - (UOFFSET)((LABELPTR32)psym)->off;
                        *phSym = (HSYM) lbs.tagLab;
                    }
                    break;

                default:
                    assert(FALSE);
                    break;
            }
        }

        //  If a thunk is closer
        if (((mDataCode & EECODE) == EECODE) && lbs.tagThunk) {
            psym = (SYMPTR) (LPB) lbs.tagThunk;
            switch (psym->rectyp) {
                case S_THUNK32:
                    if ((GetAddrOff(lbs.addr) - (UOFFSET)((THUNKPTR32)psym)->off) <= doff) {
                        doff = GetAddrOff(lbs.addr) - (UOFFSET)((THUNKPTR32)psym)->off;
                        *phSym = (HSYM) lbs.tagThunk;
                    }
                    break;

                default:
                    assert(FALSE);
                    break;
            }
        }

		// check for statics (S_LDATA32), as if they are code (not data) like S_GDATA32
		// but only allow exact matches
        if (((mDataCode & EECODE) == EECODE) && lbs.tagLoc) {
            psym = (SYMPTR) (LPB) lbs.tagLoc;
            if ( (psym->rectyp==S_LDATA32) && (GetAddrOff(lbs.addr) == ((DATAPTR32)psym)->off) ) {
                    doff = 0;
                    *phSym = (HSYM) lbs.tagLoc;
            }
        }

        // if the proc name is closer
        if (((mDataCode & EECODE) == EECODE) && lbs.tagProc) {
            psym = (SYMPTR) (LPB) lbs.tagProc;
            switch (psym->rectyp) {
                case S_LPROC32:
                case S_GPROC32:
                    if ((GetAddrOff(lbs.addr) - (UOFFSET)((PROCPTR32)psym)->off) <= doff) {
                        doff = GetAddrOff(lbs.addr) - ((PROCPTR32)psym)->off;
                        *phSym = (HSYM) lbs.tagProc;
                    }
                    break;

                case S_LPROCMIPS:
                case S_GPROCMIPS:
                    if ((GetAddrOff(lbs.addr) - (UOFFSET)((PROCPTRMIPS)psym)->off) <= doff) {
                        doff = GetAddrOff(lbs.addr) - ((PROCPTRMIPS)psym)->off;
                        *phSym = (HSYM) lbs.tagProc;
                    }
                    break;

                default:
                    assert(FALSE);
                    break;
            }
        }
    }

	if (doff==CV_MAXOFFSET)
		// if failed, look in publics (to get thunked vtables among other items)
		doff = PHGetNearestHsym (paddr, (HEXE)(paddr->emi), phSym);

    return doff;
}

//  SHIsInProlog
//
//  Purpose: To determine if the addr is in prolog or epilog code of the proc
//
//  Input:
//      pCXT - The context describing the state.  The address here is Linker index
//              based
//
//  Returns:
//      TRUE if it is in prolog or epilog code

SHFLAG
SHIsInProlog (
    PCXT pcxt
    )
{
    SYMPTR pProc;
    UOFFSET CxtOffset, ProcOffset, ProcStart, ProcEnd, ProcLen;

    if (pcxt->hProc == NULL) {
        return FALSE;
    }

    pProc = (SYMPTR) pcxt->hProc;

    CxtOffset = GetAddrOff(*SHpADDRFrompCXT(pcxt));

    // check to see if not within the proc
    switch (pProc->rectyp) {
        case S_LPROC32:
        case S_GPROC32:
            ProcOffset =((PROCPTR32)pProc)->off;
            ProcStart = ((PROCPTR32)pProc)->DbgStart;
            ProcEnd   = ((PROCPTR32)pProc)->DbgEnd;
            ProcLen   = ((PROCPTR32)pProc)->len;
            break;

        case S_LPROCMIPS:
        case S_GPROCMIPS:
            ProcOffset =((PROCPTRMIPS)pProc)->off;
            ProcStart = ((PROCPTRMIPS)pProc)->DbgStart;
            ProcEnd   = ((PROCPTRMIPS)pProc)->DbgEnd;
            ProcLen   = ((PROCPTRMIPS)pProc)->len;
            break;

        default:
            assert(FALSE);
            return(FALSE);
    }

    assert((ProcOffset <= CxtOffset) && ((ProcOffset + ProcLen) >= CxtOffset));

    return ( ((ProcOffset + ProcStart) > CxtOffset) ||      // Before the start
            (((ProcOffset + ProcEnd)   < CxtOffset) &&      //   or after the end?
             ((ProcOffset + ProcLen)   > CxtOffset)));
}

//  SHFindNameInContext
//
//  Purpose:  To look for the name at the scoping level specified by ctxt.
//      Only the specified level is searched, children may be searched
//      if fChild is set.
//
//      This routine will assume the desired scope in the following
//      way. If pcxt->hBlk != NULL, use hBlk as the starting scope.
//      If hBlk == NULL and pcxt->hProc != NULL use the proc scope.
//      If hBlk and hProc are both NULL and pcxt->hMod !=
//      NULL, use the module as the scope.
//
//  Input:
//      hSym    - The starting symbol, if NULL, then the first symbol
//          in the context is used. (NULL is find first).
//      pcxt    - The context to do the search.
//      lpsstr - pointer to the search parameters (passed to the compare routine)
//      fCaseSensitive - TRUE/FALSE on a case sensitive search
//      pfnCmp  - A pointer to the comparison routine
//      fChild  - TRUE if all child block are to be searched, FALSE if
//          only the current block is to be searched.
//
//  Output:
//      pcxtOut - The context generated
//
//  Returns:    A handle to the symbol found, NULL if not found
//
//  Notes:
//      If an hSym is specified, the hMod, hGrp and addr MUST be
//      valid and consistant with each other! If hSym is NULL only
//      the hMod must be valid.  The specification of an hSym
//      forces a search from the next symbol to the end of the
//      module scope.  Continues searches may only be done at
//      module scope.
//
//      If an hGrp is given it must be consistant with the hMod!
//
//      The level at which hSym is nested (cNest) is not passed in
//      to this function, so it must be derived.  Since this
//      could represent a significant speed hit, the level
//      of the last symbol processed is cached.  This should
//      take care of most cases and avoid the otherwise
//      necessary looping through all the previous symbols
//      in the module on each call.

HSYM
SHFindNameInContext (
    HSYM    hSym,
    PCXT    pcxt,
    LPSSTR  lpsstr,
    SHFLAG  fCase,
    PFNCMP  pfnCmp,
    PCXT    pcxtOut
    )
{
    LPMDS   lpmds;
    HMOD    hmod;
    HEXE    hexe;
    SYMPTR  lpsym;
    SYMPTR  lpEnd;
    LPB     lpstart;
    ULONG   cbSym;
    int     fSkip = FALSE;

    if (!ADDR_IS_LI (pcxt->addr)) {
        SYUnFixupAddr (&pcxt->addr);
    }

    memset(pcxtOut, 0, sizeof(CXT));
    if (!pcxt->hMod) {                   // we must always have a module
        return (HSYM) FindNameInStatics(hSym, pcxt, lpsstr, fCase, pfnCmp, pcxtOut);
    }

    hmod = pcxt->hGrp ? pcxt->hGrp : pcxt->hMod;    // Initialize the module
    lpmds = (LPMDS)hmod;

    pcxtOut->hMod   = pcxt->hMod;
    pcxtOut->hGrp   = pcxt->hGrp;

    hexe = SHHexeFromHmod (hmod);

#if 0
    // UNDONE: This needs to be fixed to handle X86 better.  >=3 means
    //      all mptix86 and mptm68k are flaged as ADDRSEG16.  Additionally,
    //      I changed SYProcessor to take a hpid (or NULL).  The code in windbg
    //      and the VC ide s/b update before enabling this code.  Finally, why
    //      is this interesting to do at all?  The only time it will stick is if
    //      we bail from no symbols or an existing hsym..

    lpexe = (LPEXE)LLLock(hexe);
    hpds = lpexe->hpds;
    lppds = (LPPDS)LLLock(hpds);

    if (SYProcessor (lppds->hpid) >= 3) {
        ADDRLIN32 (pcxtOut->addr);
    } else {
        ADDRSEG16 (pcxtOut->addr);
    }

    LLUnlock(hexe);
    LLUnlock(hpds);
    lpexe = NULL;
    lppds = NULL;
#else
    ADDRLIN32 (pcxtOut->addr);
#endif

    SetAddrFromMod(lpmds, &pcxtOut->addr);
    emiAddr (pcxtOut->addr) = (HEMI) hexe;
    ADDR_IS_LI(pcxtOut->addr) = TRUE;

    GetSymbols(lpmds);
    cbSym = lpmds->cbSymbols;

    if (cbSym == 0 || lpmds->symbols == NULL) {
        return NULL;
    }
    // Search the symbol table.

    lpstart = (LPB)(lpmds->symbols);
    lpsym = (SYMPTR) ((LPB) (lpmds->symbols) + sizeof(long));
    lpEnd = (SYMPTR) (((LPB) lpsym + cbSym) -  sizeof(long));

    // now find the start address. Always skip the current symbol because
    // we don't want to pick up the same name over and over again
    // if the user gives the start address
    if (hSym != NULL) {
        pcxtOut->hProc = (HPROC) pcxt->hProc;
        pcxtOut->hBlk = (HBLK) pcxt->hBlk;
        SetAddrOff (&pcxtOut->addr, GetAddrOff(pcxt->addr));
        SetAddrSeg (&pcxtOut->addr, GetAddrSeg(pcxt->addr));
        lpsym = (SYMPTR) hSym;

        switch (lpsym->rectyp) {
            case S_WITH32:
            case S_BLOCK32:
            case S_LPROC32:
            case S_GPROC32:
            case S_THUNK32:

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                lpsym = NEXTSYM(SYMPTR, (lpstart + ((PROCPTR)lpsym)->pEnd));
                break;

            default:
                lpsym = NEXTSYM(SYMPTR, lpsym);
        }
    } else if (pcxt->hBlk != NULL) {    // find the start address
        SYMPTR   lpbsp = (SYMPTR) pcxt->hBlk;

        pcxtOut->hProc = pcxt->hProc;
        pcxtOut->hBlk = pcxt->hBlk;
        switch (lpbsp->rectyp) {
            case S_BLOCK32:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((BLOCKPTR32)lpbsp)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((BLOCKPTR32)lpbsp)->seg);
                ADDRLIN32 (pcxtOut->addr);
                break;
        }
        lpsym = NEXTSYM(SYMPTR, lpbsp);
        lpEnd = (SYMPTR)(lpstart + ((BLOCKPTR32)lpbsp)->pEnd);
    } else if (pcxt->hProc != NULL) {

        // UNDONE: The NT code nuked this case (return NULL).

        SYMPTR lppsp = (SYMPTR) pcxt->hProc;

        switch (lppsp->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((PROCPTR32)lppsp)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((PROCPTR32)lppsp)->seg);
                ADDRLIN32 (pcxtOut->addr);
                break;

            case S_THUNK32:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((THUNKPTR32)lppsp)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((THUNKPTR32)lppsp)->seg);
                ADDRLIN32 (pcxtOut->addr);
                break;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((PROCPTRMIPS)lppsp)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((PROCPTRMIPS)lppsp)->seg);
                ADDRLIN32 (pcxtOut->addr);
                break;
        }
        pcxtOut->hProc = pcxt->hProc;
        lpsym = NEXTSYM(SYMPTR, lppsp);
        lpEnd = (SYMPTR)(lpstart + ((PROCPTR32)lppsp)->pEnd);
    }

    while (lpsym <lpEnd && ((lpsym->rectyp != S_END))) {
        assert (lpsym->reclen != 0);

        switch (lpsym->rectyp) {
            case S_LABEL32:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((LABELPTR32)lpsym)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((LABELPTR32)lpsym)->seg);
                ADDRLIN32 (pcxtOut->addr);
                goto symname;

            case S_LPROC32:
            case S_GPROC32:
                pcxtOut->hBlk = NULL;
                pcxtOut->hProc = (HPROC) lpsym;
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((PROCPTR32)lpsym)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((PROCPTR32)lpsym)->seg);
                ADDRLIN32 (pcxtOut->addr);
                goto entry32;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                pcxtOut->hBlk = NULL;
                pcxtOut->hProc = (HPROC) lpsym;
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((PROCPTRMIPS)lpsym)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((PROCPTRMIPS)lpsym)->seg);
                ADDRLIN32 (pcxtOut->addr);
                goto entry32;

            case S_BLOCK32:
                pcxtOut->hBlk = (HBLK) lpsym;
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((BLOCKPTR32)lpsym)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((BLOCKPTR32)lpsym)->seg);
                ADDRLIN32 (pcxtOut->addr);
                goto entry32;

            case S_THUNK32:
                SetAddrOff (&pcxtOut->addr, (UOFFSET)((THUNKPTR32)lpsym)->off);
                SetAddrSeg (&pcxtOut->addr, (SEGMENT)((THUNKPTR32)lpsym)->seg);

                // Fall through

            case S_WITH32:
                ADDRLIN32 (pcxtOut->addr);

            entry32:
                fSkip = TRUE;

                // fall thru and process the symbol

            case S_BPREL32:
            case S_REGREL32:
            case S_GDATA32:
            case S_LDATA32:
            case S_GTHREAD32:
            case S_LTHREAD32:
                ADDRLIN32 (pcxtOut->addr);
                goto symname;

            case S_REGISTER:
            case S_CONSTANT:
            case S_UDT:
            case S_COBOLUDT:
            case S_COMPILE:
symname:
                if ((!(lpsstr->searchmask & SSTR_symboltype) ||
                      (lpsym->rectyp == lpsstr->symtype)
                    ) &&
                    !(*pfnCmp)(lpsstr, lpsym, (LSZ) SHlszGetSymName (lpsym), fCase)
                   )
                {
                    // save the sym pointer
                    lpsym =  (SYMPTR) lpsym;
                    CheckHandles (pcxtOut);
                    return lpsym;
                }

                // up the scoping level
                if (fSkip) {
                    // Make sure the compiler did the right thing
                    assert(((PROCPTR32)lpsym)->pEnd != 0);
                    lpsym = (SYMPTR)(lpstart + ((PROCPTR32)lpsym)->pEnd);
                    fSkip = FALSE;
                }
                break;
        }
        lpsym = NEXTSYM (SYMPTR, lpsym);
    }
    return NULL;
}


LOCAL VOID
CheckHandles (
    PCXT pcxt
    )
{
    SYMPTR  psym;

    // check and restore all proc and blk handles
    if (pcxt->hProc != NULL) {
        psym = (SYMPTR) pcxt->hProc;
        switch (psym->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
                if ((GetAddrOff (pcxt->addr) <  ((PROCPTR32)psym)->off) ||
                     GetAddrOff (pcxt->addr) >= (((PROCPTR32)psym)->len +
                                                 ((PROCPTR32)psym)->off))
                {
                    pcxt->hProc = NULL;
                }
                break;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                if ((GetAddrOff (pcxt->addr) <  ((PROCPTRMIPS)psym)->off) ||
                     GetAddrOff (pcxt->addr) >= (((PROCPTRMIPS)psym)->len +
                                                 ((PROCPTRMIPS)psym)->off))
                {
                    pcxt->hProc = NULL;
                }
                break;
        }
    }
    if (pcxt->hBlk != NULL) {
        psym = (SYMPTR) pcxt->hBlk;
        switch (psym->rectyp) {
            case S_BLOCK32:
                if ((GetAddrOff (pcxt->addr) < ((BLOCKPTR32)psym)->off) ||
                     GetAddrOff (pcxt->addr) >= (((BLOCKPTR32)psym)->len +
                                                 ((BLOCKPTR32)psym)->off))
                {
                    pcxt->hBlk = NULL;
                }
                break;
        }
    }

    // now fill in the proper group
    // because there is not (currently) a unique emi within a
    // module, use the emi set in addr
    pcxt->hGrp = pcxt->hMod;
}


//  SHpSymctxtParent
//
//  Purpose: To return a pointer to the parent block of the current blk or proc.
//     The CXT is updated to the parent context. This may be a new block
//     Proc or module.
//
//  Input:
//      pcxt   - A pointer to the child CXT.
//
//  Output:
//      pcxtOut- an updated CXT to the parent.
//
//  Returns .....
//      - a Symbol point to the first record within the parent, this
//        may be pcxt->hBlk, hProc, or
//        pcxt->hMod->symbols + sizeof (long) or NULL if no parent.

HSYM
SHGoToParent (
    PCXT pcxt,
    PCXT pcxtOut
    )
{

    SYMPTR  lpsym = NULL;
    LPMDS   lpmds;
    SYMPTR  lpsymT;
    HSYM    hsym;
    LPB     lpstart;

    if (!pcxt->hMod) {
        return NULL;
    }

    lpmds = (LPMDS)pcxt->hMod;
    lpstart = (LPB) (lpmds->symbols);
    lpsymT  = (SYMPTR) ((LPB) lpmds->symbols + sizeof(long));

    *pcxtOut = *pcxt;
    // if the block is present, go to his parent
    if (pcxt->hBlk != NULL) {
        // If we are the parent, No further to go.
        assert(pcxt->hBlk != pcxt->hProc);
        // get lpsym upto the parent
        lpsym = (SYMPTR) pcxt->hBlk;
        lpsym = (SYMPTR)(lpstart + ((BLOCKPTR32)lpsym)->pParent);
        pcxtOut->hBlk = NULL;
    } else if (pcxt->hProc != NULL) {
        // otherwise check the proc's parent, and go to his parent
        lpsym = (SYMPTR) pcxt->hProc;       // get lpsym upto the parent
        lpsym = (SYMPTR)(lpstart + (((PROCPTR32)lpsym)->pParent));
        pcxtOut->hProc = NULL;
    } else {
        // otherwise there is no parent
        return NULL;
    }

    // if there is a parent, set the cxt packet.
    if (lpsym != (SYMPTR) lpstart) {
        switch(lpsym->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
            case S_LPROCMIPS:
            case S_GPROCMIPS:
                // UNDONE: The NT code was changed to set pcxtOut->hBlk here... Why?
                pcxtOut->hProc = (HPROC) lpsym;
                break;

            case S_BLOCK32:
            case S_WITH32:
                pcxtOut->hBlk = (HBLK) lpsym;
                break;

            default:
                return NULL;
        }
        return lpsym;
    } else {
        // return the module as the parent
        hsym = (HSYM) lpsymT;
        return hsym;
    }
}

//  SHFindSLink32
//
//  Purpose: To return a pointer to the SLINK32 for this proc
//
//  Input:
//      pcxt   - A pointer to the child CXT.
//
//
//  Returns .....
//      - a Symbol point to the SLINK32 record

HSYM
SHFindSLink32 (
    PCXT pcxt
    )
{
    SYMPTR  lpsym = NULL;
    LPMDS   lpmds;
    SYMPTR lpsymT;

    if (!pcxt->hMod) {
        return NULL;
    }

    lpmds = (LPMDS) pcxt->hMod;
    lpsymT = (SYMPTR) ((LPB)lpmds->symbols + sizeof(long));

    if (pcxt->hProc != NULL) {
        lpsym = (SYMPTR) pcxt->hProc;
    } else {
        return NULL;            // otherwise there is no SLINK32
    }

    lpsym = NEXTSYM(SYMPTR, lpsym);

    for (; lpsym != NULL && lpsym->rectyp != S_SLINK32;) {
        switch (lpsym->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
            case S_LPROCMIPS:
            case S_GPROCMIPS:
            case S_BLOCK32:
            case S_WITH32:
            case S_END:
                lpsym = NULL;
                break;

            case S_SLINK32:
                break;

            default:
                lpsym = NEXTSYM(SYMPTR, lpsym);
                break;
        }
    }
    return lpsym;
}

//  SHHsymFromPcxt
//
//  Purpose: To get the inner most hSym given a context
//
//  Input:
//      pcxt    - A pointer to a valid CXT.
//
//  Returns:
//      HSYM of the first symbol, or NULL on Error
//
//  Notes: Used for procedure parameter walking

HSYM
SHHsymFromPcxt(
    PCXT pcxt
    )
{
    HSYM  hsym = NULL;
    LPMDS lpmds;

    if (pcxt->hMod) {
        if (pcxt->hBlk) {
            hsym = pcxt->hBlk;
        } else if (pcxt->hProc) {
            hsym = pcxt->hProc;
        } else {
            SYMPTR  lpsymT;

            // get the first symbol
            lpmds = (LPMDS) pcxt->hMod;
            lpsymT = (SYMPTR) ((LPB) GetSymbols (lpmds) + sizeof(long));
            hsym = lpsymT;
        }
    }
    return hsym;
}

//  SHNextHsym
//
//  Purpose: To get the next symbol in the table
//
//  Input:
//      hMod -A handle to the module containing the current hSym
//      hSym -The current hSym
//
//  Returns:
//      The next hSym, or NULL if no more.

HSYM
SHNextHsym (
    HMOD hmod,
    HSYM hSym
    )
{
    SYMPTR  lpsym;
    SYMPTR  lpsymStart;
    ULONG   cbSym;
    LPMDS   lpmds;
    HSYM    hsymRet = (HSYM)NULL;
    SYMPTR  lpsymT;

    if (hmod) {
        // only if the symbol is valid
        // get module info
        lpmds = (LPMDS) hmod;
        lpsymT = (SYMPTR) ((LPB) GetSymbols (lpmds) + sizeof(long));
        lpsymStart = (SYMPTR) lpsymT;
        cbSym = lpmds->cbSymbols;

        // give him the first symbol record

        if (hSym == NULL) {
            // if the current handle to symbol is null, return the first
            // symbol.  This is actually an error condition since we don't
            // have an hSym to get the next from
            hsymRet = (HSYM)lpsymStart;
        } else {
            // get info about the sym, and then skip it

            lpsym = (SYMPTR) hSym;
            lpsym = NEXTSYM(SYMPTR, lpsym);

            // check to see if still in symbol range

            lpsymStart = (SYMPTR) lpsymStart;
            if (lpsymStart <= lpsym &&
                lpsym < (SYMPTR) (((LPB) lpsymStart) + cbSym)) {
                hsymRet = (HSYM) lpsym;
            }
        }
    }
    return hsymRet;
}


//  SHIsAddrInCxt
//
//  Purpose: To verify weather the address is within the context
//
//  Input:
//      pCXT    - The context to check against
//      pADDR   - The address in question
//
//  Returns:
//      TRUE if within context, FALSE otherwise.

SHFLAG
SHIsAddrInCxt (
    PCXT pcxt,
    LPADDR paddr
    )
{
    HMOD        hmod;
    LPMDS       lpmds;
    SYMPTR      psym;
    SHFLAG      shf = (SHFLAG)FALSE;

    if ((pcxt != NULL) && (pcxt->hMod != 0)) {

        // get the module
        if (pcxt->hGrp != 0) {
            hmod = pcxt->hGrp;
        } else {
            hmod = pcxt->hMod;
            pcxt->hGrp = hmod;
        }
        lpmds = (LPMDS) hmod;

        // The return value is true if these three conditions are all true:
        //  1. The address is in the same executable as the context
        //  2. The address is in the same module as the context
        //  3. Any of the following are true:
        //     a. There is no block or proc so the address offset
        //        can be anywhere
        //     b. The address is in the offset range of the block of
        //        the context
        //     c. The addr is in the offset range of the procedure of
        //        the context

        if (emiAddr (*paddr) != 0                       &&
            emiAddr (*paddr) != (HEMI) hpidCurr         &&
            emiAddr (*paddr) == (HEMI) SHHexeFromHmod (hmod)
       ) {
            // condition 1 is true

            if (IsAddrInMod (lpmds, paddr, NULL, NULL, NULL)) {
                // condition 2 is true

                if (pcxt->hProc == NULL && pcxt->hBlk == NULL) {
                    // condition 3a is true
                    shf = TRUE;
                }

                if (!shf && (psym = (SYMPTR) pcxt->hBlk) != NULL) {
                    // we have not passed test 3a and the block
                    // symbol handle is not null
                    switch (psym->rectyp) {

                        case S_BLOCK32:
                            if ((((BLOCKPTR32) psym)->off <= GetAddrOff (*paddr)) &&
                                (GetAddrOff (*paddr) < (UOFFSET) (((BLOCKPTR32)psym)->off +
                                                                  ((BLOCKPTR32)psym)->len)))
                            {
                                // case 3b is true for a 32 bit block symbol
                                shf = TRUE;
                            }
                            break;
                    }
                }
                if ((shf == FALSE) && ((psym = (SYMPTR) pcxt->hProc) != NULL)) {
                    // we have not passed tests 3a or 3b and the proc
                    // symbol handle is not null
                    switch (psym->rectyp) {

                        case S_LPROC32:
                        case S_GPROC32:
                            if ((((PROCPTR32) psym)->off <= GetAddrOff (*paddr)) &&
                                (GetAddrOff (*paddr) < (UOFFSET) (((PROCPTR32)psym)->off +
                                                                  ((PROCPTR32)psym)->len)))
                            {
                                // case 3b is true for a 32 bit proc symbol
                                shf = TRUE;
                            }
                            break;

                        case S_LPROCMIPS:
                        case S_GPROCMIPS:
                            if ((((PROCPTRMIPS) psym)->off <= GetAddrOff (*paddr)) &&
                                (GetAddrOff (*paddr) < (UOFFSET) (((PROCPTRMIPS)psym)->off +
                                                                  ((PROCPTRMIPS)psym)->len)))
                            {
                                // case 3b is true for a 32 bit proc symbol
                                shf = TRUE;
                            }
                            break;
                    }
                }
            }
        }
    }
    return(shf);
}



//  SHGethExeFromAltName
//
//  Purpose: To get an Exe handle given an alternate name
//
//  Input:   szPath  - The path or filename of the exe
//
//  Returns: A handle to the exe or NULL on error

HEXE
SHGethExeFromAltName(
    LPTSTR AltName
    )
{
    HEXE  hexe;
    LPTSTR p;

    hexe = SHGetNextExe (NULL);

    while (hexe) {
        p = SHGetModNameFromHexe(hexe);
        if (p && (_tcsicmp(p, AltName) == 0)) {
            return hexe;
        }
        hexe = SHGetNextExe(hexe);
    }

    return NULL;
}


//  SHGethExeFromExeName
//
//  Purpose: To get an Exe handle given an Exe name
//
//  Input:   szPath  - The path or filename of the exe
//
//  Returns: A handle to the exe or NULL on error

HEXE
SHGethExeFromExeName(
    LPTSTR ExeName
    )
{
    HEXE  hexe;
    _TCHAR   szOMFPath[_MAX_CVPATH];
    _TCHAR   szOMFFile[_MAX_CVFNAME];
    _TCHAR   szOMFExt[_MAX_CVEXT];
    _TCHAR   szName[_MAX_CVPATH];
    _TCHAR   szFile[_MAX_CVFNAME + 16];
    _TCHAR   szExt[_MAX_CVEXT];
    DWORD i;

    // BUGBUG:  See the end of the file.  This is the code from the VC shsymbol.c
    //          that's supposed to handle long file names.

    if (!_tfullpath (szName, ExeName, sizeof (szName))) {
        _tcscpy(szName, ExeName);
    }

    i = _tcslen(szName);
    if (szName[i-1] == '.') {
        szName[--i] = '\0';
    }

    _tsplitpath(szName, NULL, NULL, szFile, szExt);
    if (!szExt[0] || !szExt[1]) {
        szExt[0] = '\0';
    }

    for (hexe = SHGetNextExe((HEXE)NULL); hexe; hexe = SHGetNextExe(hexe)) {
        _tcscpy(szOMFPath, SHGetExeName(hexe));
        _tsplitpath(szOMFPath, NULL, NULL, szOMFFile, szOMFExt);

        if (_tcsicmp(szOMFFile, szFile) != 0) {
            _tcscpy(szOMFPath, SHGetModNameFromHexe(hexe));
            _tsplitpath(szOMFPath, NULL, NULL, szOMFFile, szOMFExt);
        }

        if (_tcsicmp(szOMFFile, szFile) == 0) {
            if (szExt[0]) {
                if (_tcsicmp(szExt, szOMFExt) != 0) {
                    continue;
                }
            }
            return hexe;
        }
    }

    return NULL;
}


//  SHGethExeFromName
//
//  Purpose: To get an Exe handle given a name, or partial name
//
//  Input:
//      szPath  - The path or filename of the exe
//
//  Returns:
//      A handle to the exe or NULL on error

HEXE
SHGethExeFromName (
    LPTSTR ltszPath
    )
{
    HEXE    hexe;
	// the worse case for these is a path with all the DM extra stuff on the end
	// which is "|longpath|0x12345678|0x12345678|0x12345678|0x12345678|longpath|
    _TCHAR  szAltPath[_MAX_CVPATH*2+4*11+4];
    _TCHAR  szOMFPath[_MAX_CVPATH*2+4*11+4];
    LSZ     lpch;
    DWORD   i;
    LPTSTR  p;
    LPTSTR  AltName = NULL;

    if (!ltszPath || !(*ltszPath)) {
        return((HEXE)NULL);
    }

    // Parse the input string.  If it starts with a '|', assume this is the
    // string from the DM.  The first field is the image path.  The 6th is the
    // alternate name.

    if (*ltszPath == '|') {
        i = 0;
        p = ltszPath;
        while (p) {
            p = _tcschr(p, '|');
            if (p) {
                i++;
                p = _tcsinc(p);
                if (i == 6) {
                    if (p && *p) {
                        AltName = p;
                    }
                    break;
                }
            }
        }
        if (AltName) {
            _tcscpy(szAltPath, AltName);
            p = _tcschr(szAltPath, '|');
            if (p) {
                *p = '\0';
            }
        }
        _tcscpy(szOMFPath, &ltszPath[1]);
       for (lpch = szOMFPath; (*lpch != 0) && (*lpch != '|'); lpch = _tcsinc(lpch));
	   *lpch = 0;
    } else {
        _tcscpy(szOMFPath, ltszPath);
    }

    if (AltName) {
        hexe = SHGethExeFromAltName(szOMFPath);
        return hexe;
    }

    hexe = SHGethExeFromExeName(szOMFPath);
    if (!hexe) {
        hexe = SHGethExeFromAltName(szOMFPath);
    }

    return(hexe);
}


//  SHGethExeFromName
//
//  Purpose: To get an Exe handle given a module name
//
//  Input:  lszModName - The module name to lookup
//
//  Returns: A handle to the exe or NULL on error

HEXE
SHGethExeFromModuleName(
    LSZ  lszModName
    )
{
    HEXE   hexe = NULL;
    HEXG   hexg;
    LPEXG  lpexg;
    LPSTR  lszmod;

    while (hexe = SHGetNextExe(hexe)) {
        hexg = ((LPEXE) LLLock (hexe))->hexg;
        lpexg = (LPEXG) LLLock(hexg);
        lszmod = lpexg->lszModule;
        LLUnlock (hexe);
        LLUnlock (hexg);
        if (_tcsicmp(lszModName, lszmod) == 0) {
            return hexe;
        }
    }

    return NULL;
}

#define CSOURCESUFFIX 6
#define CBSOURCESUFFIX 4
static _TCHAR  const * const rgszSourceSuffix[CSOURCESUFFIX] = {
    (_TCHAR  *) _T("**.C"),
    (_TCHAR  *) _T(".CPP"),
    (_TCHAR  *) _T(".CXX"),
    (_TCHAR  *) _T(".ASM"),
    (_TCHAR  *) _T(".BAS"),
    (_TCHAR  *) _T(".FOR")
};

//  SHGetModName
//
//  Purpose: To get an name handle given a module handle
//
//  Input:  hmod - the module handle
//
//  Returns: A handle to the exe or NULL on error
//
//  Notes:  The return pointer is only valid until the call to this function

LSZ
SHGetModName (
    HMOD  hmod
    )
{
    // UNDONE: The NT code was modified to eliminate the static szMODName
    // and replace it with a strdup of lsz before returning...  Not sure what
    // the answer is here (I suspect eliminating the static is the right idea,
    // but the VC ide must be modified to free the pointer when it's done.

    _TCHAR      szFullPath[_MAX_CVPATH];
    static _TCHAR  szMODName[_MAX_CVPATH];
    _TCHAR      szExt[_MAX_CVEXT];
    LPCH        lpch;
    LPMDS       lpmds;
    LSZ         lsz = NULL;
    WORD        iFile;
    _TCHAR  *   lpb;
    WORD        iSuffix;
    _TCHAR  *   lpbSuffix;
    BOOL        fMatch;

    if (!hmod) {
        return NULL;
    }

    szFullPath [0] = '\0';

    lpmds = (LPMDS) hmod;

    assert (lpmds);

    // Try to find a familiar source suffix

    iFile = 0;
    while (lpb = (_TCHAR  *) SLNameFromHmod (hmod, (WORD)(iFile + 1))) {

        lpbSuffix = lpb + *lpb + 1 - CBSOURCESUFFIX;
        for (iSuffix = 0; iSuffix < CSOURCESUFFIX; iSuffix++) {
            _TCHAR  *lpbTest = lpbSuffix;
            _TCHAR  const * pbTest = rgszSourceSuffix [ iSuffix ];

            fMatch = TRUE;
            while (fMatch && *pbTest) {
                switch (*pbTest) {
                    case '*':
                        break;

                    default:
                        if (('a'-'A') == (*lpbTest - *pbTest))
                            break;

                    case '.':
                        if (*lpbTest == *pbTest)
                            break;

                        fMatch = FALSE;
                }
                lpbTest = _tcsinc(lpbTest);
                pbTest = _tcsinc(pbTest);
            }

            if (fMatch) {
                break;
            }
        }
        if (fMatch) {
            memmove(szFullPath, lpb + 1, *(lpb));
            szFullPath[*lpb] = 0;
            break;
        }
        iFile++;
    }


    // As a last resort, use the module name from the omf
    if (!szFullPath[0] && lpmds->name) {
        _tcscpy (szFullPath, lpmds->name);
    }

    if (szFullPath[0]) {

        // take off the source name
        if (lpch = _tcschr ((LPCH) szFullPath, '(')) {
            *lpch = '\0';
        }

        // extract the module name (it is in the form of a path)
        _tsplitpath (szFullPath, NULL, NULL, szMODName, szExt);
        lsz = szMODName;
    }

    return lsz;
}



//  SHCmpGlobName
//
//  Purpose: Given a name, and a global symbol, determine if they match
//
//  Input:  pSym - The symbol to compare against
//          lpsstr - The name we're looking for
//          pfnCmp - A function to call to do the compare
//          fCase  - TRUE if case is important, FALSE otherwise
//
//  Returns: TRUE - The symbol matches

LOCAL BOOL
SHCmpGlobName (
    SYMPTR pSym,
    LPSSTR lpsstr,
    PFNCMP pfnCmp,
    SHFLAG fCase
    )
{
    BOOL fRet = FALSE;

    switch (pSym->rectyp) {
        default:
            assert (FALSE); // Should Never be encountered
            break;

        case S_CONSTANT:
        case S_GDATA32:
        case S_GTHREAD32:
        case S_UDT:
        case S_COBOLUDT:
            fRet = (!(lpsstr->searchmask & SSTR_symboltype) ||
                     (pSym->rectyp == lpsstr->symtype)) &&
                    !(*pfnCmp)(lpsstr, pSym, (LSZ) SHlszGetSymName(pSym), fCase);

            // save the sym pointer
            break;
    }
    return fRet;
}


//  SHCompareRE
//
//  Purpose: Compare a string (case preserving or not) to a regular expression
//          and return true if the string is in the regex.  Note, we only care
//          about '*' and '?'.
//
//  Input:  pStr - The string to compare
//          pRE  - A regular expression string
//          fCase - TRUE if case preserving, FALSE otherwise.
//
//  Returns: 0 for match, non-0 for no match.

SHFLAG
SHCompareRE (
    LPCH pStr,
    LPCH pRE,
    BOOL fCase
    )
{
    for (;;) {
        switch (*pRE) {
            case 0:
                // End of the pattern:
                if (*pStr == 0) {
                    return 0;
                } else {
                    return 1;
                }

            case '?':
                // Match anything except EOL
                if (!*pStr) {
                    return 1;
                } else {
                    pRE++;
                    pStr++;
                    break;
                }

            case '*':
                // Match 0 or more of anything
                pRE++;
                do {
                    if (!SHCompareRE(pStr, pRE, fCase)) {
                        return 0;
                    }
                } while (*pStr++);
                return 1;

            default:
                if (fCase ? (*pRE != *pStr) : (tolower(*pRE) != tolower(*pStr))) {
                    return 1;
                } else {
                    pRE++;
                    pStr++;
                    break;
                }
        }
    }
}


//  SHFindBpOrReg
//
//  Purpose: Provide a place for SHGetSymbol to lookup a stack symbol.
//
//  Input:   the address of interest, item - the BPoffset or Register
//     and which item we are searching for (S_REG S_BPREL)
//
//  Output:  The buffer rgbName is filled
//
//  Returns TRUE FALSE if found

int
SHFindBpOrReg (
    LPADDR  paddr,
    UOFFSET item,
    WORD    recLoc,
    LPCH    rgbName
    )
{
    // There is only one caller of this function... Can we optimize it?
    SYMPTR  psym;
    SYMPTR  pProc;
    CXT     cxt;
    int     fGo;

    SHHMODFrompCXT (&cxt) = 0;

    if (SHSetCxt (paddr, &cxt) == NULL) {
        return (FALSE);
    }

    for (;;) {
        fGo = FALSE;
        if (SHHBLKFrompCXT(&cxt) != 0) {
            fGo = TRUE;
        } else if ((pProc = (SYMPTR) SHHPROCFrompCXT (&cxt)) != NULL) {
            switch (pProc->rectyp) {

                case S_LPROC32:
                case S_GPROC32:
                    if (((((PROCPTR32)pProc)->off + ((PROCPTR32)pProc)->DbgStart) <=
                      GetAddrOff (*paddr))  &&
                      (GetAddrOff (*paddr) < (((PROCPTR32)pProc)->off + ((PROCPTR32)pProc)->DbgEnd))) {
                        fGo = TRUE;
                    }
                    break;
                case S_LPROCMIPS:
                case S_GPROCMIPS:
                    if (((((PROCPTRMIPS)pProc)->off + ((PROCPTRMIPS)pProc)->DbgStart) <=
                      GetAddrOff (*paddr))  &&
                      (GetAddrOff (*paddr) < (((PROCPTRMIPS)pProc)->off + ((PROCPTRMIPS)pProc)->DbgEnd))) {
                        fGo = TRUE;
                    }
                    break;
            }
        }
        if (fGo == FALSE) {
            return  (FALSE);
        }
        if (SHHBLKFrompCXT(&cxt)) {
            psym = (SYMPTR) SHHBLKFrompCXT(&cxt);
        } else if (SHHPROCFrompCXT(&cxt)) {
            psym = (SYMPTR) SHHPROCFrompCXT(&cxt);
        }

        // skip block or proc record

        psym = NEXTSYM (SYMPTR, psym);

        fGo = TRUE;
        while(fGo) {
            switch (psym->rectyp) {
                case S_REGISTER:
                    if ((recLoc == S_REGISTER)  &&
                      ((REGPTR)psym)->reg == (WORD)item) {
                        _tcsncpy (rgbName,
                                  (_TCHAR  *) &((REGPTR)psym)->name[1],
                                  (BYTE)*(((REGPTR)psym)->name));
                        rgbName[(BYTE)*(((REGPTR)psym)->name)] = '\0';
                        return(TRUE);
                    }
                    break;

                case S_END:
                    // terminate loop
                    fGo = FALSE;
                    break;

                case S_LPROC32:
                case S_GPROC32:
                case S_BLOCK32:
                case S_LPROCMIPS:
                case S_GPROCMIPS:
                    // terminate loop
                    fGo = FALSE;

                case S_BPREL32:
                    if ((recLoc == S_BPREL32) &&
                      ((UOFFSET)((BPRELPTR32)psym)->off) == item) {
                        _tcsncpy (rgbName,
                                  (_TCHAR  *) &((BPRELPTR32)psym)->name[1],
                                  (BYTE)*(((BPRELPTR32)psym)->name));
                        rgbName[(BYTE)*(((BPRELPTR32)psym)->name)] = '\0';
                        return(TRUE);
                    }
                    break;

                case S_REGREL32:
                    if ((recLoc == S_BPREL32) &&
                      ((UOFFSET)((LPREGREL32)psym)->off) == item) {
                        _tcsncpy (rgbName,
                                  (_TCHAR  *) &((LPREGREL32)psym)->name[1],
                                  (BYTE)*(((LPREGREL32)psym)->name));
                        rgbName[(BYTE)*(((LPREGREL32)psym)->name)] = '\0';
                        return(TRUE);
                    }
                    break;

                case S_LABEL32:
                case S_WITH32:
                case S_LDATA32:
                case S_GDATA32:
                case S_LTHREAD32:
                case S_GTHREAD32:
                case S_ENDARG:
                case S_CONSTANT:
                case S_UDT:
                case S_COBOLUDT:
                    break;

                default:
                    return(FALSE);          // Bad SYMBOLS data
            }
            psym = NEXTSYM (SYMPTR, psym);
        }

        // get the parent block

        SHGoToParent(&cxt, &cxt);
    }
    return (FALSE);
}


UOFFSET
SHGetDebugStart (
    HSYM hsym
    )
{
    SYMPTR psym = (SYMPTR) hsym;
    UOFFSET uoff = 0;

    switch (psym->rectyp) {
        case S_LPROC32:
        case S_GPROC32: {
                PROCPTR32 psym = (PROCPTR32) hsym;
                uoff = psym->off + psym->DbgStart;
            }
            break;

        case S_LPROCMIPS:
        case S_GPROCMIPS: {
                PROCPTRMIPS psym = (PROCPTRMIPS) hsym;
                uoff = psym->off + psym->DbgStart;
            }
            break;

        default:
            assert (FALSE);
    }

    return uoff;
}

LSZ
SHGetSymName (
    HSYM hsym,
    LSZ lsz
    )
{
    SYMPTR psym = (SYMPTR) hsym;
    LPCH   lst = NULL;

    switch (psym->rectyp) {
        case S_REGISTER:
            lst = (LPCH)((REGPTR) psym)->name;
            break;

        case S_CONSTANT:
            lst = (LPCH)((CONSTPTR) psym)->name;
            break;

        case S_BPREL32:
            lst = (LPCH)((BPRELPTR32) psym)->name;
            break;

        case S_REGREL32:
            lst = (LPCH)((LPREGREL32) psym)->name;
            break;

        case S_GDATA32:
        case S_LDATA32:
        case S_GTHREAD32:
        case S_LTHREAD32:
            lst = (LPCH)((DATAPTR32) psym)->name;
            break;

        case S_PUB32:
            lst = (LPCH)((PUBPTR32) psym)->name;
            break;

        case S_LPROC32:
        case S_GPROC32:
            lst = (LPCH)((PROCPTR32) psym)->name;
            break;

        case S_LPROCMIPS:
        case S_GPROCMIPS:
            lst = (LPCH)((PROCPTRMIPS) psym)->name;
            break;

        case S_THUNK32:
            lst = (LPCH)((THUNKPTR32) psym)->name;
            break;

        case S_BLOCK32:
            lst = (LPCH)((BLOCKPTR32) psym)->name;
            break;

        case S_LABEL32:
            lst = (LPCH)((LABELPTR32) psym)->name;
            break;
    }

    if (lst != NULL && *lst > 0) {
        _tcsncpy (lsz, lst + 1, *lst);
        *(lsz + *((CHAR *)lst)) = '\0';
        return lsz;
    } else {
        return NULL;
    }
}

BOOL
SHIsLabel (
    HSYM hsym
    )
{
    BOOL fFound = FALSE;
    SYMPTR psym = (SYMPTR) hsym;

    switch (psym->rectyp) {
        case S_LPROC32:
        case S_GPROC32:
        case S_LABEL32:
        case S_THUNK32:
        case S_LPROCMIPS:
        case S_GPROCMIPS:
            fFound = TRUE;
            break;
    }

    return fFound;
}


//  SHAddressToLabel
//
//  Purpose: To find the closest label/proc to the specified address is
//      found and put in pch. Both the symbol table and the
//      publics tables are searched.
//
//  Input:      paddr   - Pointer to the address whose label is to be found
//
//  Output:     pch     - The name is copied here.
//
//  Returns:  TRUE if a label was found.

BOOL
SHAddrToLabel(
    LPADDR paddr,
    LSZ lsz
    )
{
    CXT       cxt;
    SYMPTR    psym;
    LBS       lbs;

    // get the module to search

    *lsz = '\0';
    memset((LPV) &cxt, 0, sizeof(CXT));
    memset((LPV) &lbs, 0, sizeof(lbs));
    lbs.addr = *paddr;
    SHSetCxt (paddr, &cxt);

    if (!cxt.hMod) {
        return(FALSE);
    }

    // Get the nearest local labels in this module
    lbs.tagMod     = cxt.hMod;
    lbs.addr.emi   = cxt.addr.emi;
    SHpSymlplLabLoc (&lbs);

    // Check the candidates found

    if (lbs.tagLab) {
        psym = (SYMPTR) lbs.tagLab;
        switch (psym->rectyp) {
            case S_LABEL32:
                if (GetAddrOff (lbs.addr) == ((LABELPTR32)psym)->off) {
                    _tcsncpy(lsz,
                             (_TCHAR  *)&(((LABELPTR32)psym)->name[1]),
                             (BYTE)(((LABELPTR32)psym)->name[0]));
                    lsz[(BYTE)(((LABELPTR32)psym)->name[0])] = '\0';
                    return TRUE;
                }
        }
    }

    if (lbs.tagThunk) {
        psym = (SYMPTR) lbs.tagThunk;
        switch (psym->rectyp) {
            case S_THUNK32:
                if (GetAddrOff (lbs.addr) == ((THUNKPTR32)psym)->off) {
                    _tcsncpy(lsz,
                             (_TCHAR  *)&(((THUNKPTR32)psym)->name[1]),
                             (BYTE)(((THUNKPTR32)psym)->name[0]));
                    lsz[(BYTE)(((THUNKPTR32)psym)->name[0])] = '\0';
                    return TRUE;
                }
        }
    }

    if (lbs.tagProc) {
        psym = (SYMPTR) lbs.tagProc;
        switch (psym->rectyp) {
            case S_LPROC32:
            case S_GPROC32:
                if (GetAddrOff (lbs.addr) == ((PROCPTR32)psym)->off) {
                    _tcsncpy(lsz,
                             (_TCHAR  *)&(((PROCPTR32)psym)->name[1]),
                             (BYTE)(((PROCPTR32)psym)->name[0]));
                    lsz[(BYTE)(((PROCPTR32)psym)->name[0])] = '\0';
                    return(TRUE);
                }

                break;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                if (GetAddrOff (lbs.addr) == ((PROCPTRMIPS)psym)->off) {
                    _tcsncpy(lsz,
                             (_TCHAR  *)&(((PROCPTRMIPS)psym)->name[1]),
                             (BYTE)(((PROCPTRMIPS)psym)->name[0]));
                    lsz[(BYTE)(((PROCPTRMIPS)psym)->name[0])] = '\0';
                    return(TRUE);
                }
                break;
        }
    }

    // now check the publics
    if (!PHGetNearestHsym(SHpADDRFrompCXT(&cxt),
                         SHHexeFromHmod(SHHMODFrompCXT(&cxt)),
                         (PHSYM) &psym)) {

        switch (psym->rectyp) {
            case S_PUB32:
                _tcsncpy(lsz,
                         (_TCHAR  *)&(((DATAPTR32)psym)->name[1]),
                         (BYTE)(((DATAPTR32)psym)->name[0]));
                lsz [(BYTE)(((DATAPTR32)psym)->name[0])] = '\0';
                return(TRUE);
        }
    }
    return(FALSE);
}

BOOL
SHFIsAddrNonVirtual(
    LPADDR paddr
    )
{
    ADDR addr = *paddr;

    // If SYFixupAddr fails, it's because the address is virtual
    // (unless something is seriously wrong)

    return SYFixupAddr(&addr);
}


BOOL
SHIsEmiLoaded(
    HEXE hexe
    )
{
    BOOL fReturn = ((LPEXE)(LLLock(hexe)))->fIsLoaded;
    LLUnlock(hexe);

    return (fReturn);
}


BOOL
SHIsFarProc (
    HSYM hsym
    )
{
    BOOL fReturn = FALSE;

    switch (((SYMPTR) hsym)->rectyp) {

        case S_LPROC32:
        case S_GPROC32:
            fReturn = ((PROCPTR32) hsym)->flags.CV_PFLAG_FAR;
            break;

        case S_LPROCMIPS:
        case S_GPROCMIPS:
            fReturn = FALSE;
            break;
    }

    return fReturn;
}


const char * const M68KRegisterName[] =
{
    "D0",       //  0
    "D1",       //  1
    "D2",       //  2
    "D3",       //  3
    "D4",       //  4
    "D5",       //  5
    "D6",       //  6
    "D7",       //  7
    "A0",       //  8
    "A1",       //  9
    "A2",       // 10
    "A3",       // 11
    "A4",       // 12
    "A5",       // 13
    "A6",       // 14
    "A7",       // 15
    "CCR",      // 16
    "SR",       // 17
    "USP",      // 18
    "MSP",      // 19
    "SFC",      // 20
    "DFC",      // 21
    "CACR",     // 22
    "VBR",      // 23
    "CAAR",     // 24
    "ISP",      // 25
    "PC",       // 26
    "reserved", // 27
    "FPCR",     // 28
    "FPSR",     // 29
    "FPIAR",    // 30
    "reserved", // 31
    "FP0",      // 32
    "FP1",      // 33
    "FP2",      // 34
    "FP3",      // 35
    "FP4",      // 36
    "FP5",      // 37
    "FP6",      // 38
    "FP7",      // 39
    NULL
};

const char * const X86RegisterName[] =
{
    "NONE",    //  0
    "AL",      //  1
    "CL",      //  2
    "DL",      //  3
    "BL",      //  4
    "AH",      //  5
    "CH",      //  6
    "DH",      //  7
    "BH",      //  8
    "AX",      //  9
    "CX",      // 10
    "DX",      // 11
    "BX",      // 12
    "SP",      // 13
    "BP",      // 14
    "SI",      // 15
    "DI",      // 16
    "EAX",     // 17
    "ECX",     // 18
    "EDX",     // 19
    "EBX",     // 20
    "ESP",     // 21
    "EBP",     // 22
    "ESI",     // 23
    "EDI",     // 24
    "ES",      // 25
    "CS",      // 26
    "SS",      // 27
    "DS",      // 28
    "FS",      // 29
    "GS",      // 30
    "IP",      // 31
    "FLAGS",   // 32
    NULL
};

typedef struct _RegInfo {
    WORD    wIndex;
    const CHAR *szName;
} REGINFO;
typedef REGINFO * LPREGINFO;

const REGINFO rgRegInfoPPC[] = {
    // PowerPC General Registers (User Level)

    { CV_PPC_GPR0,      "GPR0"  },
    { CV_PPC_GPR1,      "SP"    },
    { CV_PPC_GPR2,      "RTOC"  },
    { CV_PPC_GPR3,      "GPR3"  },
    { CV_PPC_GPR4,      "GPR4"  },
    { CV_PPC_GPR5,      "GPR5"  },
    { CV_PPC_GPR6,      "GPR6"  },
    { CV_PPC_GPR7,      "GPR7"  },
    { CV_PPC_GPR8,      "GPR8"  },
    { CV_PPC_GPR9,      "GPR9"  },
    { CV_PPC_GPR10,     "GPR10" },
    { CV_PPC_GPR11,     "GPR11" },
    { CV_PPC_GPR12,     "GPR12" },
    { CV_PPC_GPR13,     "GPR13" },
    { CV_PPC_GPR14,     "GPR14" },
    { CV_PPC_GPR15,     "GPR15" },
    { CV_PPC_GPR16,     "GPR16" },
    { CV_PPC_GPR17,     "GPR17" },
    { CV_PPC_GPR18,     "GPR18" },
    { CV_PPC_GPR19,     "GPR19" },
    { CV_PPC_GPR20,     "GPR20" },
    { CV_PPC_GPR21,     "GPR21" },
    { CV_PPC_GPR22,     "GPR22" },
    { CV_PPC_GPR23,     "GPR23" },
    { CV_PPC_GPR24,     "GPR24" },
    { CV_PPC_GPR25,     "GPR25" },
    { CV_PPC_GPR26,     "GPR26" },
    { CV_PPC_GPR27,     "GPR27" },
    { CV_PPC_GPR28,     "GPR28" },
    { CV_PPC_GPR29,     "GPR29" },
    { CV_PPC_GPR30,     "GPR30" },
    { CV_PPC_GPR31,     "GPR31" },

    // PowerPC Condition Register (User Level)

    { CV_PPC_CR,        "CR"    },
    { CV_PPC_CR0,       "CR0"   },
    { CV_PPC_CR1,       "CR1"   },
    { CV_PPC_CR2,       "CR2"   },
    { CV_PPC_CR3,       "CR3"   },
    { CV_PPC_CR4,       "CR4"   },
    { CV_PPC_CR5,       "CR5"   },
    { CV_PPC_CR6,       "CR6"   },
    { CV_PPC_CR7,       "CR7"   },

    // PowerPC Floating Point Registers (User Level)

    { CV_PPC_FPR0,      "FPR0"  },
    { CV_PPC_FPR1,      "FPR1"  },
    { CV_PPC_FPR2,      "FPR2"  },
    { CV_PPC_FPR3,      "FPR3"  },
    { CV_PPC_FPR4,      "FPR4"  },
    { CV_PPC_FPR5,      "FPR5"  },
    { CV_PPC_FPR6,      "FPR6"  },
    { CV_PPC_FPR7,      "FPR7"  },
    { CV_PPC_FPR8,      "FPR8"  },
    { CV_PPC_FPR9,      "FPR9"  },
    { CV_PPC_FPR10,     "FPR10" },
    { CV_PPC_FPR11,     "FPR11" },
    { CV_PPC_FPR12,     "FPR12" },
    { CV_PPC_FPR13,     "FPR13" },
    { CV_PPC_FPR14,     "FPR14" },
    { CV_PPC_FPR15,     "FPR15" },
    { CV_PPC_FPR16,     "FPR16" },
    { CV_PPC_FPR17,     "FPR17" },
    { CV_PPC_FPR18,     "FPR18" },
    { CV_PPC_FPR19,     "FPR19" },
    { CV_PPC_FPR20,     "FPR20" },
    { CV_PPC_FPR21,     "FPR21" },
    { CV_PPC_FPR22,     "FPR22" },
    { CV_PPC_FPR23,     "FPR23" },
    { CV_PPC_FPR24,     "FPR24" },
    { CV_PPC_FPR25,     "FPR25" },
    { CV_PPC_FPR26,     "FPR26" },
    { CV_PPC_FPR27,     "FPR27" },
    { CV_PPC_FPR28,     "FPR28" },
    { CV_PPC_FPR29,     "FPR29" },
    { CV_PPC_FPR30,     "FPR30" },
    { CV_PPC_FPR31,     "FPR31" },

    // PowerPC Floating Point Status and Control Register (User Level)

    { CV_PPC_FPSCR,     "FPSCR" },

    // PowerPC Machine State Register (Supervisor Level)

    { CV_PPC_MSR,       "MSR"   },

    // PowerPC Segment Registers (Supervisor Level)

    { CV_PPC_SR0,       "SR0"   },
    { CV_PPC_SR1,       "SR1"   },
    { CV_PPC_SR2,       "SR2"   },
    { CV_PPC_SR3,       "SR3"   },
    { CV_PPC_SR4,       "SR4"   },
    { CV_PPC_SR5,       "SR5"   },
    { CV_PPC_SR6,       "SR6"   },
    { CV_PPC_SR7,       "SR7"   },
    { CV_PPC_SR8,       "SR8"   },
    { CV_PPC_SR9,       "SR9"   },
    { CV_PPC_SR10,      "SR10"  },
    { CV_PPC_SR11,      "SR11"  },
    { CV_PPC_SR12,      "SR12"  },
    { CV_PPC_SR13,      "SR13"  },
    { CV_PPC_SR14,      "SR14"  },
    { CV_PPC_SR15,      "SR15"  },

    // For all of the special purpose registers add 100 to the SPR# that the
    // Motorola/IBM documentation gives with the exception of any imaginary
    // registers.

    // PowerPC Special Purpose Registers (User Level)

    { CV_PPC_PC,        "PC"    },    // PC (imaginary register)

    { CV_PPC_MQ,        "MQ"    },    // MPC601
    { CV_PPC_XER,       "XER"   },
    { CV_PPC_RTCU,      "RTCU"  },    // MPC601
    { CV_PPC_RTCL,      "RTCL"  },    // MPC601
    { CV_PPC_LR,        "LR"    },
    { CV_PPC_CTR,       "CTR"   },

    // PowerPC Special Purpose Registers (Supervisor Level)

    { CV_PPC_DSISR,     "DSISR" },
    { CV_PPC_DAR,       "DAR"   },
    { CV_PPC_DEC,       "DEC"   },
    { CV_PPC_SDR1,      "SDR1"  },
    { CV_PPC_SRR0,      "SRR0"  },
    { CV_PPC_SRR1,      "SRR1"  },
    { CV_PPC_SPRG0,     "SPRG0" },
    { CV_PPC_SPRG1,     "SPRG1" },
    { CV_PPC_SPRG2,     "SPRG2" },
    { CV_PPC_SPRG3,     "SPRG3" },
    { CV_PPC_ASR,       "ASR"   },    // 64-bit implementations only
    { CV_PPC_EAR,       "EAR"   },
    { CV_PPC_PVR,       "PVR"   },
    { CV_PPC_BAT0U,     "BAT0U" },
    { CV_PPC_BAT0L,     "BAT0L" },
    { CV_PPC_BAT1U,     "BAT1U" },
    { CV_PPC_BAT1L,     "BAT1L" },
    { CV_PPC_BAT2U,     "BAT2U" },
    { CV_PPC_BAT2L,     "BAT2L" },
    { CV_PPC_BAT3U,     "BAT3U" },
    { CV_PPC_BAT3L,     "BAT3L" },
    { CV_PPC_DBAT0U,    "DBAT0U" },
    { CV_PPC_DBAT0L,    "DBAT0L" },
    { CV_PPC_DBAT1U,    "DBAT1U" },
    { CV_PPC_DBAT1L,    "DBAT1L" },
    { CV_PPC_DBAT2U,    "DBAT2U" },
    { CV_PPC_DBAT2L,    "DBAT2L" },
    { CV_PPC_DBAT3U,    "DBAT3U" },
    { CV_PPC_DBAT3L,    "DBAT3L" },

    // PowerPC Special Purpose Registers Implementation Dependent (Supervisor Level)

    // Doesn't appear that IBM/Motorola has finished defining these.

    { CV_PPC_PMR0,      "PMR0"  },   // MPC620
    { CV_PPC_PMR1,      "PMR1"  },   // MPC620
    { CV_PPC_PMR2,      "PMR2"  },   // MPC620
    { CV_PPC_PMR3,      "PMR3"  },   // MPC620
    { CV_PPC_PMR4,      "PMR4"  },   // MPC620
    { CV_PPC_PMR5,      "PMR5"  },   // MPC620
    { CV_PPC_PMR6,      "PMR6"  },   // MPC620
    { CV_PPC_PMR7,      "PMR7"  },   // MPC620
    { CV_PPC_PMR8,      "PMR8"  },   // MPC620
    { CV_PPC_PMR9,      "PMR9"  },   // MPC620
    { CV_PPC_PMR10,     "PMR10" },   // MPC620
    { CV_PPC_PMR11,     "PMR11" },   // MPC620
    { CV_PPC_PMR12,     "PMR12" },   // MPC620
    { CV_PPC_PMR13,     "PMR13" },   // MPC620
    { CV_PPC_PMR14,     "PMR14" },   // MPC620
    { CV_PPC_PMR15,     "PMR15" },   // MPC620

    { CV_PPC_DMISS,     "DMISS" },   // MPC603
    { CV_PPC_DCMP,      "DCMP"  },   // MPC603
    { CV_PPC_HASH1,     "HASH1" },   // MPC603
    { CV_PPC_HASH2,     "HASH2" },   // MPC603
    { CV_PPC_IMISS,     "IMISS" },   // MPC603
    { CV_PPC_ICMP,      "ICMP"  },   // MPC603
    { CV_PPC_RPA,       "RPA"   },   // MPC603

    { CV_PPC_HID0,      "HID0"  },   // MPC601, MPC603, MPC620
    { CV_PPC_HID1,      "HID1"  },   // MPC601
    { CV_PPC_HID2,      "HID2"  },   // MPC601, MPC603, MPC620 (IABR)
    { CV_PPC_HID3,      "HID3"  },   // Not Defined
    { CV_PPC_HID4,      "HID4"  },   // Not Defined
    { CV_PPC_HID5,      "HID5"  },   // MPC601, MPC604, MPC620 (DABR)
    { CV_PPC_HID6,      "HID6"  },   // Not Defined
    { CV_PPC_HID7,      "HID7"  },   // Not Defined
    { CV_PPC_HID8,      "HID8"  },   // MPC620 (BUSCSR)
    { CV_PPC_HID9,      "HID9"  },   // MPC620 (L2CSR)
    { CV_PPC_HID10,     "HID10" },   // Not Defined
    { CV_PPC_HID11,     "HID11" },   // Not Defined
    { CV_PPC_HID12,     "HID12" },   // Not Defined
    { CV_PPC_HID13,     "HID13" },   // MPC604 (HCR)
    { CV_PPC_HID14,     "HID14" },   // Not Defined
    { CV_PPC_HID15,     "HID15" }    // MPC601, MPC604, MPC620 (PIR)
};

const REGINFO rgRegInfoAlpha[] = {
    { CV_ALPHA_NOREG, "NOREG" },
    { CV_ALPHA_FltF0, "F0" },
    { CV_ALPHA_FltF1, "F1" },
    { CV_ALPHA_FltF2, "F2" },
    { CV_ALPHA_FltF3, "F3" },
    { CV_ALPHA_FltF4, "F4" },
    { CV_ALPHA_FltF5, "F5" },
    { CV_ALPHA_FltF6, "F6" },
    { CV_ALPHA_FltF7, "F7" },
    { CV_ALPHA_FltF8, "F8" },
    { CV_ALPHA_FltF9, "F9" },
    { CV_ALPHA_FltF10, "F10" },
    { CV_ALPHA_FltF11, "F11" },
    { CV_ALPHA_FltF12, "F12" },
    { CV_ALPHA_FltF13, "F13" },
    { CV_ALPHA_FltF14, "F14" },
    { CV_ALPHA_FltF15, "F15" },
    { CV_ALPHA_FltF16, "F16" },
    { CV_ALPHA_FltF17, "F17" },
    { CV_ALPHA_FltF18, "F18" },
    { CV_ALPHA_FltF19, "F19" },
    { CV_ALPHA_FltF20, "F20" },
    { CV_ALPHA_FltF21, "F21" },
    { CV_ALPHA_FltF22, "F22" },
    { CV_ALPHA_FltF23,   "F23" },
    { CV_ALPHA_FltF24,   "F24" },
    { CV_ALPHA_FltF25,   "F25" },
    { CV_ALPHA_FltF26,   "F26" },
    { CV_ALPHA_FltF27,   "F27" },
    { CV_ALPHA_FltF28,   "F28" },
    { CV_ALPHA_FltF29,   "F29" },
    { CV_ALPHA_FltF30,   "F30" },
    { CV_ALPHA_FltF31,   "F31" },
    { CV_ALPHA_IntV0,   "V0" },
    { CV_ALPHA_IntT0,   "T0" },
    { CV_ALPHA_IntT1,   "T1" },
    { CV_ALPHA_IntT2,   "T2" },
    { CV_ALPHA_IntT3,   "T3" },
    { CV_ALPHA_IntT4,   "T4" },
    { CV_ALPHA_IntT5,   "T5" },
    { CV_ALPHA_IntT6,   "T6" },
    { CV_ALPHA_IntT7,   "T7" },
    { CV_ALPHA_IntS0,   "S0" },
    { CV_ALPHA_IntS1,   "S1" },
    { CV_ALPHA_IntS2,   "S2" },
    { CV_ALPHA_IntS3,   "S3" },
    { CV_ALPHA_IntS4,   "S4" },
    { CV_ALPHA_IntS5,   "S5" },
    { CV_ALPHA_IntFP,   "FP" },
    { CV_ALPHA_IntA0,   "A0" },
    { CV_ALPHA_IntA1,   "A1" },
    { CV_ALPHA_IntA2,   "A2" },
    { CV_ALPHA_IntA3,   "A3" },
    { CV_ALPHA_IntA4,   "A4" },
    { CV_ALPHA_IntA5,   "A5" },
    { CV_ALPHA_IntT8,   "T8" },
    { CV_ALPHA_IntT9,   "T9" },
    { CV_ALPHA_IntT10,  "T10" },
    { CV_ALPHA_IntT11,  "T11" },
    { CV_ALPHA_IntRA,   "RA" },
    { CV_ALPHA_IntT12,  "T12" },
    { CV_ALPHA_IntAT,   "AT" },
    { CV_ALPHA_IntGP,   "GP" },
    { CV_ALPHA_IntSP,   "SP" },
    { CV_ALPHA_IntZERO, "ZERO" },
    { CV_ALPHA_Fpcr,    "FPCR" },
    { CV_ALPHA_Fir, "FIR" },
    { CV_ALPHA_Psr, "PSR" },
    { CV_ALPHA_FltFsr,  "FSR" },
};

INT __cdecl
RegInfoCmp (
    const VOID * lpElem1,
    const VOID * lpElem2
    )
{
    if (((LPREGINFO)lpElem1)->wIndex < ((LPREGINFO)lpElem2)->wIndex) {
        return (-1);
    } else if (((LPREGINFO)lpElem1)->wIndex > ((LPREGINFO)lpElem2)->wIndex) {
        return (1);
    } else {
        return (0);
    }
}

//  SHGetSymLoc
//
//  Input:
//      hSym    - A handle to the symbol to get a location.
//      lsz     - Where to write the result.
//      cbMax   - Size of lsz.
//      pcxt    - Context.
//
//  Output:
//      lsz filled in.
//
//  Returns - The number of bytes written to the string.
//
//  Notes: lpSym emspage must be loaded

int
SHGetSymLoc (
    HSYM hsym,
    LSZ lsz,
    UINT cbMax,
    PCXT pcxt
    )
{
    SYMPTR lpsym = (SYMPTR) hsym;
    char rgch[20];
    MPT TargetMachine;

    if (cbMax == 0) {
        return 0;
    }

    // What machine is this?

    TargetMachine = GetTargetMachine(pcxt);

    memset(rgch, '\0', sizeof(rgch));

    switch (lpsym->rectyp) {
        case S_BPREL32:
            {
                long off = (long) ((BPRELPTR32) lpsym)->off;
                const char *szFMT;
                char ch;
                const char *szBPREG;

                switch (TargetMachine) {
                    case mptm68k:
                        szBPREG = "A6";
                        break;

                    case mptmppc:
                        szBPREG = "[SP]";
                        break;

                    default:
                        szBPREG = "EBP";
                        break;
                }

                if (off < 0) {
                    ch = '-';
                    off = -off;
                } else {
                    ch = '+';
                }

                if (HIWORD(off)) {
                    szFMT = "[%s%c%08lX]";
                } else {
                    szFMT = "[%s%c%04lX]";
                }

                sprintf(rgch, szFMT, szBPREG, ch, off);
            }
            break;

        case S_REGREL32:
            {
                long off = (long) ((LPREGREL32) lpsym)->off;
                short reg = ((LPREGREL32)lpsym)->reg;
                char *lpch = rgch;
                REGINFO     regInfo;
                LPREGINFO   lpRegInfo;
                char    ch;
                const char *szFMT;
                const char *szRegName;

                // UNDONE: Only Alpha really does this right.  Fix the rest.

                switch (TargetMachine) {
                    case mptdaxp:
                        regInfo.wIndex = reg;

                        lpRegInfo = (LPREGINFO) bsearch(&regInfo,
                                            rgRegInfoAlpha,
                                            sizeof (rgRegInfoAlpha) / sizeof (rgRegInfoAlpha[0]),
                                            sizeof (rgRegInfoAlpha[0]),
                                            &RegInfoCmp);

                        assert (lpRegInfo);
                        szRegName = lpRegInfo->szName;
                        break;

                    case mptmips:
                        switch (reg) {
                            case CV_M4_IntSP:
                                szRegName = "SP";
                                break;
                            case CV_M4_IntS8:
                                szRegName = "S8";
                                break;
                            case CV_M4_IntGP:
                                szRegName = "GP";
                                break;
                            default:
                                szRegName = "REG";
                                break;
                        }
                        break;

                    default:
                        szRegName = "REG";
                }

                if (off < 0) {
                    ch = '-';
                    off = -off;
                } else {
                    ch = '+';
                }

                if (HIWORD(off)) {
                    szFMT = "[%s%c%08lX]";
                } else {
                    szFMT = "[%s%c%04lX]";
                }

                sprintf(lpch, szFMT, szRegName, ch, off);
            }
            break;

        case S_REGISTER:
            {
                WORD        iReg1, iReg2;
                REGINFO     regInfo;
                LPREGINFO   lpRegInfo;

                // UNDONE: Again, I think Alpha is the only one to do it right...

                switch (TargetMachine) {
                    case mptm68k:
                        iReg1 = (((REGPTR) lpsym)->reg) & 0x00ff;
                        _tcscpy (rgch, M68KRegisterName [iReg1]);
                        break;

                    case mptdaxp:
                        iReg1 = (((REGPTR) lpsym)->reg);

                        regInfo.wIndex = iReg1;

                        lpRegInfo = (LPREGINFO) bsearch (&regInfo,
                                             rgRegInfoAlpha,
                                             sizeof (rgRegInfoAlpha) / sizeof (rgRegInfoAlpha[0]),
                                             sizeof (rgRegInfoAlpha[0]),
                                             &RegInfoCmp);
                        assert (lpRegInfo);
                        _tcscpy (rgch, lpRegInfo->szName);
                        break;

                    case mptmppc:
                    case mptntppc:
                        iReg1 = (((REGPTR) lpsym)->reg);

                        regInfo.wIndex = iReg1;

                        lpRegInfo = (LPREGINFO) bsearch (&regInfo,
                                             rgRegInfoPPC,
                                             sizeof (rgRegInfoPPC) / sizeof (rgRegInfoPPC[0]),
                                             sizeof (rgRegInfoPPC[0]),
                                             &RegInfoCmp);
                        assert (lpRegInfo);
                        _tcscpy (rgch, lpRegInfo->szName);
                        break;

                    case mptmips:
                        // UNDONE: Need to add the MIPS register definitions
                        rgch[0] = '\0';
                        break;

                    case mptix86:
                        iReg1 = (((REGPTR) lpsym)->reg) & 0x00ff;
                        iReg2 = ((((REGPTR)lpsym)->reg) >> 8) & 0x00ff;

                        rgch[0] = '\0';

                        if (iReg2) {
                            _tcscat (rgch, X86RegisterName [iReg2]);
                            _tcscat (rgch, ":");
                        }

                        _tcscat (rgch, X86RegisterName [iReg1]);
                        break;
                }
                _tcscat (rgch, " reg");
            }
            break;

        case S_CONSTANT: {
            HTYPE   htype;
            lfOEM * ptype;

            htype = THGetTypeFromIndex (
                SHHMODFrompCXT (pcxt),
                ((CONSTSYM *)lpsym)->typind
           );

            if (htype) {
                ptype = (lfOEM *)MMLock ((HDEP)htype);

                ptype = (lfOEM *)&(((TYPTYPE *)ptype)->leaf);

                if (ptype->cvOEM != OEM_MS_FORTRAN90) {
                    _tcscpy (rgch, "constant");
                }

                MMUnlock ((HDEP) htype);
            }

            break;
        }

        case S_PUB32:
        case S_LDATA32:
        case S_GDATA32:
        case S_LTHREAD32:
        case S_GTHREAD32:
            {
                ADDR addr = {0};

                assert (pcxt->hMod != 0);

                SetAddrSeg (&addr, ((DATAPTR32) lpsym)->seg);
                SetAddrOff (&addr, ((DATAPTR32) lpsym)->off);
                emiAddr (addr) = (HEMI) SHHexeFromHmod (pcxt->hMod);
                ADDR_IS_LI (addr) = TRUE;
                // REVIEW - billjoy - not necessarily ADDRLIN32.  How do we tell?
                ADDRLIN32 (addr);
                SYFixupAddr (&addr);

                if (ADDR_IS_LI (addr) != TRUE) {
                    if ((GetAddrSeg(addr) != 0) && (TargetMachine == mptm68k))
                        sprintf(rgch, "%04X:%08lX", GetAddrSeg(addr), GetAddrOff(addr));
                    else
                        sprintf(rgch, "%08lX", GetAddrOff(addr));
                }
            }
            break;

        case S_LPROC32:
        case S_GPROC32:
            {
                ADDR addr = {0};

                assert (pcxt->hMod != 0);

                SetAddrSeg (&addr, ((PROCPTR32) lpsym)->seg);
                SetAddrOff (&addr, ((PROCPTR32) lpsym)->off);
                emiAddr (addr) = (HEMI) SHHexeFromHmod (pcxt->hMod);
                ADDR_IS_LI (addr) = TRUE;
                // REVIEW - billjoy - not necessarily ADDRLIN32.  How do we tell?
                ADDRLIN32 (addr);

                SYFixupAddr (&addr);

                if (ADDR_IS_LI (addr) != TRUE) {
                    if ((GetAddrSeg(addr) != 0) && (TargetMachine == mptm68k))
                        sprintf(rgch, "%04X:%08lX", GetAddrSeg(addr), GetAddrOff(addr));
                    else
                        sprintf(rgch, "%08lX", GetAddrOff(addr));
                }
            }

            break;

        case S_LPROCMIPS:
        case S_GPROCMIPS:
            {
                ADDR addr = {0};

                assert (pcxt->hMod != 0);

                SetAddrSeg (&addr, ((PROCPTRMIPS) lpsym)->seg);
                SetAddrOff (&addr, ((PROCPTRMIPS) lpsym)->off);
                emiAddr (addr) = (HEMI) SHHexeFromHmod (pcxt->hMod);
                ADDR_IS_LI (addr) = TRUE;
                // REVIEW - billjoy - not necessarily ADDRLIN32.  How do we tell?
                // Do we even care here (MIPS)?
                ADDRLIN32 (addr);

                SYFixupAddr (&addr);

                if (ADDR_IS_LI (addr) != TRUE) {
                    if ((GetAddrSeg(addr) != 0) && (TargetMachine == mptm68k))
                        sprintf(rgch, "%04X:%08lX", GetAddrSeg(addr), GetAddrOff(addr));
                    else
                        sprintf(rgch, "%08lX", GetAddrOff(addr));
                }
            }

            break;
    }

    _tcsncpy (lsz, rgch, cbMax);
    lsz[cbMax-1] = '\0';    // ensure that it's null-terminated

    return _tcslen (lsz);
}

LPV
SHLpGSNGetTable(
    HEXE hexe
    )
{
    LPB     lpb = NULL;
	LPEXE	lpexe = NULL;
	LPEXG	lpexg = NULL;

    if (hexe) {
		lpexe = (LPEXE) LLLock (hexe);
        assert (lpexe && lpexe->hexg);
		lpexg = (LPEXG) LLLock (lpexe->hexg);
		lpb = lpexg->lpgsi;
        LLUnlock (lpexe->hexg);
        LLUnlock (hexe);
    }
    return (LPV)lpb;
}

SHFLAG PHExactCmp (HVOID, HVOID, LSZ, SHFLAG);

HSYM
SHFindSymInExe (
    HEXE   hexe,
    LPSSTR lpsstr,
    BOOL   fCaseSensitive
    )
{
    CXT  cxt    = { 0 };
    CXT  cxtOut = { 0 };
    HSYM hsym   = NULL;

    cxt.hMod = 0;

    // First search all of the modules in the exe

    while (!hsym && (cxt.hMod = SHGetNextMod (hexe, cxt.hMod)) != 0)
    {
        hsym = SHFindNameInContext(NULL,
                                    &cxt,
                                    lpsstr,
                                    fCaseSensitive,
                                    PHExactCmp,
                                    &cxtOut);
    }

#pragma message("REVIEW: Should SHFindSymInExe call PHFindNameInPublics???")
#if 0

    // UNDONE: Perhaps for NTSD support?

    // This code is very expensive and yet has no effect!!!
    // It ignores the HSYM which is returned by PHFindNameInPublics!
    //
    // I'm not sure which is the best fix -- putting "hsym ="
    // in front of the call to PHFindNameInPublics, or disabling
    // this code entirely.  Since the old way seems to have
    // works fine without causing any trouble, I'm going to
    // just disable it for now.  But this should be revisited.
    // The name of this function (SHFindSymInExe) implies
    // to the caller that it searches publics as well as other
    // symbols.  [mikemo]
    if (!hsym) {
        PHFindNameInPublics (
            NULL,
            hexe,
            lpsstr,
            fCaseSensitive,
            PHExactCmp
       );
    }
#endif

    return hsym;
}

BOOL
SHFindSymbol (
    LSZ   lsz,
    PADDR lpaddr,
    LPASR lpasr
    )
{
    ADDR addr   = *lpaddr;
    CXT  cxt    = {0};
    CXT  cxtOut = {0};
    SSTR sstr   = {0};
    HSYM hsym   = NULL;
    HEXE hexe   = hexeNull;
    BOOL fCaseSensitive = TRUE;

    // Get a context for the code address that was passed in

    SYUnFixupAddr (&addr);
    SHSetCxt (&addr, &cxt);
    hexe = SHHexeFromHmod (cxt.hMod);

    // Do an outward context search

    sstr.lpName = (LPB) lsz;
    sstr.cb = (BYTE)_tcslen (lsz);

    // Search all of the blocks & procs outward

    while ((cxt.hBlk || cxt.hProc) && !hsym) {
        hsym = SHFindNameInContext(NULL,
                                   &cxt,
                                   &sstr,
                                   fCaseSensitive,
                                   PHExactCmp,
                                   &cxtOut);

        SHGoToParent (&cxt, &cxt);
    }

    if (!hsym) {
        hsym = SHFindSymInExe (hexe, &sstr, fCaseSensitive);
    }

    if (!hsym) {
        hexe = hexeNull;

        while (!hsym && (hexe = SHGetNextExe (hexe))) {
            hsym = SHFindSymInExe (hexe, &sstr, fCaseSensitive);
        }
    }

    if (hsym) {
        // Package up the symbol and send it back

        switch (((SYMPTR) hsym)->rectyp) {
            case S_REGISTER:
                lpasr->ast  = astRegister;
                lpasr->ireg = ((REGPTR) hsym)->reg;
                break;

            case S_BPREL32:
                lpasr->ast = astBaseOff;
                lpasr->off = ((BPRELPTR32) hsym)->off;
                break;

            case S_REGREL32:
               lpasr->ast = astBaseOff;
               lpasr->off = ((LPREGREL32) hsym)->off;
               break;

            case S_LDATA32:
            case S_LTHREAD32:
                lpasr->fcd = fcdData;
                goto setaddress;

            case S_GPROC32:
            case S_LPROC32:
                lpasr->fcd =
                    (((PROCPTR32) hsym)->flags.CV_PFLAG_FAR) ?
                    fcdFar : fcdNear;
                goto setaddress;

            case S_GPROCMIPS:
            case S_LPROCMIPS:
               lpasr->fcd = fcdNear;
               goto setaddress;

            case S_LABEL32:
            case S_THUNK32:
            case S_WITH32:
            case S_PUB32:
                lpasr->fcd = fcdUnknown;
setaddress:
                lpasr->ast = astAddress;
                SHAddrFromHsym (&lpasr->addr, hsym);
                emiAddr (lpasr->addr) = (HEMI) hexe;
                lpasr->addr.mode.fIsLI = TRUE;
                SYFixupAddr (&lpasr->addr);
                break;

            default:
                hsym = NULL;
                break;
        }
    }

    if (hsym) {
        return TRUE;
    } else {
        // We didn't find anything so return false
        lpasr->ast = astNone;

        return FALSE;
    }
}

void
SetAddrFromMod(
    LPMDS lpmds,
    UNALIGNED ADDR* paddr
    )
{
    if (lpmds->pmod) {
        ISECT isect;
        OFF off;
        BOOL fTmp = ModQuerySecContrib(lpmds->pmod, &isect, &off, NULL, NULL);
        assert(fTmp);
        SetAddrSeg (paddr, isect);
        SetAddrOff (paddr, off);
    } else {
        SetAddrSeg (paddr, lpmds->lpsgc[0].seg);
        SetAddrOff (paddr, (UOFFSET)lpmds->lpsgc[0].off);
    }
}

LPVOID
SHGetDebugData(
    HEXE hexe
    )
{
    // UNDONE: Why make the copy the debugData?  BryanT - Still to resolve.

    LPDEBUGDATA lpd = NULL;

    if (hexe) {
        LPEXE lpexe = (LPEXE) LLLock(hexe);

        if (!lpexe->pDebugData) {

            HEXG        hexg;
            LPEXG       lpexg;

            hexg = ((LPEXE)LLLock(hexe))->hexg;
            assert(hexg);

            lpexg = (LPEXG)LLLock(hexg);

            // This is the first time the debug data was requested.  Fix it up appropriately
            if (lpexe->LoadAddress == lpexg->LoadAddress) {
                // The address for the first image is the same as the load address.
                // Nothing else to do.
                lpexe->pDebugData = &lpexg->debugData;
            } else {

                if (lpexg->fIsRisc) {

                    DWORD size;

                    lpexe->pDebugData = (LPDEBUGDATA) MHAlloc(sizeof(DEBUGDATA));
                    *lpexe->pDebugData = lpexg->debugData;
                    size = lpexe->pDebugData->cRtf * sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY);
                    lpexe->pDebugData->lpRtf = (PIMAGE_RUNTIME_FUNCTION_ENTRY) MHAlloc(size);
                    memmove(lpexe->pDebugData->lpRtf, lpexg->debugData.lpRtf, size);

                    // Fix up any pdata for functions that have moved.
                    ULONG   index;
                    LONG    diff = lpexe->LoadAddress - lpexg->LoadAddress;
                    PIMAGE_RUNTIME_FUNCTION_ENTRY rf = lpexe->pDebugData->lpRtf;
                    for (index=0; index < lpexe->pDebugData->cRtf; index++) {
                        rf[index].BeginAddress += diff;
                        rf[index].EndAddress += diff;
                        rf[index].PrologEndAddress += diff;
                    }

                } else {
                    lpexe->pDebugData = &lpexg->debugData;
                }
            }
            LLUnlock(hexg);
        }

		if (lpexe->pDebugData->cOmapFrom || lpexe->pDebugData->cOmapTo)
		{
			assert( lpexe->pDebugData->dwOrigAlign!=0);			// ensure Lego alignment obtained
		}

        lpd = (LPDEBUGDATA) MHAlloc(sizeof (*lpd));
        assert(lpd);
        if (lpd != NULL) {
           *lpd = *lpexe->pDebugData;
        }
        LLUnlock(hexe);
    }

    return (LPVOID)lpd;
}

BOOL
SHIsThunk(
    HSYM			hsym,
	THUNK_ORDINAL*	ordinal,
	ULONG*			length
    )
{
    SYMPTR		psym = (SYMPTR) hsym;
	THUNKSYM32*	thunk = (THUNKSYM32*) psym;

	if (psym->rectyp != S_THUNK32) {
		return FALSE;
	}

	if (ordinal) {
		*ordinal = (THUNK_ORDINAL) thunk->ord;
	}

	if (length) {
		*length = thunk->len;
	}

	return TRUE;
}


#if 0
// VC 4.1 shsymbol.c version.  Changed to 2 passes to support long file names
// Merge into the above code once you understand the implications...

// BryanT 1-19-96

/*** SHGethExeFromName
*
*   Purpose: To get an Exe handle given a name, or partial name
*
*   Input:
*	szPath	- The path or filename of the exe
*
*   Output:
*
*   Returns:
*	    A handle to the exe or NULL on error
*
*   Exceptions:
*
*   Notes:
*
*************************************************************************/
HEXE LOADDS PASCAL SHGethExeFromName ( LPTSTR ltszPath ) {
	HEXE	hexe;
	HEXE	hexeEnd;
	HEXE	hexeMatch = (HEXE)NULL;
	CHAR *  szOMFPath;
	CHAR    szOMFFile[_MAX_CVFNAME];
	CHAR    szOMFExt[_MAX_CVEXT];
	CHAR    szName[_MAX_CVPATH];
	CHAR    szFile[_MAX_CVFNAME];
	CHAR    szExt[_MAX_CVEXT];
	int     iNameEnd;
	LPTSTR	lptchEnd = NULL;
	int		iPass;
	WIN32_FIND_DATA wfd;

	// get the start of the exe list, or return an error if we can't get one
    if( !ltszPath || !(*ltszPath) ||
      !(hexe = hexeEnd = SHGetNextExe ( (HEXE)NULL )) ) {
		return( (HEXE)NULL );
	}

    /*
	 *	Does this module come with a file handle attached to it?  If so,
     *  copy the path into the buffer where the path is to go and get
     *  the full path name for the file.
     */

    if (*ltszPath == '|') {
		ltszPath++;
		lptchEnd = _ftcschr(ltszPath, '|');
		assert(lptchEnd);
		if (lptchEnd)
			*lptchEnd = '\0';
    }

	// split it to the root name and extension

    SHSplitPath ( ltszPath, NULL, NULL, szFile, szExt );
	if ( !szExt[0]	||	!szExt[1] ) {
		szExt[0] = '\0';
	}

	// we haven't yet determined the full path of the input name
	szName[0] = '\0';

	// Make two passes thru the exes - the second pass checks for matching
	// alternate (long vs 8.3) names
	for (iPass=0; iPass < 2; iPass++)
	{
		if (iPass == 1)
		{
			if ( !_tfullpath ( szName, ltszPath, sizeof ( szName ) ) ) {
				return( (HEXE)NULL );
			}
			if ( (HANDLE f=FindFirstFile(szName, &wfd)) != INVALID_HANDLE_VALUE)
			{
				FindClose(f);
				// If the long and short names are identical, don't bother with
				// this extra pass
				if ( !_ftcsicmp ( wfd.cFileName, wfd.cAlternateFileName )) {
					goto exit;
				}
				SHSplitPath( wfd.cFileName, NULL, NULL, szFile, szExt);
			}
			else
			{
				// can't just return NULL here (hexeMatch may be set)
				goto exit;
			}
			// Reset the iteration mechanism to the first exe
			hexe = SHGetNextExe ( (HEXE)NULL );
		}

		do {

			// get the full exe name
			// WARNING: this assumes pointers are the same as handles!!!
			szOMFPath = SHGetExeName( hexe );

			// get the extension
			SHSplitPath ( szOMFPath, NULL, NULL, szOMFFile, szOMFExt );

			// check for match
			if ( !_ftcsicmp ( szOMFFile, szFile ) &&
				!_ftcsicmp ( szOMFExt, szExt )
			) {

				// if we haven't done _tfullpath yet, do it now
				if (szName[0] == '\0') {
					if ( !_tfullpath ( szName, ltszPath, sizeof ( szName ) ) ) {
						return( (HEXE)NULL );
					}

					iNameEnd = _ftcslen(szName);
					if( *_ftcsdec( szName, &szName[iNameEnd] ) == '.' ) {
					   szName[--iNameEnd] = '\0';
					}
				}

				// check for exact match, need the full path, but we know
				// exe names are stored as full paths so szOMFPath is a full path

				// if no extension, put the current extension on

				if ( !szExt[0] && szOMFExt[0] ) {
					_ftcscpy(szName + iNameEnd, szOMFExt);
				}

				// see if these are the same

				if ( !_ftcsicmp( szOMFPath, szName ) ) {
					hexeMatch = hexe;
					goto exit;
				}

				if ( !szExt[0] ) {
					szName[iNameEnd] = '\0';
				}

				// save away the first potential match
				if( !hexeMatch ) {
					hexeMatch = hexe;
				}
			}
		} while ( hexe = SHGetNextExe ( hexe ) );
	}

exit:
	// restore '|'
	if (lptchEnd)
		*lptchEnd = '|';

	return(hexeMatch);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\shsymlb0.cpp ===
//  SHsymlb0.c - general library routines to find an omff symbol by name or address.
//
//  Copyright <C> 1988-94, Microsoft Corporation
//
//  Purpose: To supply a concise interface to the debug omf for symbols
//
//      10-Nov-94 BryanT
//          Merge in NT changes.
//          SHIsAddrInMod -> IsAddrInMod
//          Delete SHszDir/SHszDrive/SHszDebuggeeDrive/SHszDebuggeeDir.  Not used
//          Make SHSetDebuggeeDir a shell since there is no usage for the dir.
//          Delete special case Mac targeting S_CEXMODEL32 handling.
//          Remove ems code from SHpSymlplLabLoc.
//          Add support for S_THUNK16/S_THUNK32 in SHpSymlplLabLoc.
//          Replace local statics with a Cache entry.
//          Remove SHModelFromCxt (no callers and not exposed).

#include "shinc.hpp"
#pragma hdrstop

//
//  fundamental source line lookup routines
//

VOID
SHSetDebuggeeDir (
    LSZ lszDir
    )
{
    // Functionality not used any longer.
    return;
}


//  SHpSymlplLabLoc
//
//  Purpose: To completely fill in a plpl pkt. The hmod and addr must already
//           be valid. The locals and labels are searched based on paddr. The
//           whole module is search for now. Better decisions may be made in the
//           future.
//
//
//  Input:
//      plpl    - lpl packet with a valid module and address in it.
//
//  Output:
//      plpl    - Is updated with Proc, Local, and Label.
//
// Notes: This includes locals and lables

VOID
SHpSymlplLabLoc (
    LPLBS lplbs
    )
{
    SYMPTR      lpSym = NULL;
    SYMPTR      lpSymEnd;
    LPMDS       lpmds;
    ULONG       cbMod = 0;
    CV_uoff32_t obModelMin = 0;
    CV_uoff32_t obModelMax = CV_MAXOFFSET;
    CV_uoff32_t obTarget;
    CV_uoff32_t doffNew;
    CV_uoff32_t doffOld;

    // for now we are doing the whole module

    lplbs->tagLoc   = NULL;
    lplbs->tagLab   = NULL;
    lplbs->tagProc  = NULL;
    lplbs->tagThunk = NULL;
    lplbs->tagModelMin = NULL;
    lplbs->tagModelMax = NULL;

    if (!lplbs->tagMod) {
        return;
    }

    // because segments of locals don't have to match the segment of the
    // searched module, check segment here is wrong. However we can set
    // a flag up for proc and labels

    lpmds    = (LPMDS) lplbs->tagMod;
    obTarget = GetAddrOff (lplbs->addr);

    // add/subtract the size of the hash table ptr

    lpSym = (SYMPTR) ((LPB) GetSymbols (lpmds) + sizeof(long));
    cbMod    = lpmds->cbSymbols;
    lpSymEnd = (SYMPTR) ((BYTE *) lpSym + cbMod - sizeof (long));

    while(lpSym < lpSymEnd) {

        switch(lpSym->rectyp) {
            case S_CEXMODEL32:
                if (((WORD)(((CEXMPTR32)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr))) {
                    CV_uoff32_t obTemp = (CV_uoff32_t)(((CEXMPTR32)lpSym)->off);
                    if (obTemp <= obModelMax) {
                        if (obTemp > obTarget) {
                            lplbs->tagModelMax = (CEXMPTR32)lpSym;
                            obModelMax = obTemp;
                        }
                        else if (obTemp >= obModelMin) {
                            lplbs->tagModelMin = (CEXMPTR32)lpSym;
                            obModelMin = obTemp;
                        }
                    }
                }
                break;

            case S_LPROC32:
            case S_GPROC32:
                if (((WORD)(((PROCPTR32)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr)) &&
                  ((CV_uoff32_t)(((PROCPTR32)lpSym)->off) <= obTarget) &&
                  (obTarget < ((CV_uoff32_t)(((PROCPTR32)lpSym)->off) + (CV_uoff32_t)(((PROCPTR32)lpSym)->len)))) {
                    lplbs->tagProc = (SYMPTR)lpSym;
                }
                break;

            case S_LPROCMIPS:
            case S_GPROCMIPS:
                if (((WORD)(((PROCPTRMIPS)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr)) &&
                  ((CV_uoff32_t)(((PROCPTRMIPS)lpSym)->off) <= obTarget) &&
                  (obTarget < ((CV_uoff32_t)(((PROCPTRMIPS)lpSym)->off) + (CV_uoff32_t)(((PROCPTRMIPS)lpSym)->len)))) {
                    lplbs->tagProc = (SYMPTR)lpSym;
                }
                break;

            case S_LABEL32:
                if (((WORD)(((LABELPTR32)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr)) &&
                    (((CV_uoff32_t)((LABELPTR32)lpSym)->off) <= obTarget)) {
                    doffNew = obTarget - (CV_uoff32_t)(((LABELPTR32)lpSym)->off);

                    // calculate what the old offset was, this requires no
                    // use of static variables

                    doffOld = obTarget;

                    if (lplbs->tagLab) {
                        doffOld -= (CV_uoff32_t)(((LABELPTR32)lplbs->tagLab)->off);
                    }

                    if (doffNew <= doffOld) {
                        lplbs->tagLab = (SYMPTR)lpSym;
                    }
                }
                break;

            case S_LDATA32:
            case S_GDATA32:
            case S_LTHREAD32:
            case S_GTHREAD32:
                if (((WORD)(((DATAPTR32)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr)) &&
                  ((CV_uoff32_t)(((DATAPTR32)lpSym)->off) <= obTarget)) {
                    doffNew = obTarget - (CV_uoff32_t)(((DATAPTR32)lpSym)->off);

                    // calculate what the old offset was.
                    doffOld = obTarget;

                    if (lplbs->tagLoc) {
                        doffOld -= (CV_uoff32_t)(((DATAPTR32)lplbs->tagLoc)->off);
                    }

                    if (doffNew <= doffOld) {
                        lplbs->tagLoc = (SYMPTR) lpSym;
                    }
                }
                break;

            case S_THUNK32:
                if (((WORD)(((THUNKPTR32)lpSym)->seg) == (WORD)GetAddrSeg (lplbs->addr)) &&
                    ((CV_uoff32_t)(((THUNKPTR32)lpSym)->off) <= obTarget) &&
                    (obTarget < ((CV_uoff32_t)(((THUNKPTR32)lpSym)->off) + (CV_uoff32_t)(((THUNKPTR32)lpSym)->len)))) {
                    lplbs->tagThunk = (SYMPTR)lpSym;
                }
                break;

        }
        lpSym = NEXTSYM (SYMPTR, lpSym);
    }
}


//  SHdNearestSymbol
//
//  Purpose: To find the closest label/proc to the specified address is
//          found and put in pch. Both the symbol table and the
//          publics tables are searched.
//
//  Input:
//      ptxt -  a pointer to the context, address and mdi must
//              be filled in.
//
//      sop  -  Determine what type of symbols to look for
//
//  Notes: If CV_MAXOFFSET is returned in the lpodr, there is no closest
//          symbol Also all symbols in the module are searched so only the
//          cxt.addr and cxt.mdi have meaning.

VOID
SHdNearestSymbol (
    PCXT pcxt,
    SOP sop,
    LPODR lpodr
    )
{
    HSYM    hSym;
    SYMPTR  pSym;
    LBS     lbs;
    ULONG   doff = CV_MAXOFFSET;
    ULONG   doffNew = CV_MAXOFFSET;
    LPCH    lpch = lpodr->lszName;

    lpodr->fst = fstNone;
    lpodr->fcd = fcdUnknown;
    lpodr->fpt = fptUnknown;
    lpodr->cbProlog = 0;
    lpodr->dwDeltaOff = 0;

    *lpch = '\0';
    if (SHHMODFrompCXT (pcxt)) {
        BOOL bAddrInProc = FALSE;

        // at some point we may wish to specify only a scope to search for
        // a label. So we may wish to initialize the lbs differently

        // get the Labels
        lbs.tagMod = SHHMODFrompCXT (pcxt);
        lbs.addr   = *SHpADDRFrompCXT (pcxt);
        SHpSymlplLabLoc (&lbs);

        // check for closest data local, if requested
        if ((sop & sopData)  &&  lbs.tagLoc) {
            pSym = (SYMPTR) lbs.tagLoc;
            switch (pSym->rectyp) {
                case S_LDATA32:
                case S_GDATA32:
                case S_LTHREAD32:
                case S_GTHREAD32:
                    doff = GetAddrOff (lbs.addr) -
                      (CV_uoff32_t)(((DATAPTR32)pSym)->off);
                    _tcsncpy (lpch,
                              (char *)&((DATAPTR32)pSym)->name[1],
                              (BYTE)(*((DATAPTR32)pSym)->name));
                    lpch[(BYTE)(*((DATAPTR32)pSym)->name)] = '\0';
                    break;
            }
        }

        // check for closest label
        if (!(sop & sopFcn) && lbs.tagLab) {
            pSym = (SYMPTR) lbs.tagLab;
            switch (pSym->rectyp) {
                case S_LABEL32:
                    doff = GetAddrOff (lbs.addr) -
                      (CV_uoff32_t)(((LABELPTR32)pSym)->off) ;
                    _tcsncpy (lpch,
                              (char *)&((LABELPTR32)pSym)->name[1],
                              (BYTE)(*((LABELPTR32)pSym)->name));
                    lpch[(BYTE)(*((LABELPTR32)pSym)->name)] = '\0';
                    break;
            }
        }

        // if the thunk name is closer
        if (lbs.tagThunk) {
            pSym = (SYMPTR) lbs.tagThunk;
            switch (pSym->rectyp) {
                case S_THUNK32:
                    doff = GetAddrOff (lbs.addr) -
                      (CV_uoff32_t)(((THUNKPTR32)pSym)->off) ;
                    _tcsncpy (lpch,
                              (char *)&((THUNKPTR32)pSym)->name[1],
                              (BYTE)(*((THUNKPTR32)pSym)->name));
                    lpch[(BYTE)(*((THUNKPTR32)pSym)->name)] = '\0';
                    break;
            }
        }

		// if a static symbol is closer
		if (lbs.tagLoc) {
			pSym = (SYMPTR) lbs.tagLoc;
			if (pSym->rectyp==S_LDATA32) {
				doffNew = GetAddrOff (lbs.addr) -
								(CV_uoff32_t)(((DATAPTR32)pSym)->off);
				if (doffNew <= doff) {
					doff = doffNew;
                    _tcsncpy (lpch,
                              (char *)&((DATAPTR32)pSym)->name[1],
                              (BYTE)(*((DATAPTR32)pSym)->name));
                    lpch[(BYTE)(*((DATAPTR32)pSym)->name)] = '\0';
				}
			}
		}


        // if the proc name is closer
        if (lbs.tagProc) {
            pSym = (SYMPTR) lbs.tagProc;
            switch (pSym->rectyp) {
                case S_LPROC32:
                case S_GPROC32:
                    doffNew = GetAddrOff (lbs.addr) -
                                (CV_uoff32_t)(((PROCPTR32)pSym)->off);
                    if (doffNew <= doff) {
                        doff = doffNew;
                        _tcsncpy (lpch,
                                  (char *)&((PROCPTR32)pSym)->name[1],
                                  (BYTE)(*((PROCPTR32)pSym)->name));
                        lpch[(BYTE)(*((PROCPTR32)pSym)->name)] = '\0';

                        // cbProlog is a WORD, so until we change that, we'll
                        // have to make sure the prolog is <64K (a safe bet)

                        assert (((PROCPTR32)pSym)->DbgStart <= 65535);
                        lpodr->cbProlog = (WORD)(((PROCPTR32)pSym)->DbgStart);

                        lpodr->fcd = (((PROCPTR32)pSym)->flags.CV_PFLAG_FAR) ? fcdFar : fcdNear;
                        lpodr->fst = fstSymbol;
                        if (((PROCPTR32)pSym)->flags.CV_PFLAG_NOFPO ) {
                            lpodr->fpt = fptPresent;
                        }
                        if ( doff < (CV_uoff32_t)((PROCPTR32)pSym)->len ) {
                            bAddrInProc = TRUE;
                        }
                    }
                    break;

                case S_LPROCMIPS:
                case S_GPROCMIPS:
                    doffNew = GetAddrOff (lbs.addr) -
                                (CV_uoff32_t)(((PROCPTRMIPS)pSym)->off);
                    if (doffNew <= doff) {
                        doff = doffNew;
                        _tcsncpy (lpch,
                                  (char *)&((PROCPTRMIPS)pSym)->name[1],
                                  (BYTE)(*((PROCPTRMIPS)pSym)->name));
                        lpch[(BYTE)(*((PROCPTRMIPS)pSym)->name)] = '\0';

                        // cbProlog is a WORD, so until we change that, we'll
                        // have to make sure the prolog is <64K (a safe bet)
                        if (((PROCPTRMIPS)pSym)->DbgStart == 0) {
                            lpodr->cbProlog = 0;
                        } else {
                            // TEMPORARY HACK !!!!!!! - sanjays
                            assert (((PROCPTRMIPS)pSym)->DbgStart - 1 <= 65535);
                            lpodr->cbProlog = (WORD)(((PROCPTRMIPS)pSym)->DbgStart - 1);
                        }

                        lpodr->fcd = fcdNear;
                        lpodr->fst = fstSymbol;

                        if ( doff < (CV_uoff32_t)((PROCPTRMIPS)pSym)->len ) {
                            bAddrInProc = TRUE;
                        }
                    }
                    break;
            }
        }

        if (!doff) {
            lpodr->dwDeltaOff = 0;  // Exact Match
            return;
        }

        // Avoid searching the publics if the address we were searching for
        // is in the range of the proc we found.
        if ( bAddrInProc && !(sop & sopData))
        {
            lpodr->dwDeltaOff = doff;
            return;
        }
    }

    // now check the publics

    doffNew = PHGetNearestHsym (SHpADDRFrompCXT (pcxt), (HEXE) SHpADDRFrompCXT(pcxt)->emi, &hSym);

    if (doffNew < doff) {
        doff = doffNew;
        pSym = (SYMPTR) hSym;
        switch (pSym->rectyp) {
            case S_GDATA32:
            case S_PUB32:
                _tcsncpy (lpch,
                          (char *)&((DATAPTR32)pSym)->name[1],
                          (BYTE)(*((DATAPTR32)pSym)->name));
                lpch[(BYTE)(*((DATAPTR32)pSym)->name)] = '\0';
                lpodr->fst = fstPublic;
                break;
        }
    }

    lpodr->dwDeltaOff = doff;
    return;
}

// the next function is provided to osdebug via callbacks and
//  should not be called within the CV kernel

//  SHModelFromAddr
//
//  Purpose: To fill the supplied buffer with the relevant Change
//       Execution Model record from the symbols section.
//
//  Input:
//      pcxt    -   a pointer to an addr,
//
//  Output:
//      pch     -   The Change Execution Model record is copied here.
//
//  Returns
//      True if there is symbol information for the module.
//
//  Notes:  If there is no symbol information for the module, the supplied
//          buffer is not changed and the function returns FALSE.

// UNDONE: The statics in this function s/b moved to a CACHE struct.  Better yet,
// it, simply test for mac targetting and return native if not.

int
SHModelFromAddr (
    LPADDR paddr,
    LPW lpwModel,
    LPB lpbModel,
    CV_uoff32_t *pobMax
    )
{
    static CEXMPTR32    tagOld;
    static CV_uoff32_t  obMax = 0;
    static CV_uoff32_t  obMin = 0;
    static HEMI         emiOld = 0;
    static WORD         segOld = 0;

    SYMPTR *lppModel = (SYMPTR *) lpbModel;
    LBS   lbs;
    ADDR  addr;
    LPMDS lpmds;
    HMOD  hmod;
    CXT   cxt = {0};
    CB cbSecContrib;
    BOOL fTmp;

    // if physical, unfix it up
    if (!ADDR_IS_LI (*paddr))
        SYUnFixupAddr (paddr);

    cxt.addr = *paddr;
    cxt.hMod = 0;

    if ((segOld != (WORD) GetAddrSeg (*SHpADDRFrompCXT(&cxt))) ||
        (emiOld !=  emiAddr (*SHpADDRFrompCXT(&cxt)))          ||
        (GetAddrOff (*SHpADDRFrompCXT(&cxt)) >= obMax)         ||
        (GetAddrOff (*SHpADDRFrompCXT(&cxt)) < obMin))
    {
        if (!SHHMODFrompCXT (&cxt)) {
            addr = *SHpADDRFrompCXT (&cxt);
            memset(&cxt, 0, sizeof(CXT));
            if (!SHSetCxtMod(&addr, &cxt)) {
                return FALSE;
            }
        }

        hmod = (HMOD)SHHGRPFrompCXT(&cxt);
        lpmds = (LPMDS) hmod;
        emiOld = emiAddr (*SHpADDRFrompCXT(&cxt));
        fTmp = IsAddrInMod (lpmds, &cxt.addr, &segOld, (OFF *)&obMin, &cbSecContrib);
        assert(fTmp);
        obMax = obMin + cbSecContrib + 1;
        tagOld = NULL;

        // at some point we may wish to specify only a scope to search for
        // a label. So we may wish to initialize the lbs differently

        // get the Relevant change model records

        if (GetSymbols ((LPMDS) (lbs.tagMod = SHHMODFrompCXT(&cxt)))) {
            lbs.addr   = *SHpADDRFrompCXT(&cxt);
            SHpSymlplLabLoc(&lbs);

            if (tagOld = lbs.tagModelMin) {
                obMin = lbs.tagModelMin->off;
            }

            if (lbs.tagModelMax) {
                obMax = lbs.tagModelMax->off;
            }
        }
    }

    if (tagOld != NULL) {
        // pass on ptr to the SYM
        *lppModel = (SYMPTR) tagOld;
        *lpwModel = ((CEXMPTR32) *lppModel)->model;

        if (*lpwModel != CEXM_MDL_cobol
            && *lpwModel != CEXM_MDL_pcode32Mac
            && *lpwModel != CEXM_MDL_pcode32MacNep
            ) {
            *lpwModel &= 0xfff0;
        }
    } else {
        // no model record, must be native
        *lppModel = NULL;
        *lpwModel = CEXM_MDL_native;
    }
    *pobMax = obMax;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\strings.cpp ===
//  STRINGS.C
//
//  This file defines all strings which are used in the EM for display
//  purposes.  This is done for internationalization purposes.
//
//  strings.h contains all declarations for the data in this file.

//  We define DEFINE_STRINGS before including strings.h so that all the
//  strings will be defined rather than just declared.


#include "shinc.hpp"
#pragma hdrstop

#define DEFINE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\stab.cpp ===
// stab.cpp - symbol table for created UDT syms
#include "shinc.hpp"

struct STAB {
public:
    BOOL fFindSym(LPSSTR lpsstr, PFNCMP pfnCmp, SHFLAG fCase, UDTPTR* ppsym, unsigned *piHash);
    BOOL fAddSym(LPSSTR lpsstr, unsigned iHash, UDTPTR* ppsym);
    STAB();
    ~STAB();

private:
    unsigned itMac;
    unsigned itEntries;
    UDTPTR* rgpsym;
    BOOL fCreateNewUDTSym(LPSSTR lpsstr, unsigned iHash, UDTPTR* ppsym);
    BOOL resize();

    unsigned hash(LPB lpName)
    {
        return hashPbCb(lpName + 1, *lpName, itMac);
    }
    unsigned hash(LPSSTR lpsstr)
    {
        return hashPbCb(lpsstr->lpName, lpsstr->cb, itMac);
    }
};

void* __cdecl operator new (size_t cb)
{
	return MHAlloc(cb);
}

void __cdecl operator delete(void *pv)
{
    MHFree(pv);
}

BOOL STABOpen(STAB **ppstab)
{
    *ppstab = new STAB;
    return *ppstab != 0;
}

BOOL STABFindUDTSym(STAB* pstab, LPSSTR lpsstr, PFNCMP pfnCmp, SHFLAG fCase, UDTPTR *ppsym, unsigned *piHash)
{
    *piHash = 0;
    assert(pstab);
    return pstab->fFindSym(lpsstr, pfnCmp, fCase, (UDTPTR *)ppsym, piHash);
}

BOOL STABAddUDTSym(STAB* pstab, LPSSTR lpsstr, unsigned iHash, UDTPTR* ppsym)
{
    assert(pstab);
    return pstab->fAddSym(lpsstr, iHash, (UDTPTR *)ppsym);
}

void STABClose(STAB* pstab)
{
    delete pstab;
}

STAB::STAB()
{
    itEntries = 0;
    itMac = 1024;
    rgpsym = (UDTPTR *) MHAlloc(itMac * sizeof(UDTPTR));
    memset(rgpsym, 0, itMac * sizeof(UDTPTR));
}

STAB::~STAB()
{
    for (unsigned i = 0; i < itMac; i++)
        if (rgpsym[i])
            MHFree(rgpsym[i]);

    MHFree(rgpsym);
    itEntries = 0;
    itMac = 1024;
    rgpsym = 0;

}

BOOL STAB::fFindSym(LPSSTR lpsstr, PFNCMP pfnCmp, SHFLAG fCase, UDTPTR* ppsym, unsigned* piHash)
{
    *ppsym = 0;

    // nothing but S_UDTs here - if were looking for a specific type of sym
    // and its not a S_UDT - don't bother
    if ((lpsstr->searchmask & SSTR_symboltype ) &&
        ( lpsstr->symtype != S_UDT ))
        return FALSE;

    for (*piHash = hash(lpsstr);
        rgpsym[*piHash];
        *piHash = (*piHash < (itMac-1)) ? *piHash + 1: 0) {
        // thats right pfnCmp returns 0 if compare succeeds
        if (!(*pfnCmp) ( lpsstr, (SYMPTR)rgpsym[*piHash], (char *)(rgpsym[*piHash]->name), fCase )) {
            // got it  - return the sym
            *ppsym = rgpsym[*piHash];
            return TRUE;
        }
    }

    return FALSE;
}

BOOL STAB::fAddSym(LPSSTR lpsstr, unsigned iHash, UDTPTR* ppsym)
{
    if (!fCreateNewUDTSym(lpsstr, iHash, ppsym))
        return FALSE;

    if ((itEntries >> 1) > itMac) {
        // over half full - double itMac and rehash the table
        if (!resize())
            return FALSE;
    }

    return TRUE;
}

BOOL STAB::fCreateNewUDTSym(LPSSTR lpsstr, unsigned iHash, UDTPTR* ppsym)
{
    *ppsym = rgpsym[iHash] = (UDTPTR) MHAlloc(sizeof(UDTSYM) + lpsstr->cb);

    if (*ppsym) {
        (*ppsym)->reclen = sizeof(UDTSYM) + lpsstr->cb;
        (*ppsym)->rectyp = S_UDT;
        (*ppsym)->typind = 0;
        (*ppsym)->name[0] = lpsstr->cb;
        memcpy((*ppsym)->name + 1, lpsstr->lpName, lpsstr->cb);
        itEntries++;
        return TRUE;
    }

    return FALSE;
}

BOOL STAB::resize()
{
    unsigned itMac_ = itMac;
    itMac = itMac << 1;         // double size of hash table
    UDTPTR *rgpsym_ = rgpsym;
    rgpsym = (UDTPTR *) MHAlloc(itMac * sizeof(UDTPTR));
    if (!rgpsym)  {
        rgpsym = rgpsym_;
        return FALSE;
    }

    memset(rgpsym, 0, itMac * sizeof(UDTPTR));

    for (unsigned i_ = 0; i_ < itMac_; i_++)  {
        if (rgpsym_[i_]) {
            for (unsigned i = hash((LPB)(rgpsym_[i_]->name));
                rgpsym[i];
                i = (i < itMac) ? i + 1: 0);
            rgpsym[i] = rgpsym_[i_];
        }
    }

    MHFree(rgpsym_);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\sl.cpp ===
//  sl.cxx -- all routines to work with the source line information
//
//  Copyright <C> 1991, Microsoft Corporation
//
//  Revisions:
//
//      19-Dec-91 Davidgra
//          [00] Cache in SLFLineToAddr & SLLineFromAddr
//
//      03-Jan-92 ArthurC
//          [01] Added argument to SLFLineToAddr
//
//      01-Dec-94 BryanT
//          Merge with NT codebase.
//
//  Purpose:
//      To query information for the source module, source file, and
//      source line information tables.

#include "shinc.hpp"
#pragma hdrstop

#define cbndsAllocBlock 512
typedef struct _BNDS {
    WORD ilnStart;
    WORD ilnEnd;
} BNDS; // BouNDS
typedef BNDS *LPBNDS;

HST     HstFromLpmds (LPMDS);
LOCAL   BOOL    FCheckSLOrder (LPSL);
LOCAL   LPBNDS  BuildBounds (WORD, LPUL, LPW);

__inline VOID   SortSM (LPSM);
__inline VOID   SortSL (LPSL);
__inline WORD   FindPosition (LPBNDS, WORD, LPUL, ULONG);
__inline LPBNDS InsertBlock (WORD, WORD, LPBNDS, LPW, LPW);
__inline WORD   ScanBlock (LPUL, WORD, WORD, ULONG);
__inline VOID   SortOffFromBounds (WORD, LPBNDS, WORD, LPUL);
__inline VOID   SortLnFromBounds (WORD, LPBNDS, WORD, LPW);
__inline VOID   SortFromBounds (WORD, LPBNDS, WORD, LPV, WORD);

#define SIZEOFBASE          4
#define SIZEOFSTARTEND      8
#define SIZEOFLINENUMBER    2
#define SIZEOFHEADER        4
#define SIZEOFSEG           2
#define SIZEOFNAME          2

// make sure Pascal length byte gets read correctly regardless of type
inline size_t cbNameLen( TCHAR *pPascalString )
{
	return *( (BYTE*)pPascalString );		// MUST be treated as unsigned byte
}

//  Internal support routines
//  Low level routines to tranverse the source module, source file and
//  source line information tables
//
//  List of internal support functions

LPW
PsegFromSMIndex (
    LPSM lpsm,
    WORD iseg
    )
{
    assert (lpsm != NULL);
    assert (iseg < lpsm->cSeg);

    return ((LPW)
        ((CHAR *) lpsm +
         SIZEOFHEADER +
         (SIZEOFBASE * lpsm->cFile) +
         (SIZEOFSTARTEND * lpsm->cSeg) +
         (SIZEOFSEG * iseg)
       )
    );
}


// GetSMBounds
//
//  Purpose:  Get the segment number and start/end offset pair for the
//              segment (iseg) contributing to the module lpsm.
//  Input:
//      lpsmCur - pointer to the current source module table.
//      iseg    - the index of the segment contributing to
//                the module to get the bounds for.
//
//  Returns  a pointer to a start/end offset pair

__inline LPOFP
GetSMBounds (
    LPSM  lpsm,
    WORD  iSeg
    )
{
    assert (lpsm != NULL);
    assert (iSeg < lpsm->cSeg);

    return ((LPOFP) ((CHAR *) lpsm +
            SIZEOFHEADER +
            (SIZEOFBASE * lpsm->cFile) +
            (sizeof (OFP) * iSeg)));
}


LPW
PsegFromSFIndex (
    LPSM lpsm,
    LPSF lpsf,
    WORD iseg
    )
{
    ULONG ulBase = 0;

    assert (lpsf != NULL);
    assert (iseg < lpsf->cSeg);

    ulBase = *((ULONG *) ((LPCH)lpsf + SIZEOFHEADER + (SIZEOFBASE * iseg)));

    return (LPW) ((LPCH) lpsm + ulBase);
}

//  GetSFBounds
//
//  Purpose:  Get the next/first start address from the Source File table.
//
//  Input:
//      lpsmCur     -   pointer to the current source module table.
//      lpiStart    -   pointer to index of the current file pointer
//                       0 if getting first in list.
//      lpulNext    -   pointer to the next source file block.
//
//  Returns:
//      lpulNext    -   set to pointer to next source file. NULL
//                       if no more entries.

__inline LPOFP
GetSFBounds (
    LPSF lpsf,
    WORD iseg
    )
{
    assert (lpsf != NULL);
    assert (iseg < lpsf->cSeg);

    return (LPOFP) ((CHAR *) lpsf +
            SIZEOFHEADER +
            (SIZEOFBASE * lpsf->cSeg) +
            (sizeof (OFP) * iseg));
}


//  GetLpsfFromIndex
//
//  Purpose: From the current source module, and source file pointer find
//          the next one.
//
//  Input:
//      lpsmCur     -   pointer to the current source module table.
//      isfCur      -   index of the current file pointer
//                       0 if getting first in list.
//  Returns:
//      lpsfNext    -   set to pointer to next source file. NULL
//                       not found.

LPSF
GetLpsfFromIndex (
    LPSM lpsmCur,
    WORD iFile
    )
{
    LPSF lpsfNext = NULL;

    assert (lpsmCur != NULL);

    if (lpsmCur && iFile < lpsmCur->cFile) {
        lpsfNext = (LPSF) ((CHAR *)lpsmCur + lpsmCur->baseSrcFile[iFile]);
    }
    return lpsfNext;
}


// LpsfFromAddr
//
// Purpose:  Find the pointer to the source file that the addr falls into
//
// Input:
//      lpaddr      -   pointer to address package
//      lpsf        -   pointer to lpsf that contain addr in range
//      lpsmCur     -   pointer to current source module table.
//
//  Returns:
//      lpsf        -   contain pointer to source file if addr is
//                      in range.  Unchanged if could not find file.

BOOL
FLpsfFromAddr (
    LPADDR lpaddr,
    LPSM lpsmCur,
    LPSF * plpsf,
    LPW lpwFileIndex,
    LPW lpwSegIndex
    )
{
    WORD iFile   = 0;
    BOOL fFound  = FALSE;

    assert (lpsmCur != (LPSM) NULL);
    assert (lpaddr != (LPADDR) NULL);

    while (iFile < lpsmCur->cFile && !fFound) {
        WORD iseg = 0;
        LPSF lpsf = GetLpsfFromIndex (lpsmCur, iFile);

        while (iseg < lpsf->cSeg && !fFound) {
            WORD  seg   = *PsegFromSFIndex (lpsmCur, lpsf, iseg);
            LPOFP lpofp = GetSFBounds (lpsf, iseg);

            if ((GetAddrSeg (*lpaddr) == seg) &&
                (GetAddrOff (*lpaddr) >= lpofp->offStart) &&
                (GetAddrOff (*lpaddr) <= lpofp->offEnd))
            {
                *lpwFileIndex = iFile;
                *lpwSegIndex  = iseg;
                *plpsf = lpsf;
                fFound = TRUE;
            }

            iseg++;
        }
        iFile++;
    }

    return fFound;
}


//  LpchGetName

__inline LPCH
LpchGetName (
    LPSF lpsf
    )
{
    LPCH lpch = NULL;

    assert (lpsf != NULL);

    lpch =  (LPCH) ((CHAR *)lpsf +
                    SIZEOFHEADER +
                    (SIZEOFBASE * lpsf->cSeg) +
                    (SIZEOFSTARTEND * lpsf->cSeg));

    return lpch;
}


//  LpsfFromName

short
IsfFromName (
    BOOL fExactMatch,
    short isfStart,
    LSZ lszName,
    LPMDS lpmds
    )
{
    short isfFound = -1;
    short isf = isfStart;
    LPEXG lpexg = (LPEXG) LLLock (lpmds->hexg);

    if (lpexg->lpefi) {
        CHAR szFileSrc [ _MAX_CVFNAME ];
        CHAR szExtSrc [ _MAX_CVEXT ];
        int cbName = 0;
        int cchName = 0;
        LSZ  lszFileExt = NULL;
        int  imds = lpmds->imds - 1;

        _tsplitpath(lszName, NULL, NULL, szFileSrc, szExtSrc);

        // If fExactMatch, the path must match the OMF
        if (fExactMatch) {
            cbName = _tcslen(lszName);
            cchName = _tcslen(lszName);
            lszFileExt = lszName;
        } else {
            cbName = _tcslen(szExtSrc) + _tcslen(szFileSrc);
            cchName = _tcslen(szExtSrc) + _tcslen(szFileSrc);
            lszFileExt = lszName + _tcslen(lszName) - cbName;
        }

        CHAR szPathOMF [ _MAX_CVPATH ];
        CHAR szFile [ _MAX_CVFNAME ];
        CHAR szExt [ _MAX_CVEXT ];

        if ( lpmds->hst ) {
            // line numbers have already been loaded from this mod so
            // use the mod info rather than the global file info - in case the 
            // global info is stale thanks to edit and continue.

            for (isf = isfStart; isf < ((LPSM) lpmds->hst)->cFile; isf++) {
                LPSF lpsf = GetLpsfFromIndex ((LPSM)lpmds->hst, isf);
                _TCHAR  * lpch = (_TCHAR  *) LpchGetName( lpsf );

                if (!_tcsnicmp (lszFileExt, (_TCHAR  *) lpch + cbNameLen(lpch) - cbName + 1, cchName)) {
                    memset(szPathOMF, 0, _MAX_CVPATH);
                    memcpy(szPathOMF, lpch + 1, cbNameLen(lpch));
                    _tsplitpath(szPathOMF, NULL, NULL, szFile, szExt);
                    if (!_tcsicmp (szFileSrc, szFile) &&
                         !_tcsicmp (szExtSrc, szExt))
                    {
                        isfFound = isf;
                        break;
                    }
                }
 
            }
        } else {

            for (isf = isfStart; isf < (short) lpexg->rgculFile [ imds ]; isf++) {
                _TCHAR  * lpch = (_TCHAR  *)
                    lpexg->lpchFileNames +
                    (lpexg->rgichFile [ (WORD) (lpexg->rgiulFile [ imds ]) + isf ]);

                // IMPORTANT NOTE:
                //
                // Below, it is VITAL for DBCS to use the number of CHARACTERS
                // to compare as opposed to the number of bytes or the DBCS
                // strnicmp will fail!

                if (!_tcsnicmp (lszFileExt, (_TCHAR  *) lpch + cbNameLen(lpch) - cbName + 1, cchName)) {
                    memset(szPathOMF, 0, _MAX_CVPATH);
                    memcpy(szPathOMF, lpch + 1, cbNameLen(lpch));
                    _tsplitpath(szPathOMF, NULL, NULL, szFile, szExt);
                    if (!_tcsicmp (szFileSrc, szFile) &&
                         !_tcsicmp (szExtSrc, szExt))
                    {
                        isfFound = isf;
                        break;
                    }
                }
            }
        }
    }

    LLUnlock (lpmds->hexg);

    return isfFound;
}


//  GetLpslFromIndex
//
//  Purpose:  Get the next line number entry

__inline LPSL
GetLpslFromIndex (
    LPSM lpsmCur,
    LPSF lpsfCur,
    WORD iSeg
    )
{
    LPSL lpsl = NULL;

    assert (lpsfCur != NULL);

    if (iSeg < lpsfCur->cSeg) {
        lpsl = (LPSL) ((CHAR *)lpsmCur +
            lpsfCur->baseSrcLn [iSeg]);
    }
    return lpsl;
}


BOOL
FLpslFromAddr (
    LPADDR lpaddr,
    LPSM lpsm,
    LPSL * plpsl
    )
{
    WORD    iSeg        = 0;
    WORD    iSegCur     = 0;
    WORD    iFileCur    = 0;
    BOOL    fRet        = FALSE;
    LPSF    lpsf        = NULL;

    assert (lpsm != NULL);
    assert (lpaddr != NULL);

    // First, do a high level pass to see if the address actually exists
    //  within the given module.

    while (iSeg < lpsm->cSeg) {

        WORD  seg   = *PsegFromSMIndex (lpsm, iSeg);
        LPOFP lpofp = GetSMBounds (lpsm, iSeg);

        if ((GetAddrSeg (*lpaddr) == seg) &&
             (GetAddrOff (*lpaddr) >= lpofp->offStart) &&
             (GetAddrOff (*lpaddr) <= lpofp->offEnd)
       ) {
            break;
        }

        iSeg++;
    }

    // We know it is in this module, so now find the correct file

    if (iSeg < lpsm->cSeg &&
         FLpsfFromAddr (lpaddr, lpsm, &lpsf, &iFileCur, &iSegCur))
    {
        *plpsl = GetLpslFromIndex (lpsm, lpsf, iSegCur);
        fRet   = TRUE;
    }

    return fRet;
}


//  OffsetFromIndex
//
//  Purpose:  Get the next line number entry

__inline BOOL
OffsetFromIndex (
    LPSL lpslCur,
    WORD iPair,
    ULONG * lpulOff
    )
{
    BOOL fRet = FALSE;

    assert (lpslCur != NULL);
    assert (lpulOff != NULL);

    if (iPair < lpslCur->cLnOff) {
        *lpulOff = lpslCur->offset [ iPair ];
        fRet = TRUE;
    }

    return fRet;
}


//  LineFromIndex
//
//  Purpose:  Get the next line number entry

__inline BOOL
LineFromIndex (
    LPSL lpslCur,
    WORD iPair,
    USHORT * lpusLine
    )
{
    BOOL    fRet = FALSE;
    ULONG   ul;

    assert (lpslCur != NULL);
    assert (lpusLine != NULL);

    if (iPair < lpslCur->cLnOff) {
        ul = (sizeof (LONG) * lpslCur->cLnOff) + (sizeof (WORD) * iPair);
        *lpusLine = *(USHORT *)((CHAR *) lpslCur->offset + ul);
        fRet = TRUE;
    }
    return fRet;
}


//
// Exported APIs
//


//  SLHmodFromHsf - Return the module in which a source file is used
//
//  Purpose:    Given a source file, return an HMOD indicating which
//              module it was compiled into.
//
//  Input:      hexe - handle to the EXE in which to look, or NULL for all
//              hsf - handle to source file for which to find module
//
//  Returns:    handle to the module into which this source file was
//              compiled
//
//  Notes:      REVIEW: BUG: It's possible (mainly in C++ but also in C)
//              for a source file to be used in more than one module
//              (e.g. a C++ header file with inline functions, or a C
//              header file with a static function).  This function just
//              finds the first one, which is very misleading.

HMOD
SLHmodFromHsf (
    HEXE hexe,
    HSF hsf
    )
{
    HEXE    hexeCur         = hexe;
    HMOD    hmod            = 0;
    BOOL    fFound          = FALSE;
    LPMDS   lpmds           = NULL;
    WORD    iFile;

    if (hsf != HsfCache.Hsf) {
        // to get an Hmod from hsf we must loop through
        // exe's to Hmods and compare hsfs associated to the
        // hmod
        while (hexeCur = (hexe ? hexe : SHGetNextExe (hexeCur))) {
            while ((hmod = SHGetNextMod (hexeCur, hmod)) && !fFound) {
                lpmds = (LPMDS) hmod;
                if (lpmds != NULL && lpmds->hst) {
                    for (iFile = 0; iFile < ((LPSM) lpmds->hst)->cFile; iFile++) {
                        if (hsf == GetLpsfFromIndex ((LPSM)lpmds->hst, iFile)) {
                            HsfCache.Hmod = hmod;
                            HsfCache.Hsf = hsf;
                            fFound = TRUE;
                            break;
                        }
                    }
                }
            }

            if (hexe != (HEXE) NULL || fFound) {
                //
                // if given an exe to search don't go any further.
                //
                break;
            }
        }
    }
    return HsfCache.Hmod;
}


//  SLLineFromAddr - Return info about the source line for an address
//
//  Purpose:    Given an address return line number that corresponds.
//              Also return count bytes for the given line, and the delta
//              between the address that was passed in and the first byte
//              corresponding to this source line.
//
//  Input:      lpaddr - address for which we want source line info
//
//  Output:    *lpwLine - the (one-based) line for this address
//             *lpcb - the number of bytes of code that were generated
//                      for this source line
//             *lpdb - the offset of *lpaddr minus the offset for the
//                      beginning of the line
//
//  Returns:    TRUE if source was found, FALSE if not
//
//  Notes:
//      1.  add parameter for hexe start

BOOL
SLLineFromAddr (
    LPADDR      lpaddr,
    LPW         lpwLine,
    SHOFF * lpcb,
    SHOFF * lpdb
    )
{
    HMOD    hmod    = (HMOD) NULL;
    LPMDS   lpmds   = NULL;
    CXT     cxtT    = {0};
    LPSL    lpsl    = NULL;
    WORD    cPair;
    WORD    i;
    HEXE    hexe;
    UOFFSET maxOff  = CV_MAXOFFSET;
    BOOL    fRet    = FALSE;
    short   low;
    short   mid;
    short   high;
    ULONG   ulOff;
    USHORT  usLine;

    assert (lpaddr != NULL);
    assert (lpwLine != NULL);

    if (!ADDR_IS_LI (*lpaddr)) {
        SYUnFixupAddr (lpaddr);
    }

    if (emiAddr (*lpaddr) == emiAddr (AddrCache.addr) &&
        GetAddrSeg (*lpaddr) == GetAddrSeg (AddrCache.addr) &&
        GetAddrOff (*lpaddr) >= GetAddrOff (AddrCache.addr) &&
        GetAddrOff (*lpaddr) < GetAddrOff (AddrCache.addr) + AddrCache.cb - 1)
    {
        *lpwLine = AddrCache.wLine;
        if (lpcb) {
            *lpcb    = AddrCache.cb - 1;
        }

        if (lpdb) {
            *lpdb = GetAddrOff (*lpaddr) - GetAddrOff (AddrCache.addr);
        }

        return TRUE;
    }

    *lpwLine = 0;

    if (SHSetCxtMod (lpaddr, &cxtT) != NULL) {
        hmod = SHHMODFrompCXT (&cxtT);

        if (hmod != (HMOD) NULL &&
            (lpmds = (LPMDS) hmod) != NULL &&
            lpmds && HstFromLpmds (lpmds) &&
            FLpslFromAddr (lpaddr, (LPSM) lpmds->hst, &lpsl))
        {
            hexe  = SHHexeFromHmod (SHHMODFrompCXT (&cxtT));

            cPair = lpsl->cLnOff;

            for (i = 0; i < cPair; i++) {

                if (OffsetFromIndex (lpsl, i, &ulOff)) {
                    if (emiAddr (*lpaddr) == (HEMI) hexe) {
                        // set up for the search routine

                        low   = 0;
                        high  = lpsl->cLnOff - 1;

                        // binary search for the offset
                        while (low <= high) {
                            mid = (low + high) / 2;

                            if (OffsetFromIndex (lpsl, mid, &ulOff)) {
                                if (GetAddrOff (*lpaddr) < (UOFFSET) ulOff) {
                                    high = mid - 1;
                                } else if (GetAddrOff (*lpaddr) > (UOFFSET) ulOff) {
                                    low = mid + 1;
                                } else if (LineFromIndex (lpsl, mid, &usLine)) {
                                    *lpwLine = usLine;
                                    maxOff = 0;
                                    high = mid;
                                    goto found;
                                }
                            }
                        }

                        // if we didn't find it, get the closet but earlier line
                        // high should be one less than low.

                        if (OffsetFromIndex (lpsl, high, &ulOff)) {

                            if (low  &&
                                 ((GetAddrOff (*lpaddr) -
                                   (UOFFSET) ulOff) <
                                   maxOff)
                              ) {
                                maxOff = (UOFFSET) (GetAddrOff (*lpaddr) -
                                    (UOFFSET) ulOff);
                                if (LineFromIndex (lpsl, high, &usLine)) {
                                    *lpwLine = (WORD) usLine;
                                    //goto found;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

found:

    if (*lpwLine != 0) {
        ULONG ulOff = 0;
        ULONG ulOffNext = 0;

        AddrCache.wLine = *lpwLine;

        AddrCache.cb = 0;

        while (AddrCache.cb == 0 && (high + 1 < (int) lpsl->cLnOff)) {

            if (OffsetFromIndex (lpsl, (WORD)(high + 1), &ulOffNext) &&
                 OffsetFromIndex (lpsl, high, &ulOff)) {

                AddrCache.cb = (int) (ulOffNext - ulOff);
                if (AddrCache.cb != 0) {
                    LineFromIndex (lpsl, high, lpwLine);
                    AddrCache.wLine = *lpwLine;
                    break;
                }
            }
            high += 1;
        }

        if (AddrCache.cb == 0) {
            LPSF lpsf  = NULL;
            WORD iFile = 0;
            WORD iseg  = 0;

            if (FLpsfFromAddr (lpaddr, (LPSM) lpmds->hst, &lpsf, &iFile, &iseg)
                    &&
                OffsetFromIndex (lpsl, high, &ulOff))
            {
                AddrCache.cb = (int) (GetSFBounds (lpsf, iseg)->offEnd - ulOff + 1);
            }
        }

        if (lpcb != NULL) {
            *lpcb = AddrCache.cb - 1;
        }

        if (lpdb != NULL) {
            if (OffsetFromIndex (lpsl, high, &ulOff)) {
                *lpdb = GetAddrOff (*lpaddr) - ulOff;
            }
        }

        AddrCache.addr = *lpaddr;
        SetAddrOff (&AddrCache.addr, ulOff);

        fRet = TRUE;
    }

    return fRet;
}


//  SLFLineToAddrExteneded - Return the address for a given source line
//
//  Purpose:    Given a line and filename derive an an address.  This is
//              an extended version of LineToAddr to be able to search through
//              a source line table when there are multiple entries in the
//              source line table for a single line.
//
//  Input:      hsf - handle to the source file
//              line - the source line
//             *piSegStart - segment table in hsf to start search at
//             *piEntryFind - find the nth entry in *piSegStart
//
//  Output:    *piSegStart - segment table in hsf line found at.  Only valid
//                             when TRUE is returned!
//             *piEntryFind - index to begin search in next call to this fn
//             *lpaddr - the address for this source line
//             *lpcbLn - the number of bytes of code that were generated
//                        for this source line
//              rgwNearestLines[] - The nearest line below ([0]) and above ([1])
//                                   which generated code.
//
//      *** Below means lower LINE NUMBER not where it
//          would be on the screen!!!!!
//
//  Returns:    TRUE for success, FALSE for failure
//
//  Exceptions: lpNearestLines may not be valid if the return value is TRUE

BOOL
SLFLineToAddrExtended (
    HSF     hsf,
    WORD    line,
    WORD  * piSegStart,
    WORD  * piEntryFind,
    LPADDR  lpaddr,
    SHOFF * lpcbLn,
    WORD  * rgwNearestLines
    )
{
    WORD    rgwRet[2];
    ADDR    addr = {0};
    SHOFF   cbln = 0;
    HMOD    hmod;
    BOOL    fRet = FALSE;
    LPSF    lpsf = NULL;
    WORD    cEntryRemain;

    if (piEntryFind) {
        cEntryRemain = *piEntryFind;
    } else {
        cEntryRemain = 0;
    }

    rgwRet[0] = 0;
    rgwRet[1] = 0x7FFF;
    lpsf = (LPSF) hsf;

    ADDR_IS_LI (addr) = TRUE;

    // We need to get a mod.

    if (hmod = SLHmodFromHsf ((HEXE) NULL, hsf)) {
        HEXE  hexe  = SHHexeFromHmod (hmod);
        LPMDS lpmds = (LPMDS) hmod;

        // Set the fFlat and fOff32 bits base on the exe
        HEXG hexg = ((LPEXE) LLLock (hexe))->hexg;
        LLUnlock (hexe);
        if (((LPEXG) LLLock (hexg))->fIsPE) {
            // REVIEW - billjoy - should we check machine type or something?
            ADDRLIN32 (addr);
        } else {
            // REVIEW - billjoy - should we check machine type or something?
            //ADDR????
        }
        LLUnlock (hexg);

        if ((lpmds != NULL) && (lpsf != NULL)) {

            WORD i;

            for (i = *piSegStart; !fRet && i < lpsf->cSeg; i++) {
                ULONG   ulOff;
                WORD    iLn;
                LPSL    lpsl = NULL;
                WORD    wLine = 0;

                lpsl = GetLpslFromIndex ((LPSM) lpmds->hst, lpsf, i);

                for (iLn = 0; iLn < lpsl->cLnOff; iLn++) {
                    //
                    // look through all of the lines in the table
                    //
                    BOOL fT = LineFromIndex (lpsl, iLn, &wLine);

                    assert (fT);
                    if (wLine == line) {
                        LPOFP   lpofp;

                        fT = OffsetFromIndex (lpsl, iLn, &ulOff);
                        assert (fT);

                        SetAddrOff (&addr, ulOff);
                        SetAddrSeg (&addr, lpsl->Seg);
                        emiAddr (addr) = (HEMI) hexe;

                        if (iLn + 1 < lpsl->cLnOff) {
                            //
                            // if the next line is in range
                            //
                            OffsetFromIndex(lpsl, (WORD)(iLn+1), &ulOff);
                            //
                            // if we have a next line get the range
                            // based on next line.
                            //

                            cbln = ulOff - GetAddrOff (addr);

                            if (cbln == (SHOFF) 0) {
                                if (wLine < rgwRet[1]) {
                                    rgwRet[1] = wLine;
                                }
                                continue;
                            }
                        } else {
                            // if we don't have a next line then
                            // get the range from the boundry

                            lpofp = GetSFBounds (lpsf, i);

                            // GetSFBounds offEnd is inclusive
                            // for the source range.  Need to
                            // add 1 for the count bytes!

                            cbln = lpofp->offEnd - ulOff + 1;

                            // the end information is probably the same as the
                            // beginning offset for the last line in the file.
                            // So for now I will make a wild guess at the
                            // size of average epilog code. 10 bytes.

                            if (!cbln) {
                                cbln = 10;
                            }
                        }

                        *piSegStart = i;
                        if (!cEntryRemain--) {
                            if (piEntryFind) {
                                *piEntryFind += 1;
                            }
                            fRet = TRUE;
                            break;
                        }
                    } else {
                        if (wLine < line) {
                            if (wLine > rgwRet[0]) {
                                rgwRet[0] = wLine;
                            }
                        } else {
                            if (wLine < rgwRet[1]) {
                                rgwRet[1] = wLine;
                            }
                        }
                    }
                }

                // If continuing search, reset to stop at 1st
                // entry in next table
                if (!fRet) {
                    cEntryRemain = 0;
                    if (piEntryFind) {
                        *piEntryFind = 0;
                    }
                }
            }
        }
    }

    if(lpaddr) {
        *lpaddr = addr;
    }
    if(lpcbLn) {
        *lpcbLn = cbln;
    }

    if(rgwNearestLines) {
        rgwNearestLines[0] = rgwRet[0];
        rgwNearestLines[1] = rgwRet[1];
    }

    return fRet;
}


//  SLFLineToAddr - Return the address for a given source line
//
//  Purpose:    Given a line and filename derive an an address.
//
//  Input:      hsf - handle to the source file
//              line - the source line
//
//  Output:    *lpaddr - the address for this source line
//             *lpcbLn - the number of bytes of code that were generated
//                        for this source line
//              rgwNearestLines[] - The nearest line below ([0]) and above ([1])
//                                   which generated code.
//
//   *** Below means lower LINE NUMBER not where it
//       would be on the screen!!!!!
//
//  Returns:    TRUE for success, FALSE for failure
//
//  Exceptions: lpNearestLines may not be valid if the return value is TRUE

BOOL
SLFLineToAddr (
    HSF     hsf,
    WORD    line,
    LPADDR  lpaddr,
    SHOFF * lpcbLn,
    WORD *  rgwNearestLines
    )
{
    if ((hsf  != LineCache.hsf) ||
        (line != LineCache.wLine))
    {
        WORD    iSegStart = 0;

        LineCache.fRet = SLFLineToAddrExtended(hsf,
                                         line,
                                         &iSegStart,
                                         NULL,
                                         &LineCache.addr,
                                         &LineCache.cbLn,
                                         LineCache.rgw);
        LineCache.hsf = hsf;
        LineCache.wLine = line;
    }

    if (lpaddr) {
        *lpaddr = LineCache.addr;
    }
    if (lpcbLn) {
        *lpcbLn = LineCache.cbLn;
    }
    if (rgwNearestLines) {
        rgwNearestLines[ 0 ] = LineCache.rgw [ 0 ];
        rgwNearestLines[ 1 ] = LineCache.rgw [ 1 ];
    }

    return LineCache.fRet;
}


//  SLFFileInHexe - Is specified file a source contributor to hexe?
//
//  Purpose:  Determine if the file specified will have source line
//             information in this exe.
//
//  Input:
//      hexe            Exe (hexg) to search
//      fExactMatch     If TRUE, lszFile and OMF path must match.  If FALSE,
//                      only the basename and extension must match.
//      lszFile         Name of file to search for in OMF
//
//  Returns:              TRUE if file is found in exe's OMF
//
//  Notes:  This is a FAST search.  Just go through the file
//          list from exg.lpchFileNames.

BOOL
SLFFileInHexe(
    HEXE hexe,
    BOOL fExactMatch,
    LSZ lszFile
    )
{
    BOOL    fRet = FALSE;
    LPEXG   lpexg;
    LPEXE   lpexe;

    assert(hexe);
    lpexe = (LPEXE)LLLock(hexe);

    // Make sure that there's and exg for this exe
    if (lpexg = (LPEXG)LLLock(lpexe->hexg)) {

        // The code below is copied from IsfFromName (FYI   -markbro)
        if (lpexg->lpchFileNames) {
            _TCHAR  * lpch = (_TCHAR  *)lpexg->lpchFileNames;
            _TCHAR  * lpchMax = lpch + lpexg->cbFileNames;
            CHAR    szFileSrc [ _MAX_CVFNAME ];
            CHAR    szExtSrc [ _MAX_CVEXT ];
            int    cbName = 0;
            int    cchName = 0;
            LSZ     lszFileExt = NULL;

            _splitpath(lszFile, NULL, NULL, szFileSrc, szExtSrc);

            // If fExactMatch, the path must match the OMF
            if (fExactMatch) {
                cbName = _tcslen(lszFile);
                cchName = _tcslen(lszFile);
                lszFileExt = lszFile;
            } else {
                cbName = _tcslen(szExtSrc) + _tcslen(szFileSrc);
                cchName = _tcslen(szExtSrc) + _tcslen(szFileSrc);
                lszFileExt = lszFile + _tcslen(lszFile) - cbName;
            }

            // Stop when we've found something or the end of the table is found.
            while(!fRet && lpch < lpchMax) {
                CHAR szPathOMF [ _MAX_CVPATH ];
                CHAR szFile [ _MAX_CVFNAME ];
                CHAR szExt [ _MAX_CVEXT ];

                // IMPORTANT NOTE:
                //
                // Below, it is VITAL for DBCS to use the number of CHARACTERS
                // to compare as opposed to the number of bytes or the DBCS
                // strnicmp will fail!

                if (!_tcsnicmp (lszFileExt, lpch + cbNameLen(lpch) - cbName + 1, cchName)) {
                    memset(szPathOMF, 0, _MAX_CVPATH);
                    memcpy(szPathOMF, lpch + 1, cbNameLen(lpch));
                    _tsplitpath(szPathOMF, NULL, NULL, szFile, szExt);
                    if (!_tcsicmp (szFileSrc, szFile) &&
                        !_tcsicmp (szExtSrc, szExt))
                    {
                        fRet = TRUE;
                    }
                }

                // Skip to the next name in the table
                lpch += cbNameLen(lpch) + 1;
            }
        }
        LLUnlock(lpexe->hexg);
    }

    LLUnlock(hexe);

    return fRet;
}


//  SLCAddrFromLine - get all addresses which match the requested line
//
//  Purpose: Given a line and filename derive all addresses within
//              the specified exe
//
//  Input:      hexe - exe/dll to search in (if NULL, use all)
//              hmod - module of hexe to search in (if NULL, use all in hexe)
//              lszFile - file name
//              line - the source line
//
//  Output:    *lplpslp - pointer to slp array (allocated by this function)
//              containing return value # of pairs
//
//  Returns:    number of pairs found in exe

int
SLCAddrFromLine (
    HEXE        hexeStart,
    HMOD        hmodStart,
    LSZ         lszFileT,
    WORD        line,
    LPSLP      *lplpslp
    )
{
    LPSLP   lpslp = (LPSLP)NULL;
    int     cslp = 0;
    HMOD    hmod = hmodStart;
    HEXE    hexe = hexeStart;
    int     iPass;
    char    szFileBuf[_MAX_PATH];
    LPSTR   lszFile;

    assert(lplpslp);
    assert(lszFileT);
    assert(*lszFileT != '\0');

    // If the filename is quoted, remove the quotes.
    if ((*lszFileT == '\"') && (*(lszFileT + _tcslen(lszFileT) - 1) == '\"')) {
        lszFile = szFileBuf;
        memcpy(lszFile, _tcsinc(lszFileT), _tcslen(lszFileT) - 2);
        lszFile[_tcslen(lszFileT)-2] = '\0';
    } else {
        lszFile = lszFileT;
    }

    if ((SlCache.cslp != -1) &&
        (hexeStart == SlCache.hexe) &&
        (hmodStart == SlCache.hmod) &&
        (line      == SlCache.line) &&
        (!_tcscmp(lszFile, SlCache.szFile)))
    {
        if ((SlCache.cslp == 0) ||
            !(lpslp = (LPSLP)MHAlloc(sizeof(SLP) * (SlCache.cslp))))
        {
            *lplpslp = NULL;
            return 0;
        }

        assert(SlCache.lpslp != NULL);

        memcpy(lpslp, SlCache.lpslp, sizeof(SLP) * SlCache.cslp);
        *lplpslp = lpslp;
        return SlCache.cslp;
    }

    // Two passes, first pass, see if there is an exact match.  If there aren't
    // any exact matches, try to match just the file.ext name.  When OMF file
    // names are fully qualified, we should expect to always find a match on
    // the first pass.  This will help out with the case where there are two
    // different file.ext's in the exes/dlls loaded.
    for(iPass = 0; iPass < 2 && !lpslp; ++iPass) {

        // Loop through all of the exes that we know about.  We may want
        // to change this later
        while(hexeStart || (hexe = SHGetNextExe(hexe))) {

            // Extra fast scan to see if the file is in the list of files for the exe
            if (SLFFileInHexe(hexe, (BOOL)!iPass, lszFile)) {

                while(hmodStart || (hmod = SHGetNextMod(hexe, hmod))) {
                    LPMDS   lpmds = (LPMDS) hmod;
                    short   isf;
                    short   isfNext = -1;

                    do {
                        isf = isfNext + 1;

                        // Search for the filename in the current module
                        isfNext = IsfFromName((BOOL)!iPass, isf, lszFile, lpmds);

                        if (isfNext != -1) {
                            HSF     hsf;
                            SHOFF   cb;
                            ADDR    addr;
                            WORD    iSeg = 0;
                            WORD    iEntry = 0;

                            hsf = (HSF)GetLpsfFromIndex(
                                (LPSM) HstFromLpmds(lpmds),
                                isfNext
                           );

                            // Reuse the original version.  Since we have gotten our
                            // own hsf, we know that we will get the correct line
                            // number table
                            while(SLFLineToAddrExtended(hsf,
                                                          line,
                                                          &iSeg,
                                                          &iEntry,
                                                          &addr,
                                                          &cb,
                                                          (LPW)NULL))
                            {
                                // This could be smarter to allocate blocks, but the
                                // regular case will be that this will only happen
                                // once rather than multiple times, so just eat up
                                // a little CPU for simplicity
                                if (lpslp) {
                                    lpslp = (LPSLP)MHRealloc(lpslp,
                                                    sizeof(SLP) * (cslp + 1));
                                }
                                else {
                                    lpslp = (LPSLP)MHAlloc(sizeof(SLP));
                                }

                                // Additional check to see that the allocation
                                // actually succeeded before copying the data
                                if (lpslp) {
                                    lpslp[ cslp ].cb = cb;
                                    lpslp[ cslp ].addr = addr;
                                    ++cslp;
                                }
                            }
                        }
                    } while(isfNext != -1);

                    // If a module is specified, then DON'T loop through the rest of
                    // the modules
                    if (hmodStart) {
                        break;
                    }
                }
            }

            // If a module is specified, DON'T loop through any of the remaining
            // modules or exes.  Also, if an exe is specified, don't go through
            // any mor exes either
            if (hmodStart || hexeStart) {
                break;
            }
        }
    }

    *lplpslp = lpslp;

    if ( cslp ) {
        // Only free up if we need to
        if (SlCache.cslp < cslp) {
            if (SlCache.lpslp) {
                MHFree(SlCache.lpslp);
            }
            SlCache.lpslp = (LPSLP)MHAlloc(sizeof(SLP) * cslp);

            if (SlCache.lpslp == NULL) {
                return(0);
            }
        }

        if (cslp) {
            memcpy(SlCache.lpslp, lpslp, sizeof(SLP) * cslp);
        }

        _tcscpy(SlCache.szFile, lszFile);
        SlCache.hexe = hexeStart;
        SlCache.hmod = hmodStart;
        SlCache.line = line;
        SlCache.cslp = cslp;
    }
    return cslp;
}


//  SLNameFromHsf - Return the filename for an HSF
//
//  Purpose:        Get the filename associated to an HSF
//
//  Input:          hsf - handle to a source file
//
//  Returns:        Length-prefixed pointer to the filename.
//                  *** NOTE *** This is an ST!!!  It's length-prefixed,
//                  and it's NOT guaranteed to be null-terminated!

LPCH
SLNameFromHsf (
    HSF hsf
    )
{
    LPCH    lpch = NULL;

    if (hsf) {
        lpch = LpchGetName ((LPSF) hsf);
    }
    return(lpch);
}


//  SLNameFromHmod - Return the filename for an HMOD
//
//  Purpose:        Get one filename associated with an HMOD.  Each module
//                  of a program may have many source files associated
//                  with it (e.g., "foo.hpp", "bar.hpp", and "foo.cpp"),
//                  depending on whether there is code in any included
//                  files.  The iFile parameter can be used to loop
//                  through all the files.
//
//  Input:          hmod - handle to a module
//                  iFile - ONE-based index indicating which filename to
//                     return
//
//  Returns:        Length-prefixed pointer to the filename.
//                  *** NOTE *** This is an ST!!!  It's length-prefixed,
//                  and it's NOT guaranteed to be null-terminated!
//
//  Notes:          The filenames are NOT in any special order (you can't
//                  assume, for example, that the last one is the "real"
//                  source file.)
//
//                  Also, unfortunately (due to the linker), there may be
//                  duplicates!!!  One module may have two occurrences of
//                  "foo.hpp".

#pragma optimize ("", off)
LPCH
SLNameFromHmod (
    HMOD hmod,
    WORD iFile
    )
{
    LPCH    lpch  = NULL;
    LPMDS   lpmds;
    LPEXG   lpexg;

    if ((lpmds = (LPMDS) hmod) &&
        (lpexg = (LPEXG) LLLock (lpmds->hexg)))
    {
        UINT imod = lpmds->imds - 1;

        if (imod < lpexg->cMod && iFile <= lpexg->rgculFile [imod]) {
            lpch = lpexg->lpchFileNames +
                (lpexg->rgichFile [(WORD) (lpexg->rgiulFile [imod]) + iFile - 1]);
        }

        LLUnlock (lpmds->hexg);
    }

    return lpch;
}
#pragma optimize ("", on)


//  SLFQueryModSrc - Query whether a module has symbolic information
//
//  Purpose:        Query whether a module has symbolic information
//
//  Input:          hmod - module to check for source
//
//  Returns:        TRUE if this module has symbolic information, FALSE
//                  if not

BOOL
SLFQueryModSrc (
    HMOD hmod
    )
{
    LPMDS lpmds = (LPMDS) hmod;

    BOOL  fRet = lpmds->hst != NULL || lpmds->ulhst;

    return fRet;
}


//  SLHsfFromPcxt - Return source file for a context
//
//  Purpose:        Return the source file that a particular CXT is from
//
//  Input:          pcxt - pointer to CXT for which to find source file
//
//  Returns:        handle to source file, or NULL if not found

HSF
SLHsfFromPcxt (
    PCXT pcxt
    )
{
    LPMDS   lpmds = (LPMDS) SHHMODFrompCXT(pcxt);
    WORD    iFile = 0;
    WORD    iSeg  = 0;
    LPSF    lpsf = NULL;

    if (lpmds != NULL && HstFromLpmds (lpmds) != NULL) {
        FLpsfFromAddr (SHpADDRFrompCXT (pcxt),
                        (LPSM) lpmds->hst,
                        &lpsf,
                        &iFile,
                        &iSeg);
    }

    return (HSF) lpsf;
}


//  SLHsfFromFile - return HSF for a given source filename
//
//  Purpose:        Given a module and a source filename, return the HSF
//                  that corresponds
//
//  Input:          hmod - module to check for this filename (can't be NULL)
//                  lszFile - filename and extension
//
//  Returns:        handle to source file, or NULL if not found
//
//  Notes:          ONLY the filename and extension of lszFile are
//                  matched!  There must be no path on the lszFile

HSF
SLHsfFromFile (
    HMOD hmod,
    LSZ  lszFile
    )
{
    // We need to handle the no-hit case w/o loading source info

    LPSF    lpsf = NULL;
    LPMDS   lpmds = (LPMDS) hmod;
    char    szFileBuf[_MAX_PATH];
    LPSTR   lszFileT;

    assert(lszFile);
    assert(*lszFile != '\0');

    // If the filename is quoted, remove the quotes.

    if ((*lszFile == '\"') && (*(lszFile + _tcslen(lszFile) - 1) == '\"')) {
        lszFileT = szFileBuf;
        memcpy(lszFileT, _tcsinc(lszFile), _tcslen(lszFile) - 2);
        lszFileT[_tcslen(lszFile)-2] = '\0';
    } else {
        lszFileT = lszFile;
    }

    if (lpmds != NULL) {
        short isf = IsfFromName (FALSE, 0, lszFileT, lpmds);

        if (isf != -1) {
            lpsf = GetLpsfFromIndex ((LPSM) HstFromLpmds (lpmds), isf);
        }
    }

    return lpsf;
}


HST
HstFromLpmds (
    LPMDS lpmds
    )
{
    if (lpmds->hst != NULL) {
        return lpmds->hst;
    } else if (lpmds->pmod) {
        // Allocate space for this module's line number information,
        // then load it from the PDB and sort it.

        if (!ModQueryLines(lpmds->pmod, 0, (CB *)&lpmds->cbhst) ||
            !(lpmds->cbhst) ||
            !(lpmds->hst = MHAlloc(lpmds->cbhst)))
            return 0;

        if (ModQueryLines(lpmds->pmod, (PB)lpmds->hst, (CB *)&lpmds->cbhst)) {
            SortSM((LPSM)lpmds->hst);
            return lpmds->hst;
        } else {
            MHFree(lpmds->hst);
            lpmds->hst = 0;
            return 0;
        }
    } else if (lpmds->ulhst == 0) {
        return NULL;
    } else {
        assert(FALSE);          // We should never hit this code now
                                //  that we're mapped.
        LPEXG lpexg = (LPEXG) LLLock (lpmds->hexg);
        INT   hfile = SYOpen (lpexg->lszDebug);
        HST   hst   = MHAlloc ((UINT) lpmds->cbhst);

        if (hfile == -1 || hst == NULL) {
            LLUnlock (lpmds->hexg);
            return NULL;
        }

        if (SYSeek(hfile, lpmds->ulhst, SEEK_SET) != (LONG) lpmds->ulhst) {
            assert(FALSE);
        }

        if (SYReadFar (hfile, (LPB) hst, (UINT) lpmds->cbhst) != lpmds->cbhst) {
            assert (FALSE);
        }

        SYClose (hfile);

        lpmds->hst = hst;

        LLUnlock (lpmds->hexg);

        SortSM ((LPSM)hst);

        return hst;
    }
}


__inline VOID
SortSM (
    LPSM lpsm
    )
{
    short isf  = 0;
    LPSF  lpsf = NULL;

    while ((lpsf = GetLpsfFromIndex (lpsm, isf)) != NULL) {
        WORD isl = 0;
        LPSL lpsl = NULL;

        while ((lpsl = GetLpslFromIndex (lpsm, lpsf, isl)) != NULL) {
            if (!FCheckSLOrder (lpsl)) {
                SortSL (lpsl);
            }
            isl += 1;
        }
        isf += 1;
    }
}

BOOL
FCheckSLOrder (
    LPSL lpsl
    )
{
    BOOL fSorted  = TRUE;
    int  fChanged = FALSE;
    unsigned short coff     = lpsl->cLnOff;
    LPUL rgoff    = lpsl->offset;
    LPW  rgln     = (LPW) &lpsl->offset [ coff ];
    int  ioff     = 0;

    for (ioff = 1; ioff < coff; ioff++) {
        if (rgoff [ioff] == rgoff[ioff-1]) {

            // Yes this is extremely slow, but it is safe, and the
            //  condition that causes this move should only happen
            //  in a very odd case when the QC back end screws up.

            memmove(&rgoff[ioff - 1],
                    &rgoff[ioff],
                    (coff - ioff) * sizeof(ULONG));

            memmove(&rgln[ioff - 1],
                    &rgln[ioff],
                    (coff - ioff) * sizeof(WORD));

            fChanged = TRUE;
            coff -= 1;
        }
        else if (rgoff [ ioff ] < rgoff [ ioff - 1 ]) {
            fSorted = FALSE;
        }
    }

    if (fChanged) {
        memmove(&rgoff[coff],
                rgln,
                coff * sizeof(WORD));

        lpsl->cLnOff = coff;
    }

    return fSorted;
}


__inline VOID
SortOffFromBounds (
    WORD cbnds,
    LPBNDS rgbnds,
    WORD coff,
    LPUL rgoff
    )
{
    SortFromBounds (cbnds, rgbnds, coff, rgoff, sizeof (ULONG));
}


__inline VOID
SortLnFromBounds (
    WORD cbnds,
    LPBNDS rgbnds,
    WORD cln,
    LPW rgln
    )
{
    SortFromBounds (cbnds, rgbnds, cln, rgln, sizeof (WORD));
}


__inline VOID
SortFromBounds (
    WORD cbnds,
    LPBNDS rgbnds,
    WORD cv,
    LPV rgv,
    WORD cbv
    )
{
    LPV  lpv    = MHAlloc (cbv * cv);
    WORD ibnds  = 0;
    WORD iv     = 0;

    if (lpv == NULL) {
        return;
    }

    for (ibnds = 0; ibnds < cbnds; ibnds++) {
        WORD cvT = rgbnds [ ibnds ].ilnEnd - rgbnds [ ibnds ].ilnStart + 1;

        memcpy(((LPB) lpv) + (iv * cbv),
               ((LPB) rgv) + (rgbnds[ibnds].ilnStart * cbv),
               cvT * cbv);

        iv += cvT;
    }

    memcpy(rgv, lpv, cbv * cv);

    MHFree(lpv);
}

__inline VOID
SortSL (
    LPSL lpsl
    )
{
    WORD   coff      = lpsl->cLnOff;
    LPUL   rgoff     = lpsl->offset;
    LPW    rgln      = (LPW) &lpsl->offset [ coff ];
    WORD   cbnds     = 0;
    LPBNDS rgbnds    = NULL;

    rgbnds = BuildBounds (coff, rgoff, &cbnds);
    if (rgbnds != NULL) {
        SortOffFromBounds (cbnds, rgbnds, coff, rgoff);
        SortLnFromBounds  (cbnds, rgbnds, coff, rgln );

        MHFree (rgbnds);
    }
}


__inline WORD
FindPosition (
    LPBNDS rgbnds,
    WORD cbnds,
    LPUL rgoff,
    ULONG uoff
    )
{
    WORD ibnds = 0;

    // This should be a binary search - but existing test cases
    //  contain so few blocks that I'm not going to bother right now

    while (ibnds < cbnds) {
        if (rgoff [ rgbnds [ ibnds ].ilnEnd ] > uoff) {
            break;
        }

        ibnds += 1;
    }

    return ibnds;
}


__inline LPBNDS
InsertBlock (
    WORD   ibnds,
    WORD   cbnds,
    LPBNDS rgbnds,
    LPW    lpcbndsMax,
    LPW    lpcbndsAlloc
    )
{
    if (*lpcbndsMax + cbnds > *lpcbndsAlloc) {
        // If the insert is going to run over the currently allocated
        //  block array, reallocate it to give more room

        rgbnds = (LPBNDS) MHRealloc(rgbnds, sizeof(BNDS) * (*lpcbndsAlloc + cbndsAllocBlock));

        *lpcbndsAlloc += cbndsAllocBlock;
    }

    if (ibnds < *lpcbndsMax) {

        // If we're somewhere in the middle of the array, we need
        //  to shift the remainder up in memory.
        memmove(&rgbnds[ibnds + cbnds],
                &rgbnds[ibnds],
                (*lpcbndsMax - ibnds) * sizeof(BNDS));
    }

    *lpcbndsMax += cbnds;

    return rgbnds;
}


__inline WORD
ScanBlock (
    LPUL rgoff,
    WORD coff,
    WORD ioff,
    ULONG uoffMax
    )
{
    while (ioff + 1 < coff &&
            rgoff [ ioff + 1 ] > rgoff [ ioff ] &&
            rgoff [ ioff + 1 ] < uoffMax)
    {
        ioff += 1;
    }

    return ioff;
}


LPBNDS
BuildBounds (
    WORD coff,
    LPUL rgoff,
    LPW lpcbnds
    )
{
    LPBNDS rgbnds     = (LPBNDS) MHAlloc (sizeof (BNDS) * cbndsAllocBlock);
    WORD   cbndsAlloc = cbndsAllocBlock;
    WORD   cbnds      = 0;
    WORD   ioff       = 0;

    while (ioff < coff) {
        ULONG uoffCurr  = rgoff [ ioff ];
        ULONG uoffMax   = 0;
        WORD  ibnds     = FindPosition (rgbnds, cbnds, rgoff, uoffCurr);

        if (ibnds == cbnds) {

            // We're after all other known blocks, so our max
            //  is "infinity"

            uoffMax = 0xFFFFFFFF;

            rgbnds = InsertBlock (ibnds, 1, rgbnds, &cbnds, &cbndsAlloc);

        } else if (rgoff [ rgbnds [ ibnds ].ilnStart ] > uoffCurr) {

            // We're at an insertion point, not in the middle of
            //  another block candidate

            uoffMax = rgoff [ rgbnds [ ibnds ].ilnStart ];

            rgbnds = InsertBlock (ibnds, 1, rgbnds, &cbnds, &cbndsAlloc);
        } else {

            // We're in the middle of another block candidate, so we
            //  must split it in two

            rgbnds = InsertBlock (ibnds, 2, rgbnds, &cbnds, &cbndsAlloc);

            // Start of ibnds is already set
            rgbnds [ ibnds ].ilnEnd = ScanBlock (
                rgoff,
                coff,
                rgbnds [ ibnds ].ilnStart,
                uoffCurr
           );

            rgbnds [ ibnds + 2 ].ilnStart = rgbnds [ ibnds ].ilnEnd + 1;
            // End of ibnds + 2 is already set

            uoffMax = rgoff [ rgbnds [ ibnds + 2 ].ilnStart ];

            ibnds += 1;
        }

        rgbnds [ ibnds ].ilnStart = ioff;
        rgbnds [ ibnds ].ilnEnd   = ScanBlock (rgoff, coff, ioff, uoffMax);

        ioff = rgbnds [ ibnds ].ilnEnd + 1;
    }

    *lpcbnds = cbnds;
    return rgbnds;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\inc\shassert.h ===
/***
*assert.h - define the assert macro
*
*   Copyright (c) 1985-1987, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*   Defines the assert(exp) macro.
*   [ANSI/System V]
*
*Modified:
*   Allent 3/14/88 - call Quit instead of abort
*******************************************************************************/
#ifndef _ASSERT_DEFINED

#ifdef DEBUGVER

#define assert(exp) { \
    if (!(exp)) { \
        LBPrintf( #exp, __FILE__, __LINE__); \
        LBQuit(2); \
    } \
}

#else

#define assert(exp)

#endif /* NDEBUG */

#define _ASSERT_DEFINED

#endif /* _ASSERT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\th.cpp ===
// th.c
//
//   Copyright <C> 1989-94, Microsoft Corporation

#include "shinc.hpp"
#pragma hdrstop

__inline HTYPE
NB09GetTypeFromIndex (
    LPEXG lpexg,
    THIDX index
    )
{
    HTYPE   htype = (HTYPE)NULL;

    if (lpexg->lpalmTypes ) {
        assert ( lpexg->rgitd != NULL );

        // adjust the pointer to an internal index
        index -= CV_FIRST_NONPRIM;

        // if type is in range, return it
        if( index < (THIDX) lpexg->citd ) {
            htype = (HTYPE) LpvFromAlmLfo ( lpexg->lpalmTypes, lpexg->rgitd [ index ] );
#if CC_CVTYPE32
            if( lpexg->pwti ) {
                htype = HTYPE(lpexg->pwti->pTypeWidenTi ( index, PB(htype) ));
            }
#endif
        }
    }
    return htype;
}

HTYPE
THGetTypeFromIndex (
    HMOD hmod,
    THIDX index
    )
{
    HTYPE htype = (HTYPE)NULL;

    if ( hmod && !CV_IS_PRIMITIVE (index) ) {
        HEXG hexg = SHHexgFromHmod ( hmod );
        LPEXG lpexg = (LPEXG) LLLock ( hexg );

        if (lpexg->ppdb) {
            assert (lpexg->ptpi);
#if CC_LAZYTYPES
            if (TypesIsTypeServed(lpexg->ptpi, index))
#else
            if (index < TypesQueryTiMac(lpexg->ptpi))
#endif
            {
                if (!TypesQueryPbCVRecordForTi(lpexg->ptpi, index, (PB*) &htype)){
                    htype = (HTYPE) NULL;
                }
            }
        } else {
            htype = NB09GetTypeFromIndex (lpexg, index);
        }

        LLUnlock( hexg );
    }

    return htype;
}

HTYPE
THGetNextType (
    HMOD hmod,
    HTYPE hType
    )
{
    Unreferenced( hmod );
    Unreferenced( hType );
    return(NULL);
}

#if CC_LAZYTYPES
BOOL
THAreTypesEqual(
                HMOD hmod,
                THIDX ti1,
                THIDX ti2 )
{
    if ( hmod ) {
        HEXG    hexg = SHHexgFromHmod ( hmod );
        LPEXG   lpexg = (LPEXG) LLLock ( hexg );

        if (lpexg->ppdb) {
            assert (lpexg->ptpi);
            BOOL    fRet = TypesAreTypesEqual( lpexg->ptpi, ti1, ti2 );
            LLUnlock ( hexg );
            return fRet;
        }
        LLUnlock ( hexg );
    }
    return ti1 == ti2;  // by default just compare the indexes
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\shsymlb1.cpp ===
//  SHsymlb1.c - common library routines to find an
//       omf symbol by name or address.
//
//  Copyright <C> 1988, Microsoft Corporation
//
//  Purpose: To supply a concise interface to the debug omf for symbols
//
//  Revision History:
//
//      [00] 15-nov-91 DavidGra
//
//          Suppress hashing when the SSTR_NoHash bit it set.
//
//      10-Dec-94 BryanT    Nuke SHSetUserDir

#include "shinc.hpp"
#pragma hdrstop

// This is project dependent stuff used in this module

BOOL
SHCanDisplay (
    HSYM hsym
    )
{
    switch ( ( (SYMPTR) hsym)->rectyp ) {
        case S_REGISTER:
        case S_CONSTANT:
        case S_BPREL32:
        case S_REGREL32:
        case S_LDATA32:
        case S_GDATA32:
        case S_LTHREAD32:
        case S_GTHREAD32:
        case S_PUB32:
            return TRUE;

        default:
            return FALSE;
    }
}


//  SHlszGetSymName
//
//  Purpose: To return a pointer to the length prefixed symbol name.
//
//  Input:
//      lpSym   - The pointer to the symbol, this must not be a tag
//
//  Returns
//      - a far pointer to the length prefixed name or NULL.

LPB
SHlszGetSymName(
    SYMPTR lpSym
    )
{

    WORD  fSkip;

    if ( !lpSym ) {
        return NULL;
    }

    switch (lpSym->rectyp) {

        case S_COMPILE:
            return NULL;

        case S_REGISTER:
            return ((REGPTR) lpSym)->name;

        case S_UDT:
        case S_COBOLUDT:
             return ((UDTPTR) lpSym)->name;

        case S_CONSTANT:
            fSkip = offsetof (CONSTSYM, name);
            if (((CONSTPTR)lpSym)->value >= LF_CHAR) {
                switch(((CONSTPTR)lpSym)->value) {
                    case LF_CHAR:
                        fSkip += sizeof (CHAR);
                        break;

                    case LF_SHORT:
                    case LF_USHORT:
                        fSkip += sizeof (WORD);
                        break;

                    case LF_LONG:
                    case LF_ULONG:
                    case LF_REAL32:
                        fSkip += sizeof (LONG);
                        break;

                    case LF_REAL64:
                        fSkip += 8;
                        break;

                    case LF_REAL80:
                        fSkip += 10;
                        break;

                    case LF_REAL128:
                        fSkip += 16;
                        break;

                    case LF_VARSTRING:
                        fSkip += ((lfVarString *)&(((CONSTPTR)lpSym)->value))->len +
                          sizeof (((lfVarString *)&(((CONSTPTR)lpSym)->value))->len);
                         break;

                    default:
                        assert (FALSE);
                        break;

                }
            }
            return ((LPB)lpSym) + fSkip;

        case S_BPREL32:
            return ((BPRELPTR32)lpSym)->name;

        case S_REGREL32:
            return ((LPREGREL32)lpSym)->name;

        case S_LDATA32:
        case S_GDATA32:
        case S_LTHREAD32:
        case S_GTHREAD32:
        case S_PUB32:
            return ((DATAPTR32)lpSym)->name;

        case S_LABEL32:
            return ((LABELPTR32) lpSym)->name;

        case S_LPROC32:
        case S_GPROC32:
        //case S_ENTRY:
            return ((PROCPTR32) lpSym)->name;

        case S_LPROCMIPS:
        case S_GPROCMIPS:
            return ((PROCPTRMIPS) lpSym)->name;

        case S_THUNK32:
            return ((THUNKPTR32)lpSym)->name;

        case S_BLOCK32:
            return ((BLOCKPTR32)lpSym)->name;

    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\inc\strings.h ===
//  STRINGS.H
//
//  This file contains all strings which are used in the EM for display
//  purposes.  This is done for internationalization purposes.
//
//  strings.c should define DEFINE_STRINGS before including this file,
//  so that the strings will be defined rather than just declared.

#ifdef DEFINE_STRINGS
#define DECL_STR(name, value)   char name[] = value
#else
#define DECL_STR(name, value)   extern char name[]
#endif

DECL_STR( SzSheNone,             "symbols loaded"               );
DECL_STR( SzSheNoSymbols,        "no symbols loaded"            );
DECL_STR( SzSheFutureSymbols,    "symbol format not supported"  );
DECL_STR( SzSheMustRelink,       "symbol format not supported"  );
DECL_STR( SzSheNotPacked,        "must run cvpack on symbols"   );
DECL_STR( SzSheOutOfMemory,      "out of memory"                );
DECL_STR( SzSheCorruptOmf,       "symbol information corrumpt"  );
DECL_STR( SzSheFileOpen,         "could not open symbol file"   );
DECL_STR( SzSheSuppressSyms,     "symbol loading suppressed"    );
DECL_STR( SzSheDeferSyms,        "symbol loading deferred"      );
DECL_STR( SzSheSymbolsConverted, "symbols converted & loaded"   );
DECL_STR( SzSheBadTimeStamp,     "has mismatched timestamps"    );
DECL_STR( SzSheBadChecksum,      "has mismatched checksums"     );
DECL_STR( SzShePdbNotFound,      "can't find/open pdb file"     );
DECL_STR( SzShePdbBadSig,        "internal pdb signature doesn't match sym handler" );
DECL_STR( SzShePdbInvalidAge,    "pdb info doesn't match image" );
DECL_STR( SzShePdbOldFormat,     "pdb format is obsolete"       );
DECL_STR( SzSheConvertTIs,       "converting 16-bit type indices" );

// Last resort error returned by SHLszGetErrorText()
DECL_STR( SzSheBadError,         "unknown symbol handler error" );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\symcvt.h ===
/*++


Copyright (c) 1992  Microsoft Corporation

Module Name:

    symcvt.h

Abstract:

    This file contains all of the type definitions and prototypes
    necessary to access the symcvt library.

Author:

    Wesley A. Witt (wesw) 19-April-1993

Environment:

    Win32, User Mode

--*/


typedef struct tagPTRINFO {
    DWORD                       size;
    DWORD                       count;
    PUCHAR                      ptr;
} PTRINFO, *PPTRINFO;

typedef struct tagIMAGEPOINTERS {
    char                        szName[MAX_PATH];
    HANDLE                      hFile;
    BOOL                        CloseFile;      // TRUE if symcvt opened file
    HANDLE                      hMap;
    DWORD                       fsize;
    PUCHAR                      fptr;
    BOOLEAN                     fRomImage;
    PIMAGE_DOS_HEADER           dosHdr;
    PIMAGE_NT_HEADERS           ntHdr;
    PIMAGE_ROM_HEADERS          romHdr;
    PIMAGE_FILE_HEADER          fileHdr;
    PIMAGE_OPTIONAL_HEADER      optHdr;
    PIMAGE_SEPARATE_DEBUG_HEADER sepHdr;
    int                         cDebugDir;
    PIMAGE_DEBUG_DIRECTORY *    rgDebugDir;
    PIMAGE_SECTION_HEADER       sectionHdrs;
    PIMAGE_SECTION_HEADER       debugSection;
    PIMAGE_SYMBOL               AllSymbols;
    PUCHAR                      stringTable;
    int                         numberOfSymbols;
    int                         numberOfSections;
    PCHAR *                     rgpbDebugSave;
} IMAGEPOINTERS, *PIMAGEPOINTERS;

#define COFF_DIR(x)             ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_COFF])
#define CV_DIR(x)               ((x)->rgDebugDir[IMAGE_DEBUG_TYPE_CODEVIEW])

typedef struct _MODULEINFO {
    DWORD               iMod;
    DWORD               cb;
    DWORD               SrcModule;
    LPSTR               name;
} MODULEINFO, *LPMODULEINFO;

typedef struct tagPOINTERS {
    IMAGEPOINTERS               iptrs;         // input file pointers
    IMAGEPOINTERS               optrs;         // output file pointers
    PTRINFO                     pCvStart;      // start of cv info
    PUCHAR                      pCvCurr;       // current cv pointer
    PTRINFO                     pCvModules;    // module information
    PTRINFO                     pCvSrcModules; // source module information
    PTRINFO                     pCvPublics;    // publics information
    PTRINFO                     pCvSegName;    // segment names
    PTRINFO                     pCvSegMap;     // segment map
    PTRINFO                     pCvSymHash;    // symbol hash table
    PTRINFO                     pCvAddrSort;   // address sort table
    LPMODULEINFO                pMi;
    DWORD                       modcnt;
} POINTERS, *PPOINTERS;

#if 0
#define DECL_STR( she, val, str )	she=val,
typedef enum
{
#include "sherror.h"
} SHE;
#undef DECL_STR

typedef  char *  (* CONVERTPROC) (HANDLE, char *, SHE*);
#endif

BOOL MapInputFile ( PPOINTERS p, HANDLE hFile, char *fname);
BOOL UnMapInputFile ( PPOINTERS p );
BOOL CalculateNtImagePointers( PIMAGEPOINTERS p );

#define align(_n)       ((4 - (( (DWORD)_n ) % 4 )) & 3)

#define ValidateHeap()

BOOL ConvertExpToCv(PPOINTERS p, char *fname, SHE*);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\bp.c ===
#include "precomp.h"
#pragma hdrstop

SetFile()


BREAKPOINT      masterBP = {0L,0L};
PBREAKPOINT     bpList = &masterBP;

extern HTHDX        thdList;
extern CRITICAL_SECTION csThreadProcList;


PBREAKPOINT
GetNewBp(
    HPRCX         hprc,
    HTHDX         hthd,
    BPTP          BpType,
    BPNS          BpNotify,
    ADDR         *AddrBp,
    HPID          id,
    PBREAKPOINT   BpUse
    )
/*++

Routine Description:

    Allocates a BREAKPOINT structure and initializes it. Note that
    this does NOT add the structure to the breakpoint list (bplist).
    If it is not an address bp (i.e. it is a watchpoint), the hwalk
    field must be initialized later.

Arguments:

    hprc    - Supplies process to put BP in

    hthd    - Supplies optional thread

    AddrBp  - Supplies address structure for the breakpoint

    id      - Supplies EM id for BP

    BpUse   - (optional) Supplies other BP on same address (so we can steal
                the original code from it instead of reading).

Return Value:

    PBREAKPOINT      -   Pointer to allocated and initialized structure.

--*/

{
    PBREAKPOINT Bp;
    DWORD       i;

    assert( !BpUse || ( BpUse->hthd != hthd ) || (BpUse->bpNotify != BpNotify) );

    Bp = (PBREAKPOINT)MHAlloc(sizeof(BREAKPOINT));
    assert( Bp );

    if ( Bp ) {

        assert( bpList );

        Bp->next        = NULL;
        Bp->hprc        = hprc;
        Bp->hthd        = hthd;
        Bp->cthd        = 1;
        Bp->id          = id;
        Bp->instances   = 1;
        Bp->isStep      = FALSE;
        Bp->hBreakPoint = 0;
        Bp->bpType      = BpType;
        Bp->bpNotify    = BpNotify;
        Bp->hWalk       = NULL;
        memset(&Bp->addr, 0, sizeof(Bp->addr));

        //
        // Get the opcode from the indicated address
        //

        if (AddrBp) {

            assert(!ADDR_IS_LI(*AddrBp));
            if (ADDR_IS_LI(*AddrBp)) {
                MHFree(Bp);
                Bp = NULL;
            } else {

                //Bp->instr1      = 0;
                Bp->addr        = *AddrBp;

#if 0
                if ( BpUse ) {

                    Bp->instr1 = BpUse->instr1;

                } else if (!AddrReadMemory(hprc, hthd, AddrBp, &(Bp->instr1), BP_SIZE, &i) ||
                               (i != BP_SIZE)) {

#ifdef KERNEL
                    Bp->instr1 = 0;
#else
                    MHFree(Bp);
                    Bp = NULL;
#endif
                }
#endif
            }
        }
    }

    return Bp;
}



PBREAKPOINT
SetBP(
    HPRCX     hprc,
    HTHDX     hthd,
    BPTP      bptype,
    BPNS      bpnotify,
    LPADDR    paddr,
    HPID      id
    )
/*++

Routine Description:

    Set a breakpoint, or increment instance count on an existing bp.
    if hthd is non-NULL, BP is only for that thread.

Arguments:

    hprc  - Supplies process to put BP in

    hthd  - Supplies optional thread

    bptype - Supplies OSDEBUG BP type

    bpnotify - Supplies OSDEBUG notification code

    paddr - Supplies address structure for the breakpoint

    id    - Supplies EM id for BP

Return Value:

    pointer to bp structure, or NULL for failure

--*/
{
    PBREAKPOINT pbp;
    PBREAKPOINT pbpT;
    ADDR        addr;
    ADDR        addr2;

    if (!hprc) {
        return (PBREAKPOINT)NULL;
    }

    EnterCriticalSection(&csThreadProcList);

    /*
     * First let's try to find a breakpoint that
     * matches this description
     */

    pbpT = FindBP(hprc, hthd, bptype, bpnotify, paddr, FALSE);

    /*
     * If this thread has a breakpoint here,
     * increment reference count.
     */

    if (pbpT &&
        pbpT->hthd == hthd &&
        pbpT->bpNotify == bpnotify
        ) {

        pbp = pbpT;
        pbp->instances++;

    } else if ( pbp = GetNewBp( hprc, hthd, bptype, bpnotify, paddr, id, pbpT )) {

        if ( !pbpT ) {

            //
            //  Now write the cpu-specific breakpoint code.
            //
            if ( WriteBreakPoint(pbp) ) {
                AddBpToList(pbp);
            } else {
                MHFree( pbp );
                pbp = NULL;
            }
        }
        else
            AddBpToList(pbp);           // if already a bp at that addr, just add to list


        /*
         * Make it a linear address to start with
         */

        addr2 = *paddr;
        TranslateAddress(hprc, hthd, &addr2, TRUE);

        /*
         * Check with the threads to see if we are at this address. If so then
         *  we need to set the BP field so we don't hit the bp imeadiately
         */

        if (hthd) {
            AddrFromHthdx(&addr, hthd);
            if ((hthd->tstate & ts_stopped) &&
                (AtBP(hthd) == NULL) &&
                AreAddrsEqual(hprc, hthd, &addr, &addr2)) {
                SetBPFlag(hthd, pbp);
            }
        } else {
            for (hthd = hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                AddrFromHthdx(&addr, hthd);
                if ((hthd->tstate & ts_stopped) &&
                    (AtBP(hthd) == NULL) &&
                    AreAddrsEqual(hprc, hthd, &addr, &addr2)) {
                    SetBPFlag(hthd, pbp);
                }
            }
        }
    }

    LeaveCriticalSection(&csThreadProcList);

    return pbp;
}                               /* SetBP() */


#ifdef KERNEL


BOOL
SetBPEx(
    HPRCX         hprc,
    HTHDX         hthd,
    HPID          id,
    DWORD         Count,
    ADDR         *Addrs,
    PBREAKPOINT  *Bps,
    DWORD         ContinueStatus
    )

/*++

Routine Description:

    Allocates a bunch of breakpoints from a given list of linear offsets.

Arguments:

    hprc    - Supplies process to put BP in

    hthd    - Supplies optional thread

    Count   - Supplies count of breakpoints to set

    Addrs   - Supplies list with Count addresses

    Bps     - Supplies buffer to be filled with Count pointers to
                       BREAKPOINT structures.  Original contents are
                       overwritten.

    ContinueStatus -

Return Value:

    BOOL    -   If TRUE, then ALL breakpoints were set.
                If FALSE, then NONE of the breakpoints were set.


    NOTENOTE - Not sure of what will happen if the list contains duplicated
               addresses!

--*/

{
    PDBGKD_WRITE_BREAKPOINT     DbgKdBp;
    PDBGKD_RESTORE_BREAKPOINT   DbgKdBpRes;
    DWORD                       SetCount = 0;
    DWORD                       NewCount = 0;
    DWORD                       i;
    DWORD                       j;
    PBREAKPOINT                 BpT;
    BOOL                        Ok;
    ADDR                        Addr;
    ADDR                        Addr2;

    if (!hprc) {
        assert(!"hprc == NULL is SetBPEx");
        return FALSE;
    }

    assert( Count > 0 );
    assert( Addrs );
    assert( Bps );

    if ( Count == 1 ) {
        //
        //  Only one breakpoint, faster to simply call SetBP
        //
        Bps[0] = SetBP( hprc, hthd, bptpExec, bpnsStop, &Addrs[0], id );
        return ( Bps[0] != NULL );
    }

    EnterCriticalSection(&csThreadProcList);

    AddrInit( &Addr, 0, 0, 0, TRUE, TRUE, FALSE, FALSE );

    //
    //  Allocate space for Count breakpoints
    //
    DbgKdBp = (PDBGKD_WRITE_BREAKPOINT)
                            MHAlloc( sizeof(DBGKD_WRITE_BREAKPOINT) * Count );
    assert( DbgKdBp );

    if ( !DbgKdBp ) {
        LeaveCriticalSection(&csThreadProcList);
        return FALSE;
    }

    for ( i=0; i<Count; i++ ) {

        //
        //  See if we already have a breakpoint at this address.
        //
        BpT = FindBP( hprc, hthd, bptpExec, bpnsStop, &Addrs[i], FALSE );

        if (BpT &&
            BpT->hthd == hthd &&
            BpT->bpNotify == bpnsStop
            ) {

            //
            // exact match: just bump the instance count
            //

            Bps[i] = BpT;
            Bps[i]->instances++;

        } else if (BpT) {

            //
            // address matched: keep the old BP handle, make a new record
            //

            Bps[i] = GetNewBp( hprc, hthd, bptpExec, bpnsStop, &Addrs[i], id, NULL );
            Bps[i]->hBreakPoint = BpT->hBreakPoint;

        } else {

            //
            // no match: need a new BP
            //

            Bps[i] = GetNewBp( hprc, hthd, bptpExec, bpnsStop, &Addrs[i], id, NULL );
            assert( Bps[i] );

            //
            // set instance to 0 to indicate it is unset
            //
            Bps[i]->instances = 0;

            DbgKdBp[ NewCount ].BreakPointAddress = (PVOID)GetAddrOff(Addrs[i]);
            DbgKdBp[ NewCount ].BreakPointHandle  = (ULONG)NULL;

            //
            // keep BP packet index in handle field until BP is set
            //
            Bps[i]->hBreakPoint = NewCount++;
        }
    }

    Ok = TRUE;
    if ( NewCount > 0 ) {

        //
        //  Set all new breakpoints
        //
        assert( NewCount <= Count );
        Ok = WriteBreakPointEx( hthd, NewCount, DbgKdBp, ContinueStatus );
    }

    if ( Ok ) {
        //
        //  Fill in the breakpoint list
        //
        for ( i=0; i<Count; i++ ) {

            if ( Bps[i] && Bps[i]->instances == 0) {

                j = Bps[i]->hBreakPoint;

                assert( (PVOID)GetAddrOff(Addrs[i]) ==
                                         DbgKdBp[j].BreakPointAddress );
                //
                //  Allocate new BP structure and get handle from
                //  the breakpoint packet.
                //

                Bps[i]->hBreakPoint = DbgKdBp[j].BreakPointHandle;
                Bps[i]->instances = 1;
                AddBpToList(Bps[i]);
            }

            SetCount++;

            //
            //  Check with the threads to see if we are at this address.
            //  If so then we need to set the BP field so we don't hit
            //  the bp imeadiately
            //

            Addr2 = Bps[i]->addr;

            if ( hthd ) {
                AddrFromHthdx( &Addr, hthd );
                if ((hthd->tstate & ts_stopped) &&
                    (AtBP(hthd) == NULL) &&
                    AreAddrsEqual(hprc, hthd, &Addr, &Addr2 )) {
                    SetBPFlag(hthd, Bps[i]);
                }
            } else {
                for (hthd=hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                    AddrFromHthdx( &Addr, hthd );
                    if ((hthd->tstate & ts_stopped) &&
                        (AtBP(hthd) == NULL) &&
                        AreAddrsEqual(hprc, hthd, &Addr, &Addr2)) {
                        SetBPFlag(hthd, Bps[i]);
                    }
                }
            }
        }

        assert( j == NewCount );

    } else {

        //
        //  Clean up any breakpoints that were set.
        //
        DbgKdBpRes = (PDBGKD_RESTORE_BREAKPOINT)
                    MHAlloc( sizeof(DBGKD_RESTORE_BREAKPOINT) * NewCount );
        assert( DbgKdBpRes );

        if ( DbgKdBpRes ) {

            //
            //  Put all breakpoints with a valid handle on the list of
            //  breakpoints to be removed.
            //
            j = 0;
            for ( i=0; i<NewCount;i++) {
                if ( DbgKdBp[i].BreakPointHandle != (ULONG)NULL ) {
                    DbgKdBpRes[j++].BreakPointHandle =
                                             DbgKdBp[i].BreakPointHandle;
                }
            }

            //
            //  Now remove them
            //
            if ( j > 0 ) {
                assert( j <= NewCount );
                RestoreBreakPointEx( j, DbgKdBpRes );
            }

            MHFree( DbgKdBpRes );

            //
            //  Remove allocated BP structures
            //
            for ( i=0; i<Count; i++ ) {
                if ( Bps[i] && Bps[i]->instances == 0 ) {
                    assert( !Bps[i]->next );
                    MHFree( Bps[i] );
                    Bps[i] = NULL;
                }
           }
        }
    }

    MHFree( DbgKdBp );

    LeaveCriticalSection(&csThreadProcList);

    return (SetCount == Count);
}


#else   // KERNEL

BOOL
SetBPEx(
    HPRCX         hprc,
    HTHDX         hthd,
    HPID          id,
    DWORD         Count,
    ADDR         *Addrs,
    PBREAKPOINT  *Bps,
    DWORD         ContinueStatus
    )

/*++

Routine Description:

    Allocates a bunch of breakpoints from a given list of linear offsets.

Arguments:

    hprc    - Supplies process to put BP in

    hthd    - Supplies optional thread

    Count   - Supplies count of breakpoints to set

    Addrs   - Supplies list with Count addresses

    Bps     - Supplies buffer to be filled with Count pointers to
                       BREAKPOINT structures.  Original contents is
                       overwritten.

    ContinueStatus -

Return Value:

    BOOL    -   If TRUE, then ALL breakpoints were set.
                If FALSE, then NONE of the breakpoints were set.


    NOTENOTE - Not sure of what will happen if the list contains duplicated
               addresses!

--*/

{
    DWORD       SetCount = 0;
    DWORD       i;
    DWORD       j;
    DWORD       cbBytes;
    ADDR        Addr;
    ADDR        Addr2;
    PBREAKPOINT BpT;

    if (!hprc) {
        assert(!"hprc == NULL in SetBPEx");
        return FALSE;
    }

    assert( Count > 0 );
    assert( Addrs );
    assert( Bps );

    if ( Count == 1 ) {
        //
        //  Only one breakpoint, faster to simply call SetBP
        //
        Bps[0] = SetBP( hprc, hthd, bptpExec, bpnsStop, &Addrs[0], id );
        return ( Bps[0] != NULL );
    }

    EnterCriticalSection(&csThreadProcList);

    for ( i=0; i<Count; i++ ) {

        //
        //  See if we already have a breakpoint at this address.
        //
        BpT = FindBP( hprc, hthd, bptpExec, bpnsStop, &Addrs[i], FALSE );

        if (BpT &&
            BpT->hthd == hthd &&
            BpT->bpNotify == bpnsStop
            ) {

            //
            //  Reuse this breakpoint
            //

            Bps[i]->instances++;
            assert( Bps[i]->instances > 1 );

        } else {

            //
            //  Get new breakpoint
            //

            Bps[i] = GetNewBp(hprc, hthd, bptpExec, bpnsStop, &Addrs[i], id, BpT);

            if ( !Bps[i] ) {
                assert(!"GetNewBp failed in SetBPEx");
                break;
            }

            if (!BpT) {
                if (!WriteBreakPoint(Bps[i])) {
                    MHFree( Bps[i] );
                    Bps[i] = NULL;
                    assert(!"WriteBreakPoint failed in SetBPEx");
                    break;
                }
            }
        }
    }

    if ( i < Count ) {
        //
        //  Something went wrong, will backtrack
        //

        assert(!"i < Count in SetBPEx");

        for ( j=0; j<i; j++ ) {

            assert( Bps[j] );
            Bps[j]->instances--;

            if ( Bps[j]->instances == 0 ) {

#if 0
                if ( !ADDR_IS_LI(Bps[j]->addr) ) {
                    AddrWriteMemory(hprc, hthd, &Bps[j]->addr,
                                      (LPBYTE) &Bps[j]->instr1, BP_SIZE, &cbBytes);
                }
#endif
                MHFree( Bps[j] );
                Bps[j] = NULL;
            }
        }

    } else {

        //
        //  Add all the new breakpoints to the list
        //
        for ( i=0; i<Count; i++ ) {

            if ( Bps[i]->instances == 1 ) {
                AddBpToList(Bps[i]);
            }

            //
            //  Check with the threads to see if we are at this address. If so then
            //  we need to set the BP field so we don't hit the bp imeadiately
            //

            Addr2 = Bps[i]->addr;

            if ( hthd ) {
                AddrFromHthdx( &Addr, hthd );
                if ((hthd->tstate & ts_stopped) &&
                    (AtBP(hthd) == NULL) &&
                    AreAddrsEqual(hprc, hthd, &Addr, &Addr2 )) {
                    SetBPFlag(hthd, Bps[i]);
                }
            } else {
                for (hthd=hprc->hthdChild; hthd; hthd = hthd->nextSibling) {
                    AddrFromHthdx( &Addr, hthd );
                    if ((hthd->tstate & ts_stopped) &&
                        (AtBP(hthd) == NULL) &&
                        AreAddrsEqual(hprc, hthd, &Addr, &Addr2)) {
                        SetBPFlag(hthd, Bps[i]);
                    }
                }
            }
        }

        SetCount = Count;
    }

    LeaveCriticalSection(&csThreadProcList);

    return (SetCount == Count);
}

#endif // KERNEL

BOOL
BPInRange(
    HPRCX         hprc,
    HTHDX         hthd,
    PBREAKPOINT   bp,
    LPADDR        paddrStart,
    DWORD         cb,
    LPDWORD       offset
    )
{
    ADDR        addr1;
    ADDR        addr2;

    /*
     * If the breakpoint has a Loader index address then we can not
     *  possibly match it
     */

    assert (!ADDR_IS_LI(*paddrStart) );
    if (ADDR_IS_LI(bp->addr)) {
        return FALSE;
    }

    *offset = 0;

    /*
     * Now check for "equality" of the addresses.
     *
     *     Need to include size of BP in the address range check.  Since
     *  the address may start half way through a breakpoint.
     */

    if ((ADDR_IS_FLAT(*paddrStart) == TRUE) &&
        (ADDR_IS_FLAT(bp->addr) == TRUE)) {
        if ((GetAddrOff(*paddrStart) - sizeof(BP_UNIT) + 1 <=
                GetAddrOff(bp->addr)) &&
            (GetAddrOff(bp->addr) < GetAddrOff(*paddrStart) + cb)) {

            *offset = (DWORD) GetAddrOff(bp->addr) -
                (DWORD) GetAddrOff(*paddrStart);
            return TRUE;
        }
        return FALSE;
    }

    /*
     * The two addresses did not start out as flat addresses.  So change
     *  them to linear addresses so that we can see if the addresses are
     *  are really the same
     */

    addr1 = *paddrStart;
    if (!TranslateAddress(hprc, hthd, &addr1, TRUE)) {
        return FALSE;
    }
    addr2 = bp->addr;
    if (!TranslateAddress(hprc, hthd, &addr2, TRUE)) {
        return FALSE;
    }

    if ((GetAddrOff(addr1) - sizeof(BP_UNIT) + 1 <= GetAddrOff(addr2)) &&
        (GetAddrOff(addr2) < GetAddrOff(addr1) + cb)) {
        *offset = (DWORD) GetAddrOff(addr2) - (DWORD) GetAddrOff(addr1);
        return TRUE;
    }

    return FALSE;
}


BOOL
BPPriorityIsGreater(
    BPNS n1,
    BPNS n2
    )
{
    if (n1 == bpnsStop) {
        return (n2 == bpnsContinue) || (n2 == bpnsCheck);
    } else if (n1 == bpnsCheck) {
        return (n2 == bpnsContinue);
    } else {
        return FALSE;
    }
}


#if 0
PBREAKPOINT
FindBP(
    HPRCX    hprc,
    HTHDX    hthd,
    BPTP     bptype,
    BPNS     bpnotify,
    LPADDR   paddr,
    BOOL     fExact
    )
/*++

Routine Description:

    Find and return a pointer to a BP struct.

    This is called for the following cases:

    1) A breakpoint has been hit, and we want to find a BP record for it.
       In this case, we want to see the highest priority match, with
       preference to the correct thread.

       Call with bpnotify == -1, hthd == xxxx, fExact == FALSE

    2) We want to step off/through a BP.  Any match will do, we just need
       the instruction.

       Call with bpnotify == -1, hthd == 0, fExact == FALSE

    3) We want to delete a BP.  Everything must match exactly.  (It would
       be better to do this directly by the pointer to the BP, but the
       shells do not support this properly.)

       Call with bpnotify == bpnsXXXX, hthd == xxxx, fExact == TRUE
       (N.B. hthd may be NULL, which means "any thread")

    Always returns a BP that matches hthd and bpnotify if one exists; if
    fExact is FALSE and there is no exact match, a BP matching only hprc
    and address will succeed.


Arguments:

    hprc   - Supplies process

    hthd   - Supplies thread

    bptype - Supplies OSDEBUG BP type

    bpnotify -

    paddr  - Supplies address

    fExact - Supplies TRUE if must be for a certain thread

Return Value:

    pointer to BREAKPOINT struct, or NULL if none found.

--*/
{
    PBREAKPOINT  pbp;
    PBREAKPOINT  pbpFound = NULL;
    ADDR         addr;

    EnterCriticalSection(&csThreadProcList);

    /*
     * Pre-translate the address to a linear address
     */

    addr = *paddr;
    TranslateAddress(hprc, hthd, &addr, TRUE);

    //
    // Check for an equivalent breakpoint.  Breakpoints will be equal if
    //
    //  1.  The process must be the same
    //  2.  The BP type must be the same
    //  3.  a) if it is an exec BP the addresses must match
    //      b) if not, MatchWalk is called
    //  4.  The thread and notify types must match if fExact is specified
    //

    for (pbp=bpList->next; pbp; pbp=pbp->next) {
        if ((pbp->hprc == hprc) && (bptype == pbp->bpType)) {
            if (bptype == bptpExec && AreAddrsEqual(hprc, hthd, &pbp->addr, &addr)) {

                //
                // if it matches exactly, take it now.
                // if not, take it if it is better than the
                // previous partial match
                //

                if (hthd == pbp->hthd && bpnotify == pbp->bpNotify) {
                    pbpFound = pbp;
                    break;
                }

                if (!pbpFound) {
                    //
                    // any match is better than none
                    //

                    pbpFound = pbp;

                } else if (pbp->hthd == NULL || pbp->hthd == hthd) {
                    //
                    // this thread matches:
                    //   is it better than the one we had?
                    //
                    if (hthd != pbpFound->hthd) {
                        pbpFound = pbp;
                    } else if (bpnotify == pbp->bpNotify && bpnotify != pbpFound->bpNotify) {
                        pbpFound = pbp;
                    } else if ((bpnotify == (BPNS)-1) &&
                            BPPriorityIsGreater(pbp->bpNotify, pbpFound->bpNotify)) {
                        pbpFound = pbp;
                    }
                }
            }
        }
    }

    LeaveCriticalSection(&csThreadProcList);

    if (!fExact || (
            pbpFound &&
            (pbpFound->hthd == hthd) &&
            (pbpFound->bpNotify == bpnotify) ) )
    {
        return pbpFound;
    } else {
        return NULL;
    }
}                               /* FindBP() */

#endif

PBREAKPOINT
FindBP(
    HPRCX    hprc,
    HTHDX    hthd,
    BPTP     bptype,
    BPNS     bpnotify,
    LPADDR   paddr,
    BOOL     fExact
    )
/*++

Routine Description:

    Find and return a pointer to a BP struct.

    This is called for the following cases:

    1) A breakpoint has been hit, and we want to find a BP record for it.
       In this case, we want to see the highest priority match, with
       preference to the correct thread.

       Call with bpnotify == -1, hthd == xxxx, fExact == FALSE

    2) We want to step off/through a BP.  Any match will do, we just need
       the instruction.

       Call with bpnotify == -1, hthd == 0, fExact == FALSE

    3) We want to delete a BP.  Everything must match exactly.  (It would
       be better to do this directly by the pointer to the BP, but the
       shells do not support this properly.)

       Call with bpnotify == bpnsXXXX, hthd == xxxx, fExact == TRUE
       (N.B. hthd may be NULL, which means "any thread")

    Always returns a BP that matches hthd and bpnotify if one exists; if
    fExact is FALSE and there is no exact match, a BP matching only hprc
    and address will succeed.


Arguments:

    hprc   - Supplies process

    hthd   - Supplies thread

    bptype - Supplies OSDEBUG BP type

    bpnotify -

    paddr  - Supplies address

    fExact - Supplies TRUE if must be for a certain thread

Return Value:

    pointer to BREAKPOINT struct, or NULL if none found.

--*/
{
    PBREAKPOINT  pbp;
    PBREAKPOINT  pbpFound = NULL;
    ADDR         addr;

    EnterCriticalSection(&csThreadProcList);

    /*
     * Pre-translate the address to a linear address
     */

    addr = *paddr;
    TranslateAddress(hprc, hthd, &addr, TRUE);

    //
    // Check for an equivalent breakpoint.  Breakpoints will be equal if
    //
    //  1.  The process must be the same
    //  2.  The BP type must be the same
    //  3.  a) if it is an exec BP the addresses must match
    //      b) if it is a message BP, the addresses must match
    //      c) other BP types are not supported at this time
    //  4.  The thread and notify types must match if fExact is specified
    //

    for (pbp=bpList->next; pbp; pbp=pbp->next)
    {
        if ((pbp->hprc == hprc) && (bptype == pbp->bpType))
        {
            switch (bptype) {
            
                case bptpMessage:
                case bptpExec:

                    if (AreAddrsEqual(hprc, hthd, &pbp->addr, &addr))
                    {
                        //
                        // if it matches exactly, take it now.
                        // if not, take it if it is better than the
                        // previous partial match
                        //

                        if (hthd == pbp->hthd && bpnotify == pbp->bpNotify) {
                            pbpFound = pbp;
                            goto out_of_loop;
                        }

                        if (!pbpFound) {

                            //
                            // any match is better than none
                            //

                            pbpFound = pbp;

                        } else if (pbp->hthd == NULL || pbp->hthd == hthd) {

                            //
                            // this thread matches:
                            //   is it better than the one we had?
                            //

                            if (hthd != pbpFound->hthd)
                            {
                                pbpFound = pbp;
                            }
                            else if (bpnotify == pbp->bpNotify &&
                                     bpnotify != pbpFound->bpNotify)
                            {
                                pbpFound = pbp;
                            }
                            else if ((bpnotify == (BPNS)-1) &&
                                     BPPriorityIsGreater (pbp->bpNotify,
                                                          pbpFound->bpNotify)
                                    )
                            {
                                pbpFound = pbp;
                            }
                        }
                    }

                break;

                default:

                    // At this time FindBP () only supports types Message and
                    // exec.  Add your matching code this this switch stmt.
                    
                    assert (FALSE);
            }
        }
    }

out_of_loop:

    LeaveCriticalSection(&csThreadProcList);

    if (!fExact || (
            pbpFound &&
            (pbpFound->hthd == hthd) &&
            (pbpFound->bpNotify == bpnotify) ) )
    {
        return pbpFound;
    } else {
        return NULL;
    }
}                               /* FindBP() */


PBREAKPOINT
BPNextHprcPbp(
    HPRCX        hprc,
    PBREAKPOINT  pbp
    )

/*++

Routine Description:

    Find the next breakpoint for the given process after pbp.
    If pbp is NULL start at the front of the list, for a find
    first, find next behaviour.


Arguments:

    hprc    - Supplies the process handle to match breakpoints for

    pbp     - Supplies pointer to breakpoint item to start searching after

Return Value:

    NULL if no matching breakpoint is found else a pointer to the
    matching breakpoint

--*/

{
    EnterCriticalSection(&csThreadProcList);
    if (pbp == NULL) {
        pbp = bpList->next;
    } else {
        pbp = pbp->next;
    }

    for ( ; pbp; pbp = pbp->next ) {
        if (pbp->hprc == hprc) {
            break;
        }
    }
    LeaveCriticalSection(&csThreadProcList);

    return pbp;
}                               /* BPNextHprcPbp() */


PBREAKPOINT
BPNextHthdPbp(
    HTHDX        hthd,
    PBREAKPOINT  pbp
    )
/*++

Routine Description:

    Find the next breakpoint for the given thread after pbp.
    If pbp is NULL start at the front of the list for find
    first, find next behaviour.

Arguments:

    hthd    - Supplies the thread handle to match breakpoints for

    pbp     - Supplies pointer to breakpoint item to start searching after

Return Value:

    NULL if no matching breakpoint is found else a pointer to the
    matching breakpoint

--*/

{
    EnterCriticalSection(&csThreadProcList);

    if (pbp == NULL) {
        pbp = bpList->next;
    } else {
        pbp = pbp->next;
    }

    for ( ; pbp; pbp = pbp->next ) {
        if (pbp->hthd == hthd) {
            break;
        }
    }

    LeaveCriticalSection(&csThreadProcList);

    return pbp;
}                               /* BPNextHthdPbp() */


void ReleaseBP(PBREAKPOINT pbp)
{
    EnterCriticalSection(&csThreadProcList);
    /* If we have refcount problems, we could get to a state where we're
     * releasing the last thread ref but this breakpoint still has an
     * instance count (this would be because we forgot to inc the thread
     * ref count somewhere).  We attempt to recovery gracefully from that by
     * prohibiting a final release if the instance count is nonzero.  We know
     * the bp will get freed eventually when its instance count finally drops
     * to zero */
    if(pbp && pbp != EMBEDDED_BP && 0 == --pbp->cthd) {
        if(0 == pbp->instances)
            MHFree(pbp);
        else
            /* Whoops */
            ++pbp->cthd;
    }
    LeaveCriticalSection(&csThreadProcList);
}


BOOL
RemoveBPHelper(
    PBREAKPOINT pbp,
    BOOL        fRestore
    )
{
    PBREAKPOINT         pbpPrev;
    PBREAKPOINT         pbpCur;
    PBREAKPOINT         pbpT;
    HTHDX               hthd;
    BOOL                rVal = FALSE;


    //
    // first, is it real?
    //
    if (!pbp || pbp == EMBEDDED_BP) {
        return FALSE;
    }

    EnterCriticalSection(&csThreadProcList);

    /* Decrement the instances counter      */
    if (--pbp->instances) {

        /*
         * BUGBUG:  jimsch -- Feb 29 1993
         *    This piece of code is most likely incorrect.  We need to
         *      know if we are the DM freeing a breakpoint or the user
         *      freeing a breakpoint before we clear the step bit.  Otherwise
         *      we may be in the following situation
         *
         *      Set a thread specific breakpoint on an address
         *      Step the thread so that the address is the destination is
         *              where the step ends up (but it takes some time such
         *              as over a function call)
         *      Clear the thread specific breakpoint
         *
         *      This will cause the step breakpoint to be cleared so we will
         *      stop at the address instead of just continuing stepping.
         */
// v-vadimp - on Alpha in the case of a watchpoint we can have isStep == 2
// presumably because a single step breakpoint gets reused in this case
// and the old berakpoint's isStep is incremented (in SetupSingleStep())
#if defined(TARGET_ALPHA)  
        pbp->isStep--;
#else if
        pbp->isStep = FALSE;
#endif
        LeaveCriticalSection(&csThreadProcList);
        return FALSE;
    }

    /* Search the list for the specified breakpoint */


    for (   pbpPrev = bpList, pbpCur = bpList->next;
            pbpCur;
            pbpPrev = pbpCur, pbpCur = pbpCur->next) {

        if (pbpCur == pbp)  {

            /*
             * Remove this bp from the list:
             */

            pbpPrev->next = pbpCur->next;

            //
            // pbpT will be used later to replace atBP
            // in any thread which happens to be sitting
            // on the BP which we are removing.
            //
            if (pbpCur->bpType != bptpExec && pbpCur->bpType != bptpMessage) {

                pbpT = NULL;

            } else {
                //
                // see if there is another bp on the same address:
                //

                pbpT = FindBP(pbpCur->hprc,
                              pbpCur->hthd,
                              pbpCur->bpType,
                              (BPNS)-1,
                              &pbpCur->addr,
                              FALSE);

                if (!pbpT && (pbpCur->bpType == bptpExec ||
                        pbpCur->bpType == bptpMessage))
                {
                    //
                    // if this was the only one, put the
                    // opcode back where it belongs.
                    //

                    if ( fRestore ) {
                        RestoreBreakPoint( pbpCur );
                    }
                }
            }

            if (pbpCur->hWalk) {
                RemoveWalk(pbpCur->hWalk, pbpCur->hthd == NULL);
            }

            //
            // Now we have to go through all the threads to see
            // if any of them are on this breakpoint and clear
            // the breakpoint indicator on these threads
            //

            //
            // Could be on any thread:
            //

            //
            // (We are already in the ThreadProcList critical section)
            //

            for (hthd = thdList->next; hthd; hthd = hthd->next) {
                if (hthd->atBP == pbpCur) {
                    SetBPFlag(hthd, pbpT);
                }
            }

            ReleaseBP(pbpCur);
            rVal = TRUE;
            break;
        }

    }

    LeaveCriticalSection(&csThreadProcList);

    return rVal;

}


BOOL
RemoveAllHprcBP(
    HPRCX hprc
    )
{
    PBREAKPOINT pbp, pbpT;

    for (pbp = BPNextHprcPbp(hprc, NULL); pbp; pbp = pbpT) {
        BYTE count = pbp->instances;
        pbpT = BPNextHprcPbp(hprc, pbp);
        while (count--) {
            RemoveBPHelper(pbp, TRUE);
        }
    }

    // All bps for this process should be cleared. 
    assert(BPNextHprcPbp(hprc,NULL) == NULL);

    return TRUE;
}


BOOL
RemoveBP(
    PBREAKPOINT pbp
    )
{
    return RemoveBPHelper( pbp, TRUE );
}

#ifdef KERNEL

BOOL
RemoveBPEx(
    DWORD       Count,
    PBREAKPOINT *Bps
    )
{

    PDBGKD_RESTORE_BREAKPOINT   DbgKdBp;
    DWORD                       RestoreCount = 0;
    DWORD                       GoneCount    = 0;
    DWORD                       i;
    PBREAKPOINT                 BpCur;
    PBREAKPOINT                 BpOther;

    assert( Count > 0 );

    if ( Count == 1 ) {
        //
        //  Only one breakpoint, its faster to simply call RemoveBP
        //
        return RemoveBP( Bps[0] );
    }

    EnterCriticalSection(&csThreadProcList);

    DbgKdBp = (PDBGKD_RESTORE_BREAKPOINT)MHAlloc( sizeof(DBGKD_RESTORE_BREAKPOINT) * Count );
    assert( DbgKdBp );

    if ( DbgKdBp ) {

        //
        //  Find out what breakpoints we have to restore and put them in
        //  the list.
        //
        for ( i=0; i<Count;i++ ) {

            assert( Bps[i] != EMBEDDED_BP );

            for (   BpCur = bpList->next; BpCur; BpCur = BpCur->next) {

                if ( BpCur == Bps[i] )  {

                    //
                    // See if there is another bp on the same address.
                    //
                    for ( BpOther = bpList->next; BpOther; BpOther = BpOther->next ) {
                        if ( (BpOther != BpCur) &&
                             AreAddrsEqual( BpCur->hprc, BpCur->hthd, &BpCur->addr, &BpOther->addr ) ) {
                            break;
                        }
                    }

                    if ( !BpOther ) {
                        //
                        // If this was the only one, put it in the list.
                        //
                        DbgKdBp[GoneCount++].BreakPointHandle = Bps[i]->hBreakPoint;
                    }

                    break;
                }
            }
        }

        //
        //  Restore the breakpoints in the list.
        //
        if ( GoneCount > 0 ) {
            assert( GoneCount <= Count );
            RestoreBreakPointEx( GoneCount, DbgKdBp );
        }

        //
        //  All breakpoints that were to be restored have been
        //  restored, now go ahead and do the cleaning up stuff.
        //
        for ( i=0; i<Count;i++ ) {
            RemoveBPHelper( Bps[i], FALSE );
            RestoreCount++;
        }

        MHFree( DbgKdBp );
    }

    LeaveCriticalSection(&csThreadProcList);

    return ( RestoreCount == Count );
}

#else // KERNEL

BOOL
RemoveBPEx(
    DWORD       Count,
    PBREAKPOINT *Bps
    )
{

    DWORD                       i;

    assert( Count > 0 );

        for ( i=0; i<Count;i++ ) {

        RemoveBPHelper( Bps[i], TRUE );
    }

    return TRUE;
}

#endif // KERNEL


void
SetBPFlag(
    HTHDX hthd,
    PBREAKPOINT bp
    )
{
    EnterCriticalSection(&csThreadProcList);
    ReleaseBP(hthd->atBP);
    hthd->atBP = bp;
    if(bp && bp != EMBEDDED_BP)
        ++bp->cthd;
    LeaveCriticalSection(&csThreadProcList);
}



PBREAKPOINT
AtBP(
    HTHDX hthd
    )
{
    return hthd->atBP;
}




void
ClearBPFlag(
    HTHDX hthd
    )
{
    SetBPFlag(hthd, NULL);
}



void
RestoreInstrBP(
    HTHDX            hthd,
    PBREAKPOINT      bp
    )
/*++

Routine Description:

    Replace the instruction for a breakpoint.  If it was not
    the debugger's BP, skip the IP past it.

Arguments:

    hthd -  Thread

    bp   -  breakpoint data

Return Value:


--*/
{
    //
    // Check if this is an embedded breakpoint
    //

    if (bp == EMBEDDED_BP) {

        //
        // It was, so there is no instruction to restore,
        // just increment the EIP
        //

        IncrementIP(hthd);
        return;
    }

    if (bp->hWalk) {

        //
        // This is really a hardware breakpoint.  Let the
        // walk manager fix this.
        //

        ExprBPClearBPForStep(hthd);

    } else {

        //
        // Replace the breakpoint current in memory with the correct
        // instruction
        //

        RestoreBreakPoint( bp );
        bp->hBreakPoint = 0;

    }

    return;
}


VOID
DeleteAllBps(
    VOID
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PBREAKPOINT pbp, bpn;

    EnterCriticalSection(&csThreadProcList);

    pbp = bpList->next;

    while (pbp) {
        bpn = pbp->next;
        if (bpn) {
            MHFree( pbp );
        }
        pbp = bpn;
    }

    bpList->next = NULL;
    bpList->hprc = NULL;

    LeaveCriticalSection(&csThreadProcList);
}

void
AddBpToList(
    PBREAKPOINT pbp
    )
{
    assert(bpList);
    EnterCriticalSection(&csThreadProcList);
    pbp->next    = bpList->next;
    bpList->next = pbp;
    LeaveCriticalSection(&csThreadProcList);
}

PBREAKPOINT
SetWP(
    HPRCX   hprc,
    HTHDX   hthd,
    BPTP    bptype,
    BPNS    bpnotify,
    ADDR    addr
    )
{
    return (PBREAKPOINT)0;
}

#if DBG

char*
BpTypes [] = {
    "bptpExec",
    "bptpDataC",
    "bptpDataW",
    "bptpDataR",
    "bptpDataExec",
    "bptpRegC",
    "bptpRegW",
    "bptpRegR",
    "bptpMessage",
    "bptpMClass",
    "bptpInt",
    "bptpRange"
};

//  Walk      hthd      Type   GC  LC  Strt/Adr  Stop/Cnt  Reg  Contents\n

//
// *00004444  03333333  RangeC   1  Cont  0123345add  00000000  0xffffffff  


VOID
DumpBpHeader(
    )
{
    DebugPrint ("  Bp        hthd      Type   Cnt  Ntfy  Addr/Walk EmId      Instr\n");
}

char*
BpTypeToStr(
    BPTP
    );

#define XX(_bpns) case bpns##_bpns: return #_bpns

CHAR*
BpNotifyToStr(
    BPNS    bpns
    )
{
    switch (bpns) {

        XX (Stop);
        XX (Continue);
        XX (Check);

        default: return "Err";
    }

    return "Err";
}

#undef XX

VOID
DumpBp(
    PBREAKPOINT bp
    )
{

    if (bp == NULL) {
        DebugPrint ("<Invalid bp == NULL>\n");
        return;
    }
        
    DebugPrint (" %c%08x  %08x  %5.5s  %3d  %4.4s  %08x  %-8x\n",
                    bp->isStep ? '*' : ' ',
                    bp,
                    bp->hthd,
                    BpTypeToStr (bp->bpType),
                    bp->instances,
                    BpNotifyToStr (bp->bpNotify),
                    bp->hWalk ? bp->hWalk : (HANDLE) bp->addr.addr.off,
                    bp->id);
}
                    
                    

    
VOID
DumpBps(
    )
{
    BREAKPOINT* bp;

    DebugPrint ("\n");
    DumpBpHeader ();

    for (bp = bpList->next; bp; bp = bp->next) {
        DumpBp (bp);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\debug.h ===
#define PPDBFromPid(x) (PDB*)x  // Take these out when the kernel function
                // is written
#define PTDBFromTid(x) (TDB*)x

#define PidFromPPDB(x)      (PID)x

#define TidFromPTDB(x)      (TID)x


//typedef   PDB *           PID;
//typedef   TDB *           TID;

typedef enum    {
    DBERR_NO_ERROR  = 0,
    DBERR_PROCESS_CREATION,
    DBERR_THREAD_CREATION,
    DBERR_BAD_ACCESS
} DB_ERRORS;


typedef enum        {
    ACCESS_READ = 0x01,
    ACCESS_WRITE    = 0x02,
    ACCESS_EXECUTE  = 0x04
} DW_DESIRED_ACCESS;

#define EVENT_UNION_SIZE    sizeof(EVENT_UNION)

typedef struct  rq {
    struct  rq      *next;
    struct  rq      *prev;
    TID thread;
}   RUNQUEUE;


void PrintDebug(void);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\shxbox\osdebug\shinit.cpp ===
//  shinit
//
//  Copyright <C> 1990-94, Microsoft Corporation
//
//      [00] 31-dec-91 DavidGra
//          Add SHFindSymbol API for assembler symbol handling.
//
//      10-Nov-94   BryanT
//          Merge in NT changes.
//          Remove SHF ifdef's, remove non-Win32 hosting, remove FAR/NEAR/PASCAL.
//          Replace SHCritxxx calls with native CritSec calls.
//          Initialize the SymCvt pointers.
//          Use the DBG version macros if NT_BUILD
//          Add the background symbol support, but leave it under if 0 for now.

#include "shinc.hpp"
#pragma hdrstop
#include "version.h"


CRITICAL_SECTION    csSh;   // Global CritSec used for MT safe.
KNF                 knf;    // Kernel functions (init to zero by the loader)
//HMODULE             hLib;   // Handle returned from LoadLibrary on symcvt symcvt
CONVERTPROC         pfConvertSymbolsForImage; // Symcvt ptr.

#ifndef ACTIVEDBG

static SHF shf = {
    sizeof(SHF),
    SHCreateProcess,
    SHSetHpid,
    SHDeleteProcess,
    SHChangeProcess,
    SHAddDll,
    SHAddDllsToProcess,
    SHLoadDll,
    SHUnloadDll,
    SHGetDebugStart,
    SHGetSymName,
    SHAddrFromHsym,
    SHHmodGetNextGlobal,
    SHModelFromAddr,
    SHPublicNameToAddr,
    SHGetSymbol,
    PHGetAddr,
    SHIsLabel,

    SHSetDebuggeeDir,
    SHAddrToLabel,

    SHGetSymLoc,
    SHFIsAddrNonVirtual,
    SHIsFarProc,

    SHGetNextExe,
    SHHexeFromHmod,
    SHGetNextMod,
    SHGetCxtFromHmod,
    SHSetCxt,
    SHSetCxtMod,
    SHFindNameInGlobal,
    SHFindNameInContext,
    SHGoToParent,
    SHHsymFromPcxt,
    SHNextHsym,
    NULL,                       // SHGetFuncCXF
    SHGetModName,
    SHGetExeName,
    SHGethExeFromName,
    SHGetNearestHsym,
    SHIsInProlog,
    SHIsAddrInCxt,
    SHCompareRE,                // SHCompareRE
    SHFindSymbol,
    PHGetNearestHsym,
    PHFindNameInPublics,
    THGetTypeFromIndex,
    THGetNextType,
    SHLpGSNGetTable,
    SHCanDisplay,

    // Source Line Handler API

    SLLineFromAddr,
    SLFLineToAddr,
    SLNameFromHsf,
    SLNameFromHmod,
    SLFQueryModSrc,
    NULL,
    SLHsfFromPcxt,
    SLHsfFromFile,
    SLCAddrFromLine,
    SHFree,
    SHUnloadSymbolHandler,
    SHGetExeTimeStamp,
    SHPdbNameFromExe,
    SHGetDebugData,
    SHIsThunk,
    SHFindSymInExe,
    SHFindSLink32,
    SHIsEmiLoaded,

// Entries added for NT work.

    SHGetModule,
    SHGetCxtFromHexe,
    SHGetModNameFromHexe,
    SHGetSymFName,
    SHGethExeFromModuleName,
    SHLszGetErrorText,
    SHWantSymbols,
	SHFindNameInTypes,
#if CC_LAZYTYPES
    THAreTypesEqual,
#endif
	SHLoadDllEx,
    
    SHGetSrcPath,
    SHGetObjPath,
    SHGetCompileEnv,
    SHModSupportsEC,
    SHExeSupportsEC,
    SHModLinkedFromLib,

    SHModFromHmod,
    SHFlushModSyms,
    SHUseAltPdb
};
#endif

VOID
SHFree(
    LPV lpv
    )
{
    MHFree (lpv);
}

#ifndef ACTIVEDBG

BOOL
SHInit(
    LPSHF  *lplpshf,
    LPKNF   lpknf
    )
{
	// lpknf is allowed to be NULL on 2nd and subsequent calls
	if (lpknf!=NULL)
	{
		assert( lpknf->cb == sizeof(KNF) );

		knf = *lpknf;
	}
	else
	{
		assert( knf.cb==sizeof(KNF) );		// make sure been here before
	    *lplpshf = &shf;
		return TRUE;						// don't init twice
	}


    *lplpshf = &shf;

    // Initialize symbol convert pointers.
#if 0
#ifdef _DEBUG
    hLib = LoadLibrary( "vcsymcvtd.dll" );
#else
    hLib = LoadLibrary( "vcsymcvt.dll" );
#endif
    if (hLib != NULL) {
        pfConvertSymbolsForImage = (CONVERTPROC) GetProcAddress( hLib, "ConvertSymbolsForImage2" );
    }
#else
	pfConvertSymbolsForImage = ConvertSymbolsForImage2;
#endif

    InitializeCriticalSection(&csSh);


#if 0
    // initialize synchronization objects used by background sym loader.

    InitializeCriticalSection( &CsSymbolLoad );
    InitializeCriticalSection( &CsSymbolProcess );
    hEventLoaded = CreateEvent( NULL, FALSE, FALSE, NULL );
#endif

    return FInitLists();
}
#endif

#if defined(DEBUGVER)
DEBUG_VERSION('S','H',"Debug Symbolics handler")
#else
RELEASE_VERSION('S','H',"Debug Symbolics handler")
#endif

DBGVERSIONCHECK();
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\dmdisasm.c ===
/**** DMDISASM.C - EM Lego disassembler interface                          *
 *                                                                         *
 *                                                                         *
 *  Copyright <C> 1995, Microsoft Corp                                     *
 *                                                                         *
 *  Created: January 1, 1996 by Kent Forschmiedt
 *                                                                         *
 *  Revision History:                                                      *
 *                                                                         *
 *                                                                         *
 *                                                                         *
 ***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <simpldis.h>


#define MAXL     20
#define CCHMAX   256

#if defined(TARGET_i386)
#define SIMPLE_ARCH_CURRENT Simple_Arch_X86
#elif defined(TARGET_MIPS)
#define SIMPLE_ARCH_CURRENT Simple_Arch_Mips
#elif defined(TARGET_ALPHA)
#define SIMPLE_ARCH_CURRENT Simple_Arch_AlphaAxp
#elif defined(TARGET_PPC)
#define SIMPLE_ARCH_CURRENT Simple_Arch_PowerPc
#else
#error "Undefined processor"
#endif


int
CvRegFromSimpleReg(
    MPT     mpt,
    int     regInstr
    )
{
    switch (mpt) {
    case mptix86:
        switch(regInstr) {
            case SimpleRegEax: return CV_REG_EAX;
            case SimpleRegEcx: return CV_REG_ECX;
            case SimpleRegEdx: return CV_REG_EDX;
            case SimpleRegEbx: return CV_REG_EBX;
            case SimpleRegEsp: return CV_REG_ESP;
            case SimpleRegEbp: return CV_REG_EBP;
            case SimpleRegEsi: return CV_REG_ESI;
            case SimpleRegEdi: return CV_REG_EDI;
        }
        break;

    case mptmips:
        return (regInstr + CV_M4_IntZERO);

    case mptdaxp:
        return (regInstr + CV_ALPHA_IntV0);

    case mptmppc:
        return (regInstr + CV_PPC_GPR0);

    }
    return (0);
}




#if 0
ULONGLONG
QwGetreg(
    PVOID   pv,
    int     regInstr
    )
{
    HTHDX       hthdx = (HTHDX)pv;
    XOSD        xosd;
    ULONGLONG   retVal;

	_asm int 3
	EnsureHthdReg(hthdx, CONTEXT_FULL | CONTEXT_FLOATING_POINT);
    retVal = GetRegValue(&hthdx->ctx,
                         CvRegFromSimpleReg(MPT_CURRENT, regInstr)
                         );

    return retVal;
}

XOSD
disasm (
    HTHDX  hthd,
    LPSDI  lpsdi,
    PVOID  Memory,
    int    Size
    )
{
    XOSD        xosd      = xosdNone;
    int         cbUsed;
    int         Bytes;
    SIMPLEDIS   Sdis;

    Bytes = SimplyDisassemble(
        Memory,                    // code ptr
        Size,                      // bytes
        GetAddrOff(lpsdi->addr),
        SIMPLE_ARCH_CURRENT,
        &Sdis,
        NULL,
        NULL,
        NULL,
        QwGetreg,
        (PVOID)hthd
        );

    if (Bytes < 0) {
        cbUsed = -Bytes;
        xosd = xosdGeneral;
    } else {
        cbUsed = Bytes;
    }

    return xosd;
}

DWORD
BranchUnassemble(
    HTHDX   hthd,
    PVOID   Memory,
    DWORD   Size,
    LPADDR  Addr,
    BOOL   *IsBranch,
    BOOL   *TargetKnown,
    BOOL   *IsCall,
    BOOL   *IsTable,
    LPADDR  Target
    )
{
    int         cbUsed;
    int         Bytes;
    SIMPLEDIS   Sdis;
    DWORD       dwTarget = 0;


    Bytes = SimplyDisassemble(
        Memory,                    // code ptr
        Size,                      // bytes
        GetAddrOff(*Addr),
        SIMPLE_ARCH_CURRENT,
        &Sdis,
        NULL,
        NULL,
        NULL,
        QwGetreg,
        (PVOID)hthd
        );

    if (Bytes < 0) {
        *IsBranch = FALSE;
        *IsTable = FALSE;
        *IsCall = FALSE;
        *TargetKnown = FALSE;
        return 0;
    }

    *IsBranch = Sdis.IsBranch;
    *IsCall = Sdis.IsCall;
    *IsTable = FALSE;

    if (*IsBranch) {
        //
        // when do we know the branch target, and when do we not?
        //
        if (Sdis.dwJumpTable) {
            *IsTable = TRUE;
            dwTarget = Sdis.dwJumpTable;
        } else {
            *IsTable = FALSE;
            dwTarget = Sdis.dwBranchTarget;
        }
    }

    if (*IsCall) {
        *IsCall = TRUE;
        dwTarget = Sdis.dwBranchTarget;
    }

    *TargetKnown = !!dwTarget;

    if (*TargetKnown) {
        AddrInit( Target, 0, 0, dwTarget, TRUE, TRUE, FALSE, FALSE );
    }

    return Bytes;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\debugger\tlxbox\dm.h ===
#ifdef __cplusplus
extern "C" {
#endif

XOSD AttachOrReboot(void);

//
// Forward Declarations

typedef struct _OLERG *POLERG;
typedef struct _OLERET *POLERET;

struct _HPRCX;
typedef struct _HPRCX* HPRCX;

struct _HTHDX;




#define _tsizeof(str) (sizeof(str)/sizeof(TCHAR))

#define DONT_NOTIFY     ((METHOD*)0)

#define NO_ACTION       ((ACVECTOR)0)

#define INVALID         (-1L)

#define NO_SUBCLASS     ((DWORD)(-1L))

#define DWORDLONG ULONGLONG

// WaitForDebugEvent() timeout, milliseconds
#define WAITFORDEBUG_MS (50L)

// Wait for loader breakpoint timeout sec * ticks/sec
#define LDRBP_MAXTICKS  (60L * 1000L/WAITFORDEBUG_MS)

#define SetFile()

#ifndef XBOX
extern DBF *lpdbf;
#endif


#ifndef KERNEL

//extern BOOL CrashDump;

#endif

void UserTimerStop();
void UserTimerGo();

#if defined(TARGET_i386)

#if 0
#define PC(x)               ((x)->context.Eip)
#define cPC(x)              ((x)->Eip)
#define STACK_POINTER(x)    ((x)->context.Esp)
#define FRAME_POINTER(x)    ((x)->context.Ebp)
#define PcSegOfHthdx(x)     ((SEGMENT) (x->context.SegCs))
#define SsSegOfHthdx(x)     ((SEGMENT) (x->context.SegSs))
#endif
#define PC(x)               (HthdReg(x,Eip))
#define cPC(x)              ((x)->Eip)
#define STACK_POINTER(x)    (HthdReg(x,Esp))
#define FRAME_POINTER(x)    (HthdReg(x,Ebp))
#define PcSegOfHthdx(x)     ((SEGMENT) HthdReg(x,SegCs))
#define SsSegOfHthdx(x)     ((SEGMENT) HthdReg(x,SegSs))

#define MPT_CURRENT mptix86

#elif defined (TARGET_MIPS)

#define PC(x)               ((x)->context.XFir)
#define cPC(x)              ((x)->XFir)
#define STACK_POINTER(x)    ((x)->context.XIntSp)
#define FRAME_POINTER(x)    ((x)->context.XIntSp)
#define PcSegOfHthdx(x)     (0)
#define SsSegOfHthdx(x)     (0)

#define MPT_CURRENT mptmips

// Define MIPS nonvolatile register test macros. */
//

#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)

#include <mipsinst.h> // get all mips opcodes and associated cruft


//
//
// Define stack register and zero register numbers.
//

#define RA 0x1f                 /* integer register 31 */
#define SP 0x1d                 /* integer register 29 */
#define ZERO 0x0                /* integer register 0 */

//
// Define saved register masks. */
//

#define SAVED_FLOATING_MASK 0xfff00000 /* saved floating registers */
#define SAVED_INTEGER_MASK 0xf3ffff02 /* saved integer registers */


typedef union instr {
    ULONG   instruction;
    struct _jump_instr {
        ULONG   Target  : 26;
        ULONG   Opcode  : 6;
    } jump_instr;
    struct _trap_instr {
        ULONG   Opcode  : 6;
        ULONG   Value   : 10;
        ULONG   RT      : 5;
        ULONG   RS      : 5;
        ULONG   Special : 6;
    } trap_instr;
    struct _immed_instr {
        ULONG   Value   : 16;
        ULONG   RT      : 5;
        ULONG   RS      : 5;
        ULONG   Opcode  : 6;
    } immed_instr;
    struct _special_instr {
        ULONG   Funct   : 6;
        ULONG   RE      : 5;
        ULONG   RD      : 5;
        ULONG   RT      : 5;
        ULONG   RS      : 5;
        ULONG   Opcode  : 6;
    } special_instr;
    struct _float_instr {
        ULONG   Funct   : 6;
        ULONG   FD      : 5;
        ULONG   FS      : 5;
        ULONG   FT      : 5;
        ULONG   Format  : 5;
        ULONG   Opcode  : 6;
    } float_instr;
    struct {
        ULONG Function  : 6;
        ULONG Unused    : 10;
        ULONG Code      : 10;
        ULONG Opcode    : 6;
    } break_instr;
} INSTR, *PINSTR;

#elif defined (TARGET_PPC)

#define PC(x)               ((x)->context.Iar)
#define cPC(x)              ((x)->Iar)
#define STACK_POINTER(x)    ((x)->context.Gpr1)
#define FRAME_POINTER(x)    ((x)->context.Gpr1)

#define PcSegOfHthdx(x)     (0)
#define SsSegOfHthdx(x)     (0)

#define MPT_CURRENT mptmppc

#define GetThreadContext PPCGetThreadContext
#define SetThreadContext PPCSetThreadContext
BOOL
PPCGetThreadContext(
    HANDLE   hThread,
    PCONTEXT PRegContext
    );
BOOL
PPCSetThreadContext(
    HANDLE   hThread,
    PCONTEXT PRegContext
    );


//
// Define PPC nonvolatile register test macros. */
//

//#define IS_FLOATING_SAVED(Register) ((SAVED_FLOATING_MASK >> Register) & 1L)
//#define IS_INTEGER_SAVED(Register) ((SAVED_INTEGER_MASK >> Register) & 1L)

#include <ppcinst.h> // get all ppc opcodes and associated cruft


//
// Define saved register masks. */
//

//#define SAVED_FLOATING_MASK 0xffffc000 /* saved floating registers */
//#define SAVED_INTEGER_MASK 0xffffe000  /* saved integer registers */



// This comes straight from ppcinst.h
typedef PPC_INSTRUCTION INSTR;

#elif defined (TARGET_ALPHA)

#include "alphaops.h"
#include "ctxptrs.h"


#define PC(x)               ((DWORD)((x)->context.Fir))
#define cPC(x)              ((DWORD)((x)->Fir))
#define STACK_POINTER(x)    ((DWORD)((x)->context.IntSp))
#define FRAME_POINTER(x)    ((DWORD)((x)->context.IntSp))

#define PcSegOfHthdx(x)         (0)
#define SsSegOfHthdx(x)         (0)

#define MPT_CURRENT mptdaxp

#else

#error "Undefined processor"

#endif


//
// Breakpoint stuff
//

#if defined(TARGET_i386)

typedef BYTE BP_UNIT;
#define BP_OPCODE   0xCC
#define DELAYED_BRANCH_SLOT_SIZE    0


#define HAS_DEBUG_REGS
// #undef NO_TRACE_FLAG

#define NUMBER_OF_DEBUG_REGISTERS   4
#define DEBUG_REG_DATA_SIZES        { 1, 2, 4 }
#define MAX_DEBUG_REG_DATA_SIZE     4
#define DEBUG_REG_LENGTH_MASKS      {   \
                            0xffffffff,          \
                            0,          \
                            1,          \
                            0Xffffffff, \
                            3           \
                            }


#define TF_BIT_MASK 0x00000100  /* This is the right bit map for */
/* the 286, make sure its correct */
/* for the 386. */

#elif defined(TARGET_PPC)

typedef DWORD BP_UNIT;
#define BP_OPCODE   0x0FE00016 // twi 31,0,DEBUG_STOP_BREAKPOINT
#define PPC_KERNEL_BREAKIN_OPCODE 0x0fe00002
#define DELAYED_BRANCH_SLOT_SIZE    0

#define HAS_DEBUG_REGS
#define NO_TRACE_FLAG

#define NUMBER_OF_DEBUG_REGISTERS   1
#define DEBUG_REG_DATA_SIZES        { 8 }
#define MAX_DEBUG_REG_DATA_SIZE     8
#define DEBUG_REG_LENGTH_MASKS      {   \
                            0,          \
                            0xffffffff, \
                            0xffffffff, \
                            0xffffffff, \
                            0xffffffff, \
                            0xffffffff, \
                            0xffffffff, \
                            0xffffffff, \
                            3           \
                            }

#elif defined(TARGET_MIPS)

typedef DWORD BP_UNIT;
#define BP_OPCODE   0x0016000D
#define DELAYED_BRANCH_SLOT_SIZE    (sizeof(DWORD))

// #undef HAS_DEBUG_REGS
#define NO_TRACE_FLAG

#elif defined(TARGET_ALPHA)

typedef DWORD BP_UNIT;
#define BP_OPCODE   0x80L
#define DELAYED_BRANCH_SLOT_SIZE    0

// #undef HAS_DEBUG_REGS
#define NO_TRACE_FLAG

#else

#error "Unknown target CPU"

#endif

//
// constant from windbgkd.h:
//
#define MAX_KD_BPS  BREAKPOINT_TABLE_SIZE
//
// machine-dependent BP instruction size
//

#define BP_SIZE     sizeof(BP_UNIT)

typedef struct DEBUGREG {
    DWORD       DataAddr;       //  Data Address
    DWORD       DataSize;       //  Data Size
    BPTP        BpType;         //  read, write, execute, etc
    BOOL        InUse;          //  In use
    DWORD       ReferenceCount;
} DEBUGREG;
typedef DEBUGREG *PDEBUGREG;

extern DWORD DebugRegDataSizes[];



#define EXADDR(pde)    ((pde)->u.Exception.ExceptionRecord.ExceptionAddress)

#define AddrFromHthdx(paddr, hthd) \
        AddrInit(paddr, 0, PcSegOfHthdx(hthd), (DWORD)PC(hthd), \
                hthd->fAddrIsFlat, hthd->fAddrOff32, FALSE, hthd->fAddrIsReal)

typedef struct _CALLSTRUCT *PCALLSTRUCT;

/*
 * These are "debug events" which are generated internally by the DM.
 * They are either remappings of certain exceptions or events which
 * do not correspond directly to a system-generated event or exception.
 */

enum    {
    BREAKPOINT_DEBUG_EVENT=(RIP_EVENT+1),
    CHECK_BREAKPOINT_DEBUG_EVENT,
    SEGMENT_LOAD_DEBUG_EVENT,
    DESTROY_PROCESS_DEBUG_EVENT,
    DESTROY_THREAD_DEBUG_EVENT,
    ATTACH_DEADLOCK_DEBUG_EVENT,
    ENTRYPOINT_DEBUG_EVENT,
    LOAD_COMPLETE_DEBUG_EVENT,
    INPUT_DEBUG_STRING_EVENT,
    MESSAGE_DEBUG_EVENT,
    MESSAGE_SEND_DEBUG_EVENT,
    FUNC_EXIT_EVENT,
    OLE_DEBUG_EVENT,
    FIBER_DEBUG_EVENT,
    GENERIC_DEBUG_EVENT,
    BOGUS_WIN95_SINGLESTEP_EVENT,
	SPECIAL_DEBUGGER_EVENT,
#ifdef OMNI
	OMNI_DLL_LOAD_EVENT,
#endif
    MAX_EVENT_CODE
  };

/*
 * This is the set of legal return values from IsCall.  The function of
 *      that routine is to analyze the instruction and determine if the
 *      debugger can simply step over it.
 */

typedef enum    {
    INSTR_TRACE_BIT,            /* Use the trace bit stepping or emulation
                                        thereof */
    INSTR_BREAKPOINT,           /* This is a breakpoint instruction     */
    INSTR_CANNOT_TRACE,         /* Can not trace this instruction       */
    INSTR_SOFT_INTERRUPT,       /* This is an interrupt opcode          */
    INSTR_IS_CALL,              /* This is a call instruction           */
    INSTR_CANNOT_STEP,                  /* In Win95 system code                                 */
} INSTR_TYPES;

typedef enum {
    THUNK_NONE = 0,
    THUNK_USER,
    THUNK_SYSTEM,
} DM32ThunkTypes;

typedef enum {
    RETURN_NONE = 0,
    RETURN_USER,
    RETURN_SYSTEM,
} DM32ReturnTypes;

typedef enum {
    ps_root       = 0x0001,     /* This is the root process, do not send a */
                                /* dbcDeleteProc when this is continued */
                                /* after a dbcProcTerm. */
    ps_preStart   = 0x0002,     /* Process is expecting loader BP */
    ps_preEntry   = 0x0004,     /* Process is expecting Entry BP */
    ps_dead       = 0x0010,     /* This process is dead. */
    ps_deadThread = 0x0020,     /* This process owns dead threads */
    ps_exited     = 0x0040,     /* We have notified the debugger that this */
                                /* process has exited. */
    ps_destroyed  = 0x0080,     /* This process has been destroyed (deleted) */
    ps_killed     = 0x0100,     /* This process is being killed */
    ps_connect    = 0x0200,
	ps_breaking	  = 0x4000
} DMPSTATE;

typedef void (*VECTOR)();

typedef struct  _EXCEPTION_LIST {
    struct _EXCEPTION_LIST *next;
    EXCEPTION_DESCRIPTION  excp;
} EXCEPTION_LIST, *LPEXCEPTION_LIST;

typedef struct _DLLLOAD_ITEM {
    BOOL        fValidDll;         // is this entry filled?
    DWORD       offBaseOfImage;    // offset for base of Image
    DWORD       cbImage;           // size of image in bytes
    LPTSTR      szDllName;         // dll name

    PIMAGE_SECTION_HEADER Sections;          // pointer to section headers
    DWORD                 NumberOfSections;  // number of section headers

#ifndef KERNEL

    BOOL        fReal;
    BOOL        fWow;
    OFFSET      offTlsIndex;    // The offset of the TLS index for the DLL
    // kentf The following comment is what I found in the sources which I
    //       hacked the OLE stuff from.
                                // ptr (in debuggee's memory space) to this
                                // DLL's 1-byte boolean flag indicating whether
                                // OLE RPC debugging is enabled.  If this DLL
                                // does not support OLE RPC, then this field
                                // will be zero.
    // However, the code in dmole.c uses this as a pointer to a function which
    // takes two args, the first of which is the above described flag, and the
    // second of which is zero.
    LPVOID      lpvOleRpc;

    BOOL        fContainsOle;   // does this DLL contain any OLE RPC segments?
    //DEBUG_EVENT de;             // load-dll notification for this DLL

#else

    DWORD                 TimeStamp;         //
    DWORD                 CheckSum;          //
    WORD                  SegCs;             //
    WORD                  SegDs;             //
    PIMAGE_SECTION_HEADER sec;               //

#endif

} DLLLOAD_ITEM, * PDLLLOAD_ITEM;

#if defined(INTERNAL)
typedef struct _DLL_DEFER_LIST {
    struct _DLL_DEFER_LIST  * next;
    LOAD_DLL_DEBUG_INFO       LoadDll;
} DLL_DEFER_LIST, *PDLL_DEFER_LIST;
#endif

/*
 * CWPI is the number of Wndproc-invoking functions that exist:
 *              SendMessage
 *              SendMessageTimeout
 *              SendMessageCallback
 *              SendNotifyMessage
 *              SendDlgItemMessage
 *              DispatchMessage
 *              CallWindowProc
 * times two (A version and W version)
 */

#define CWPI    14


//
// Data structures for timer-events
//

typedef VOID
(*TIMER_EVENT_CALLBACK) (
	HPRCX	hprc,
	LPVOID	lparam
	);

typedef struct _TIMER_EVENT {
	TIMER_EVENT_CALLBACK	callback;
	LPVOID					param;
	DWORD					ticks;
	struct _TIMER_EVENT*	next;
	HANDLE					handle;
} TIMER_EVENT;


typedef struct _TIMER_EVENT_QUEUE {
	TIMER_EVENT*		head;
	TIMER_EVENT*		waitlist;
	CRITICAL_SECTION	cs;
	DWORD				count;
} TIMER_EVENT_QUEUE;

//
// When the user requests that we begin orpc debugging, we set the
// OrpcDebugging variable in the process structure to be
// ORPC_START_DEBUGGING.  The next appropiate time -- during a step, for
// example -- we check the value of the OrpcDebgging and if it's
// ORPC_START_DEBUGGING, we call the trojan and set OrpcDebugging to to
// ORPC_DEBUGGING.  When we are ORPC_DEBUGGING and the user requests to
// stop orpc debugging we set the OrpcDebugging value to ORPC_STOP_DEBUGGING
// and at the next appropiate time, call the trojan to stop debugging.
//
// We cannot call the trojan immediately because this fails on W95.
//

typedef enum _ORPC_DEBUGGING_STATE {
    ORPC_NOT_DEBUGGING      = 0,
    ORPC_START_DEBUGGING,
    ORPC_DEBUGGING,
    ORPC_STOP_DEBUGGING
} ORPC_DEBUGGING_STATE;

typedef struct _HFBRX {
    // linked list
    struct _HFBRX   *next;
    LPVOID  fbrstrt;
    LPVOID  fbrcntx;

} HFBRXSTRUCT,*HFBRX;


typedef struct  _HPRCX {
    // linked lists
    struct _HPRCX   *next;
    struct _HTHDX   *hthdChild;
    struct _HFBRX   *FbrLst;
    PID             pid;            // OS provided process ID
    HANDLE          rwHand;         // OS provided Process handle
    BOOL            CloseProcessHandle; // If we have a private
                                    // handle to this process, close it.
                                    // Otherwise, it belongs to smss.
    DWORD           dwExitCode;     // Process exit status

    HPID            hpid;           // binding to EM object

    DMPSTATE        pstate;         // DM state model
    BOOL            f16bit;         // CreateProcess EXE was 16 bit
    EXCEPTION_LIST *exceptionList;  // list of exceptions to silently
                                    // continue unhandled
    int             cLdrBPWait;     // timeout counter while waiting for ldr BP
	LONG			fExited;		// synchronization object for
                                    // process termination
    PDLLLOAD_ITEM   rgDllList;      // module list
    int             cDllList;       // item count for module list

    HANDLE          hEventCreateThread;  // Sync object for thread creation
	ULONG			StopCount;
	//BOOL			fSoftBroken;

	BOOL            fUseFbrs;       // Use fiber context or thread context
    PVOID           pFbrCntx;       // Pointer to a fiber context to display
                                    // NULL = use thread context
    DWORD           dwKernel32Base; // lpBaseOfDll for kernel32.

    DWORD           colerg;         // number of OLE ranges in *rgolerg
    POLERG          rgolerg;        // array of OLERGs: sorted list of all
                                    // addresses in this process (including
                                    // its DLLs) which are special OLE
                                    // segments.  May be
                                    // NULL if colerg is zero.

    ORPC_DEBUGGING_STATE    OrpcDebugging;  // orpc debugging state (see above)
    UOFFSET					gwpoff[CWPI];  // addrs of Wndproc-invoking functions
    HLLI					llnlg;          // non-local goto
    TID						lastTidDebugEvent;

	BOOL				fStepInto;		// Are we stepping into on this proc
	TIMER_EVENT_QUEUE	TimerQueue;		// For timer-events.

	HANDLE				hExitFailed;	// TIMER_EVENT for when the process
										// does not return a valid
										// EXIT_PROCESS event upon exit.
	
	HANDLE				hAsyncStopRequest;	// TIMER_EVENT for async breaking

#if defined(TARGET_i386)
    SEGMENT         segCode;
#endif

#ifdef KERNEL

    BOOL            fRomImage;      // rom image
    BOOL            fRelocatable;   // relocatable code

#endif


#if defined(INTERNAL)

	//
    // during process startup, dll name resolution may be
    // deferred until the loader BP.  Once the process is
    // fully initialized, this deferral is no longer allowed.
	//
	
    BOOL            fNameRequired;
    PDLL_DEFER_LIST pDllDeferList;

#endif


} HPRCXSTRUCT, *HPRCX;

#define hprcxNull       ((HPRCX) 0)

typedef enum {
    //ts_preStart =0x1000,        /* Before the starting point of the thread */
                                /* from this state a registers and trace   */
                                /* are dealt with specially                */
    ts_running  = 0x001,        /* Execution is proceeding on the thead    */
    ts_stopped  = 0x002,        /* An event has stopped execution          */
    ts_frozen   = 0x010,        /* Debugger froze thread.                  */
    ts_dead     = 0x020,        /* Thread is dead.                         */
    ts_destroyed =0x040,        /* Thread is destroyed (deleted)           */
    ts_first    = 0x100,        /* Thread is at first chance exception     */
    ts_second   = 0x200,        /* Thread is at second chance exception    */
    ts_rip      = 0x400,        /* Thread is in RIP state                  */
    ts_stepping = 0x800,		/*                                         */
	ts_breaking = 0x1000,		/* Trying async break this thread          */
    ts_funceval = 0x40000000    /* Thread is being used for function call  */
} TSTATEX;

typedef struct  _WTNODE {
    struct _WTNODE      *caller;      // caller's wtnode
    struct _WTNODE      *callee;      // current function called by this function
    DWORD               offset;       // address of this function
    DWORD               sp;           // SP for this frame
    int                 icnt;         // number of instructions executed
    int                 scnt;         // subordinate count
    int                 lex;          // lexical level of this function
    LPSTR               fname;        // function name
} WTNODE, *LPWTNODE;


typedef struct  _HTHDX {
    struct  _HTHDX    *next;
    struct  _HTHDX    *nextSibling;
    HPRCX             hprc;
    HTID              htid;
    TID               tid;
    HANDLE            rwHand;
    LPVOID            lpStartAddress;
    CONTEXT           ctx;
    LPVOID            atBP;
    TSTATEX           tstate;
    BOOL              fExceptionHandled;
    DWORD             stackRA;
    DWORD             stackBase;
    int               cFuncEval;
    DWORD             dwExitCode;
    OFFSET            offTeb;

    BOOL              fContextDirty;// has the context changed?
    BOOL              fContextStale;// does the context need to be refreshed?
    BOOL              fContextExtendedDirty; //extended registers need be written 	

    BOOL              fAddrIsFlat;  // Is this address segmented?
    BOOL              fAddrIsReal;  // Is this address in real mode?
    BOOL              fAddrOff32;   // Is the offset of this addres 32 bits?
    BOOL              fDontStepOff; //

    BOOL              fWowEvent;    // Was the last event WOW?

    ADDR              addrIsCall;
    int               iInstrIsCall;

    EXCEPTION_RECORD  ExceptionRecord;

    BOOL              fIsCallDone;
    BOOL              fDisplayReturnValues;
    BOOL              fStopOnNLG;
    BOOL              fReturning;

    ADDR              addrFrom;
    ADDR              addrStack;

    WTNODE            wthead;       // root of the call tree for a wt command
    LPWTNODE          wtcurr;       // current wtnode
    DWORD             wtmode;       // wt command executing?

    LIST_ENTRY        WalkList;     // Walks associated with this thread
    PVOID             WalkData;     // Per-thread walk data

	BOOL			  fSoftBroken;	// this is for Async-stop fake soft break

#ifdef HAS_DEBUG_REGS
    DEBUGREG          DebugRegs[NUMBER_OF_DEBUG_REGISTERS];
#endif

#ifndef KERNEL
    char              szThreadName[32];
#endif // !KERNEL

 	BOOL       	      fPassException;
} HTHDXSTRUCT, *HTHDX;

typedef void (*ACVECTOR)(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);
typedef void (*DDVECTOR)(DEBUG_EVENT*, HTHDX);

#define hthdxNull ((HTHDX) NULL)

typedef struct _BREAKPOINT {
    struct _BREAKPOINT *next;
    HPRCX       hprc;       // The process the BP belongs to
    HTHDX       hthd;       // The thread the BP belongs to
    int         cthd;       // The number of threads pointing at this bp (atBP)
    BPTP        bpType;     // OSDebug BP type
    BPNS        bpNotify;   // OSDebug notify type

    ADDR        addr;       // The address of the Breakpoint

    HANDLE      hWalk;      // The associated walk handle.
    
    BYTE        instances;   // The # of instances that exist
    HPID        id;          // Id supplied by the EM
    BOOL        isStep;      // Single step flag
    DWORD       hBreakPoint; // kernel debugger breakpoint handle
} BREAKPOINT;
typedef BREAKPOINT *PBREAKPOINT;

//
// these are magic values used in the hthd->atBP field.
//

#define EMBEDDED_BP     ((PBREAKPOINT)(-1))

//
// These are used in the id field of a BREAKPOINT.
//
#define ENTRY_BP        ((ULONG) -2)
#define ASYNC_STOP_BP   ((ULONG) -3)

extern  BREAKPOINT      masterBP , *bpList;

typedef struct _METHOD {
    ACVECTOR notifyFunction; /* The notification function to call */
    void   *lparam;        /* The parameter to pass to it */
    void   *lparam2;       /* Extra pointer in case the method */
    /* needs to be freed afterwards */
} METHOD;
typedef METHOD *PMETHOD;

typedef struct _EXPECTED_EVENT {
    struct   _EXPECTED_EVENT  *next;
    HPRCX    hprc;
    HTHDX    hthd;
    DWORD    eventCode;
    DWORD    subClass;
    METHOD*  notifier;
    ACVECTOR action;
    BOOL     fPersistent;
    LPVOID   lparam;
} EXPECTED_EVENT;
typedef EXPECTED_EVENT *PEXPECTED_EVENT;


typedef VOID    (*STEPPER)(HTHDX,METHOD*,BOOL, BOOL);

typedef DWORD   (*CDVECTOR)(HPRCX,HTHDX,LPDBB);

typedef struct {
    DMF         dmf;
    CDVECTOR    function;
    WORD        type;
} CMD_DESC;


enum {
    BLOCKING,
    NON_BLOCKING,
    REPLY
};


#if 0
/*
 * Setup for a CreateProcess to occur
 */

typedef struct _SPAWN_STRUCT {
    BOOL                fSpawn;
    HANDLE              hEventApiDone;

    BOOL                fReturn;    // return from API
    DWORD               dwError;

    char *              szAppName;  // args to API etc
    char *              szArgs;
    char *              pszCurrentDirectory; // directory to spawn process.
    DWORD               fdwCreate;
    BOOL                fInheritHandles;
    STARTUPINFO         si;
} SPAWN_STRUCT, *PSPAWN_STRUCT;
#endif

/*
 *      Setup for a DebugActiveProcess to occur
 */

typedef struct _DEBUG_ACTIVE_STRUCT {
    volatile BOOL fAttach;          // tell DmPoll to act
    HANDLE        hEventApiDone;    // signal shell that API finished
    HANDLE        hEventReady;      // clear until finished loading

    BOOL          fReturn;          // API return value
    DWORD         dwError;          // GetLastError() value

    DWORD         dwProcessId;      // pid to debug
    HANDLE        hEventGo;         // signal after hitting ldr BP
} DEBUG_ACTIVE_STRUCT, *PDEBUG_ACTIVE_STRUCT;

//
// packet for starting WT (Watch Trace)
//
typedef struct _WT_STRUCT {
    BOOL          fWt;
    DWORD         dwType;
    HTHDX         hthd;
} WT_STRUCT, *LPWT_STRUCT;

//
// Packet for killing a process
//
typedef struct _KILLSTRUCT {
    struct _KILLSTRUCT * next;
    HPRCX                hprc;
} KILLSTRUCT, *PKILLSTRUCT;

extern  BOOL    StartDmPollThread(void);
extern  BOOL    StartCrashPollThread(void);


extern BOOL SearchPathSet;
extern char SearchPathString[];

//
//  Single stepping stuff
//
typedef struct _BRANCH_NODE {
    BOOL    TargetKnown;     //  Know target address
    BOOL    IsCall;          //  Is a call instruction
    ADDR    Addr;            //  Branch instruction address
    ADDR    Target;          //  Target address
} BRANCH_NODE;

#pragma warning( disable: 4200)

typedef struct _BRANCH_LIST {
    ADDR        AddrStart;      //  Start of range
    ADDR        AddrEnd;        //  End of range
    DWORD       Count;          //  Count of branch nodes
    BRANCH_NODE BranchNode[0];  //  List of branch nodes
} BRANCH_LIST;

#pragma warning( default: 4200 )

DWORD
BranchUnassemble(
    HTHDX   hthd,
    void   *Memory,
    DWORD   Size,
    ADDR   *Addr,
    BOOL   *IsBranch,
    BOOL   *TargetKnown,
    BOOL   *IsCall,
    BOOL   *IsTable,
    ADDR   *Target
    );


//
//  Structure for doing range stepping
//
typedef struct _RANGESTRUCT {
    HTHDX        hthd;          //  thread
    BOOL         fStepOver;     //  Step over flag
    BOOL         fStopOnBP;     //  Stop on BP flag
    METHOD       *Method;       //  Method
    DWORD        BpCount;       //  Count of temporary breakpoints
    ADDR         *BpAddrs;      //  List of breakpoint addresses
    BREAKPOINT   **BpList;      //  List of breakpoints
    BRANCH_LIST  *BranchList;   //  branch list
    ADDR         PrevAddr;      //  For single stepping
    BOOL         fSingleStep;   //  For single stepping
    ADDR         TmpAddr;       //  For single stepping
    BOOL         fInCall;       //  For single stepping
    BREAKPOINT   *TmpBp;        //  For single stepping
} RANGESTRUCT;

BOOL
SmartRangeStep(
    HTHDX       hthd,
    UOFF32      offStart,
    UOFF32      offEnd,
    BOOL        fStopOnBP,
    BOOL        fStepOver
    );

VOID
MethodSmartRangeStep(
    DEBUG_EVENT* pde,
    HTHDX hthd,
    DWORD unused,
    RANGESTRUCT* RangeStruct
    );

typedef struct  _RANGESTEP {
    HTHDX       hthd;           // The thread's structure
    SEGMENT     segCur;         // Segment to do range stepping in
    UOFF32      addrStart;      // starting address of range step
    UOFF32      addrEnd;        // ending address of range step
    SEGMENT     SavedSeg;       // Save locations for thunk stepping
    UOFF32      SavedAddrStart; //  "       "
    UOFF32      SavedAddrEnd;   //  "       "
	UOFF32      SavedEBP;       // Save the EBP register (may not be the Frame Pointer!)
    STEPPER     stepFunction;   // The step function to call
    METHOD      *method;        // The method to handle this event
    BREAKPOINT  *safetyBP;      // Safety BP
    BOOL        fIsCall;        // just traced a call instruction?
    BOOL        fIsRet;         // just traced a ret?
    BOOL        fInThunk;       // stepping in a thunk?
    BOOL        fSkipProlog;    // step past prolog on function entry
    BOOL        fGetReturnValue;// Getting a return value.
} RANGESTEP;

extern DEBUG_EVENT FuncExitEvent;
extern HINSTANCE hInstance; // The DM DLLs hInstance
extern DWORD g_ProcFlags;	// PROCESSOR_FLAGS_xxx

VOID
RangeStep(
    HTHDX       hthd,
    UOFF32      offStart,
    UOFF32      offEnd,
    BOOL        fStopOnBP,
    BOOL        fstepOver
    );

VOID
MethodRangeStep(
    DEBUG_EVENT* pde,
    HTHDX hthd,
    DWORD unused,
    RANGESTEP* RangeStep
    );

VOID
IsCall(
    HTHDX hthd,
    LPADDR lpAddr,
    LPINT lpFlag,
    BOOL fStepOver
    );

VOID
IsCallEx(
    HTHDX hthd,
    LPADDR lpAddr,
    LPINT lpFlag,
    BOOL fStepOver,
	LPADDR	addrDest
    );

VOID
DecrementIP(
    HTHDX hthd
    );

VOID
IncrementIP(
    HTHDX hthd
    );

BOOL
IsRet(
    HTHDX hthd,
    LPADDR addr
    );

VOID
ContinueFromBP(
    HTHDX hthd,
    PBREAKPOINT pbp
    );

#define CB_THUNK_MAX    32

BOOL
IsThunk (
    HTHDX       hthd,
    UOFFSET     uoffset,
    LPINT       lpfThunkType,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
FIsDirectJump(
    BYTE *      rgbBuffer,
    DWORD       cbBuff,
    HTHDX       hthd,
    UOFFSET     uoffset,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
FIsIndirectJump(
    BYTE *      rgbBuffer,
    DWORD       cbBuff,
    HTHDX       hthd,
    UOFFSET     uoffset,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
FIsVCallThunk(
    BYTE *      rgbBuffer,
    DWORD       cbBuff,
    HTHDX       hthd,
    UOFFSET     uoffset,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
FIsVTDispAdjustorThunk(
    BYTE *      rgbBuffer,
    DWORD       cbBuff,
    HTHDX       hthd,
    UOFFSET     uoffset,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
FIsAdjustorThunk(
    BYTE *      rgbBuffer,
    DWORD       cbBuff,
    HTHDX       hthd,
    UOFFSET     uoffset,
    UOFFSET *   lpuoffThunkDest,
    LPDWORD     lpdwThunkSize
    );

BOOL
GetPMFDest(
    HTHDX hthd,
    UOFFSET uThis,
    UOFFSET uPMF,
    UOFFSET *lpuOffDest
    );

BOOL
SetupSingleStep(
    HTHDX hthd,
    BOOL DoContinue,
    BOOL fTraceSet 
    );

BOOL
SetupReturnStep(
    HTHDX hthd,
    BOOL  DoContinue,
    LPADDR lpaddr,
    LPADDR addrStack
    );

DWORD
GetCanStep (
    HPID hpid,
    HTID htid,
    LPADDR lpaddr,
    LPCANSTEP lpCanStep
    );

DWORD
GetEndOfRange (
    HPRCX,
    HTHDX,
    DWORD
    );

VOID
SingleStep(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval
    );

VOID
SingleStepEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    BOOL fDoContinue
    );

VOID
ReturnStep(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    LPADDR addrRA,
    LPADDR addrStack
    );

VOID
ReturnStepEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    LPADDR addrRA,
    LPADDR addrStack,
    BOOL fDoContinue,
    BOOL fCheckOrpc
    );


VOID
StepOverEx(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval,
    BOOL fCheckOrpc
    );

VOID
StepOver(
    HTHDX hthd,
    METHOD* notify,
    BOOL stopOnBP,
    BOOL fInFuncEval
    );

VOID
MoveIPToException(
    HTHDX hthd,
    LPDEBUG_EVENT pde
    );

void
MethodContinueSS(
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    METHOD *method
    );


BOOL
DecodeSingleStepEvent(
    HTHDX hthd,
    DEBUG_EVENT *de,
    PDWORD eventCode,
    PDWORD subClass
    );

VOID
WtRangeStep(
    HTHDX hthd
    );

VOID
WtMethodRangeStep(
    DEBUG_EVENT* pde,
    HTHDX hthd,
    DWORD unused,
    RANGESTEP* RangeStep
    );

BOOL
GetWndProcMessage(
    HTHDX   hthd,
    UINT*   message
    );

//
// Function calling, for internal use
//

typedef struct _CALLSTRUCT {
    PBREAKPOINT pbp;
    LPVOID      atBP;
    CONTEXT     context;
    ACVECTOR    Action;
    BOOL        HasReturnValue;
    LPARAM      lparam;
} CALLSTRUCT, *PCALLSTRUCT;

BOOL
WINAPIV
CallFunction(
    HTHDX       hthd,
    ACVECTOR    Action,
    LPARAM      lparam,
    BOOL        HasReturnValue,
    LPVOID      Function,
    int         cArgs,
    ...
    );

//
// This function is machine-specific
//
VOID
vCallFunctionHelper(
    HTHDX hthd,
    FARPROC lpFunction,
    int cArgs,
    va_list vargs
    );

//
// This function is machine-specific
//

DWORDLONG
GetFunctionResult(
    PCALLSTRUCT pcs
    );


void
SetDebugEventThreadState(
    HPRCX   hprc,
    TSTATEX RemoveState
    );
//
// Win95 support
//

BOOL IsInSystemDll ( UOFFSET uoffDest );
void SendDBCErrorStep(HPRCX hprc);

/*
 *
 */

#ifdef KERNEL
extern  void    ProcessDebugEvent( DEBUG_EVENT *de, DBGKD_WAIT_STATE_CHANGE  *sc );
extern  VOID    ProcessHandleExceptionCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessIgnoreExceptionCmd(HPRCX,HTHDX,LPDBB);
extern  BOOL    ProcessFrameStackWalkNextCmd( HPRCX, HTHDX, PCONTEXT, LPVOID );
extern  VOID    ProcessGetExtendedContextCmd(HPRCX hprc,HTHDX hthd,LPDBB lpdbb);
extern  VOID    ProcessSetExtendedContextCmd(HPRCX hprc,HTHDX hthd,LPDBB lpdbb);
extern  void    DeleteAllBps( VOID );
extern  VOID    DmPollTerminate( VOID );

#else

extern  void    ProcessDebugEvent( DEBUG_EVENT *de );
extern  VOID    ProcessBPAcceptedCmd( HPRCX hprcx, HTHDX hthdx, LPDBB lpdbb );
extern  VOID    ProcessGetDRegsCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb);
extern  VOID    ProcessSetDRegsCmd(HPRCX hprc, HTHDX hthd, LPDBB lpdbb);

#endif


extern  void    ProcessExceptionEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessCreateThreadEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessCreateProcessEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessExitThreadEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessExitProcessEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessLoadDLLEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessUnloadDLLEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessOutputDebugStringEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessBreakpointEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessRipEvent(DEBUG_EVENT*, HTHDX);
extern  void    ProcessBogusSSEvent(DEBUG_EVENT*, HTHDX);


extern  void    NotifyEM(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);
extern  void    ConsumeThreadEventsAndNotifyEM(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);
extern  void    FreeHthdx(HTHDX hthd);
extern  XOSD    FreeProcess( HPRCX hprc, BOOL fKillRoot);

extern  VOID    ProcessCreateProcessCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessProcStatCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessThreadStatCmd(HPRCX,HTHDX,LPDBB);
extern  void    ProcessSpawnOrphanCmd(HPRCX,HTHDX,LPDBB);
extern  void    ProcessProgLoadCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessUnloadCmd(HPRCX,HTHDX,LPDBB);

extern  VOID    ProcessReadMemoryCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessWriteMemoryCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessGetContextCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessGetSectionsCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessSetContextCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessSingleStepCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessRangeStepCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessReturnStepCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessExecuteCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessContinueCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessFreezeThreadCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessTerminateThreadCmd(HPRCX,HTHDX,LPDBB);
extern  BOOL	ProcessTerminateProcessCmd(HPRCX,HTHDX,LPDBB);
extern  DWORD   ProcessAsyncGoCmd(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessGetFP(HPRCX,HTHDX,LPDBB);
extern  VOID    ProcessIoctlCmd( HPRCX, HTHDX, LPDBB );
extern  VOID    ProcessSSVCCustomCmd( HPRCX, HTHDX, LPDBB );
extern  VOID    ProcessSelLimCmd( HPRCX, HTHDX, LPDBB );
extern  VOID    ClearContextPointers(PKNONVOLATILE_CONTEXT_POINTERS);
extern  VOID    ProcessDebugActiveCmd(HPRCX, HTHDX, LPDBB);
extern  VOID    ProcessAsyncStopCmd(HPRCX, HTHDX, LPDBB );
extern  VOID    ProcessAllProgFreeCmd( HPRCX hprcXX, HTHDX hthd, LPDBB lpdbb );
extern  VOID    ProcessSetPathCmd( HPRCX hprcXX, HTHDX hthd, LPDBB lpdbb );
extern  VOID    ProcessQueryTlsBaseCmd( HPRCX hprcx, HTHDX hthdx, LPDBB lpdbb );
extern  VOID    ProcessQuerySelectorCmd(HPRCX, HTHDX, LPDBB);
extern  VOID    ProcessReloadModulesCmd(HPRCX hprcx, HTHDX hthdx, LPDBB lpdbb );
extern  VOID    ProcessVirtualQueryCmd(HPRCX hprcx, LPDBB lpdbb);
extern  VOID    ProcessGetDmInfoCmd(HPRCX hprc, LPDBB lpdbb, DWORD cb);
extern  VOID    ProcessRemoteQuit(VOID);
extern  ULONG   ProcessGetTimeStamp (HPRCX, HTHDX, LPDBB);
extern  ULONG   ProcessGetSpecialReg (HPRCX, HTHDX, LPDBB);
extern  ULONG   ProcessSetSpecialReg (HPRCX, HTHDX, LPDBB);

VOID
ProcessGetFrameContextCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    );

VOID
ProcessGetExceptionState(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    );

VOID
ProcessSetExceptionState(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    );

EXCEPTION_FILTER_DEFAULT
ExceptionAction(
    HPRCX hprc,
    DWORD dwExceptionCode
    );

VOID
RemoveExceptionList(
    HPRCX hprc
    );

EXCEPTION_LIST *
InsertException(
    EXCEPTION_LIST ** ppeList,
    LPEXCEPTION_DESCRIPTION lpexc
    );

VOID
ProcessBreakpointCmd(
    HPRCX hprcx,
    HTHDX hthdx,
    LPDBB lpdbb
    );

VOID
ProcessSystemServiceCmd(
    HPRCX hprc,
    HTHDX hthd,
    LPDBB lpdbb
    );


VOID
InitExceptionList(
    HPRCX hprc
    );

VOID
CompleteTerminateProcessCmd(
    VOID
    );


//
// Public functions from walk.c
//

VOID
ExprBPCreateThread(
    HPRCX hprc,
    HTHDX hthd
    );

VOID
ExprBPExitThread(
    HPRCX hprc,
    HTHDX hthd
    );

VOID
ExprBPContinue(
    HPRCX hprc,
    HTHDX hthd
    );

VOID
ExprBPRestoreDebugRegs(
    HTHDX hthd
    );

VOID
ExprBPClearBPForStep(
    HTHDX hthd
    );

VOID
ExprBPResetBP(
    HTHDX hthd,
    PBREAKPOINT bp
    );

VOID
ExprBPInitialize(
    VOID
    );

PBREAKPOINT
GetWalkBPFromBits(
    HTHDX   hthd,
    DWORD   bits
    );

BOOL
IsWalkInGroup(
    HANDLE hWalk,
    PVOID pWalk
    );

HANDLE
GetNewWalk(
    HPRCX   hprc,
    HTHDX   hthd,
    DWORD   Addr,
    DWORD   Size,
    DWORD   BpType,
    BOOL    fEmulate
    );

BOOL
RemoveWalk(
    HANDLE hWalk,
    BOOL Global
    );

BOOL
CheckDataBP(
    HTHDX hthd,
    PBREAKPOINT Bp
    );

VOID
ClearThreadWalkFlags(
    HTHDX   hthd
    );

VOID
ClearProcessWalkFlags(
    HPRCX   hprc
    );

//
//
//


#ifdef HAS_DEBUG_REGS
BOOL
SetupDebugRegister(         // implemented in mach.c
    HTHDX       hthd,
    int         Register,
    int         DataSize,
    DWORD       DataAddr,
    DWORD       BpType
    );

VOID
ClearDebugRegister(
    HTHDX hthd,
    int Register
    );

#endif

VOID
ClearAllDebugRegisters(
    HPRCX hprc
	);



extern
void
SSActionReplaceByte(
    DEBUG_EVENT *de,
    HTHDX hthdx,
    DWORD unused,
    PBREAKPOINT bp
    );

extern
void
SSActionRBAndContinue(
    DEBUG_EVENT*,
    HTHDX,
    DWORD,
    BREAKPOINT*
    );


extern
void SSActionRemoveBP(
    DEBUG_EVENT *de,
    HTHDX hthd,
    DWORD unused,
    METHOD* method
    );

extern
void
SSActionStepOver(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    METHOD* method
    );

extern
void
ActionDefineProcess(
    DEBUG_EVENT *de,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    );

extern
void ActionAllDllsLoaded(
    DEBUG_EVENT *de,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    );

extern
void
ActionDebugActiveReady(
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    );

extern
void
ActionDebugNewReady(
    DEBUG_EVENT *pde,
    HTHDX hthd,
    DWORD unused,
    HPRCX hprc
    );

extern
void
ActionExceptionDuringStep(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    );

extern
void *
InfoExceptionDuringStep(
    HTHDX hthd
    );


BOOL
CDECL
DMPrintShellMsg(
    PCHAR szFormat,
    ...
    );

BOOL
WINAPIV
DMPrintShellMsgEx(
	DWORD	ids,
	...
	);
	

//
// event.c
//

PEXPECTED_EVENT
RegisterExpectedEvent(
    HPRCX hprc,
    HTHDX hthd,
    DWORD eventcode,
    DWORD subclass,
    METHOD* method,
    ACVECTOR action,
    BOOL persistent,
    LPVOID lparam
    );

PEXPECTED_EVENT
PeeIsEventExpected(
    HTHDX hthd,
    DWORD eventcode,
    DWORD subclass,
        BOOL bRemove
    );

VOID
ConsumeAllThreadEvents(
    HTHDX hthd,
    BOOL ConsumePersistent
    );

VOID
ConsumeAllProcessEvents(
    HPRCX hprc,
    BOOL ConsumePersistent
    );

VOID
ConsumeSpecifiedEvent(
    PEXPECTED_EVENT ee
    );

#if 0
//
//
//

XOSD
Load(
    HPRCX hprc,
    LPCTSTR szAppName,
    LPCTSTR szArg,
    LPVOID pattrib,
    LPVOID tattrib,
    DWORD creationFlags,
    BOOL inheritHandles,
    CONST LPCTSTR* environment,
    LPCTSTR currentDirectory,
    STARTUPINFO FAR * pstartupInfo,
    LPPROCESS_INFORMATION lppi
    );
#endif

HPRCX
InitProcess(
    HPID hpid
    );

VOID
SetExceptionAddress(
    DEBUG_EVENT*    pde,
    ULONG           addr
    );

#if defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)
VOID
RemoveFuncList(
    HPRCX hprc
    );
#endif

#if defined(TARGET_MIPS)

typedef enum { Ctx32Bit, Ctx64Bit } MIPSCONTEXTSIZE;
extern MIPSCONTEXTSIZE MipsContextSize;

BOOL
CoerceContext64To32(
    PCONTEXT pContext
    );

BOOL
CoerceContext32To64 (
    PCONTEXT pContext
    );
#endif // TARGET_MIPS

VOID
WINAPI
DMFunc(
    DWORD cb,
    LPDBB lpdbb
    );


VOID
ReConnectDebugger(
    DEBUG_EVENT *de,
    BOOL fNoDllLoad
    );


#if defined(TARGET_MIPS) || defined(TARGET_ALPHA) || defined(TARGET_PPC)
extern  ULONG       GetNextOffset (HTHDX, BOOL);
#endif

extern void SetupEntryBP(HTHDX hthd);
void DestroyDllLoadItem(PDLLLOAD_ITEM pDll);


VOID
Reply(
    UINT length,
    void * lpbBuffer,
    HPID hpid
    );


// Use this specifically to send errors about process startup.
VOID
SendNTError(
        HPRCX hprc,
        DWORD dwErr,
        LPTSTR lszString
        );

// Used for other dbcError's.

VOID
SendDBCError(
        HPRCX hprc,
        DWORD dwErr,
        LPTSTR lszString
        );

/*
 **
 */

#if DBG

#ifndef XBOX
#define assert(exp) if (!(exp)) {lpdbf->lpfnLBAssert(#exp,__FILE__,__LINE__);}
#endif

extern BOOL FVerbose;
extern BOOL FUseOutputDebugString;
extern char rgchDebug[];
extern void DebugPrint(char *, ...);
extern ULONG gTraceFlag;

#define TR_RANGESTEP	0x00000001

#ifdef XBOX
// retain block compatibility with non-Xbox version
#define DPRINT(level, args) if(1) { (DbgPrint)args; }
#else
#define DPRINT(level, args) \
  if (FVerbose >= level) { ((FUseOutputDebugString)? (DebugPrint) : (DMPrintShellMsg)) args; }
#endif

#define DEBUG_PRINT(str) DPRINT(5, (str))
#define DEBUG_PRINT_1(str, a1) DPRINT(5, (str, a1))
#define DEBUG_PRINT_2(str, a1, a2) DPRINT(5, (str, a1, a2))
#define DEBUG_PRINT_3(str, a1, a2, a3) DPRINT(5, (str, a1, a2, a3))
#define DEBUG_PRINT_4(str, a1, a2, a3, a4) DPRINT(5, (str, a1, a2, a3, a4))
#define DEBUG_PRINT_5(str, a1, a2, a3, a4, a5) DPRINT(5, (str, a1, a2, a3, a4, a5))
#define DEBUG_LEVEL_PRINT(level, str) DPRINT(level, (str))
#define VERIFY(X) if (!(X)) assert(FALSE)

void
WINAPI
_DbgTrace(
	ULONG	Flag,
	LPCTSTR	szFormat,
	...
	);

#define DbgTrace(_x) _DbgTrace _x

#else

#ifndef XBOX
#define assert(exp)
#endif

#define DPRINT(level, args)

#define DEBUG_PRINT(str)
#define DEBUG_PRINT_1(str, a1)
#define DEBUG_PRINT_2(str, a1, a2)
#define DEBUG_PRINT_3(str, a1, a2, a3)
#define DEBUG_PRINT_4(str, a1, a2, a3, a4)
#define DEBUG_PRINT_5(str, a1, a2, a3, a4, a5)

#define DEBUG_LEVEL_PRINT(level, str)
#define VERIFY(X) ((void)(X))
#define DbgTrace(_x)

#endif

extern  DMTLFUNCTYPE        DmTlFunc;

/*
**   Win95/Chicago and other OS feature related functions
*/

BOOL IsChicago(VOID);
extern BOOL FXSAVESupported;

/*
**   WOW functions
*/

//#define WOW_IMPLEMENTED

#ifdef WOW_IMPLEMENTED
BOOL TranslateAddress(HPRCX, HTHDX, LPADDR, BOOL);
BOOL IsWOWPresent(VOID);
BOOL    WOWGetThreadContext(HTHDX hthdx, LPCONTEXT lpcxt);
BOOL    WOWSetThreadContext(HTHDX hthdx, LPCONTEXT lpcxt);
#else
#define TranslateAddress(a,b,c,d)    FALSE
#define IsWOWPresent()               FALSE
#define WOWGetThreadContext(a,b)     FALSE
#define WOWSetThreadContext(a,b)     FALSE
#endif

extern  void    ProcessSegmentLoadEvent(DEBUG_EVENT *, HTHDX);
extern  void    ProcessEntryPointEvent(DEBUG_EVENT *pde, HTHDX hthdx);

/*
**  Prototypes from util.c
*/

ULONG   SetReadPointer(ULONG cbOffset, int iFrom);
VOID    SetPointerToFile(HANDLE hFile);
VOID    SetPointerToMemory(HPRCX hprcx, LPVOID lpv);
BOOL    DoRead(LPVOID lpv, DWORD cb);
BOOL    AreAddrsEqual(HPRCX, HTHDX, LPADDR, LPADDR);

HTHDX HTHDXFromPIDTID(PID, TID);
HTHDX HTHDXFromHPIDHTID(HPID, HTID);
HPRCX HPRCFromPID(PID);
HPRCX HPRCFromHPID(HPID);
HPRCX HPRCFromHPRC(HANDLE);



BOOL
CheckBpt(
    HTHDX       hthd,
    PBREAKPOINT pbp
    );

LPTSTR
MHStrdup(
    LPCTSTR s
    );

XOSD
DMSendRequestReply (
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD cbInput,
    LPVOID lpInput,
    DWORD cbOutput,
    LPVOID lpOutput
    );

XOSD
DMSendDebugPacket(
    DBC dbc,
    HPID hpid,
    HTID htid,
    DWORD cbInput,
    LPVOID lpInput
    );

UOFFSET
FileOffFromVA(
    PDLLLOAD_ITEM           pdi,
    HFILE                   hfile,
    UOFFSET                 uoffBasePE,
    const IMAGE_NT_HEADERS *pnthdr,
    UOFFSET                 va
    );

DWORD
CbReadDllHdr(
    HFILE hfile,
    UOFFSET uoff,
    LPVOID lpvBuf,
    DWORD cb
    );

ULONGLONG
GetRegValue(
    PCONTEXT regs,
    int cvindex
    );

VOID
DmSetFocus (
    HPRCX phprc
    );

BOOL
FGetExport(
    PDLLLOAD_ITEM pdi,
    HFILE       hfile,
    LPCTSTR     szExport,
    LPVOID*     plpvValue
    );

VOID
GetTaskList(
    PTASK_LIST pTask,
    DWORD dwNumTasks
    );

BOOL
AddrReadMemory(
    HPRCX       hprc,
    HTHDX       hthd,
    LPADDR      paddr,
    LPVOID      lpb,
    DWORD       cb,
    LPDWORD     pcbRead
    );

BOOL
AddrWriteMemory(
    HPRCX       hprc,
    HTHDX       hthd,
    LPADDR      paddr,
    LPVOID      lpv,
    DWORD       cb,
    LPDWORD     pcbWritten
    );


//
// userapi.c / kdapi.c
//

BOOL
DbgReadMemory(
    HPRCX       hprc,
    LPCVOID     lpOffset,
    LPVOID      lpv,
    DWORD       cb,
    LPDWORD     pcbRead
    );

BOOL
DbgWriteMemory(
    HPRCX       hprc,
    LPVOID      lpOffset,
    LPVOID      lpb,
    DWORD       cb,
    LPDWORD     pcbWritten
    );

BOOL
DbgGetThreadContext(
    HTHDX hthd,
    LPCONTEXT lpContext
    );

BOOL
DbgSetThreadContext(
    IN HTHDX hthd,
    IN LPCONTEXT lpContext
    );      \

EXHDLR *
GetExceptionCatchLocations(
    IN HTHDX,
    IN LPVOID
    );

VOID
GetMachineType(
    LPPROCESSOR p
    );

void
AddQueue(
    DWORD dwType,
    DWORD dwProcessId,
    DWORD dwThreadId,
    DWORD dwData,
    DWORD dwLen
    );

BOOL
DequeueAllEvents(
    BOOL fForce,
    BOOL fConsume
    );

VOID
InitEventQueue(
    VOID
    );

typedef struct _DEQ {
	BOOL fNeedsContinue;
	DEBUG_EVENT de;
	union {
		DMN_MODLOAD dmml;
		DMN_BREAK dmbr;
	};
	struct _DEQ *pdeqNext;
} DEQ;

VOID InitDEQ(void);
BOOL WaitDEQ(DEQ *, DWORD);
void PostDEQ(DEBUG_EVENT *, BOOL);

BOOL
IsPassingException(
    HPRCX   hprc
    );

void
ThreadContinueDebugEventEx(
    HTHDX   hthd,
    ULONG   Continue
    );

void
ThreadContinueDebugEvent(
    HTHDX   hthd
    );


#define QT_CONTINUE_DEBUG_EVENT     1
#define QT_RELOAD_MODULES           2
#define QT_TRACE_DEBUG_EVENT        3
#define QT_REBOOT                   4
#define QT_RESYNC                   5
#define QT_DEBUGSTRING              6
#define QT_CRASH                    7


//
// any ssvc not recognized by ProcessSystemServiceCmd is
// punted to this, which is provided separately by the user
// and kernel versions.
//
VOID
LocalProcessSystemServiceCmd(
    HPRCX   hprc,
    HTHDX   hthd,
    LPDBB   lpdbb
    );


//
//
//

#ifndef KERNEL

//
// OLE debugging support
//

typedef enum _OLESEG OLESEG;
typedef enum _ORPC ORPC;

typedef VOID (*COMPLETION_FUNCTION) (HTHDX, LPVOID);

OLESEG  GetOleSegType(LPVOID);
OLESEG  OleSegFromAddr(HPRCX, UOFFSET);
#define EnsureOleRpcStatus(hthd, pfn, lpv) ((pfn)(hthd, lpv))
BOOL    FClientNotifyStep(HTHDX, DEBUG_EVENT*);
BOOL    FServerNotifyStop(HTHDX, DEBUG_EVENT*);
ORPC    OrpcFromPthd(HTHDX, DEBUG_EVENT*);
VOID    ProcessOleEvent(DEBUG_EVENT*, HTHDX);

BOOL
CheckAndSetupForOrpcSection(
    HTHDX   hthd
    );

UOFFSET
GetReturnDestination(
    HTHDX   hthd
    );

VOID
SetupOrpcRangeStep(
    HTHDX   hthd
    );

VOID ActionOrpcClientGetBufferSize(DEBUG_EVENT *, HTHDX, DWORD, LPVOID);
VOID ActionOrpcClientFillBuffer(DEBUG_EVENT *, HTHDX, DWORD, LPVOID);
VOID ActionOrpcClientNotify(DEBUG_EVENT *, HTHDX, DWORD, LPVOID);
VOID ActionOrpcServerNotify(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);
VOID ActionOrpcServerGetBufferSize(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);
VOID ActionOrpcSkipToSource(DEBUG_EVENT*, HTHDX, DWORD, LPVOID);

BOOL
GetSinglePVOIDArgument(
	HTHDX	hthd,
	PVOID*	Argument
	);

BOOL
GetDoublePVOIDArgument(
	HTHDX	hthd,
	DWORD*	Argument1,
	DWORD*	Argument2
	);

//
//  Fiber Support
//
VOID ProcessFiberEvent(DEBUG_EVENT*,HTHDX);
VOID RemoveFiberList(HPRCX);

VOID ProcessSpecialEvent(DEBUG_EVENT*,HTHDX);
//
//  Non Local Goto support
//

typedef HDEP HNLG;  // Handle to NLG
typedef struct _NLG_DESTINATION {
    DWORD   dwSig;
    UOFFSET uoffDestination;
    DWORD   dwCode;
    UOFFSET uoffFramePointer;
} NLG_DESTINATION;
typedef NLG_DESTINATION FAR * LPNLG_DESTINATION;

#define NLG_LONGJMP						0x00000000
#define NLG_EXCEPT_ENTER				0x00000001
#define NLG_CATCH_LEAVE					0x00000002
#define NLG_LONGJMPEX					0x00000003
#define NLG_CATCH_ENTER					0x00000100
#define NLG_FINALLY_ENTER				0x00000101
#define NLG_FILTER_ENTER				0x00000102
#define NLG_DESTRUCTOR_ENTER			0x00000103
#define NLG_GLOBAL_CONSTRUCTOR_ENTER	0x00000104
#define NLG_GLOBAL_DESTRUCTOR_ENTER		0x00000105
#define NLG_DLL_ENTRY                   0x00000106
#define NLG_DLL_EXIT                    0x00000107
#define NLG_COM_PLUS_THUNK				0x00000108

#define NLG_SIG							0x19930520

typedef enum _NLG_LOCATION {
    NLG_DISPATCH,
    NLG_RETURN
} NLG_LOCATION, FAR * LPNLG_LOCATION;

#define hnlgNull    ((HNLG)NULL)

INT FAR PASCAL NLGComp (LPNLG, LPVOID, LONG);

VOID
ActionNLGDispatch(
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    );

VOID
ActionNLGDestination   (
    DEBUG_EVENT* de,
    HTHDX hthd,
    DWORD unused,
    LPVOID lpv
    );

HNLG CheckNLG ( HPRCX, HTHDX, NLG_LOCATION, LPADDR );
BOOL SetupNLG ( HTHDX, LPADDR );
DWORD GetSPFromNLGDest(HTHDX, LPNLG_DESTINATION);

void ProcessNonLocalGoto( HPRCX, HTHDX, LPDBB );

typedef enum _NFI {
    nfiHEMI,
} NFI; // NonLocalGoto Find Information
typedef NFI FAR * LPNFI;


#ifdef OMNI

//
//  Omni JIT support
//

VOID
ProcessOmniDllLoadEvent(
	DEBUG_EVENT*	event,
	HTHDX			hthd
	);

#endif

BOOL
CreateTimerEventQueue(
	TIMER_EVENT_QUEUE*	queue
	);

BOOL
DeleteTimerEventQueue(
	TIMER_EVENT_QUEUE*	queue
	);

HANDLE
CreateTimerEvent(
	HPRCX					hprc,
	TIMER_EVENT_CALLBACK	callback,
	LPVOID					param,
	DWORD					ticks,
	BOOL					fQueueEvent
	);

BOOL
EnqueueTimerEvent(
	HPRCX	hprc,
	HANDLE	hEvent
	);

BOOL
RemoveTimerEvent(
	HPRCX	hprc,
	HANDLE	hTimerEvent
	);

BOOL
FireOutstandingTimerEvents(
	HPRCX	hprc
	);

#endif // !KERNEL



enum {
	FLAG_ALREADY_SET,
	FLAG_SET,
	FLAG_ALREADY_CLEARED,
	FLAG_CLEARED
};


DWORD
InterlockedSetFlag(
	LONG*	lpFlag
	);


DWORD
InterlockedClearFlag(
	LONG*	lpFlag
	);

#ifdef REGSYNC
void EnsureHthdReg(HTHDX, DWORD);
#define HthdReg(hthd, reg) (*(EnsureHthdReg(hthd, _ctx_##reg), &hthd->ctx.reg))
#define _ctx_Eax CONTEXT_INTEGER
#define _ctx_Ebx CONTEXT_INTEGER
#define _ctx_Ecx CONTEXT_INTEGER
#define _ctx_Edx CONTEXT_INTEGER
#define _ctx_Esi CONTEXT_INTEGER
#define _ctx_Edi CONTEXT_INTEGER
#define _ctx_Esp CONTEXT_CONTROL
#define _ctx_Ebp CONTEXT_CONTROL
#define _ctx_Eip CONTEXT_CONTROL
#define _ctx_SegCs CONTEXT_CONTROL
#define _ctx_SegSs CONTEXT_CONTROL
#define _ctx_EFlags CONTEXT_CONTROL
#else
#define HthdReg(hthd, reg) ((hthd)->ctx.reg)
#define EnsureHthdReg(hthd, dw)
#endif

char XboxAssert(PDMN_DEBUGSTR);
void XboxRip(LPCSTR);

BOOL
UnpackLoadCmd(
    CONST LPVOID lpv,
    LPPRL lpprl
    );

#ifdef KERNEL

/*
**  Kernel Debugger Specific Functions
*/

BOOL  MyFindExecutable( PCHAR PathName, PCHAR OutputBuffer );
BOOLEAN DmKdConnectAndInitialize( LPSTR lpProgName );
VOID  QueueActionEvent( HTHDX hthd, DWORD dwAction, LPVOID lpv, DWORD dwLength );
VOID  ReloadModulesWorker( ULONG ListHead, LPSTR lpModules, DWORD dwLength );

BOOL
WriteBreakPointEx(
    IN HTHDX hthd,
    IN ULONG BreakPointCount,
    IN OUT PDBGKD_WRITE_BREAKPOINT BreakPoints,
    IN ULONG ContinueStatus
    );

BOOL
RestoreBreakPointEx(
    IN ULONG BreakPointCount,
    IN PDBGKD_RESTORE_BREAKPOINT BreakPointHandles
    );


VOID  ContinueTargetSystem(DWORD ContinueStatus, PDBGKD_CONTROL_SET ControlSet);
VOID  RestoreKernelBreakpoints(HTHDX hthd, UOFF32 Offset);
BOOL  ReadControlSpace(USHORT Processor, PVOID TargetBaseAddress, PVOID UserInterfaceBuffer, ULONG TransferCount, PULONG ActualBytesRead);

#if defined(HAS_DEBUG_REGS)
BOOL  GetExtendedContext(HTHDX hthd, PKSPECIAL_REGISTERS pksr);
BOOL  SetExtendedContext(H